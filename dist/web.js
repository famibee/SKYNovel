var th = (n, t, e) => {
  if (!t.has(n))
    throw TypeError("Cannot " + e);
};
var H = (n, t, e) => (th(n, t, "read from private field"), e ? e.call(n) : t.get(n)), it = (n, t, e) => {
  if (t.has(n))
    throw TypeError("Cannot add the same private member more than once");
  t instanceof WeakSet ? t.add(n) : t.set(n, e);
}, et = (n, t, e, o) => (th(n, t, "write to private field"), o ? o.call(n, e) : t.set(n, e), e), Re = (n, t, e, o) => ({
  set _(R) {
    et(n, t, R, e);
  },
  get _() {
    return H(n, t, o);
  }
}), st = (n, t, e) => (th(n, t, "access private method"), e);
var commonjsGlobal$1 = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {}, platform$1 = { exports: {} };
/*!
 * Platform.js v1.3.6
 * Copyright 2014-2020 Benjamin Tan
 * Copyright 2011-2013 John-David Dalton
 * Available under MIT license
 */
(function(n, t) {
  (function() {
    var e = {
      function: !0,
      object: !0
    }, o = e[typeof window] && window || this, R = t, N = n && !n.nodeType && n, M = R && N && typeof commonjsGlobal$1 == "object" && commonjsGlobal$1;
    M && (M.global === M || M.window === M || M.self === M) && (o = M);
    var D = Math.pow(2, 53) - 1, L = /\bOpera/, B = Object.prototype, $ = B.hasOwnProperty, k = B.toString;
    function U(tt) {
      return tt = String(tt), tt.charAt(0).toUpperCase() + tt.slice(1);
    }
    function z(tt, nt, at) {
      var lt = {
        "10.0": "10",
        "6.4": "10 Technical Preview",
        "6.3": "8.1",
        "6.2": "8",
        "6.1": "Server 2008 R2 / 7",
        "6.0": "Server 2008 / Vista",
        "5.2": "Server 2003 / XP 64-bit",
        "5.1": "XP",
        "5.01": "2000 SP1",
        "5.0": "2000",
        "4.0": "NT",
        "4.90": "ME"
      };
      return nt && at && /^Win/i.test(tt) && !/^Windows Phone /i.test(tt) && (lt = lt[/[\d.]+$/.exec(tt)]) && (tt = "Windows " + lt), tt = String(tt), nt && at && (tt = tt.replace(RegExp(nt, "i"), at)), tt = V(
        tt.replace(/ ce$/i, " CE").replace(/\bhpw/i, "web").replace(/\bMacintosh\b/, "Mac OS").replace(/_PowerPC\b/i, " OS").replace(/\b(OS X) [^ \d]+/i, "$1").replace(/\bMac (OS X)\b/, "$1").replace(/\/(\d)/, " $1").replace(/_/g, ".").replace(/(?: BePC|[ .]*fc[ \d.]+)$/i, "").replace(/\bx86\.64\b/gi, "x86_64").replace(/\b(Windows Phone) OS\b/, "$1").replace(/\b(Chrome OS \w+) [\d.]+\b/, "$1").split(" on ")[0]
      ), tt;
    }
    function X(tt, nt) {
      var at = -1, lt = tt ? tt.length : 0;
      if (typeof lt == "number" && lt > -1 && lt <= D)
        for (; ++at < lt; )
          nt(tt[at], at, tt);
      else
        W(tt, nt);
    }
    function V(tt) {
      return tt = Q(tt), /^(?:webOS|i(?:OS|P))/.test(tt) ? tt : U(tt);
    }
    function W(tt, nt) {
      for (var at in tt)
        $.call(tt, at) && nt(tt[at], at, tt);
    }
    function Y(tt) {
      return tt == null ? U(tt) : k.call(tt).slice(8, -1);
    }
    function q(tt, nt) {
      var at = tt != null ? typeof tt[nt] : "number";
      return !/^(?:boolean|number|string|undefined)$/.test(at) && (at == "object" ? !!tt[nt] : !0);
    }
    function Z(tt) {
      return String(tt).replace(/([ -])(?!$)/g, "$1?");
    }
    function J(tt, nt) {
      var at = null;
      return X(tt, function(lt, ut) {
        at = nt(at, lt, ut, tt);
      }), at;
    }
    function Q(tt) {
      return String(tt).replace(/^ +| +$/g, "");
    }
    function K(tt) {
      var nt = o, at = tt && typeof tt == "object" && Y(tt) != "String";
      at && (nt = tt, tt = null);
      var lt = nt.navigator || {}, ut = lt.userAgent || "";
      tt || (tt = ut);
      var dt = at ? !!lt.likeChrome : /\bChrome\b/.test(tt) && !/internal|\n/i.test(k.toString()), yt = "Object", pt = at ? yt : "ScriptBridgingProxyObject", gt = at ? yt : "Environment", xt = at && nt.java ? "JavaPackage" : Y(nt.java), Lt = at ? yt : "RuntimeObject", mt = /\bJava/.test(xt) && nt.java, ct = mt && Y(nt.environment) == gt, vt = mt ? "a" : "\u03B1", Tt = mt ? "b" : "\u03B2", Pt = nt.document || {}, wt = nt.operamini || nt.opera, Mt = L.test(Mt = at && wt ? wt["[[Class]]"] : Y(wt)) ? Mt : wt = null, ht, $t = tt, At = [], kt = null, Ot = tt == ut, _t = Ot && wt && typeof wt.version == "function" && wt.version(), Gt, St = Zt([
        { label: "EdgeHTML", pattern: "Edge" },
        "Trident",
        { label: "WebKit", pattern: "AppleWebKit" },
        "iCab",
        "Presto",
        "NetFront",
        "Tasman",
        "KHTML",
        "Gecko"
      ]), Et = se([
        "Adobe AIR",
        "Arora",
        "Avant Browser",
        "Breach",
        "Camino",
        "Electron",
        "Epiphany",
        "Fennec",
        "Flock",
        "Galeon",
        "GreenBrowser",
        "iCab",
        "Iceweasel",
        "K-Meleon",
        "Konqueror",
        "Lunascape",
        "Maxthon",
        { label: "Microsoft Edge", pattern: "(?:Edge|Edg|EdgA|EdgiOS)" },
        "Midori",
        "Nook Browser",
        "PaleMoon",
        "PhantomJS",
        "Raven",
        "Rekonq",
        "RockMelt",
        { label: "Samsung Internet", pattern: "SamsungBrowser" },
        "SeaMonkey",
        { label: "Silk", pattern: "(?:Cloud9|Silk-Accelerated)" },
        "Sleipnir",
        "SlimBrowser",
        { label: "SRWare Iron", pattern: "Iron" },
        "Sunrise",
        "Swiftfox",
        "Vivaldi",
        "Waterfox",
        "WebPositive",
        { label: "Yandex Browser", pattern: "YaBrowser" },
        { label: "UC Browser", pattern: "UCBrowser" },
        "Opera Mini",
        { label: "Opera Mini", pattern: "OPiOS" },
        "Opera",
        { label: "Opera", pattern: "OPR" },
        "Chromium",
        "Chrome",
        { label: "Chrome", pattern: "(?:HeadlessChrome)" },
        { label: "Chrome Mobile", pattern: "(?:CriOS|CrMo)" },
        { label: "Firefox", pattern: "(?:Firefox|Minefield)" },
        { label: "Firefox for iOS", pattern: "FxiOS" },
        { label: "IE", pattern: "IEMobile" },
        { label: "IE", pattern: "MSIE" },
        "Safari"
      ]), Rt = Oe([
        { label: "BlackBerry", pattern: "BB10" },
        "BlackBerry",
        { label: "Galaxy S", pattern: "GT-I9000" },
        { label: "Galaxy S2", pattern: "GT-I9100" },
        { label: "Galaxy S3", pattern: "GT-I9300" },
        { label: "Galaxy S4", pattern: "GT-I9500" },
        { label: "Galaxy S5", pattern: "SM-G900" },
        { label: "Galaxy S6", pattern: "SM-G920" },
        { label: "Galaxy S6 Edge", pattern: "SM-G925" },
        { label: "Galaxy S7", pattern: "SM-G930" },
        { label: "Galaxy S7 Edge", pattern: "SM-G935" },
        "Google TV",
        "Lumia",
        "iPad",
        "iPod",
        "iPhone",
        "Kindle",
        { label: "Kindle Fire", pattern: "(?:Cloud9|Silk-Accelerated)" },
        "Nexus",
        "Nook",
        "PlayBook",
        "PlayStation Vita",
        "PlayStation",
        "TouchPad",
        "Transformer",
        { label: "Wii U", pattern: "WiiU" },
        "Wii",
        "Xbox One",
        { label: "Xbox 360", pattern: "Xbox" },
        "Xoom"
      ]), Dt = Yt({
        Apple: { iPad: 1, iPhone: 1, iPod: 1 },
        Alcatel: {},
        Archos: {},
        Amazon: { Kindle: 1, "Kindle Fire": 1 },
        Asus: { Transformer: 1 },
        "Barnes & Noble": { Nook: 1 },
        BlackBerry: { PlayBook: 1 },
        Google: { "Google TV": 1, Nexus: 1 },
        HP: { TouchPad: 1 },
        HTC: {},
        Huawei: {},
        Lenovo: {},
        LG: {},
        Microsoft: { Xbox: 1, "Xbox One": 1 },
        Motorola: { Xoom: 1 },
        Nintendo: { "Wii U": 1, Wii: 1 },
        Nokia: { Lumia: 1 },
        Oppo: {},
        Samsung: { "Galaxy S": 1, "Galaxy S2": 1, "Galaxy S3": 1, "Galaxy S4": 1 },
        Sony: { PlayStation: 1, "PlayStation Vita": 1 },
        Xiaomi: { Mi: 1, Redmi: 1 }
      }), Ct = xe([
        "Windows Phone",
        "KaiOS",
        "Android",
        "CentOS",
        { label: "Chrome OS", pattern: "CrOS" },
        "Debian",
        { label: "DragonFly BSD", pattern: "DragonFly" },
        "Fedora",
        "FreeBSD",
        "Gentoo",
        "Haiku",
        "Kubuntu",
        "Linux Mint",
        "OpenBSD",
        "Red Hat",
        "SuSE",
        "Ubuntu",
        "Xubuntu",
        "Cygwin",
        "Symbian OS",
        "hpwOS",
        "webOS ",
        "webOS",
        "Tablet OS",
        "Tizen",
        "Linux",
        "Mac OS X",
        "Macintosh",
        "Mac",
        "Windows 98;",
        "Windows "
      ]);
      function Zt(ue) {
        return J(ue, function(ae, Jt) {
          return ae || RegExp("\\b" + (Jt.pattern || Z(Jt)) + "\\b", "i").exec(tt) && (Jt.label || Jt);
        });
      }
      function Yt(ue) {
        return J(ue, function(ae, Jt, Pe) {
          return ae || (Jt[Rt] || Jt[/^[a-z]+(?: +[a-z]+\b)*/i.exec(Rt)] || RegExp("\\b" + Z(Pe) + "(?:\\b|\\w*\\d)", "i").exec(tt)) && Pe;
        });
      }
      function se(ue) {
        return J(ue, function(ae, Jt) {
          return ae || RegExp("\\b" + (Jt.pattern || Z(Jt)) + "\\b", "i").exec(tt) && (Jt.label || Jt);
        });
      }
      function xe(ue) {
        return J(ue, function(ae, Jt) {
          var Pe = Jt.pattern || Z(Jt);
          return !ae && (ae = RegExp("\\b" + Pe + "(?:/[\\d.]+|[ \\w.]*)", "i").exec(tt)) && (ae = z(ae, Pe, Jt.label || Jt)), ae;
        });
      }
      function Oe(ue) {
        return J(ue, function(ae, Jt) {
          var Pe = Jt.pattern || Z(Jt);
          return !ae && (ae = RegExp("\\b" + Pe + " *\\d+[.\\w_]*", "i").exec(tt) || RegExp("\\b" + Pe + " *\\w+-[\\w]*", "i").exec(tt) || RegExp("\\b" + Pe + "(?:; *(?:[a-z]+[_-])?[a-z]+\\d+|[^ ();-]*)", "i").exec(tt)) && ((ae = String(Jt.label && !RegExp(Pe, "i").test(Jt.label) ? Jt.label : ae).split("/"))[1] && !/[\d.]+/.test(ae[0]) && (ae[0] += " " + ae[1]), Jt = Jt.label || Jt, ae = V(ae[0].replace(RegExp(Pe, "i"), Jt).replace(RegExp("; *(?:" + Jt + "[_-])?", "i"), " ").replace(RegExp("(" + Jt + ")[-_.]?(\\w)", "i"), "$1 $2"))), ae;
        });
      }
      function Qt(ue) {
        return J(ue, function(ae, Jt) {
          return ae || (RegExp(Jt + "(?:-[\\d.]+/|(?: for [\\w-]+)?[ /-])([\\d.]+[^ ();/_-]*)", "i").exec(tt) || 0)[1] || null;
        });
      }
      function Ie() {
        return this.description || "";
      }
      if (St && (St = [St]), /\bAndroid\b/.test(Ct) && !Rt && (ht = /\bAndroid[^;]*;(.*?)(?:Build|\) AppleWebKit)\b/i.exec(tt)) && (Rt = Q(ht[1]).replace(/^[a-z]{2}-[a-z]{2};\s*/i, "") || null), Dt && !Rt ? Rt = Oe([Dt]) : Dt && Rt && (Rt = Rt.replace(RegExp("^(" + Z(Dt) + ")[-_.\\s]", "i"), Dt + " ").replace(RegExp("^(" + Z(Dt) + ")[-_.]?(\\w)", "i"), Dt + " $2")), (ht = /\bGoogle TV\b/.exec(Rt)) && (Rt = ht[0]), /\bSimulator\b/i.test(tt) && (Rt = (Rt ? Rt + " " : "") + "Simulator"), Et == "Opera Mini" && /\bOPiOS\b/.test(tt) && At.push("running in Turbo/Uncompressed mode"), Et == "IE" && /\blike iPhone OS\b/.test(tt) ? (ht = K(tt.replace(/like iPhone OS/, "")), Dt = ht.manufacturer, Rt = ht.product) : /^iP/.test(Rt) ? (Et || (Et = "Safari"), Ct = "iOS" + ((ht = / OS ([\d_]+)/i.exec(tt)) ? " " + ht[1].replace(/_/g, ".") : "")) : Et == "Konqueror" && /^Linux\b/i.test(Ct) ? Ct = "Kubuntu" : Dt && Dt != "Google" && (/Chrome/.test(Et) && !/\bMobile Safari\b/i.test(tt) || /\bVita\b/.test(Rt)) || /\bAndroid\b/.test(Ct) && /^Chrome/.test(Et) && /\bVersion\//i.test(tt) ? (Et = "Android Browser", Ct = /\bAndroid\b/.test(Ct) ? Ct : "Android") : Et == "Silk" ? (/\bMobi/i.test(tt) || (Ct = "Android", At.unshift("desktop mode")), /Accelerated *= *true/i.test(tt) && At.unshift("accelerated")) : Et == "UC Browser" && /\bUCWEB\b/.test(tt) ? At.push("speed mode") : Et == "PaleMoon" && (ht = /\bFirefox\/([\d.]+)\b/.exec(tt)) ? At.push("identifying as Firefox " + ht[1]) : Et == "Firefox" && (ht = /\b(Mobile|Tablet|TV)\b/i.exec(tt)) ? (Ct || (Ct = "Firefox OS"), Rt || (Rt = ht[1])) : !Et || (ht = !/\bMinefield\b/i.test(tt) && /\b(?:Firefox|Safari)\b/.exec(Et)) ? (Et && !Rt && /[\/,]|^[^(]+?\)/.test(tt.slice(tt.indexOf(ht + "/") + 8)) && (Et = null), (ht = Rt || Dt || Ct) && (Rt || Dt || /\b(?:Android|Symbian OS|Tablet OS|webOS)\b/.test(Ct)) && (Et = /[a-z]+(?: Hat)?/i.exec(/\bAndroid\b/.test(Ct) ? Ct : ht) + " Browser")) : Et == "Electron" && (ht = (/\bChrome\/([\d.]+)\b/.exec(tt) || 0)[1]) && At.push("Chromium " + ht), _t || (_t = Qt([
        "(?:Cloud9|CriOS|CrMo|Edge|Edg|EdgA|EdgiOS|FxiOS|HeadlessChrome|IEMobile|Iron|Opera ?Mini|OPiOS|OPR|Raven|SamsungBrowser|Silk(?!/[\\d.]+$)|UCBrowser|YaBrowser)",
        "Version",
        Z(Et),
        "(?:Firefox|Minefield|NetFront)"
      ])), (ht = St == "iCab" && parseFloat(_t) > 3 && "WebKit" || /\bOpera\b/.test(Et) && (/\bOPR\b/.test(tt) ? "Blink" : "Presto") || /\b(?:Midori|Nook|Safari)\b/i.test(tt) && !/^(?:Trident|EdgeHTML)$/.test(St) && "WebKit" || !St && /\bMSIE\b/i.test(tt) && (Ct == "Mac OS" ? "Tasman" : "Trident") || St == "WebKit" && /\bPlayStation\b(?! Vita\b)/i.test(Et) && "NetFront") && (St = [ht]), Et == "IE" && (ht = (/; *(?:XBLWP|ZuneWP)(\d+)/i.exec(tt) || 0)[1]) ? (Et += " Mobile", Ct = "Windows Phone " + (/\+$/.test(ht) ? ht : ht + ".x"), At.unshift("desktop mode")) : /\bWPDesktop\b/i.test(tt) ? (Et = "IE Mobile", Ct = "Windows Phone 8.x", At.unshift("desktop mode"), _t || (_t = (/\brv:([\d.]+)/.exec(tt) || 0)[1])) : Et != "IE" && St == "Trident" && (ht = /\brv:([\d.]+)/.exec(tt)) && (Et && At.push("identifying as " + Et + (_t ? " " + _t : "")), Et = "IE", _t = ht[1]), Ot) {
        if (q(nt, "global"))
          if (mt && (ht = mt.lang.System, $t = ht.getProperty("os.arch"), Ct = Ct || ht.getProperty("os.name") + " " + ht.getProperty("os.version")), ct) {
            try {
              _t = nt.require("ringo/engine").version.join("."), Et = "RingoJS";
            } catch {
              (ht = nt.system) && ht.global.system == nt.system && (Et = "Narwhal", Ct || (Ct = ht[0].os || null));
            }
            Et || (Et = "Rhino");
          } else
            typeof nt.process == "object" && !nt.process.browser && (ht = nt.process) && (typeof ht.versions == "object" && (typeof ht.versions.electron == "string" ? (At.push("Node " + ht.versions.node), Et = "Electron", _t = ht.versions.electron) : typeof ht.versions.nw == "string" && (At.push("Chromium " + _t, "Node " + ht.versions.node), Et = "NW.js", _t = ht.versions.nw)), Et || (Et = "Node.js", $t = ht.arch, Ct = ht.platform, _t = /[\d.]+/.exec(ht.version), _t = _t ? _t[0] : null));
        else
          Y(ht = nt.runtime) == pt ? (Et = "Adobe AIR", Ct = ht.flash.system.Capabilities.os) : Y(ht = nt.phantom) == Lt ? (Et = "PhantomJS", _t = (ht = ht.version || null) && ht.major + "." + ht.minor + "." + ht.patch) : typeof Pt.documentMode == "number" && (ht = /\bTrident\/(\d+)/i.exec(tt)) ? (_t = [_t, Pt.documentMode], (ht = +ht[1] + 4) != _t[1] && (At.push("IE " + _t[1] + " mode"), St && (St[1] = ""), _t[1] = ht), _t = Et == "IE" ? String(_t[1].toFixed(1)) : _t[0]) : typeof Pt.documentMode == "number" && /^(?:Chrome|Firefox)\b/.test(Et) && (At.push("masking as " + Et + " " + _t), Et = "IE", _t = "11.0", St = ["Trident"], Ct = "Windows");
        Ct = Ct && V(Ct);
      }
      if (_t && (ht = /(?:[ab]|dp|pre|[ab]\d+pre)(?:\d+\+?)?$/i.exec(_t) || /(?:alpha|beta)(?: ?\d)?/i.exec(tt + ";" + (Ot && lt.appMinorVersion)) || /\bMinefield\b/i.test(tt) && "a") && (kt = /b/i.test(ht) ? "beta" : "alpha", _t = _t.replace(RegExp(ht + "\\+?$"), "") + (kt == "beta" ? Tt : vt) + (/\d+\+?/.exec(ht) || "")), Et == "Fennec" || Et == "Firefox" && /\b(?:Android|Firefox OS|KaiOS)\b/.test(Ct))
        Et = "Firefox Mobile";
      else if (Et == "Maxthon" && _t)
        _t = _t.replace(/\.[\d.]+/, ".x");
      else if (/\bXbox\b/i.test(Rt))
        Rt == "Xbox 360" && (Ct = null), Rt == "Xbox 360" && /\bIEMobile\b/.test(tt) && At.unshift("mobile mode");
      else if ((/^(?:Chrome|IE|Opera)$/.test(Et) || Et && !Rt && !/Browser|Mobi/.test(Et)) && (Ct == "Windows CE" || /Mobi/i.test(tt)))
        Et += " Mobile";
      else if (Et == "IE" && Ot)
        try {
          nt.external === null && At.unshift("platform preview");
        } catch {
          At.unshift("embedded");
        }
      else
        (/\bBlackBerry\b/.test(Rt) || /\bBB10\b/.test(tt)) && (ht = (RegExp(Rt.replace(/ +/g, " *") + "/([.\\d]+)", "i").exec(tt) || 0)[1] || _t) ? (ht = [ht, /BB10/.test(tt)], Ct = (ht[1] ? (Rt = null, Dt = "BlackBerry") : "Device Software") + " " + ht[0], _t = null) : this != W && Rt != "Wii" && (Ot && wt || /Opera/.test(Et) && /\b(?:MSIE|Firefox)\b/i.test(tt) || Et == "Firefox" && /\bOS X (?:\d+\.){2,}/.test(Ct) || Et == "IE" && (Ct && !/^Win/.test(Ct) && _t > 5.5 || /\bWindows XP\b/.test(Ct) && _t > 8 || _t == 8 && !/\bTrident\b/.test(tt))) && !L.test(ht = K.call(W, tt.replace(L, "") + ";")) && ht.name && (ht = "ing as " + ht.name + ((ht = ht.version) ? " " + ht : ""), L.test(Et) ? (/\bIE\b/.test(ht) && Ct == "Mac OS" && (Ct = null), ht = "identify" + ht) : (ht = "mask" + ht, Mt ? Et = V(Mt.replace(/([a-z])([A-Z])/g, "$1 $2")) : Et = "Opera", /\bIE\b/.test(ht) && (Ct = null), Ot || (_t = null)), St = ["Presto"], At.push(ht));
      (ht = (/\bAppleWebKit\/([\d.]+\+?)/i.exec(tt) || 0)[1]) && (ht = [parseFloat(ht.replace(/\.(\d)$/, ".0$1")), ht], Et == "Safari" && ht[1].slice(-1) == "+" ? (Et = "WebKit Nightly", kt = "alpha", _t = ht[1].slice(0, -1)) : (_t == ht[1] || _t == (ht[2] = (/\bSafari\/([\d.]+\+?)/i.exec(tt) || 0)[1])) && (_t = null), ht[1] = (/\b(?:Headless)?Chrome\/([\d.]+)/i.exec(tt) || 0)[1], ht[0] == 537.36 && ht[2] == 537.36 && parseFloat(ht[1]) >= 28 && St == "WebKit" && (St = ["Blink"]), !Ot || !dt && !ht[1] ? (St && (St[1] = "like Safari"), ht = (ht = ht[0], ht < 400 ? 1 : ht < 500 ? 2 : ht < 526 ? 3 : ht < 533 ? 4 : ht < 534 ? "4+" : ht < 535 ? 5 : ht < 537 ? 6 : ht < 538 ? 7 : ht < 601 ? 8 : ht < 602 ? 9 : ht < 604 ? 10 : ht < 606 ? 11 : ht < 608 ? 12 : "12")) : (St && (St[1] = "like Chrome"), ht = ht[1] || (ht = ht[0], ht < 530 ? 1 : ht < 532 ? 2 : ht < 532.05 ? 3 : ht < 533 ? 4 : ht < 534.03 ? 5 : ht < 534.07 ? 6 : ht < 534.1 ? 7 : ht < 534.13 ? 8 : ht < 534.16 ? 9 : ht < 534.24 ? 10 : ht < 534.3 ? 11 : ht < 535.01 ? 12 : ht < 535.02 ? "13+" : ht < 535.07 ? 15 : ht < 535.11 ? 16 : ht < 535.19 ? 17 : ht < 536.05 ? 18 : ht < 536.1 ? 19 : ht < 537.01 ? 20 : ht < 537.11 ? "21+" : ht < 537.13 ? 23 : ht < 537.18 ? 24 : ht < 537.24 ? 25 : ht < 537.36 ? 26 : St != "Blink" ? "27" : "28")), St && (St[1] += " " + (ht += typeof ht == "number" ? ".x" : /[.+]/.test(ht) ? "" : "+")), Et == "Safari" && (!_t || parseInt(_t) > 45) ? _t = ht : Et == "Chrome" && /\bHeadlessChrome/i.test(tt) && At.unshift("headless")), Et == "Opera" && (ht = /\bzbov|zvav$/.exec(Ct)) ? (Et += " ", At.unshift("desktop mode"), ht == "zvav" ? (Et += "Mini", _t = null) : Et += "Mobile", Ct = Ct.replace(RegExp(" *" + ht + "$"), "")) : Et == "Safari" && /\bChrome\b/.exec(St && St[1]) ? (At.unshift("desktop mode"), Et = "Chrome Mobile", _t = null, /\bOS X\b/.test(Ct) ? (Dt = "Apple", Ct = "iOS 4.3+") : Ct = null) : /\bSRWare Iron\b/.test(Et) && !_t && (_t = Qt("Chrome")), _t && _t.indexOf(ht = /[\d.]+$/.exec(Ct)) == 0 && tt.indexOf("/" + ht + "-") > -1 && (Ct = Q(Ct.replace(ht, ""))), Ct && Ct.indexOf(Et) != -1 && !RegExp(Et + " OS").test(Ct) && (Ct = Ct.replace(RegExp(" *" + Z(Et) + " *"), "")), St && !/\b(?:Avant|Nook)\b/.test(Et) && (/Browser|Lunascape|Maxthon/.test(Et) || Et != "Safari" && /^iOS/.test(Ct) && /\bSafari\b/.test(St[1]) || /^(?:Adobe|Arora|Breach|Midori|Opera|Phantom|Rekonq|Rock|Samsung Internet|Sleipnir|SRWare Iron|Vivaldi|Web)/.test(Et) && St[1]) && (ht = St[St.length - 1]) && At.push(ht), At.length && (At = ["(" + At.join("; ") + ")"]), Dt && Rt && Rt.indexOf(Dt) < 0 && At.push("on " + Dt), Rt && At.push((/^on /.test(At[At.length - 1]) ? "" : "on ") + Rt), Ct && (ht = / ([\d.+]+)$/.exec(Ct), Gt = ht && Ct.charAt(Ct.length - ht[0].length - 1) == "/", Ct = {
        architecture: 32,
        family: ht && !Gt ? Ct.replace(ht[0], "") : Ct,
        version: ht ? ht[1] : null,
        toString: function() {
          var ue = this.version;
          return this.family + (ue && !Gt ? " " + ue : "") + (this.architecture == 64 ? " 64-bit" : "");
        }
      }), (ht = /\b(?:AMD|IA|Win|WOW|x86_|x)64\b/i.exec($t)) && !/\bi686\b/i.test($t) ? (Ct && (Ct.architecture = 64, Ct.family = Ct.family.replace(RegExp(" *" + ht), "")), Et && (/\bWOW64\b/i.test(tt) || Ot && /\w(?:86|32)$/.test(lt.cpuClass || lt.platform) && !/\bWin64; x64\b/i.test(tt)) && At.unshift("32-bit")) : Ct && /^OS X/.test(Ct.family) && Et == "Chrome" && parseFloat(_t) >= 39 && (Ct.architecture = 64), tt || (tt = null);
      var de = {};
      return de.description = tt, de.layout = St && St[0], de.manufacturer = Dt, de.name = Et, de.prerelease = kt, de.product = Rt, de.ua = tt, de.version = Et && _t, de.os = Ct || {
        architecture: null,
        family: null,
        version: null,
        toString: function() {
          return "null";
        }
      }, de.parse = K, de.toString = Ie, de.version && At.unshift(_t), de.name && At.unshift(Et), Ct && Et && !(Ct == String(Ct).split(" ")[0] && (Ct == Et.split(" ")[0] || Rt)) && At.push(Rt ? "(" + Ct + ")" : "on " + Ct), At.length && (de.description = At.join(" ")), de;
    }
    var rt = K();
    R && N ? W(rt, function(tt, nt) {
      R[nt] = tt;
    }) : o.platform = rt;
  }).call(commonjsGlobal$1);
})(platform$1, platform$1.exports);
const platform = platform$1.exports;
function int(n) {
  return parseInt(String(n), 10);
}
function uint(n) {
  const t = parseInt(String(n), 10);
  return t < 0 ? -t : t;
}
"toInt" in String.prototype || (String.prototype.toInt = function() {
  return int(this);
});
"toUint" in String.prototype || (String.prototype.toUint = function() {
  const n = int(this);
  return n < 0 ? -n : n;
});
function getDateStr(n = "/", t = " ", e = ":", o = "") {
  const R = new Date();
  return R.getFullYear() + n + String(100 + R.getMonth() + 1).slice(1, 3) + n + String(100 + R.getDate()).slice(1, 3) + t + String(100 + R.getHours()).slice(1, 3) + e + String(100 + R.getMinutes()).slice(1, 3) + (o === "" ? "" : o + String(R.getMilliseconds()));
}
const hMemberCnt = {
  alpha: 0,
  height: 0,
  rotation: 0,
  scale_x: 0,
  scale_y: 0,
  pivot_x: 0,
  pivot_y: 0,
  width: 0,
  x: 0,
  y: 0
};
function cnvTweenArg(n, t) {
  const e = {};
  for (const o in hMemberCnt) {
    if (!(o in n))
      continue;
    const R = String(n[o]), N = (R.charAt(0) === "=" ? R.slice(1) : R).split(","), M = e[o] = parseFloat(N[0]);
    N.length > 1 && (e[o] += Math.round(Math.random() * (parseFloat(N[1]) - M + 1))), R.charAt(0) === "=" && (e[o] += parseFloat(t[o]));
  }
  return e;
}
const css_key4del = "/* SKYNovel */";
function initStyle() {
  const n = document.getElementsByTagName("head")[0], t = n.children.length;
  for (let e = t - 1; e >= 0; --e) {
    const o = n.children[e];
    o instanceof HTMLStyleElement && o.innerText.slice(0, 14) === css_key4del && n.removeChild(o);
  }
}
function addStyle(n) {
  const t = document.createElement("style");
  t.innerHTML = css_key4del + n, document.getElementsByTagName("head")[0].appendChild(t);
}
function argChk_Num(n, t, e) {
  const o = n[t];
  if (!(t in n)) {
    if (isNaN(e))
      throw `[${n[":\u30BF\u30B0\u540D"]}]\u5C5E\u6027 ${t} \u306F\u5FC5\u9808\u3067\u3059`;
    return n[t] = e, e;
  }
  const R = String(o).slice(0, 2) === "0x" ? parseInt(o) : parseFloat(o);
  if (isNaN(R))
    throw `[${n[":\u30BF\u30B0\u540D"]}]\u5C5E\u6027 ${t} \u306E\u5024\u3010${o}\u3011\u304C\u6570\u5024\u3067\u306F\u3042\u308A\u307E\u305B\u3093`;
  return n[t] = R;
}
function argChk_Boolean(n, t, e) {
  if (!(t in n))
    return n[t] = e;
  const o = n[t];
  if (o === null)
    return !1;
  const R = String(o);
  return n[t] = R === "false" ? !1 : Boolean(R);
}
function parseColor(n) {
  if (n.charAt(0) === "#")
    return parseInt(n.slice(1), 16);
  const t = Number(n);
  if (!isNaN(t))
    return t;
  if (n === "black")
    return 0;
  CmnLib.cc4ColorName.fillStyle = n;
  const e = CmnLib.cc4ColorName.fillStyle;
  if (e === "#000000")
    throw `\u8272\u540D\u524D ${n} \u304C\u7570\u5E38\u3067\u3059`;
  return parseInt(e.slice(1), 16);
}
function argChk_Color(n, t, e) {
  const o = n[t];
  return o ? n[t] = parseColor(String(o)) : n[t] = e;
}
const REG_ERRMES_JSON = /JSON at position (\d+)$/;
function mesErrJSON(n, t = "", e = "") {
  var R;
  const o = ((R = e.match(REG_ERRMES_JSON)) != null ? R : ["", ""])[1];
  return `[${n[":\u30BF\u30B0\u540D"]}] ${t} \u5C5E\u6027\u306E\u89E3\u6790\u30A8\u30E9\u30FC : ${e}
${n[t]}${o ? `
${"^".padStart(Number(o))}` : ""}`;
}
const REG_FN = /^[^\/\.]+$|[^\/]+(?=\.)/;
function getFn(n) {
  var t;
  return ((t = n.match(REG_FN)) != null ? t : [""])[0];
}
const REG_EXT = /\.([^\.]+)$/;
function getExt(n) {
  var t;
  return ((t = n.match(REG_EXT)) != null ? t : ["", ""])[1];
}
class CmnLib {
}
CmnLib.stageW = 0;
CmnLib.stageH = 0;
CmnLib.debugLog = !1;
CmnLib.isSafari = platform$1.exports.name === "Safari";
CmnLib.isFirefox = platform$1.exports.name === "Firefox";
var Bh, $h;
CmnLib.isMac = new RegExp("OS X").test(($h = (Bh = platform$1.exports.os) == null ? void 0 : Bh.family) != null ? $h : "");
var kh, Gh;
CmnLib.isMobile = !new RegExp("(Windows|OS X)").test((Gh = (kh = platform$1.exports.os) == null ? void 0 : kh.family) != null ? Gh : "");
CmnLib.hDip = {};
CmnLib.isDbg = !1;
CmnLib.isPackaged = !1;
CmnLib.isDarkMode = !1;
const PACKET_TYPES = /* @__PURE__ */ Object.create(null);
PACKET_TYPES.open = "0";
PACKET_TYPES.close = "1";
PACKET_TYPES.ping = "2";
PACKET_TYPES.pong = "3";
PACKET_TYPES.message = "4";
PACKET_TYPES.upgrade = "5";
PACKET_TYPES.noop = "6";
const PACKET_TYPES_REVERSE = /* @__PURE__ */ Object.create(null);
Object.keys(PACKET_TYPES).forEach((n) => {
  PACKET_TYPES_REVERSE[PACKET_TYPES[n]] = n;
});
const ERROR_PACKET = { type: "error", data: "parser error" }, withNativeBlob$1 = typeof Blob == "function" || typeof Blob < "u" && Object.prototype.toString.call(Blob) === "[object BlobConstructor]", withNativeArrayBuffer$2 = typeof ArrayBuffer == "function", isView$1 = (n) => typeof ArrayBuffer.isView == "function" ? ArrayBuffer.isView(n) : n && n.buffer instanceof ArrayBuffer, encodePacket = ({ type: n, data: t }, e, o) => withNativeBlob$1 && t instanceof Blob ? e ? o(t) : encodeBlobAsBase64(t, o) : withNativeArrayBuffer$2 && (t instanceof ArrayBuffer || isView$1(t)) ? e ? o(t) : encodeBlobAsBase64(new Blob([t]), o) : o(PACKET_TYPES[n] + (t || "")), encodeBlobAsBase64 = (n, t) => {
  const e = new FileReader();
  return e.onload = function() {
    const o = e.result.split(",")[1];
    t("b" + o);
  }, e.readAsDataURL(n);
}, chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", lookup$1 = typeof Uint8Array > "u" ? [] : new Uint8Array(256);
for (let n = 0; n < chars.length; n++)
  lookup$1[chars.charCodeAt(n)] = n;
const decode$3 = (n) => {
  let t = n.length * 0.75, e = n.length, o, R = 0, N, M, D, L;
  n[n.length - 1] === "=" && (t--, n[n.length - 2] === "=" && t--);
  const B = new ArrayBuffer(t), $ = new Uint8Array(B);
  for (o = 0; o < e; o += 4)
    N = lookup$1[n.charCodeAt(o)], M = lookup$1[n.charCodeAt(o + 1)], D = lookup$1[n.charCodeAt(o + 2)], L = lookup$1[n.charCodeAt(o + 3)], $[R++] = N << 2 | M >> 4, $[R++] = (M & 15) << 4 | D >> 2, $[R++] = (D & 3) << 6 | L & 63;
  return B;
}, withNativeArrayBuffer$1 = typeof ArrayBuffer == "function", decodePacket = (n, t) => {
  if (typeof n != "string")
    return {
      type: "message",
      data: mapBinary(n, t)
    };
  const e = n.charAt(0);
  return e === "b" ? {
    type: "message",
    data: decodeBase64Packet(n.substring(1), t)
  } : PACKET_TYPES_REVERSE[e] ? n.length > 1 ? {
    type: PACKET_TYPES_REVERSE[e],
    data: n.substring(1)
  } : {
    type: PACKET_TYPES_REVERSE[e]
  } : ERROR_PACKET;
}, decodeBase64Packet = (n, t) => {
  if (withNativeArrayBuffer$1) {
    const e = decode$3(n);
    return mapBinary(e, t);
  } else
    return { base64: !0, data: n };
}, mapBinary = (n, t) => {
  switch (t) {
    case "blob":
      return n instanceof ArrayBuffer ? new Blob([n]) : n;
    case "arraybuffer":
    default:
      return n;
  }
}, SEPARATOR = String.fromCharCode(30), encodePayload = (n, t) => {
  const e = n.length, o = new Array(e);
  let R = 0;
  n.forEach((N, M) => {
    encodePacket(N, !1, (D) => {
      o[M] = D, ++R === e && t(o.join(SEPARATOR));
    });
  });
}, decodePayload = (n, t) => {
  const e = n.split(SEPARATOR), o = [];
  for (let R = 0; R < e.length; R++) {
    const N = decodePacket(e[R], t);
    if (o.push(N), N.type === "error")
      break;
  }
  return o;
}, protocol$1 = 4;
function Emitter(n) {
  if (n)
    return mixin(n);
}
function mixin(n) {
  for (var t in Emitter.prototype)
    n[t] = Emitter.prototype[t];
  return n;
}
Emitter.prototype.on = Emitter.prototype.addEventListener = function(n, t) {
  return this._callbacks = this._callbacks || {}, (this._callbacks["$" + n] = this._callbacks["$" + n] || []).push(t), this;
};
Emitter.prototype.once = function(n, t) {
  function e() {
    this.off(n, e), t.apply(this, arguments);
  }
  return e.fn = t, this.on(n, e), this;
};
Emitter.prototype.off = Emitter.prototype.removeListener = Emitter.prototype.removeAllListeners = Emitter.prototype.removeEventListener = function(n, t) {
  if (this._callbacks = this._callbacks || {}, arguments.length == 0)
    return this._callbacks = {}, this;
  var e = this._callbacks["$" + n];
  if (!e)
    return this;
  if (arguments.length == 1)
    return delete this._callbacks["$" + n], this;
  for (var o, R = 0; R < e.length; R++)
    if (o = e[R], o === t || o.fn === t) {
      e.splice(R, 1);
      break;
    }
  return e.length === 0 && delete this._callbacks["$" + n], this;
};
Emitter.prototype.emit = function(n) {
  this._callbacks = this._callbacks || {};
  for (var t = new Array(arguments.length - 1), e = this._callbacks["$" + n], o = 1; o < arguments.length; o++)
    t[o - 1] = arguments[o];
  if (e) {
    e = e.slice(0);
    for (var o = 0, R = e.length; o < R; ++o)
      e[o].apply(this, t);
  }
  return this;
};
Emitter.prototype.emitReserved = Emitter.prototype.emit;
Emitter.prototype.listeners = function(n) {
  return this._callbacks = this._callbacks || {}, this._callbacks["$" + n] || [];
};
Emitter.prototype.hasListeners = function(n) {
  return !!this.listeners(n).length;
};
const globalThisShim = (() => typeof self < "u" ? self : typeof window < "u" ? window : Function("return this")())();
function pick(n, ...t) {
  return t.reduce((e, o) => (n.hasOwnProperty(o) && (e[o] = n[o]), e), {});
}
const NATIVE_SET_TIMEOUT = setTimeout, NATIVE_CLEAR_TIMEOUT = clearTimeout;
function installTimerFunctions(n, t) {
  t.useNativeTimers ? (n.setTimeoutFn = NATIVE_SET_TIMEOUT.bind(globalThisShim), n.clearTimeoutFn = NATIVE_CLEAR_TIMEOUT.bind(globalThisShim)) : (n.setTimeoutFn = setTimeout.bind(globalThisShim), n.clearTimeoutFn = clearTimeout.bind(globalThisShim));
}
const BASE64_OVERHEAD = 1.33;
function byteLength(n) {
  return typeof n == "string" ? utf8Length(n) : Math.ceil((n.byteLength || n.size) * BASE64_OVERHEAD);
}
function utf8Length(n) {
  let t = 0, e = 0;
  for (let o = 0, R = n.length; o < R; o++)
    t = n.charCodeAt(o), t < 128 ? e += 1 : t < 2048 ? e += 2 : t < 55296 || t >= 57344 ? e += 3 : (o++, e += 4);
  return e;
}
class TransportError extends Error {
  constructor(t, e, o) {
    super(t), this.description = e, this.context = o, this.type = "TransportError";
  }
}
class Transport extends Emitter {
  constructor(t) {
    super(), this.writable = !1, installTimerFunctions(this, t), this.opts = t, this.query = t.query, this.readyState = "", this.socket = t.socket;
  }
  onError(t, e, o) {
    return super.emitReserved("error", new TransportError(t, e, o)), this;
  }
  open() {
    return (this.readyState === "closed" || this.readyState === "") && (this.readyState = "opening", this.doOpen()), this;
  }
  close() {
    return (this.readyState === "opening" || this.readyState === "open") && (this.doClose(), this.onClose()), this;
  }
  send(t) {
    this.readyState === "open" && this.write(t);
  }
  onOpen() {
    this.readyState = "open", this.writable = !0, super.emitReserved("open");
  }
  onData(t) {
    const e = decodePacket(t, this.socket.binaryType);
    this.onPacket(e);
  }
  onPacket(t) {
    super.emitReserved("packet", t);
  }
  onClose(t) {
    this.readyState = "closed", super.emitReserved("close", t);
  }
}
const alphabet = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-_".split(""), length = 64, map$3 = {};
let seed = 0, i = 0, prev;
function encode$3(n) {
  let t = "";
  do
    t = alphabet[n % length] + t, n = Math.floor(n / length);
  while (n > 0);
  return t;
}
function yeast() {
  const n = encode$3(+new Date());
  return n !== prev ? (seed = 0, prev = n) : n + "." + encode$3(seed++);
}
for (; i < length; i++)
  map$3[alphabet[i]] = i;
function encode$2(n) {
  let t = "";
  for (let e in n)
    n.hasOwnProperty(e) && (t.length && (t += "&"), t += encodeURIComponent(e) + "=" + encodeURIComponent(n[e]));
  return t;
}
function decode$2(n) {
  let t = {}, e = n.split("&");
  for (let o = 0, R = e.length; o < R; o++) {
    let N = e[o].split("=");
    t[decodeURIComponent(N[0])] = decodeURIComponent(N[1]);
  }
  return t;
}
let value = !1;
try {
  value = typeof XMLHttpRequest < "u" && "withCredentials" in new XMLHttpRequest();
} catch {
}
const hasCORS = value;
function XHR(n) {
  const t = n.xdomain;
  try {
    if (typeof XMLHttpRequest < "u" && (!t || hasCORS))
      return new XMLHttpRequest();
  } catch {
  }
  if (!t)
    try {
      return new globalThisShim[["Active"].concat("Object").join("X")]("Microsoft.XMLHTTP");
    } catch {
    }
}
function empty() {
}
const hasXHR2 = function() {
  return new XHR({
    xdomain: !1
  }).responseType != null;
}();
class Polling extends Transport {
  constructor(t) {
    if (super(t), this.polling = !1, typeof location < "u") {
      const o = location.protocol === "https:";
      let R = location.port;
      R || (R = o ? "443" : "80"), this.xd = typeof location < "u" && t.hostname !== location.hostname || R !== t.port, this.xs = t.secure !== o;
    }
    const e = t && t.forceBase64;
    this.supportsBinary = hasXHR2 && !e;
  }
  get name() {
    return "polling";
  }
  doOpen() {
    this.poll();
  }
  pause(t) {
    this.readyState = "pausing";
    const e = () => {
      this.readyState = "paused", t();
    };
    if (this.polling || !this.writable) {
      let o = 0;
      this.polling && (o++, this.once("pollComplete", function() {
        --o || e();
      })), this.writable || (o++, this.once("drain", function() {
        --o || e();
      }));
    } else
      e();
  }
  poll() {
    this.polling = !0, this.doPoll(), this.emitReserved("poll");
  }
  onData(t) {
    const e = (o) => {
      if (this.readyState === "opening" && o.type === "open" && this.onOpen(), o.type === "close")
        return this.onClose({ description: "transport closed by the server" }), !1;
      this.onPacket(o);
    };
    decodePayload(t, this.socket.binaryType).forEach(e), this.readyState !== "closed" && (this.polling = !1, this.emitReserved("pollComplete"), this.readyState === "open" && this.poll());
  }
  doClose() {
    const t = () => {
      this.write([{ type: "close" }]);
    };
    this.readyState === "open" ? t() : this.once("open", t);
  }
  write(t) {
    this.writable = !1, encodePayload(t, (e) => {
      this.doWrite(e, () => {
        this.writable = !0, this.emitReserved("drain");
      });
    });
  }
  uri() {
    let t = this.query || {};
    const e = this.opts.secure ? "https" : "http";
    let o = "";
    this.opts.timestampRequests !== !1 && (t[this.opts.timestampParam] = yeast()), !this.supportsBinary && !t.sid && (t.b64 = 1), this.opts.port && (e === "https" && Number(this.opts.port) !== 443 || e === "http" && Number(this.opts.port) !== 80) && (o = ":" + this.opts.port);
    const R = encode$2(t), N = this.opts.hostname.indexOf(":") !== -1;
    return e + "://" + (N ? "[" + this.opts.hostname + "]" : this.opts.hostname) + o + this.opts.path + (R.length ? "?" + R : "");
  }
  request(t = {}) {
    return Object.assign(t, { xd: this.xd, xs: this.xs }, this.opts), new Request(this.uri(), t);
  }
  doWrite(t, e) {
    const o = this.request({
      method: "POST",
      data: t
    });
    o.on("success", e), o.on("error", (R, N) => {
      this.onError("xhr post error", R, N);
    });
  }
  doPoll() {
    const t = this.request();
    t.on("data", this.onData.bind(this)), t.on("error", (e, o) => {
      this.onError("xhr poll error", e, o);
    }), this.pollXhr = t;
  }
}
class Request extends Emitter {
  constructor(t, e) {
    super(), installTimerFunctions(this, e), this.opts = e, this.method = e.method || "GET", this.uri = t, this.async = e.async !== !1, this.data = e.data !== void 0 ? e.data : null, this.create();
  }
  create() {
    const t = pick(this.opts, "agent", "pfx", "key", "passphrase", "cert", "ca", "ciphers", "rejectUnauthorized", "autoUnref");
    t.xdomain = !!this.opts.xd, t.xscheme = !!this.opts.xs;
    const e = this.xhr = new XHR(t);
    try {
      e.open(this.method, this.uri, this.async);
      try {
        if (this.opts.extraHeaders) {
          e.setDisableHeaderCheck && e.setDisableHeaderCheck(!0);
          for (let o in this.opts.extraHeaders)
            this.opts.extraHeaders.hasOwnProperty(o) && e.setRequestHeader(o, this.opts.extraHeaders[o]);
        }
      } catch {
      }
      if (this.method === "POST")
        try {
          e.setRequestHeader("Content-type", "text/plain;charset=UTF-8");
        } catch {
        }
      try {
        e.setRequestHeader("Accept", "*/*");
      } catch {
      }
      "withCredentials" in e && (e.withCredentials = this.opts.withCredentials), this.opts.requestTimeout && (e.timeout = this.opts.requestTimeout), e.onreadystatechange = () => {
        e.readyState === 4 && (e.status === 200 || e.status === 1223 ? this.onLoad() : this.setTimeoutFn(() => {
          this.onError(typeof e.status == "number" ? e.status : 0);
        }, 0));
      }, e.send(this.data);
    } catch (o) {
      this.setTimeoutFn(() => {
        this.onError(o);
      }, 0);
      return;
    }
    typeof document < "u" && (this.index = Request.requestsCount++, Request.requests[this.index] = this);
  }
  onError(t) {
    this.emitReserved("error", t, this.xhr), this.cleanup(!0);
  }
  cleanup(t) {
    if (!(typeof this.xhr > "u" || this.xhr === null)) {
      if (this.xhr.onreadystatechange = empty, t)
        try {
          this.xhr.abort();
        } catch {
        }
      typeof document < "u" && delete Request.requests[this.index], this.xhr = null;
    }
  }
  onLoad() {
    const t = this.xhr.responseText;
    t !== null && (this.emitReserved("data", t), this.emitReserved("success"), this.cleanup());
  }
  abort() {
    this.cleanup();
  }
}
Request.requestsCount = 0;
Request.requests = {};
if (typeof document < "u") {
  if (typeof attachEvent == "function")
    attachEvent("onunload", unloadHandler);
  else if (typeof addEventListener == "function") {
    const n = "onpagehide" in globalThisShim ? "pagehide" : "unload";
    addEventListener(n, unloadHandler, !1);
  }
}
function unloadHandler() {
  for (let n in Request.requests)
    Request.requests.hasOwnProperty(n) && Request.requests[n].abort();
}
const nextTick = (() => typeof Promise == "function" && typeof Promise.resolve == "function" ? (t) => Promise.resolve().then(t) : (t, e) => e(t, 0))(), WebSocket = globalThisShim.WebSocket || globalThisShim.MozWebSocket, usingBrowserWebSocket = !0, defaultBinaryType = "arraybuffer", isReactNative = typeof navigator < "u" && typeof navigator.product == "string" && navigator.product.toLowerCase() === "reactnative";
class WS extends Transport {
  constructor(t) {
    super(t), this.supportsBinary = !t.forceBase64;
  }
  get name() {
    return "websocket";
  }
  doOpen() {
    if (!this.check())
      return;
    const t = this.uri(), e = this.opts.protocols, o = isReactNative ? {} : pick(this.opts, "agent", "perMessageDeflate", "pfx", "key", "passphrase", "cert", "ca", "ciphers", "rejectUnauthorized", "localAddress", "protocolVersion", "origin", "maxPayload", "family", "checkServerIdentity");
    this.opts.extraHeaders && (o.headers = this.opts.extraHeaders);
    try {
      this.ws = usingBrowserWebSocket && !isReactNative ? e ? new WebSocket(t, e) : new WebSocket(t) : new WebSocket(t, e, o);
    } catch (R) {
      return this.emitReserved("error", R);
    }
    this.ws.binaryType = this.socket.binaryType || defaultBinaryType, this.addEventListeners();
  }
  addEventListeners() {
    this.ws.onopen = () => {
      this.opts.autoUnref && this.ws._socket.unref(), this.onOpen();
    }, this.ws.onclose = (t) => this.onClose({
      description: "websocket connection closed",
      context: t
    }), this.ws.onmessage = (t) => this.onData(t.data), this.ws.onerror = (t) => this.onError("websocket error", t);
  }
  write(t) {
    this.writable = !1;
    for (let e = 0; e < t.length; e++) {
      const o = t[e], R = e === t.length - 1;
      encodePacket(o, this.supportsBinary, (N) => {
        const M = {};
        try {
          usingBrowserWebSocket && this.ws.send(N);
        } catch {
        }
        R && nextTick(() => {
          this.writable = !0, this.emitReserved("drain");
        }, this.setTimeoutFn);
      });
    }
  }
  doClose() {
    typeof this.ws < "u" && (this.ws.close(), this.ws = null);
  }
  uri() {
    let t = this.query || {};
    const e = this.opts.secure ? "wss" : "ws";
    let o = "";
    this.opts.port && (e === "wss" && Number(this.opts.port) !== 443 || e === "ws" && Number(this.opts.port) !== 80) && (o = ":" + this.opts.port), this.opts.timestampRequests && (t[this.opts.timestampParam] = yeast()), this.supportsBinary || (t.b64 = 1);
    const R = encode$2(t), N = this.opts.hostname.indexOf(":") !== -1;
    return e + "://" + (N ? "[" + this.opts.hostname + "]" : this.opts.hostname) + o + this.opts.path + (R.length ? "?" + R : "");
  }
  check() {
    return !!WebSocket;
  }
}
const transports = {
  websocket: WS,
  polling: Polling
}, re = /^(?:(?![^:@]+:[^:@\/]*@)(http|https|ws|wss):\/\/)?((?:(([^:@]*)(?::([^:@]*))?)?@)?((?:[a-f0-9]{0,4}:){2,7}[a-f0-9]{0,4}|[^:\/?#]*)(?::(\d*))?)(((\/(?:[^?#](?![^?#\/]*\.[^?#\/.]+(?:[?#]|$)))*\/?)?([^?#\/]*))(?:\?([^#]*))?(?:#(.*))?)/, parts = [
  "source",
  "protocol",
  "authority",
  "userInfo",
  "user",
  "password",
  "host",
  "port",
  "relative",
  "path",
  "directory",
  "file",
  "query",
  "anchor"
];
function parse$2(n) {
  const t = n, e = n.indexOf("["), o = n.indexOf("]");
  e != -1 && o != -1 && (n = n.substring(0, e) + n.substring(e, o).replace(/:/g, ";") + n.substring(o, n.length));
  let R = re.exec(n || ""), N = {}, M = 14;
  for (; M--; )
    N[parts[M]] = R[M] || "";
  return e != -1 && o != -1 && (N.source = t, N.host = N.host.substring(1, N.host.length - 1).replace(/;/g, ":"), N.authority = N.authority.replace("[", "").replace("]", "").replace(/;/g, ":"), N.ipv6uri = !0), N.pathNames = pathNames(N, N.path), N.queryKey = queryKey(N, N.query), N;
}
function pathNames(n, t) {
  const e = /\/{2,9}/g, o = t.replace(e, "/").split("/");
  return (t.substr(0, 1) == "/" || t.length === 0) && o.splice(0, 1), t.substr(t.length - 1, 1) == "/" && o.splice(o.length - 1, 1), o;
}
function queryKey(n, t) {
  const e = {};
  return t.replace(/(?:^|&)([^&=]*)=?([^&]*)/g, function(o, R, N) {
    R && (e[R] = N);
  }), e;
}
class Socket$1 extends Emitter {
  constructor(t, e = {}) {
    super(), t && typeof t == "object" && (e = t, t = null), t ? (t = parse$2(t), e.hostname = t.host, e.secure = t.protocol === "https" || t.protocol === "wss", e.port = t.port, t.query && (e.query = t.query)) : e.host && (e.hostname = parse$2(e.host).host), installTimerFunctions(this, e), this.secure = e.secure != null ? e.secure : typeof location < "u" && location.protocol === "https:", e.hostname && !e.port && (e.port = this.secure ? "443" : "80"), this.hostname = e.hostname || (typeof location < "u" ? location.hostname : "localhost"), this.port = e.port || (typeof location < "u" && location.port ? location.port : this.secure ? "443" : "80"), this.transports = e.transports || ["polling", "websocket"], this.readyState = "", this.writeBuffer = [], this.prevBufferLen = 0, this.opts = Object.assign({
      path: "/engine.io",
      agent: !1,
      withCredentials: !1,
      upgrade: !0,
      timestampParam: "t",
      rememberUpgrade: !1,
      rejectUnauthorized: !0,
      perMessageDeflate: {
        threshold: 1024
      },
      transportOptions: {},
      closeOnBeforeunload: !0
    }, e), this.opts.path = this.opts.path.replace(/\/$/, "") + "/", typeof this.opts.query == "string" && (this.opts.query = decode$2(this.opts.query)), this.id = null, this.upgrades = null, this.pingInterval = null, this.pingTimeout = null, this.pingTimeoutTimer = null, typeof addEventListener == "function" && (this.opts.closeOnBeforeunload && addEventListener("beforeunload", () => {
      this.transport && (this.transport.removeAllListeners(), this.transport.close());
    }, !1), this.hostname !== "localhost" && (this.offlineEventListener = () => {
      this.onClose("transport close", {
        description: "network connection lost"
      });
    }, addEventListener("offline", this.offlineEventListener, !1))), this.open();
  }
  createTransport(t) {
    const e = Object.assign({}, this.opts.query);
    e.EIO = protocol$1, e.transport = t, this.id && (e.sid = this.id);
    const o = Object.assign({}, this.opts.transportOptions[t], this.opts, {
      query: e,
      socket: this,
      hostname: this.hostname,
      secure: this.secure,
      port: this.port
    });
    return new transports[t](o);
  }
  open() {
    let t;
    if (this.opts.rememberUpgrade && Socket$1.priorWebsocketSuccess && this.transports.indexOf("websocket") !== -1)
      t = "websocket";
    else if (this.transports.length === 0) {
      this.setTimeoutFn(() => {
        this.emitReserved("error", "No transports available");
      }, 0);
      return;
    } else
      t = this.transports[0];
    this.readyState = "opening";
    try {
      t = this.createTransport(t);
    } catch {
      this.transports.shift(), this.open();
      return;
    }
    t.open(), this.setTransport(t);
  }
  setTransport(t) {
    this.transport && this.transport.removeAllListeners(), this.transport = t, t.on("drain", this.onDrain.bind(this)).on("packet", this.onPacket.bind(this)).on("error", this.onError.bind(this)).on("close", (e) => this.onClose("transport close", e));
  }
  probe(t) {
    let e = this.createTransport(t), o = !1;
    Socket$1.priorWebsocketSuccess = !1;
    const R = () => {
      o || (e.send([{ type: "ping", data: "probe" }]), e.once("packet", (k) => {
        if (!o)
          if (k.type === "pong" && k.data === "probe") {
            if (this.upgrading = !0, this.emitReserved("upgrading", e), !e)
              return;
            Socket$1.priorWebsocketSuccess = e.name === "websocket", this.transport.pause(() => {
              o || this.readyState !== "closed" && ($(), this.setTransport(e), e.send([{ type: "upgrade" }]), this.emitReserved("upgrade", e), e = null, this.upgrading = !1, this.flush());
            });
          } else {
            const U = new Error("probe error");
            U.transport = e.name, this.emitReserved("upgradeError", U);
          }
      }));
    };
    function N() {
      o || (o = !0, $(), e.close(), e = null);
    }
    const M = (k) => {
      const U = new Error("probe error: " + k);
      U.transport = e.name, N(), this.emitReserved("upgradeError", U);
    };
    function D() {
      M("transport closed");
    }
    function L() {
      M("socket closed");
    }
    function B(k) {
      e && k.name !== e.name && N();
    }
    const $ = () => {
      e.removeListener("open", R), e.removeListener("error", M), e.removeListener("close", D), this.off("close", L), this.off("upgrading", B);
    };
    e.once("open", R), e.once("error", M), e.once("close", D), this.once("close", L), this.once("upgrading", B), e.open();
  }
  onOpen() {
    if (this.readyState = "open", Socket$1.priorWebsocketSuccess = this.transport.name === "websocket", this.emitReserved("open"), this.flush(), this.readyState === "open" && this.opts.upgrade && this.transport.pause) {
      let t = 0;
      const e = this.upgrades.length;
      for (; t < e; t++)
        this.probe(this.upgrades[t]);
    }
  }
  onPacket(t) {
    if (this.readyState === "opening" || this.readyState === "open" || this.readyState === "closing")
      switch (this.emitReserved("packet", t), this.emitReserved("heartbeat"), t.type) {
        case "open":
          this.onHandshake(JSON.parse(t.data));
          break;
        case "ping":
          this.resetPingTimeout(), this.sendPacket("pong"), this.emitReserved("ping"), this.emitReserved("pong");
          break;
        case "error":
          const e = new Error("server error");
          e.code = t.data, this.onError(e);
          break;
        case "message":
          this.emitReserved("data", t.data), this.emitReserved("message", t.data);
          break;
      }
  }
  onHandshake(t) {
    this.emitReserved("handshake", t), this.id = t.sid, this.transport.query.sid = t.sid, this.upgrades = this.filterUpgrades(t.upgrades), this.pingInterval = t.pingInterval, this.pingTimeout = t.pingTimeout, this.maxPayload = t.maxPayload, this.onOpen(), this.readyState !== "closed" && this.resetPingTimeout();
  }
  resetPingTimeout() {
    this.clearTimeoutFn(this.pingTimeoutTimer), this.pingTimeoutTimer = this.setTimeoutFn(() => {
      this.onClose("ping timeout");
    }, this.pingInterval + this.pingTimeout), this.opts.autoUnref && this.pingTimeoutTimer.unref();
  }
  onDrain() {
    this.writeBuffer.splice(0, this.prevBufferLen), this.prevBufferLen = 0, this.writeBuffer.length === 0 ? this.emitReserved("drain") : this.flush();
  }
  flush() {
    if (this.readyState !== "closed" && this.transport.writable && !this.upgrading && this.writeBuffer.length) {
      const t = this.getWritablePackets();
      this.transport.send(t), this.prevBufferLen = t.length, this.emitReserved("flush");
    }
  }
  getWritablePackets() {
    if (!(this.maxPayload && this.transport.name === "polling" && this.writeBuffer.length > 1))
      return this.writeBuffer;
    let e = 1;
    for (let o = 0; o < this.writeBuffer.length; o++) {
      const R = this.writeBuffer[o].data;
      if (R && (e += byteLength(R)), o > 0 && e > this.maxPayload)
        return this.writeBuffer.slice(0, o);
      e += 2;
    }
    return this.writeBuffer;
  }
  write(t, e, o) {
    return this.sendPacket("message", t, e, o), this;
  }
  send(t, e, o) {
    return this.sendPacket("message", t, e, o), this;
  }
  sendPacket(t, e, o, R) {
    if (typeof e == "function" && (R = e, e = void 0), typeof o == "function" && (R = o, o = null), this.readyState === "closing" || this.readyState === "closed")
      return;
    o = o || {}, o.compress = o.compress !== !1;
    const N = {
      type: t,
      data: e,
      options: o
    };
    this.emitReserved("packetCreate", N), this.writeBuffer.push(N), R && this.once("flush", R), this.flush();
  }
  close() {
    const t = () => {
      this.onClose("forced close"), this.transport.close();
    }, e = () => {
      this.off("upgrade", e), this.off("upgradeError", e), t();
    }, o = () => {
      this.once("upgrade", e), this.once("upgradeError", e);
    };
    return (this.readyState === "opening" || this.readyState === "open") && (this.readyState = "closing", this.writeBuffer.length ? this.once("drain", () => {
      this.upgrading ? o() : t();
    }) : this.upgrading ? o() : t()), this;
  }
  onError(t) {
    Socket$1.priorWebsocketSuccess = !1, this.emitReserved("error", t), this.onClose("transport error", t);
  }
  onClose(t, e) {
    (this.readyState === "opening" || this.readyState === "open" || this.readyState === "closing") && (this.clearTimeoutFn(this.pingTimeoutTimer), this.transport.removeAllListeners("close"), this.transport.close(), this.transport.removeAllListeners(), typeof removeEventListener == "function" && removeEventListener("offline", this.offlineEventListener, !1), this.readyState = "closed", this.id = null, this.emitReserved("close", t, e), this.writeBuffer = [], this.prevBufferLen = 0);
  }
  filterUpgrades(t) {
    const e = [];
    let o = 0;
    const R = t.length;
    for (; o < R; o++)
      ~this.transports.indexOf(t[o]) && e.push(t[o]);
    return e;
  }
}
Socket$1.protocol = protocol$1;
function url$1(n, t = "", e) {
  let o = n;
  e = e || typeof location < "u" && location, n == null && (n = e.protocol + "//" + e.host), typeof n == "string" && (n.charAt(0) === "/" && (n.charAt(1) === "/" ? n = e.protocol + n : n = e.host + n), /^(https?|wss?):\/\//.test(n) || (typeof e < "u" ? n = e.protocol + "//" + n : n = "https://" + n), o = parse$2(n)), o.port || (/^(http|ws)$/.test(o.protocol) ? o.port = "80" : /^(http|ws)s$/.test(o.protocol) && (o.port = "443")), o.path = o.path || "/";
  const N = o.host.indexOf(":") !== -1 ? "[" + o.host + "]" : o.host;
  return o.id = o.protocol + "://" + N + ":" + o.port + t, o.href = o.protocol + "://" + N + (e && e.port === o.port ? "" : ":" + o.port), o;
}
const withNativeArrayBuffer = typeof ArrayBuffer == "function", isView = (n) => typeof ArrayBuffer.isView == "function" ? ArrayBuffer.isView(n) : n.buffer instanceof ArrayBuffer, toString = Object.prototype.toString, withNativeBlob = typeof Blob == "function" || typeof Blob < "u" && toString.call(Blob) === "[object BlobConstructor]", withNativeFile = typeof File == "function" || typeof File < "u" && toString.call(File) === "[object FileConstructor]";
function isBinary(n) {
  return withNativeArrayBuffer && (n instanceof ArrayBuffer || isView(n)) || withNativeBlob && n instanceof Blob || withNativeFile && n instanceof File;
}
function hasBinary(n, t) {
  if (!n || typeof n != "object")
    return !1;
  if (Array.isArray(n)) {
    for (let e = 0, o = n.length; e < o; e++)
      if (hasBinary(n[e]))
        return !0;
    return !1;
  }
  if (isBinary(n))
    return !0;
  if (n.toJSON && typeof n.toJSON == "function" && arguments.length === 1)
    return hasBinary(n.toJSON(), !0);
  for (const e in n)
    if (Object.prototype.hasOwnProperty.call(n, e) && hasBinary(n[e]))
      return !0;
  return !1;
}
function deconstructPacket(n) {
  const t = [], e = n.data, o = n;
  return o.data = _deconstructPacket(e, t), o.attachments = t.length, { packet: o, buffers: t };
}
function _deconstructPacket(n, t) {
  if (!n)
    return n;
  if (isBinary(n)) {
    const e = { _placeholder: !0, num: t.length };
    return t.push(n), e;
  } else if (Array.isArray(n)) {
    const e = new Array(n.length);
    for (let o = 0; o < n.length; o++)
      e[o] = _deconstructPacket(n[o], t);
    return e;
  } else if (typeof n == "object" && !(n instanceof Date)) {
    const e = {};
    for (const o in n)
      Object.prototype.hasOwnProperty.call(n, o) && (e[o] = _deconstructPacket(n[o], t));
    return e;
  }
  return n;
}
function reconstructPacket(n, t) {
  return n.data = _reconstructPacket(n.data, t), n.attachments = void 0, n;
}
function _reconstructPacket(n, t) {
  if (!n)
    return n;
  if (n && n._placeholder === !0) {
    if (typeof n.num == "number" && n.num >= 0 && n.num < t.length)
      return t[n.num];
    throw new Error("illegal attachments");
  } else if (Array.isArray(n))
    for (let e = 0; e < n.length; e++)
      n[e] = _reconstructPacket(n[e], t);
  else if (typeof n == "object")
    for (const e in n)
      Object.prototype.hasOwnProperty.call(n, e) && (n[e] = _reconstructPacket(n[e], t));
  return n;
}
const protocol = 5;
var PacketType;
(function(n) {
  n[n.CONNECT = 0] = "CONNECT", n[n.DISCONNECT = 1] = "DISCONNECT", n[n.EVENT = 2] = "EVENT", n[n.ACK = 3] = "ACK", n[n.CONNECT_ERROR = 4] = "CONNECT_ERROR", n[n.BINARY_EVENT = 5] = "BINARY_EVENT", n[n.BINARY_ACK = 6] = "BINARY_ACK";
})(PacketType || (PacketType = {}));
class Encoder {
  constructor(t) {
    this.replacer = t;
  }
  encode(t) {
    return (t.type === PacketType.EVENT || t.type === PacketType.ACK) && hasBinary(t) ? (t.type = t.type === PacketType.EVENT ? PacketType.BINARY_EVENT : PacketType.BINARY_ACK, this.encodeAsBinary(t)) : [this.encodeAsString(t)];
  }
  encodeAsString(t) {
    let e = "" + t.type;
    return (t.type === PacketType.BINARY_EVENT || t.type === PacketType.BINARY_ACK) && (e += t.attachments + "-"), t.nsp && t.nsp !== "/" && (e += t.nsp + ","), t.id != null && (e += t.id), t.data != null && (e += JSON.stringify(t.data, this.replacer)), e;
  }
  encodeAsBinary(t) {
    const e = deconstructPacket(t), o = this.encodeAsString(e.packet), R = e.buffers;
    return R.unshift(o), R;
  }
}
class Decoder extends Emitter {
  constructor(t) {
    super(), this.reviver = t;
  }
  add(t) {
    let e;
    if (typeof t == "string") {
      if (this.reconstructor)
        throw new Error("got plaintext data when reconstructing a packet");
      e = this.decodeString(t), e.type === PacketType.BINARY_EVENT || e.type === PacketType.BINARY_ACK ? (this.reconstructor = new BinaryReconstructor(e), e.attachments === 0 && super.emitReserved("decoded", e)) : super.emitReserved("decoded", e);
    } else if (isBinary(t) || t.base64)
      if (this.reconstructor)
        e = this.reconstructor.takeBinaryData(t), e && (this.reconstructor = null, super.emitReserved("decoded", e));
      else
        throw new Error("got binary data when not reconstructing a packet");
    else
      throw new Error("Unknown type: " + t);
  }
  decodeString(t) {
    let e = 0;
    const o = {
      type: Number(t.charAt(0))
    };
    if (PacketType[o.type] === void 0)
      throw new Error("unknown packet type " + o.type);
    if (o.type === PacketType.BINARY_EVENT || o.type === PacketType.BINARY_ACK) {
      const N = e + 1;
      for (; t.charAt(++e) !== "-" && e != t.length; )
        ;
      const M = t.substring(N, e);
      if (M != Number(M) || t.charAt(e) !== "-")
        throw new Error("Illegal attachments");
      o.attachments = Number(M);
    }
    if (t.charAt(e + 1) === "/") {
      const N = e + 1;
      for (; ++e && !(t.charAt(e) === "," || e === t.length); )
        ;
      o.nsp = t.substring(N, e);
    } else
      o.nsp = "/";
    const R = t.charAt(e + 1);
    if (R !== "" && Number(R) == R) {
      const N = e + 1;
      for (; ++e; ) {
        const M = t.charAt(e);
        if (M == null || Number(M) != M) {
          --e;
          break;
        }
        if (e === t.length)
          break;
      }
      o.id = Number(t.substring(N, e + 1));
    }
    if (t.charAt(++e)) {
      const N = this.tryParse(t.substr(e));
      if (Decoder.isPayloadValid(o.type, N))
        o.data = N;
      else
        throw new Error("invalid payload");
    }
    return o;
  }
  tryParse(t) {
    try {
      return JSON.parse(t, this.reviver);
    } catch {
      return !1;
    }
  }
  static isPayloadValid(t, e) {
    switch (t) {
      case PacketType.CONNECT:
        return typeof e == "object";
      case PacketType.DISCONNECT:
        return e === void 0;
      case PacketType.CONNECT_ERROR:
        return typeof e == "string" || typeof e == "object";
      case PacketType.EVENT:
      case PacketType.BINARY_EVENT:
        return Array.isArray(e) && e.length > 0;
      case PacketType.ACK:
      case PacketType.BINARY_ACK:
        return Array.isArray(e);
    }
  }
  destroy() {
    this.reconstructor && this.reconstructor.finishedReconstruction();
  }
}
class BinaryReconstructor {
  constructor(t) {
    this.packet = t, this.buffers = [], this.reconPack = t;
  }
  takeBinaryData(t) {
    if (this.buffers.push(t), this.buffers.length === this.reconPack.attachments) {
      const e = reconstructPacket(this.reconPack, this.buffers);
      return this.finishedReconstruction(), e;
    }
    return null;
  }
  finishedReconstruction() {
    this.reconPack = null, this.buffers = [];
  }
}
const parser = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  protocol,
  get PacketType() {
    return PacketType;
  },
  Encoder,
  Decoder
}, Symbol.toStringTag, { value: "Module" }));
function on(n, t, e) {
  return n.on(t, e), function() {
    n.off(t, e);
  };
}
const RESERVED_EVENTS = Object.freeze({
  connect: 1,
  connect_error: 1,
  disconnect: 1,
  disconnecting: 1,
  newListener: 1,
  removeListener: 1
});
class Socket extends Emitter {
  constructor(t, e, o) {
    super(), this.connected = !1, this.receiveBuffer = [], this.sendBuffer = [], this.ids = 0, this.acks = {}, this.flags = {}, this.io = t, this.nsp = e, o && o.auth && (this.auth = o.auth), this.io._autoConnect && this.open();
  }
  get disconnected() {
    return !this.connected;
  }
  subEvents() {
    if (this.subs)
      return;
    const t = this.io;
    this.subs = [
      on(t, "open", this.onopen.bind(this)),
      on(t, "packet", this.onpacket.bind(this)),
      on(t, "error", this.onerror.bind(this)),
      on(t, "close", this.onclose.bind(this))
    ];
  }
  get active() {
    return !!this.subs;
  }
  connect() {
    return this.connected ? this : (this.subEvents(), this.io._reconnecting || this.io.open(), this.io._readyState === "open" && this.onopen(), this);
  }
  open() {
    return this.connect();
  }
  send(...t) {
    return t.unshift("message"), this.emit.apply(this, t), this;
  }
  emit(t, ...e) {
    if (RESERVED_EVENTS.hasOwnProperty(t))
      throw new Error('"' + t + '" is a reserved event name');
    e.unshift(t);
    const o = {
      type: PacketType.EVENT,
      data: e
    };
    if (o.options = {}, o.options.compress = this.flags.compress !== !1, typeof e[e.length - 1] == "function") {
      const M = this.ids++, D = e.pop();
      this._registerAckCallback(M, D), o.id = M;
    }
    const R = this.io.engine && this.io.engine.transport && this.io.engine.transport.writable;
    return this.flags.volatile && (!R || !this.connected) || (this.connected ? (this.notifyOutgoingListeners(o), this.packet(o)) : this.sendBuffer.push(o)), this.flags = {}, this;
  }
  _registerAckCallback(t, e) {
    const o = this.flags.timeout;
    if (o === void 0) {
      this.acks[t] = e;
      return;
    }
    const R = this.io.setTimeoutFn(() => {
      delete this.acks[t];
      for (let N = 0; N < this.sendBuffer.length; N++)
        this.sendBuffer[N].id === t && this.sendBuffer.splice(N, 1);
      e.call(this, new Error("operation has timed out"));
    }, o);
    this.acks[t] = (...N) => {
      this.io.clearTimeoutFn(R), e.apply(this, [null, ...N]);
    };
  }
  packet(t) {
    t.nsp = this.nsp, this.io._packet(t);
  }
  onopen() {
    typeof this.auth == "function" ? this.auth((t) => {
      this.packet({ type: PacketType.CONNECT, data: t });
    }) : this.packet({ type: PacketType.CONNECT, data: this.auth });
  }
  onerror(t) {
    this.connected || this.emitReserved("connect_error", t);
  }
  onclose(t, e) {
    this.connected = !1, delete this.id, this.emitReserved("disconnect", t, e);
  }
  onpacket(t) {
    if (t.nsp === this.nsp)
      switch (t.type) {
        case PacketType.CONNECT:
          if (t.data && t.data.sid) {
            const R = t.data.sid;
            this.onconnect(R);
          } else
            this.emitReserved("connect_error", new Error("It seems you are trying to reach a Socket.IO server in v2.x with a v3.x client, but they are not compatible (more information here: https://socket.io/docs/v3/migrating-from-2-x-to-3-0/)"));
          break;
        case PacketType.EVENT:
        case PacketType.BINARY_EVENT:
          this.onevent(t);
          break;
        case PacketType.ACK:
        case PacketType.BINARY_ACK:
          this.onack(t);
          break;
        case PacketType.DISCONNECT:
          this.ondisconnect();
          break;
        case PacketType.CONNECT_ERROR:
          this.destroy();
          const o = new Error(t.data.message);
          o.data = t.data.data, this.emitReserved("connect_error", o);
          break;
      }
  }
  onevent(t) {
    const e = t.data || [];
    t.id != null && e.push(this.ack(t.id)), this.connected ? this.emitEvent(e) : this.receiveBuffer.push(Object.freeze(e));
  }
  emitEvent(t) {
    if (this._anyListeners && this._anyListeners.length) {
      const e = this._anyListeners.slice();
      for (const o of e)
        o.apply(this, t);
    }
    super.emit.apply(this, t);
  }
  ack(t) {
    const e = this;
    let o = !1;
    return function(...R) {
      o || (o = !0, e.packet({
        type: PacketType.ACK,
        id: t,
        data: R
      }));
    };
  }
  onack(t) {
    const e = this.acks[t.id];
    typeof e == "function" && (e.apply(this, t.data), delete this.acks[t.id]);
  }
  onconnect(t) {
    this.id = t, this.connected = !0, this.emitBuffered(), this.emitReserved("connect");
  }
  emitBuffered() {
    this.receiveBuffer.forEach((t) => this.emitEvent(t)), this.receiveBuffer = [], this.sendBuffer.forEach((t) => {
      this.notifyOutgoingListeners(t), this.packet(t);
    }), this.sendBuffer = [];
  }
  ondisconnect() {
    this.destroy(), this.onclose("io server disconnect");
  }
  destroy() {
    this.subs && (this.subs.forEach((t) => t()), this.subs = void 0), this.io._destroy(this);
  }
  disconnect() {
    return this.connected && this.packet({ type: PacketType.DISCONNECT }), this.destroy(), this.connected && this.onclose("io client disconnect"), this;
  }
  close() {
    return this.disconnect();
  }
  compress(t) {
    return this.flags.compress = t, this;
  }
  get volatile() {
    return this.flags.volatile = !0, this;
  }
  timeout(t) {
    return this.flags.timeout = t, this;
  }
  onAny(t) {
    return this._anyListeners = this._anyListeners || [], this._anyListeners.push(t), this;
  }
  prependAny(t) {
    return this._anyListeners = this._anyListeners || [], this._anyListeners.unshift(t), this;
  }
  offAny(t) {
    if (!this._anyListeners)
      return this;
    if (t) {
      const e = this._anyListeners;
      for (let o = 0; o < e.length; o++)
        if (t === e[o])
          return e.splice(o, 1), this;
    } else
      this._anyListeners = [];
    return this;
  }
  listenersAny() {
    return this._anyListeners || [];
  }
  onAnyOutgoing(t) {
    return this._anyOutgoingListeners = this._anyOutgoingListeners || [], this._anyOutgoingListeners.push(t), this;
  }
  prependAnyOutgoing(t) {
    return this._anyOutgoingListeners = this._anyOutgoingListeners || [], this._anyOutgoingListeners.unshift(t), this;
  }
  offAnyOutgoing(t) {
    if (!this._anyOutgoingListeners)
      return this;
    if (t) {
      const e = this._anyOutgoingListeners;
      for (let o = 0; o < e.length; o++)
        if (t === e[o])
          return e.splice(o, 1), this;
    } else
      this._anyOutgoingListeners = [];
    return this;
  }
  listenersAnyOutgoing() {
    return this._anyOutgoingListeners || [];
  }
  notifyOutgoingListeners(t) {
    if (this._anyOutgoingListeners && this._anyOutgoingListeners.length) {
      const e = this._anyOutgoingListeners.slice();
      for (const o of e)
        o.apply(this, t.data);
    }
  }
}
function Backoff(n) {
  n = n || {}, this.ms = n.min || 100, this.max = n.max || 1e4, this.factor = n.factor || 2, this.jitter = n.jitter > 0 && n.jitter <= 1 ? n.jitter : 0, this.attempts = 0;
}
Backoff.prototype.duration = function() {
  var n = this.ms * Math.pow(this.factor, this.attempts++);
  if (this.jitter) {
    var t = Math.random(), e = Math.floor(t * this.jitter * n);
    n = (Math.floor(t * 10) & 1) == 0 ? n - e : n + e;
  }
  return Math.min(n, this.max) | 0;
};
Backoff.prototype.reset = function() {
  this.attempts = 0;
};
Backoff.prototype.setMin = function(n) {
  this.ms = n;
};
Backoff.prototype.setMax = function(n) {
  this.max = n;
};
Backoff.prototype.setJitter = function(n) {
  this.jitter = n;
};
class Manager extends Emitter {
  constructor(t, e) {
    var o;
    super(), this.nsps = {}, this.subs = [], t && typeof t == "object" && (e = t, t = void 0), e = e || {}, e.path = e.path || "/socket.io", this.opts = e, installTimerFunctions(this, e), this.reconnection(e.reconnection !== !1), this.reconnectionAttempts(e.reconnectionAttempts || 1 / 0), this.reconnectionDelay(e.reconnectionDelay || 1e3), this.reconnectionDelayMax(e.reconnectionDelayMax || 5e3), this.randomizationFactor((o = e.randomizationFactor) !== null && o !== void 0 ? o : 0.5), this.backoff = new Backoff({
      min: this.reconnectionDelay(),
      max: this.reconnectionDelayMax(),
      jitter: this.randomizationFactor()
    }), this.timeout(e.timeout == null ? 2e4 : e.timeout), this._readyState = "closed", this.uri = t;
    const R = e.parser || parser;
    this.encoder = new R.Encoder(), this.decoder = new R.Decoder(), this._autoConnect = e.autoConnect !== !1, this._autoConnect && this.open();
  }
  reconnection(t) {
    return arguments.length ? (this._reconnection = !!t, this) : this._reconnection;
  }
  reconnectionAttempts(t) {
    return t === void 0 ? this._reconnectionAttempts : (this._reconnectionAttempts = t, this);
  }
  reconnectionDelay(t) {
    var e;
    return t === void 0 ? this._reconnectionDelay : (this._reconnectionDelay = t, (e = this.backoff) === null || e === void 0 || e.setMin(t), this);
  }
  randomizationFactor(t) {
    var e;
    return t === void 0 ? this._randomizationFactor : (this._randomizationFactor = t, (e = this.backoff) === null || e === void 0 || e.setJitter(t), this);
  }
  reconnectionDelayMax(t) {
    var e;
    return t === void 0 ? this._reconnectionDelayMax : (this._reconnectionDelayMax = t, (e = this.backoff) === null || e === void 0 || e.setMax(t), this);
  }
  timeout(t) {
    return arguments.length ? (this._timeout = t, this) : this._timeout;
  }
  maybeReconnectOnOpen() {
    !this._reconnecting && this._reconnection && this.backoff.attempts === 0 && this.reconnect();
  }
  open(t) {
    if (~this._readyState.indexOf("open"))
      return this;
    this.engine = new Socket$1(this.uri, this.opts);
    const e = this.engine, o = this;
    this._readyState = "opening", this.skipReconnect = !1;
    const R = on(e, "open", function() {
      o.onopen(), t && t();
    }), N = on(e, "error", (M) => {
      o.cleanup(), o._readyState = "closed", this.emitReserved("error", M), t ? t(M) : o.maybeReconnectOnOpen();
    });
    if (this._timeout !== !1) {
      const M = this._timeout;
      M === 0 && R();
      const D = this.setTimeoutFn(() => {
        R(), e.close(), e.emit("error", new Error("timeout"));
      }, M);
      this.opts.autoUnref && D.unref(), this.subs.push(function() {
        clearTimeout(D);
      });
    }
    return this.subs.push(R), this.subs.push(N), this;
  }
  connect(t) {
    return this.open(t);
  }
  onopen() {
    this.cleanup(), this._readyState = "open", this.emitReserved("open");
    const t = this.engine;
    this.subs.push(on(t, "ping", this.onping.bind(this)), on(t, "data", this.ondata.bind(this)), on(t, "error", this.onerror.bind(this)), on(t, "close", this.onclose.bind(this)), on(this.decoder, "decoded", this.ondecoded.bind(this)));
  }
  onping() {
    this.emitReserved("ping");
  }
  ondata(t) {
    this.decoder.add(t);
  }
  ondecoded(t) {
    this.emitReserved("packet", t);
  }
  onerror(t) {
    this.emitReserved("error", t);
  }
  socket(t, e) {
    let o = this.nsps[t];
    return o || (o = new Socket(this, t, e), this.nsps[t] = o), o;
  }
  _destroy(t) {
    const e = Object.keys(this.nsps);
    for (const o of e)
      if (this.nsps[o].active)
        return;
    this._close();
  }
  _packet(t) {
    const e = this.encoder.encode(t);
    for (let o = 0; o < e.length; o++)
      this.engine.write(e[o], t.options);
  }
  cleanup() {
    this.subs.forEach((t) => t()), this.subs.length = 0, this.decoder.destroy();
  }
  _close() {
    this.skipReconnect = !0, this._reconnecting = !1, this.onclose("forced close"), this.engine && this.engine.close();
  }
  disconnect() {
    return this._close();
  }
  onclose(t, e) {
    this.cleanup(), this.backoff.reset(), this._readyState = "closed", this.emitReserved("close", t, e), this._reconnection && !this.skipReconnect && this.reconnect();
  }
  reconnect() {
    if (this._reconnecting || this.skipReconnect)
      return this;
    const t = this;
    if (this.backoff.attempts >= this._reconnectionAttempts)
      this.backoff.reset(), this.emitReserved("reconnect_failed"), this._reconnecting = !1;
    else {
      const e = this.backoff.duration();
      this._reconnecting = !0;
      const o = this.setTimeoutFn(() => {
        t.skipReconnect || (this.emitReserved("reconnect_attempt", t.backoff.attempts), !t.skipReconnect && t.open((R) => {
          R ? (t._reconnecting = !1, t.reconnect(), this.emitReserved("reconnect_error", R)) : t.onreconnect();
        }));
      }, e);
      this.opts.autoUnref && o.unref(), this.subs.push(function() {
        clearTimeout(o);
      });
    }
  }
  onreconnect() {
    const t = this.backoff.attempts;
    this._reconnecting = !1, this.backoff.reset(), this.emitReserved("reconnect", t);
  }
}
const cache = {};
function lookup(n, t) {
  typeof n == "object" && (t = n, n = void 0), t = t || {};
  const e = url$1(n, t.path || "/socket.io"), o = e.source, R = e.id, N = e.path, M = cache[R] && N in cache[R].nsps, D = t.forceNew || t["force new connection"] || t.multiplex === !1 || M;
  let L;
  return D ? L = new Manager(o, t) : (cache[R] || (cache[R] = new Manager(o, t)), L = cache[R]), e.query && !t.query && (t.query = e.queryKey), L.socket(e.path, t);
}
Object.assign(lookup, {
  Manager,
  Socket,
  io: lookup,
  connect: lookup
});
var __accessCheck$5 = (n, t, e) => {
  if (!t.has(n))
    throw TypeError("Cannot " + e);
}, __privateGet$5 = (n, t, e) => (__accessCheck$5(n, t, "read from private field"), e ? e.call(n) : t.get(n)), __privateAdd$5 = (n, t, e) => {
  if (t.has(n))
    throw TypeError("Cannot add the same private member more than once");
  t instanceof WeakSet ? t.add(n) : t.set(n, e);
}, __privateSet$5 = (n, t, e, o) => (__accessCheck$5(n, t, "write to private field"), o ? o.call(n, e) : t.set(n, e), e), _cvsWidth, _cvsHeight, _cvsScale, _ofsLeft4elm, _ofsTop4elm, _ofsPadLeft_Dom2PIXI, _ofsPadTop_Dom2PIXI, _sk, _hHook, _hToastDat, _aFncHook, _main_title, _tglFlscr, _info_title, _preFromPlg, _hN2Ext, _genImage, _genVideo;
const _SysBase = class {
  constructor(n = {}, t) {
    this.hPlg = n, this.arg = t, this.hFactoryCls = {}, this.fetch = (e) => fetch(e), this.resolution = 1, this.data = { sys: {}, mark: {}, kidoku: {} }, __privateAdd$5(this, _cvsWidth, 0), __privateAdd$5(this, _cvsHeight, 0), __privateAdd$5(this, _cvsScale, 1), __privateAdd$5(this, _ofsLeft4elm, 0), __privateAdd$5(this, _ofsTop4elm, 0), __privateAdd$5(this, _ofsPadLeft_Dom2PIXI, 0), __privateAdd$5(this, _ofsPadTop_Dom2PIXI, 0), this.isFullScr = !1, this.extPort = 3776, __privateAdd$5(this, _sk, void 0), __privateAdd$5(this, _hHook, {
      auth: (e) => {
        if (e.t !== this.cfg.oCfg.debuger_token) {
          this.end();
          return;
        }
        this.toast("\u63A5\u7D9A");
      },
      continue: () => this.toast("\u518D\u751F"),
      disconnect: () => this.toast("\u5207\u65AD"),
      restart: (e) => {
        var o;
        this.send2Dbg((o = e == null ? void 0 : e.ri) != null ? o : "", {}), this.end(), this.run();
      },
      pause: () => this.toast("\u4E00\u6642\u505C\u6B62"),
      stopOnEntry: () => this.toast("\u4E00\u6642\u505C\u6B62"),
      stopOnDataBreakpoint: () => this.toast("\u6CE8\u610F"),
      stopOnBreakpoint: () => this.toast("\u6CE8\u610F"),
      stopOnStep: () => this.toast("\u4E00\u6B69\u9032\u3080"),
      stopOnStepIn: () => this.toast("\u30B9\u30C6\u30C3\u30D5\u309A\u30A4\u30F3"),
      stopOnStepOut: () => this.toast("\u30B9\u30C6\u30C3\u30D5\u309A\u30A2\u30A6\u30C8"),
      stopOnBackstep: () => this.toast("\u4E00\u6B69\u623B\u308B"),
      _addPath: (e) => this.cfg.addPath(e.fn, e.o)
    }), this.pathBaseCnvSnPath4Dbg = "", __privateAdd$5(this, _aFncHook, []), this.callHook = (e, o) => {
    }, this.send2Dbg = (e, o) => {
      var R;
      (R = __privateGet$5(this, _sk)) == null || R.emit("data", e, o);
    }, this.copyBMFolder = (e, o) => {
    }, this.eraseBMFolder = (e) => {
    }, this.close = () => !1, this._export = () => !1, this._import = () => !1, this.navigate_to = () => !1, this.title = (e) => {
      const { text: o } = e;
      if (!o)
        throw "[title] text\u306F\u5FC5\u9808\u3067\u3059";
      return __privateSet$5(this, _main_title, o), this.titleSub(__privateGet$5(this, _main_title) + __privateGet$5(this, _info_title)), !1;
    }, __privateAdd$5(this, _main_title, ""), __privateAdd$5(this, _tglFlscr, (e) => {
      if (!e.key)
        return this.tglFlscr_sub(), !1;
      const o = e.key.toLowerCase();
      return document.addEventListener("keydown", (R) => {
        (R.altKey ? R.key === "Alt" ? "" : "alt+" : "") + (R.ctrlKey ? R.key === "Control" ? "" : "ctrl+" : "") + (R.shiftKey ? R.key === "Shift" ? "" : "shift+" : "") + R.key.toLowerCase() === o && (R.stopPropagation(), this.tglFlscr_sub());
      }, { passive: !0 }), !1;
    }), this.update_check = () => !1, this.window = () => !1, __privateAdd$5(this, _info_title, ""), __privateAdd$5(this, _preFromPlg, (e, o) => ({ ret: o.toString(), ext_num: 0 })), __privateAdd$5(this, _hN2Ext, {
      1: { ext: "jpeg", fnc: (e) => __privateGet$5(this, _genImage).call(this, e), mime: "image/jpeg" },
      2: { ext: "png", fnc: (e) => __privateGet$5(this, _genImage).call(this, e), mime: "image/png" },
      3: { ext: "svg", fnc: (e) => __privateGet$5(this, _genImage).call(this, e), mime: "image/svg+xml" },
      4: { ext: "webp", fnc: (e) => __privateGet$5(this, _genImage).call(this, e), mime: "image/webp" },
      10: { ext: "mp3", fnc: (e) => e.arrayBuffer(), mime: "audio/mpeg" },
      11: { ext: "m4a", fnc: (e) => e.arrayBuffer(), mime: "audio/aac" },
      12: { ext: "ogg", fnc: (e) => e.arrayBuffer(), mime: "audio/ogg" },
      13: { ext: "aac", fnc: (e) => e.arrayBuffer(), mime: "audio/aac" },
      14: { ext: "flac", fnc: (e) => e.arrayBuffer(), mime: "audio/flac" },
      15: { ext: "wav", fnc: (e) => e.arrayBuffer(), mime: "audio/wav" },
      20: { ext: "mp4", fnc: (e) => __privateGet$5(this, _genVideo).call(this, e), mime: "video/mp4" },
      21: { ext: "webm", fnc: (e) => __privateGet$5(this, _genVideo).call(this, e), mime: "video/webm" },
      22: { ext: "ogv", fnc: (e) => __privateGet$5(this, _genVideo).call(this, e), mime: "video/ogv" }
    }), __privateAdd$5(this, _genImage, (e) => new Promise((o, R) => {
      const N = new Image();
      N.onload = () => o(N), N.onerror = (M) => R(M), N.src = URL.createObjectURL(e);
    })), __privateAdd$5(this, _genVideo, (e) => new Promise((o, R) => {
      const N = document.createElement("video");
      N.addEventListener("error", () => {
        var M, D;
        return R((D = (M = N == null ? void 0 : N.error) == null ? void 0 : M.message) != null ? D : "");
      }), N.addEventListener("canplay", () => o(N)), N.src = URL.createObjectURL(e);
    })), this.enc = (e) => e, this.stk = () => "", this.hash = (e) => "", this.isApp = !1, this.$path_downloads = "", this.$path_userdata = "", this.canCapturePage = (e) => !1;
  }
  async loaded(n, t) {
    const e = n.snsys_pre;
    return delete n.snsys_pre, e == null ? void 0 : e.init({
      addTag: () => {
      },
      addLayCls: () => {
      },
      searchPath: () => "",
      getVal: () => ({}),
      resume: () => {
      },
      render: () => {
      },
      setDec: (o) => __privateSet$5(this, _preFromPlg, o),
      setEnc: (o) => this.enc = o,
      getStK: (o) => this.stk = o,
      getHash: (o) => this.hash = o
    });
  }
  get cur() {
    return this.arg.cur;
  }
  get crypto() {
    return this.arg.crypto;
  }
  async loadPath(n, t) {
    this.cfg = t;
  }
  initVal(n, t, e) {
  }
  flush() {
  }
  async run() {
  }
  init(n, t, e, o) {
    this.val = e, this.appPixi = t;
    let R = "";
    try {
      this.val.setSys(this), R = "sys", R += Number(this.val.getVal("sys:TextLayer.Back.Alpha", 1)), R = "kidoku", this.val.saveKidoku();
    } catch (M) {
      console.error(`\u30BB\u30FC\u30D6\u30C7\u30FC\u30BF\uFF08${R}\uFF09\u304C\u58CA\u308C\u3066\u3044\u307E\u3059\u3002\u4E00\u5EA6\u30AF\u30EA\u30A2\u3059\u308B\u5FC5\u8981\u304C\u3042\u308A\u307E\u3059 %o`, M);
    }
    n.close = (M) => this.close(M), n.export = (M) => this._export(M), n.import = (M) => this._import(M), n.navigate_to = (M) => this.navigate_to(M), n.title = (M) => this.title(M), n.toggle_full_screen = (M) => __privateGet$5(this, _tglFlscr).call(this, M), n.update_check = (M) => this.update_check(M), n.window = (M) => this.window(M), e.setVal_Nochk("tmp", "const.sn.isApp", () => this.isApp), e.setVal_Nochk("tmp", "const.sn.isDbg", () => CmnLib.isDbg), e.setVal_Nochk("tmp", "const.sn.isPackaged", () => CmnLib.isPackaged), this.val.defTmp("const.sn.displayState", () => this.isFullScr), e.setVal_Nochk("sys", _SysBase.VALNM_CFG_NS, this.cfg.oCfg.save_ns), e.flush(), CmnLib.isDbg && this.attach_debug(o), this.hFactoryCls = {};
    const N = [];
    for (const M in this.hPlg)
      N.push(this.hPlg[M].init({
        addTag: (D, L) => {
          if (n[D])
            throw `\u3059\u3067\u306B\u5B9A\u7FA9\u6E08\u307F\u306E\u30BF\u30B0[${D}]\u3067\u3059`;
          n[D] = L;
        },
        addLayCls: (D, L) => {
          if (this.hFactoryCls[D])
            throw `\u3059\u3067\u306B\u5B9A\u7FA9\u6E08\u307F\u306E\u30EC\u30A4\u30E4cls\u3010${D}\u3011\u3067\u3059`;
          this.hFactoryCls[D] = L;
        },
        searchPath: (D, L = "") => this.cfg.searchPath(D, L),
        getVal: e.getVal,
        resume: () => o.resume(),
        render: (D, L, B = !1) => this.appPixi.renderer.render(D, { renderTexture: L, clear: B }),
        setDec: (D) => __privateSet$5(this, _preFromPlg, D),
        setEnc: (D) => this.enc = D,
        getStK: (D) => this.stk = D,
        getHash: (D) => this.hash = D
      }));
    return N;
  }
  get cvsWidth() {
    return __privateGet$5(this, _cvsWidth);
  }
  get cvsHeight() {
    return __privateGet$5(this, _cvsHeight);
  }
  get cvsScale() {
    return __privateGet$5(this, _cvsScale);
  }
  get ofsLeft4elm() {
    return __privateGet$5(this, _ofsLeft4elm);
  }
  get ofsTop4elm() {
    return __privateGet$5(this, _ofsTop4elm);
  }
  get ofsPadLeft_Dom2PIXI() {
    return __privateGet$5(this, _ofsPadLeft_Dom2PIXI);
  }
  get ofsPadTop_Dom2PIXI() {
    return __privateGet$5(this, _ofsPadTop_Dom2PIXI);
  }
  cvsResize() {
    var D, L;
    let n = globalThis.innerWidth, t = globalThis.innerHeight;
    const e = this.appPixi.view, o = e.parentElement !== document.body;
    if (o) {
      const B = globalThis.getComputedStyle(e);
      n = parseFloat(B.width), t = parseFloat(B.height);
    }
    if (CmnLib.isMobile) {
      const $ = ((L = (D = screen.orientation) == null ? void 0 : D.angle) != null ? L : 0) % 180 === 0;
      ($ && n > t || !$ && n < t) && ([n, t] = [t, n]);
    }
    const R = e.getBoundingClientRect();
    if (argChk_Boolean(CmnLib.hDip, "expanding", !0) || o || CmnLib.stageW > n || CmnLib.stageH > t)
      if (CmnLib.stageW / CmnLib.stageH <= n / t ? (__privateSet$5(this, _cvsHeight, t), __privateSet$5(this, _cvsWidth, CmnLib.stageW / CmnLib.stageH * t)) : (__privateSet$5(this, _cvsWidth, n), __privateSet$5(this, _cvsHeight, CmnLib.stageH / CmnLib.stageW * n)), __privateSet$5(this, _cvsScale, __privateGet$5(this, _cvsWidth) / CmnLib.stageW), o)
        __privateSet$5(this, _ofsPadLeft_Dom2PIXI, 0), __privateSet$5(this, _ofsPadTop_Dom2PIXI, 0);
      else {
        const B = 1 - __privateGet$5(this, _cvsScale);
        CmnLib.isMobile ? (__privateSet$5(this, _ofsPadLeft_Dom2PIXI, (n - __privateGet$5(this, _cvsWidth)) / 2 * B), __privateSet$5(this, _ofsPadTop_Dom2PIXI, (t - __privateGet$5(this, _cvsHeight)) / 2 * B)) : (__privateSet$5(this, _ofsPadLeft_Dom2PIXI, R.left * B), __privateSet$5(this, _ofsPadTop_Dom2PIXI, R.top * B));
      }
    else
      __privateSet$5(this, _cvsWidth, CmnLib.stageW), __privateSet$5(this, _cvsHeight, CmnLib.stageH), __privateSet$5(this, _cvsScale, 1), __privateSet$5(this, _ofsPadLeft_Dom2PIXI, 0), __privateSet$5(this, _ofsPadTop_Dom2PIXI, 0);
    const N = e.parentElement.style;
    o || (N.position = "relative", N.width = `${__privateGet$5(this, _cvsWidth)}px`, N.height = `${__privateGet$5(this, _cvsHeight)}px`);
    const M = e.style;
    M.width = N.width, M.height = N.height, __privateSet$5(this, _ofsLeft4elm, R.left), __privateSet$5(this, _ofsTop4elm, R.top), this.isFullScr && (__privateSet$5(this, _ofsLeft4elm, __privateGet$5(this, _ofsLeft4elm) + (n - __privateGet$5(this, _cvsWidth)) / 2), __privateSet$5(this, _ofsTop4elm, __privateGet$5(this, _ofsTop4elm) + (t - __privateGet$5(this, _cvsHeight)) / 2));
  }
  attach_debug(n) {
    this.attach_debug = () => {
    };
    const t = document.createElement("style");
    t.innerHTML = `/* SKYNovel Dbg */
.sn_BounceInOut { animation: sn_kfBounceInOut linear 1.5s; }
@keyframes sn_kfBounceInOut{
0%	{opacity: 0;	transform: scaleX(0.30) scaleY(0.30);}
10%	{opacity: 1;	transform: scaleX(1.10) scaleY(1.10);}
20%	{				transform: scaleX(0.95) scaleY(0.95);}
30%	{				transform: scaleX(1.00) scaleY(1.00);}
70%	{opacity: 1;}
100%{opacity: 0;}
}
.sn_BounceIn { animation: sn_kfBounceIn linear 0.3s; }
@keyframes sn_kfBounceIn{
0%	{opacity: 0;	transform: scaleX(0.30) scaleY(0.30);}
50%	{opacity: 1;	transform: scaleX(1.10) scaleY(1.10);}
100%{				transform: scaleX(0.95) scaleY(0.95);}
}
.sn_HopIn { animation: sn_kfHopIn linear 0.8s; }
@keyframes sn_kfHopIn{
0%	{transform:	translate(0px,   0px);}
15% {transform:	translate(0px, -25px);}
30% {transform:	translate(0px,   0px);}
45% {transform:	translate(0px, -15px);}
60% {transform:	translate(0px,   0px);}
75% {transform:	translate(0px,  -5px);}
100%{transform:	translate(0px,   0px);}
}`, document.getElementsByTagName("head")[0].appendChild(t), this.addHook((e, o) => {
      var R, N;
      return (N = (R = __privateGet$5(this, _hHook))[e]) == null ? void 0 : N.call(R, o);
    }), __privateSet$5(this, _sk, lookup(`http://localhost:${this.extPort}`)), __privateGet$5(this, _sk).on("data", (e, o) => {
      this.callHook(e, o);
    }).on("disconnect", () => n.setLoop(!0)), this.callHook = (e, o) => __privateGet$5(this, _aFncHook).forEach((R) => R(e, o));
  }
  end() {
    var n;
    (n = __privateGet$5(this, _sk)) == null || n.disconnect(), __privateSet$5(this, _sk, void 0);
  }
  toast(n) {
    var N, M, D;
    const t = document.body;
    t.querySelectorAll(".sn_BounceIn, .sn_HopIn").forEach((L) => t.removeChild(L));
    const e = document.createElement("img"), o = __privateGet$5(_SysBase, _hToastDat)[n];
    e.src = `data:image/svg+xml;base64,${o.dat}`;
    const R = Math.min(CmnLib.stageW, CmnLib.stageH) / 4 * __privateGet$5(this, _cvsScale);
    e.width = e.height = R, e.style.cssText = `position: absolute;
left: ${(CmnLib.stageW - R) / 2 * __privateGet$5(this, _cvsScale) + R * ((N = o.dx) != null ? N : 0)}px;
top: ${(CmnLib.stageH - R) / 2 * __privateGet$5(this, _cvsScale) + R * ((M = o.dy) != null ? M : 0)}px;`, e.classList.add("sn_toast", (D = o.ease) != null ? D : "sn_BounceInOut"), o.ease || e.addEventListener("animationend", () => t.removeChild(e), { once: !0, passive: !0 }), t.insertBefore(e, this.appPixi.view);
  }
  setFire(n) {
    this.fire = n;
  }
  addHook(n) {
    __privateGet$5(this, _aFncHook).push(n);
  }
  titleSub(n) {
  }
  tglFlscr_sub() {
  }
  setTitleInfo(n) {
    __privateSet$5(this, _info_title, n), this.titleSub(__privateGet$5(this, _main_title) + __privateGet$5(this, _info_title));
  }
  decStr(n, t) {
    return __privateGet$5(this, _preFromPlg).call(this, n, t).ret;
  }
  async dec(n, t) {
    const { ret: e, ext_num: o } = __privateGet$5(this, _preFromPlg).call(this, n, t), R = __privateGet$5(this, _hN2Ext)[o];
    return R != null && R.fnc ? await R.fnc(new Blob([e], { type: R.mime })) : e;
  }
  get path_downloads() {
    return this.$path_downloads;
  }
  get path_userdata() {
    return this.$path_userdata;
  }
  async savePic(n, t) {
  }
  async appendFile(n, t, e) {
  }
  async ensureFileSync(n) {
  }
};
let SysBase = _SysBase;
_cvsWidth = /* @__PURE__ */ new WeakMap();
_cvsHeight = /* @__PURE__ */ new WeakMap();
_cvsScale = /* @__PURE__ */ new WeakMap();
_ofsLeft4elm = /* @__PURE__ */ new WeakMap();
_ofsTop4elm = /* @__PURE__ */ new WeakMap();
_ofsPadLeft_Dom2PIXI = /* @__PURE__ */ new WeakMap();
_ofsPadTop_Dom2PIXI = /* @__PURE__ */ new WeakMap();
_sk = /* @__PURE__ */ new WeakMap();
_hHook = /* @__PURE__ */ new WeakMap();
_hToastDat = /* @__PURE__ */ new WeakMap();
_aFncHook = /* @__PURE__ */ new WeakMap();
_main_title = /* @__PURE__ */ new WeakMap();
_tglFlscr = /* @__PURE__ */ new WeakMap();
_info_title = /* @__PURE__ */ new WeakMap();
_preFromPlg = /* @__PURE__ */ new WeakMap();
_hN2Ext = /* @__PURE__ */ new WeakMap();
_genImage = /* @__PURE__ */ new WeakMap();
_genVideo = /* @__PURE__ */ new WeakMap();
SysBase.VALNM_CFG_NS = "const.sn.cfg.ns";
__privateAdd$5(SysBase, _hToastDat, {
  \u63A5\u7D9A: { dx: -1, dat: "PHN2ZyBoZWlnaHQ9IjY0MCIgcHJlc2VydmVBc3BlY3RSYXRpbz0ieE1pZFlNaWQgbWVldCIgdmlld0JveD0iMCAwIDY0MCA2NDAiIHdpZHRoPSI2NDAiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiPjxkZWZzPjxwYXRoIGlkPSJhIiBkPSJtNjQwIDMyMGMwIDE3Ni43My0xNDMuMjcgMzIwLTMyMCAzMjBzLTMyMC0xNDMuMjctMzIwLTMyMCAxNDMuMjctMzIwIDMyMC0zMjAgMzIwIDE0My4yNyAzMjAgMzIweiIvPjxwYXRoIGlkPSJiIiBkPSJtMCAyOTJ2NTUuODhoMTI3LjEzYzEyLjM3IDQ2IDU0LjEyIDc5Ljg3IDEwNCA3OS44N2g3Ny44N3YtMjE1LjYyYy00Ni43MyAwLTcyLjY4IDAtNzcuODggMC00OS43NCAwLTkxLjYyIDMzLjg3LTEwMy45OSA3OS44Ny0xNi45NSAwLTU5LjMzIDAtMTI3LjEzIDB6Ii8+PHBhdGggaWQ9ImMiIGQ9Im01MTIuODggMjkyYy0xMi4zOC00Ni01NC4xMy03OS44Ny0xMDQtNzkuODctNS4yMSAwLTMxLjIxIDAtNzggMHYyMTUuNzRoNzcuODdjNDkuODggMCA5MS43NS0zMy44NyAxMDQtNzkuODdoMTI3LjI1di01NmMtNzYuMjcgMC0xMTguNjUgMC0xMjcuMTIgMHoiLz48L2RlZnM+PHVzZSBmaWxsPSIjMmUyZTJlIiB4bGluazpocmVmPSIjYSIvPjx1c2UgZmlsbD0ibm9uZSIgeGxpbms6aHJlZj0iI2EiLz48dXNlIGZpbGw9IiMzYWFiZDIiIHhsaW5rOmhyZWY9IiNiIi8+PHVzZSBmaWxsPSJub25lIiB4bGluazpocmVmPSIjYiIvPjx1c2UgZmlsbD0iIzNhYWJkMiIgeGxpbms6aHJlZj0iI2MiLz48dXNlIGZpbGw9Im5vbmUiIHhsaW5rOmhyZWY9IiNjIi8+PC9zdmc+" },
  \u5207\u65AD: { dat: "PHN2ZyBoZWlnaHQ9IjY0MCIgcHJlc2VydmVBc3BlY3RSYXRpbz0ieE1pZFlNaWQgbWVldCIgdmlld0JveD0iMCAwIDY0MCA2NDAiIHdpZHRoPSI2NDAiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiPjxkZWZzPjxwYXRoIGlkPSJhIiBkPSJtNjQwIDMyMGMwIDE3Ni43My0xNDMuMjcgMzIwLTMyMCAzMjBzLTMyMC0xNDMuMjctMzIwLTMyMCAxNDMuMjctMzIwIDMyMC0zMjAgMzIwIDE0My4yNyAzMjAgMzIweiIvPjxwYXRoIGlkPSJiIiBkPSJtMTkxLjUzIDIyMS4yNGMtNDUuNjggMC04NC4wMSAzMS4wNC05NS4zIDczLjE2LTYuNDEgMC0zOC40OSAwLTk2LjIzIDB2NTEuMjFoOTYuMjNjMTEuMyA0Mi4xMSA0OS42MyA3My4xNiA5NS4zIDczLjE2aDcxLjMzdi00OC4yNGg1My43OHYtMTAxLjA1aC01My43OHYtNDguMjRjLTQyLjggMC02Ni41NyAwLTcxLjMzIDB6Ii8+PHBhdGggaWQ9ImMiIGQ9Im00NDguNDcgMjIxLjIzYy00Ljc2IDAtMjguNTMgMC03MS4zMyAwdjE5Ny41M2g3MS4zM2M0NS42OCAwIDgzLjk5LTMxLjA0IDk1LjI5LTczLjE1aDk2LjI0di01MS4yMWgtOTYuMjRjLTMzLjA4LTQ4Ljc4LTY0Ljg0LTczLjE3LTk1LjI5LTczLjE3eiIvPjwvZGVmcz48dXNlIGZpbGw9IiMyZTJlMmUiIHhsaW5rOmhyZWY9IiNhIi8+PHVzZSBmaWxsPSJub25lIiB4bGluazpocmVmPSIjYSIvPjx1c2UgZmlsbD0iI2RmNTY1NiIgeGxpbms6aHJlZj0iI2IiLz48dXNlIGZpbGw9Im5vbmUiIHhsaW5rOmhyZWY9IiNiIi8+PHVzZSBmaWxsPSIjZGY1NjU2IiB4bGluazpocmVmPSIjYyIvPjx1c2UgZmlsbD0ibm9uZSIgeGxpbms6aHJlZj0iI2MiLz48L3N2Zz4=" },
  \u518D\u751F: { dat: "PHN2ZyBoZWlnaHQ9IjY0MCIgcHJlc2VydmVBc3BlY3RSYXRpbz0ieE1pZFlNaWQgbWVldCIgdmlld0JveD0iMCAwIDY0MCA2NDAiIHdpZHRoPSI2NDAiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiPjxkZWZzPjxwYXRoIGlkPSJhIiBkPSJtMCAzMjBjMCAxNzYuNzIgMTQzLjI4IDMyMCAzMjAgMzIwczMyMC0xNDMuMjggMzIwLTMyMC0xNDMuMjgtMzIwLTMyMC0zMjAtMzIwIDE0My4yOC0zMjAgMzIwem0yNTguODMgMTExLjA1Yy0xLjI5Ljc5LTIuOTMuODMtNC4yNi4wNC0xLjI5LS43NC0yLjExLTIuMTItMi4xMS0zLjY3IDAtNy4xNiAwLTQyLjk3IDAtMTA3LjQzczAtMTAwLjI3IDAtMTA3LjQzYzAtMS41My44Mi0yLjkzIDIuMTEtMy42OCAxLjMzLS43NiAyLjk3LS43MiA0LjI2LjA0IDE4IDEwLjc1IDE2MiA5Ni43MSAxODAgMTA3LjQ2IDEuMjkuNzMgMi4wNSAyLjE0IDIuMDUgMy42MSAwIDEuNDktLjc2IDIuODgtMi4wNSAzLjYzLTM2IDIxLjQ5LTE2MiA5Ni42OS0xODAgMTA3LjQzeiIvPjwvZGVmcz48cGF0aCBkPSJtMTU0LjU3IDE3MC4xOWgzNDYuMTV2MzA3LjY5aC0zNDYuMTV6IiBmaWxsPSIjZmZmIi8+PHVzZSBmaWxsPSIjMmUyZTJlIiB4bGluazpocmVmPSIjYSIvPjx1c2UgZmlsbD0ibm9uZSIgeGxpbms6aHJlZj0iI2EiLz48L3N2Zz4=" },
  \u4E00\u6642\u505C\u6B62: { dat: "PHN2ZyBoZWlnaHQ9IjY0MCIgcHJlc2VydmVBc3BlY3RSYXRpbz0ieE1pZFlNaWQgbWVldCIgdmlld0JveD0iMCAwIDY0MCA2NDAiIHdpZHRoPSI2NDAiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiPjxkZWZzPjxwYXRoIGlkPSJhIiBkPSJtMCAzMjBjMCAxNzYuNzIgMTQzLjI4IDMyMCAzMjAgMzIwczMyMC0xNDMuMjggMzIwLTMyMC0xNDMuMjgtMzIwLTMyMC0zMjAtMzIwIDE0My4yOC0zMjAgMzIwem0yMDAgMTAwdi0yMDBoODB2MjAwem0xNjAgMHYtMjAwaDgwdjIwMHoiLz48L2RlZnM+PHBhdGggZD0ibTE0Ny40OSAxODAuNDFoMzUyLjR2MjgyLjY5aC0zNTIuNHoiIGZpbGw9IiNmZmYiLz48dXNlIGZpbGw9IiMyZTJlMmUiIHhsaW5rOmhyZWY9IiNhIi8+PHVzZSBmaWxsPSJub25lIiB4bGluazpocmVmPSIjYSIvPjwvc3ZnPg==" },
  \u6CE8\u610F: { ease: "sn_HopIn", dat: "PHN2ZyBoZWlnaHQ9IjY0MCIgcHJlc2VydmVBc3BlY3RSYXRpbz0ieE1pZFlNaWQgbWVldCIgdmlld0JveD0iMCAwIDY0MCA2NDAiIHdpZHRoPSI2NDAiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiPjxkZWZzPjxwYXRoIGlkPSJhIiBkPSJtMzQzLjM0IDI5LjJjLTEwLjM3LTE3Ljk3LTM2LjMxLTE3Ljk3LTQ2LjY5IDAtMjkuMyA1MC43NS0yNjMuNyA0NTYuNzQtMjkzIDUwNy40OS0xMC4zNyAxNy45NyAyLjU5IDQwLjQ0IDIzLjM0IDQwLjQ0aDU4Ni4wMWMyMC43NSAwIDMzLjcyLTIyLjQ2IDIzLjM1LTQwLjQ0LTU4LjYtMTAxLjUtMjYzLjctNDU2Ljc0LTI5My4wMS01MDcuNDl6bS0yMy4zNCA0ODIuODNjLTE0LjUyIDAtMjYuMjktMi43MS0yNi4yOS02LjA2IDAtNC4yMSAwLTM3Ljg2IDAtNDIuMDcgMC0zLjM1IDExLjc3LTYuMDcgMjYuMjktNi4wN3MyNi4yOSAyLjcyIDI2LjI5IDYuMDd2NDIuMDdjLTcuODQgNC4wNC0xNi42MSA2LjA2LTI2LjI5IDYuMDZ6bTIxLjk5LTEwMy44NGMwIDUuNDMtOS44NSA5LjgzLTIxLjk5IDkuODMtMTIuMTUgMC0yMS45OS00LjQtMjEuOTktOS44MyAwLS4xMy4wNy0uMjUuMDgtLjM4LTEuMzctMTcuNTYtMTIuMy0xNTguMDYtMTMuNjctMTc1LjYyIDAtNS40MyAxNS45My05Ljg0IDM1LjU4LTkuODRzMzUuNTggNC40MSAzNS41OCA5Ljg0Yy0uOTEgMTEuNy01LjQ3IDcwLjI1LTEzLjY3IDE3NS42Mi4wNi4xNi4wOC4yOS4wOC4zOHoiLz48L2RlZnM+PHBhdGggZD0ibTI0MS4yOSAxOTEuNDRoMTQ1LjQ5djM1MS42NmgtMTQ1LjQ5eiIgZmlsbD0iI2ZmZiIvPjx1c2UgZmlsbD0iI2QyYmYzYSIgeGxpbms6aHJlZj0iI2EiLz48dXNlIGZpbGw9Im5vbmUiIHhsaW5rOmhyZWY9IiNhIi8+PC9zdmc+" },
  \u4E00\u6B69\u9032\u3080: { ease: "sn_BounceIn", dat: "PHN2ZyBoZWlnaHQ9IjY0MCIgcHJlc2VydmVBc3BlY3RSYXRpbz0ieE1pZFlNaWQgbWVldCIgdmlld0JveD0iMCAwIDY0MCA2NDAiIHdpZHRoPSI2NDAiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiPjxkZWZzPjxwYXRoIGlkPSJhIiBkPSJtMCAzMjBjMCAxNzYuNzIgMTQzLjI4IDMyMCAzMjAgMzIwczMyMC0xNDMuMjggMzIwLTMyMC0xNDMuMjgtMzIwLTMyMC0zMjAtMzIwIDE0My4yOC0zMjAgMzIwem0zNzYuOTMgOTEuOTdjMC01My41MSAwLTgzLjI0IDAtODkuMTktLjE1LjE0LS4yNS4zNC0uNDQuNDUtMTYuMTEgOS42Mi0xNDQuOTUgODYuNTQtMTYxLjA2IDk2LjE1LTEuMTUuNjktMi42Mi43My0zLjgxLjAyLTEuMTUtLjY0LTEuODktMS44OS0xLjg5LTMuMjggMC02LjQxIDAtMzguNDQgMC05Ni4xMSAwLTU3LjY5IDAtODkuNzQgMC05Ni4xNSAwLTEuMzUuNzQtMi42MiAxLjg5LTMuMjkgMS4xOS0uNjggMi42Ni0uNjQgMy44MS4wNCAxNi4xMSA5LjYyIDE0NC45NSA4Ni41NCAxNjEuMDYgOTYuMTYuMTkuMS4yOS4zMS40NC40NSAwLTYuMTMgMC0zNi43NyAwLTkxLjkyaDUzLjMydjE4Ni42N3oiLz48L2RlZnM+PHBhdGggZD0ibTE0Ny40OSAxNTQuMmgzNTIuNHYzMDguOWgtMzUyLjR6IiBmaWxsPSIjZmZmIi8+PHVzZSBmaWxsPSIjMmUyZTJlIiB4bGluazpocmVmPSIjYSIvPjx1c2UgZmlsbD0ibm9uZSIgeGxpbms6aHJlZj0iI2EiLz48L3N2Zz4=" },
  \u4E00\u6B69\u623B\u308B: { ease: "sn_BounceIn", dat: "PHN2ZyBoZWlnaHQ9IjY0MCIgcHJlc2VydmVBc3BlY3RSYXRpbz0ieE1pZFlNaWQgbWVldCIgdmlld0JveD0iMCAwIDY0MCA2NDAiIHdpZHRoPSI2NDAiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiPjxkZWZzPjxwYXRoIGlkPSJhIiBkPSJtMCAzMjBjMCAxNzYuNzIgMTQzLjI4IDMyMCAzMjAgMzIwczMyMC0xNDMuMjggMzIwLTMyMC0xNDMuMjgtMzIwLTMyMC0zMjAtMzIwIDE0My4yOC0zMjAgMzIwem00MzAuMjcgOTYuMTRjMCAxLjM1LS43NCAyLjYyLTEuODkgMy4yOC0xLjE5LjY5LTIuNjYuNjUtMy44MS0uMDMtMTYuMTEtOS42Mi0xNDQuOTUtODYuNTQtMTYxLjA1LTk2LjE2LS4yLS4xLS4yOS0uMzEtLjQ1LS40NXY5MS45MmgtNTMuMzJ2LTE4Ni42N2g1My4zMnY4OS4xOWMuMTYtLjE0LjI1LS4zNC40NS0uNDUgMTYuMS05LjYyIDE0NC45NC04Ni41NCAxNjEuMDUtOTYuMTYgMS4xNS0uNjggMi42Mi0uNzIgMy44MS0uMDEgMS4xNS42NCAxLjg5IDEuODkgMS44OSAzLjI4djk2LjExeiIvPjwvZGVmcz48cGF0aCBkPSJtMTQ3LjQ5IDE1NC4yaDM1Mi40djMwOC45aC0zNTIuNHoiIGZpbGw9IiNmZmYiLz48dXNlIGZpbGw9IiMyZTJlMmUiIHhsaW5rOmhyZWY9IiNhIi8+PHVzZSBmaWxsPSJub25lIiB4bGluazpocmVmPSIjYSIvPjwvc3ZnPg==" },
  \u30B9\u30C6\u30C3\u30D5\u309A\u30A4\u30F3: { ease: "sn_BounceIn", dat: "PHN2ZyBoZWlnaHQ9IjY0MCIgcHJlc2VydmVBc3BlY3RSYXRpbz0ieE1pZFlNaWQgbWVldCIgdmlld0JveD0iMCAwIDY0MCA2NDAiIHdpZHRoPSI2NDAiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiPjxkZWZzPjxwYXRoIGlkPSJhIiBkPSJtMCAzMTkuOTljMCAxNzYuNzQgMTQzLjI3IDMyMC4wMSAzMjAuMDEgMzIwLjAxIDE3Ni43MiAwIDMxOS45OS0xNDMuMjcgMzE5Ljk5LTMyMC4wMSAwLTE3Ni43Mi0xNDMuMjctMzE5Ljk5LTMxOS45OS0zMTkuOTktMTc2Ljc0IDAtMzIwLjAxIDE0My4yNy0zMjAuMDEgMzE5Ljk5em0xNTMuMDUtMjkuNzIgNTUuMTItNTUuMTMgMTExLjg0IDExMS44MiAxMTEuODItMTExLjgyIDU1LjEyIDU1LjEyLTE2Ni45NCAxNjYuOTd6Ii8+PC9kZWZzPjxwYXRoIGQ9Im0xNDcuNDkgMTU0LjJoMzUyLjR2MzA4LjloLTM1Mi40eiIgZmlsbD0iI2ZmZiIvPjx1c2UgZmlsbD0iIzJlMmUyZSIgeGxpbms6aHJlZj0iI2EiLz48dXNlIGZpbGw9Im5vbmUiIHhsaW5rOmhyZWY9IiNhIi8+PC9zdmc+" },
  \u30B9\u30C6\u30C3\u30D5\u309A\u30A2\u30A6\u30C8: { ease: "sn_BounceIn", dat: "PHN2ZyBoZWlnaHQ9IjY0MCIgcHJlc2VydmVBc3BlY3RSYXRpbz0ieE1pZFlNaWQgbWVldCIgdmlld0JveD0iMCAwIDY0MCA2NDAiIHdpZHRoPSI2NDAiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiPjxkZWZzPjxwYXRoIGlkPSJhIiBkPSJtMCAzMjAuMDFjMCAxNzYuNzIgMTQzLjI3IDMxOS45OSAzMTkuOTkgMzE5Ljk5IDE3Ni43NCAwIDMyMC4wMS0xNDMuMjcgMzIwLjAxLTMxOS45OSAwLTE3Ni43NC0xNDMuMjctMzIwLjAxLTMyMC4wMS0zMjAuMDEtMTc2LjcyIDAtMzE5Ljk5IDE0My4yNy0zMTkuOTkgMzIwLjAxem0zMTkuOTktMjYuOTgtMTExLjgyIDExMS44My01NS4xMi01NS4xMyAxNjYuOTQtMTY2Ljk2IDE2Ni45NiAxNjYuOTYtNTUuMTIgNTUuMTN6Ii8+PC9kZWZzPjxwYXRoIGQ9Im0xNDcuNDkgMTU0LjJoMzUyLjR2MzA4LjloLTM1Mi40eiIgZmlsbD0iI2ZmZiIvPjx1c2UgZmlsbD0iIzJlMmUyZSIgeGxpbms6aHJlZj0iI2EiLz48dXNlIGZpbGw9Im5vbmUiIHhsaW5rOmhyZWY9IiNhIi8+PC9zdmc+" }
});
var __accessCheck$4 = (n, t, e) => {
  if (!t.has(n))
    throw TypeError("Cannot " + e);
}, __privateGet$4 = (n, t, e) => (__accessCheck$4(n, t, "read from private field"), e ? e.call(n) : t.get(n)), __privateAdd$4 = (n, t, e) => {
  if (t.has(n))
    throw TypeError("Cannot add the same private member more than once");
  t instanceof WeakSet ? t.add(n) : t.set(n, e);
}, __privateSet$4 = (n, t, e, o) => (__accessCheck$4(n, t, "write to private field"), o ? o.call(n, e) : t.set(n, e), e), _existsBreakline, _existsBreakpage, _REG_PATH;
const _Config = class {
  constructor(n) {
    this.sys = n, this.oCfg = {
      save_ns: "",
      window: {
        width: 300,
        height: 300
      },
      book: {
        title: "",
        creator: "",
        cre_url: "",
        publisher: "",
        pub_url: "",
        detail: "",
        version: "1.0"
      },
      log: { max_len: 1024 },
      init: {
        bg_color: "#000000",
        tagch_msecwait: 10,
        auto_msecpagewait: 3500,
        escape: ""
      },
      debug: {
        devtool: !1,
        token: !1,
        tag: !1,
        putCh: !1,
        debugLog: !1,
        baseTx: !1,
        masume: !1,
        variable: !1
      },
      code: {},
      debuger_token: ""
    }, this.userFnTail = "", this.hPathFn2Exts = {}, __privateAdd$4(this, _existsBreakline, !1), __privateAdd$4(this, _existsBreakpage, !1), __privateAdd$4(this, _REG_PATH, /([^\/\s]+)\.([^\d]\w+)/);
  }
  static async generate(n) {
    const t = new _Config(n), e = n.cur + "prj.json", o = await (await n.fetch(e)).text(), R = JSON.parse(n.decStr(e, o));
    return await t.load(R), t;
  }
  async load(n) {
    var t, e, o, R, N, M, D, L;
    if (this.oCfg.save_ns = (t = n == null ? void 0 : n.save_ns) != null ? t : this.oCfg.save_ns, CmnLib.stageW = this.oCfg.window.width = Number((o = (e = n == null ? void 0 : n.window) == null ? void 0 : e.width) != null ? o : this.oCfg.window.width), CmnLib.stageH = this.oCfg.window.height = Number((N = (R = n == null ? void 0 : n.window) == null ? void 0 : R.height) != null ? N : this.oCfg.window.height), this.oCfg.book = { ...this.oCfg.book, ...n.book }, this.oCfg.log.max_len = (L = (D = (M = n.log) == null ? void 0 : M.max_len) == null ? void 0 : D.max_len) != null ? L : this.oCfg.log.max_len, this.oCfg.init = { ...this.oCfg.init, ...n.init }, this.oCfg.debug = { ...this.oCfg.debug, ...n.debug }, CmnLib.debugLog = this.oCfg.debug.debugLog, this.oCfg.debuger_token = n.debuger_token, await this.sys.loadPath(this.hPathFn2Exts, this), __privateSet$4(this, _existsBreakline, this.matchPath("^breakline$", _Config.EXT_SPRITE).length > 0), __privateSet$4(this, _existsBreakpage, this.matchPath("^breakpage$", _Config.EXT_SPRITE).length > 0), this.sys.crypto)
      for (const B in this.hPathFn2Exts) {
        const $ = this.hPathFn2Exts[B];
        for (const k in $) {
          if (k.slice(-10) !== ":RIPEMD160")
            continue;
          const U = $[k].slice($[k].lastIndexOf("/") + 1), z = $[k.slice(0, -10)], V = await (await this.sys.fetch(z)).text(), W = this.sys.hash(V);
          if (U !== W)
            throw `\u30D5\u30A1\u30A4\u30EB\u6539\u7AC4\u30A8\u30E9\u30FC\u3067\u3059 fn:${z}`;
        }
      }
  }
  get existsBreakline() {
    return __privateGet$4(this, _existsBreakline);
  }
  get existsBreakpage() {
    return __privateGet$4(this, _existsBreakpage);
  }
  getNs() {
    return `skynovel.${this.oCfg.save_ns} - `;
  }
  searchPath(n, t = "") {
    if (!n)
      throw "[searchPath] fn\u304C\u7A7A\u3067\u3059";
    if (n.slice(0, 7) === "http://")
      return n;
    if (n.slice(0, 11) === "downloads:/") {
      const D = this.sys.path_downloads + n.slice(11);
      return this.sys.ensureFileSync(D), D;
    }
    if (n.slice(0, 10) === "userdata:/") {
      const D = this.sys.path_userdata + "storage/" + n.slice(10);
      return this.sys.ensureFileSync(D), D;
    }
    const e = n.match(__privateGet$4(this, _REG_PATH));
    let o = e ? e[1] : n;
    const R = e ? e[2] : "";
    if (this.userFnTail) {
      const D = o + "@@" + this.userFnTail;
      if (D in this.hPathFn2Exts) {
        if (t === "")
          o = D;
        else
          for (let L in this.hPathFn2Exts[D])
            if (`|${t}|`.indexOf(`|${L}|`) !== -1) {
              o = D;
              break;
            }
      }
    }
    const N = this.hPathFn2Exts[o];
    if (!N)
      throw `\u30B5\u30FC\u30C1\u30D1\u30B9\u306B\u5B58\u5728\u3057\u306A\u3044\u30D5\u30A1\u30A4\u30EB\u3010${n}\u3011\u3067\u3059`;
    let M = "";
    if (!R) {
      const D = int(N[":cnt"]);
      if (t === "") {
        if (D > 1)
          throw `\u6307\u5B9A\u30D5\u30A1\u30A4\u30EB\u3010${n}\u3011\u304C\u8907\u6570\u30DE\u30C3\u30C1\u3057\u307E\u3059\u3002\u30B5\u30FC\u30C1\u5BFE\u8C61\u62E1\u5F35\u5B50\u7FA4\u3010${t}\u3011\u3067\u7D5E\u308A\u8FBC\u3080\u304B\u3001\u30D5\u30A1\u30A4\u30EB\u540D\u3092\u500B\u5225\u306B\u3057\u3066\u4E0B\u3055\u3044\u3002`;
        return n;
      }
      const L = `|${t}|`;
      if (D > 1) {
        let B = 0;
        for (const $ in N)
          if (L.indexOf(`|${$}|`) !== -1 && ++B > 1)
            throw `\u6307\u5B9A\u30D5\u30A1\u30A4\u30EB\u3010${n}\u3011\u304C\u8907\u6570\u30DE\u30C3\u30C1\u3057\u307E\u3059\u3002\u30B5\u30FC\u30C1\u5BFE\u8C61\u62E1\u5F35\u5B50\u7FA4\u3010${t}\u3011\u3067\u7D5E\u308A\u8FBC\u3080\u304B\u3001\u30D5\u30A1\u30A4\u30EB\u540D\u3092\u500B\u5225\u306B\u3057\u3066\u4E0B\u3055\u3044\u3002`;
      }
      for (let B in N)
        if (L.indexOf(`|${B}|`) > -1)
          return N[B];
      throw `\u30B5\u30FC\u30C1\u5BFE\u8C61\u62E1\u5F35\u5B50\u7FA4\u3010${t}\u3011\u306B\u30DE\u30C3\u30C1\u3059\u308B\u30D5\u30A1\u30A4\u30EB\u304C\u30B5\u30FC\u30C1\u30D1\u30B9\u306B\u5B58\u5728\u3057\u307E\u305B\u3093\u3002\u63A2\u7D22\u30D5\u30A1\u30A4\u30EB\u540D=\u3010${n}\u3011`;
    }
    if (t !== "" && `|${t}|`.indexOf(`|${R}|`) === -1)
      throw `\u6307\u5B9A\u30D5\u30A1\u30A4\u30EB\u306E\u62E1\u5F35\u5B50\u3010${R}\u3011\u306F\u3001\u30B5\u30FC\u30C1\u5BFE\u8C61\u62E1\u5F35\u5B50\u7FA4\u3010${t}\u3011\u306B\u30DE\u30C3\u30C1\u3057\u307E\u305B\u3093\u3002\u63A2\u7D22\u30D5\u30A1\u30A4\u30EB\u540D=\u3010${n}\u3011`;
    if (M = N[R], !M)
      throw `\u30B5\u30FC\u30C1\u30D1\u30B9\u306B\u5B58\u5728\u3057\u306A\u3044\u62E1\u5F35\u5B50\u3010${R}\u3011\u3067\u3059\u3002\u63A2\u7D22\u30D5\u30A1\u30A4\u30EB\u540D=\u3010${n}\u3011\u3001\u30B5\u30FC\u30C1\u5BFE\u8C61\u62E1\u5F35\u5B50\u7FA4\u3010${t}\u3011`;
    return M;
  }
  matchPath(n, t = "") {
    const e = [], o = new RegExp(n), R = new RegExp(t);
    for (let N in this.hPathFn2Exts) {
      if (N.search(o) === -1)
        continue;
      const M = this.hPathFn2Exts[N];
      if (t === "") {
        e.push(M);
        continue;
      }
      const D = {};
      let L = !1;
      for (const B in M)
        B.search(R) !== -1 && (D[B] = N, L = !0);
      L && e.push(D);
    }
    return e;
  }
  addPath(n, t) {
    const e = {};
    for (const o in t)
      e[o] = (o.charAt(0) === ":" ? "" : this.sys.cur) + t[o];
    this.hPathFn2Exts[n] = e;
  }
};
let Config = _Config;
_existsBreakline = /* @__PURE__ */ new WeakMap();
_existsBreakpage = /* @__PURE__ */ new WeakMap();
_REG_PATH = /* @__PURE__ */ new WeakMap();
Config.EXT_SPRITE = "png|jpg|jpeg|json|svg|webp|mp4|webm";
Config.EXT_SCRIPT = "sn|ssn";
Config.EXT_FONT = "woff2|woff|otf|ttf";
Config.EXT_SOUND = "mp3|m4a|ogg|aac|flac|wav";
Config.EXT_HTML = "htm|html";
var Yi, Vr, Sa;
const di = class {
  constructor() {
    it(this, Vr, () => {
    });
  }
  static setting(t) {
    t.sesame && et(di, Yi, t.sesame);
  }
  static getSesame() {
    return H(di, Yi);
  }
  static destroy() {
    et(di, Yi, "\u30FD");
  }
  init(t) {
    et(this, Vr, t);
  }
  static setEscape(t) {
    et(di, Sa, new RegExp(
      `${t ? `(?<ce>\\${t}\\S)|` : ""}\uFF5C(?<str>[^\u300A\\n]+)\u300A(?<ruby>[^\u300B\\n]+)\u300B|(?:(?<kan>[\u2E80-\u2FDF\u3005\u3007\u303B\u3400-\u9FFF\u8C48-\uFAFF]+[\u3041-\u30FF]*|[^\u3000\uFF5C\u300A\u300B\\n])\u300A(?<kan_ruby>[^\u300B\\n]+)\u300B)|(?<txt>[\uD800-\uDBFF][\uDC00-\uDFFF]|[^\u3000\uFF5C\u300A\u300B]+(?=\uFF5C)|[^\u3000\uFF5C\u300A\u300B]*[\u3041-\u30FF](?=[\u2E80-\u2FDF\u3005\u3007\u303B\u3400-\u9FFF\u8C48-\uFAFF]+\u300A)|.)`,
      "gs"
    ));
  }
  putTxt(t) {
    var o;
    let e = null;
    for (; e = H(di, Sa).exec(t); ) {
      const R = e == null ? void 0 : e.groups;
      if (!R)
        continue;
      const N = R.ruby;
      if (N) {
        this.putTxtRb(R.str, N);
        continue;
      }
      const M = R.kan_ruby;
      if (M) {
        this.putTxtRb(R.kan, M);
        continue;
      }
      if (R.ce) {
        H(this, Vr).call(this, R.ce.slice(1), "");
        continue;
      }
      Array.from((o = R.txt) != null ? o : "").forEach((D) => H(this, Vr).call(this, D, ""));
    }
  }
  putTxtRb(t, e) {
    const o = Array.from(t), R = o.length;
    if (e.charAt(0) === "*" && e.length <= 2) {
      const L = "center\uFF5C" + (e === "*" ? H(di, Yi) : e.charAt(1));
      for (let B = 0; B < R; ++B)
        H(this, Vr).call(this, o[B], L);
      return;
    }
    if (R === 1 || e.indexOf(" ") === -1) {
      H(this, Vr).call(this, t, e.replaceAll("	", " "));
      return;
    }
    const N = e.split(" "), M = N.length, D = M > R ? M : R;
    for (let L = 0; L < D; ++L)
      H(this, Vr).call(this, L < R ? o[L] : "", L < M ? N[L].replaceAll("	", " ") : "");
  }
};
let RubySpliter = di;
Yi = new WeakMap(), Vr = new WeakMap(), Sa = new WeakMap(), it(RubySpliter, Yi, "\u30FD"), it(RubySpliter, Sa, void 0);
const REG_TAG = /(?<name>[^\s;\]]+)/;
function tagToken2Name_Args(n) {
  const t = REG_TAG.exec(n.slice(1, -1)), e = t == null ? void 0 : t.groups;
  if (!e)
    throw `\u30BF\u30B0\u8A18\u8FF0\u3010${n}\u3011\u7570\u5E38\u3067\u3059(\u30BF\u30B0\u89E3\u6790)`;
  const o = e.name;
  return [o, n.slice(1 + o.length, -1)];
}
function tagToken2Name(n) {
  const t = REG_TAG.exec(n.slice(1)), e = t == null ? void 0 : t.groups;
  if (!e)
    throw `\u30BF\u30B0\u8A18\u8FF0\u3010${n}\u3011\u7570\u5E38\u3067\u3059(\u30BF\u30B0\u89E3\u6790)`;
  return e.name;
}
function splitAmpersand(n) {
  const t = n.replaceAll("==", "\uFF1D").replaceAll("!=", "\u2260").split("="), e = t.length;
  if (e < 2 || e > 3)
    throw "\u300C&\u8A08\u7B97\u300D\u66F8\u5F0F\u3067\u306F\u300C=\u300D\u6307\u5B9A\u304C\u4E00\u3064\u304B\u4E8C\u3064\u5FC5\u8981\u3067\u3059";
  if (t[1].charAt(0) === "&")
    throw "\u300C&\u8A08\u7B97\u300D\u66F8\u5F0F\u3067\u306F\u300C&\u300D\u6307\u5B9A\u304C\u4E0D\u8981\u3067\u3059";
  return {
    name: t[0].replaceAll("\uFF1D", "==").replaceAll("\u2260", "!="),
    text: t[1].replaceAll("\uFF1D", "==").replaceAll("\u2260", "!="),
    cast: e === 3 ? t[2].trim() : void 0
  };
}
var qi, Wn, Yn, qn, $e;
class Grammar {
  constructor() {
    it(this, qi, void 0);
    it(this, Wn, void 0);
    it(this, Yn, void 0);
    it(this, qn, void 0);
    it(this, $e, void 0);
    et(this, Wn, new RegExp("")), et(this, Yn, ""), et(this, qn, ""), this.replaceScr_C2M_And_let_ml = (t, e = 0) => {
      if (!!H(this, $e)) {
        for (let o = t.len - 1; o >= e; --o) {
          const R = t.aToken[o];
          if (this.REG_TOKEN_NOTXT.test(R.charAt(0)))
            continue;
          const N = t.aLNum[o], M = R.match(H(this, Wn));
          if (!M)
            continue;
          let D = 1;
          for (let L = M.length - 1; L >= 0; --L) {
            let B = M[L];
            const $ = H(this, $e)[B.charAt(0)];
            $ && (B = $ + ($.slice(-1) === "]" ? "" : `'${B.slice(1, -1)}']`)), t.aToken.splice(o, D, B), t.aLNum.splice(o, D, N), D = 0;
          }
        }
        t.len = t.aToken.length;
      }
    }, this.setEscape("");
  }
  setEscape(t) {
    if (H(this, $e) && t in H(this, $e))
      throw "[\u30A8\u30B9\u30B1\u30FC\u30D7\u6587\u5B57] char\u3010" + t + "\u3011\u304C\u767B\u9332\u6E08\u307F\u306E\u62EC\u5F27\u30DE\u30AF\u30ED\u307E\u305F\u306F\u4E00\u6587\u5B57\u30DE\u30AF\u30ED\u3067\u3059";
    const e = t != null ? t : "\\";
    this.REG_TOKEN = new RegExp(
      (t ? `\\${t}\\S|` : "") + `\\n+|\\t+|\\[let_ml\\s+[^\\]]+\\].+?(?=\\[endlet_ml[\\]\\s])|\\[(?:[^"'#;\\]]+|` + (e ? `(?:"(?:\\${e}["'#\\n]|[^"])*"|'(?:\\${e}["'#\\n]|[^'])*'|\\#(?:\\${e}["'#\\n]|[^#])*\\#)` : `(["'#]).*?\\1`) + `|;[^\\n]*)*?]|;[^\\n]*|&[^&\\n]+&|&&?[^;\\n\\t&]+|^\\*\\w+|[^\\n\\t\\[;${t ? `\\${t}` : ""}]+`,
      "gs"
    ), RubySpliter.setEscape(t), et(this, qi, new RegExp(`[\\w\\s;[\\]*=&\uFF5C\u300A\u300B${t ? `\\${t}` : ""}]`)), this.REG_TOKEN_NOTXT = new RegExp(`[\\n\\t;\\[*&${t ? `\\${t}` : ""}]`);
  }
  matchToken(t) {
    var e;
    return (e = t.match(this.REG_TOKEN)) != null ? e : [];
  }
  bracket2macro(t, e, o) {
    var L;
    const { name: R, text: N } = t;
    if (!R)
      throw "[bracket2macro] name\u306F\u5FC5\u9808\u3067\u3059";
    if (!N)
      throw "[bracket2macro] text\u306F\u5FC5\u9808\u3067\u3059";
    if (N.length !== 2)
      throw "[bracket2macro] text\u306F\u62EC\u5F27\u306E\u524D\u5F8C\u3092\u793A\u3059\u4E8C\u6587\u5B57\u3092\u6307\u5B9A\u3057\u3066\u304F\u3060\u3055\u3044";
    (L = H(this, $e)) != null || et(this, $e, {});
    const M = N.charAt(0), D = N.charAt(1);
    if (M in H(this, $e))
      throw "[bracket2macro] text\u3010" + M + "\u3011\u304C\u767B\u9332\u6E08\u307F\u306E\u62EC\u5F27\u30DE\u30AF\u30ED\u307E\u305F\u306F\u4E00\u6587\u5B57\u30DE\u30AF\u30ED\u3067\u3059";
    if (D in H(this, $e))
      throw "[bracket2macro] text\u3010" + D + "\u3011\u304C\u767B\u9332\u6E08\u307F\u306E\u62EC\u5F27\u30DE\u30AF\u30ED\u307E\u305F\u306F\u4E00\u6587\u5B57\u30DE\u30AF\u30ED\u3067\u3059";
    if (H(this, qi).test(M))
      throw "[bracket2macro] text\u3010" + M + "\u3011\u306F\u62EC\u5F27\u30DE\u30AF\u30ED\u306B\u4F7F\u7528\u3067\u304D\u306A\u3044\u6587\u5B57\u3067\u3059";
    if (H(this, qi).test(D))
      throw "[bracket2macro] text\u3010" + D + "\u3011\u306F\u62EC\u5F27\u30DE\u30AF\u30ED\u306B\u4F7F\u7528\u3067\u304D\u306A\u3044\u6587\u5B57\u3067\u3059";
    H(this, $e)[D] = "0", H(this, $e)[M] = `[${R} text=`, this.addC2M(`\\${M}[^\\${D}]*\\${D}`, `\\${M}\\${D}`), this.replaceScr_C2M_And_let_ml(e, o);
  }
  char2macro(t, e, o, R) {
    var D;
    const { char: N, name: M } = t;
    if (!N)
      throw "[char2macro] char\u306F\u5FC5\u9808\u3067\u3059";
    if ((D = H(this, $e)) != null || et(this, $e, {}), N in H(this, $e))
      throw "[char2macro] char\u3010" + N + "\u3011\u304C\u767B\u9332\u6E08\u307F\u306E\u62EC\u5F27\u30DE\u30AF\u30ED\u307E\u305F\u306F\u4E00\u6587\u5B57\u30DE\u30AF\u30ED\u3067\u3059";
    if (H(this, qi).test(N))
      throw "[char2macro] char\u3010" + N + "\u3011\u306F\u4E00\u6587\u5B57\u30DE\u30AF\u30ED\u306B\u4F7F\u7528\u3067\u304D\u306A\u3044\u6587\u5B57\u3067\u3059";
    if (!M)
      throw "[char2macro] name\u306F\u5FC5\u9808\u3067\u3059";
    if (!(M in e))
      throw `[char2macro] \u672A\u5B9A\u7FA9\u306E\u30BF\u30B0\u53C8\u306F\u30DE\u30AF\u30ED[${M}]\u3067\u3059`;
    H(this, $e)[N] = `[${M}]`, this.addC2M(`\\${N}`, `\\${N}`), this.replaceScr_C2M_And_let_ml(o, R);
  }
  addC2M(t, e) {
    et(this, Yn, H(this, Yn) + `${t}|`), et(this, qn, H(this, qn) + `${e}`), et(this, Wn, new RegExp(
      `(${H(this, Yn)}[^${H(this, qn)}]+)`,
      "g"
    ));
  }
}
qi = new WeakMap(), Wn = new WeakMap(), Yn = new WeakMap(), qn = new WeakMap(), $e = new WeakMap();
var su, Zi, Zn;
class AnalyzeTagArg {
  constructor() {
    it(this, su, /;[^\n]*|(?<key>\w+)(?:\s|;[^\n]*\n)*=(?:\s|;[^\n]*\n)*(?:(?<val>[^\s"'#|;]+)|(["'#])(?<val2>.*?)\3)(?:\|(?:(?<def>[^\s"'#;]+)|(["'#])(?<def2>.*?)\6))?|(?<literal>[^\s;]+)/g);
    it(this, Zi, {});
    it(this, Zn, !1);
  }
  go(t) {
    var o, R;
    if (et(this, Zi, {}), et(this, Zn, !1), !t)
      return;
    let e = null;
    for (; e = H(this, su).exec(t); ) {
      const N = e == null ? void 0 : e.groups;
      !N || (N.key ? H(this, Zi)[N.key] = {
        val: (o = N.val) != null ? o : N.val2,
        def: (R = N.def) != null ? R : N.def2
      } : N.literal && (N.literal === "*" ? et(this, Zn, !0) : H(this, Zi)[N.literal] = { val: "1" }));
    }
  }
  get hPrm() {
    return H(this, Zi);
  }
  get isKomeParam() {
    return H(this, Zn);
  }
}
su = new WeakMap(), Zi = new WeakMap(), Zn = new WeakMap();
var parsimmon_umd_min = { exports: {} };
(function(n, t) {
  (function(e, o) {
    n.exports = o();
  })(typeof self < "u" ? self : commonjsGlobal$1, function() {
    return function(e) {
      var o = {};
      function R(N) {
        if (o[N])
          return o[N].exports;
        var M = o[N] = { i: N, l: !1, exports: {} };
        return e[N].call(M.exports, M, M.exports, R), M.l = !0, M.exports;
      }
      return R.m = e, R.c = o, R.d = function(N, M, D) {
        R.o(N, M) || Object.defineProperty(N, M, { configurable: !1, enumerable: !0, get: D });
      }, R.r = function(N) {
        Object.defineProperty(N, "__esModule", { value: !0 });
      }, R.n = function(N) {
        var M = N && N.__esModule ? function() {
          return N.default;
        } : function() {
          return N;
        };
        return R.d(M, "a", M), M;
      }, R.o = function(N, M) {
        return Object.prototype.hasOwnProperty.call(N, M);
      }, R.p = "", R(R.s = 0);
    }([function(e, o, R) {
      function N(ot) {
        if (!(this instanceof N))
          return new N(ot);
        this._ = ot;
      }
      var M = N.prototype;
      function D(ot, ft) {
        for (var bt = 0; bt < ot; bt++)
          ft(bt);
      }
      function L(ot, ft, bt) {
        return function(It, Nt) {
          D(Nt.length, function(Ft) {
            It(Nt[Ft], Ft, Nt);
          });
        }(function(It, Nt, Ft) {
          ft = ot(ft, It, Nt, Ft);
        }, bt), ft;
      }
      function B(ot, ft) {
        return L(function(bt, It, Nt, Ft) {
          return bt.concat([ot(It, Nt, Ft)]);
        }, [], ft);
      }
      function $(ot, ft) {
        var bt = { v: 0, buf: ft };
        return D(ot, function() {
          var It;
          bt = { v: bt.v << 1 | (It = bt.buf, It[0] >> 7), buf: function(Nt) {
            var Ft = L(function(Bt, Wt, ve, Be) {
              return Bt.concat(ve === Be.length - 1 ? Buffer.from([Wt, 0]).readUInt16BE(0) : Be.readUInt16BE(ve));
            }, [], Nt);
            return Buffer.from(B(function(Bt) {
              return (Bt << 1 & 65535) >> 8;
            }, Ft));
          }(bt.buf) };
        }), bt;
      }
      function k() {
        return typeof Buffer < "u";
      }
      function U() {
        if (!k())
          throw new Error("Buffer global does not exist; please use webpack if you need to parse Buffers in the browser.");
      }
      function z(ot) {
        U();
        var ft = L(function(Ft, Bt) {
          return Ft + Bt;
        }, 0, ot);
        if (ft % 8 != 0)
          throw new Error("The bits [" + ot.join(", ") + "] add up to " + ft + " which is not an even number of bytes; the total should be divisible by 8");
        var bt, It = ft / 8, Nt = (bt = function(Ft) {
          return Ft > 48;
        }, L(function(Ft, Bt) {
          return Ft || (bt(Bt) ? Bt : Ft);
        }, null, ot));
        if (Nt)
          throw new Error(Nt + " bit range requested exceeds 48 bit (6 byte) Number max.");
        return new N(function(Ft, Bt) {
          var Wt = It + Bt;
          return Wt > Ft.length ? tt(Bt, It.toString() + " bytes") : rt(Wt, L(function(ve, Be) {
            var Ne = $(Be, ve.buf);
            return { coll: ve.coll.concat(Ne.v), buf: Ne.buf };
          }, { coll: [], buf: Ft.slice(Bt, Wt) }, ot).coll);
        });
      }
      function X(ot, ft) {
        return new N(function(bt, It) {
          return U(), It + ft > bt.length ? tt(It, ft + " bytes for " + ot) : rt(It + ft, bt.slice(It, It + ft));
        });
      }
      function V(ot, ft) {
        if (typeof (bt = ft) != "number" || Math.floor(bt) !== bt || ft < 0 || ft > 6)
          throw new Error(ot + " requires integer length in range [0, 6].");
        var bt;
      }
      function W(ot) {
        return V("uintBE", ot), X("uintBE(" + ot + ")", ot).map(function(ft) {
          return ft.readUIntBE(0, ot);
        });
      }
      function Y(ot) {
        return V("uintLE", ot), X("uintLE(" + ot + ")", ot).map(function(ft) {
          return ft.readUIntLE(0, ot);
        });
      }
      function q(ot) {
        return V("intBE", ot), X("intBE(" + ot + ")", ot).map(function(ft) {
          return ft.readIntBE(0, ot);
        });
      }
      function Z(ot) {
        return V("intLE", ot), X("intLE(" + ot + ")", ot).map(function(ft) {
          return ft.readIntLE(0, ot);
        });
      }
      function J(ot) {
        return ot instanceof N;
      }
      function Q(ot) {
        return {}.toString.call(ot) === "[object Array]";
      }
      function K(ot) {
        return k() && Buffer.isBuffer(ot);
      }
      function rt(ot, ft) {
        return { status: !0, index: ot, value: ft, furthest: -1, expected: [] };
      }
      function tt(ot, ft) {
        return Q(ft) || (ft = [ft]), { status: !1, index: -1, value: null, furthest: ot, expected: ft };
      }
      function nt(ot, ft) {
        if (!ft || ot.furthest > ft.furthest)
          return ot;
        var bt = ot.furthest === ft.furthest ? function(It, Nt) {
          if (function() {
            if (N._supportsSet !== void 0)
              return N._supportsSet;
            var jr = typeof Set < "u";
            return N._supportsSet = jr, jr;
          }() && Array.from) {
            for (var Ft = new Set(It), Bt = 0; Bt < Nt.length; Bt++)
              Ft.add(Nt[Bt]);
            var Wt = Array.from(Ft);
            return Wt.sort(), Wt;
          }
          for (var ve = {}, Be = 0; Be < It.length; Be++)
            ve[It[Be]] = !0;
          for (var Ne = 0; Ne < Nt.length; Ne++)
            ve[Nt[Ne]] = !0;
          var zr = [];
          for (var Ke in ve)
            ({}).hasOwnProperty.call(ve, Ke) && zr.push(Ke);
          return zr.sort(), zr;
        }(ot.expected, ft.expected) : ft.expected;
        return { status: ot.status, index: ot.index, value: ot.value, furthest: ft.furthest, expected: bt };
      }
      var at = {};
      function lt(ot, ft) {
        if (K(ot))
          return { offset: ft, line: -1, column: -1 };
        ot in at || (at[ot] = {});
        for (var bt = at[ot], It = 0, Nt = 0, Ft = 0, Bt = ft; Bt >= 0; ) {
          if (Bt in bt) {
            It = bt[Bt].line, Ft === 0 && (Ft = bt[Bt].lineStart);
            break;
          }
          (ot.charAt(Bt) === `
` || ot.charAt(Bt) === "\r" && ot.charAt(Bt + 1) !== `
`) && (Nt++, Ft === 0 && (Ft = Bt + 1)), Bt--;
        }
        var Wt = It + Nt, ve = ft - Ft;
        return bt[ft] = { line: Wt, lineStart: Ft }, { offset: ft, line: Wt + 1, column: ve + 1 };
      }
      function ut(ot) {
        if (!J(ot))
          throw new Error("not a parser: " + ot);
      }
      function dt(ot, ft) {
        return typeof ot == "string" ? ot.charAt(ft) : ot[ft];
      }
      function yt(ot) {
        if (typeof ot != "number")
          throw new Error("not a number: " + ot);
      }
      function pt(ot) {
        if (typeof ot != "function")
          throw new Error("not a function: " + ot);
      }
      function gt(ot) {
        if (typeof ot != "string")
          throw new Error("not a string: " + ot);
      }
      var xt = 2, Lt = 3, mt = 8, ct = 5 * mt, vt = 4 * mt, Tt = "  ";
      function Pt(ot, ft) {
        return new Array(ft + 1).join(ot);
      }
      function wt(ot, ft, bt) {
        var It = ft - ot.length;
        return It <= 0 ? ot : Pt(bt, It) + ot;
      }
      function Mt(ot, ft, bt, It) {
        return { from: ot - ft > 0 ? ot - ft : 0, to: ot + bt > It ? It : ot + bt };
      }
      function ht(ot, ft) {
        var bt, It, Nt, Ft, Bt, Wt = ft.index, ve = Wt.offset, Be = 1;
        if (ve === ot.length)
          return "Got the end of the input";
        if (K(ot)) {
          var Ne = ve - ve % mt, zr = ve - Ne, Ke = Mt(Ne, ct, vt + mt, ot.length), jr = B(function(we) {
            return B(function(Dn) {
              return wt(Dn.toString(16), 2, "0");
            }, we);
          }, function(we, Dn) {
            var Ln = we.length, Vi = [], Fn = 0;
            if (Ln <= Dn)
              return [we.slice()];
            for (var Bn = 0; Bn < Ln; Bn++)
              Vi[Fn] || Vi.push([]), Vi[Fn].push(we[Bn]), (Bn + 1) % Dn == 0 && Fn++;
            return Vi;
          }(ot.slice(Ke.from, Ke.to).toJSON().data, mt));
          Ft = function(we) {
            return we.from === 0 && we.to === 1 ? { from: we.from, to: we.to } : { from: we.from / mt, to: Math.floor(we.to / mt) };
          }(Ke), It = Ne / mt, bt = 3 * zr, zr >= 4 && (bt += 1), Be = 2, Nt = B(function(we) {
            return we.length <= 4 ? we.join(" ") : we.slice(0, 4).join(" ") + "  " + we.slice(4).join(" ");
          }, jr), (Bt = (8 * (Ft.to > 0 ? Ft.to - 1 : Ft.to)).toString(16).length) < 2 && (Bt = 2);
        } else {
          var Mn = ot.split(/\r\n|[\n\r\u2028\u2029]/);
          bt = Wt.column - 1, It = Wt.line - 1, Ft = Mt(It, xt, Lt, Mn.length), Nt = Mn.slice(Ft.from, Ft.to), Bt = Ft.to.toString().length;
        }
        var Af = It - Ft.from;
        return K(ot) && (Bt = (8 * (Ft.to > 0 ? Ft.to - 1 : Ft.to)).toString(16).length) < 2 && (Bt = 2), L(function(we, Dn, Ln) {
          var Vi, Fn = Ln === Af, Bn = Fn ? "> " : Tt;
          return Vi = K(ot) ? wt((8 * (Ft.from + Ln)).toString(16), Bt, "0") : wt((Ft.from + Ln + 1).toString(), Bt, " "), [].concat(we, [Bn + Vi + " | " + Dn], Fn ? [Tt + Pt(" ", Bt) + " | " + wt("", bt, " ") + Pt("^", Be)] : []);
        }, [], Nt).join(`
`);
      }
      function $t(ot, ft) {
        return [`
`, "-- PARSING FAILED " + Pt("-", 50), `

`, ht(ot, ft), `

`, (bt = ft.expected, bt.length === 1 ? `Expected:

` + bt[0] : `Expected one of the following: 

` + bt.join(", ")), `
`].join("");
        var bt;
      }
      function At(ot) {
        return ot.flags !== void 0 ? ot.flags : [ot.global ? "g" : "", ot.ignoreCase ? "i" : "", ot.multiline ? "m" : "", ot.unicode ? "u" : "", ot.sticky ? "y" : ""].join("");
      }
      function kt() {
        for (var ot = [].slice.call(arguments), ft = ot.length, bt = 0; bt < ft; bt += 1)
          ut(ot[bt]);
        return N(function(It, Nt) {
          for (var Ft, Bt = new Array(ft), Wt = 0; Wt < ft; Wt += 1) {
            if (!(Ft = nt(ot[Wt]._(It, Nt), Ft)).status)
              return Ft;
            Bt[Wt] = Ft.value, Nt = Ft.index;
          }
          return nt(rt(Nt, Bt), Ft);
        });
      }
      function Ot() {
        var ot = [].slice.call(arguments);
        if (ot.length === 0)
          throw new Error("seqMap needs at least one argument");
        var ft = ot.pop();
        return pt(ft), kt.apply(null, ot).map(function(bt) {
          return ft.apply(null, bt);
        });
      }
      function _t() {
        var ot = [].slice.call(arguments), ft = ot.length;
        if (ft === 0)
          return Ct("zero alternates");
        for (var bt = 0; bt < ft; bt += 1)
          ut(ot[bt]);
        return N(function(It, Nt) {
          for (var Ft, Bt = 0; Bt < ot.length; Bt += 1)
            if ((Ft = nt(ot[Bt]._(It, Nt), Ft)).status)
              return Ft;
          return Ft;
        });
      }
      function Gt(ot, ft) {
        return St(ot, ft).or(Dt([]));
      }
      function St(ot, ft) {
        return ut(ot), ut(ft), Ot(ot, ft.then(ot).many(), function(bt, It) {
          return [bt].concat(It);
        });
      }
      function Et(ot) {
        gt(ot);
        var ft = "'" + ot + "'";
        return N(function(bt, It) {
          var Nt = It + ot.length, Ft = bt.slice(It, Nt);
          return Ft === ot ? rt(Nt, Ft) : tt(It, ft);
        });
      }
      function Rt(ot, ft) {
        (function(Nt) {
          if (!(Nt instanceof RegExp))
            throw new Error("not a regexp: " + Nt);
          for (var Ft = At(Nt), Bt = 0; Bt < Ft.length; Bt++) {
            var Wt = Ft.charAt(Bt);
            if (Wt !== "i" && Wt !== "m" && Wt !== "u" && Wt !== "s")
              throw new Error('unsupported regexp flag "' + Wt + '": ' + Nt);
          }
        })(ot), arguments.length >= 2 ? yt(ft) : ft = 0;
        var bt = function(Nt) {
          return RegExp("^(?:" + Nt.source + ")", At(Nt));
        }(ot), It = "" + ot;
        return N(function(Nt, Ft) {
          var Bt = bt.exec(Nt.slice(Ft));
          if (Bt) {
            if (0 <= ft && ft <= Bt.length) {
              var Wt = Bt[0], ve = Bt[ft];
              return rt(Ft + Wt.length, ve);
            }
            return tt(Ft, "valid match group (0 to " + Bt.length + ") in " + It);
          }
          return tt(Ft, It);
        });
      }
      function Dt(ot) {
        return N(function(ft, bt) {
          return rt(bt, ot);
        });
      }
      function Ct(ot) {
        return N(function(ft, bt) {
          return tt(bt, ot);
        });
      }
      function Zt(ot) {
        if (J(ot))
          return N(function(ft, bt) {
            var It = ot._(ft, bt);
            return It.index = bt, It.value = "", It;
          });
        if (typeof ot == "string")
          return Zt(Et(ot));
        if (ot instanceof RegExp)
          return Zt(Rt(ot));
        throw new Error("not a string, regexp, or parser: " + ot);
      }
      function Yt(ot) {
        return ut(ot), N(function(ft, bt) {
          var It = ot._(ft, bt), Nt = ft.slice(bt, It.index);
          return It.status ? tt(bt, 'not "' + Nt + '"') : rt(bt, null);
        });
      }
      function se(ot) {
        return pt(ot), N(function(ft, bt) {
          var It = dt(ft, bt);
          return bt < ft.length && ot(It) ? rt(bt + 1, It) : tt(bt, "a character/byte matching " + ot);
        });
      }
      function xe(ot, ft) {
        arguments.length < 2 && (ft = ot, ot = void 0);
        var bt = N(function(It, Nt) {
          return bt._ = ft()._, bt._(It, Nt);
        });
        return ot ? bt.desc(ot) : bt;
      }
      function Oe() {
        return Ct("fantasy-land/empty");
      }
      M.parse = function(ot) {
        if (typeof ot != "string" && !K(ot))
          throw new Error(".parse must be called with a string or Buffer as its argument");
        var ft, bt = this.skip(ue)._(ot, 0);
        return ft = bt.status ? { status: !0, value: bt.value } : { status: !1, index: lt(ot, bt.furthest), expected: bt.expected }, delete at[ot], ft;
      }, M.tryParse = function(ot) {
        var ft = this.parse(ot);
        if (ft.status)
          return ft.value;
        var bt = $t(ot, ft), It = new Error(bt);
        throw It.type = "ParsimmonError", It.result = ft, It;
      }, M.assert = function(ot, ft) {
        return this.chain(function(bt) {
          return ot(bt) ? Dt(bt) : Ct(ft);
        });
      }, M.or = function(ot) {
        return _t(this, ot);
      }, M.trim = function(ot) {
        return this.wrap(ot, ot);
      }, M.wrap = function(ot, ft) {
        return Ot(ot, this, ft, function(bt, It) {
          return It;
        });
      }, M.thru = function(ot) {
        return ot(this);
      }, M.then = function(ot) {
        return ut(ot), kt(this, ot).map(function(ft) {
          return ft[1];
        });
      }, M.many = function() {
        var ot = this;
        return N(function(ft, bt) {
          for (var It = [], Nt = void 0; ; ) {
            if (!(Nt = nt(ot._(ft, bt), Nt)).status)
              return nt(rt(bt, It), Nt);
            if (bt === Nt.index)
              throw new Error("infinite loop detected in .many() parser --- calling .many() on a parser which can accept zero characters is usually the cause");
            bt = Nt.index, It.push(Nt.value);
          }
        });
      }, M.tieWith = function(ot) {
        return gt(ot), this.map(function(ft) {
          if (function(Nt) {
            if (!Q(Nt))
              throw new Error("not an array: " + Nt);
          }(ft), ft.length) {
            gt(ft[0]);
            for (var bt = ft[0], It = 1; It < ft.length; It++)
              gt(ft[It]), bt += ot + ft[It];
            return bt;
          }
          return "";
        });
      }, M.tie = function() {
        return this.tieWith("");
      }, M.times = function(ot, ft) {
        var bt = this;
        return arguments.length < 2 && (ft = ot), yt(ot), yt(ft), N(function(It, Nt) {
          for (var Ft = [], Bt = void 0, Wt = void 0, ve = 0; ve < ot; ve += 1) {
            if (Wt = nt(Bt = bt._(It, Nt), Wt), !Bt.status)
              return Wt;
            Nt = Bt.index, Ft.push(Bt.value);
          }
          for (; ve < ft && (Wt = nt(Bt = bt._(It, Nt), Wt), Bt.status); ve += 1)
            Nt = Bt.index, Ft.push(Bt.value);
          return nt(rt(Nt, Ft), Wt);
        });
      }, M.result = function(ot) {
        return this.map(function() {
          return ot;
        });
      }, M.atMost = function(ot) {
        return this.times(0, ot);
      }, M.atLeast = function(ot) {
        return Ot(this.times(ot), this.many(), function(ft, bt) {
          return ft.concat(bt);
        });
      }, M.map = function(ot) {
        pt(ot);
        var ft = this;
        return N(function(bt, It) {
          var Nt = ft._(bt, It);
          return Nt.status ? nt(rt(Nt.index, ot(Nt.value)), Nt) : Nt;
        });
      }, M.contramap = function(ot) {
        pt(ot);
        var ft = this;
        return N(function(bt, It) {
          var Nt = ft.parse(ot(bt.slice(It)));
          return Nt.status ? rt(It + bt.length, Nt.value) : Nt;
        });
      }, M.promap = function(ot, ft) {
        return pt(ot), pt(ft), this.contramap(ot).map(ft);
      }, M.skip = function(ot) {
        return kt(this, ot).map(function(ft) {
          return ft[0];
        });
      }, M.mark = function() {
        return Ot(Qt, this, Qt, function(ot, ft, bt) {
          return { start: ot, value: ft, end: bt };
        });
      }, M.node = function(ot) {
        return Ot(Qt, this, Qt, function(ft, bt, It) {
          return { name: ot, value: bt, start: ft, end: It };
        });
      }, M.sepBy = function(ot) {
        return Gt(this, ot);
      }, M.sepBy1 = function(ot) {
        return St(this, ot);
      }, M.lookahead = function(ot) {
        return this.skip(Zt(ot));
      }, M.notFollowedBy = function(ot) {
        return this.skip(Yt(ot));
      }, M.desc = function(ot) {
        Q(ot) || (ot = [ot]);
        var ft = this;
        return N(function(bt, It) {
          var Nt = ft._(bt, It);
          return Nt.status || (Nt.expected = ot), Nt;
        });
      }, M.fallback = function(ot) {
        return this.or(Dt(ot));
      }, M.ap = function(ot) {
        return Ot(ot, this, function(ft, bt) {
          return ft(bt);
        });
      }, M.chain = function(ot) {
        var ft = this;
        return N(function(bt, It) {
          var Nt = ft._(bt, It);
          return Nt.status ? nt(ot(Nt.value)._(bt, Nt.index), Nt) : Nt;
        });
      }, M.concat = M.or, M.empty = Oe, M.of = Dt, M["fantasy-land/ap"] = M.ap, M["fantasy-land/chain"] = M.chain, M["fantasy-land/concat"] = M.concat, M["fantasy-land/empty"] = M.empty, M["fantasy-land/of"] = M.of, M["fantasy-land/map"] = M.map;
      var Qt = N(function(ot, ft) {
        return rt(ft, lt(ot, ft));
      }), Ie = N(function(ot, ft) {
        return ft >= ot.length ? tt(ft, "any character/byte") : rt(ft + 1, dt(ot, ft));
      }), de = N(function(ot, ft) {
        return rt(ot.length, ot.slice(ft));
      }), ue = N(function(ot, ft) {
        return ft < ot.length ? tt(ft, "EOF") : rt(ft, null);
      }), ae = Rt(/[0-9]/).desc("a digit"), Jt = Rt(/[0-9]*/).desc("optional digits"), Pe = Rt(/[a-z]/i).desc("a letter"), ha = Rt(/[a-z]*/i).desc("optional letters"), Ql = Rt(/\s*/).desc("optional whitespace"), Bo = Rt(/\s+/).desc("whitespace"), ca = Et("\r"), $o = Et(`
`), ko = Et(`\r
`), Go = _t(ko, $o, ca).desc("newline"), fa = _t(Go, ue);
      N.all = de, N.alt = _t, N.any = Ie, N.cr = ca, N.createLanguage = function(ot) {
        var ft = {};
        for (var bt in ot)
          ({}).hasOwnProperty.call(ot, bt) && function(It) {
            ft[It] = xe(function() {
              return ot[It](ft);
            });
          }(bt);
        return ft;
      }, N.crlf = ko, N.custom = function(ot) {
        return N(ot(rt, tt));
      }, N.digit = ae, N.digits = Jt, N.empty = Oe, N.end = fa, N.eof = ue, N.fail = Ct, N.formatError = $t, N.index = Qt, N.isParser = J, N.lazy = xe, N.letter = Pe, N.letters = ha, N.lf = $o, N.lookahead = Zt, N.makeFailure = tt, N.makeSuccess = rt, N.newline = Go, N.noneOf = function(ot) {
        return se(function(ft) {
          return ot.indexOf(ft) < 0;
        }).desc("none of '" + ot + "'");
      }, N.notFollowedBy = Yt, N.of = Dt, N.oneOf = function(ot) {
        for (var ft = ot.split(""), bt = 0; bt < ft.length; bt++)
          ft[bt] = "'" + ft[bt] + "'";
        return se(function(It) {
          return ot.indexOf(It) >= 0;
        }).desc(ft);
      }, N.optWhitespace = Ql, N.Parser = N, N.range = function(ot, ft) {
        return se(function(bt) {
          return ot <= bt && bt <= ft;
        }).desc(ot + "-" + ft);
      }, N.regex = Rt, N.regexp = Rt, N.sepBy = Gt, N.sepBy1 = St, N.seq = kt, N.seqMap = Ot, N.seqObj = function() {
        for (var ot, ft = {}, bt = 0, It = (ot = arguments, Array.prototype.slice.call(ot)), Nt = It.length, Ft = 0; Ft < Nt; Ft += 1) {
          var Bt = It[Ft];
          if (!J(Bt)) {
            if (Q(Bt) && Bt.length === 2 && typeof Bt[0] == "string" && J(Bt[1])) {
              var Wt = Bt[0];
              if (Object.prototype.hasOwnProperty.call(ft, Wt))
                throw new Error("seqObj: duplicate key " + Wt);
              ft[Wt] = !0, bt++;
              continue;
            }
            throw new Error("seqObj arguments must be parsers or [string, parser] array pairs.");
          }
        }
        if (bt === 0)
          throw new Error("seqObj expects at least one named parser, found zero");
        return N(function(ve, Be) {
          for (var Ne, zr = {}, Ke = 0; Ke < Nt; Ke += 1) {
            var jr, Mn;
            if (Q(It[Ke]) ? (jr = It[Ke][0], Mn = It[Ke][1]) : (jr = null, Mn = It[Ke]), !(Ne = nt(Mn._(ve, Be), Ne)).status)
              return Ne;
            jr && (zr[jr] = Ne.value), Be = Ne.index;
          }
          return nt(rt(Be, zr), Ne);
        });
      }, N.string = Et, N.succeed = Dt, N.takeWhile = function(ot) {
        return pt(ot), N(function(ft, bt) {
          for (var It = bt; It < ft.length && ot(dt(ft, It)); )
            It++;
          return rt(It, ft.slice(bt, It));
        });
      }, N.test = se, N.whitespace = Bo, N["fantasy-land/empty"] = Oe, N["fantasy-land/of"] = Dt, N.Binary = { bitSeq: z, bitSeqObj: function(ot) {
        U();
        var ft = {}, bt = 0, It = B(function(Ft) {
          if (Q(Ft)) {
            var Bt = Ft;
            if (Bt.length !== 2)
              throw new Error("[" + Bt.join(", ") + "] should be length 2, got length " + Bt.length);
            if (gt(Bt[0]), yt(Bt[1]), Object.prototype.hasOwnProperty.call(ft, Bt[0]))
              throw new Error("duplicate key in bitSeqObj: " + Bt[0]);
            return ft[Bt[0]] = !0, bt++, Bt;
          }
          return yt(Ft), [null, Ft];
        }, ot);
        if (bt < 1)
          throw new Error("bitSeqObj expects at least one named pair, got [" + ot.join(", ") + "]");
        var Nt = B(function(Ft) {
          return Ft[0];
        }, It);
        return z(B(function(Ft) {
          return Ft[1];
        }, It)).map(function(Ft) {
          return L(function(Bt, Wt) {
            return Wt[0] !== null && (Bt[Wt[0]] = Wt[1]), Bt;
          }, {}, B(function(Bt, Wt) {
            return [Bt, Ft[Wt]];
          }, Nt));
        });
      }, byte: function(ot) {
        if (U(), yt(ot), ot > 255)
          throw new Error("Value specified to byte constructor (" + ot + "=0x" + ot.toString(16) + ") is larger in value than a single byte.");
        var ft = (ot > 15 ? "0x" : "0x0") + ot.toString(16);
        return N(function(bt, It) {
          var Nt = dt(bt, It);
          return Nt === ot ? rt(It + 1, Nt) : tt(It, ft);
        });
      }, buffer: function(ot) {
        return X("buffer", ot).map(function(ft) {
          return Buffer.from(ft);
        });
      }, encodedString: function(ot, ft) {
        return X("string", ft).map(function(bt) {
          return bt.toString(ot);
        });
      }, uintBE: W, uint8BE: W(1), uint16BE: W(2), uint32BE: W(4), uintLE: Y, uint8LE: Y(1), uint16LE: Y(2), uint32LE: Y(4), intBE: q, int8BE: q(1), int16BE: q(2), int32BE: q(4), intLE: Z, int8LE: Z(1), int16LE: Z(2), int32LE: Z(4), floatBE: X("floatBE", 4).map(function(ot) {
        return ot.readFloatBE(0);
      }), floatLE: X("floatLE", 4).map(function(ot) {
        return ot.readFloatLE(0);
      }), doubleBE: X("doubleBE", 8).map(function(ot) {
        return ot.readDoubleBE(0);
      }), doubleLE: X("doubleLE", 8).map(function(ot) {
        return ot.readDoubleLE(0);
      }) }, e.exports = N;
    }]);
  });
})(parsimmon_umd_min);
var vi, zt, jt, Xr, gi, $n, Ca, Ia, eh, au, ou, Uh;
const Lh = class {
  constructor(t, e = "\\") {
    it(this, zt);
    it(this, gi);
    it(this, Ia);
    it(this, vi, void 0);
    it(this, Xr, void 0);
    it(this, Ca, void 0);
    this.val = t, et(this, vi, null), et(this, Xr, {
      "!num!": (W) => W.shift(),
      "!str!": (W) => st(this, Ia, eh).call(this, W.shift()),
      "!bool!": (W) => W.shift(),
      "!": (W) => {
        const Y = W.shift();
        return Y[0] === "!bool!" ? !Boolean(Y[1]) : String(st(this, zt, jt).call(this, Y)) !== "true";
      },
      "~": (W) => ~Number(st(this, zt, jt).call(this, W.shift())),
      "**": (W) => Number(st(this, zt, jt).call(this, W.shift())) ** Number(st(this, zt, jt).call(this, W.shift())),
      "*": (W) => Number(st(this, zt, jt).call(this, W.shift())) * Number(st(this, zt, jt).call(this, W.shift())),
      "/": (W) => Number(st(this, zt, jt).call(this, W.shift())) / Number(st(this, zt, jt).call(this, W.shift())),
      "\xA5": (W) => Math.floor(H(this, Xr)["/"](W)),
      "%": (W) => Number(st(this, zt, jt).call(this, W.shift())) % Number(st(this, zt, jt).call(this, W.shift())),
      "+": (W) => {
        const Y = st(this, zt, jt).call(this, W.shift()), q = st(this, zt, jt).call(this, W.shift());
        return Object.prototype.toString.call(Y) === "[object String]" || Object.prototype.toString.call(q) === "[object String]" ? String(Y) + String(q) : Number(Y) + Number(q);
      },
      "-": (W) => Number(st(this, zt, jt).call(this, W.shift())) - Number(st(this, zt, jt).call(this, W.shift())),
      int: (W) => int(st(this, gi, $n).call(this, W.shift())),
      parseInt: (W) => int(H(this, Xr).Number(W)),
      Number: (W) => {
        const Y = st(this, zt, jt).call(this, W.shift());
        return Object.prototype.toString.call(Y) !== "[object String]" ? Number(Y) : st(this, gi, $n).call(this, H(this, vi).parse(String(Y)).value);
      },
      ceil: (W) => Math.ceil(st(this, gi, $n).call(this, W.shift())),
      floor: (W) => Math.floor(st(this, gi, $n).call(this, W.shift())),
      round: (W) => Math.round(st(this, gi, $n).call(this, W.shift())),
      isNaN: (W) => isNaN(Number(st(this, zt, jt).call(this, W.shift()))),
      "<<": (W) => Number(st(this, zt, jt).call(this, W.shift())) << Number(st(this, zt, jt).call(this, W.shift())),
      ">>": (W) => Number(st(this, zt, jt).call(this, W.shift())) >> Number(st(this, zt, jt).call(this, W.shift())),
      ">>>": (W) => Number(st(this, zt, jt).call(this, W.shift())) >>> Number(st(this, zt, jt).call(this, W.shift())),
      "<": (W) => Number(st(this, zt, jt).call(this, W.shift())) < Number(st(this, zt, jt).call(this, W.shift())),
      "<=": (W) => Number(st(this, zt, jt).call(this, W.shift())) <= Number(st(this, zt, jt).call(this, W.shift())),
      ">": (W) => Number(st(this, zt, jt).call(this, W.shift())) > Number(st(this, zt, jt).call(this, W.shift())),
      ">=": (W) => Number(st(this, zt, jt).call(this, W.shift())) >= Number(st(this, zt, jt).call(this, W.shift())),
      "==": (W) => {
        const Y = st(this, zt, jt).call(this, W.shift()), q = st(this, zt, jt).call(this, W.shift());
        return Y == null && q == null && (!Y || !q) ? Y == q : String(Y) === String(q);
      },
      "!=": (W) => !H(this, Xr)["=="](W),
      "===": (W) => {
        const Y = st(this, zt, jt).call(this, W.shift()), q = st(this, zt, jt).call(this, W.shift());
        return Object.prototype.toString.call(Y) != Object.prototype.toString.call(q) ? !1 : String(Y) === String(q);
      },
      "!==": (W) => !H(this, Xr)["==="](W),
      "&": (W) => Number(st(this, zt, jt).call(this, W.shift())) & Number(st(this, zt, jt).call(this, W.shift())),
      "^": (W) => Number(st(this, zt, jt).call(this, W.shift())) ^ Number(st(this, zt, jt).call(this, W.shift())),
      "|": (W) => Number(st(this, zt, jt).call(this, W.shift())) | Number(st(this, zt, jt).call(this, W.shift())),
      "&&": (W) => String(st(this, zt, jt).call(this, W.shift())) === "true" && String(st(this, zt, jt).call(this, W.shift())) === "true",
      "||": (W) => String(st(this, zt, jt).call(this, W.shift())) === "true" || String(st(this, zt, jt).call(this, W.shift())) === "true",
      "?": (W) => {
        const Y = W.shift();
        let q = !1;
        if (Y[0] === "!bool!")
          q = Boolean(Y[1]);
        else {
          const J = String(st(this, zt, jt).call(this, Y));
          q = J !== "true" && J !== "false" ? int(J) !== 0 : J === "true";
        }
        const Z = W.shift();
        if (Z[0] !== ":")
          throw Error("(PropParser)\u4E09\u9805\u6F14\u7B97\u5B50\u306E\u6587\u6CD5\u30A8\u30E9\u30FC\u3067\u3059\u3002: \u304C\u898B\u3064\u304B\u308A\u307E\u305B\u3093");
        return st(this, zt, jt).call(this, Z[q ? 1 : 2]);
      },
      ":": () => {
        throw Error("(PropParser)\u4E09\u9805\u6F14\u7B97\u5B50\u306E\u6587\u6CD5\u30A8\u30E9\u30FC\u3067\u3059\u3002? \u304C\u898B\u3064\u304B\u308A\u307E\u305B\u3093");
      }
    }), et(this, Ca, /(\$((tmp|sys|save|mp):)?[^\s!--\/:-@[-^`{-~]+|\#\{[^\}]+})/g), this.getValAmpersand = (W) => W.charAt(0) === "&" ? String(this.parse(W.slice(1))) : W;
    function o(W) {
      const Y = [];
      return W.forEach((q) => Y.push(
        (q instanceof RegExp ? parsimmon_umd_min.exports.regex(q) : parsimmon_umd_min.exports.string(q)).trim(parsimmon_umd_min.exports.optWhitespace)
      )), parsimmon_umd_min.exports.alt.apply(null, Y);
    }
    function R(W, Y) {
      const q = parsimmon_umd_min.exports.lazy(() => parsimmon_umd_min.exports.seq(W, q).or(Y));
      return q;
    }
    function N(W, Y) {
      let q = parsimmon_umd_min.exports.lazy(
        () => Y.chain(
          (Z) => parsimmon_umd_min.exports.seq(
            W,
            parsimmon_umd_min.exports.of(Z),
            q
          ).or(parsimmon_umd_min.exports.of(Z))
        )
      );
      return q;
    }
    function M(W, Y) {
      return parsimmon_umd_min.exports.seqMap(
        Y,
        parsimmon_umd_min.exports.seq(W, Y).many(),
        (q, Z) => Z.reduce((J, Q) => [Q[0], J, Q[1]], q)
      );
    }
    const D = parsimmon_umd_min.exports.alt(
      parsimmon_umd_min.exports.alt(
        parsimmon_umd_min.exports.regex(/-?(0|[1-9][0-9]*)\.[0-9]+/),
        parsimmon_umd_min.exports.regex(/0x[0-9a-fA-F]+/)
      ).map(Number),
      parsimmon_umd_min.exports.alt(
        parsimmon_umd_min.exports.regex(/-?(0|[1-9][0-9]*)/)
      ).map((W) => int(W))
    ).map((W) => ["!num!", W]).desc("number"), L = parsimmon_umd_min.exports.string("null").map(() => ["!str!", null]), B = parsimmon_umd_min.exports.regex(/(true|false)/).map((W) => ["!bool!", W === "true"]).desc("boolean"), $ = parsimmon_umd_min.exports.regex(new RegExp(`(?:"(?:\\${e}["'#\\n]|[^"])*"|'(?:\\${e}["'#\\n]|[^'])*'|\\#(?:\\${e}["'#\\n]|[^#])*\\#)`)).map((W) => ["!str!", W.slice(1, -1).replaceAll(e, "")]).desc("string"), k = /\[[^\]]+\]/g, U = parsimmon_umd_min.exports.regex(/-?(?:(?:tmp|sys|save|mp):)?[^\s!-\/:-@[-^`{-~]+(?:\.[^\s!-\/:-@[-^`{-~]+|\[[^\]]+\])*(?:@str)?/).map((W) => {
      const Y = String(W).replace(
        k,
        (Z) => "." + this.parse(Z.slice(1, -1))
      );
      if (Y.charAt(0) === "-") {
        const Z = this.val.getVal(Y.slice(1));
        if (Z == null || String(Z) === "null")
          throw Error("(PropParser)\u6570\u5024\u4EE5\u5916\u306B-\u7B26\u53F7\u304C\u3064\u3044\u3066\u3044\u307E\u3059");
        return ["!num!", -Number(Z)];
      }
      const q = this.val.getVal(Y);
      return q == null ? ["!str!", q] : typeof q == "boolean" ? ["!bool!", q] : Object.prototype.toString.call(q) === "[object String]" ? ["!str!", String(q)] : ["!num!", Number(q)];
    }).desc("string"), z = parsimmon_umd_min.exports.lazy(
      () => parsimmon_umd_min.exports.string("(").then(H(this, vi)).skip(parsimmon_umd_min.exports.string(")")).or(D).or(L).or(B).or($).or(U)
    ), V = [
      { type: R, ops: o([/[A-Za-z_][A-Za-z0-9_]*(?=\()/]) },
      { type: R, ops: o([/(!(?!=)|~)/]) },
      { type: N, ops: o(["**"]) },
      { type: M, ops: o(["*", "/", "\xA5", "%"]) },
      { type: M, ops: o(["+", "-"]) },
      { type: M, ops: o([/(>>>|<<|>>)/]) },
      { type: M, ops: o([/(<=|<|>=|>)/]) },
      { type: M, ops: o([/(===|!==|==|!=)/]) },
      { type: M, ops: o([/&(?!&)/]) },
      { type: M, ops: o(["^"]) },
      { type: M, ops: o([/\|(?!\|)/]) },
      { type: M, ops: o(["&&"]) },
      { type: M, ops: o(["||"]) },
      { type: N, ops: o([":"]) },
      { type: N, ops: o(["?"]) }
    ].reduce(
      (W, Y) => Y.type(Y.ops, W),
      z
    );
    et(this, vi, V.trim(parsimmon_umd_min.exports.optWhitespace));
  }
  parse(t) {
    const e = H(this, vi).parse(t);
    if (!e.status)
      throw Error("(PropParser)\u6587\u6CD5\u30A8\u30E9\u30FC\u3010" + t + "\u3011");
    const o = e.value;
    return o[0] === "!str!" ? st(this, Ia, eh).call(this, o[1]) : st(this, zt, jt).call(this, o);
  }
  static getValName(t) {
    var R, N;
    const e = H(this, au).exec(t.trim()), o = e == null ? void 0 : e.groups;
    if (!!o)
      return {
        scope: o.scope || "tmp",
        name: st(R = Lh, ou, Uh).call(R, o.name),
        at: (N = o.at) != null ? N : ""
      };
  }
};
let PropParser = Lh;
vi = new WeakMap(), zt = new WeakSet(), jt = function(t) {
  const e = t.shift();
  if (e instanceof Array)
    return st(this, zt, jt).call(this, e);
  const o = H(this, Xr)[e];
  return o ? o(t) : Object(null);
}, Xr = new WeakMap(), gi = new WeakSet(), $n = function(t) {
  const e = st(this, zt, jt).call(this, t);
  if (Object.prototype.toString.call(e) !== "[object Number]")
    throw Error("(PropParser)\u5F15\u6570\u3010" + e + "\u3011\u304C\u6570\u5024\u3067\u306F\u3042\u308A\u307E\u305B\u3093");
  return Number(e);
}, Ca = new WeakMap(), Ia = new WeakSet(), eh = function(t) {
  return t == null ? t : String(t).replace(H(this, Ca), (e) => e.charAt(0) === "$" ? this.val.getVal(e.slice(1)) : this.parse(e.slice(2, -1)));
}, au = new WeakMap(), ou = new WeakSet(), Uh = function(t) {
  let e = 0, o = 0;
  for (; ; ) {
    if (e = t.indexOf('["'), e < 0) {
      if (e = t.indexOf("['"), e < 0)
        break;
      o = t.indexOf("']", e + 2);
    } else
      o = t.indexOf('"]', e + 2);
    if (o < 0)
      break;
    t = t.slice(0, e) + "." + t.slice(e + 2, o) + t.slice(o + 2), e = o - 2;
  }
  return t;
}, it(PropParser, ou), it(PropParser, au, /^((?<scope>\w+?):)?(?<name>[^\s :@]+)(?<at>\@str)?$/);
var __accessCheck$3 = (n, t, e) => {
  if (!t.has(n))
    throw TypeError("Cannot " + e);
}, __privateGet$3 = (n, t, e) => (__accessCheck$3(n, t, "read from private field"), e ? e.call(n) : t.get(n)), __privateAdd$3 = (n, t, e) => {
  if (t.has(n))
    throw TypeError("Cannot add the same private member more than once");
  t instanceof WeakSet ? t.add(n) : t.set(n, e);
}, __privateSet$3 = (n, t, e, o) => (__accessCheck$3(n, t, "write to private field"), o ? o.call(n, e) : t.set(n, e), e), __privateMethod$3 = (n, t, e) => (__accessCheck$3(n, t, "access private method"), e), _scrItr$1, _hTag, _title, _spnDbg, _first, _log, log_fn, _trace, trace_fn, _st_trace, st_trace_fn, _dspDbg, dspDbg_fn;
const _DebugMng = class {
  constructor(n, t, e) {
    this.sys = n, __privateAdd$3(this, _log), __privateAdd$3(this, _trace), __privateAdd$3(this, _first, !0), __privateSet$3(_DebugMng, _scrItr$1, e), __privateSet$3(_DebugMng, _hTag, t), __privateSet$3(_DebugMng, _title, t.title), _DebugMng.myTrace = __privateMethod$3(_DebugMng, _st_trace, st_trace_fn), t.log = (o) => __privateMethod$3(this, _log, log_fn).call(this, o), t.trace = (o) => __privateMethod$3(this, _trace, trace_fn).call(this, o), __privateSet$3(_DebugMng, _spnDbg, document.createElement("span")), __privateGet$3(_DebugMng, _spnDbg).hidden = !0, __privateGet$3(_DebugMng, _spnDbg).textContent = "", __privateGet$3(_DebugMng, _spnDbg).style.cssText = `	z-index: ${Number.MAX_SAFE_INTEGER};
			position: absolute; left: 0; top: 0;
			color: black;
			background-color: rgba(255, 255, 255, 0.7);`, document.body.appendChild(__privateGet$3(_DebugMng, _spnDbg));
  }
  destroy() {
    __privateSet$3(_DebugMng, _title, () => !1), document.body.removeChild(__privateGet$3(_DebugMng, _spnDbg)), _DebugMng.myTrace = _DebugMng.trace_beforeNew;
  }
  static trace_beforeNew(n, t = "E") {
    let e = `{${t}} ` + n, o = "";
    switch (t) {
      case "D":
        o = `color:#${CmnLib.isDarkMode ? "49F" : "05A"};`;
        break;
      case "W":
        o = "color:#FF8800;";
        break;
      case "F":
        o = "color:#BB0000;";
        break;
      case "ET":
        throw e;
      case "E":
        console.error("%c" + e, "color:#FF3300;");
        return;
      default:
        o = "color:black;", e = " " + e;
    }
    console.info("%c" + e, o);
  }
};
let DebugMng = _DebugMng;
_scrItr$1 = /* @__PURE__ */ new WeakMap();
_hTag = /* @__PURE__ */ new WeakMap();
_title = /* @__PURE__ */ new WeakMap();
_spnDbg = /* @__PURE__ */ new WeakMap();
_first = /* @__PURE__ */ new WeakMap();
_log = /* @__PURE__ */ new WeakSet();
log_fn = function(n) {
  let t = "";
  return __privateGet$3(this, _first) && (__privateSet$3(this, _first, !1), t = `== ${platform.description} ==
`), this.sys.appendFile(
    this.sys.path_downloads + "log.txt",
    `${t}--- ${getDateStr("-", "_", "")} [fn:${__privateGet$3(_DebugMng, _scrItr$1).scriptFn} line:${__privateGet$3(_DebugMng, _scrItr$1).lineNum}] prj:${this.sys.cur}
${n.text || `(text is ${n.text})`}
`,
    (e) => {
      e && console.log(e);
    }
  ), !1;
};
_trace = /* @__PURE__ */ new WeakSet();
trace_fn = function(n) {
  return _DebugMng.myTrace(n.text || `(text is ${n.text})`, "I"), !1;
};
_st_trace = /* @__PURE__ */ new WeakSet();
st_trace_fn = function(n, t = "E") {
  var e, o;
  let R = `{${t}} `;
  __privateGet$3(_DebugMng, _scrItr$1) && __privateGet$3(_DebugMng, _scrItr$1).lineNum > 0 && (R += `(fn:${__privateGet$3(_DebugMng, _scrItr$1).scriptFn} line:${__privateGet$3(_DebugMng, _scrItr$1).lineNum}) `), R += n, __privateMethod$3(e = _DebugMng, _dspDbg, dspDbg_fn).call(e, R, t);
  let N = "";
  switch (t) {
    case "D":
      N = `color:#${CmnLib.isDarkMode ? "49F" : "05A"};`;
      break;
    case "W":
      N = "color:#F80;";
      break;
    case "F":
      N = "color:#B00;";
      break;
    case "ET":
    case "E":
      if (__privateGet$3(o = _DebugMng, _title).call(o, { text: n }), __privateGet$3(this, _hTag).dump_lay({}), __privateGet$3(this, _hTag).dump_val({}), __privateGet$3(_DebugMng, _scrItr$1).dumpErrForeLine(), __privateGet$3(this, _hTag).dump_stack({}), t === "ET")
        throw R;
      console.error("%c" + R, "color:#F30;");
      return;
    default:
      N = "", R = " " + R;
  }
  console.info("%c" + R, N);
};
_dspDbg = /* @__PURE__ */ new WeakSet();
dspDbg_fn = function(n, t) {
  let e = "";
  switch (t) {
    case "D":
      e = "color:#05A;";
      break;
    case "W":
      e = "color:#F80;";
      break;
    case "F":
      e = "color:#B00;";
      break;
    case "ET":
    case "E":
      e = "color:#F30;";
      break;
    default:
      e = "";
  }
  __privateGet$3(_DebugMng, _spnDbg).innerHTML += `<span style='${e}'>${n}</span><br/>`, __privateGet$3(_DebugMng, _spnDbg).hidden = !1;
};
__privateAdd$3(DebugMng, _st_trace);
__privateAdd$3(DebugMng, _dspDbg);
__privateAdd$3(DebugMng, _scrItr$1, void 0);
__privateAdd$3(DebugMng, _hTag, void 0);
__privateAdd$3(DebugMng, _title, void 0);
__privateAdd$3(DebugMng, _spnDbg, void 0);
DebugMng.myTrace = _DebugMng.trace_beforeNew;
class Areas {
  constructor() {
    this.hAreas = {};
  }
  clear() {
    this.hAreas = {};
  }
  search(t) {
    for (const e in this.hAreas)
      if (!(t < parseInt(e)) && t <= this.hAreas[e])
        return !0;
    return !1;
  }
  record(t) {
    if (!this.search(t)) {
      for (const e in this.hAreas)
        if (this.hAreas[e] + 1 === t) {
          t + 1 in this.hAreas ? (this.hAreas[e] = this.hAreas[t + 1], delete this.hAreas[t + 1]) : this.hAreas[e] = t;
          return;
        }
      if (t + 1 in this.hAreas) {
        this.hAreas[t] = this.hAreas[t + 1], delete this.hAreas[t + 1];
        return;
      }
      this.hAreas[t] = t;
    }
  }
  erase(t) {
    if (!!this.search(t)) {
      if (t in this.hAreas) {
        this.hAreas[t] > t && (this.hAreas[t + 1] = this.hAreas[t]), delete this.hAreas[t];
        return;
      }
      for (const e in this.hAreas)
        if (!(t < parseInt(e)) && !(this.hAreas[e] < t)) {
          if (this.hAreas[e] === t) {
            this.hAreas[e] = t - 1;
            return;
          }
          this.hAreas[t + 1] = this.hAreas[e], this.hAreas[e] = t - 1;
          return;
        }
    }
  }
  get count() {
    return Object.keys(this.hAreas).length;
  }
  toString() {
    let t = "";
    const e = [];
    for (const o in this.hAreas)
      e.push(parseInt(o));
    return e.sort(function(o, R) {
      return o - R;
    }), e.forEach((o) => {
      t += "," + o + (o === this.hAreas[o]) ? "" : "~" + this.hAreas[o];
    }), t !== "" && (t = t.slice(1)), t;
  }
}
var Te, je, pe, Wr, _e, Ve, or, wa, Ra, Pa, rh, Kn, Jn, uu, Hh, lu, zh, ur, Rr, hu, jh, cu, Vh, fu, Xh, du, Wh, pu, Yh, vu, qh, gu, Zh, _u, Kh, Qn, Uo, Aa, ih, ts, Ki, Oa, nh, Na, Ma, Ji, es, rs, Ho, mu, Jh, yu, Qh, Da, sh, La, ah, bu, tc, Eu, ec, is, zo;
const Xn = class {
  constructor(t, e) {
    it(this, Pa);
    it(this, uu);
    it(this, lu);
    it(this, ur);
    it(this, hu);
    it(this, cu);
    it(this, fu);
    it(this, du);
    it(this, pu);
    it(this, vu);
    it(this, gu);
    it(this, _u);
    it(this, Qn);
    it(this, Aa);
    it(this, Oa);
    it(this, rs);
    it(this, mu);
    it(this, yu);
    it(this, Da);
    it(this, La);
    it(this, bu);
    it(this, Eu);
    it(this, is);
    it(this, Te, void 0);
    it(this, je, void 0);
    it(this, pe, void 0);
    it(this, Wr, void 0);
    it(this, _e, void 0);
    it(this, Ve, void 0);
    it(this, or, void 0);
    it(this, wa, void 0);
    it(this, Ra, void 0);
    it(this, Kn, void 0);
    it(this, Jn, void 0);
    it(this, ts, void 0);
    it(this, Na, void 0);
    it(this, Ma, void 0);
    it(this, Ji, void 0);
    it(this, es, void 0);
    var N;
    if (this.cfg = t, et(this, Te, { sys: {}, save: {}, tmp: {}, mp: {} }), et(this, je, H(this, Te).save), et(this, pe, H(this, Te).tmp), et(this, _e, { sys: {}, mark: {}, kidoku: {} }), et(this, or, {}), et(this, Ra, {
      auth: (M, D) => st(this, Pa, rh).call(this, D.hBreakpoint.aData),
      var: (M, D) => {
        var L;
        return H(this, Wr).send2Dbg(D.ri, { v: (L = H(this, Te)[D.scope]) != null ? L : {} });
      },
      set_var: (M, D) => {
        try {
          H(this, ts).call(this, D.nm, D.val), H(this, Wr).send2Dbg(D.ri, {});
        } catch {
        }
      },
      set_data_break: (M, D) => {
        st(this, Pa, rh).call(this, D.a), H(this, Wr).send2Dbg(D.ri, {});
      },
      disconnect: (M) => et(Xn, Ki, {})
    }), et(this, Kn, () => {
    }), et(this, Jn, (M) => {
    }), this.getMark = (M) => H(this, _e).mark[M], this.getAreaKidoku = (M) => H(this, or)[M], et(this, ts, (M, D, L = !0) => {
      if (!M)
        throw "[\u5909\u6570\u306B\u5024\u30BB\u30C3\u30C8] name\u306F\u5FC5\u9808\u3067\u3059";
      if (D == null)
        throw "[\u5909\u6570\u306B\u5024\u30BB\u30C3\u30C8] text\u306F\u5FC5\u9808\u3067\u3059\uFF08\u7A7A\u6587\u5B57\u306FOK\uFF09";
      const B = PropParser.getValName(M);
      if (B === void 0)
        throw "[\u5909\u6570\u53C2\u7167] name(" + M + ")\u304C\u5909\u6570\u540D\u3068\u3057\u3066\u7570\u5E38\u3067\u3059";
      const $ = H(this, Te)[B.scope];
      if (!$)
        throw "[\u5909\u6570\u306B\u5024\u30BB\u30C3\u30C8] scope\u304C\u7570\u5E38\u3010" + B.scope + "\u3011\u3067\u3059";
      const k = B.name;
      if (k.slice(0, 6) === "const." && k in $)
        throw "[\u5909\u6570\u306B\u5024\u30BB\u30C3\u30C8] \u5909\u6570\u3010" + k + "\u3011\u306F\u66F8\u304D\u63DB\u3048\u4E0D\u53EF\u3067\u3059";
      this.setVal_Nochk(B.scope, k, D, L);
    }), this.getVal = (M, D) => {
      if (!M)
        throw "[\u5909\u6570\u53C2\u7167] name\u306F\u5FC5\u9808\u3067\u3059";
      const L = PropParser.getValName(M);
      if (L === void 0)
        throw "[\u5909\u6570\u53C2\u7167] name(" + M + ")\u304C\u5909\u6570\u540D\u3068\u3057\u3066\u7570\u5E38\u3067\u3059";
      const B = H(this, Te)[L.scope];
      if (!B)
        throw "[\u5909\u6570\u53C2\u7167] scope\u304C\u7570\u5E38\u3010" + L.scope + "\u3011\u3067\u3059";
      const $ = L.name;
      let k = B[$];
      if (!($ in B)) {
        k = D;
        let U = "";
        const z = $.split("."), X = z.length;
        for (let V = 0; V < X; ++V, U += ".") {
          if (U += z[V], !(U in B))
            continue;
          let W = JSON.parse(B[U]);
          if (Object.prototype.toString.call(W) !== "[object Object]") {
            if (V + 1 === X) {
              k = W;
              break;
            }
            continue;
          }
          let Y = V;
          for (; ++Y < X; ) {
            if (!(z[Y] in W)) {
              k = D;
              break;
            }
            if (W = W[z[Y]], Object.prototype.toString.call(W) !== "[object Object]" || Y + 1 === X) {
              k = W;
              break;
            }
          }
          k instanceof Object && (k = JSON.stringify(k));
          break;
        }
      }
      return k instanceof Function && (k = k()), L.at === "@str" ? k : st(this, Oa, nh).call(this, k);
    }, et(this, Na, /^-?[\d\.]+$/), et(this, Ma, () => {
      const M = { tmp: {}, sys: {}, save: {}, mp: {} };
      for (let D in M) {
        const L = H(this, Te)[D], B = M[D];
        for (let $ in L) {
          const k = L[$];
          Object.prototype.toString.call(k) === "[object Function]" ? B[$] = k() : B[$] = k;
        }
      }
      return console.info("\u{1F95F} [dump_val]", M), !1;
    }), et(this, Ji, !1), et(this, es, {
      "sys:sn.tagCh.doWait": (M) => st(this, rs, Ho).call(this, M),
      "sys:sn.tagCh.doWait_Kidoku": (M) => st(this, rs, Ho).call(this, M),
      "sys:sn.tagCh.msecWait": (M) => st(this, mu, Jh).call(this, M),
      "sys:sn.tagCh.msecWait_Kidoku": (M) => st(this, yu, Qh).call(this, M),
      "sys:sn.tagCh.canskip": (M) => st(this, rs, Ho).call(this, M),
      "sys:sn.auto.msecPageWait": (M) => st(this, Da, sh).call(this, M),
      "sys:sn.auto.msecPageWait_Kidoku": (M) => st(this, Da, sh).call(this, M),
      "sys:sn.auto.msecLineWait": (M) => st(this, La, ah).call(this, M),
      "sys:sn.auto.msecLineWait_Kidoku": (M) => st(this, La, ah).call(this, M),
      "save:sn.doRecLog": (M) => {
        H(this, Jn).call(this, et(this, Ji, st(this, bu, tc).call(this, M)));
      },
      "save:sn.userFnTail": (M, D) => this.cfg.userFnTail = D,
      "tmp:sn.tagL.enabled": (M) => st(this, Eu, ec).call(this, M),
      "tmp:sn.skip.all": (M) => st(this, is, zo).call(this, M),
      "tmp:sn.skip.enabled": (M) => st(this, is, zo).call(this, M),
      "tmp:sn.auto.enabled": (M) => st(this, is, zo).call(this, M),
      "tmp:flash.desktop.NativeApplication.nativeApplication.systemIdleMode": () => {
      }
    }), e.let = (M) => st(this, ur, Rr).call(this, M), e.let_abs = (M) => st(this, hu, jh).call(this, M), e.let_char_at = (M) => st(this, cu, Vh).call(this, M), e.let_index_of = (M) => st(this, fu, Xh).call(this, M), e.let_length = (M) => st(this, du, Wh).call(this, M), e.let_replace = (M) => st(this, pu, Yh).call(this, M), e.let_round = (M) => st(this, vu, qh).call(this, M), e.let_search = (M) => st(this, gu, Zh).call(this, M), e.let_substr = (M) => st(this, _u, Kh).call(this, M), e.clearsysvar = () => st(this, Qn, Uo).call(this), e.clearvar = () => st(this, Aa, ih).call(this), e.dump_val = () => H(this, Ma).call(this), e.copybookmark = (M) => st(this, uu, Hh).call(this, M), e.erasebookmark = (M) => st(this, lu, zh).call(this, M), H(this, je)["sn.userFnTail"] = "", this.defTmp("const.sn.bookmark.json", () => {
      const M = [];
      return Object.keys(H(this, _e).mark).sort().forEach((D) => {
        const L = { ...H(this, _e).mark[D].json };
        L.place = D, M.push(L);
      }), JSON.stringify(M);
    }), H(this, pe)["const.sn.isFirstBoot"] = !0, H(this, pe)["sn.tagL.enabled"] = !0, H(this, pe)["sn.skip.all"] = !1, H(this, pe)["sn.skip.enabled"] = !1, H(this, pe)["sn.auto.enabled"] = !1, H(this, pe)["const.sn.last_page_text"] = "", H(this, pe)["const.sn.displayState"] = !1, H(this, pe)["const.Date.getTime"] = () => new Date().getTime(), H(this, pe)["const.Date.getDateStr"] = () => getDateStr(), H(this, pe)["const.sn.platform"] = JSON.stringify(platform), st(this, Qn, Uo).call(this), st(this, Aa, ih).call(this), H(this, pe)["const.sn.config.window.width"] = t.oCfg.window.width, H(this, pe)["const.sn.config.window.height"] = t.oCfg.window.height, H(this, pe)["const.sn.config.book.title"] = t.oCfg.book.title, H(this, pe)["const.sn.config.book.version"] = t.oCfg.book.version, H(this, pe)["const.sn.Math.PI"] = Math.PI, typeof window > "u")
      return;
    const o = window, R = (N = o.AudioContext) != null ? N : o.webkitAudioContext;
    H(this, pe)["const.sn.needClick2Play"] = () => new R().state === "suspended";
  }
  setSys(t) {
    et(this, Wr, t), t.initVal(H(this, _e), H(this, pe), (e) => {
      this.updateData(e), sessionStorage.clear();
      const o = this.cfg.getNs();
      et(this, Kn, this.cfg.oCfg.debug.variable ? () => {
        const N = {};
        Object.keys(H(this, Ve)).forEach((k) => {
          const U = H(this, Ve)[k];
          N["sys:" + k] = U instanceof Function ? U() : U;
        }), sessionStorage[o + "sys"] = JSON.stringify(N);
        const M = {};
        Object.keys(H(this, je)).forEach((k) => {
          const U = H(this, je)[k];
          M["save:" + k] = U instanceof Function ? U() : U;
        }), sessionStorage[o + "save"] = JSON.stringify(M);
        const D = {};
        Object.keys(H(this, pe)).forEach((k) => {
          const U = H(this, pe)[k];
          D[k] = U instanceof Function ? U() : U;
        }), sessionStorage[o + "tmp"] = JSON.stringify(D);
        const L = {};
        Object.keys(H(this, Te).mp).forEach((k) => {
          const U = H(this, Te).mp[k];
          L[k] = U instanceof Function ? U() : U;
        }), sessionStorage[o + "mp"] = JSON.stringify(L);
        const B = {};
        Object.keys(H(this, _e).mark).forEach((k) => {
          const U = H(this, _e).mark[k];
          B[k] = U instanceof Function ? U() : U;
        }), sessionStorage[o + "mark"] = JSON.stringify(B);
        const $ = {};
        Object.keys(H(this, _e).kidoku).forEach((k) => {
          const U = H(this, _e).kidoku[k];
          $[k] = U instanceof Function ? U() : U;
        }), sessionStorage[o + "kidoku"] = JSON.stringify($), t.flush();
      } : () => t.flush()), et(this, wa, (N, M) => t.callHook(N, M)), t.addHook((N, M) => {
        var D, L;
        return (L = (D = H(this, Ra))[N]) == null ? void 0 : L.call(D, N, M);
      });
      const R = this.getVal("sys:sn.tagCh.msecWait", -1);
      (H(this, pe)["const.sn.isFirstBoot"] || R === -1) && st(this, Qn, Uo).call(this);
    });
  }
  updateData(t) {
    et(this, _e, t), et(this, Ve, H(this, Te).sys = H(this, _e).sys), et(this, or, {});
    for (const e in H(this, _e).kidoku) {
      const o = new Areas();
      o.hAreas = { ...H(this, _e).kidoku[e] }, H(this, or)[e] = o;
    }
  }
  flush() {
    H(this, Kn).call(this);
  }
  setDoRecProc(t) {
    et(this, Jn, t);
  }
  defTmp(t, e) {
    H(this, pe)[t] = e;
  }
  cloneMp() {
    return { ...H(this, Te).mp };
  }
  setMp(t) {
    H(this, Te).mp = t;
  }
  setMark(t, e) {
    H(this, _e).mark[t] = e, this.flush();
  }
  cloneSave() {
    return { ...H(this, Te).save };
  }
  mark2save(t) {
    var e;
    et(this, je, H(this, Te).save = { ...t.hSave }), et(this, Ji, (e = H(this, je)["sn.doRecLog"]) != null ? e : !1);
  }
  loadScrWork(t) {
    t in H(this, or) || (H(this, or)[t] = new Areas());
  }
  saveKidoku() {
    for (const t in H(this, or))
      H(this, _e).kidoku[t] = { ...H(this, or)[t].hAreas };
    this.flush();
  }
  setVal_Nochk(t, e, o, R = !1) {
    var D, L;
    const N = H(this, Te)[t];
    R && (o = st(this, Oa, nh).call(this, o));
    const M = t + ":" + e;
    if (M in H(Xn, Ki)) {
      const B = N[e], $ = o;
      B != $ && H(this, wa).call(this, "data_break", {
        dataId: M,
        old_v: B,
        new_v: $
      });
    }
    N[e] = o, (L = (D = H(this, es))[M]) == null || L.call(D, e, o);
  }
  doRecLog() {
    return H(this, Ji);
  }
  defValTrg(t, e) {
    H(this, es)[t] = e;
  }
};
let Variable = Xn;
Te = new WeakMap(), je = new WeakMap(), pe = new WeakMap(), Wr = new WeakMap(), _e = new WeakMap(), Ve = new WeakMap(), or = new WeakMap(), wa = new WeakMap(), Ra = new WeakMap(), Pa = new WeakSet(), rh = function(t) {
  et(Xn, Ki, {}), t.forEach((e) => H(Xn, Ki)[e.dataId] = 1);
}, Kn = new WeakMap(), Jn = new WeakMap(), uu = new WeakSet(), Hh = function(t) {
  if (!("from" in t))
    throw "from\u306F\u5FC5\u9808\u3067\u3059";
  if (!("to" in t))
    throw "to\u306F\u5FC5\u9808\u3067\u3059";
  const e = Number(t.from), o = Number(t.to);
  if (e === o)
    return !1;
  if (!(e in H(this, _e).mark))
    throw `from:${e} \u306E\u30BB\u30FC\u30D6\u30C7\u30FC\u30BF\u306F\u5B58\u5728\u3057\u307E\u305B\u3093`;
  return this.setMark(o, { ...H(this, _e).mark[e] }), H(this, Wr).copyBMFolder(e, o), !1;
}, lu = new WeakSet(), zh = function(t) {
  const { place: e } = t;
  if (!e)
    throw "place\u306F\u5FC5\u9808\u3067\u3059";
  return delete H(this, _e).mark[e], this.flush(), H(this, Wr).eraseBMFolder(e), !1;
}, ur = new WeakSet(), Rr = function(t) {
  if (!t.name)
    throw "name\u306F\u5FC5\u9808\u3067\u3059";
  let e = !0;
  if (t.cast)
    switch (t.cast) {
      case "num":
        argChk_Num(t, "text", NaN);
        break;
      case "int":
        t.text = String(int(argChk_Num(t, "text", NaN)));
        break;
      case "uint":
        t.text = String(uint(argChk_Num(t, "text", NaN)));
        break;
      case "bool":
        argChk_Boolean(t, "text", !1);
        break;
      case "str":
        e = !1;
        break;
      default:
        throw "cast\u3010" + t.cast + "\u3011\u306F\u672A\u5B9A\u7FA9\u3067\u3059";
    }
  return H(this, ts).call(this, t.name, t.text, e), !1;
}, hu = new WeakSet(), jh = function(t) {
  const e = argChk_Num(t, "text", 0);
  return t.text = String(e < 0 ? -e : e), st(this, ur, Rr).call(this, t), !1;
}, cu = new WeakSet(), Vh = function(t) {
  var e;
  return t.text = ((e = t.text) != null ? e : "").charAt(argChk_Num(t, "pos", 0)), st(this, ur, Rr).call(this, t), !1;
}, fu = new WeakSet(), Xh = function(t) {
  var R;
  const { val: e } = t;
  if (!e)
    throw "val\u306F\u5FC5\u9808\u3067\u3059";
  const o = argChk_Num(t, "start", 0);
  return t.text = String(((R = t.text) != null ? R : "").indexOf(e, o)), st(this, ur, Rr).call(this, t), !1;
}, du = new WeakSet(), Wh = function(t) {
  var e;
  return t.text = String(((e = t.text) != null ? e : "").length), st(this, ur, Rr).call(this, t), !1;
}, pu = new WeakSet(), Yh = function(t) {
  var R;
  if (!t.reg)
    throw "reg\u306F\u5FC5\u9808\u3067\u3059";
  const { flags: e } = t, o = e ? new RegExp(t.reg, e) : new RegExp(t.reg);
  return t.text = String((R = t.text) != null ? R : "").replace(o, String(t.val)), st(this, ur, Rr).call(this, t), !1;
}, vu = new WeakSet(), qh = function(t) {
  const e = argChk_Num(t, "text", 0);
  return t.text = String(Math.round(e)), st(this, ur, Rr).call(this, t), !1;
}, gu = new WeakSet(), Zh = function(t) {
  var R;
  if (!t.reg)
    throw "reg\u306F\u5FC5\u9808\u3067\u3059";
  const { flags: e } = t, o = e ? new RegExp(t.reg, e) : new RegExp(t.reg);
  return t.text = String(((R = t.text) != null ? R : "").search(o)), st(this, ur, Rr).call(this, t), !1;
}, _u = new WeakSet(), Kh = function(t) {
  var o, R;
  const e = argChk_Num(t, "pos", 0);
  return t.text = t.len !== "all" ? ((o = t.text) != null ? o : "").slice(e, e + int(argChk_Num(t, "len", 1))) : ((R = t.text) != null ? R : "").slice(e), st(this, ur, Rr).call(this, t), !1;
}, Qn = new WeakSet(), Uo = function() {
  var o, R;
  const t = et(this, Ve, H(this, Te).sys = H(this, _e).sys = {});
  typeof process < "u" || (this.setVal_Nochk("sys", "const.sn.window.x", 0), this.setVal_Nochk("sys", "const.sn.window.y", 0)), this.setVal_Nochk("sys", "sn.tagCh.doWait", !0), this.setVal_Nochk("sys", "sn.tagCh.doWait_Kidoku", !0), this.setVal_Nochk("sys", "sn.tagCh.msecWait", this.cfg.oCfg.init.tagch_msecwait), this.setVal_Nochk("sys", "sn.tagCh.msecWait_Kidoku", this.cfg.oCfg.init.tagch_msecwait), this.setVal_Nochk("sys", "sn.tagCh.canskip", !0), this.setVal_Nochk("sys", "sn.skip.mode", "s"), this.setVal_Nochk("sys", "sn.auto.msecPageWait", argChk_Num(t, "sn.auto.msecPageWait", (o = this.cfg.oCfg.init.auto_msecpagewait) != null ? o : 3500)), this.setVal_Nochk("sys", "sn.auto.msecPageWait_Kidoku", argChk_Num(t, "sn.auto.msecPageWait", (R = this.cfg.oCfg.init.auto_msecpagewait) != null ? R : 3500)), this.setVal_Nochk("sys", "sn.auto.msecLineWait", 500), this.setVal_Nochk("sys", "sn.auto.msecLineWait_Kidoku", 500), this.setVal_Nochk("sys", "const.sn.sound.BGM.volume", 1), this.setVal_Nochk("sys", "const.sn.sound.SE.volume", 1), this.setVal_Nochk("sys", "const.sn.sound.SYS.volume", 1);
  for (const N in H(this, _e).kidoku)
    H(this, _e).kidoku[N].hAreas = {}, H(this, or)[N].clear();
  return this.setVal_Nochk("sys", "TextLayer.Back.Alpha", 0.5), H(this, Te).mark = H(this, _e).mark = {}, this.setVal_Nochk("sys", "const.sn.save.place", 1), this.flush(), !1;
}, Aa = new WeakSet(), ih = function() {
  var R, N, M;
  const t = (R = H(this, je)["const.sn.mesLayer"]) != null ? R : "", e = (N = H(this, je)["sn.doRecLog"]) != null ? N : !1, o = (M = H(this, je)["const.sn.sLog"]) != null ? M : "[]";
  return et(this, je, H(this, Te).save = {}), this.setVal_Nochk("save", "const.sn.mesLayer", t), this.setVal_Nochk("save", "sn.doRecLog", e), this.setVal_Nochk("save", "const.sn.sLog", o), !1;
}, ts = new WeakMap(), Ki = new WeakMap(), Oa = new WeakSet(), nh = function(t) {
  const e = t;
  if (e === "true")
    return !0;
  if (e === "false")
    return !1;
  if (e === "null")
    return null;
  if (e !== "undefined")
    return H(this, Na).test(e) ? parseFloat(e) : t;
}, Na = new WeakMap(), Ma = new WeakMap(), Ji = new WeakMap(), es = new WeakMap(), rs = new WeakSet(), Ho = function(t) {
  argChk_Boolean(H(this, Ve), t, !0);
}, mu = new WeakSet(), Jh = function(t) {
  argChk_Num(H(this, Ve), t, 10), H(this, Ve)["sn.tagCh.doWait"];
}, yu = new WeakSet(), Qh = function(t) {
  argChk_Num(
    H(this, Ve),
    t,
    this.cfg.oCfg.init.tagch_msecwait === void 0 ? 10 : this.cfg.oCfg.init.tagch_msecwait
  ), H(this, Ve)["sn.tagCh.doWait_Kidoku"];
}, Da = new WeakSet(), sh = function(t) {
  argChk_Num(
    H(this, Ve),
    t,
    this.cfg.oCfg.init.auto_msecpagewait === void 0 ? 3500 : this.cfg.oCfg.init.auto_msecpagewait
  );
}, La = new WeakSet(), ah = function(t) {
  argChk_Num(H(this, Ve), t, 500);
}, bu = new WeakSet(), tc = function(t) {
  return argChk_Boolean(H(this, je), t, !0);
}, Eu = new WeakSet(), ec = function(t) {
  argChk_Boolean(H(this, pe), t, !0);
}, is = new WeakSet(), zo = function(t) {
  argChk_Boolean(H(this, pe), t, !1);
}, it(Variable, Ki, {});
var Easing = {
  Linear: {
    None: function(n) {
      return n;
    }
  },
  Quadratic: {
    In: function(n) {
      return n * n;
    },
    Out: function(n) {
      return n * (2 - n);
    },
    InOut: function(n) {
      return (n *= 2) < 1 ? 0.5 * n * n : -0.5 * (--n * (n - 2) - 1);
    }
  },
  Cubic: {
    In: function(n) {
      return n * n * n;
    },
    Out: function(n) {
      return --n * n * n + 1;
    },
    InOut: function(n) {
      return (n *= 2) < 1 ? 0.5 * n * n * n : 0.5 * ((n -= 2) * n * n + 2);
    }
  },
  Quartic: {
    In: function(n) {
      return n * n * n * n;
    },
    Out: function(n) {
      return 1 - --n * n * n * n;
    },
    InOut: function(n) {
      return (n *= 2) < 1 ? 0.5 * n * n * n * n : -0.5 * ((n -= 2) * n * n * n - 2);
    }
  },
  Quintic: {
    In: function(n) {
      return n * n * n * n * n;
    },
    Out: function(n) {
      return --n * n * n * n * n + 1;
    },
    InOut: function(n) {
      return (n *= 2) < 1 ? 0.5 * n * n * n * n * n : 0.5 * ((n -= 2) * n * n * n * n + 2);
    }
  },
  Sinusoidal: {
    In: function(n) {
      return 1 - Math.cos(n * Math.PI / 2);
    },
    Out: function(n) {
      return Math.sin(n * Math.PI / 2);
    },
    InOut: function(n) {
      return 0.5 * (1 - Math.cos(Math.PI * n));
    }
  },
  Exponential: {
    In: function(n) {
      return n === 0 ? 0 : Math.pow(1024, n - 1);
    },
    Out: function(n) {
      return n === 1 ? 1 : 1 - Math.pow(2, -10 * n);
    },
    InOut: function(n) {
      return n === 0 ? 0 : n === 1 ? 1 : (n *= 2) < 1 ? 0.5 * Math.pow(1024, n - 1) : 0.5 * (-Math.pow(2, -10 * (n - 1)) + 2);
    }
  },
  Circular: {
    In: function(n) {
      return 1 - Math.sqrt(1 - n * n);
    },
    Out: function(n) {
      return Math.sqrt(1 - --n * n);
    },
    InOut: function(n) {
      return (n *= 2) < 1 ? -0.5 * (Math.sqrt(1 - n * n) - 1) : 0.5 * (Math.sqrt(1 - (n -= 2) * n) + 1);
    }
  },
  Elastic: {
    In: function(n) {
      return n === 0 ? 0 : n === 1 ? 1 : -Math.pow(2, 10 * (n - 1)) * Math.sin((n - 1.1) * 5 * Math.PI);
    },
    Out: function(n) {
      return n === 0 ? 0 : n === 1 ? 1 : Math.pow(2, -10 * n) * Math.sin((n - 0.1) * 5 * Math.PI) + 1;
    },
    InOut: function(n) {
      return n === 0 ? 0 : n === 1 ? 1 : (n *= 2, n < 1 ? -0.5 * Math.pow(2, 10 * (n - 1)) * Math.sin((n - 1.1) * 5 * Math.PI) : 0.5 * Math.pow(2, -10 * (n - 1)) * Math.sin((n - 1.1) * 5 * Math.PI) + 1);
    }
  },
  Back: {
    In: function(n) {
      var t = 1.70158;
      return n * n * ((t + 1) * n - t);
    },
    Out: function(n) {
      var t = 1.70158;
      return --n * n * ((t + 1) * n + t) + 1;
    },
    InOut: function(n) {
      var t = 2.5949095;
      return (n *= 2) < 1 ? 0.5 * (n * n * ((t + 1) * n - t)) : 0.5 * ((n -= 2) * n * ((t + 1) * n + t) + 2);
    }
  },
  Bounce: {
    In: function(n) {
      return 1 - Easing.Bounce.Out(1 - n);
    },
    Out: function(n) {
      return n < 1 / 2.75 ? 7.5625 * n * n : n < 2 / 2.75 ? 7.5625 * (n -= 1.5 / 2.75) * n + 0.75 : n < 2.5 / 2.75 ? 7.5625 * (n -= 2.25 / 2.75) * n + 0.9375 : 7.5625 * (n -= 2.625 / 2.75) * n + 0.984375;
    },
    InOut: function(n) {
      return n < 0.5 ? Easing.Bounce.In(n * 2) * 0.5 : Easing.Bounce.Out(n * 2 - 1) * 0.5 + 0.5;
    }
  }
}, now$2;
typeof self > "u" && typeof process < "u" && process.hrtime ? now$2 = function() {
  var n = process.hrtime();
  return n[0] * 1e3 + n[1] / 1e6;
} : typeof self < "u" && self.performance !== void 0 && self.performance.now !== void 0 ? now$2 = self.performance.now.bind(self.performance) : Date.now !== void 0 ? now$2 = Date.now : now$2 = function() {
  return new Date().getTime();
};
var now$1$1 = now$2, Group = function() {
  function n() {
    this._tweens = {}, this._tweensAddedDuringUpdate = {};
  }
  return n.prototype.getAll = function() {
    var t = this;
    return Object.keys(this._tweens).map(function(e) {
      return t._tweens[e];
    });
  }, n.prototype.removeAll = function() {
    this._tweens = {};
  }, n.prototype.add = function(t) {
    this._tweens[t.getId()] = t, this._tweensAddedDuringUpdate[t.getId()] = t;
  }, n.prototype.remove = function(t) {
    delete this._tweens[t.getId()], delete this._tweensAddedDuringUpdate[t.getId()];
  }, n.prototype.update = function(t, e) {
    t === void 0 && (t = now$1$1()), e === void 0 && (e = !1);
    var o = Object.keys(this._tweens);
    if (o.length === 0)
      return !1;
    for (; o.length > 0; ) {
      this._tweensAddedDuringUpdate = {};
      for (var R = 0; R < o.length; R++) {
        var N = this._tweens[o[R]], M = !e;
        N && N.update(t, M) === !1 && !e && delete this._tweens[o[R]];
      }
      o = Object.keys(this._tweensAddedDuringUpdate);
    }
    return !0;
  }, n;
}(), Interpolation = {
  Linear: function(n, t) {
    var e = n.length - 1, o = e * t, R = Math.floor(o), N = Interpolation.Utils.Linear;
    return t < 0 ? N(n[0], n[1], o) : t > 1 ? N(n[e], n[e - 1], e - o) : N(n[R], n[R + 1 > e ? e : R + 1], o - R);
  },
  Bezier: function(n, t) {
    for (var e = 0, o = n.length - 1, R = Math.pow, N = Interpolation.Utils.Bernstein, M = 0; M <= o; M++)
      e += R(1 - t, o - M) * R(t, M) * n[M] * N(o, M);
    return e;
  },
  CatmullRom: function(n, t) {
    var e = n.length - 1, o = e * t, R = Math.floor(o), N = Interpolation.Utils.CatmullRom;
    return n[0] === n[e] ? (t < 0 && (R = Math.floor(o = e * (1 + t))), N(n[(R - 1 + e) % e], n[R], n[(R + 1) % e], n[(R + 2) % e], o - R)) : t < 0 ? n[0] - (N(n[0], n[0], n[1], n[1], -o) - n[0]) : t > 1 ? n[e] - (N(n[e], n[e], n[e - 1], n[e - 1], o - e) - n[e]) : N(n[R ? R - 1 : 0], n[R], n[e < R + 1 ? e : R + 1], n[e < R + 2 ? e : R + 2], o - R);
  },
  Utils: {
    Linear: function(n, t, e) {
      return (t - n) * e + n;
    },
    Bernstein: function(n, t) {
      var e = Interpolation.Utils.Factorial;
      return e(n) / e(t) / e(n - t);
    },
    Factorial: function() {
      var n = [1];
      return function(t) {
        var e = 1;
        if (n[t])
          return n[t];
        for (var o = t; o > 1; o--)
          e *= o;
        return n[t] = e, e;
      };
    }(),
    CatmullRom: function(n, t, e, o, R) {
      var N = (e - n) * 0.5, M = (o - t) * 0.5, D = R * R, L = R * D;
      return (2 * t - 2 * e + N + M) * L + (-3 * t + 3 * e - 2 * N - M) * D + N * R + t;
    }
  }
}, Sequence = function() {
  function n() {
  }
  return n.nextId = function() {
    return n._nextId++;
  }, n._nextId = 0, n;
}(), mainGroup = new Group(), Tween = function() {
  function n(t, e) {
    e === void 0 && (e = mainGroup), this._object = t, this._group = e, this._isPaused = !1, this._pauseStart = 0, this._valuesStart = {}, this._valuesEnd = {}, this._valuesStartRepeat = {}, this._duration = 1e3, this._initialRepeat = 0, this._repeat = 0, this._yoyo = !1, this._isPlaying = !1, this._reversed = !1, this._delayTime = 0, this._startTime = 0, this._easingFunction = Easing.Linear.None, this._interpolationFunction = Interpolation.Linear, this._chainedTweens = [], this._onStartCallbackFired = !1, this._id = Sequence.nextId(), this._isChainStopped = !1, this._goToEnd = !1;
  }
  return n.prototype.getId = function() {
    return this._id;
  }, n.prototype.isPlaying = function() {
    return this._isPlaying;
  }, n.prototype.isPaused = function() {
    return this._isPaused;
  }, n.prototype.to = function(t, e) {
    return this._valuesEnd = Object.create(t), e !== void 0 && (this._duration = e), this;
  }, n.prototype.duration = function(t) {
    return this._duration = t, this;
  }, n.prototype.start = function(t) {
    if (this._isPlaying)
      return this;
    if (this._group && this._group.add(this), this._repeat = this._initialRepeat, this._reversed) {
      this._reversed = !1;
      for (var e in this._valuesStartRepeat)
        this._swapEndStartRepeatValues(e), this._valuesStart[e] = this._valuesStartRepeat[e];
    }
    return this._isPlaying = !0, this._isPaused = !1, this._onStartCallbackFired = !1, this._isChainStopped = !1, this._startTime = t !== void 0 ? typeof t == "string" ? now$1$1() + parseFloat(t) : t : now$1$1(), this._startTime += this._delayTime, this._setupProperties(this._object, this._valuesStart, this._valuesEnd, this._valuesStartRepeat), this;
  }, n.prototype._setupProperties = function(t, e, o, R) {
    for (var N in o) {
      var M = t[N], D = Array.isArray(M), L = D ? "array" : typeof M, B = !D && Array.isArray(o[N]);
      if (!(L === "undefined" || L === "function")) {
        if (B) {
          var $ = o[N];
          if ($.length === 0)
            continue;
          $ = $.map(this._handleRelativeValue.bind(this, M)), o[N] = [M].concat($);
        }
        if ((L === "object" || D) && M && !B) {
          e[N] = D ? [] : {};
          for (var k in M)
            e[N][k] = M[k];
          R[N] = D ? [] : {}, this._setupProperties(M, e[N], o[N], R[N]);
        } else
          typeof e[N] > "u" && (e[N] = M), D || (e[N] *= 1), B ? R[N] = o[N].slice().reverse() : R[N] = e[N] || 0;
      }
    }
  }, n.prototype.stop = function() {
    return this._isChainStopped || (this._isChainStopped = !0, this.stopChainedTweens()), this._isPlaying ? (this._group && this._group.remove(this), this._isPlaying = !1, this._isPaused = !1, this._onStopCallback && this._onStopCallback(this._object), this) : this;
  }, n.prototype.end = function() {
    return this._goToEnd = !0, this.update(1 / 0), this;
  }, n.prototype.pause = function(t) {
    return t === void 0 && (t = now$1$1()), this._isPaused || !this._isPlaying ? this : (this._isPaused = !0, this._pauseStart = t, this._group && this._group.remove(this), this);
  }, n.prototype.resume = function(t) {
    return t === void 0 && (t = now$1$1()), !this._isPaused || !this._isPlaying ? this : (this._isPaused = !1, this._startTime += t - this._pauseStart, this._pauseStart = 0, this._group && this._group.add(this), this);
  }, n.prototype.stopChainedTweens = function() {
    for (var t = 0, e = this._chainedTweens.length; t < e; t++)
      this._chainedTweens[t].stop();
    return this;
  }, n.prototype.group = function(t) {
    return this._group = t, this;
  }, n.prototype.delay = function(t) {
    return this._delayTime = t, this;
  }, n.prototype.repeat = function(t) {
    return this._initialRepeat = t, this._repeat = t, this;
  }, n.prototype.repeatDelay = function(t) {
    return this._repeatDelayTime = t, this;
  }, n.prototype.yoyo = function(t) {
    return this._yoyo = t, this;
  }, n.prototype.easing = function(t) {
    return this._easingFunction = t, this;
  }, n.prototype.interpolation = function(t) {
    return this._interpolationFunction = t, this;
  }, n.prototype.chain = function() {
    for (var t = [], e = 0; e < arguments.length; e++)
      t[e] = arguments[e];
    return this._chainedTweens = t, this;
  }, n.prototype.onStart = function(t) {
    return this._onStartCallback = t, this;
  }, n.prototype.onUpdate = function(t) {
    return this._onUpdateCallback = t, this;
  }, n.prototype.onRepeat = function(t) {
    return this._onRepeatCallback = t, this;
  }, n.prototype.onComplete = function(t) {
    return this._onCompleteCallback = t, this;
  }, n.prototype.onStop = function(t) {
    return this._onStopCallback = t, this;
  }, n.prototype.update = function(t, e) {
    if (t === void 0 && (t = now$1$1()), e === void 0 && (e = !0), this._isPaused)
      return !0;
    var o, R, N = this._startTime + this._duration;
    if (!this._goToEnd && !this._isPlaying) {
      if (t > N)
        return !1;
      e && this.start(t);
    }
    if (this._goToEnd = !1, t < this._startTime)
      return !0;
    this._onStartCallbackFired === !1 && (this._onStartCallback && this._onStartCallback(this._object), this._onStartCallbackFired = !0), R = (t - this._startTime) / this._duration, R = this._duration === 0 || R > 1 ? 1 : R;
    var M = this._easingFunction(R);
    if (this._updateProperties(this._object, this._valuesStart, this._valuesEnd, M), this._onUpdateCallback && this._onUpdateCallback(this._object, R), R === 1)
      if (this._repeat > 0) {
        isFinite(this._repeat) && this._repeat--;
        for (o in this._valuesStartRepeat)
          !this._yoyo && typeof this._valuesEnd[o] == "string" && (this._valuesStartRepeat[o] = this._valuesStartRepeat[o] + parseFloat(this._valuesEnd[o])), this._yoyo && this._swapEndStartRepeatValues(o), this._valuesStart[o] = this._valuesStartRepeat[o];
        return this._yoyo && (this._reversed = !this._reversed), this._repeatDelayTime !== void 0 ? this._startTime = t + this._repeatDelayTime : this._startTime = t + this._delayTime, this._onRepeatCallback && this._onRepeatCallback(this._object), !0;
      } else {
        this._onCompleteCallback && this._onCompleteCallback(this._object);
        for (var D = 0, L = this._chainedTweens.length; D < L; D++)
          this._chainedTweens[D].start(this._startTime + this._duration);
        return this._isPlaying = !1, !1;
      }
    return !0;
  }, n.prototype._updateProperties = function(t, e, o, R) {
    for (var N in o)
      if (e[N] !== void 0) {
        var M = e[N] || 0, D = o[N], L = Array.isArray(t[N]), B = Array.isArray(D), $ = !L && B;
        $ ? t[N] = this._interpolationFunction(D, R) : typeof D == "object" && D ? this._updateProperties(t[N], M, D, R) : (D = this._handleRelativeValue(M, D), typeof D == "number" && (t[N] = M + (D - M) * R));
      }
  }, n.prototype._handleRelativeValue = function(t, e) {
    return typeof e != "string" ? e : e.charAt(0) === "+" || e.charAt(0) === "-" ? t + parseFloat(e) : parseFloat(e);
  }, n.prototype._swapEndStartRepeatValues = function(t) {
    var e = this._valuesStartRepeat[t], o = this._valuesEnd[t];
    typeof o == "string" ? this._valuesStartRepeat[t] = this._valuesStartRepeat[t] + parseFloat(o) : this._valuesStartRepeat[t] = this._valuesEnd[t], this._valuesEnd[t] = e;
  }, n;
}();
Sequence.nextId;
var TWEEN = mainGroup;
TWEEN.getAll.bind(TWEEN);
var removeAll = TWEEN.removeAll.bind(TWEEN);
TWEEN.add.bind(TWEEN);
TWEEN.remove.bind(TWEEN);
var update = TWEEN.update.bind(TWEEN), Fa;
const xu = class {
  static ease(t) {
    if (!t)
      return (e) => Easing.Linear.None(e);
    if (!(t in H(xu, Fa)))
      throw "\u7570\u5E38\u306Aease\u6307\u5B9A\u3067\u3059";
    return H(xu, Fa)[t];
  }
};
let CmnTween = xu;
Fa = new WeakMap(), it(CmnTween, Fa, {
  "Back.In": (t) => Easing.Back.In(t),
  "Back.InOut": (t) => Easing.Back.InOut(t),
  "Back.Out": (t) => Easing.Back.Out(t),
  "Bounce.In": (t) => Easing.Bounce.In(t),
  "Bounce.InOut": (t) => Easing.Bounce.InOut(t),
  "Bounce.Out": (t) => Easing.Bounce.Out(t),
  "Circular.In": (t) => Easing.Circular.In(t),
  "Circular.InOut": (t) => Easing.Circular.InOut(t),
  "Circular.Out": (t) => Easing.Circular.Out(t),
  "Cubic.In": (t) => Easing.Cubic.In(t),
  "Cubic.InOut": (t) => Easing.Cubic.InOut(t),
  "Cubic.Out": (t) => Easing.Cubic.Out(t),
  "Elastic.In": (t) => Easing.Elastic.In(t),
  "Elastic.InOut": (t) => Easing.Elastic.InOut(t),
  "Elastic.Out": (t) => Easing.Elastic.Out(t),
  "Exponential.In": (t) => Easing.Exponential.In(t),
  "Exponential.InOut": (t) => Easing.Exponential.InOut(t),
  "Exponential.Out": (t) => Easing.Exponential.Out(t),
  "Linear.None": (t) => Easing.Linear.None(t),
  "Quadratic.In": (t) => Easing.Quadratic.In(t),
  "Quadratic.InOut": (t) => Easing.Quadratic.InOut(t),
  "Quadratic.Out": (t) => Easing.Quadratic.Out(t),
  "Quartic.In": (t) => Easing.Quartic.In(t),
  "Quartic.InOut": (t) => Easing.Quartic.InOut(t),
  "Quartic.Out": (t) => Easing.Quartic.Out(t),
  "Quintic.In": (t) => Easing.Quintic.In(t),
  "Quintic.InOut": (t) => Easing.Quintic.InOut(t),
  "Quintic.Out": (t) => Easing.Quintic.Out(t),
  "Sinusoidal.In": (t) => Easing.Sinusoidal.In(t),
  "Sinusoidal.InOut": (t) => Easing.Sinusoidal.InOut(t),
  "Sinusoidal.Out": (t) => Easing.Sinusoidal.Out(t)
});
/*!
 * @pixi/settings - v6.5.2
 * Compiled Wed, 24 Aug 2022 13:51:19 UTC
 *
 * @pixi/settings is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
/*!
 * @pixi/constants - v6.5.2
 * Compiled Wed, 24 Aug 2022 13:51:19 UTC
 *
 * @pixi/constants is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
var ENV$6;
(function(n) {
  n[n.WEBGL_LEGACY = 0] = "WEBGL_LEGACY", n[n.WEBGL = 1] = "WEBGL", n[n.WEBGL2 = 2] = "WEBGL2";
})(ENV$6 || (ENV$6 = {}));
var RENDERER_TYPE$6;
(function(n) {
  n[n.UNKNOWN = 0] = "UNKNOWN", n[n.WEBGL = 1] = "WEBGL", n[n.CANVAS = 2] = "CANVAS";
})(RENDERER_TYPE$6 || (RENDERER_TYPE$6 = {}));
var BUFFER_BITS$6;
(function(n) {
  n[n.COLOR = 16384] = "COLOR", n[n.DEPTH = 256] = "DEPTH", n[n.STENCIL = 1024] = "STENCIL";
})(BUFFER_BITS$6 || (BUFFER_BITS$6 = {}));
var BLEND_MODES$6;
(function(n) {
  n[n.NORMAL = 0] = "NORMAL", n[n.ADD = 1] = "ADD", n[n.MULTIPLY = 2] = "MULTIPLY", n[n.SCREEN = 3] = "SCREEN", n[n.OVERLAY = 4] = "OVERLAY", n[n.DARKEN = 5] = "DARKEN", n[n.LIGHTEN = 6] = "LIGHTEN", n[n.COLOR_DODGE = 7] = "COLOR_DODGE", n[n.COLOR_BURN = 8] = "COLOR_BURN", n[n.HARD_LIGHT = 9] = "HARD_LIGHT", n[n.SOFT_LIGHT = 10] = "SOFT_LIGHT", n[n.DIFFERENCE = 11] = "DIFFERENCE", n[n.EXCLUSION = 12] = "EXCLUSION", n[n.HUE = 13] = "HUE", n[n.SATURATION = 14] = "SATURATION", n[n.COLOR = 15] = "COLOR", n[n.LUMINOSITY = 16] = "LUMINOSITY", n[n.NORMAL_NPM = 17] = "NORMAL_NPM", n[n.ADD_NPM = 18] = "ADD_NPM", n[n.SCREEN_NPM = 19] = "SCREEN_NPM", n[n.NONE = 20] = "NONE", n[n.SRC_OVER = 0] = "SRC_OVER", n[n.SRC_IN = 21] = "SRC_IN", n[n.SRC_OUT = 22] = "SRC_OUT", n[n.SRC_ATOP = 23] = "SRC_ATOP", n[n.DST_OVER = 24] = "DST_OVER", n[n.DST_IN = 25] = "DST_IN", n[n.DST_OUT = 26] = "DST_OUT", n[n.DST_ATOP = 27] = "DST_ATOP", n[n.ERASE = 26] = "ERASE", n[n.SUBTRACT = 28] = "SUBTRACT", n[n.XOR = 29] = "XOR";
})(BLEND_MODES$6 || (BLEND_MODES$6 = {}));
var DRAW_MODES$6;
(function(n) {
  n[n.POINTS = 0] = "POINTS", n[n.LINES = 1] = "LINES", n[n.LINE_LOOP = 2] = "LINE_LOOP", n[n.LINE_STRIP = 3] = "LINE_STRIP", n[n.TRIANGLES = 4] = "TRIANGLES", n[n.TRIANGLE_STRIP = 5] = "TRIANGLE_STRIP", n[n.TRIANGLE_FAN = 6] = "TRIANGLE_FAN";
})(DRAW_MODES$6 || (DRAW_MODES$6 = {}));
var FORMATS$6;
(function(n) {
  n[n.RGBA = 6408] = "RGBA", n[n.RGB = 6407] = "RGB", n[n.RG = 33319] = "RG", n[n.RED = 6403] = "RED", n[n.RGBA_INTEGER = 36249] = "RGBA_INTEGER", n[n.RGB_INTEGER = 36248] = "RGB_INTEGER", n[n.RG_INTEGER = 33320] = "RG_INTEGER", n[n.RED_INTEGER = 36244] = "RED_INTEGER", n[n.ALPHA = 6406] = "ALPHA", n[n.LUMINANCE = 6409] = "LUMINANCE", n[n.LUMINANCE_ALPHA = 6410] = "LUMINANCE_ALPHA", n[n.DEPTH_COMPONENT = 6402] = "DEPTH_COMPONENT", n[n.DEPTH_STENCIL = 34041] = "DEPTH_STENCIL";
})(FORMATS$6 || (FORMATS$6 = {}));
var TARGETS$6;
(function(n) {
  n[n.TEXTURE_2D = 3553] = "TEXTURE_2D", n[n.TEXTURE_CUBE_MAP = 34067] = "TEXTURE_CUBE_MAP", n[n.TEXTURE_2D_ARRAY = 35866] = "TEXTURE_2D_ARRAY", n[n.TEXTURE_CUBE_MAP_POSITIVE_X = 34069] = "TEXTURE_CUBE_MAP_POSITIVE_X", n[n.TEXTURE_CUBE_MAP_NEGATIVE_X = 34070] = "TEXTURE_CUBE_MAP_NEGATIVE_X", n[n.TEXTURE_CUBE_MAP_POSITIVE_Y = 34071] = "TEXTURE_CUBE_MAP_POSITIVE_Y", n[n.TEXTURE_CUBE_MAP_NEGATIVE_Y = 34072] = "TEXTURE_CUBE_MAP_NEGATIVE_Y", n[n.TEXTURE_CUBE_MAP_POSITIVE_Z = 34073] = "TEXTURE_CUBE_MAP_POSITIVE_Z", n[n.TEXTURE_CUBE_MAP_NEGATIVE_Z = 34074] = "TEXTURE_CUBE_MAP_NEGATIVE_Z";
})(TARGETS$6 || (TARGETS$6 = {}));
var TYPES$6;
(function(n) {
  n[n.UNSIGNED_BYTE = 5121] = "UNSIGNED_BYTE", n[n.UNSIGNED_SHORT = 5123] = "UNSIGNED_SHORT", n[n.UNSIGNED_SHORT_5_6_5 = 33635] = "UNSIGNED_SHORT_5_6_5", n[n.UNSIGNED_SHORT_4_4_4_4 = 32819] = "UNSIGNED_SHORT_4_4_4_4", n[n.UNSIGNED_SHORT_5_5_5_1 = 32820] = "UNSIGNED_SHORT_5_5_5_1", n[n.UNSIGNED_INT = 5125] = "UNSIGNED_INT", n[n.UNSIGNED_INT_10F_11F_11F_REV = 35899] = "UNSIGNED_INT_10F_11F_11F_REV", n[n.UNSIGNED_INT_2_10_10_10_REV = 33640] = "UNSIGNED_INT_2_10_10_10_REV", n[n.UNSIGNED_INT_24_8 = 34042] = "UNSIGNED_INT_24_8", n[n.UNSIGNED_INT_5_9_9_9_REV = 35902] = "UNSIGNED_INT_5_9_9_9_REV", n[n.BYTE = 5120] = "BYTE", n[n.SHORT = 5122] = "SHORT", n[n.INT = 5124] = "INT", n[n.FLOAT = 5126] = "FLOAT", n[n.FLOAT_32_UNSIGNED_INT_24_8_REV = 36269] = "FLOAT_32_UNSIGNED_INT_24_8_REV", n[n.HALF_FLOAT = 36193] = "HALF_FLOAT";
})(TYPES$6 || (TYPES$6 = {}));
var SAMPLER_TYPES$6;
(function(n) {
  n[n.FLOAT = 0] = "FLOAT", n[n.INT = 1] = "INT", n[n.UINT = 2] = "UINT";
})(SAMPLER_TYPES$6 || (SAMPLER_TYPES$6 = {}));
var SCALE_MODES$6;
(function(n) {
  n[n.NEAREST = 0] = "NEAREST", n[n.LINEAR = 1] = "LINEAR";
})(SCALE_MODES$6 || (SCALE_MODES$6 = {}));
var WRAP_MODES$6;
(function(n) {
  n[n.CLAMP = 33071] = "CLAMP", n[n.REPEAT = 10497] = "REPEAT", n[n.MIRRORED_REPEAT = 33648] = "MIRRORED_REPEAT";
})(WRAP_MODES$6 || (WRAP_MODES$6 = {}));
var MIPMAP_MODES$6;
(function(n) {
  n[n.OFF = 0] = "OFF", n[n.POW2 = 1] = "POW2", n[n.ON = 2] = "ON", n[n.ON_MANUAL = 3] = "ON_MANUAL";
})(MIPMAP_MODES$6 || (MIPMAP_MODES$6 = {}));
var ALPHA_MODES$6;
(function(n) {
  n[n.NPM = 0] = "NPM", n[n.UNPACK = 1] = "UNPACK", n[n.PMA = 2] = "PMA", n[n.NO_PREMULTIPLIED_ALPHA = 0] = "NO_PREMULTIPLIED_ALPHA", n[n.PREMULTIPLY_ON_UPLOAD = 1] = "PREMULTIPLY_ON_UPLOAD", n[n.PREMULTIPLY_ALPHA = 2] = "PREMULTIPLY_ALPHA", n[n.PREMULTIPLIED_ALPHA = 2] = "PREMULTIPLIED_ALPHA";
})(ALPHA_MODES$6 || (ALPHA_MODES$6 = {}));
var CLEAR_MODES$6;
(function(n) {
  n[n.NO = 0] = "NO", n[n.YES = 1] = "YES", n[n.AUTO = 2] = "AUTO", n[n.BLEND = 0] = "BLEND", n[n.CLEAR = 1] = "CLEAR", n[n.BLIT = 2] = "BLIT";
})(CLEAR_MODES$6 || (CLEAR_MODES$6 = {}));
var GC_MODES$6;
(function(n) {
  n[n.AUTO = 0] = "AUTO", n[n.MANUAL = 1] = "MANUAL";
})(GC_MODES$6 || (GC_MODES$6 = {}));
var PRECISION$6;
(function(n) {
  n.LOW = "lowp", n.MEDIUM = "mediump", n.HIGH = "highp";
})(PRECISION$6 || (PRECISION$6 = {}));
var MASK_TYPES$6;
(function(n) {
  n[n.NONE = 0] = "NONE", n[n.SCISSOR = 1] = "SCISSOR", n[n.STENCIL = 2] = "STENCIL", n[n.SPRITE = 3] = "SPRITE", n[n.COLOR = 4] = "COLOR";
})(MASK_TYPES$6 || (MASK_TYPES$6 = {}));
var COLOR_MASK_BITS$6;
(function(n) {
  n[n.RED = 1] = "RED", n[n.GREEN = 2] = "GREEN", n[n.BLUE = 4] = "BLUE", n[n.ALPHA = 8] = "ALPHA";
})(COLOR_MASK_BITS$6 || (COLOR_MASK_BITS$6 = {}));
var MSAA_QUALITY$6;
(function(n) {
  n[n.NONE = 0] = "NONE", n[n.LOW = 2] = "LOW", n[n.MEDIUM = 4] = "MEDIUM", n[n.HIGH = 8] = "HIGH";
})(MSAA_QUALITY$6 || (MSAA_QUALITY$6 = {}));
var BUFFER_TYPE$6;
(function(n) {
  n[n.ELEMENT_ARRAY_BUFFER = 34963] = "ELEMENT_ARRAY_BUFFER", n[n.ARRAY_BUFFER = 34962] = "ARRAY_BUFFER", n[n.UNIFORM_BUFFER = 35345] = "UNIFORM_BUFFER";
})(BUFFER_TYPE$6 || (BUFFER_TYPE$6 = {}));
var BrowserAdapter$1 = {
  createCanvas: function(n, t) {
    var e = document.createElement("canvas");
    return e.width = n, e.height = t, e;
  },
  getWebGLRenderingContext: function() {
    return WebGLRenderingContext;
  },
  getNavigator: function() {
    return navigator;
  },
  getBaseUrl: function() {
    var n;
    return (n = document.baseURI) !== null && n !== void 0 ? n : window.location.href;
  },
  fetch: function(n, t) {
    return fetch(n, t);
  }
}, appleIphone$1 = /iPhone/i, appleIpod$1 = /iPod/i, appleTablet$1 = /iPad/i, appleUniversal$1 = /\biOS-universal(?:.+)Mac\b/i, androidPhone$1 = /\bAndroid(?:.+)Mobile\b/i, androidTablet$1 = /Android/i, amazonPhone$1 = /(?:SD4930UR|\bSilk(?:.+)Mobile\b)/i, amazonTablet$1 = /Silk/i, windowsPhone$1 = /Windows Phone/i, windowsTablet$1 = /\bWindows(?:.+)ARM\b/i, otherBlackBerry$1 = /BlackBerry/i, otherBlackBerry10$1 = /BB10/i, otherOpera$1 = /Opera Mini/i, otherChrome$1 = /\b(CriOS|Chrome)(?:.+)Mobile/i, otherFirefox$1 = /Mobile(?:.+)Firefox\b/i, isAppleTabletOnIos13$1 = function(n) {
  return typeof n < "u" && n.platform === "MacIntel" && typeof n.maxTouchPoints == "number" && n.maxTouchPoints > 1 && typeof MSStream > "u";
};
function createMatch$1(n) {
  return function(t) {
    return t.test(n);
  };
}
function isMobile$1$1(n) {
  var t = {
    userAgent: "",
    platform: "",
    maxTouchPoints: 0
  };
  !n && typeof navigator < "u" ? t = {
    userAgent: navigator.userAgent,
    platform: navigator.platform,
    maxTouchPoints: navigator.maxTouchPoints || 0
  } : typeof n == "string" ? t.userAgent = n : n && n.userAgent && (t = {
    userAgent: n.userAgent,
    platform: n.platform,
    maxTouchPoints: n.maxTouchPoints || 0
  });
  var e = t.userAgent, o = e.split("[FBAN");
  typeof o[1] < "u" && (e = o[0]), o = e.split("Twitter"), typeof o[1] < "u" && (e = o[0]);
  var R = createMatch$1(e), N = {
    apple: {
      phone: R(appleIphone$1) && !R(windowsPhone$1),
      ipod: R(appleIpod$1),
      tablet: !R(appleIphone$1) && (R(appleTablet$1) || isAppleTabletOnIos13$1(t)) && !R(windowsPhone$1),
      universal: R(appleUniversal$1),
      device: (R(appleIphone$1) || R(appleIpod$1) || R(appleTablet$1) || R(appleUniversal$1) || isAppleTabletOnIos13$1(t)) && !R(windowsPhone$1)
    },
    amazon: {
      phone: R(amazonPhone$1),
      tablet: !R(amazonPhone$1) && R(amazonTablet$1),
      device: R(amazonPhone$1) || R(amazonTablet$1)
    },
    android: {
      phone: !R(windowsPhone$1) && R(amazonPhone$1) || !R(windowsPhone$1) && R(androidPhone$1),
      tablet: !R(windowsPhone$1) && !R(amazonPhone$1) && !R(androidPhone$1) && (R(amazonTablet$1) || R(androidTablet$1)),
      device: !R(windowsPhone$1) && (R(amazonPhone$1) || R(amazonTablet$1) || R(androidPhone$1) || R(androidTablet$1)) || R(/\bokhttp\b/i)
    },
    windows: {
      phone: R(windowsPhone$1),
      tablet: R(windowsTablet$1),
      device: R(windowsPhone$1) || R(windowsTablet$1)
    },
    other: {
      blackberry: R(otherBlackBerry$1),
      blackberry10: R(otherBlackBerry10$1),
      opera: R(otherOpera$1),
      firefox: R(otherFirefox$1),
      chrome: R(otherChrome$1),
      device: R(otherBlackBerry$1) || R(otherBlackBerry10$1) || R(otherOpera$1) || R(otherFirefox$1) || R(otherChrome$1)
    },
    any: !1,
    phone: !1,
    tablet: !1
  };
  return N.any = N.apple.device || N.android.device || N.windows.device || N.other.device, N.phone = N.apple.phone || N.android.phone || N.windows.phone, N.tablet = N.apple.tablet || N.android.tablet || N.windows.tablet, N;
}
var isMobile$2 = isMobile$1$1(globalThis.navigator);
function canUploadSameBuffer$1() {
  return !isMobile$2.apple.device;
}
function maxRecommendedTextures$1(n) {
  var t = !0;
  if (isMobile$2.tablet || isMobile$2.phone) {
    if (isMobile$2.apple.device) {
      var e = navigator.userAgent.match(/OS (\d+)_(\d+)?/);
      if (e) {
        var o = parseInt(e[1], 10);
        o < 11 && (t = !1);
      }
    }
    if (isMobile$2.android.device) {
      var e = navigator.userAgent.match(/Android\s([0-9.]*)/);
      if (e) {
        var o = parseInt(e[1], 10);
        o < 7 && (t = !1);
      }
    }
  }
  return t ? n : 4;
}
var settings$1 = {
  ADAPTER: BrowserAdapter$1,
  MIPMAP_TEXTURES: MIPMAP_MODES$6.POW2,
  ANISOTROPIC_LEVEL: 0,
  RESOLUTION: 1,
  FILTER_RESOLUTION: 1,
  FILTER_MULTISAMPLE: MSAA_QUALITY$6.NONE,
  SPRITE_MAX_TEXTURES: maxRecommendedTextures$1(32),
  SPRITE_BATCH_SIZE: 4096,
  RENDER_OPTIONS: {
    view: null,
    antialias: !1,
    autoDensity: !1,
    backgroundColor: 0,
    backgroundAlpha: 1,
    useContextAlpha: !0,
    clearBeforeRender: !0,
    preserveDrawingBuffer: !1,
    width: 800,
    height: 600,
    legacy: !1
  },
  GC_MODE: GC_MODES$6.AUTO,
  GC_MAX_IDLE: 60 * 60,
  GC_MAX_CHECK_COUNT: 60 * 10,
  WRAP_MODE: WRAP_MODES$6.CLAMP,
  SCALE_MODE: SCALE_MODES$6.LINEAR,
  PRECISION_VERTEX: PRECISION$6.HIGH,
  PRECISION_FRAGMENT: isMobile$2.apple.device ? PRECISION$6.HIGH : PRECISION$6.MEDIUM,
  CAN_UPLOAD_SAME_BUFFER: canUploadSameBuffer$1(),
  CREATE_IMAGE_BITMAP: !1,
  ROUND_PIXELS: !1
};
/*!
 * @pixi/constants - v6.5.2
 * Compiled Wed, 24 Aug 2022 13:51:19 UTC
 *
 * @pixi/constants is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
var ENV$5;
(function(n) {
  n[n.WEBGL_LEGACY = 0] = "WEBGL_LEGACY", n[n.WEBGL = 1] = "WEBGL", n[n.WEBGL2 = 2] = "WEBGL2";
})(ENV$5 || (ENV$5 = {}));
var RENDERER_TYPE$5;
(function(n) {
  n[n.UNKNOWN = 0] = "UNKNOWN", n[n.WEBGL = 1] = "WEBGL", n[n.CANVAS = 2] = "CANVAS";
})(RENDERER_TYPE$5 || (RENDERER_TYPE$5 = {}));
var BUFFER_BITS$5;
(function(n) {
  n[n.COLOR = 16384] = "COLOR", n[n.DEPTH = 256] = "DEPTH", n[n.STENCIL = 1024] = "STENCIL";
})(BUFFER_BITS$5 || (BUFFER_BITS$5 = {}));
var BLEND_MODES$5;
(function(n) {
  n[n.NORMAL = 0] = "NORMAL", n[n.ADD = 1] = "ADD", n[n.MULTIPLY = 2] = "MULTIPLY", n[n.SCREEN = 3] = "SCREEN", n[n.OVERLAY = 4] = "OVERLAY", n[n.DARKEN = 5] = "DARKEN", n[n.LIGHTEN = 6] = "LIGHTEN", n[n.COLOR_DODGE = 7] = "COLOR_DODGE", n[n.COLOR_BURN = 8] = "COLOR_BURN", n[n.HARD_LIGHT = 9] = "HARD_LIGHT", n[n.SOFT_LIGHT = 10] = "SOFT_LIGHT", n[n.DIFFERENCE = 11] = "DIFFERENCE", n[n.EXCLUSION = 12] = "EXCLUSION", n[n.HUE = 13] = "HUE", n[n.SATURATION = 14] = "SATURATION", n[n.COLOR = 15] = "COLOR", n[n.LUMINOSITY = 16] = "LUMINOSITY", n[n.NORMAL_NPM = 17] = "NORMAL_NPM", n[n.ADD_NPM = 18] = "ADD_NPM", n[n.SCREEN_NPM = 19] = "SCREEN_NPM", n[n.NONE = 20] = "NONE", n[n.SRC_OVER = 0] = "SRC_OVER", n[n.SRC_IN = 21] = "SRC_IN", n[n.SRC_OUT = 22] = "SRC_OUT", n[n.SRC_ATOP = 23] = "SRC_ATOP", n[n.DST_OVER = 24] = "DST_OVER", n[n.DST_IN = 25] = "DST_IN", n[n.DST_OUT = 26] = "DST_OUT", n[n.DST_ATOP = 27] = "DST_ATOP", n[n.ERASE = 26] = "ERASE", n[n.SUBTRACT = 28] = "SUBTRACT", n[n.XOR = 29] = "XOR";
})(BLEND_MODES$5 || (BLEND_MODES$5 = {}));
var DRAW_MODES$5;
(function(n) {
  n[n.POINTS = 0] = "POINTS", n[n.LINES = 1] = "LINES", n[n.LINE_LOOP = 2] = "LINE_LOOP", n[n.LINE_STRIP = 3] = "LINE_STRIP", n[n.TRIANGLES = 4] = "TRIANGLES", n[n.TRIANGLE_STRIP = 5] = "TRIANGLE_STRIP", n[n.TRIANGLE_FAN = 6] = "TRIANGLE_FAN";
})(DRAW_MODES$5 || (DRAW_MODES$5 = {}));
var FORMATS$5;
(function(n) {
  n[n.RGBA = 6408] = "RGBA", n[n.RGB = 6407] = "RGB", n[n.RG = 33319] = "RG", n[n.RED = 6403] = "RED", n[n.RGBA_INTEGER = 36249] = "RGBA_INTEGER", n[n.RGB_INTEGER = 36248] = "RGB_INTEGER", n[n.RG_INTEGER = 33320] = "RG_INTEGER", n[n.RED_INTEGER = 36244] = "RED_INTEGER", n[n.ALPHA = 6406] = "ALPHA", n[n.LUMINANCE = 6409] = "LUMINANCE", n[n.LUMINANCE_ALPHA = 6410] = "LUMINANCE_ALPHA", n[n.DEPTH_COMPONENT = 6402] = "DEPTH_COMPONENT", n[n.DEPTH_STENCIL = 34041] = "DEPTH_STENCIL";
})(FORMATS$5 || (FORMATS$5 = {}));
var TARGETS$5;
(function(n) {
  n[n.TEXTURE_2D = 3553] = "TEXTURE_2D", n[n.TEXTURE_CUBE_MAP = 34067] = "TEXTURE_CUBE_MAP", n[n.TEXTURE_2D_ARRAY = 35866] = "TEXTURE_2D_ARRAY", n[n.TEXTURE_CUBE_MAP_POSITIVE_X = 34069] = "TEXTURE_CUBE_MAP_POSITIVE_X", n[n.TEXTURE_CUBE_MAP_NEGATIVE_X = 34070] = "TEXTURE_CUBE_MAP_NEGATIVE_X", n[n.TEXTURE_CUBE_MAP_POSITIVE_Y = 34071] = "TEXTURE_CUBE_MAP_POSITIVE_Y", n[n.TEXTURE_CUBE_MAP_NEGATIVE_Y = 34072] = "TEXTURE_CUBE_MAP_NEGATIVE_Y", n[n.TEXTURE_CUBE_MAP_POSITIVE_Z = 34073] = "TEXTURE_CUBE_MAP_POSITIVE_Z", n[n.TEXTURE_CUBE_MAP_NEGATIVE_Z = 34074] = "TEXTURE_CUBE_MAP_NEGATIVE_Z";
})(TARGETS$5 || (TARGETS$5 = {}));
var TYPES$5;
(function(n) {
  n[n.UNSIGNED_BYTE = 5121] = "UNSIGNED_BYTE", n[n.UNSIGNED_SHORT = 5123] = "UNSIGNED_SHORT", n[n.UNSIGNED_SHORT_5_6_5 = 33635] = "UNSIGNED_SHORT_5_6_5", n[n.UNSIGNED_SHORT_4_4_4_4 = 32819] = "UNSIGNED_SHORT_4_4_4_4", n[n.UNSIGNED_SHORT_5_5_5_1 = 32820] = "UNSIGNED_SHORT_5_5_5_1", n[n.UNSIGNED_INT = 5125] = "UNSIGNED_INT", n[n.UNSIGNED_INT_10F_11F_11F_REV = 35899] = "UNSIGNED_INT_10F_11F_11F_REV", n[n.UNSIGNED_INT_2_10_10_10_REV = 33640] = "UNSIGNED_INT_2_10_10_10_REV", n[n.UNSIGNED_INT_24_8 = 34042] = "UNSIGNED_INT_24_8", n[n.UNSIGNED_INT_5_9_9_9_REV = 35902] = "UNSIGNED_INT_5_9_9_9_REV", n[n.BYTE = 5120] = "BYTE", n[n.SHORT = 5122] = "SHORT", n[n.INT = 5124] = "INT", n[n.FLOAT = 5126] = "FLOAT", n[n.FLOAT_32_UNSIGNED_INT_24_8_REV = 36269] = "FLOAT_32_UNSIGNED_INT_24_8_REV", n[n.HALF_FLOAT = 36193] = "HALF_FLOAT";
})(TYPES$5 || (TYPES$5 = {}));
var SAMPLER_TYPES$5;
(function(n) {
  n[n.FLOAT = 0] = "FLOAT", n[n.INT = 1] = "INT", n[n.UINT = 2] = "UINT";
})(SAMPLER_TYPES$5 || (SAMPLER_TYPES$5 = {}));
var SCALE_MODES$5;
(function(n) {
  n[n.NEAREST = 0] = "NEAREST", n[n.LINEAR = 1] = "LINEAR";
})(SCALE_MODES$5 || (SCALE_MODES$5 = {}));
var WRAP_MODES$5;
(function(n) {
  n[n.CLAMP = 33071] = "CLAMP", n[n.REPEAT = 10497] = "REPEAT", n[n.MIRRORED_REPEAT = 33648] = "MIRRORED_REPEAT";
})(WRAP_MODES$5 || (WRAP_MODES$5 = {}));
var MIPMAP_MODES$5;
(function(n) {
  n[n.OFF = 0] = "OFF", n[n.POW2 = 1] = "POW2", n[n.ON = 2] = "ON", n[n.ON_MANUAL = 3] = "ON_MANUAL";
})(MIPMAP_MODES$5 || (MIPMAP_MODES$5 = {}));
var ALPHA_MODES$5;
(function(n) {
  n[n.NPM = 0] = "NPM", n[n.UNPACK = 1] = "UNPACK", n[n.PMA = 2] = "PMA", n[n.NO_PREMULTIPLIED_ALPHA = 0] = "NO_PREMULTIPLIED_ALPHA", n[n.PREMULTIPLY_ON_UPLOAD = 1] = "PREMULTIPLY_ON_UPLOAD", n[n.PREMULTIPLY_ALPHA = 2] = "PREMULTIPLY_ALPHA", n[n.PREMULTIPLIED_ALPHA = 2] = "PREMULTIPLIED_ALPHA";
})(ALPHA_MODES$5 || (ALPHA_MODES$5 = {}));
var CLEAR_MODES$5;
(function(n) {
  n[n.NO = 0] = "NO", n[n.YES = 1] = "YES", n[n.AUTO = 2] = "AUTO", n[n.BLEND = 0] = "BLEND", n[n.CLEAR = 1] = "CLEAR", n[n.BLIT = 2] = "BLIT";
})(CLEAR_MODES$5 || (CLEAR_MODES$5 = {}));
var GC_MODES$5;
(function(n) {
  n[n.AUTO = 0] = "AUTO", n[n.MANUAL = 1] = "MANUAL";
})(GC_MODES$5 || (GC_MODES$5 = {}));
var PRECISION$5;
(function(n) {
  n.LOW = "lowp", n.MEDIUM = "mediump", n.HIGH = "highp";
})(PRECISION$5 || (PRECISION$5 = {}));
var MASK_TYPES$5;
(function(n) {
  n[n.NONE = 0] = "NONE", n[n.SCISSOR = 1] = "SCISSOR", n[n.STENCIL = 2] = "STENCIL", n[n.SPRITE = 3] = "SPRITE", n[n.COLOR = 4] = "COLOR";
})(MASK_TYPES$5 || (MASK_TYPES$5 = {}));
var COLOR_MASK_BITS$5;
(function(n) {
  n[n.RED = 1] = "RED", n[n.GREEN = 2] = "GREEN", n[n.BLUE = 4] = "BLUE", n[n.ALPHA = 8] = "ALPHA";
})(COLOR_MASK_BITS$5 || (COLOR_MASK_BITS$5 = {}));
var MSAA_QUALITY$5;
(function(n) {
  n[n.NONE = 0] = "NONE", n[n.LOW = 2] = "LOW", n[n.MEDIUM = 4] = "MEDIUM", n[n.HIGH = 8] = "HIGH";
})(MSAA_QUALITY$5 || (MSAA_QUALITY$5 = {}));
var BUFFER_TYPE$5;
(function(n) {
  n[n.ELEMENT_ARRAY_BUFFER = 34963] = "ELEMENT_ARRAY_BUFFER", n[n.ARRAY_BUFFER = 34962] = "ARRAY_BUFFER", n[n.UNIFORM_BUFFER = 35345] = "UNIFORM_BUFFER";
})(BUFFER_TYPE$5 || (BUFFER_TYPE$5 = {}));
var eventemitter3 = { exports: {} };
(function(n) {
  var t = Object.prototype.hasOwnProperty, e = "~";
  function o() {
  }
  Object.create && (o.prototype = /* @__PURE__ */ Object.create(null), new o().__proto__ || (e = !1));
  function R(L, B, $) {
    this.fn = L, this.context = B, this.once = $ || !1;
  }
  function N(L, B, $, k, U) {
    if (typeof $ != "function")
      throw new TypeError("The listener must be a function");
    var z = new R($, k || L, U), X = e ? e + B : B;
    return L._events[X] ? L._events[X].fn ? L._events[X] = [L._events[X], z] : L._events[X].push(z) : (L._events[X] = z, L._eventsCount++), L;
  }
  function M(L, B) {
    --L._eventsCount === 0 ? L._events = new o() : delete L._events[B];
  }
  function D() {
    this._events = new o(), this._eventsCount = 0;
  }
  D.prototype.eventNames = function() {
    var B = [], $, k;
    if (this._eventsCount === 0)
      return B;
    for (k in $ = this._events)
      t.call($, k) && B.push(e ? k.slice(1) : k);
    return Object.getOwnPropertySymbols ? B.concat(Object.getOwnPropertySymbols($)) : B;
  }, D.prototype.listeners = function(B) {
    var $ = e ? e + B : B, k = this._events[$];
    if (!k)
      return [];
    if (k.fn)
      return [k.fn];
    for (var U = 0, z = k.length, X = new Array(z); U < z; U++)
      X[U] = k[U].fn;
    return X;
  }, D.prototype.listenerCount = function(B) {
    var $ = e ? e + B : B, k = this._events[$];
    return k ? k.fn ? 1 : k.length : 0;
  }, D.prototype.emit = function(B, $, k, U, z, X) {
    var V = e ? e + B : B;
    if (!this._events[V])
      return !1;
    var W = this._events[V], Y = arguments.length, q, Z;
    if (W.fn) {
      switch (W.once && this.removeListener(B, W.fn, void 0, !0), Y) {
        case 1:
          return W.fn.call(W.context), !0;
        case 2:
          return W.fn.call(W.context, $), !0;
        case 3:
          return W.fn.call(W.context, $, k), !0;
        case 4:
          return W.fn.call(W.context, $, k, U), !0;
        case 5:
          return W.fn.call(W.context, $, k, U, z), !0;
        case 6:
          return W.fn.call(W.context, $, k, U, z, X), !0;
      }
      for (Z = 1, q = new Array(Y - 1); Z < Y; Z++)
        q[Z - 1] = arguments[Z];
      W.fn.apply(W.context, q);
    } else {
      var J = W.length, Q;
      for (Z = 0; Z < J; Z++)
        switch (W[Z].once && this.removeListener(B, W[Z].fn, void 0, !0), Y) {
          case 1:
            W[Z].fn.call(W[Z].context);
            break;
          case 2:
            W[Z].fn.call(W[Z].context, $);
            break;
          case 3:
            W[Z].fn.call(W[Z].context, $, k);
            break;
          case 4:
            W[Z].fn.call(W[Z].context, $, k, U);
            break;
          default:
            if (!q)
              for (Q = 1, q = new Array(Y - 1); Q < Y; Q++)
                q[Q - 1] = arguments[Q];
            W[Z].fn.apply(W[Z].context, q);
        }
    }
    return !0;
  }, D.prototype.on = function(B, $, k) {
    return N(this, B, $, k, !1);
  }, D.prototype.once = function(B, $, k) {
    return N(this, B, $, k, !0);
  }, D.prototype.removeListener = function(B, $, k, U) {
    var z = e ? e + B : B;
    if (!this._events[z])
      return this;
    if (!$)
      return M(this, z), this;
    var X = this._events[z];
    if (X.fn)
      X.fn === $ && (!U || X.once) && (!k || X.context === k) && M(this, z);
    else {
      for (var V = 0, W = [], Y = X.length; V < Y; V++)
        (X[V].fn !== $ || U && !X[V].once || k && X[V].context !== k) && W.push(X[V]);
      W.length ? this._events[z] = W.length === 1 ? W[0] : W : M(this, z);
    }
    return this;
  }, D.prototype.removeAllListeners = function(B) {
    var $;
    return B ? ($ = e ? e + B : B, this._events[$] && M(this, $)) : (this._events = new o(), this._eventsCount = 0), this;
  }, D.prototype.off = D.prototype.removeListener, D.prototype.addListener = D.prototype.on, D.prefixed = e, D.EventEmitter = D, n.exports = D;
})(eventemitter3);
const EventEmitter$4 = eventemitter3.exports;
var earcut$1 = { exports: {} };
earcut$1.exports = earcut;
earcut$1.exports.default = earcut;
function earcut(n, t, e) {
  e = e || 2;
  var o = t && t.length, R = o ? t[0] * e : n.length, N = linkedList(n, 0, R, e, !0), M = [];
  if (!N || N.next === N.prev)
    return M;
  var D, L, B, $, k, U, z;
  if (o && (N = eliminateHoles(n, t, N, e)), n.length > 80 * e) {
    D = B = n[0], L = $ = n[1];
    for (var X = e; X < R; X += e)
      k = n[X], U = n[X + 1], k < D && (D = k), U < L && (L = U), k > B && (B = k), U > $ && ($ = U);
    z = Math.max(B - D, $ - L), z = z !== 0 ? 32767 / z : 0;
  }
  return earcutLinked(N, M, e, D, L, z, 0), M;
}
function linkedList(n, t, e, o, R) {
  var N, M;
  if (R === signedArea(n, t, e, o) > 0)
    for (N = t; N < e; N += o)
      M = insertNode(N, n[N], n[N + 1], M);
  else
    for (N = e - o; N >= t; N -= o)
      M = insertNode(N, n[N], n[N + 1], M);
  return M && equals$1(M, M.next) && (removeNode(M), M = M.next), M;
}
function filterPoints(n, t) {
  if (!n)
    return n;
  t || (t = n);
  var e = n, o;
  do
    if (o = !1, !e.steiner && (equals$1(e, e.next) || area(e.prev, e, e.next) === 0)) {
      if (removeNode(e), e = t = e.prev, e === e.next)
        break;
      o = !0;
    } else
      e = e.next;
  while (o || e !== t);
  return t;
}
function earcutLinked(n, t, e, o, R, N, M) {
  if (!!n) {
    !M && N && indexCurve(n, o, R, N);
    for (var D = n, L, B; n.prev !== n.next; ) {
      if (L = n.prev, B = n.next, N ? isEarHashed(n, o, R, N) : isEar(n)) {
        t.push(L.i / e | 0), t.push(n.i / e | 0), t.push(B.i / e | 0), removeNode(n), n = B.next, D = B.next;
        continue;
      }
      if (n = B, n === D) {
        M ? M === 1 ? (n = cureLocalIntersections(filterPoints(n), t, e), earcutLinked(n, t, e, o, R, N, 2)) : M === 2 && splitEarcut(n, t, e, o, R, N) : earcutLinked(filterPoints(n), t, e, o, R, N, 1);
        break;
      }
    }
  }
}
function isEar(n) {
  var t = n.prev, e = n, o = n.next;
  if (area(t, e, o) >= 0)
    return !1;
  for (var R = t.x, N = e.x, M = o.x, D = t.y, L = e.y, B = o.y, $ = R < N ? R < M ? R : M : N < M ? N : M, k = D < L ? D < B ? D : B : L < B ? L : B, U = R > N ? R > M ? R : M : N > M ? N : M, z = D > L ? D > B ? D : B : L > B ? L : B, X = o.next; X !== t; ) {
    if (X.x >= $ && X.x <= U && X.y >= k && X.y <= z && pointInTriangle(R, D, N, L, M, B, X.x, X.y) && area(X.prev, X, X.next) >= 0)
      return !1;
    X = X.next;
  }
  return !0;
}
function isEarHashed(n, t, e, o) {
  var R = n.prev, N = n, M = n.next;
  if (area(R, N, M) >= 0)
    return !1;
  for (var D = R.x, L = N.x, B = M.x, $ = R.y, k = N.y, U = M.y, z = D < L ? D < B ? D : B : L < B ? L : B, X = $ < k ? $ < U ? $ : U : k < U ? k : U, V = D > L ? D > B ? D : B : L > B ? L : B, W = $ > k ? $ > U ? $ : U : k > U ? k : U, Y = zOrder(z, X, t, e, o), q = zOrder(V, W, t, e, o), Z = n.prevZ, J = n.nextZ; Z && Z.z >= Y && J && J.z <= q; ) {
    if (Z.x >= z && Z.x <= V && Z.y >= X && Z.y <= W && Z !== R && Z !== M && pointInTriangle(D, $, L, k, B, U, Z.x, Z.y) && area(Z.prev, Z, Z.next) >= 0 || (Z = Z.prevZ, J.x >= z && J.x <= V && J.y >= X && J.y <= W && J !== R && J !== M && pointInTriangle(D, $, L, k, B, U, J.x, J.y) && area(J.prev, J, J.next) >= 0))
      return !1;
    J = J.nextZ;
  }
  for (; Z && Z.z >= Y; ) {
    if (Z.x >= z && Z.x <= V && Z.y >= X && Z.y <= W && Z !== R && Z !== M && pointInTriangle(D, $, L, k, B, U, Z.x, Z.y) && area(Z.prev, Z, Z.next) >= 0)
      return !1;
    Z = Z.prevZ;
  }
  for (; J && J.z <= q; ) {
    if (J.x >= z && J.x <= V && J.y >= X && J.y <= W && J !== R && J !== M && pointInTriangle(D, $, L, k, B, U, J.x, J.y) && area(J.prev, J, J.next) >= 0)
      return !1;
    J = J.nextZ;
  }
  return !0;
}
function cureLocalIntersections(n, t, e) {
  var o = n;
  do {
    var R = o.prev, N = o.next.next;
    !equals$1(R, N) && intersects(R, o, o.next, N) && locallyInside(R, N) && locallyInside(N, R) && (t.push(R.i / e | 0), t.push(o.i / e | 0), t.push(N.i / e | 0), removeNode(o), removeNode(o.next), o = n = N), o = o.next;
  } while (o !== n);
  return filterPoints(o);
}
function splitEarcut(n, t, e, o, R, N) {
  var M = n;
  do {
    for (var D = M.next.next; D !== M.prev; ) {
      if (M.i !== D.i && isValidDiagonal(M, D)) {
        var L = splitPolygon(M, D);
        M = filterPoints(M, M.next), L = filterPoints(L, L.next), earcutLinked(M, t, e, o, R, N, 0), earcutLinked(L, t, e, o, R, N, 0);
        return;
      }
      D = D.next;
    }
    M = M.next;
  } while (M !== n);
}
function eliminateHoles(n, t, e, o) {
  var R = [], N, M, D, L, B;
  for (N = 0, M = t.length; N < M; N++)
    D = t[N] * o, L = N < M - 1 ? t[N + 1] * o : n.length, B = linkedList(n, D, L, o, !1), B === B.next && (B.steiner = !0), R.push(getLeftmost(B));
  for (R.sort(compareX), N = 0; N < R.length; N++)
    e = eliminateHole(R[N], e);
  return e;
}
function compareX(n, t) {
  return n.x - t.x;
}
function eliminateHole(n, t) {
  var e = findHoleBridge(n, t);
  if (!e)
    return t;
  var o = splitPolygon(e, n);
  return filterPoints(o, o.next), filterPoints(e, e.next);
}
function findHoleBridge(n, t) {
  var e = t, o = n.x, R = n.y, N = -1 / 0, M;
  do {
    if (R <= e.y && R >= e.next.y && e.next.y !== e.y) {
      var D = e.x + (R - e.y) * (e.next.x - e.x) / (e.next.y - e.y);
      if (D <= o && D > N && (N = D, M = e.x < e.next.x ? e : e.next, D === o))
        return M;
    }
    e = e.next;
  } while (e !== t);
  if (!M)
    return null;
  var L = M, B = M.x, $ = M.y, k = 1 / 0, U;
  e = M;
  do
    o >= e.x && e.x >= B && o !== e.x && pointInTriangle(R < $ ? o : N, R, B, $, R < $ ? N : o, R, e.x, e.y) && (U = Math.abs(R - e.y) / (o - e.x), locallyInside(e, n) && (U < k || U === k && (e.x > M.x || e.x === M.x && sectorContainsSector(M, e))) && (M = e, k = U)), e = e.next;
  while (e !== L);
  return M;
}
function sectorContainsSector(n, t) {
  return area(n.prev, n, t.prev) < 0 && area(t.next, n, n.next) < 0;
}
function indexCurve(n, t, e, o) {
  var R = n;
  do
    R.z === 0 && (R.z = zOrder(R.x, R.y, t, e, o)), R.prevZ = R.prev, R.nextZ = R.next, R = R.next;
  while (R !== n);
  R.prevZ.nextZ = null, R.prevZ = null, sortLinked(R);
}
function sortLinked(n) {
  var t, e, o, R, N, M, D, L, B = 1;
  do {
    for (e = n, n = null, N = null, M = 0; e; ) {
      for (M++, o = e, D = 0, t = 0; t < B && (D++, o = o.nextZ, !!o); t++)
        ;
      for (L = B; D > 0 || L > 0 && o; )
        D !== 0 && (L === 0 || !o || e.z <= o.z) ? (R = e, e = e.nextZ, D--) : (R = o, o = o.nextZ, L--), N ? N.nextZ = R : n = R, R.prevZ = N, N = R;
      e = o;
    }
    N.nextZ = null, B *= 2;
  } while (M > 1);
  return n;
}
function zOrder(n, t, e, o, R) {
  return n = (n - e) * R | 0, t = (t - o) * R | 0, n = (n | n << 8) & 16711935, n = (n | n << 4) & 252645135, n = (n | n << 2) & 858993459, n = (n | n << 1) & 1431655765, t = (t | t << 8) & 16711935, t = (t | t << 4) & 252645135, t = (t | t << 2) & 858993459, t = (t | t << 1) & 1431655765, n | t << 1;
}
function getLeftmost(n) {
  var t = n, e = n;
  do
    (t.x < e.x || t.x === e.x && t.y < e.y) && (e = t), t = t.next;
  while (t !== n);
  return e;
}
function pointInTriangle(n, t, e, o, R, N, M, D) {
  return (R - M) * (t - D) >= (n - M) * (N - D) && (n - M) * (o - D) >= (e - M) * (t - D) && (e - M) * (N - D) >= (R - M) * (o - D);
}
function isValidDiagonal(n, t) {
  return n.next.i !== t.i && n.prev.i !== t.i && !intersectsPolygon(n, t) && (locallyInside(n, t) && locallyInside(t, n) && middleInside(n, t) && (area(n.prev, n, t.prev) || area(n, t.prev, t)) || equals$1(n, t) && area(n.prev, n, n.next) > 0 && area(t.prev, t, t.next) > 0);
}
function area(n, t, e) {
  return (t.y - n.y) * (e.x - t.x) - (t.x - n.x) * (e.y - t.y);
}
function equals$1(n, t) {
  return n.x === t.x && n.y === t.y;
}
function intersects(n, t, e, o) {
  var R = sign$1(area(n, t, e)), N = sign$1(area(n, t, o)), M = sign$1(area(e, o, n)), D = sign$1(area(e, o, t));
  return !!(R !== N && M !== D || R === 0 && onSegment(n, e, t) || N === 0 && onSegment(n, o, t) || M === 0 && onSegment(e, n, o) || D === 0 && onSegment(e, t, o));
}
function onSegment(n, t, e) {
  return t.x <= Math.max(n.x, e.x) && t.x >= Math.min(n.x, e.x) && t.y <= Math.max(n.y, e.y) && t.y >= Math.min(n.y, e.y);
}
function sign$1(n) {
  return n > 0 ? 1 : n < 0 ? -1 : 0;
}
function intersectsPolygon(n, t) {
  var e = n;
  do {
    if (e.i !== n.i && e.next.i !== n.i && e.i !== t.i && e.next.i !== t.i && intersects(e, e.next, n, t))
      return !0;
    e = e.next;
  } while (e !== n);
  return !1;
}
function locallyInside(n, t) {
  return area(n.prev, n, n.next) < 0 ? area(n, t, n.next) >= 0 && area(n, n.prev, t) >= 0 : area(n, t, n.prev) < 0 || area(n, n.next, t) < 0;
}
function middleInside(n, t) {
  var e = n, o = !1, R = (n.x + t.x) / 2, N = (n.y + t.y) / 2;
  do
    e.y > N != e.next.y > N && e.next.y !== e.y && R < (e.next.x - e.x) * (N - e.y) / (e.next.y - e.y) + e.x && (o = !o), e = e.next;
  while (e !== n);
  return o;
}
function splitPolygon(n, t) {
  var e = new Node$1(n.i, n.x, n.y), o = new Node$1(t.i, t.x, t.y), R = n.next, N = t.prev;
  return n.next = t, t.prev = n, e.next = R, R.prev = e, o.next = e, e.prev = o, N.next = o, o.prev = N, o;
}
function insertNode(n, t, e, o) {
  var R = new Node$1(n, t, e);
  return o ? (R.next = o.next, R.prev = o, o.next.prev = R, o.next = R) : (R.prev = R, R.next = R), R;
}
function removeNode(n) {
  n.next.prev = n.prev, n.prev.next = n.next, n.prevZ && (n.prevZ.nextZ = n.nextZ), n.nextZ && (n.nextZ.prevZ = n.prevZ);
}
function Node$1(n, t, e) {
  this.i = n, this.x = t, this.y = e, this.prev = null, this.next = null, this.z = 0, this.prevZ = null, this.nextZ = null, this.steiner = !1;
}
earcut.deviation = function(n, t, e, o) {
  var R = t && t.length, N = R ? t[0] * e : n.length, M = Math.abs(signedArea(n, 0, N, e));
  if (R)
    for (var D = 0, L = t.length; D < L; D++) {
      var B = t[D] * e, $ = D < L - 1 ? t[D + 1] * e : n.length;
      M -= Math.abs(signedArea(n, B, $, e));
    }
  var k = 0;
  for (D = 0; D < o.length; D += 3) {
    var U = o[D] * e, z = o[D + 1] * e, X = o[D + 2] * e;
    k += Math.abs(
      (n[U] - n[X]) * (n[z + 1] - n[U + 1]) - (n[U] - n[z]) * (n[X + 1] - n[U + 1])
    );
  }
  return M === 0 && k === 0 ? 0 : Math.abs((k - M) / M);
};
function signedArea(n, t, e, o) {
  for (var R = 0, N = t, M = e - o; N < e; N += o)
    R += (n[M] - n[N]) * (n[N + 1] + n[M + 1]), M = N;
  return R;
}
earcut.flatten = function(n) {
  for (var t = n[0][0].length, e = { vertices: [], holes: [], dimensions: t }, o = 0, R = 0; R < n.length; R++) {
    for (var N = 0; N < n[R].length; N++)
      for (var M = 0; M < t; M++)
        e.vertices.push(n[R][N][M]);
    R > 0 && (o += n[R - 1].length, e.holes.push(o));
  }
  return e;
};
var punycode$1 = { exports: {} };
/*! https://mths.be/punycode v1.3.2 by @mathias */
(function(n, t) {
  (function(e) {
    var o = t && !t.nodeType && t, R = n && !n.nodeType && n, N = typeof commonjsGlobal$1 == "object" && commonjsGlobal$1;
    (N.global === N || N.window === N || N.self === N) && (e = N);
    var M, D = 2147483647, L = 36, B = 1, $ = 26, k = 38, U = 700, z = 72, X = 128, V = "-", W = /^xn--/, Y = /[^\x20-\x7E]/, q = /[\x2E\u3002\uFF0E\uFF61]/g, Z = {
      overflow: "Overflow: input needs wider integers to process",
      "not-basic": "Illegal input >= 0x80 (not a basic code point)",
      "invalid-input": "Invalid input"
    }, J = L - B, Q = Math.floor, K = String.fromCharCode, rt;
    function tt(ct) {
      throw RangeError(Z[ct]);
    }
    function nt(ct, vt) {
      for (var Tt = ct.length, Pt = []; Tt--; )
        Pt[Tt] = vt(ct[Tt]);
      return Pt;
    }
    function at(ct, vt) {
      var Tt = ct.split("@"), Pt = "";
      Tt.length > 1 && (Pt = Tt[0] + "@", ct = Tt[1]), ct = ct.replace(q, ".");
      var wt = ct.split("."), Mt = nt(wt, vt).join(".");
      return Pt + Mt;
    }
    function lt(ct) {
      for (var vt = [], Tt = 0, Pt = ct.length, wt, Mt; Tt < Pt; )
        wt = ct.charCodeAt(Tt++), wt >= 55296 && wt <= 56319 && Tt < Pt ? (Mt = ct.charCodeAt(Tt++), (Mt & 64512) == 56320 ? vt.push(((wt & 1023) << 10) + (Mt & 1023) + 65536) : (vt.push(wt), Tt--)) : vt.push(wt);
      return vt;
    }
    function ut(ct) {
      return nt(ct, function(vt) {
        var Tt = "";
        return vt > 65535 && (vt -= 65536, Tt += K(vt >>> 10 & 1023 | 55296), vt = 56320 | vt & 1023), Tt += K(vt), Tt;
      }).join("");
    }
    function dt(ct) {
      return ct - 48 < 10 ? ct - 22 : ct - 65 < 26 ? ct - 65 : ct - 97 < 26 ? ct - 97 : L;
    }
    function yt(ct, vt) {
      return ct + 22 + 75 * (ct < 26) - ((vt != 0) << 5);
    }
    function pt(ct, vt, Tt) {
      var Pt = 0;
      for (ct = Tt ? Q(ct / U) : ct >> 1, ct += Q(ct / vt); ct > J * $ >> 1; Pt += L)
        ct = Q(ct / J);
      return Q(Pt + (J + 1) * ct / (ct + k));
    }
    function gt(ct) {
      var vt = [], Tt = ct.length, Pt, wt = 0, Mt = X, ht = z, $t, At, kt, Ot, _t, Gt, St, Et, Rt;
      for ($t = ct.lastIndexOf(V), $t < 0 && ($t = 0), At = 0; At < $t; ++At)
        ct.charCodeAt(At) >= 128 && tt("not-basic"), vt.push(ct.charCodeAt(At));
      for (kt = $t > 0 ? $t + 1 : 0; kt < Tt; ) {
        for (Ot = wt, _t = 1, Gt = L; kt >= Tt && tt("invalid-input"), St = dt(ct.charCodeAt(kt++)), (St >= L || St > Q((D - wt) / _t)) && tt("overflow"), wt += St * _t, Et = Gt <= ht ? B : Gt >= ht + $ ? $ : Gt - ht, !(St < Et); Gt += L)
          Rt = L - Et, _t > Q(D / Rt) && tt("overflow"), _t *= Rt;
        Pt = vt.length + 1, ht = pt(wt - Ot, Pt, Ot == 0), Q(wt / Pt) > D - Mt && tt("overflow"), Mt += Q(wt / Pt), wt %= Pt, vt.splice(wt++, 0, Mt);
      }
      return ut(vt);
    }
    function xt(ct) {
      var vt, Tt, Pt, wt, Mt, ht, $t, At, kt, Ot, _t, Gt = [], St, Et, Rt, Dt;
      for (ct = lt(ct), St = ct.length, vt = X, Tt = 0, Mt = z, ht = 0; ht < St; ++ht)
        _t = ct[ht], _t < 128 && Gt.push(K(_t));
      for (Pt = wt = Gt.length, wt && Gt.push(V); Pt < St; ) {
        for ($t = D, ht = 0; ht < St; ++ht)
          _t = ct[ht], _t >= vt && _t < $t && ($t = _t);
        for (Et = Pt + 1, $t - vt > Q((D - Tt) / Et) && tt("overflow"), Tt += ($t - vt) * Et, vt = $t, ht = 0; ht < St; ++ht)
          if (_t = ct[ht], _t < vt && ++Tt > D && tt("overflow"), _t == vt) {
            for (At = Tt, kt = L; Ot = kt <= Mt ? B : kt >= Mt + $ ? $ : kt - Mt, !(At < Ot); kt += L)
              Dt = At - Ot, Rt = L - Ot, Gt.push(
                K(yt(Ot + Dt % Rt, 0))
              ), At = Q(Dt / Rt);
            Gt.push(K(yt(At, 0))), Mt = pt(Tt, Et, Pt == wt), Tt = 0, ++Pt;
          }
        ++Tt, ++vt;
      }
      return Gt.join("");
    }
    function Lt(ct) {
      return at(ct, function(vt) {
        return W.test(vt) ? gt(vt.slice(4).toLowerCase()) : vt;
      });
    }
    function mt(ct) {
      return at(ct, function(vt) {
        return Y.test(vt) ? "xn--" + xt(vt) : vt;
      });
    }
    if (M = {
      version: "1.3.2",
      ucs2: {
        decode: lt,
        encode: ut
      },
      decode: gt,
      encode: xt,
      toASCII: mt,
      toUnicode: Lt
    }, o && R)
      if (n.exports == o)
        R.exports = M;
      else
        for (rt in M)
          M.hasOwnProperty(rt) && (o[rt] = M[rt]);
    else
      e.punycode = M;
  })(commonjsGlobal$1);
})(punycode$1, punycode$1.exports);
var util$8 = {
  isString: function(n) {
    return typeof n == "string";
  },
  isObject: function(n) {
    return typeof n == "object" && n !== null;
  },
  isNull: function(n) {
    return n === null;
  },
  isNullOrUndefined: function(n) {
    return n == null;
  }
}, querystring$1 = {};
function hasOwnProperty$2(n, t) {
  return Object.prototype.hasOwnProperty.call(n, t);
}
var decode$1 = function(n, t, e, o) {
  t = t || "&", e = e || "=";
  var R = {};
  if (typeof n != "string" || n.length === 0)
    return R;
  var N = /\+/g;
  n = n.split(t);
  var M = 1e3;
  o && typeof o.maxKeys == "number" && (M = o.maxKeys);
  var D = n.length;
  M > 0 && D > M && (D = M);
  for (var L = 0; L < D; ++L) {
    var B = n[L].replace(N, "%20"), $ = B.indexOf(e), k, U, z, X;
    $ >= 0 ? (k = B.substr(0, $), U = B.substr($ + 1)) : (k = B, U = ""), z = decodeURIComponent(k), X = decodeURIComponent(U), hasOwnProperty$2(R, z) ? Array.isArray(R[z]) ? R[z].push(X) : R[z] = [R[z], X] : R[z] = X;
  }
  return R;
}, stringifyPrimitive$1 = function(n) {
  switch (typeof n) {
    case "string":
      return n;
    case "boolean":
      return n ? "true" : "false";
    case "number":
      return isFinite(n) ? n : "";
    default:
      return "";
  }
}, encode$1 = function(n, t, e, o) {
  return t = t || "&", e = e || "=", n === null && (n = void 0), typeof n == "object" ? Object.keys(n).map(function(R) {
    var N = encodeURIComponent(stringifyPrimitive$1(R)) + e;
    return Array.isArray(n[R]) ? n[R].map(function(M) {
      return N + encodeURIComponent(stringifyPrimitive$1(M));
    }).join(t) : N + encodeURIComponent(stringifyPrimitive$1(n[R]));
  }).join(t) : o ? encodeURIComponent(stringifyPrimitive$1(o)) + e + encodeURIComponent(stringifyPrimitive$1(n)) : "";
};
querystring$1.decode = querystring$1.parse = decode$1;
querystring$1.encode = querystring$1.stringify = encode$1;
var punycode = punycode$1.exports, util$7 = util$8, parse$1 = urlParse, resolve$1 = urlResolve, format$1 = urlFormat;
function Url() {
  this.protocol = null, this.slashes = null, this.auth = null, this.host = null, this.port = null, this.hostname = null, this.hash = null, this.search = null, this.query = null, this.pathname = null, this.path = null, this.href = null;
}
var protocolPattern = /^([a-z0-9.+-]+:)/i, portPattern = /:[0-9]*$/, simplePathPattern = /^(\/\/?(?!\/)[^\?\s]*)(\?[^\s]*)?$/, delims = ["<", ">", '"', "`", " ", "\r", `
`, "	"], unwise = ["{", "}", "|", "\\", "^", "`"].concat(delims), autoEscape = ["'"].concat(unwise), nonHostChars = ["%", "/", "?", ";", "#"].concat(autoEscape), hostEndingChars = ["/", "?", "#"], hostnameMaxLen = 255, hostnamePartPattern = /^[+a-z0-9A-Z_-]{0,63}$/, hostnamePartStart = /^([+a-z0-9A-Z_-]{0,63})(.*)$/, unsafeProtocol = {
  javascript: !0,
  "javascript:": !0
}, hostlessProtocol = {
  javascript: !0,
  "javascript:": !0
}, slashedProtocol = {
  http: !0,
  https: !0,
  ftp: !0,
  gopher: !0,
  file: !0,
  "http:": !0,
  "https:": !0,
  "ftp:": !0,
  "gopher:": !0,
  "file:": !0
}, querystring = querystring$1;
function urlParse(n, t, e) {
  if (n && util$7.isObject(n) && n instanceof Url)
    return n;
  var o = new Url();
  return o.parse(n, t, e), o;
}
Url.prototype.parse = function(n, t, e) {
  if (!util$7.isString(n))
    throw new TypeError("Parameter 'url' must be a string, not " + typeof n);
  var o = n.indexOf("?"), R = o !== -1 && o < n.indexOf("#") ? "?" : "#", N = n.split(R), M = /\\/g;
  N[0] = N[0].replace(M, "/"), n = N.join(R);
  var D = n;
  if (D = D.trim(), !e && n.split("#").length === 1) {
    var L = simplePathPattern.exec(D);
    if (L)
      return this.path = D, this.href = D, this.pathname = L[1], L[2] ? (this.search = L[2], t ? this.query = querystring.parse(this.search.substr(1)) : this.query = this.search.substr(1)) : t && (this.search = "", this.query = {}), this;
  }
  var B = protocolPattern.exec(D);
  if (B) {
    B = B[0];
    var $ = B.toLowerCase();
    this.protocol = $, D = D.substr(B.length);
  }
  if (e || B || D.match(/^\/\/[^@\/]+@[^@\/]+/)) {
    var k = D.substr(0, 2) === "//";
    k && !(B && hostlessProtocol[B]) && (D = D.substr(2), this.slashes = !0);
  }
  if (!hostlessProtocol[B] && (k || B && !slashedProtocol[B])) {
    for (var U = -1, z = 0; z < hostEndingChars.length; z++) {
      var X = D.indexOf(hostEndingChars[z]);
      X !== -1 && (U === -1 || X < U) && (U = X);
    }
    var V, W;
    U === -1 ? W = D.lastIndexOf("@") : W = D.lastIndexOf("@", U), W !== -1 && (V = D.slice(0, W), D = D.slice(W + 1), this.auth = decodeURIComponent(V)), U = -1;
    for (var z = 0; z < nonHostChars.length; z++) {
      var X = D.indexOf(nonHostChars[z]);
      X !== -1 && (U === -1 || X < U) && (U = X);
    }
    U === -1 && (U = D.length), this.host = D.slice(0, U), D = D.slice(U), this.parseHost(), this.hostname = this.hostname || "";
    var Y = this.hostname[0] === "[" && this.hostname[this.hostname.length - 1] === "]";
    if (!Y)
      for (var q = this.hostname.split(/\./), z = 0, Z = q.length; z < Z; z++) {
        var J = q[z];
        if (!!J && !J.match(hostnamePartPattern)) {
          for (var Q = "", K = 0, rt = J.length; K < rt; K++)
            J.charCodeAt(K) > 127 ? Q += "x" : Q += J[K];
          if (!Q.match(hostnamePartPattern)) {
            var tt = q.slice(0, z), nt = q.slice(z + 1), at = J.match(hostnamePartStart);
            at && (tt.push(at[1]), nt.unshift(at[2])), nt.length && (D = "/" + nt.join(".") + D), this.hostname = tt.join(".");
            break;
          }
        }
      }
    this.hostname.length > hostnameMaxLen ? this.hostname = "" : this.hostname = this.hostname.toLowerCase(), Y || (this.hostname = punycode.toASCII(this.hostname));
    var lt = this.port ? ":" + this.port : "", ut = this.hostname || "";
    this.host = ut + lt, this.href += this.host, Y && (this.hostname = this.hostname.substr(1, this.hostname.length - 2), D[0] !== "/" && (D = "/" + D));
  }
  if (!unsafeProtocol[$])
    for (var z = 0, Z = autoEscape.length; z < Z; z++) {
      var dt = autoEscape[z];
      if (D.indexOf(dt) !== -1) {
        var yt = encodeURIComponent(dt);
        yt === dt && (yt = escape(dt)), D = D.split(dt).join(yt);
      }
    }
  var pt = D.indexOf("#");
  pt !== -1 && (this.hash = D.substr(pt), D = D.slice(0, pt));
  var gt = D.indexOf("?");
  if (gt !== -1 ? (this.search = D.substr(gt), this.query = D.substr(gt + 1), t && (this.query = querystring.parse(this.query)), D = D.slice(0, gt)) : t && (this.search = "", this.query = {}), D && (this.pathname = D), slashedProtocol[$] && this.hostname && !this.pathname && (this.pathname = "/"), this.pathname || this.search) {
    var lt = this.pathname || "", xt = this.search || "";
    this.path = lt + xt;
  }
  return this.href = this.format(), this;
};
function urlFormat(n) {
  return util$7.isString(n) && (n = urlParse(n)), n instanceof Url ? n.format() : Url.prototype.format.call(n);
}
Url.prototype.format = function() {
  var n = this.auth || "";
  n && (n = encodeURIComponent(n), n = n.replace(/%3A/i, ":"), n += "@");
  var t = this.protocol || "", e = this.pathname || "", o = this.hash || "", R = !1, N = "";
  this.host ? R = n + this.host : this.hostname && (R = n + (this.hostname.indexOf(":") === -1 ? this.hostname : "[" + this.hostname + "]"), this.port && (R += ":" + this.port)), this.query && util$7.isObject(this.query) && Object.keys(this.query).length && (N = querystring.stringify(this.query));
  var M = this.search || N && "?" + N || "";
  return t && t.substr(-1) !== ":" && (t += ":"), this.slashes || (!t || slashedProtocol[t]) && R !== !1 ? (R = "//" + (R || ""), e && e.charAt(0) !== "/" && (e = "/" + e)) : R || (R = ""), o && o.charAt(0) !== "#" && (o = "#" + o), M && M.charAt(0) !== "?" && (M = "?" + M), e = e.replace(/[?#]/g, function(D) {
    return encodeURIComponent(D);
  }), M = M.replace("#", "%23"), t + R + e + M + o;
};
function urlResolve(n, t) {
  return urlParse(n, !1, !0).resolve(t);
}
Url.prototype.resolve = function(n) {
  return this.resolveObject(urlParse(n, !1, !0)).format();
};
Url.prototype.resolveObject = function(n) {
  if (util$7.isString(n)) {
    var t = new Url();
    t.parse(n, !1, !0), n = t;
  }
  for (var e = new Url(), o = Object.keys(this), R = 0; R < o.length; R++) {
    var N = o[R];
    e[N] = this[N];
  }
  if (e.hash = n.hash, n.href === "")
    return e.href = e.format(), e;
  if (n.slashes && !n.protocol) {
    for (var M = Object.keys(n), D = 0; D < M.length; D++) {
      var L = M[D];
      L !== "protocol" && (e[L] = n[L]);
    }
    return slashedProtocol[e.protocol] && e.hostname && !e.pathname && (e.path = e.pathname = "/"), e.href = e.format(), e;
  }
  if (n.protocol && n.protocol !== e.protocol) {
    if (!slashedProtocol[n.protocol]) {
      for (var B = Object.keys(n), $ = 0; $ < B.length; $++) {
        var k = B[$];
        e[k] = n[k];
      }
      return e.href = e.format(), e;
    }
    if (e.protocol = n.protocol, !n.host && !hostlessProtocol[n.protocol]) {
      for (var Z = (n.pathname || "").split("/"); Z.length && !(n.host = Z.shift()); )
        ;
      n.host || (n.host = ""), n.hostname || (n.hostname = ""), Z[0] !== "" && Z.unshift(""), Z.length < 2 && Z.unshift(""), e.pathname = Z.join("/");
    } else
      e.pathname = n.pathname;
    if (e.search = n.search, e.query = n.query, e.host = n.host || "", e.auth = n.auth, e.hostname = n.hostname || n.host, e.port = n.port, e.pathname || e.search) {
      var U = e.pathname || "", z = e.search || "";
      e.path = U + z;
    }
    return e.slashes = e.slashes || n.slashes, e.href = e.format(), e;
  }
  var X = e.pathname && e.pathname.charAt(0) === "/", V = n.host || n.pathname && n.pathname.charAt(0) === "/", W = V || X || e.host && n.pathname, Y = W, q = e.pathname && e.pathname.split("/") || [], Z = n.pathname && n.pathname.split("/") || [], J = e.protocol && !slashedProtocol[e.protocol];
  if (J && (e.hostname = "", e.port = null, e.host && (q[0] === "" ? q[0] = e.host : q.unshift(e.host)), e.host = "", n.protocol && (n.hostname = null, n.port = null, n.host && (Z[0] === "" ? Z[0] = n.host : Z.unshift(n.host)), n.host = null), W = W && (Z[0] === "" || q[0] === "")), V)
    e.host = n.host || n.host === "" ? n.host : e.host, e.hostname = n.hostname || n.hostname === "" ? n.hostname : e.hostname, e.search = n.search, e.query = n.query, q = Z;
  else if (Z.length)
    q || (q = []), q.pop(), q = q.concat(Z), e.search = n.search, e.query = n.query;
  else if (!util$7.isNullOrUndefined(n.search)) {
    if (J) {
      e.hostname = e.host = q.shift();
      var Q = e.host && e.host.indexOf("@") > 0 ? e.host.split("@") : !1;
      Q && (e.auth = Q.shift(), e.host = e.hostname = Q.shift());
    }
    return e.search = n.search, e.query = n.query, (!util$7.isNull(e.pathname) || !util$7.isNull(e.search)) && (e.path = (e.pathname ? e.pathname : "") + (e.search ? e.search : "")), e.href = e.format(), e;
  }
  if (!q.length)
    return e.pathname = null, e.search ? e.path = "/" + e.search : e.path = null, e.href = e.format(), e;
  for (var K = q.slice(-1)[0], rt = (e.host || n.host || q.length > 1) && (K === "." || K === "..") || K === "", tt = 0, nt = q.length; nt >= 0; nt--)
    K = q[nt], K === "." ? q.splice(nt, 1) : K === ".." ? (q.splice(nt, 1), tt++) : tt && (q.splice(nt, 1), tt--);
  if (!W && !Y)
    for (; tt--; tt)
      q.unshift("..");
  W && q[0] !== "" && (!q[0] || q[0].charAt(0) !== "/") && q.unshift(""), rt && q.join("/").substr(-1) !== "/" && q.push("");
  var at = q[0] === "" || q[0] && q[0].charAt(0) === "/";
  if (J) {
    e.hostname = e.host = at ? "" : q.length ? q.shift() : "";
    var Q = e.host && e.host.indexOf("@") > 0 ? e.host.split("@") : !1;
    Q && (e.auth = Q.shift(), e.host = e.hostname = Q.shift());
  }
  return W = W || e.host && q.length, W && !at && q.unshift(""), q.length ? e.pathname = q.join("/") : (e.pathname = null, e.path = null), (!util$7.isNull(e.pathname) || !util$7.isNull(e.search)) && (e.path = (e.pathname ? e.pathname : "") + (e.search ? e.search : "")), e.auth = n.auth || e.auth, e.slashes = e.slashes || n.slashes, e.href = e.format(), e;
};
Url.prototype.parseHost = function() {
  var n = this.host, t = portPattern.exec(n);
  t && (t = t[0], t !== ":" && (this.port = t.substr(1)), n = n.substr(0, n.length - t.length)), n && (this.hostname = n);
};
/*!
 * @pixi/utils - v6.5.2
 * Compiled Wed, 24 Aug 2022 13:51:19 UTC
 *
 * @pixi/utils is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
var url = {
  parse: parse$1,
  format: format$1,
  resolve: resolve$1
};
settings$1.RETINA_PREFIX = /@([0-9\.]+)x/;
settings$1.FAIL_IF_MAJOR_PERFORMANCE_CAVEAT = !1;
var saidHello = !1, VERSION = "6.5.2";
function skipHello() {
  saidHello = !0;
}
function sayHello(n) {
  var t;
  if (!saidHello) {
    if (settings$1.ADAPTER.getNavigator().userAgent.toLowerCase().indexOf("chrome") > -1) {
      var e = [
        `
 %c %c %c PixiJS ` + VERSION + " - \u2730 " + n + ` \u2730  %c  %c  http://www.pixijs.com/  %c %c \u2665%c\u2665%c\u2665 

`,
        "background: #ff66a5; padding:5px 0;",
        "background: #ff66a5; padding:5px 0;",
        "color: #ff66a5; background: #030307; padding:5px 0;",
        "background: #ff66a5; padding:5px 0;",
        "background: #ffc3dc; padding:5px 0;",
        "background: #ff66a5; padding:5px 0;",
        "color: #ff2424; background: #fff; padding:5px 0;",
        "color: #ff2424; background: #fff; padding:5px 0;",
        "color: #ff2424; background: #fff; padding:5px 0;"
      ];
      (t = globalThis.console).log.apply(t, e);
    } else
      globalThis.console && globalThis.console.log("PixiJS " + VERSION + " - " + n + " - http://www.pixijs.com/");
    saidHello = !0;
  }
}
var supported;
function isWebGLSupported() {
  return typeof supported > "u" && (supported = function() {
    var t = {
      stencil: !0,
      failIfMajorPerformanceCaveat: settings$1.FAIL_IF_MAJOR_PERFORMANCE_CAVEAT
    };
    try {
      if (!settings$1.ADAPTER.getWebGLRenderingContext())
        return !1;
      var e = settings$1.ADAPTER.createCanvas(), o = e.getContext("webgl", t) || e.getContext("experimental-webgl", t), R = !!(o && o.getContextAttributes().stencil);
      if (o) {
        var N = o.getExtension("WEBGL_lose_context");
        N && N.loseContext();
      }
      return o = null, R;
    } catch {
      return !1;
    }
  }()), supported;
}
var aliceblue = "#f0f8ff", antiquewhite = "#faebd7", aqua = "#00ffff", aquamarine = "#7fffd4", azure = "#f0ffff", beige = "#f5f5dc", bisque = "#ffe4c4", black = "#000000", blanchedalmond = "#ffebcd", blue = "#0000ff", blueviolet = "#8a2be2", brown = "#a52a2a", burlywood = "#deb887", cadetblue = "#5f9ea0", chartreuse = "#7fff00", chocolate = "#d2691e", coral = "#ff7f50", cornflowerblue = "#6495ed", cornsilk = "#fff8dc", crimson = "#dc143c", cyan = "#00ffff", darkblue = "#00008b", darkcyan = "#008b8b", darkgoldenrod = "#b8860b", darkgray = "#a9a9a9", darkgreen = "#006400", darkgrey = "#a9a9a9", darkkhaki = "#bdb76b", darkmagenta = "#8b008b", darkolivegreen = "#556b2f", darkorange = "#ff8c00", darkorchid = "#9932cc", darkred = "#8b0000", darksalmon = "#e9967a", darkseagreen = "#8fbc8f", darkslateblue = "#483d8b", darkslategray = "#2f4f4f", darkslategrey = "#2f4f4f", darkturquoise = "#00ced1", darkviolet = "#9400d3", deeppink = "#ff1493", deepskyblue = "#00bfff", dimgray = "#696969", dimgrey = "#696969", dodgerblue = "#1e90ff", firebrick = "#b22222", floralwhite = "#fffaf0", forestgreen = "#228b22", fuchsia = "#ff00ff", gainsboro = "#dcdcdc", ghostwhite = "#f8f8ff", goldenrod = "#daa520", gold = "#ffd700", gray = "#808080", green = "#008000", greenyellow = "#adff2f", grey = "#808080", honeydew = "#f0fff0", hotpink = "#ff69b4", indianred = "#cd5c5c", indigo = "#4b0082", ivory = "#fffff0", khaki = "#f0e68c", lavenderblush = "#fff0f5", lavender = "#e6e6fa", lawngreen = "#7cfc00", lemonchiffon = "#fffacd", lightblue = "#add8e6", lightcoral = "#f08080", lightcyan = "#e0ffff", lightgoldenrodyellow = "#fafad2", lightgray = "#d3d3d3", lightgreen = "#90ee90", lightgrey = "#d3d3d3", lightpink = "#ffb6c1", lightsalmon = "#ffa07a", lightseagreen = "#20b2aa", lightskyblue = "#87cefa", lightslategray = "#778899", lightslategrey = "#778899", lightsteelblue = "#b0c4de", lightyellow = "#ffffe0", lime = "#00ff00", limegreen = "#32cd32", linen = "#faf0e6", magenta = "#ff00ff", maroon = "#800000", mediumaquamarine = "#66cdaa", mediumblue = "#0000cd", mediumorchid = "#ba55d3", mediumpurple = "#9370db", mediumseagreen = "#3cb371", mediumslateblue = "#7b68ee", mediumspringgreen = "#00fa9a", mediumturquoise = "#48d1cc", mediumvioletred = "#c71585", midnightblue = "#191970", mintcream = "#f5fffa", mistyrose = "#ffe4e1", moccasin = "#ffe4b5", navajowhite = "#ffdead", navy = "#000080", oldlace = "#fdf5e6", olive = "#808000", olivedrab = "#6b8e23", orange = "#ffa500", orangered = "#ff4500", orchid = "#da70d6", palegoldenrod = "#eee8aa", palegreen = "#98fb98", paleturquoise = "#afeeee", palevioletred = "#db7093", papayawhip = "#ffefd5", peachpuff = "#ffdab9", peru = "#cd853f", pink = "#ffc0cb", plum = "#dda0dd", powderblue = "#b0e0e6", purple = "#800080", rebeccapurple = "#663399", red = "#ff0000", rosybrown = "#bc8f8f", royalblue = "#4169e1", saddlebrown = "#8b4513", salmon = "#fa8072", sandybrown = "#f4a460", seagreen = "#2e8b57", seashell = "#fff5ee", sienna = "#a0522d", silver = "#c0c0c0", skyblue = "#87ceeb", slateblue = "#6a5acd", slategray = "#708090", slategrey = "#708090", snow = "#fffafa", springgreen = "#00ff7f", steelblue = "#4682b4", tan = "#d2b48c", teal = "#008080", thistle = "#d8bfd8", tomato = "#ff6347", turquoise = "#40e0d0", violet = "#ee82ee", wheat = "#f5deb3", white = "#ffffff", whitesmoke = "#f5f5f5", yellow = "#ffff00", yellowgreen = "#9acd32", cssColorNames = {
  aliceblue,
  antiquewhite,
  aqua,
  aquamarine,
  azure,
  beige,
  bisque,
  black,
  blanchedalmond,
  blue,
  blueviolet,
  brown,
  burlywood,
  cadetblue,
  chartreuse,
  chocolate,
  coral,
  cornflowerblue,
  cornsilk,
  crimson,
  cyan,
  darkblue,
  darkcyan,
  darkgoldenrod,
  darkgray,
  darkgreen,
  darkgrey,
  darkkhaki,
  darkmagenta,
  darkolivegreen,
  darkorange,
  darkorchid,
  darkred,
  darksalmon,
  darkseagreen,
  darkslateblue,
  darkslategray,
  darkslategrey,
  darkturquoise,
  darkviolet,
  deeppink,
  deepskyblue,
  dimgray,
  dimgrey,
  dodgerblue,
  firebrick,
  floralwhite,
  forestgreen,
  fuchsia,
  gainsboro,
  ghostwhite,
  goldenrod,
  gold,
  gray,
  green,
  greenyellow,
  grey,
  honeydew,
  hotpink,
  indianred,
  indigo,
  ivory,
  khaki,
  lavenderblush,
  lavender,
  lawngreen,
  lemonchiffon,
  lightblue,
  lightcoral,
  lightcyan,
  lightgoldenrodyellow,
  lightgray,
  lightgreen,
  lightgrey,
  lightpink,
  lightsalmon,
  lightseagreen,
  lightskyblue,
  lightslategray,
  lightslategrey,
  lightsteelblue,
  lightyellow,
  lime,
  limegreen,
  linen,
  magenta,
  maroon,
  mediumaquamarine,
  mediumblue,
  mediumorchid,
  mediumpurple,
  mediumseagreen,
  mediumslateblue,
  mediumspringgreen,
  mediumturquoise,
  mediumvioletred,
  midnightblue,
  mintcream,
  mistyrose,
  moccasin,
  navajowhite,
  navy,
  oldlace,
  olive,
  olivedrab,
  orange,
  orangered,
  orchid,
  palegoldenrod,
  palegreen,
  paleturquoise,
  palevioletred,
  papayawhip,
  peachpuff,
  peru,
  pink,
  plum,
  powderblue,
  purple,
  rebeccapurple,
  red,
  rosybrown,
  royalblue,
  saddlebrown,
  salmon,
  sandybrown,
  seagreen,
  seashell,
  sienna,
  silver,
  skyblue,
  slateblue,
  slategray,
  slategrey,
  snow,
  springgreen,
  steelblue,
  tan,
  teal,
  thistle,
  tomato,
  turquoise,
  violet,
  wheat,
  white,
  whitesmoke,
  yellow,
  yellowgreen
};
function hex2rgb(n, t) {
  return t === void 0 && (t = []), t[0] = (n >> 16 & 255) / 255, t[1] = (n >> 8 & 255) / 255, t[2] = (n & 255) / 255, t;
}
function hex2string(n) {
  var t = n.toString(16);
  return t = "000000".substring(0, 6 - t.length) + t, "#" + t;
}
function string2hex(n) {
  return typeof n == "string" && (n = cssColorNames[n.toLowerCase()] || n, n[0] === "#" && (n = n.slice(1))), parseInt(n, 16);
}
function mapPremultipliedBlendModes$1() {
  for (var n = [], t = [], e = 0; e < 32; e++)
    n[e] = e, t[e] = e;
  n[BLEND_MODES$5.NORMAL_NPM] = BLEND_MODES$5.NORMAL, n[BLEND_MODES$5.ADD_NPM] = BLEND_MODES$5.ADD, n[BLEND_MODES$5.SCREEN_NPM] = BLEND_MODES$5.SCREEN, t[BLEND_MODES$5.NORMAL] = BLEND_MODES$5.NORMAL_NPM, t[BLEND_MODES$5.ADD] = BLEND_MODES$5.ADD_NPM, t[BLEND_MODES$5.SCREEN] = BLEND_MODES$5.SCREEN_NPM;
  var o = [];
  return o.push(t), o.push(n), o;
}
var premultiplyBlendMode = mapPremultipliedBlendModes$1();
function correctBlendMode(n, t) {
  return premultiplyBlendMode[t ? 1 : 0][n];
}
function premultiplyRgba(n, t, e, o) {
  return e = e || new Float32Array(4), o || o === void 0 ? (e[0] = n[0] * t, e[1] = n[1] * t, e[2] = n[2] * t) : (e[0] = n[0], e[1] = n[1], e[2] = n[2]), e[3] = t, e;
}
function premultiplyTint(n, t) {
  if (t === 1)
    return (t * 255 << 24) + n;
  if (t === 0)
    return 0;
  var e = n >> 16 & 255, o = n >> 8 & 255, R = n & 255;
  return e = e * t + 0.5 | 0, o = o * t + 0.5 | 0, R = R * t + 0.5 | 0, (t * 255 << 24) + (e << 16) + (o << 8) + R;
}
function premultiplyTintToRgba(n, t, e, o) {
  return e = e || new Float32Array(4), e[0] = (n >> 16 & 255) / 255, e[1] = (n >> 8 & 255) / 255, e[2] = (n & 255) / 255, (o || o === void 0) && (e[0] *= t, e[1] *= t, e[2] *= t), e[3] = t, e;
}
function createIndicesForQuads(n, t) {
  t === void 0 && (t = null);
  var e = n * 6;
  if (t = t || new Uint16Array(e), t.length !== e)
    throw new Error("Out buffer length is incorrect, got " + t.length + " and expected " + e);
  for (var o = 0, R = 0; o < e; o += 6, R += 4)
    t[o + 0] = R + 0, t[o + 1] = R + 1, t[o + 2] = R + 2, t[o + 3] = R + 0, t[o + 4] = R + 2, t[o + 5] = R + 3;
  return t;
}
function getBufferType(n) {
  if (n.BYTES_PER_ELEMENT === 4)
    return n instanceof Float32Array ? "Float32Array" : n instanceof Uint32Array ? "Uint32Array" : "Int32Array";
  if (n.BYTES_PER_ELEMENT === 2) {
    if (n instanceof Uint16Array)
      return "Uint16Array";
  } else if (n.BYTES_PER_ELEMENT === 1 && n instanceof Uint8Array)
    return "Uint8Array";
  return null;
}
function nextPow2(n) {
  return n += n === 0 ? 1 : 0, --n, n |= n >>> 1, n |= n >>> 2, n |= n >>> 4, n |= n >>> 8, n |= n >>> 16, n + 1;
}
function isPow2(n) {
  return !(n & n - 1) && !!n;
}
function log2(n) {
  var t = (n > 65535 ? 1 : 0) << 4;
  n >>>= t;
  var e = (n > 255 ? 1 : 0) << 3;
  return n >>>= e, t |= e, e = (n > 15 ? 1 : 0) << 2, n >>>= e, t |= e, e = (n > 3 ? 1 : 0) << 1, n >>>= e, t |= e, t | n >> 1;
}
function removeItems(n, t, e) {
  var o = n.length, R;
  if (!(t >= o || e === 0)) {
    e = t + e > o ? o - t : e;
    var N = o - e;
    for (R = t; R < N; ++R)
      n[R] = n[R + e];
    n.length = N;
  }
}
function sign(n) {
  return n === 0 ? 0 : n < 0 ? -1 : 1;
}
var nextUid = 0;
function uid() {
  return ++nextUid;
}
var warnings$1 = {};
function deprecation$1(n, t, e) {
  if (e === void 0 && (e = 3), !warnings$1[t]) {
    var o = new Error().stack;
    typeof o > "u" ? console.warn("PixiJS Deprecation Warning: ", t + `
Deprecated since v` + n) : (o = o.split(`
`).splice(e).join(`
`), console.groupCollapsed ? (console.groupCollapsed("%cPixiJS Deprecation Warning: %c%s", "color:#614108;background:#fffbe6", "font-weight:normal;color:#614108;background:#fffbe6", t + `
Deprecated since v` + n), console.warn(o), console.groupEnd()) : (console.warn("PixiJS Deprecation Warning: ", t + `
Deprecated since v` + n), console.warn(o))), warnings$1[t] = !0;
  }
}
var ProgramCache = {}, TextureCache = /* @__PURE__ */ Object.create(null), BaseTextureCache = /* @__PURE__ */ Object.create(null);
function clearTextureCache() {
  var n;
  for (n in TextureCache)
    delete TextureCache[n];
  for (n in BaseTextureCache)
    delete BaseTextureCache[n];
}
var CanvasRenderTarget = function() {
  function n(t, e, o) {
    this.canvas = settings$1.ADAPTER.createCanvas(), this.context = this.canvas.getContext("2d"), this.resolution = o || settings$1.RESOLUTION, this.resize(t, e);
  }
  return n.prototype.clear = function() {
    this.context.setTransform(1, 0, 0, 1, 0, 0), this.context.clearRect(0, 0, this.canvas.width, this.canvas.height);
  }, n.prototype.resize = function(t, e) {
    this.canvas.width = Math.round(t * this.resolution), this.canvas.height = Math.round(e * this.resolution);
  }, n.prototype.destroy = function() {
    this.context = null, this.canvas = null;
  }, Object.defineProperty(n.prototype, "width", {
    get: function() {
      return this.canvas.width;
    },
    set: function(t) {
      this.canvas.width = Math.round(t);
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(n.prototype, "height", {
    get: function() {
      return this.canvas.height;
    },
    set: function(t) {
      this.canvas.height = Math.round(t);
    },
    enumerable: !1,
    configurable: !0
  }), n;
}();
function trimCanvas(n) {
  var t = n.width, e = n.height, o = n.getContext("2d"), R = o.getImageData(0, 0, t, e), N = R.data, M = N.length, D = {
    top: null,
    left: null,
    right: null,
    bottom: null
  }, L = null, B, $, k;
  for (B = 0; B < M; B += 4)
    N[B + 3] !== 0 && ($ = B / 4 % t, k = ~~(B / 4 / t), D.top === null && (D.top = k), (D.left === null || $ < D.left) && (D.left = $), (D.right === null || D.right < $) && (D.right = $ + 1), (D.bottom === null || D.bottom < k) && (D.bottom = k));
  return D.top !== null && (t = D.right - D.left, e = D.bottom - D.top + 1, L = o.getImageData(D.left, D.top, t, e)), {
    height: e,
    width: t,
    data: L
  };
}
var tempAnchor$1;
function determineCrossOrigin(n, t) {
  if (t === void 0 && (t = globalThis.location), n.indexOf("data:") === 0)
    return "";
  t = t || globalThis.location, tempAnchor$1 || (tempAnchor$1 = document.createElement("a")), tempAnchor$1.href = n;
  var e = url.parse(tempAnchor$1.href), o = !e.port && t.port === "" || e.port === t.port;
  return e.hostname !== t.hostname || !o || e.protocol !== t.protocol ? "anonymous" : "";
}
function getResolutionOfUrl(n, t) {
  var e = settings$1.RETINA_PREFIX.exec(n);
  return e ? parseFloat(e[1]) : t !== void 0 ? t : 1;
}
/*!
 * @pixi/extensions - v6.5.2
 * Compiled Wed, 24 Aug 2022 13:51:19 UTC
 *
 * @pixi/extensions is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var __assign$9 = function() {
  return __assign$9 = Object.assign || function(t) {
    for (var e = arguments, o, R = 1, N = arguments.length; R < N; R++) {
      o = e[R];
      for (var M in o)
        Object.prototype.hasOwnProperty.call(o, M) && (t[M] = o[M]);
    }
    return t;
  }, __assign$9.apply(this, arguments);
}, ExtensionType;
(function(n) {
  n.Application = "application", n.RendererPlugin = "renderer-webgl-plugin", n.CanvasRendererPlugin = "renderer-canvas-plugin", n.Loader = "loader", n.LoadParser = "load-parser", n.ResolveParser = "resolve-parser", n.CacheParser = "cache-parser", n.DetectionParser = "detection-parser";
})(ExtensionType || (ExtensionType = {}));
var normalizeExtension = function(n) {
  if (typeof n == "function" || typeof n == "object" && n.extension) {
    if (!n.extension)
      throw new Error("Extension class must have an extension object");
    var t = typeof n.extension != "object" ? { type: n.extension } : n.extension;
    n = __assign$9(__assign$9({}, t), { ref: n });
  }
  if (typeof n == "object")
    n = __assign$9({}, n);
  else
    throw new Error("Invalid extension type");
  return typeof n.type == "string" && (n.type = [n.type]), n;
}, extensions = {
  _addHandlers: null,
  _removeHandlers: null,
  _queue: {},
  remove: function() {
    for (var n = arguments, t = this, e = [], o = 0; o < arguments.length; o++)
      e[o] = n[o];
    return e.map(normalizeExtension).forEach(function(R) {
      R.type.forEach(function(N) {
        var M, D;
        return (D = (M = t._removeHandlers)[N]) === null || D === void 0 ? void 0 : D.call(M, R);
      });
    }), this;
  },
  add: function() {
    for (var n = arguments, t = this, e = [], o = 0; o < arguments.length; o++)
      e[o] = n[o];
    return e.map(normalizeExtension).forEach(function(R) {
      R.type.forEach(function(N) {
        var M = t._addHandlers, D = t._queue;
        M[N] ? M[N](R) : (D[N] = D[N] || [], D[N].push(R));
      });
    }), this;
  },
  handle: function(n, t, e) {
    var o = this._addHandlers = this._addHandlers || {}, R = this._removeHandlers = this._removeHandlers || {};
    if (o[n] || R[n])
      throw new Error("Extension type " + n + " already has a handler");
    o[n] = t, R[n] = e;
    var N = this._queue;
    return N[n] && (N[n].forEach(function(M) {
      return t(M);
    }), delete N[n]), this;
  },
  handleByMap: function(n, t) {
    return this.handle(n, function(e) {
      t[e.name] = e.ref;
    }, function(e) {
      delete t[e.name];
    });
  },
  handleByList: function(n, t) {
    return this.handle(n, function(e) {
      var o, R;
      t.push(e.ref), n === ExtensionType.Loader && ((R = (o = e.ref).add) === null || R === void 0 || R.call(o));
    }, function(e) {
      var o = t.indexOf(e.ref);
      o !== -1 && t.splice(o, 1);
    });
  }
};
/*!
 * @pixi/runner - v6.5.2
 * Compiled Wed, 24 Aug 2022 13:51:19 UTC
 *
 * @pixi/runner is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
var Runner = function() {
  function n(t) {
    this.items = [], this._name = t, this._aliasCount = 0;
  }
  return n.prototype.emit = function(t, e, o, R, N, M, D, L) {
    if (arguments.length > 8)
      throw new Error("max arguments reached");
    var B = this, $ = B.name, k = B.items;
    this._aliasCount++;
    for (var U = 0, z = k.length; U < z; U++)
      k[U][$](t, e, o, R, N, M, D, L);
    return k === this.items && this._aliasCount--, this;
  }, n.prototype.ensureNonAliasedItems = function() {
    this._aliasCount > 0 && this.items.length > 1 && (this._aliasCount = 0, this.items = this.items.slice(0));
  }, n.prototype.add = function(t) {
    return t[this._name] && (this.ensureNonAliasedItems(), this.remove(t), this.items.push(t)), this;
  }, n.prototype.remove = function(t) {
    var e = this.items.indexOf(t);
    return e !== -1 && (this.ensureNonAliasedItems(), this.items.splice(e, 1)), this;
  }, n.prototype.contains = function(t) {
    return this.items.indexOf(t) !== -1;
  }, n.prototype.removeAll = function() {
    return this.ensureNonAliasedItems(), this.items.length = 0, this;
  }, n.prototype.destroy = function() {
    this.removeAll(), this.items = null, this._name = null;
  }, Object.defineProperty(n.prototype, "empty", {
    get: function() {
      return this.items.length === 0;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(n.prototype, "name", {
    get: function() {
      return this._name;
    },
    enumerable: !1,
    configurable: !0
  }), n;
}();
Object.defineProperties(Runner.prototype, {
  dispatch: { value: Runner.prototype.emit },
  run: { value: Runner.prototype.emit }
});
/*!
 * @pixi/ticker - v6.5.2
 * Compiled Wed, 24 Aug 2022 13:51:19 UTC
 *
 * @pixi/ticker is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
settings$1.TARGET_FPMS = 0.06;
var UPDATE_PRIORITY;
(function(n) {
  n[n.INTERACTION = 50] = "INTERACTION", n[n.HIGH = 25] = "HIGH", n[n.NORMAL = 0] = "NORMAL", n[n.LOW = -25] = "LOW", n[n.UTILITY = -50] = "UTILITY";
})(UPDATE_PRIORITY || (UPDATE_PRIORITY = {}));
var TickerListener = function() {
  function n(t, e, o, R) {
    e === void 0 && (e = null), o === void 0 && (o = 0), R === void 0 && (R = !1), this.next = null, this.previous = null, this._destroyed = !1, this.fn = t, this.context = e, this.priority = o, this.once = R;
  }
  return n.prototype.match = function(t, e) {
    return e === void 0 && (e = null), this.fn === t && this.context === e;
  }, n.prototype.emit = function(t) {
    this.fn && (this.context ? this.fn.call(this.context, t) : this.fn(t));
    var e = this.next;
    return this.once && this.destroy(!0), this._destroyed && (this.next = null), e;
  }, n.prototype.connect = function(t) {
    this.previous = t, t.next && (t.next.previous = this), this.next = t.next, t.next = this;
  }, n.prototype.destroy = function(t) {
    t === void 0 && (t = !1), this._destroyed = !0, this.fn = null, this.context = null, this.previous && (this.previous.next = this.next), this.next && (this.next.previous = this.previous);
    var e = this.next;
    return this.next = t ? null : e, this.previous = null, e;
  }, n;
}(), Ticker = function() {
  function n() {
    var t = this;
    this.autoStart = !1, this.deltaTime = 1, this.lastTime = -1, this.speed = 1, this.started = !1, this._requestId = null, this._maxElapsedMS = 100, this._minElapsedMS = 0, this._protected = !1, this._lastFrame = -1, this._head = new TickerListener(null, null, 1 / 0), this.deltaMS = 1 / settings$1.TARGET_FPMS, this.elapsedMS = 1 / settings$1.TARGET_FPMS, this._tick = function(e) {
      t._requestId = null, t.started && (t.update(e), t.started && t._requestId === null && t._head.next && (t._requestId = requestAnimationFrame(t._tick)));
    };
  }
  return n.prototype._requestIfNeeded = function() {
    this._requestId === null && this._head.next && (this.lastTime = performance.now(), this._lastFrame = this.lastTime, this._requestId = requestAnimationFrame(this._tick));
  }, n.prototype._cancelIfNeeded = function() {
    this._requestId !== null && (cancelAnimationFrame(this._requestId), this._requestId = null);
  }, n.prototype._startIfPossible = function() {
    this.started ? this._requestIfNeeded() : this.autoStart && this.start();
  }, n.prototype.add = function(t, e, o) {
    return o === void 0 && (o = UPDATE_PRIORITY.NORMAL), this._addListener(new TickerListener(t, e, o));
  }, n.prototype.addOnce = function(t, e, o) {
    return o === void 0 && (o = UPDATE_PRIORITY.NORMAL), this._addListener(new TickerListener(t, e, o, !0));
  }, n.prototype._addListener = function(t) {
    var e = this._head.next, o = this._head;
    if (!e)
      t.connect(o);
    else {
      for (; e; ) {
        if (t.priority > e.priority) {
          t.connect(o);
          break;
        }
        o = e, e = e.next;
      }
      t.previous || t.connect(o);
    }
    return this._startIfPossible(), this;
  }, n.prototype.remove = function(t, e) {
    for (var o = this._head.next; o; )
      o.match(t, e) ? o = o.destroy() : o = o.next;
    return this._head.next || this._cancelIfNeeded(), this;
  }, Object.defineProperty(n.prototype, "count", {
    get: function() {
      if (!this._head)
        return 0;
      for (var t = 0, e = this._head; e = e.next; )
        t++;
      return t;
    },
    enumerable: !1,
    configurable: !0
  }), n.prototype.start = function() {
    this.started || (this.started = !0, this._requestIfNeeded());
  }, n.prototype.stop = function() {
    this.started && (this.started = !1, this._cancelIfNeeded());
  }, n.prototype.destroy = function() {
    if (!this._protected) {
      this.stop();
      for (var t = this._head.next; t; )
        t = t.destroy(!0);
      this._head.destroy(), this._head = null;
    }
  }, n.prototype.update = function(t) {
    t === void 0 && (t = performance.now());
    var e;
    if (t > this.lastTime) {
      if (e = this.elapsedMS = t - this.lastTime, e > this._maxElapsedMS && (e = this._maxElapsedMS), e *= this.speed, this._minElapsedMS) {
        var o = t - this._lastFrame | 0;
        if (o < this._minElapsedMS)
          return;
        this._lastFrame = t - o % this._minElapsedMS;
      }
      this.deltaMS = e, this.deltaTime = this.deltaMS * settings$1.TARGET_FPMS;
      for (var R = this._head, N = R.next; N; )
        N = N.emit(this.deltaTime);
      R.next || this._cancelIfNeeded();
    } else
      this.deltaTime = this.deltaMS = this.elapsedMS = 0;
    this.lastTime = t;
  }, Object.defineProperty(n.prototype, "FPS", {
    get: function() {
      return 1e3 / this.elapsedMS;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(n.prototype, "minFPS", {
    get: function() {
      return 1e3 / this._maxElapsedMS;
    },
    set: function(t) {
      var e = Math.min(this.maxFPS, t), o = Math.min(Math.max(0, e) / 1e3, settings$1.TARGET_FPMS);
      this._maxElapsedMS = 1 / o;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(n.prototype, "maxFPS", {
    get: function() {
      return this._minElapsedMS ? Math.round(1e3 / this._minElapsedMS) : 0;
    },
    set: function(t) {
      if (t === 0)
        this._minElapsedMS = 0;
      else {
        var e = Math.max(this.minFPS, t);
        this._minElapsedMS = 1 / (e / 1e3);
      }
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(n, "shared", {
    get: function() {
      if (!n._shared) {
        var t = n._shared = new n();
        t.autoStart = !0, t._protected = !0;
      }
      return n._shared;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(n, "system", {
    get: function() {
      if (!n._system) {
        var t = n._system = new n();
        t.autoStart = !0, t._protected = !0;
      }
      return n._system;
    },
    enumerable: !1,
    configurable: !0
  }), n;
}(), TickerPlugin = function() {
  function n() {
  }
  return n.init = function(t) {
    var e = this;
    t = Object.assign({
      autoStart: !0,
      sharedTicker: !1
    }, t), Object.defineProperty(this, "ticker", {
      set: function(o) {
        this._ticker && this._ticker.remove(this.render, this), this._ticker = o, o && o.add(this.render, this, UPDATE_PRIORITY.LOW);
      },
      get: function() {
        return this._ticker;
      }
    }), this.stop = function() {
      e._ticker.stop();
    }, this.start = function() {
      e._ticker.start();
    }, this._ticker = null, this.ticker = t.sharedTicker ? Ticker.shared : new Ticker(), t.autoStart && this.start();
  }, n.destroy = function() {
    if (this._ticker) {
      var t = this._ticker;
      this.ticker = null, t.destroy();
    }
  }, n.extension = ExtensionType.Application, n;
}();
/*!
 * @pixi/math - v6.5.2
 * Compiled Wed, 24 Aug 2022 13:51:19 UTC
 *
 * @pixi/math is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
var PI_2 = Math.PI * 2, RAD_TO_DEG = 180 / Math.PI, DEG_TO_RAD = Math.PI / 180, SHAPES;
(function(n) {
  n[n.POLY = 0] = "POLY", n[n.RECT = 1] = "RECT", n[n.CIRC = 2] = "CIRC", n[n.ELIP = 3] = "ELIP", n[n.RREC = 4] = "RREC";
})(SHAPES || (SHAPES = {}));
var Point = function() {
  function n(t, e) {
    t === void 0 && (t = 0), e === void 0 && (e = 0), this.x = 0, this.y = 0, this.x = t, this.y = e;
  }
  return n.prototype.clone = function() {
    return new n(this.x, this.y);
  }, n.prototype.copyFrom = function(t) {
    return this.set(t.x, t.y), this;
  }, n.prototype.copyTo = function(t) {
    return t.set(this.x, this.y), t;
  }, n.prototype.equals = function(t) {
    return t.x === this.x && t.y === this.y;
  }, n.prototype.set = function(t, e) {
    return t === void 0 && (t = 0), e === void 0 && (e = t), this.x = t, this.y = e, this;
  }, n.prototype.toString = function() {
    return "[@pixi/math:Point x=" + this.x + " y=" + this.y + "]";
  }, n;
}(), tempPoints$1 = [new Point(), new Point(), new Point(), new Point()], Rectangle = function() {
  function n(t, e, o, R) {
    t === void 0 && (t = 0), e === void 0 && (e = 0), o === void 0 && (o = 0), R === void 0 && (R = 0), this.x = Number(t), this.y = Number(e), this.width = Number(o), this.height = Number(R), this.type = SHAPES.RECT;
  }
  return Object.defineProperty(n.prototype, "left", {
    get: function() {
      return this.x;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(n.prototype, "right", {
    get: function() {
      return this.x + this.width;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(n.prototype, "top", {
    get: function() {
      return this.y;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(n.prototype, "bottom", {
    get: function() {
      return this.y + this.height;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(n, "EMPTY", {
    get: function() {
      return new n(0, 0, 0, 0);
    },
    enumerable: !1,
    configurable: !0
  }), n.prototype.clone = function() {
    return new n(this.x, this.y, this.width, this.height);
  }, n.prototype.copyFrom = function(t) {
    return this.x = t.x, this.y = t.y, this.width = t.width, this.height = t.height, this;
  }, n.prototype.copyTo = function(t) {
    return t.x = this.x, t.y = this.y, t.width = this.width, t.height = this.height, t;
  }, n.prototype.contains = function(t, e) {
    return this.width <= 0 || this.height <= 0 ? !1 : t >= this.x && t < this.x + this.width && e >= this.y && e < this.y + this.height;
  }, n.prototype.intersects = function(t, e) {
    if (!e) {
      var o = this.x < t.x ? t.x : this.x, R = this.right > t.right ? t.right : this.right;
      if (R <= o)
        return !1;
      var N = this.y < t.y ? t.y : this.y, M = this.bottom > t.bottom ? t.bottom : this.bottom;
      return M > N;
    }
    var D = this.left, L = this.right, B = this.top, $ = this.bottom;
    if (L <= D || $ <= B)
      return !1;
    var k = tempPoints$1[0].set(t.left, t.top), U = tempPoints$1[1].set(t.left, t.bottom), z = tempPoints$1[2].set(t.right, t.top), X = tempPoints$1[3].set(t.right, t.bottom);
    if (z.x <= k.x || U.y <= k.y)
      return !1;
    var V = Math.sign(e.a * e.d - e.b * e.c);
    if (V === 0 || (e.apply(k, k), e.apply(U, U), e.apply(z, z), e.apply(X, X), Math.max(k.x, U.x, z.x, X.x) <= D || Math.min(k.x, U.x, z.x, X.x) >= L || Math.max(k.y, U.y, z.y, X.y) <= B || Math.min(k.y, U.y, z.y, X.y) >= $))
      return !1;
    var W = V * (U.y - k.y), Y = V * (k.x - U.x), q = W * D + Y * B, Z = W * L + Y * B, J = W * D + Y * $, Q = W * L + Y * $;
    if (Math.max(q, Z, J, Q) <= W * k.x + Y * k.y || Math.min(q, Z, J, Q) >= W * X.x + Y * X.y)
      return !1;
    var K = V * (k.y - z.y), rt = V * (z.x - k.x), tt = K * D + rt * B, nt = K * L + rt * B, at = K * D + rt * $, lt = K * L + rt * $;
    return !(Math.max(tt, nt, at, lt) <= K * k.x + rt * k.y || Math.min(tt, nt, at, lt) >= K * X.x + rt * X.y);
  }, n.prototype.pad = function(t, e) {
    return t === void 0 && (t = 0), e === void 0 && (e = t), this.x -= t, this.y -= e, this.width += t * 2, this.height += e * 2, this;
  }, n.prototype.fit = function(t) {
    var e = Math.max(this.x, t.x), o = Math.min(this.x + this.width, t.x + t.width), R = Math.max(this.y, t.y), N = Math.min(this.y + this.height, t.y + t.height);
    return this.x = e, this.width = Math.max(o - e, 0), this.y = R, this.height = Math.max(N - R, 0), this;
  }, n.prototype.ceil = function(t, e) {
    t === void 0 && (t = 1), e === void 0 && (e = 1e-3);
    var o = Math.ceil((this.x + this.width - e) * t) / t, R = Math.ceil((this.y + this.height - e) * t) / t;
    return this.x = Math.floor((this.x + e) * t) / t, this.y = Math.floor((this.y + e) * t) / t, this.width = o - this.x, this.height = R - this.y, this;
  }, n.prototype.enlarge = function(t) {
    var e = Math.min(this.x, t.x), o = Math.max(this.x + this.width, t.x + t.width), R = Math.min(this.y, t.y), N = Math.max(this.y + this.height, t.y + t.height);
    return this.x = e, this.width = o - e, this.y = R, this.height = N - R, this;
  }, n.prototype.toString = function() {
    return "[@pixi/math:Rectangle x=" + this.x + " y=" + this.y + " width=" + this.width + " height=" + this.height + "]";
  }, n;
}(), Circle = function() {
  function n(t, e, o) {
    t === void 0 && (t = 0), e === void 0 && (e = 0), o === void 0 && (o = 0), this.x = t, this.y = e, this.radius = o, this.type = SHAPES.CIRC;
  }
  return n.prototype.clone = function() {
    return new n(this.x, this.y, this.radius);
  }, n.prototype.contains = function(t, e) {
    if (this.radius <= 0)
      return !1;
    var o = this.radius * this.radius, R = this.x - t, N = this.y - e;
    return R *= R, N *= N, R + N <= o;
  }, n.prototype.getBounds = function() {
    return new Rectangle(this.x - this.radius, this.y - this.radius, this.radius * 2, this.radius * 2);
  }, n.prototype.toString = function() {
    return "[@pixi/math:Circle x=" + this.x + " y=" + this.y + " radius=" + this.radius + "]";
  }, n;
}(), Ellipse = function() {
  function n(t, e, o, R) {
    t === void 0 && (t = 0), e === void 0 && (e = 0), o === void 0 && (o = 0), R === void 0 && (R = 0), this.x = t, this.y = e, this.width = o, this.height = R, this.type = SHAPES.ELIP;
  }
  return n.prototype.clone = function() {
    return new n(this.x, this.y, this.width, this.height);
  }, n.prototype.contains = function(t, e) {
    if (this.width <= 0 || this.height <= 0)
      return !1;
    var o = (t - this.x) / this.width, R = (e - this.y) / this.height;
    return o *= o, R *= R, o + R <= 1;
  }, n.prototype.getBounds = function() {
    return new Rectangle(this.x - this.width, this.y - this.height, this.width, this.height);
  }, n.prototype.toString = function() {
    return "[@pixi/math:Ellipse x=" + this.x + " y=" + this.y + " width=" + this.width + " height=" + this.height + "]";
  }, n;
}(), Polygon = function() {
  function n() {
    for (var t = arguments, e = [], o = 0; o < arguments.length; o++)
      e[o] = t[o];
    var R = Array.isArray(e[0]) ? e[0] : e;
    if (typeof R[0] != "number") {
      for (var N = [], M = 0, D = R.length; M < D; M++)
        N.push(R[M].x, R[M].y);
      R = N;
    }
    this.points = R, this.type = SHAPES.POLY, this.closeStroke = !0;
  }
  return n.prototype.clone = function() {
    var t = this.points.slice(), e = new n(t);
    return e.closeStroke = this.closeStroke, e;
  }, n.prototype.contains = function(t, e) {
    for (var o = !1, R = this.points.length / 2, N = 0, M = R - 1; N < R; M = N++) {
      var D = this.points[N * 2], L = this.points[N * 2 + 1], B = this.points[M * 2], $ = this.points[M * 2 + 1], k = L > e != $ > e && t < (B - D) * ((e - L) / ($ - L)) + D;
      k && (o = !o);
    }
    return o;
  }, n.prototype.toString = function() {
    return "[@pixi/math:Polygon" + ("closeStroke=" + this.closeStroke) + ("points=" + this.points.reduce(function(t, e) {
      return t + ", " + e;
    }, "") + "]");
  }, n;
}(), RoundedRectangle = function() {
  function n(t, e, o, R, N) {
    t === void 0 && (t = 0), e === void 0 && (e = 0), o === void 0 && (o = 0), R === void 0 && (R = 0), N === void 0 && (N = 20), this.x = t, this.y = e, this.width = o, this.height = R, this.radius = N, this.type = SHAPES.RREC;
  }
  return n.prototype.clone = function() {
    return new n(this.x, this.y, this.width, this.height, this.radius);
  }, n.prototype.contains = function(t, e) {
    if (this.width <= 0 || this.height <= 0)
      return !1;
    if (t >= this.x && t <= this.x + this.width && e >= this.y && e <= this.y + this.height) {
      var o = Math.max(0, Math.min(this.radius, Math.min(this.width, this.height) / 2));
      if (e >= this.y + o && e <= this.y + this.height - o || t >= this.x + o && t <= this.x + this.width - o)
        return !0;
      var R = t - (this.x + o), N = e - (this.y + o), M = o * o;
      if (R * R + N * N <= M || (R = t - (this.x + this.width - o), R * R + N * N <= M) || (N = e - (this.y + this.height - o), R * R + N * N <= M) || (R = t - (this.x + o), R * R + N * N <= M))
        return !0;
    }
    return !1;
  }, n.prototype.toString = function() {
    return "[@pixi/math:RoundedRectangle x=" + this.x + " y=" + this.y + ("width=" + this.width + " height=" + this.height + " radius=" + this.radius + "]");
  }, n;
}(), ObservablePoint = function() {
  function n(t, e, o, R) {
    o === void 0 && (o = 0), R === void 0 && (R = 0), this._x = o, this._y = R, this.cb = t, this.scope = e;
  }
  return n.prototype.clone = function(t, e) {
    return t === void 0 && (t = this.cb), e === void 0 && (e = this.scope), new n(t, e, this._x, this._y);
  }, n.prototype.set = function(t, e) {
    return t === void 0 && (t = 0), e === void 0 && (e = t), (this._x !== t || this._y !== e) && (this._x = t, this._y = e, this.cb.call(this.scope)), this;
  }, n.prototype.copyFrom = function(t) {
    return (this._x !== t.x || this._y !== t.y) && (this._x = t.x, this._y = t.y, this.cb.call(this.scope)), this;
  }, n.prototype.copyTo = function(t) {
    return t.set(this._x, this._y), t;
  }, n.prototype.equals = function(t) {
    return t.x === this._x && t.y === this._y;
  }, n.prototype.toString = function() {
    return "[@pixi/math:ObservablePoint x=" + 0 + " y=" + 0 + " scope=" + this.scope + "]";
  }, Object.defineProperty(n.prototype, "x", {
    get: function() {
      return this._x;
    },
    set: function(t) {
      this._x !== t && (this._x = t, this.cb.call(this.scope));
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(n.prototype, "y", {
    get: function() {
      return this._y;
    },
    set: function(t) {
      this._y !== t && (this._y = t, this.cb.call(this.scope));
    },
    enumerable: !1,
    configurable: !0
  }), n;
}(), Matrix = function() {
  function n(t, e, o, R, N, M) {
    t === void 0 && (t = 1), e === void 0 && (e = 0), o === void 0 && (o = 0), R === void 0 && (R = 1), N === void 0 && (N = 0), M === void 0 && (M = 0), this.array = null, this.a = t, this.b = e, this.c = o, this.d = R, this.tx = N, this.ty = M;
  }
  return n.prototype.fromArray = function(t) {
    this.a = t[0], this.b = t[1], this.c = t[3], this.d = t[4], this.tx = t[2], this.ty = t[5];
  }, n.prototype.set = function(t, e, o, R, N, M) {
    return this.a = t, this.b = e, this.c = o, this.d = R, this.tx = N, this.ty = M, this;
  }, n.prototype.toArray = function(t, e) {
    this.array || (this.array = new Float32Array(9));
    var o = e || this.array;
    return t ? (o[0] = this.a, o[1] = this.b, o[2] = 0, o[3] = this.c, o[4] = this.d, o[5] = 0, o[6] = this.tx, o[7] = this.ty, o[8] = 1) : (o[0] = this.a, o[1] = this.c, o[2] = this.tx, o[3] = this.b, o[4] = this.d, o[5] = this.ty, o[6] = 0, o[7] = 0, o[8] = 1), o;
  }, n.prototype.apply = function(t, e) {
    e = e || new Point();
    var o = t.x, R = t.y;
    return e.x = this.a * o + this.c * R + this.tx, e.y = this.b * o + this.d * R + this.ty, e;
  }, n.prototype.applyInverse = function(t, e) {
    e = e || new Point();
    var o = 1 / (this.a * this.d + this.c * -this.b), R = t.x, N = t.y;
    return e.x = this.d * o * R + -this.c * o * N + (this.ty * this.c - this.tx * this.d) * o, e.y = this.a * o * N + -this.b * o * R + (-this.ty * this.a + this.tx * this.b) * o, e;
  }, n.prototype.translate = function(t, e) {
    return this.tx += t, this.ty += e, this;
  }, n.prototype.scale = function(t, e) {
    return this.a *= t, this.d *= e, this.c *= t, this.b *= e, this.tx *= t, this.ty *= e, this;
  }, n.prototype.rotate = function(t) {
    var e = Math.cos(t), o = Math.sin(t), R = this.a, N = this.c, M = this.tx;
    return this.a = R * e - this.b * o, this.b = R * o + this.b * e, this.c = N * e - this.d * o, this.d = N * o + this.d * e, this.tx = M * e - this.ty * o, this.ty = M * o + this.ty * e, this;
  }, n.prototype.append = function(t) {
    var e = this.a, o = this.b, R = this.c, N = this.d;
    return this.a = t.a * e + t.b * R, this.b = t.a * o + t.b * N, this.c = t.c * e + t.d * R, this.d = t.c * o + t.d * N, this.tx = t.tx * e + t.ty * R + this.tx, this.ty = t.tx * o + t.ty * N + this.ty, this;
  }, n.prototype.setTransform = function(t, e, o, R, N, M, D, L, B) {
    return this.a = Math.cos(D + B) * N, this.b = Math.sin(D + B) * N, this.c = -Math.sin(D - L) * M, this.d = Math.cos(D - L) * M, this.tx = t - (o * this.a + R * this.c), this.ty = e - (o * this.b + R * this.d), this;
  }, n.prototype.prepend = function(t) {
    var e = this.tx;
    if (t.a !== 1 || t.b !== 0 || t.c !== 0 || t.d !== 1) {
      var o = this.a, R = this.c;
      this.a = o * t.a + this.b * t.c, this.b = o * t.b + this.b * t.d, this.c = R * t.a + this.d * t.c, this.d = R * t.b + this.d * t.d;
    }
    return this.tx = e * t.a + this.ty * t.c + t.tx, this.ty = e * t.b + this.ty * t.d + t.ty, this;
  }, n.prototype.decompose = function(t) {
    var e = this.a, o = this.b, R = this.c, N = this.d, M = t.pivot, D = -Math.atan2(-R, N), L = Math.atan2(o, e), B = Math.abs(D + L);
    return B < 1e-5 || Math.abs(PI_2 - B) < 1e-5 ? (t.rotation = L, t.skew.x = t.skew.y = 0) : (t.rotation = 0, t.skew.x = D, t.skew.y = L), t.scale.x = Math.sqrt(e * e + o * o), t.scale.y = Math.sqrt(R * R + N * N), t.position.x = this.tx + (M.x * e + M.y * R), t.position.y = this.ty + (M.x * o + M.y * N), t;
  }, n.prototype.invert = function() {
    var t = this.a, e = this.b, o = this.c, R = this.d, N = this.tx, M = t * R - e * o;
    return this.a = R / M, this.b = -e / M, this.c = -o / M, this.d = t / M, this.tx = (o * this.ty - R * N) / M, this.ty = -(t * this.ty - e * N) / M, this;
  }, n.prototype.identity = function() {
    return this.a = 1, this.b = 0, this.c = 0, this.d = 1, this.tx = 0, this.ty = 0, this;
  }, n.prototype.clone = function() {
    var t = new n();
    return t.a = this.a, t.b = this.b, t.c = this.c, t.d = this.d, t.tx = this.tx, t.ty = this.ty, t;
  }, n.prototype.copyTo = function(t) {
    return t.a = this.a, t.b = this.b, t.c = this.c, t.d = this.d, t.tx = this.tx, t.ty = this.ty, t;
  }, n.prototype.copyFrom = function(t) {
    return this.a = t.a, this.b = t.b, this.c = t.c, this.d = t.d, this.tx = t.tx, this.ty = t.ty, this;
  }, n.prototype.toString = function() {
    return "[@pixi/math:Matrix a=" + this.a + " b=" + this.b + " c=" + this.c + " d=" + this.d + " tx=" + this.tx + " ty=" + this.ty + "]";
  }, Object.defineProperty(n, "IDENTITY", {
    get: function() {
      return new n();
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(n, "TEMP_MATRIX", {
    get: function() {
      return new n();
    },
    enumerable: !1,
    configurable: !0
  }), n;
}(), ux = [1, 1, 0, -1, -1, -1, 0, 1, 1, 1, 0, -1, -1, -1, 0, 1], uy = [0, 1, 1, 1, 0, -1, -1, -1, 0, 1, 1, 1, 0, -1, -1, -1], vx = [0, -1, -1, -1, 0, 1, 1, 1, 0, 1, 1, 1, 0, -1, -1, -1], vy = [1, 1, 0, -1, -1, -1, 0, 1, -1, -1, 0, 1, 1, 1, 0, -1], rotationCayley = [], rotationMatrices = [], signum = Math.sign;
function init() {
  for (var n = 0; n < 16; n++) {
    var t = [];
    rotationCayley.push(t);
    for (var e = 0; e < 16; e++)
      for (var o = signum(ux[n] * ux[e] + vx[n] * uy[e]), R = signum(uy[n] * ux[e] + vy[n] * uy[e]), N = signum(ux[n] * vx[e] + vx[n] * vy[e]), M = signum(uy[n] * vx[e] + vy[n] * vy[e]), D = 0; D < 16; D++)
        if (ux[D] === o && uy[D] === R && vx[D] === N && vy[D] === M) {
          t.push(D);
          break;
        }
  }
  for (var n = 0; n < 16; n++) {
    var L = new Matrix();
    L.set(ux[n], uy[n], vx[n], vy[n], 0, 0), rotationMatrices.push(L);
  }
}
init();
var groupD8 = {
  E: 0,
  SE: 1,
  S: 2,
  SW: 3,
  W: 4,
  NW: 5,
  N: 6,
  NE: 7,
  MIRROR_VERTICAL: 8,
  MAIN_DIAGONAL: 10,
  MIRROR_HORIZONTAL: 12,
  REVERSE_DIAGONAL: 14,
  uX: function(n) {
    return ux[n];
  },
  uY: function(n) {
    return uy[n];
  },
  vX: function(n) {
    return vx[n];
  },
  vY: function(n) {
    return vy[n];
  },
  inv: function(n) {
    return n & 8 ? n & 15 : -n & 7;
  },
  add: function(n, t) {
    return rotationCayley[n][t];
  },
  sub: function(n, t) {
    return rotationCayley[n][groupD8.inv(t)];
  },
  rotate180: function(n) {
    return n ^ 4;
  },
  isVertical: function(n) {
    return (n & 3) === 2;
  },
  byDirection: function(n, t) {
    return Math.abs(n) * 2 <= Math.abs(t) ? t >= 0 ? groupD8.S : groupD8.N : Math.abs(t) * 2 <= Math.abs(n) ? n > 0 ? groupD8.E : groupD8.W : t > 0 ? n > 0 ? groupD8.SE : groupD8.SW : n > 0 ? groupD8.NE : groupD8.NW;
  },
  matrixAppendRotationInv: function(n, t, e, o) {
    e === void 0 && (e = 0), o === void 0 && (o = 0);
    var R = rotationMatrices[groupD8.inv(t)];
    R.tx = e, R.ty = o, n.append(R);
  }
}, Transform = function() {
  function n() {
    this.worldTransform = new Matrix(), this.localTransform = new Matrix(), this.position = new ObservablePoint(this.onChange, this, 0, 0), this.scale = new ObservablePoint(this.onChange, this, 1, 1), this.pivot = new ObservablePoint(this.onChange, this, 0, 0), this.skew = new ObservablePoint(this.updateSkew, this, 0, 0), this._rotation = 0, this._cx = 1, this._sx = 0, this._cy = 0, this._sy = 1, this._localID = 0, this._currentLocalID = 0, this._worldID = 0, this._parentID = 0;
  }
  return n.prototype.onChange = function() {
    this._localID++;
  }, n.prototype.updateSkew = function() {
    this._cx = Math.cos(this._rotation + this.skew.y), this._sx = Math.sin(this._rotation + this.skew.y), this._cy = -Math.sin(this._rotation - this.skew.x), this._sy = Math.cos(this._rotation - this.skew.x), this._localID++;
  }, n.prototype.toString = function() {
    return "[@pixi/math:Transform " + ("position=(" + this.position.x + ", " + this.position.y + ") ") + ("rotation=" + this.rotation + " ") + ("scale=(" + this.scale.x + ", " + this.scale.y + ") ") + ("skew=(" + this.skew.x + ", " + this.skew.y + ") ") + "]";
  }, n.prototype.updateLocalTransform = function() {
    var t = this.localTransform;
    this._localID !== this._currentLocalID && (t.a = this._cx * this.scale.x, t.b = this._sx * this.scale.x, t.c = this._cy * this.scale.y, t.d = this._sy * this.scale.y, t.tx = this.position.x - (this.pivot.x * t.a + this.pivot.y * t.c), t.ty = this.position.y - (this.pivot.x * t.b + this.pivot.y * t.d), this._currentLocalID = this._localID, this._parentID = -1);
  }, n.prototype.updateTransform = function(t) {
    var e = this.localTransform;
    if (this._localID !== this._currentLocalID && (e.a = this._cx * this.scale.x, e.b = this._sx * this.scale.x, e.c = this._cy * this.scale.y, e.d = this._sy * this.scale.y, e.tx = this.position.x - (this.pivot.x * e.a + this.pivot.y * e.c), e.ty = this.position.y - (this.pivot.x * e.b + this.pivot.y * e.d), this._currentLocalID = this._localID, this._parentID = -1), this._parentID !== t._worldID) {
      var o = t.worldTransform, R = this.worldTransform;
      R.a = e.a * o.a + e.b * o.c, R.b = e.a * o.b + e.b * o.d, R.c = e.c * o.a + e.d * o.c, R.d = e.c * o.b + e.d * o.d, R.tx = e.tx * o.a + e.ty * o.c + o.tx, R.ty = e.tx * o.b + e.ty * o.d + o.ty, this._parentID = t._worldID, this._worldID++;
    }
  }, n.prototype.setFromMatrix = function(t) {
    t.decompose(this), this._localID++;
  }, Object.defineProperty(n.prototype, "rotation", {
    get: function() {
      return this._rotation;
    },
    set: function(t) {
      this._rotation !== t && (this._rotation = t, this.updateSkew());
    },
    enumerable: !1,
    configurable: !0
  }), n.IDENTITY = new n(), n;
}();
/*!
 * @pixi/core - v6.5.2
 * Compiled Wed, 24 Aug 2022 13:51:19 UTC
 *
 * @pixi/core is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
settings$1.PREFER_ENV = isMobile$2.any ? ENV$5.WEBGL : ENV$5.WEBGL2;
settings$1.STRICT_TEXTURE_CACHE = !1;
var INSTALLED = [];
function autoDetectResource(n, t) {
  if (!n)
    return null;
  var e = "";
  if (typeof n == "string") {
    var o = /\.(\w{3,4})(?:$|\?|#)/i.exec(n);
    o && (e = o[1].toLowerCase());
  }
  for (var R = INSTALLED.length - 1; R >= 0; --R) {
    var N = INSTALLED[R];
    if (N.test && N.test(n, e))
      return new N(n, t);
  }
  throw new Error("Unrecognized source type to auto-detect Resource");
}
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var extendStatics$q = function(n, t) {
  return extendStatics$q = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(e, o) {
    e.__proto__ = o;
  } || function(e, o) {
    for (var R in o)
      o.hasOwnProperty(R) && (e[R] = o[R]);
  }, extendStatics$q(n, t);
};
function __extends$q(n, t) {
  extendStatics$q(n, t);
  function e() {
    this.constructor = n;
  }
  n.prototype = t === null ? Object.create(t) : (e.prototype = t.prototype, new e());
}
var __assign$8 = function() {
  return __assign$8 = Object.assign || function(t) {
    for (var e = arguments, o, R = 1, N = arguments.length; R < N; R++) {
      o = e[R];
      for (var M in o)
        Object.prototype.hasOwnProperty.call(o, M) && (t[M] = o[M]);
    }
    return t;
  }, __assign$8.apply(this, arguments);
};
function __rest$3(n, t) {
  var e = {};
  for (var o in n)
    Object.prototype.hasOwnProperty.call(n, o) && t.indexOf(o) < 0 && (e[o] = n[o]);
  if (n != null && typeof Object.getOwnPropertySymbols == "function")
    for (var R = 0, o = Object.getOwnPropertySymbols(n); R < o.length; R++)
      t.indexOf(o[R]) < 0 && Object.prototype.propertyIsEnumerable.call(n, o[R]) && (e[o[R]] = n[o[R]]);
  return e;
}
var Resource = function() {
  function n(t, e) {
    t === void 0 && (t = 0), e === void 0 && (e = 0), this._width = t, this._height = e, this.destroyed = !1, this.internal = !1, this.onResize = new Runner("setRealSize"), this.onUpdate = new Runner("update"), this.onError = new Runner("onError");
  }
  return n.prototype.bind = function(t) {
    this.onResize.add(t), this.onUpdate.add(t), this.onError.add(t), (this._width || this._height) && this.onResize.emit(this._width, this._height);
  }, n.prototype.unbind = function(t) {
    this.onResize.remove(t), this.onUpdate.remove(t), this.onError.remove(t);
  }, n.prototype.resize = function(t, e) {
    (t !== this._width || e !== this._height) && (this._width = t, this._height = e, this.onResize.emit(t, e));
  }, Object.defineProperty(n.prototype, "valid", {
    get: function() {
      return !!this._width && !!this._height;
    },
    enumerable: !1,
    configurable: !0
  }), n.prototype.update = function() {
    this.destroyed || this.onUpdate.emit();
  }, n.prototype.load = function() {
    return Promise.resolve(this);
  }, Object.defineProperty(n.prototype, "width", {
    get: function() {
      return this._width;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(n.prototype, "height", {
    get: function() {
      return this._height;
    },
    enumerable: !1,
    configurable: !0
  }), n.prototype.style = function(t, e, o) {
    return !1;
  }, n.prototype.dispose = function() {
  }, n.prototype.destroy = function() {
    this.destroyed || (this.destroyed = !0, this.dispose(), this.onError.removeAll(), this.onError = null, this.onResize.removeAll(), this.onResize = null, this.onUpdate.removeAll(), this.onUpdate = null);
  }, n.test = function(t, e) {
    return !1;
  }, n;
}(), BufferResource = function(n) {
  __extends$q(t, n);
  function t(e, o) {
    var R = this, N = o || {}, M = N.width, D = N.height;
    if (!M || !D)
      throw new Error("BufferResource width or height invalid");
    return R = n.call(this, M, D) || this, R.data = e, R;
  }
  return t.prototype.upload = function(e, o, R) {
    var N = e.gl;
    N.pixelStorei(N.UNPACK_PREMULTIPLY_ALPHA_WEBGL, o.alphaMode === ALPHA_MODES$5.UNPACK);
    var M = o.realWidth, D = o.realHeight;
    return R.width === M && R.height === D ? N.texSubImage2D(o.target, 0, 0, 0, M, D, o.format, R.type, this.data) : (R.width = M, R.height = D, N.texImage2D(o.target, 0, R.internalFormat, M, D, 0, o.format, R.type, this.data)), !0;
  }, t.prototype.dispose = function() {
    this.data = null;
  }, t.test = function(e) {
    return e instanceof Float32Array || e instanceof Uint8Array || e instanceof Uint32Array;
  }, t;
}(Resource), defaultBufferOptions = {
  scaleMode: SCALE_MODES$5.NEAREST,
  format: FORMATS$5.RGBA,
  alphaMode: ALPHA_MODES$5.NPM
}, BaseTexture = function(n) {
  __extends$q(t, n);
  function t(e, o) {
    e === void 0 && (e = null), o === void 0 && (o = null);
    var R = n.call(this) || this;
    o = o || {};
    var N = o.alphaMode, M = o.mipmap, D = o.anisotropicLevel, L = o.scaleMode, B = o.width, $ = o.height, k = o.wrapMode, U = o.format, z = o.type, X = o.target, V = o.resolution, W = o.resourceOptions;
    return e && !(e instanceof Resource) && (e = autoDetectResource(e, W), e.internal = !0), R.resolution = V || settings$1.RESOLUTION, R.width = Math.round((B || 0) * R.resolution) / R.resolution, R.height = Math.round(($ || 0) * R.resolution) / R.resolution, R._mipmap = M !== void 0 ? M : settings$1.MIPMAP_TEXTURES, R.anisotropicLevel = D !== void 0 ? D : settings$1.ANISOTROPIC_LEVEL, R._wrapMode = k || settings$1.WRAP_MODE, R._scaleMode = L !== void 0 ? L : settings$1.SCALE_MODE, R.format = U || FORMATS$5.RGBA, R.type = z || TYPES$5.UNSIGNED_BYTE, R.target = X || TARGETS$5.TEXTURE_2D, R.alphaMode = N !== void 0 ? N : ALPHA_MODES$5.UNPACK, R.uid = uid(), R.touched = 0, R.isPowerOfTwo = !1, R._refreshPOT(), R._glTextures = {}, R.dirtyId = 0, R.dirtyStyleId = 0, R.cacheId = null, R.valid = B > 0 && $ > 0, R.textureCacheIds = [], R.destroyed = !1, R.resource = null, R._batchEnabled = 0, R._batchLocation = 0, R.parentTextureArray = null, R.setResource(e), R;
  }
  return Object.defineProperty(t.prototype, "realWidth", {
    get: function() {
      return Math.round(this.width * this.resolution);
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(t.prototype, "realHeight", {
    get: function() {
      return Math.round(this.height * this.resolution);
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(t.prototype, "mipmap", {
    get: function() {
      return this._mipmap;
    },
    set: function(e) {
      this._mipmap !== e && (this._mipmap = e, this.dirtyStyleId++);
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(t.prototype, "scaleMode", {
    get: function() {
      return this._scaleMode;
    },
    set: function(e) {
      this._scaleMode !== e && (this._scaleMode = e, this.dirtyStyleId++);
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(t.prototype, "wrapMode", {
    get: function() {
      return this._wrapMode;
    },
    set: function(e) {
      this._wrapMode !== e && (this._wrapMode = e, this.dirtyStyleId++);
    },
    enumerable: !1,
    configurable: !0
  }), t.prototype.setStyle = function(e, o) {
    var R;
    return e !== void 0 && e !== this.scaleMode && (this.scaleMode = e, R = !0), o !== void 0 && o !== this.mipmap && (this.mipmap = o, R = !0), R && this.dirtyStyleId++, this;
  }, t.prototype.setSize = function(e, o, R) {
    return R = R || this.resolution, this.setRealSize(e * R, o * R, R);
  }, t.prototype.setRealSize = function(e, o, R) {
    return this.resolution = R || this.resolution, this.width = Math.round(e) / this.resolution, this.height = Math.round(o) / this.resolution, this._refreshPOT(), this.update(), this;
  }, t.prototype._refreshPOT = function() {
    this.isPowerOfTwo = isPow2(this.realWidth) && isPow2(this.realHeight);
  }, t.prototype.setResolution = function(e) {
    var o = this.resolution;
    return o === e ? this : (this.resolution = e, this.valid && (this.width = Math.round(this.width * o) / e, this.height = Math.round(this.height * o) / e, this.emit("update", this)), this._refreshPOT(), this);
  }, t.prototype.setResource = function(e) {
    if (this.resource === e)
      return this;
    if (this.resource)
      throw new Error("Resource can be set only once");
    return e.bind(this), this.resource = e, this;
  }, t.prototype.update = function() {
    this.valid ? (this.dirtyId++, this.dirtyStyleId++, this.emit("update", this)) : this.width > 0 && this.height > 0 && (this.valid = !0, this.emit("loaded", this), this.emit("update", this));
  }, t.prototype.onError = function(e) {
    this.emit("error", this, e);
  }, t.prototype.destroy = function() {
    this.resource && (this.resource.unbind(this), this.resource.internal && this.resource.destroy(), this.resource = null), this.cacheId && (delete BaseTextureCache[this.cacheId], delete TextureCache[this.cacheId], this.cacheId = null), this.dispose(), t.removeFromCache(this), this.textureCacheIds = null, this.destroyed = !0;
  }, t.prototype.dispose = function() {
    this.emit("dispose", this);
  }, t.prototype.castToBaseTexture = function() {
    return this;
  }, t.from = function(e, o, R) {
    R === void 0 && (R = settings$1.STRICT_TEXTURE_CACHE);
    var N = typeof e == "string", M = null;
    if (N)
      M = e;
    else {
      if (!e._pixiId) {
        var D = o && o.pixiIdPrefix || "pixiid";
        e._pixiId = D + "_" + uid();
      }
      M = e._pixiId;
    }
    var L = BaseTextureCache[M];
    if (N && R && !L)
      throw new Error('The cacheId "' + M + '" does not exist in BaseTextureCache.');
    return L || (L = new t(e, o), L.cacheId = M, t.addToCache(L, M)), L;
  }, t.fromBuffer = function(e, o, R, N) {
    e = e || new Float32Array(o * R * 4);
    var M = new BufferResource(e, { width: o, height: R }), D = e instanceof Float32Array ? TYPES$5.FLOAT : TYPES$5.UNSIGNED_BYTE;
    return new t(M, Object.assign(defaultBufferOptions, N || { width: o, height: R, type: D }));
  }, t.addToCache = function(e, o) {
    o && (e.textureCacheIds.indexOf(o) === -1 && e.textureCacheIds.push(o), BaseTextureCache[o] && console.warn("BaseTexture added to the cache with an id [" + o + "] that already had an entry"), BaseTextureCache[o] = e);
  }, t.removeFromCache = function(e) {
    if (typeof e == "string") {
      var o = BaseTextureCache[e];
      if (o) {
        var R = o.textureCacheIds.indexOf(e);
        return R > -1 && o.textureCacheIds.splice(R, 1), delete BaseTextureCache[e], o;
      }
    } else if (e && e.textureCacheIds) {
      for (var N = 0; N < e.textureCacheIds.length; ++N)
        delete BaseTextureCache[e.textureCacheIds[N]];
      return e.textureCacheIds.length = 0, e;
    }
    return null;
  }, t._globalBatch = 0, t;
}(EventEmitter$4), AbstractMultiResource = function(n) {
  __extends$q(t, n);
  function t(e, o) {
    var R = this, N = o || {}, M = N.width, D = N.height;
    R = n.call(this, M, D) || this, R.items = [], R.itemDirtyIds = [];
    for (var L = 0; L < e; L++) {
      var B = new BaseTexture();
      R.items.push(B), R.itemDirtyIds.push(-2);
    }
    return R.length = e, R._load = null, R.baseTexture = null, R;
  }
  return t.prototype.initFromArray = function(e, o) {
    for (var R = 0; R < this.length; R++)
      !e[R] || (e[R].castToBaseTexture ? this.addBaseTextureAt(e[R].castToBaseTexture(), R) : e[R] instanceof Resource ? this.addResourceAt(e[R], R) : this.addResourceAt(autoDetectResource(e[R], o), R));
  }, t.prototype.dispose = function() {
    for (var e = 0, o = this.length; e < o; e++)
      this.items[e].destroy();
    this.items = null, this.itemDirtyIds = null, this._load = null;
  }, t.prototype.addResourceAt = function(e, o) {
    if (!this.items[o])
      throw new Error("Index " + o + " is out of bounds");
    return e.valid && !this.valid && this.resize(e.width, e.height), this.items[o].setResource(e), this;
  }, t.prototype.bind = function(e) {
    if (this.baseTexture !== null)
      throw new Error("Only one base texture per TextureArray is allowed");
    n.prototype.bind.call(this, e);
    for (var o = 0; o < this.length; o++)
      this.items[o].parentTextureArray = e, this.items[o].on("update", e.update, e);
  }, t.prototype.unbind = function(e) {
    n.prototype.unbind.call(this, e);
    for (var o = 0; o < this.length; o++)
      this.items[o].parentTextureArray = null, this.items[o].off("update", e.update, e);
  }, t.prototype.load = function() {
    var e = this;
    if (this._load)
      return this._load;
    var o = this.items.map(function(N) {
      return N.resource;
    }).filter(function(N) {
      return N;
    }), R = o.map(function(N) {
      return N.load();
    });
    return this._load = Promise.all(R).then(function() {
      var N = e.items[0], M = N.realWidth, D = N.realHeight;
      return e.resize(M, D), Promise.resolve(e);
    }), this._load;
  }, t;
}(Resource), ArrayResource = function(n) {
  __extends$q(t, n);
  function t(e, o) {
    var R = this, N = o || {}, M = N.width, D = N.height, L, B;
    return Array.isArray(e) ? (L = e, B = e.length) : B = e, R = n.call(this, B, { width: M, height: D }) || this, L && R.initFromArray(L, o), R;
  }
  return t.prototype.addBaseTextureAt = function(e, o) {
    if (e.resource)
      this.addResourceAt(e.resource, o);
    else
      throw new Error("ArrayResource does not support RenderTexture");
    return this;
  }, t.prototype.bind = function(e) {
    n.prototype.bind.call(this, e), e.target = TARGETS$5.TEXTURE_2D_ARRAY;
  }, t.prototype.upload = function(e, o, R) {
    var N = this, M = N.length, D = N.itemDirtyIds, L = N.items, B = e.gl;
    R.dirtyId < 0 && B.texImage3D(B.TEXTURE_2D_ARRAY, 0, R.internalFormat, this._width, this._height, M, 0, o.format, R.type, null);
    for (var $ = 0; $ < M; $++) {
      var k = L[$];
      D[$] < k.dirtyId && (D[$] = k.dirtyId, k.valid && B.texSubImage3D(
        B.TEXTURE_2D_ARRAY,
        0,
        0,
        0,
        $,
        k.resource.width,
        k.resource.height,
        1,
        o.format,
        R.type,
        k.resource.source
      ));
    }
    return !0;
  }, t;
}(AbstractMultiResource), BaseImageResource = function(n) {
  __extends$q(t, n);
  function t(e) {
    var o = this, R = e, N = R.naturalWidth || R.videoWidth || R.width, M = R.naturalHeight || R.videoHeight || R.height;
    return o = n.call(this, N, M) || this, o.source = e, o.noSubImage = !1, o;
  }
  return t.crossOrigin = function(e, o, R) {
    R === void 0 && o.indexOf("data:") !== 0 ? e.crossOrigin = determineCrossOrigin(o) : R !== !1 && (e.crossOrigin = typeof R == "string" ? R : "anonymous");
  }, t.prototype.upload = function(e, o, R, N) {
    var M = e.gl, D = o.realWidth, L = o.realHeight;
    if (N = N || this.source, N instanceof HTMLImageElement) {
      if (!N.complete || N.naturalWidth === 0)
        return !1;
    } else if (N instanceof HTMLVideoElement && N.readyState <= 1)
      return !1;
    return M.pixelStorei(M.UNPACK_PREMULTIPLY_ALPHA_WEBGL, o.alphaMode === ALPHA_MODES$5.UNPACK), !this.noSubImage && o.target === M.TEXTURE_2D && R.width === D && R.height === L ? M.texSubImage2D(M.TEXTURE_2D, 0, 0, 0, o.format, R.type, N) : (R.width = D, R.height = L, M.texImage2D(o.target, 0, R.internalFormat, o.format, R.type, N)), !0;
  }, t.prototype.update = function() {
    if (!this.destroyed) {
      var e = this.source, o = e.naturalWidth || e.videoWidth || e.width, R = e.naturalHeight || e.videoHeight || e.height;
      this.resize(o, R), n.prototype.update.call(this);
    }
  }, t.prototype.dispose = function() {
    this.source = null;
  }, t;
}(Resource), CanvasResource = function(n) {
  __extends$q(t, n);
  function t(e) {
    return n.call(this, e) || this;
  }
  return t.test = function(e) {
    var o = globalThis.OffscreenCanvas;
    return o && e instanceof o ? !0 : globalThis.HTMLCanvasElement && e instanceof HTMLCanvasElement;
  }, t;
}(BaseImageResource), CubeResource = function(n) {
  __extends$q(t, n);
  function t(e, o) {
    var R = this, N = o || {}, M = N.width, D = N.height, L = N.autoLoad, B = N.linkBaseTexture;
    if (e && e.length !== t.SIDES)
      throw new Error("Invalid length. Got " + e.length + ", expected 6");
    R = n.call(this, 6, { width: M, height: D }) || this;
    for (var $ = 0; $ < t.SIDES; $++)
      R.items[$].target = TARGETS$5.TEXTURE_CUBE_MAP_POSITIVE_X + $;
    return R.linkBaseTexture = B !== !1, e && R.initFromArray(e, o), L !== !1 && R.load(), R;
  }
  return t.prototype.bind = function(e) {
    n.prototype.bind.call(this, e), e.target = TARGETS$5.TEXTURE_CUBE_MAP;
  }, t.prototype.addBaseTextureAt = function(e, o, R) {
    if (!this.items[o])
      throw new Error("Index " + o + " is out of bounds");
    if (!this.linkBaseTexture || e.parentTextureArray || Object.keys(e._glTextures).length > 0)
      if (e.resource)
        this.addResourceAt(e.resource, o);
      else
        throw new Error("CubeResource does not support copying of renderTexture.");
    else
      e.target = TARGETS$5.TEXTURE_CUBE_MAP_POSITIVE_X + o, e.parentTextureArray = this.baseTexture, this.items[o] = e;
    return e.valid && !this.valid && this.resize(e.realWidth, e.realHeight), this.items[o] = e, this;
  }, t.prototype.upload = function(e, o, R) {
    for (var N = this.itemDirtyIds, M = 0; M < t.SIDES; M++) {
      var D = this.items[M];
      (N[M] < D.dirtyId || R.dirtyId < o.dirtyId) && (D.valid && D.resource ? (D.resource.upload(e, D, R), N[M] = D.dirtyId) : N[M] < -1 && (e.gl.texImage2D(D.target, 0, R.internalFormat, o.realWidth, o.realHeight, 0, o.format, R.type, null), N[M] = -1));
    }
    return !0;
  }, t.test = function(e) {
    return Array.isArray(e) && e.length === t.SIDES;
  }, t.SIDES = 6, t;
}(AbstractMultiResource), ImageResource = function(n) {
  __extends$q(t, n);
  function t(e, o) {
    var R = this;
    if (o = o || {}, !(e instanceof HTMLImageElement)) {
      var N = new Image();
      BaseImageResource.crossOrigin(N, e, o.crossorigin), N.src = e, e = N;
    }
    return R = n.call(this, e) || this, !e.complete && !!R._width && !!R._height && (R._width = 0, R._height = 0), R.url = e.src, R._process = null, R.preserveBitmap = !1, R.createBitmap = (o.createBitmap !== void 0 ? o.createBitmap : settings$1.CREATE_IMAGE_BITMAP) && !!globalThis.createImageBitmap, R.alphaMode = typeof o.alphaMode == "number" ? o.alphaMode : null, R.bitmap = null, R._load = null, o.autoLoad !== !1 && R.load(), R;
  }
  return t.prototype.load = function(e) {
    var o = this;
    return this._load ? this._load : (e !== void 0 && (this.createBitmap = e), this._load = new Promise(function(R, N) {
      var M = o.source;
      o.url = M.src;
      var D = function() {
        o.destroyed || (M.onload = null, M.onerror = null, o.resize(M.width, M.height), o._load = null, o.createBitmap ? R(o.process()) : R(o));
      };
      M.complete && M.src ? D() : (M.onload = D, M.onerror = function(L) {
        N(L), o.onError.emit(L);
      });
    }), this._load);
  }, t.prototype.process = function() {
    var e = this, o = this.source;
    if (this._process !== null)
      return this._process;
    if (this.bitmap !== null || !globalThis.createImageBitmap)
      return Promise.resolve(this);
    var R = globalThis.createImageBitmap, N = !o.crossOrigin || o.crossOrigin === "anonymous";
    return this._process = fetch(o.src, {
      mode: N ? "cors" : "no-cors"
    }).then(function(M) {
      return M.blob();
    }).then(function(M) {
      return R(M, 0, 0, o.width, o.height, {
        premultiplyAlpha: e.alphaMode === ALPHA_MODES$5.UNPACK ? "premultiply" : "none"
      });
    }).then(function(M) {
      return e.destroyed ? Promise.reject() : (e.bitmap = M, e.update(), e._process = null, Promise.resolve(e));
    }), this._process;
  }, t.prototype.upload = function(e, o, R) {
    if (typeof this.alphaMode == "number" && (o.alphaMode = this.alphaMode), !this.createBitmap)
      return n.prototype.upload.call(this, e, o, R);
    if (!this.bitmap && (this.process(), !this.bitmap))
      return !1;
    if (n.prototype.upload.call(this, e, o, R, this.bitmap), !this.preserveBitmap) {
      var N = !0, M = o._glTextures;
      for (var D in M) {
        var L = M[D];
        if (L !== R && L.dirtyId !== o.dirtyId) {
          N = !1;
          break;
        }
      }
      N && (this.bitmap.close && this.bitmap.close(), this.bitmap = null);
    }
    return !0;
  }, t.prototype.dispose = function() {
    this.source.onload = null, this.source.onerror = null, n.prototype.dispose.call(this), this.bitmap && (this.bitmap.close(), this.bitmap = null), this._process = null, this._load = null;
  }, t.test = function(e) {
    return typeof e == "string" || e instanceof HTMLImageElement;
  }, t;
}(BaseImageResource), SVGResource = function(n) {
  __extends$q(t, n);
  function t(e, o) {
    var R = this;
    return o = o || {}, R = n.call(this, settings$1.ADAPTER.createCanvas()) || this, R._width = 0, R._height = 0, R.svg = e, R.scale = o.scale || 1, R._overrideWidth = o.width, R._overrideHeight = o.height, R._resolve = null, R._crossorigin = o.crossorigin, R._load = null, o.autoLoad !== !1 && R.load(), R;
  }
  return t.prototype.load = function() {
    var e = this;
    return this._load ? this._load : (this._load = new Promise(function(o) {
      if (e._resolve = function() {
        e.resize(e.source.width, e.source.height), o(e);
      }, t.SVG_XML.test(e.svg.trim())) {
        if (!btoa)
          throw new Error("Your browser doesn't support base64 conversions.");
        e.svg = "data:image/svg+xml;base64," + btoa(unescape(encodeURIComponent(e.svg)));
      }
      e._loadSvg();
    }), this._load);
  }, t.prototype._loadSvg = function() {
    var e = this, o = new Image();
    BaseImageResource.crossOrigin(o, this.svg, this._crossorigin), o.src = this.svg, o.onerror = function(R) {
      !e._resolve || (o.onerror = null, e.onError.emit(R));
    }, o.onload = function() {
      if (!!e._resolve) {
        var R = o.width, N = o.height;
        if (!R || !N)
          throw new Error("The SVG image must have width and height defined (in pixels), canvas API needs them.");
        var M = R * e.scale, D = N * e.scale;
        (e._overrideWidth || e._overrideHeight) && (M = e._overrideWidth || e._overrideHeight / N * R, D = e._overrideHeight || e._overrideWidth / R * N), M = Math.round(M), D = Math.round(D);
        var L = e.source;
        L.width = M, L.height = D, L._pixiId = "canvas_" + uid(), L.getContext("2d").drawImage(o, 0, 0, R, N, 0, 0, M, D), e._resolve(), e._resolve = null;
      }
    };
  }, t.getSize = function(e) {
    var o = t.SVG_SIZE.exec(e), R = {};
    return o && (R[o[1]] = Math.round(parseFloat(o[3])), R[o[5]] = Math.round(parseFloat(o[7]))), R;
  }, t.prototype.dispose = function() {
    n.prototype.dispose.call(this), this._resolve = null, this._crossorigin = null;
  }, t.test = function(e, o) {
    return o === "svg" || typeof e == "string" && /^data:image\/svg\+xml(;(charset=utf8|utf8))?;base64/.test(e) || typeof e == "string" && t.SVG_XML.test(e);
  }, t.SVG_XML = /^(<\?xml[^?]+\?>)?\s*(<!--[^(-->)]*-->)?\s*\<svg/m, t.SVG_SIZE = /<svg[^>]*(?:\s(width|height)=('|")(\d*(?:\.\d+)?)(?:px)?('|"))[^>]*(?:\s(width|height)=('|")(\d*(?:\.\d+)?)(?:px)?('|"))[^>]*>/i, t;
}(BaseImageResource), VideoResource = function(n) {
  __extends$q(t, n);
  function t(e, o) {
    var R = this;
    if (o = o || {}, !(e instanceof HTMLVideoElement)) {
      var N = document.createElement("video");
      N.setAttribute("preload", "auto"), N.setAttribute("webkit-playsinline", ""), N.setAttribute("playsinline", ""), typeof e == "string" && (e = [e]);
      var M = e[0].src || e[0];
      BaseImageResource.crossOrigin(N, M, o.crossorigin);
      for (var D = 0; D < e.length; ++D) {
        var L = document.createElement("source"), B = e[D], $ = B.src, k = B.mime;
        $ = $ || e[D];
        var U = $.split("?").shift().toLowerCase(), z = U.slice(U.lastIndexOf(".") + 1);
        k = k || t.MIME_TYPES[z] || "video/" + z, L.src = $, L.type = k, N.appendChild(L);
      }
      e = N;
    }
    return R = n.call(this, e) || this, R.noSubImage = !0, R._autoUpdate = !0, R._isConnectedToTicker = !1, R._updateFPS = o.updateFPS || 0, R._msToNextUpdate = 0, R.autoPlay = o.autoPlay !== !1, R._load = null, R._resolve = null, R._onCanPlay = R._onCanPlay.bind(R), R._onError = R._onError.bind(R), o.autoLoad !== !1 && R.load(), R;
  }
  return t.prototype.update = function(e) {
    if (!this.destroyed) {
      var o = Ticker.shared.elapsedMS * this.source.playbackRate;
      this._msToNextUpdate = Math.floor(this._msToNextUpdate - o), (!this._updateFPS || this._msToNextUpdate <= 0) && (n.prototype.update.call(this), this._msToNextUpdate = this._updateFPS ? Math.floor(1e3 / this._updateFPS) : 0);
    }
  }, t.prototype.load = function() {
    var e = this;
    if (this._load)
      return this._load;
    var o = this.source;
    return (o.readyState === o.HAVE_ENOUGH_DATA || o.readyState === o.HAVE_FUTURE_DATA) && o.width && o.height && (o.complete = !0), o.addEventListener("play", this._onPlayStart.bind(this)), o.addEventListener("pause", this._onPlayStop.bind(this)), this._isSourceReady() ? this._onCanPlay() : (o.addEventListener("canplay", this._onCanPlay), o.addEventListener("canplaythrough", this._onCanPlay), o.addEventListener("error", this._onError, !0)), this._load = new Promise(function(R) {
      e.valid ? R(e) : (e._resolve = R, o.load());
    }), this._load;
  }, t.prototype._onError = function(e) {
    this.source.removeEventListener("error", this._onError, !0), this.onError.emit(e);
  }, t.prototype._isSourcePlaying = function() {
    var e = this.source;
    return e.currentTime > 0 && e.paused === !1 && e.ended === !1 && e.readyState > 2;
  }, t.prototype._isSourceReady = function() {
    var e = this.source;
    return e.readyState === 3 || e.readyState === 4;
  }, t.prototype._onPlayStart = function() {
    this.valid || this._onCanPlay(), this.autoUpdate && !this._isConnectedToTicker && (Ticker.shared.add(this.update, this), this._isConnectedToTicker = !0);
  }, t.prototype._onPlayStop = function() {
    this._isConnectedToTicker && (Ticker.shared.remove(this.update, this), this._isConnectedToTicker = !1);
  }, t.prototype._onCanPlay = function() {
    var e = this.source;
    e.removeEventListener("canplay", this._onCanPlay), e.removeEventListener("canplaythrough", this._onCanPlay);
    var o = this.valid;
    this.resize(e.videoWidth, e.videoHeight), !o && this._resolve && (this._resolve(this), this._resolve = null), this._isSourcePlaying() ? this._onPlayStart() : this.autoPlay && e.play();
  }, t.prototype.dispose = function() {
    this._isConnectedToTicker && (Ticker.shared.remove(this.update, this), this._isConnectedToTicker = !1);
    var e = this.source;
    e && (e.removeEventListener("error", this._onError, !0), e.pause(), e.src = "", e.load()), n.prototype.dispose.call(this);
  }, Object.defineProperty(t.prototype, "autoUpdate", {
    get: function() {
      return this._autoUpdate;
    },
    set: function(e) {
      e !== this._autoUpdate && (this._autoUpdate = e, !this._autoUpdate && this._isConnectedToTicker ? (Ticker.shared.remove(this.update, this), this._isConnectedToTicker = !1) : this._autoUpdate && !this._isConnectedToTicker && this._isSourcePlaying() && (Ticker.shared.add(this.update, this), this._isConnectedToTicker = !0));
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(t.prototype, "updateFPS", {
    get: function() {
      return this._updateFPS;
    },
    set: function(e) {
      e !== this._updateFPS && (this._updateFPS = e);
    },
    enumerable: !1,
    configurable: !0
  }), t.test = function(e, o) {
    return globalThis.HTMLVideoElement && e instanceof HTMLVideoElement || t.TYPES.indexOf(o) > -1;
  }, t.TYPES = ["mp4", "m4v", "webm", "ogg", "ogv", "h264", "avi", "mov"], t.MIME_TYPES = {
    ogv: "video/ogg",
    mov: "video/quicktime",
    m4v: "video/mp4"
  }, t;
}(BaseImageResource), ImageBitmapResource = function(n) {
  __extends$q(t, n);
  function t(e) {
    return n.call(this, e) || this;
  }
  return t.test = function(e) {
    return !!globalThis.createImageBitmap && typeof ImageBitmap < "u" && e instanceof ImageBitmap;
  }, t;
}(BaseImageResource);
INSTALLED.push(ImageResource, ImageBitmapResource, CanvasResource, VideoResource, SVGResource, BufferResource, CubeResource, ArrayResource);
var DepthResource = function(n) {
  __extends$q(t, n);
  function t() {
    return n !== null && n.apply(this, arguments) || this;
  }
  return t.prototype.upload = function(e, o, R) {
    var N = e.gl;
    N.pixelStorei(N.UNPACK_PREMULTIPLY_ALPHA_WEBGL, o.alphaMode === ALPHA_MODES$5.UNPACK);
    var M = o.realWidth, D = o.realHeight;
    return R.width === M && R.height === D ? N.texSubImage2D(o.target, 0, 0, 0, M, D, o.format, R.type, this.data) : (R.width = M, R.height = D, N.texImage2D(o.target, 0, R.internalFormat, M, D, 0, o.format, R.type, this.data)), !0;
  }, t;
}(BufferResource), Framebuffer = function() {
  function n(t, e) {
    this.width = Math.round(t || 100), this.height = Math.round(e || 100), this.stencil = !1, this.depth = !1, this.dirtyId = 0, this.dirtyFormat = 0, this.dirtySize = 0, this.depthTexture = null, this.colorTextures = [], this.glFramebuffers = {}, this.disposeRunner = new Runner("disposeFramebuffer"), this.multisample = MSAA_QUALITY$5.NONE;
  }
  return Object.defineProperty(n.prototype, "colorTexture", {
    get: function() {
      return this.colorTextures[0];
    },
    enumerable: !1,
    configurable: !0
  }), n.prototype.addColorTexture = function(t, e) {
    return t === void 0 && (t = 0), this.colorTextures[t] = e || new BaseTexture(null, {
      scaleMode: SCALE_MODES$5.NEAREST,
      resolution: 1,
      mipmap: MIPMAP_MODES$5.OFF,
      width: this.width,
      height: this.height
    }), this.dirtyId++, this.dirtyFormat++, this;
  }, n.prototype.addDepthTexture = function(t) {
    return this.depthTexture = t || new BaseTexture(new DepthResource(null, { width: this.width, height: this.height }), {
      scaleMode: SCALE_MODES$5.NEAREST,
      resolution: 1,
      width: this.width,
      height: this.height,
      mipmap: MIPMAP_MODES$5.OFF,
      format: FORMATS$5.DEPTH_COMPONENT,
      type: TYPES$5.UNSIGNED_SHORT
    }), this.dirtyId++, this.dirtyFormat++, this;
  }, n.prototype.enableDepth = function() {
    return this.depth = !0, this.dirtyId++, this.dirtyFormat++, this;
  }, n.prototype.enableStencil = function() {
    return this.stencil = !0, this.dirtyId++, this.dirtyFormat++, this;
  }, n.prototype.resize = function(t, e) {
    if (t = Math.round(t), e = Math.round(e), !(t === this.width && e === this.height)) {
      this.width = t, this.height = e, this.dirtyId++, this.dirtySize++;
      for (var o = 0; o < this.colorTextures.length; o++) {
        var R = this.colorTextures[o], N = R.resolution;
        R.setSize(t / N, e / N);
      }
      if (this.depthTexture) {
        var N = this.depthTexture.resolution;
        this.depthTexture.setSize(t / N, e / N);
      }
    }
  }, n.prototype.dispose = function() {
    this.disposeRunner.emit(this, !1);
  }, n.prototype.destroyDepthTexture = function() {
    this.depthTexture && (this.depthTexture.destroy(), this.depthTexture = null, ++this.dirtyId, ++this.dirtyFormat);
  }, n;
}(), BaseRenderTexture = function(n) {
  __extends$q(t, n);
  function t(e) {
    e === void 0 && (e = {});
    var o = this;
    if (typeof e == "number") {
      var R = arguments[0], N = arguments[1], M = arguments[2], D = arguments[3];
      e = { width: R, height: N, scaleMode: M, resolution: D };
    }
    return e.width = e.width || 100, e.height = e.height || 100, e.multisample = e.multisample !== void 0 ? e.multisample : MSAA_QUALITY$5.NONE, o = n.call(this, null, e) || this, o.mipmap = MIPMAP_MODES$5.OFF, o.valid = !0, o.clearColor = [0, 0, 0, 0], o.framebuffer = new Framebuffer(o.realWidth, o.realHeight).addColorTexture(0, o), o.framebuffer.multisample = e.multisample, o.maskStack = [], o.filterStack = [{}], o;
  }
  return t.prototype.resize = function(e, o) {
    this.framebuffer.resize(e * this.resolution, o * this.resolution), this.setRealSize(this.framebuffer.width, this.framebuffer.height);
  }, t.prototype.dispose = function() {
    this.framebuffer.dispose(), n.prototype.dispose.call(this);
  }, t.prototype.destroy = function() {
    n.prototype.destroy.call(this), this.framebuffer.destroyDepthTexture(), this.framebuffer = null;
  }, t;
}(BaseTexture), TextureUvs = function() {
  function n() {
    this.x0 = 0, this.y0 = 0, this.x1 = 1, this.y1 = 0, this.x2 = 1, this.y2 = 1, this.x3 = 0, this.y3 = 1, this.uvsFloat32 = new Float32Array(8);
  }
  return n.prototype.set = function(t, e, o) {
    var R = e.width, N = e.height;
    if (o) {
      var M = t.width / 2 / R, D = t.height / 2 / N, L = t.x / R + M, B = t.y / N + D;
      o = groupD8.add(o, groupD8.NW), this.x0 = L + M * groupD8.uX(o), this.y0 = B + D * groupD8.uY(o), o = groupD8.add(o, 2), this.x1 = L + M * groupD8.uX(o), this.y1 = B + D * groupD8.uY(o), o = groupD8.add(o, 2), this.x2 = L + M * groupD8.uX(o), this.y2 = B + D * groupD8.uY(o), o = groupD8.add(o, 2), this.x3 = L + M * groupD8.uX(o), this.y3 = B + D * groupD8.uY(o);
    } else
      this.x0 = t.x / R, this.y0 = t.y / N, this.x1 = (t.x + t.width) / R, this.y1 = t.y / N, this.x2 = (t.x + t.width) / R, this.y2 = (t.y + t.height) / N, this.x3 = t.x / R, this.y3 = (t.y + t.height) / N;
    this.uvsFloat32[0] = this.x0, this.uvsFloat32[1] = this.y0, this.uvsFloat32[2] = this.x1, this.uvsFloat32[3] = this.y1, this.uvsFloat32[4] = this.x2, this.uvsFloat32[5] = this.y2, this.uvsFloat32[6] = this.x3, this.uvsFloat32[7] = this.y3;
  }, n.prototype.toString = function() {
    return "[@pixi/core:TextureUvs " + ("x0=" + this.x0 + " y0=" + this.y0 + " ") + ("x1=" + this.x1 + " y1=" + this.y1 + " x2=" + this.x2 + " ") + ("y2=" + this.y2 + " x3=" + this.x3 + " y3=" + this.y3) + "]";
  }, n;
}(), DEFAULT_UVS = new TextureUvs();
function removeAllHandlers(n) {
  n.destroy = function() {
  }, n.on = function() {
  }, n.once = function() {
  }, n.emit = function() {
  };
}
var Texture = function(n) {
  __extends$q(t, n);
  function t(e, o, R, N, M, D) {
    var L = n.call(this) || this;
    if (L.noFrame = !1, o || (L.noFrame = !0, o = new Rectangle(0, 0, 1, 1)), e instanceof t && (e = e.baseTexture), L.baseTexture = e, L._frame = o, L.trim = N, L.valid = !1, L._uvs = DEFAULT_UVS, L.uvMatrix = null, L.orig = R || o, L._rotate = Number(M || 0), M === !0)
      L._rotate = 2;
    else if (L._rotate % 2 !== 0)
      throw new Error("attempt to use diamond-shaped UVs. If you are sure, set rotation manually");
    return L.defaultAnchor = D ? new Point(D.x, D.y) : new Point(0, 0), L._updateID = 0, L.textureCacheIds = [], e.valid ? L.noFrame ? e.valid && L.onBaseTextureUpdated(e) : L.frame = o : e.once("loaded", L.onBaseTextureUpdated, L), L.noFrame && e.on("update", L.onBaseTextureUpdated, L), L;
  }
  return t.prototype.update = function() {
    this.baseTexture.resource && this.baseTexture.resource.update();
  }, t.prototype.onBaseTextureUpdated = function(e) {
    if (this.noFrame) {
      if (!this.baseTexture.valid)
        return;
      this._frame.width = e.width, this._frame.height = e.height, this.valid = !0, this.updateUvs();
    } else
      this.frame = this._frame;
    this.emit("update", this);
  }, t.prototype.destroy = function(e) {
    if (this.baseTexture) {
      if (e) {
        var o = this.baseTexture.resource;
        o && o.url && TextureCache[o.url] && t.removeFromCache(o.url), this.baseTexture.destroy();
      }
      this.baseTexture.off("loaded", this.onBaseTextureUpdated, this), this.baseTexture.off("update", this.onBaseTextureUpdated, this), this.baseTexture = null;
    }
    this._frame = null, this._uvs = null, this.trim = null, this.orig = null, this.valid = !1, t.removeFromCache(this), this.textureCacheIds = null;
  }, t.prototype.clone = function() {
    var e = this._frame.clone(), o = this._frame === this.orig ? e : this.orig.clone(), R = new t(this.baseTexture, !this.noFrame && e, o, this.trim && this.trim.clone(), this.rotate, this.defaultAnchor);
    return this.noFrame && (R._frame = e), R;
  }, t.prototype.updateUvs = function() {
    this._uvs === DEFAULT_UVS && (this._uvs = new TextureUvs()), this._uvs.set(this._frame, this.baseTexture, this.rotate), this._updateID++;
  }, t.from = function(e, o, R) {
    o === void 0 && (o = {}), R === void 0 && (R = settings$1.STRICT_TEXTURE_CACHE);
    var N = typeof e == "string", M = null;
    if (N)
      M = e;
    else if (e instanceof BaseTexture) {
      if (!e.cacheId) {
        var D = o && o.pixiIdPrefix || "pixiid";
        e.cacheId = D + "-" + uid(), BaseTexture.addToCache(e, e.cacheId);
      }
      M = e.cacheId;
    } else {
      if (!e._pixiId) {
        var D = o && o.pixiIdPrefix || "pixiid";
        e._pixiId = D + "_" + uid();
      }
      M = e._pixiId;
    }
    var L = TextureCache[M];
    if (N && R && !L)
      throw new Error('The cacheId "' + M + '" does not exist in TextureCache.');
    return !L && !(e instanceof BaseTexture) ? (o.resolution || (o.resolution = getResolutionOfUrl(e)), L = new t(new BaseTexture(e, o)), L.baseTexture.cacheId = M, BaseTexture.addToCache(L.baseTexture, M), t.addToCache(L, M)) : !L && e instanceof BaseTexture && (L = new t(e), t.addToCache(L, M)), L;
  }, t.fromURL = function(e, o) {
    var R = Object.assign({ autoLoad: !1 }, o == null ? void 0 : o.resourceOptions), N = t.from(e, Object.assign({ resourceOptions: R }, o), !1), M = N.baseTexture.resource;
    return N.baseTexture.valid ? Promise.resolve(N) : M.load().then(function() {
      return Promise.resolve(N);
    });
  }, t.fromBuffer = function(e, o, R, N) {
    return new t(BaseTexture.fromBuffer(e, o, R, N));
  }, t.fromLoader = function(e, o, R, N) {
    var M = new BaseTexture(e, Object.assign({
      scaleMode: settings$1.SCALE_MODE,
      resolution: getResolutionOfUrl(o)
    }, N)), D = M.resource;
    D instanceof ImageResource && (D.url = o);
    var L = new t(M);
    return R || (R = o), BaseTexture.addToCache(L.baseTexture, R), t.addToCache(L, R), R !== o && (BaseTexture.addToCache(L.baseTexture, o), t.addToCache(L, o)), L.baseTexture.valid ? Promise.resolve(L) : new Promise(function(B) {
      L.baseTexture.once("loaded", function() {
        return B(L);
      });
    });
  }, t.addToCache = function(e, o) {
    o && (e.textureCacheIds.indexOf(o) === -1 && e.textureCacheIds.push(o), TextureCache[o] && console.warn("Texture added to the cache with an id [" + o + "] that already had an entry"), TextureCache[o] = e);
  }, t.removeFromCache = function(e) {
    if (typeof e == "string") {
      var o = TextureCache[e];
      if (o) {
        var R = o.textureCacheIds.indexOf(e);
        return R > -1 && o.textureCacheIds.splice(R, 1), delete TextureCache[e], o;
      }
    } else if (e && e.textureCacheIds) {
      for (var N = 0; N < e.textureCacheIds.length; ++N)
        TextureCache[e.textureCacheIds[N]] === e && delete TextureCache[e.textureCacheIds[N]];
      return e.textureCacheIds.length = 0, e;
    }
    return null;
  }, Object.defineProperty(t.prototype, "resolution", {
    get: function() {
      return this.baseTexture.resolution;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(t.prototype, "frame", {
    get: function() {
      return this._frame;
    },
    set: function(e) {
      this._frame = e, this.noFrame = !1;
      var o = e.x, R = e.y, N = e.width, M = e.height, D = o + N > this.baseTexture.width, L = R + M > this.baseTexture.height;
      if (D || L) {
        var B = D && L ? "and" : "or", $ = "X: " + o + " + " + N + " = " + (o + N) + " > " + this.baseTexture.width, k = "Y: " + R + " + " + M + " = " + (R + M) + " > " + this.baseTexture.height;
        throw new Error("Texture Error: frame does not fit inside the base Texture dimensions: " + ($ + " " + B + " " + k));
      }
      this.valid = N && M && this.baseTexture.valid, !this.trim && !this.rotate && (this.orig = e), this.valid && this.updateUvs();
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(t.prototype, "rotate", {
    get: function() {
      return this._rotate;
    },
    set: function(e) {
      this._rotate = e, this.valid && this.updateUvs();
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(t.prototype, "width", {
    get: function() {
      return this.orig.width;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(t.prototype, "height", {
    get: function() {
      return this.orig.height;
    },
    enumerable: !1,
    configurable: !0
  }), t.prototype.castToBaseTexture = function() {
    return this.baseTexture;
  }, Object.defineProperty(t, "EMPTY", {
    get: function() {
      return t._EMPTY || (t._EMPTY = new t(new BaseTexture()), removeAllHandlers(t._EMPTY), removeAllHandlers(t._EMPTY.baseTexture)), t._EMPTY;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(t, "WHITE", {
    get: function() {
      if (!t._WHITE) {
        var e = settings$1.ADAPTER.createCanvas(16, 16), o = e.getContext("2d");
        e.width = 16, e.height = 16, o.fillStyle = "white", o.fillRect(0, 0, 16, 16), t._WHITE = new t(BaseTexture.from(e)), removeAllHandlers(t._WHITE), removeAllHandlers(t._WHITE.baseTexture);
      }
      return t._WHITE;
    },
    enumerable: !1,
    configurable: !0
  }), t;
}(EventEmitter$4), RenderTexture = function(n) {
  __extends$q(t, n);
  function t(e, o) {
    var R = n.call(this, e, o) || this;
    return R.valid = !0, R.filterFrame = null, R.filterPoolKey = null, R.updateUvs(), R;
  }
  return Object.defineProperty(t.prototype, "framebuffer", {
    get: function() {
      return this.baseTexture.framebuffer;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(t.prototype, "multisample", {
    get: function() {
      return this.framebuffer.multisample;
    },
    set: function(e) {
      this.framebuffer.multisample = e;
    },
    enumerable: !1,
    configurable: !0
  }), t.prototype.resize = function(e, o, R) {
    R === void 0 && (R = !0);
    var N = this.baseTexture.resolution, M = Math.round(e * N) / N, D = Math.round(o * N) / N;
    this.valid = M > 0 && D > 0, this._frame.width = this.orig.width = M, this._frame.height = this.orig.height = D, R && this.baseTexture.resize(M, D), this.updateUvs();
  }, t.prototype.setResolution = function(e) {
    var o = this.baseTexture;
    o.resolution !== e && (o.setResolution(e), this.resize(o.width, o.height, !1));
  }, t.create = function(e) {
    for (var o = arguments, R = [], N = 1; N < arguments.length; N++)
      R[N - 1] = o[N];
    return typeof e == "number" && (deprecation$1("6.0.0", "Arguments (width, height, scaleMode, resolution) have been deprecated."), e = {
      width: e,
      height: R[0],
      scaleMode: R[1],
      resolution: R[2]
    }), new t(new BaseRenderTexture(e));
  }, t;
}(Texture), RenderTexturePool = function() {
  function n(t) {
    this.texturePool = {}, this.textureOptions = t || {}, this.enableFullScreen = !1, this._pixelsWidth = 0, this._pixelsHeight = 0;
  }
  return n.prototype.createTexture = function(t, e, o) {
    o === void 0 && (o = MSAA_QUALITY$5.NONE);
    var R = new BaseRenderTexture(Object.assign({
      width: t,
      height: e,
      resolution: 1,
      multisample: o
    }, this.textureOptions));
    return new RenderTexture(R);
  }, n.prototype.getOptimalTexture = function(t, e, o, R) {
    o === void 0 && (o = 1), R === void 0 && (R = MSAA_QUALITY$5.NONE);
    var N;
    t = Math.ceil(t * o - 1e-6), e = Math.ceil(e * o - 1e-6), !this.enableFullScreen || t !== this._pixelsWidth || e !== this._pixelsHeight ? (t = nextPow2(t), e = nextPow2(e), N = ((t & 65535) << 16 | e & 65535) >>> 0, R > 1 && (N += R * 4294967296)) : N = R > 1 ? -R : -1, this.texturePool[N] || (this.texturePool[N] = []);
    var M = this.texturePool[N].pop();
    return M || (M = this.createTexture(t, e, R)), M.filterPoolKey = N, M.setResolution(o), M;
  }, n.prototype.getFilterTexture = function(t, e, o) {
    var R = this.getOptimalTexture(t.width, t.height, e || t.resolution, o || MSAA_QUALITY$5.NONE);
    return R.filterFrame = t.filterFrame, R;
  }, n.prototype.returnTexture = function(t) {
    var e = t.filterPoolKey;
    t.filterFrame = null, this.texturePool[e].push(t);
  }, n.prototype.returnFilterTexture = function(t) {
    this.returnTexture(t);
  }, n.prototype.clear = function(t) {
    if (t = t !== !1, t)
      for (var e in this.texturePool) {
        var o = this.texturePool[e];
        if (o)
          for (var R = 0; R < o.length; R++)
            o[R].destroy(!0);
      }
    this.texturePool = {};
  }, n.prototype.setScreenSize = function(t) {
    if (!(t.width === this._pixelsWidth && t.height === this._pixelsHeight)) {
      this.enableFullScreen = t.width > 0 && t.height > 0;
      for (var e in this.texturePool)
        if (Number(e) < 0) {
          var o = this.texturePool[e];
          if (o)
            for (var R = 0; R < o.length; R++)
              o[R].destroy(!0);
          this.texturePool[e] = [];
        }
      this._pixelsWidth = t.width, this._pixelsHeight = t.height;
    }
  }, n.SCREEN_KEY = -1, n;
}(), Attribute = function() {
  function n(t, e, o, R, N, M, D) {
    e === void 0 && (e = 0), o === void 0 && (o = !1), R === void 0 && (R = TYPES$5.FLOAT), this.buffer = t, this.size = e, this.normalized = o, this.type = R, this.stride = N, this.start = M, this.instance = D;
  }
  return n.prototype.destroy = function() {
    this.buffer = null;
  }, n.from = function(t, e, o, R, N) {
    return new n(t, e, o, R, N);
  }, n;
}(), UID$4 = 0, Buffer$1 = function() {
  function n(t, e, o) {
    e === void 0 && (e = !0), o === void 0 && (o = !1), this.data = t || new Float32Array(1), this._glBuffers = {}, this._updateID = 0, this.index = o, this.static = e, this.id = UID$4++, this.disposeRunner = new Runner("disposeBuffer");
  }
  return n.prototype.update = function(t) {
    t instanceof Array && (t = new Float32Array(t)), this.data = t || this.data, this._updateID++;
  }, n.prototype.dispose = function() {
    this.disposeRunner.emit(this, !1);
  }, n.prototype.destroy = function() {
    this.dispose(), this.data = null;
  }, Object.defineProperty(n.prototype, "index", {
    get: function() {
      return this.type === BUFFER_TYPE$5.ELEMENT_ARRAY_BUFFER;
    },
    set: function(t) {
      this.type = t ? BUFFER_TYPE$5.ELEMENT_ARRAY_BUFFER : BUFFER_TYPE$5.ARRAY_BUFFER;
    },
    enumerable: !1,
    configurable: !0
  }), n.from = function(t) {
    return t instanceof Array && (t = new Float32Array(t)), new n(t);
  }, n;
}(), map$1 = {
  Float32Array,
  Uint32Array,
  Int32Array,
  Uint8Array
};
function interleaveTypedArrays(n, t) {
  for (var e = 0, o = 0, R = {}, N = 0; N < n.length; N++)
    o += t[N], e += n[N].length;
  for (var M = new ArrayBuffer(e * 4), D = null, L = 0, N = 0; N < n.length; N++) {
    var B = t[N], $ = n[N], k = getBufferType($);
    R[k] || (R[k] = new map$1[k](M)), D = R[k];
    for (var U = 0; U < $.length; U++) {
      var z = (U / B | 0) * o + L, X = U % B;
      D[z + X] = $[U];
    }
    L += B;
  }
  return new Float32Array(M);
}
var byteSizeMap$1 = { 5126: 4, 5123: 2, 5121: 1 }, UID$3 = 0, map$2 = {
  Float32Array,
  Uint32Array,
  Int32Array,
  Uint8Array,
  Uint16Array
}, Geometry = function() {
  function n(t, e) {
    t === void 0 && (t = []), e === void 0 && (e = {}), this.buffers = t, this.indexBuffer = null, this.attributes = e, this.glVertexArrayObjects = {}, this.id = UID$3++, this.instanced = !1, this.instanceCount = 1, this.disposeRunner = new Runner("disposeGeometry"), this.refCount = 0;
  }
  return n.prototype.addAttribute = function(t, e, o, R, N, M, D, L) {
    if (o === void 0 && (o = 0), R === void 0 && (R = !1), L === void 0 && (L = !1), !e)
      throw new Error("You must pass a buffer when creating an attribute");
    e instanceof Buffer$1 || (e instanceof Array && (e = new Float32Array(e)), e = new Buffer$1(e));
    var B = t.split("|");
    if (B.length > 1) {
      for (var $ = 0; $ < B.length; $++)
        this.addAttribute(B[$], e, o, R, N);
      return this;
    }
    var k = this.buffers.indexOf(e);
    return k === -1 && (this.buffers.push(e), k = this.buffers.length - 1), this.attributes[t] = new Attribute(k, o, R, N, M, D, L), this.instanced = this.instanced || L, this;
  }, n.prototype.getAttribute = function(t) {
    return this.attributes[t];
  }, n.prototype.getBuffer = function(t) {
    return this.buffers[this.getAttribute(t).buffer];
  }, n.prototype.addIndex = function(t) {
    return t instanceof Buffer$1 || (t instanceof Array && (t = new Uint16Array(t)), t = new Buffer$1(t)), t.type = BUFFER_TYPE$5.ELEMENT_ARRAY_BUFFER, this.indexBuffer = t, this.buffers.indexOf(t) === -1 && this.buffers.push(t), this;
  }, n.prototype.getIndex = function() {
    return this.indexBuffer;
  }, n.prototype.interleave = function() {
    if (this.buffers.length === 1 || this.buffers.length === 2 && this.indexBuffer)
      return this;
    var t = [], e = [], o = new Buffer$1(), R;
    for (R in this.attributes) {
      var N = this.attributes[R], M = this.buffers[N.buffer];
      t.push(M.data), e.push(N.size * byteSizeMap$1[N.type] / 4), N.buffer = 0;
    }
    for (o.data = interleaveTypedArrays(t, e), R = 0; R < this.buffers.length; R++)
      this.buffers[R] !== this.indexBuffer && this.buffers[R].destroy();
    return this.buffers = [o], this.indexBuffer && this.buffers.push(this.indexBuffer), this;
  }, n.prototype.getSize = function() {
    for (var t in this.attributes) {
      var e = this.attributes[t], o = this.buffers[e.buffer];
      return o.data.length / (e.stride / 4 || e.size);
    }
    return 0;
  }, n.prototype.dispose = function() {
    this.disposeRunner.emit(this, !1);
  }, n.prototype.destroy = function() {
    this.dispose(), this.buffers = null, this.indexBuffer = null, this.attributes = null;
  }, n.prototype.clone = function() {
    for (var t = new n(), e = 0; e < this.buffers.length; e++)
      t.buffers[e] = new Buffer$1(this.buffers[e].data.slice(0));
    for (var e in this.attributes) {
      var o = this.attributes[e];
      t.attributes[e] = new Attribute(o.buffer, o.size, o.normalized, o.type, o.stride, o.start, o.instance);
    }
    return this.indexBuffer && (t.indexBuffer = t.buffers[this.buffers.indexOf(this.indexBuffer)], t.indexBuffer.type = BUFFER_TYPE$5.ELEMENT_ARRAY_BUFFER), t;
  }, n.merge = function(t) {
    for (var e = new n(), o = [], R = [], N = [], M, D = 0; D < t.length; D++) {
      M = t[D];
      for (var L = 0; L < M.buffers.length; L++)
        R[L] = R[L] || 0, R[L] += M.buffers[L].data.length, N[L] = 0;
    }
    for (var D = 0; D < M.buffers.length; D++)
      o[D] = new map$2[getBufferType(M.buffers[D].data)](R[D]), e.buffers[D] = new Buffer$1(o[D]);
    for (var D = 0; D < t.length; D++) {
      M = t[D];
      for (var L = 0; L < M.buffers.length; L++)
        o[L].set(M.buffers[L].data, N[L]), N[L] += M.buffers[L].data.length;
    }
    if (e.attributes = M.attributes, M.indexBuffer) {
      e.indexBuffer = e.buffers[M.buffers.indexOf(M.indexBuffer)], e.indexBuffer.type = BUFFER_TYPE$5.ELEMENT_ARRAY_BUFFER;
      for (var B = 0, $ = 0, k = 0, U = 0, D = 0; D < M.buffers.length; D++)
        if (M.buffers[D] !== M.indexBuffer) {
          U = D;
          break;
        }
      for (var D in M.attributes) {
        var z = M.attributes[D];
        (z.buffer | 0) === U && ($ += z.size * byteSizeMap$1[z.type] / 4);
      }
      for (var D = 0; D < t.length; D++) {
        for (var X = t[D].indexBuffer.data, L = 0; L < X.length; L++)
          e.indexBuffer.data[L + k] += B;
        B += t[D].buffers[U].data.length / $, k += X.length;
      }
    }
    return e;
  }, n;
}(), Quad = function(n) {
  __extends$q(t, n);
  function t() {
    var e = n.call(this) || this;
    return e.addAttribute("aVertexPosition", new Float32Array([
      0,
      0,
      1,
      0,
      1,
      1,
      0,
      1
    ])).addIndex([0, 1, 3, 2]), e;
  }
  return t;
}(Geometry), QuadUv = function(n) {
  __extends$q(t, n);
  function t() {
    var e = n.call(this) || this;
    return e.vertices = new Float32Array([
      -1,
      -1,
      1,
      -1,
      1,
      1,
      -1,
      1
    ]), e.uvs = new Float32Array([
      0,
      0,
      1,
      0,
      1,
      1,
      0,
      1
    ]), e.vertexBuffer = new Buffer$1(e.vertices), e.uvBuffer = new Buffer$1(e.uvs), e.addAttribute("aVertexPosition", e.vertexBuffer).addAttribute("aTextureCoord", e.uvBuffer).addIndex([0, 1, 2, 0, 2, 3]), e;
  }
  return t.prototype.map = function(e, o) {
    var R = 0, N = 0;
    return this.uvs[0] = R, this.uvs[1] = N, this.uvs[2] = R + o.width / e.width, this.uvs[3] = N, this.uvs[4] = R + o.width / e.width, this.uvs[5] = N + o.height / e.height, this.uvs[6] = R, this.uvs[7] = N + o.height / e.height, R = o.x, N = o.y, this.vertices[0] = R, this.vertices[1] = N, this.vertices[2] = R + o.width, this.vertices[3] = N, this.vertices[4] = R + o.width, this.vertices[5] = N + o.height, this.vertices[6] = R, this.vertices[7] = N + o.height, this.invalidate(), this;
  }, t.prototype.invalidate = function() {
    return this.vertexBuffer._updateID++, this.uvBuffer._updateID++, this;
  }, t;
}(Geometry), UID$2 = 0, UniformGroup = function() {
  function n(t, e, o) {
    this.group = !0, this.syncUniforms = {}, this.dirtyId = 0, this.id = UID$2++, this.static = !!e, this.ubo = !!o, t instanceof Buffer$1 ? (this.buffer = t, this.buffer.type = BUFFER_TYPE$5.UNIFORM_BUFFER, this.autoManage = !1, this.ubo = !0) : (this.uniforms = t, this.ubo && (this.buffer = new Buffer$1(new Float32Array(1)), this.buffer.type = BUFFER_TYPE$5.UNIFORM_BUFFER, this.autoManage = !0));
  }
  return n.prototype.update = function() {
    this.dirtyId++, !this.autoManage && this.buffer && this.buffer.update();
  }, n.prototype.add = function(t, e, o) {
    if (!this.ubo)
      this.uniforms[t] = new n(e, o);
    else
      throw new Error("[UniformGroup] uniform groups in ubo mode cannot be modified, or have uniform groups nested in them");
  }, n.from = function(t, e, o) {
    return new n(t, e, o);
  }, n.uboFrom = function(t, e) {
    return new n(t, e != null ? e : !0, !0);
  }, n;
}(), FilterState = function() {
  function n() {
    this.renderTexture = null, this.target = null, this.legacy = !1, this.resolution = 1, this.multisample = MSAA_QUALITY$5.NONE, this.sourceFrame = new Rectangle(), this.destinationFrame = new Rectangle(), this.bindingSourceFrame = new Rectangle(), this.bindingDestinationFrame = new Rectangle(), this.filters = [], this.transform = null;
  }
  return n.prototype.clear = function() {
    this.target = null, this.filters = null, this.renderTexture = null;
  }, n;
}(), tempPoints = [new Point(), new Point(), new Point(), new Point()], tempMatrix$2 = new Matrix(), FilterSystem = function() {
  function n(t) {
    this.renderer = t, this.defaultFilterStack = [{}], this.texturePool = new RenderTexturePool(), this.texturePool.setScreenSize(t.view), this.statePool = [], this.quad = new Quad(), this.quadUv = new QuadUv(), this.tempRect = new Rectangle(), this.activeState = {}, this.globalUniforms = new UniformGroup({
      outputFrame: new Rectangle(),
      inputSize: new Float32Array(4),
      inputPixel: new Float32Array(4),
      inputClamp: new Float32Array(4),
      resolution: 1,
      filterArea: new Float32Array(4),
      filterClamp: new Float32Array(4)
    }, !0), this.forceClear = !1, this.useMaxPadding = !1;
  }
  return n.prototype.push = function(t, e) {
    for (var o, R, N = this.renderer, M = this.defaultFilterStack, D = this.statePool.pop() || new FilterState(), L = this.renderer.renderTexture, B = e[0].resolution, $ = e[0].multisample, k = e[0].padding, U = e[0].autoFit, z = (o = e[0].legacy) !== null && o !== void 0 ? o : !0, X = 1; X < e.length; X++) {
      var V = e[X];
      B = Math.min(B, V.resolution), $ = Math.min($, V.multisample), k = this.useMaxPadding ? Math.max(k, V.padding) : k + V.padding, U = U && V.autoFit, z = z || ((R = V.legacy) !== null && R !== void 0 ? R : !0);
    }
    M.length === 1 && (this.defaultFilterStack[0].renderTexture = L.current), M.push(D), D.resolution = B, D.multisample = $, D.legacy = z, D.target = t, D.sourceFrame.copyFrom(t.filterArea || t.getBounds(!0)), D.sourceFrame.pad(k);
    var W = this.tempRect.copyFrom(L.sourceFrame);
    N.projection.transform && this.transformAABB(tempMatrix$2.copyFrom(N.projection.transform).invert(), W), U ? (D.sourceFrame.fit(W), (D.sourceFrame.width <= 0 || D.sourceFrame.height <= 0) && (D.sourceFrame.width = 0, D.sourceFrame.height = 0)) : D.sourceFrame.intersects(W) || (D.sourceFrame.width = 0, D.sourceFrame.height = 0), this.roundFrame(D.sourceFrame, L.current ? L.current.resolution : N.resolution, L.sourceFrame, L.destinationFrame, N.projection.transform), D.renderTexture = this.getOptimalFilterTexture(D.sourceFrame.width, D.sourceFrame.height, B, $), D.filters = e, D.destinationFrame.width = D.renderTexture.width, D.destinationFrame.height = D.renderTexture.height;
    var Y = this.tempRect;
    Y.x = 0, Y.y = 0, Y.width = D.sourceFrame.width, Y.height = D.sourceFrame.height, D.renderTexture.filterFrame = D.sourceFrame, D.bindingSourceFrame.copyFrom(L.sourceFrame), D.bindingDestinationFrame.copyFrom(L.destinationFrame), D.transform = N.projection.transform, N.projection.transform = null, L.bind(D.renderTexture, D.sourceFrame, Y), N.framebuffer.clear(0, 0, 0, 0);
  }, n.prototype.pop = function() {
    var t = this.defaultFilterStack, e = t.pop(), o = e.filters;
    this.activeState = e;
    var R = this.globalUniforms.uniforms;
    R.outputFrame = e.sourceFrame, R.resolution = e.resolution;
    var N = R.inputSize, M = R.inputPixel, D = R.inputClamp;
    if (N[0] = e.destinationFrame.width, N[1] = e.destinationFrame.height, N[2] = 1 / N[0], N[3] = 1 / N[1], M[0] = Math.round(N[0] * e.resolution), M[1] = Math.round(N[1] * e.resolution), M[2] = 1 / M[0], M[3] = 1 / M[1], D[0] = 0.5 * M[2], D[1] = 0.5 * M[3], D[2] = e.sourceFrame.width * N[2] - 0.5 * M[2], D[3] = e.sourceFrame.height * N[3] - 0.5 * M[3], e.legacy) {
      var L = R.filterArea;
      L[0] = e.destinationFrame.width, L[1] = e.destinationFrame.height, L[2] = e.sourceFrame.x, L[3] = e.sourceFrame.y, R.filterClamp = R.inputClamp;
    }
    this.globalUniforms.update();
    var B = t[t.length - 1];
    if (this.renderer.framebuffer.blit(), o.length === 1)
      o[0].apply(this, e.renderTexture, B.renderTexture, CLEAR_MODES$5.BLEND, e), this.returnFilterTexture(e.renderTexture);
    else {
      var $ = e.renderTexture, k = this.getOptimalFilterTexture($.width, $.height, e.resolution);
      k.filterFrame = $.filterFrame;
      var U = 0;
      for (U = 0; U < o.length - 1; ++U) {
        U === 1 && e.multisample > 1 && (k = this.getOptimalFilterTexture($.width, $.height, e.resolution), k.filterFrame = $.filterFrame), o[U].apply(this, $, k, CLEAR_MODES$5.CLEAR, e);
        var z = $;
        $ = k, k = z;
      }
      o[U].apply(this, $, B.renderTexture, CLEAR_MODES$5.BLEND, e), U > 1 && e.multisample > 1 && this.returnFilterTexture(e.renderTexture), this.returnFilterTexture($), this.returnFilterTexture(k);
    }
    e.clear(), this.statePool.push(e);
  }, n.prototype.bindAndClear = function(t, e) {
    e === void 0 && (e = CLEAR_MODES$5.CLEAR);
    var o = this.renderer, R = o.renderTexture, N = o.state;
    if (t === this.defaultFilterStack[this.defaultFilterStack.length - 1].renderTexture ? this.renderer.projection.transform = this.activeState.transform : this.renderer.projection.transform = null, t && t.filterFrame) {
      var M = this.tempRect;
      M.x = 0, M.y = 0, M.width = t.filterFrame.width, M.height = t.filterFrame.height, R.bind(t, t.filterFrame, M);
    } else
      t !== this.defaultFilterStack[this.defaultFilterStack.length - 1].renderTexture ? R.bind(t) : this.renderer.renderTexture.bind(t, this.activeState.bindingSourceFrame, this.activeState.bindingDestinationFrame);
    var D = N.stateId & 1 || this.forceClear;
    (e === CLEAR_MODES$5.CLEAR || e === CLEAR_MODES$5.BLIT && D) && this.renderer.framebuffer.clear(0, 0, 0, 0);
  }, n.prototype.applyFilter = function(t, e, o, R) {
    var N = this.renderer;
    N.state.set(t.state), this.bindAndClear(o, R), t.uniforms.uSampler = e, t.uniforms.filterGlobals = this.globalUniforms, N.shader.bind(t), t.legacy = !!t.program.attributeData.aTextureCoord, t.legacy ? (this.quadUv.map(e._frame, e.filterFrame), N.geometry.bind(this.quadUv), N.geometry.draw(DRAW_MODES$5.TRIANGLES)) : (N.geometry.bind(this.quad), N.geometry.draw(DRAW_MODES$5.TRIANGLE_STRIP));
  }, n.prototype.calculateSpriteMatrix = function(t, e) {
    var o = this.activeState, R = o.sourceFrame, N = o.destinationFrame, M = e._texture.orig, D = t.set(N.width, 0, 0, N.height, R.x, R.y), L = e.worldTransform.copyTo(Matrix.TEMP_MATRIX);
    return L.invert(), D.prepend(L), D.scale(1 / M.width, 1 / M.height), D.translate(e.anchor.x, e.anchor.y), D;
  }, n.prototype.destroy = function() {
    this.renderer = null, this.texturePool.clear(!1);
  }, n.prototype.getOptimalFilterTexture = function(t, e, o, R) {
    return o === void 0 && (o = 1), R === void 0 && (R = MSAA_QUALITY$5.NONE), this.texturePool.getOptimalTexture(t, e, o, R);
  }, n.prototype.getFilterTexture = function(t, e, o) {
    if (typeof t == "number") {
      var R = t;
      t = e, e = R;
    }
    t = t || this.activeState.renderTexture;
    var N = this.texturePool.getOptimalTexture(t.width, t.height, e || t.resolution, o || MSAA_QUALITY$5.NONE);
    return N.filterFrame = t.filterFrame, N;
  }, n.prototype.returnFilterTexture = function(t) {
    this.texturePool.returnTexture(t);
  }, n.prototype.emptyPool = function() {
    this.texturePool.clear(!0);
  }, n.prototype.resize = function() {
    this.texturePool.setScreenSize(this.renderer.view);
  }, n.prototype.transformAABB = function(t, e) {
    var o = tempPoints[0], R = tempPoints[1], N = tempPoints[2], M = tempPoints[3];
    o.set(e.left, e.top), R.set(e.left, e.bottom), N.set(e.right, e.top), M.set(e.right, e.bottom), t.apply(o, o), t.apply(R, R), t.apply(N, N), t.apply(M, M);
    var D = Math.min(o.x, R.x, N.x, M.x), L = Math.min(o.y, R.y, N.y, M.y), B = Math.max(o.x, R.x, N.x, M.x), $ = Math.max(o.y, R.y, N.y, M.y);
    e.x = D, e.y = L, e.width = B - D, e.height = $ - L;
  }, n.prototype.roundFrame = function(t, e, o, R, N) {
    if (!(t.width <= 0 || t.height <= 0 || o.width <= 0 || o.height <= 0)) {
      if (N) {
        var M = N.a, D = N.b, L = N.c, B = N.d;
        if ((Math.abs(D) > 1e-4 || Math.abs(L) > 1e-4) && (Math.abs(M) > 1e-4 || Math.abs(B) > 1e-4))
          return;
      }
      N = N ? tempMatrix$2.copyFrom(N) : tempMatrix$2.identity(), N.translate(-o.x, -o.y).scale(R.width / o.width, R.height / o.height).translate(R.x, R.y), this.transformAABB(N, t), t.ceil(e), this.transformAABB(N.invert(), t);
    }
  }, n;
}(), ObjectRenderer = function() {
  function n(t) {
    this.renderer = t;
  }
  return n.prototype.flush = function() {
  }, n.prototype.destroy = function() {
    this.renderer = null;
  }, n.prototype.start = function() {
  }, n.prototype.stop = function() {
    this.flush();
  }, n.prototype.render = function(t) {
  }, n;
}(), BatchSystem = function() {
  function n(t) {
    this.renderer = t, this.emptyRenderer = new ObjectRenderer(t), this.currentRenderer = this.emptyRenderer;
  }
  return n.prototype.setObjectRenderer = function(t) {
    this.currentRenderer !== t && (this.currentRenderer.stop(), this.currentRenderer = t, this.currentRenderer.start());
  }, n.prototype.flush = function() {
    this.setObjectRenderer(this.emptyRenderer);
  }, n.prototype.reset = function() {
    this.setObjectRenderer(this.emptyRenderer);
  }, n.prototype.copyBoundTextures = function(t, e) {
    for (var o = this.renderer.texture.boundTextures, R = e - 1; R >= 0; --R)
      t[R] = o[R] || null, t[R] && (t[R]._batchLocation = R);
  }, n.prototype.boundArray = function(t, e, o, R) {
    for (var N = t.elements, M = t.ids, D = t.count, L = 0, B = 0; B < D; B++) {
      var $ = N[B], k = $._batchLocation;
      if (k >= 0 && k < R && e[k] === $) {
        M[B] = k;
        continue;
      }
      for (; L < R; ) {
        var U = e[L];
        if (U && U._batchEnabled === o && U._batchLocation === L) {
          L++;
          continue;
        }
        M[B] = L, $._batchLocation = L, e[L] = $;
        break;
      }
    }
  }, n.prototype.destroy = function() {
    this.renderer = null;
  }, n;
}(), CONTEXT_UID_COUNTER = 0, ContextSystem = function() {
  function n(t) {
    this.renderer = t, this.webGLVersion = 1, this.extensions = {}, this.supports = {
      uint32Indices: !1
    }, this.handleContextLost = this.handleContextLost.bind(this), this.handleContextRestored = this.handleContextRestored.bind(this), t.view.addEventListener("webglcontextlost", this.handleContextLost, !1), t.view.addEventListener("webglcontextrestored", this.handleContextRestored, !1);
  }
  return Object.defineProperty(n.prototype, "isLost", {
    get: function() {
      return !this.gl || this.gl.isContextLost();
    },
    enumerable: !1,
    configurable: !0
  }), n.prototype.contextChange = function(t) {
    this.gl = t, this.renderer.gl = t, this.renderer.CONTEXT_UID = CONTEXT_UID_COUNTER++, t.isContextLost() && t.getExtension("WEBGL_lose_context") && t.getExtension("WEBGL_lose_context").restoreContext();
  }, n.prototype.initFromContext = function(t) {
    this.gl = t, this.validateContext(t), this.renderer.gl = t, this.renderer.CONTEXT_UID = CONTEXT_UID_COUNTER++, this.renderer.runners.contextChange.emit(t);
  }, n.prototype.initFromOptions = function(t) {
    var e = this.createContext(this.renderer.view, t);
    this.initFromContext(e);
  }, n.prototype.createContext = function(t, e) {
    var o;
    if (settings$1.PREFER_ENV >= ENV$5.WEBGL2 && (o = t.getContext("webgl2", e)), o)
      this.webGLVersion = 2;
    else if (this.webGLVersion = 1, o = t.getContext("webgl", e) || t.getContext("experimental-webgl", e), !o)
      throw new Error("This browser does not support WebGL. Try using the canvas renderer");
    return this.gl = o, this.getExtensions(), this.gl;
  }, n.prototype.getExtensions = function() {
    var t = this.gl, e = {
      anisotropicFiltering: t.getExtension("EXT_texture_filter_anisotropic"),
      floatTextureLinear: t.getExtension("OES_texture_float_linear"),
      s3tc: t.getExtension("WEBGL_compressed_texture_s3tc"),
      s3tc_sRGB: t.getExtension("WEBGL_compressed_texture_s3tc_srgb"),
      etc: t.getExtension("WEBGL_compressed_texture_etc"),
      etc1: t.getExtension("WEBGL_compressed_texture_etc1"),
      pvrtc: t.getExtension("WEBGL_compressed_texture_pvrtc") || t.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc"),
      atc: t.getExtension("WEBGL_compressed_texture_atc"),
      astc: t.getExtension("WEBGL_compressed_texture_astc")
    };
    this.webGLVersion === 1 ? Object.assign(this.extensions, e, {
      drawBuffers: t.getExtension("WEBGL_draw_buffers"),
      depthTexture: t.getExtension("WEBGL_depth_texture"),
      loseContext: t.getExtension("WEBGL_lose_context"),
      vertexArrayObject: t.getExtension("OES_vertex_array_object") || t.getExtension("MOZ_OES_vertex_array_object") || t.getExtension("WEBKIT_OES_vertex_array_object"),
      uint32ElementIndex: t.getExtension("OES_element_index_uint"),
      floatTexture: t.getExtension("OES_texture_float"),
      floatTextureLinear: t.getExtension("OES_texture_float_linear"),
      textureHalfFloat: t.getExtension("OES_texture_half_float"),
      textureHalfFloatLinear: t.getExtension("OES_texture_half_float_linear")
    }) : this.webGLVersion === 2 && Object.assign(this.extensions, e, {
      colorBufferFloat: t.getExtension("EXT_color_buffer_float")
    });
  }, n.prototype.handleContextLost = function(t) {
    t.preventDefault();
  }, n.prototype.handleContextRestored = function() {
    this.renderer.runners.contextChange.emit(this.gl);
  }, n.prototype.destroy = function() {
    var t = this.renderer.view;
    this.renderer = null, t.removeEventListener("webglcontextlost", this.handleContextLost), t.removeEventListener("webglcontextrestored", this.handleContextRestored), this.gl.useProgram(null), this.extensions.loseContext && this.extensions.loseContext.loseContext();
  }, n.prototype.postrender = function() {
    this.renderer.renderingToScreen && this.gl.flush();
  }, n.prototype.validateContext = function(t) {
    var e = t.getContextAttributes(), o = "WebGL2RenderingContext" in globalThis && t instanceof globalThis.WebGL2RenderingContext;
    o && (this.webGLVersion = 2), e && !e.stencil && console.warn("Provided WebGL context does not have a stencil buffer, masks may not render correctly");
    var R = o || !!t.getExtension("OES_element_index_uint");
    this.supports.uint32Indices = R, R || console.warn("Provided WebGL context does not support 32 index buffer, complex graphics may not render correctly");
  }, n;
}(), GLFramebuffer = function() {
  function n(t) {
    this.framebuffer = t, this.stencil = null, this.dirtyId = -1, this.dirtyFormat = -1, this.dirtySize = -1, this.multisample = MSAA_QUALITY$5.NONE, this.msaaBuffer = null, this.blitFramebuffer = null, this.mipLevel = 0;
  }
  return n;
}(), tempRectangle = new Rectangle(), FramebufferSystem = function() {
  function n(t) {
    this.renderer = t, this.managedFramebuffers = [], this.unknownFramebuffer = new Framebuffer(10, 10), this.msaaSamples = null;
  }
  return n.prototype.contextChange = function() {
    var t = this.gl = this.renderer.gl;
    if (this.CONTEXT_UID = this.renderer.CONTEXT_UID, this.current = this.unknownFramebuffer, this.viewport = new Rectangle(), this.hasMRT = !0, this.writeDepthTexture = !0, this.disposeAll(!0), this.renderer.context.webGLVersion === 1) {
      var e = this.renderer.context.extensions.drawBuffers, o = this.renderer.context.extensions.depthTexture;
      settings$1.PREFER_ENV === ENV$5.WEBGL_LEGACY && (e = null, o = null), e ? t.drawBuffers = function(R) {
        return e.drawBuffersWEBGL(R);
      } : (this.hasMRT = !1, t.drawBuffers = function() {
      }), o || (this.writeDepthTexture = !1);
    } else
      this.msaaSamples = t.getInternalformatParameter(t.RENDERBUFFER, t.RGBA8, t.SAMPLES);
  }, n.prototype.bind = function(t, e, o) {
    o === void 0 && (o = 0);
    var R = this.gl;
    if (t) {
      var N = t.glFramebuffers[this.CONTEXT_UID] || this.initFramebuffer(t);
      this.current !== t && (this.current = t, R.bindFramebuffer(R.FRAMEBUFFER, N.framebuffer)), N.mipLevel !== o && (t.dirtyId++, t.dirtyFormat++, N.mipLevel = o), N.dirtyId !== t.dirtyId && (N.dirtyId = t.dirtyId, N.dirtyFormat !== t.dirtyFormat ? (N.dirtyFormat = t.dirtyFormat, N.dirtySize = t.dirtySize, this.updateFramebuffer(t, o)) : N.dirtySize !== t.dirtySize && (N.dirtySize = t.dirtySize, this.resizeFramebuffer(t)));
      for (var M = 0; M < t.colorTextures.length; M++) {
        var D = t.colorTextures[M];
        this.renderer.texture.unbind(D.parentTextureArray || D);
      }
      if (t.depthTexture && this.renderer.texture.unbind(t.depthTexture), e) {
        var L = e.width >> o, B = e.height >> o, $ = L / e.width;
        this.setViewport(e.x * $, e.y * $, L, B);
      } else {
        var L = t.width >> o, B = t.height >> o;
        this.setViewport(0, 0, L, B);
      }
    } else
      this.current && (this.current = null, R.bindFramebuffer(R.FRAMEBUFFER, null)), e ? this.setViewport(e.x, e.y, e.width, e.height) : this.setViewport(0, 0, this.renderer.width, this.renderer.height);
  }, n.prototype.setViewport = function(t, e, o, R) {
    var N = this.viewport;
    t = Math.round(t), e = Math.round(e), o = Math.round(o), R = Math.round(R), (N.width !== o || N.height !== R || N.x !== t || N.y !== e) && (N.x = t, N.y = e, N.width = o, N.height = R, this.gl.viewport(t, e, o, R));
  }, Object.defineProperty(n.prototype, "size", {
    get: function() {
      return this.current ? { x: 0, y: 0, width: this.current.width, height: this.current.height } : { x: 0, y: 0, width: this.renderer.width, height: this.renderer.height };
    },
    enumerable: !1,
    configurable: !0
  }), n.prototype.clear = function(t, e, o, R, N) {
    N === void 0 && (N = BUFFER_BITS$5.COLOR | BUFFER_BITS$5.DEPTH);
    var M = this.gl;
    M.clearColor(t, e, o, R), M.clear(N);
  }, n.prototype.initFramebuffer = function(t) {
    var e = this.gl, o = new GLFramebuffer(e.createFramebuffer());
    return o.multisample = this.detectSamples(t.multisample), t.glFramebuffers[this.CONTEXT_UID] = o, this.managedFramebuffers.push(t), t.disposeRunner.add(this), o;
  }, n.prototype.resizeFramebuffer = function(t) {
    var e = this.gl, o = t.glFramebuffers[this.CONTEXT_UID];
    o.msaaBuffer && (e.bindRenderbuffer(e.RENDERBUFFER, o.msaaBuffer), e.renderbufferStorageMultisample(e.RENDERBUFFER, o.multisample, e.RGBA8, t.width, t.height)), o.stencil && (e.bindRenderbuffer(e.RENDERBUFFER, o.stencil), o.msaaBuffer ? e.renderbufferStorageMultisample(e.RENDERBUFFER, o.multisample, e.DEPTH24_STENCIL8, t.width, t.height) : e.renderbufferStorage(e.RENDERBUFFER, e.DEPTH_STENCIL, t.width, t.height));
    var R = t.colorTextures, N = R.length;
    e.drawBuffers || (N = Math.min(N, 1));
    for (var M = 0; M < N; M++) {
      var D = R[M], L = D.parentTextureArray || D;
      this.renderer.texture.bind(L, 0);
    }
    t.depthTexture && this.writeDepthTexture && this.renderer.texture.bind(t.depthTexture, 0);
  }, n.prototype.updateFramebuffer = function(t, e) {
    var o = this.gl, R = t.glFramebuffers[this.CONTEXT_UID], N = t.colorTextures, M = N.length;
    o.drawBuffers || (M = Math.min(M, 1)), R.multisample > 1 && this.canMultisampleFramebuffer(t) ? (R.msaaBuffer = R.msaaBuffer || o.createRenderbuffer(), o.bindRenderbuffer(o.RENDERBUFFER, R.msaaBuffer), o.renderbufferStorageMultisample(o.RENDERBUFFER, R.multisample, o.RGBA8, t.width, t.height), o.framebufferRenderbuffer(o.FRAMEBUFFER, o.COLOR_ATTACHMENT0, o.RENDERBUFFER, R.msaaBuffer)) : R.msaaBuffer && (o.deleteRenderbuffer(R.msaaBuffer), R.msaaBuffer = null, R.blitFramebuffer && (R.blitFramebuffer.dispose(), R.blitFramebuffer = null));
    for (var D = [], L = 0; L < M; L++) {
      var B = N[L], $ = B.parentTextureArray || B;
      this.renderer.texture.bind($, 0), !(L === 0 && R.msaaBuffer) && (o.framebufferTexture2D(o.FRAMEBUFFER, o.COLOR_ATTACHMENT0 + L, B.target, $._glTextures[this.CONTEXT_UID].texture, e), D.push(o.COLOR_ATTACHMENT0 + L));
    }
    if (D.length > 1 && o.drawBuffers(D), t.depthTexture) {
      var k = this.writeDepthTexture;
      if (k) {
        var U = t.depthTexture;
        this.renderer.texture.bind(U, 0), o.framebufferTexture2D(o.FRAMEBUFFER, o.DEPTH_ATTACHMENT, o.TEXTURE_2D, U._glTextures[this.CONTEXT_UID].texture, e);
      }
    }
    (t.stencil || t.depth) && !(t.depthTexture && this.writeDepthTexture) ? (R.stencil = R.stencil || o.createRenderbuffer(), o.bindRenderbuffer(o.RENDERBUFFER, R.stencil), R.msaaBuffer ? o.renderbufferStorageMultisample(o.RENDERBUFFER, R.multisample, o.DEPTH24_STENCIL8, t.width, t.height) : o.renderbufferStorage(o.RENDERBUFFER, o.DEPTH_STENCIL, t.width, t.height), o.framebufferRenderbuffer(o.FRAMEBUFFER, o.DEPTH_STENCIL_ATTACHMENT, o.RENDERBUFFER, R.stencil)) : R.stencil && (o.deleteRenderbuffer(R.stencil), R.stencil = null);
  }, n.prototype.canMultisampleFramebuffer = function(t) {
    return this.renderer.context.webGLVersion !== 1 && t.colorTextures.length <= 1 && !t.depthTexture;
  }, n.prototype.detectSamples = function(t) {
    var e = this.msaaSamples, o = MSAA_QUALITY$5.NONE;
    if (t <= 1 || e === null)
      return o;
    for (var R = 0; R < e.length; R++)
      if (e[R] <= t) {
        o = e[R];
        break;
      }
    return o === 1 && (o = MSAA_QUALITY$5.NONE), o;
  }, n.prototype.blit = function(t, e, o) {
    var R = this, N = R.current, M = R.renderer, D = R.gl, L = R.CONTEXT_UID;
    if (M.context.webGLVersion === 2 && !!N) {
      var B = N.glFramebuffers[L];
      if (!!B) {
        if (!t) {
          if (!B.msaaBuffer)
            return;
          var $ = N.colorTextures[0];
          if (!$)
            return;
          B.blitFramebuffer || (B.blitFramebuffer = new Framebuffer(N.width, N.height), B.blitFramebuffer.addColorTexture(0, $)), t = B.blitFramebuffer, t.colorTextures[0] !== $ && (t.colorTextures[0] = $, t.dirtyId++, t.dirtyFormat++), (t.width !== N.width || t.height !== N.height) && (t.width = N.width, t.height = N.height, t.dirtyId++, t.dirtySize++);
        }
        e || (e = tempRectangle, e.width = N.width, e.height = N.height), o || (o = e);
        var k = e.width === o.width && e.height === o.height;
        this.bind(t), D.bindFramebuffer(D.READ_FRAMEBUFFER, B.framebuffer), D.blitFramebuffer(e.left, e.top, e.right, e.bottom, o.left, o.top, o.right, o.bottom, D.COLOR_BUFFER_BIT, k ? D.NEAREST : D.LINEAR);
      }
    }
  }, n.prototype.disposeFramebuffer = function(t, e) {
    var o = t.glFramebuffers[this.CONTEXT_UID], R = this.gl;
    if (!!o) {
      delete t.glFramebuffers[this.CONTEXT_UID];
      var N = this.managedFramebuffers.indexOf(t);
      N >= 0 && this.managedFramebuffers.splice(N, 1), t.disposeRunner.remove(this), e || (R.deleteFramebuffer(o.framebuffer), o.msaaBuffer && R.deleteRenderbuffer(o.msaaBuffer), o.stencil && R.deleteRenderbuffer(o.stencil)), o.blitFramebuffer && o.blitFramebuffer.dispose();
    }
  }, n.prototype.disposeAll = function(t) {
    var e = this.managedFramebuffers;
    this.managedFramebuffers = [];
    for (var o = 0; o < e.length; o++)
      this.disposeFramebuffer(e[o], t);
  }, n.prototype.forceStencil = function() {
    var t = this.current;
    if (!!t) {
      var e = t.glFramebuffers[this.CONTEXT_UID];
      if (!(!e || e.stencil)) {
        t.stencil = !0;
        var o = t.width, R = t.height, N = this.gl, M = N.createRenderbuffer();
        N.bindRenderbuffer(N.RENDERBUFFER, M), e.msaaBuffer ? N.renderbufferStorageMultisample(N.RENDERBUFFER, e.multisample, N.DEPTH24_STENCIL8, o, R) : N.renderbufferStorage(N.RENDERBUFFER, N.DEPTH_STENCIL, o, R), e.stencil = M, N.framebufferRenderbuffer(N.FRAMEBUFFER, N.DEPTH_STENCIL_ATTACHMENT, N.RENDERBUFFER, M);
      }
    }
  }, n.prototype.reset = function() {
    this.current = this.unknownFramebuffer, this.viewport = new Rectangle();
  }, n.prototype.destroy = function() {
    this.renderer = null;
  }, n;
}(), byteSizeMap = { 5126: 4, 5123: 2, 5121: 1 }, GeometrySystem = function() {
  function n(t) {
    this.renderer = t, this._activeGeometry = null, this._activeVao = null, this.hasVao = !0, this.hasInstance = !0, this.canUseUInt32ElementIndex = !1, this.managedGeometries = {};
  }
  return n.prototype.contextChange = function() {
    this.disposeAll(!0);
    var t = this.gl = this.renderer.gl, e = this.renderer.context;
    if (this.CONTEXT_UID = this.renderer.CONTEXT_UID, e.webGLVersion !== 2) {
      var o = this.renderer.context.extensions.vertexArrayObject;
      settings$1.PREFER_ENV === ENV$5.WEBGL_LEGACY && (o = null), o ? (t.createVertexArray = function() {
        return o.createVertexArrayOES();
      }, t.bindVertexArray = function(N) {
        return o.bindVertexArrayOES(N);
      }, t.deleteVertexArray = function(N) {
        return o.deleteVertexArrayOES(N);
      }) : (this.hasVao = !1, t.createVertexArray = function() {
        return null;
      }, t.bindVertexArray = function() {
        return null;
      }, t.deleteVertexArray = function() {
        return null;
      });
    }
    if (e.webGLVersion !== 2) {
      var R = t.getExtension("ANGLE_instanced_arrays");
      R ? (t.vertexAttribDivisor = function(N, M) {
        return R.vertexAttribDivisorANGLE(N, M);
      }, t.drawElementsInstanced = function(N, M, D, L, B) {
        return R.drawElementsInstancedANGLE(N, M, D, L, B);
      }, t.drawArraysInstanced = function(N, M, D, L) {
        return R.drawArraysInstancedANGLE(N, M, D, L);
      }) : this.hasInstance = !1;
    }
    this.canUseUInt32ElementIndex = e.webGLVersion === 2 || !!e.extensions.uint32ElementIndex;
  }, n.prototype.bind = function(t, e) {
    e = e || this.renderer.shader.shader;
    var o = this.gl, R = t.glVertexArrayObjects[this.CONTEXT_UID], N = !1;
    R || (this.managedGeometries[t.id] = t, t.disposeRunner.add(this), t.glVertexArrayObjects[this.CONTEXT_UID] = R = {}, N = !0);
    var M = R[e.program.id] || this.initGeometryVao(t, e, N);
    this._activeGeometry = t, this._activeVao !== M && (this._activeVao = M, this.hasVao ? o.bindVertexArray(M) : this.activateVao(t, e.program)), this.updateBuffers();
  }, n.prototype.reset = function() {
    this.unbind();
  }, n.prototype.updateBuffers = function() {
    for (var t = this._activeGeometry, e = this.renderer.buffer, o = 0; o < t.buffers.length; o++) {
      var R = t.buffers[o];
      e.update(R);
    }
  }, n.prototype.checkCompatibility = function(t, e) {
    var o = t.attributes, R = e.attributeData;
    for (var N in R)
      if (!o[N])
        throw new Error('shader and geometry incompatible, geometry missing the "' + N + '" attribute');
  }, n.prototype.getSignature = function(t, e) {
    var o = t.attributes, R = e.attributeData, N = ["g", t.id];
    for (var M in o)
      R[M] && N.push(M, R[M].location);
    return N.join("-");
  }, n.prototype.initGeometryVao = function(t, e, o) {
    o === void 0 && (o = !0);
    var R = this.gl, N = this.CONTEXT_UID, M = this.renderer.buffer, D = e.program;
    D.glPrograms[N] || this.renderer.shader.generateProgram(e), this.checkCompatibility(t, D);
    var L = this.getSignature(t, D), B = t.glVertexArrayObjects[this.CONTEXT_UID], $ = B[L];
    if ($)
      return B[D.id] = $, $;
    var k = t.buffers, U = t.attributes, z = {}, X = {};
    for (var V in k)
      z[V] = 0, X[V] = 0;
    for (var V in U)
      !U[V].size && D.attributeData[V] ? U[V].size = D.attributeData[V].size : U[V].size || console.warn("PIXI Geometry attribute '" + V + "' size cannot be determined (likely the bound shader does not have the attribute)"), z[U[V].buffer] += U[V].size * byteSizeMap[U[V].type];
    for (var V in U) {
      var W = U[V], Y = W.size;
      W.stride === void 0 && (z[W.buffer] === Y * byteSizeMap[W.type] ? W.stride = 0 : W.stride = z[W.buffer]), W.start === void 0 && (W.start = X[W.buffer], X[W.buffer] += Y * byteSizeMap[W.type]);
    }
    $ = R.createVertexArray(), R.bindVertexArray($);
    for (var q = 0; q < k.length; q++) {
      var Z = k[q];
      M.bind(Z), o && Z._glBuffers[N].refCount++;
    }
    return this.activateVao(t, D), this._activeVao = $, B[D.id] = $, B[L] = $, $;
  }, n.prototype.disposeGeometry = function(t, e) {
    var o;
    if (!!this.managedGeometries[t.id]) {
      delete this.managedGeometries[t.id];
      var R = t.glVertexArrayObjects[this.CONTEXT_UID], N = this.gl, M = t.buffers, D = (o = this.renderer) === null || o === void 0 ? void 0 : o.buffer;
      if (t.disposeRunner.remove(this), !!R) {
        if (D)
          for (var L = 0; L < M.length; L++) {
            var B = M[L]._glBuffers[this.CONTEXT_UID];
            B && (B.refCount--, B.refCount === 0 && !e && D.dispose(M[L], e));
          }
        if (!e) {
          for (var $ in R)
            if ($[0] === "g") {
              var k = R[$];
              this._activeVao === k && this.unbind(), N.deleteVertexArray(k);
            }
        }
        delete t.glVertexArrayObjects[this.CONTEXT_UID];
      }
    }
  }, n.prototype.disposeAll = function(t) {
    for (var e = Object.keys(this.managedGeometries), o = 0; o < e.length; o++)
      this.disposeGeometry(this.managedGeometries[e[o]], t);
  }, n.prototype.activateVao = function(t, e) {
    var o = this.gl, R = this.CONTEXT_UID, N = this.renderer.buffer, M = t.buffers, D = t.attributes;
    t.indexBuffer && N.bind(t.indexBuffer);
    var L = null;
    for (var B in D) {
      var $ = D[B], k = M[$.buffer], U = k._glBuffers[R];
      if (e.attributeData[B]) {
        L !== U && (N.bind(k), L = U);
        var z = e.attributeData[B].location;
        if (o.enableVertexAttribArray(z), o.vertexAttribPointer(z, $.size, $.type || o.FLOAT, $.normalized, $.stride, $.start), $.instance)
          if (this.hasInstance)
            o.vertexAttribDivisor(z, 1);
          else
            throw new Error("geometry error, GPU Instancing is not supported on this device");
      }
    }
  }, n.prototype.draw = function(t, e, o, R) {
    var N = this.gl, M = this._activeGeometry;
    if (M.indexBuffer) {
      var D = M.indexBuffer.data.BYTES_PER_ELEMENT, L = D === 2 ? N.UNSIGNED_SHORT : N.UNSIGNED_INT;
      D === 2 || D === 4 && this.canUseUInt32ElementIndex ? M.instanced ? N.drawElementsInstanced(t, e || M.indexBuffer.data.length, L, (o || 0) * D, R || 1) : N.drawElements(t, e || M.indexBuffer.data.length, L, (o || 0) * D) : console.warn("unsupported index buffer type: uint32");
    } else
      M.instanced ? N.drawArraysInstanced(t, o, e || M.getSize(), R || 1) : N.drawArrays(t, o, e || M.getSize());
    return this;
  }, n.prototype.unbind = function() {
    this.gl.bindVertexArray(null), this._activeVao = null, this._activeGeometry = null;
  }, n.prototype.destroy = function() {
    this.renderer = null;
  }, n;
}(), MaskData = function() {
  function n(t) {
    t === void 0 && (t = null), this.type = MASK_TYPES$5.NONE, this.autoDetect = !0, this.maskObject = t || null, this.pooled = !1, this.isMaskData = !0, this.resolution = null, this.multisample = settings$1.FILTER_MULTISAMPLE, this.enabled = !0, this.colorMask = 15, this._filters = null, this._stencilCounter = 0, this._scissorCounter = 0, this._scissorRect = null, this._scissorRectLocal = null, this._colorMask = 15, this._target = null;
  }
  return Object.defineProperty(n.prototype, "filter", {
    get: function() {
      return this._filters ? this._filters[0] : null;
    },
    set: function(t) {
      t ? this._filters ? this._filters[0] = t : this._filters = [t] : this._filters = null;
    },
    enumerable: !1,
    configurable: !0
  }), n.prototype.reset = function() {
    this.pooled && (this.maskObject = null, this.type = MASK_TYPES$5.NONE, this.autoDetect = !0), this._target = null, this._scissorRectLocal = null;
  }, n.prototype.copyCountersOrReset = function(t) {
    t ? (this._stencilCounter = t._stencilCounter, this._scissorCounter = t._scissorCounter, this._scissorRect = t._scissorRect) : (this._stencilCounter = 0, this._scissorCounter = 0, this._scissorRect = null);
  }, n;
}();
function compileShader(n, t, e) {
  var o = n.createShader(t);
  return n.shaderSource(o, e), n.compileShader(o), o;
}
function logPrettyShaderError(n, t) {
  var e = n.getShaderSource(t).split(`
`).map(function(B, $) {
    return $ + ": " + B;
  }), o = n.getShaderInfoLog(t), R = o.split(`
`), N = {}, M = R.map(function(B) {
    return parseFloat(B.replace(/^ERROR\: 0\:([\d]+)\:.*$/, "$1"));
  }).filter(function(B) {
    return B && !N[B] ? (N[B] = !0, !0) : !1;
  }), D = [""];
  M.forEach(function(B) {
    e[B - 1] = "%c" + e[B - 1] + "%c", D.push("background: #FF0000; color:#FFFFFF; font-size: 10px", "font-size: 10px");
  });
  var L = e.join(`
`);
  D[0] = L, console.error(o), console.groupCollapsed("click to view full shader code"), console.warn.apply(console, D), console.groupEnd();
}
function logProgramError(n, t, e, o) {
  n.getProgramParameter(t, n.LINK_STATUS) || (n.getShaderParameter(e, n.COMPILE_STATUS) || logPrettyShaderError(n, e), n.getShaderParameter(o, n.COMPILE_STATUS) || logPrettyShaderError(n, o), console.error("PixiJS Error: Could not initialize shader."), n.getProgramInfoLog(t) !== "" && console.warn("PixiJS Warning: gl.getProgramInfoLog()", n.getProgramInfoLog(t)));
}
function booleanArray(n) {
  for (var t = new Array(n), e = 0; e < t.length; e++)
    t[e] = !1;
  return t;
}
function defaultValue(n, t) {
  switch (n) {
    case "float":
      return 0;
    case "vec2":
      return new Float32Array(2 * t);
    case "vec3":
      return new Float32Array(3 * t);
    case "vec4":
      return new Float32Array(4 * t);
    case "int":
    case "uint":
    case "sampler2D":
    case "sampler2DArray":
      return 0;
    case "ivec2":
      return new Int32Array(2 * t);
    case "ivec3":
      return new Int32Array(3 * t);
    case "ivec4":
      return new Int32Array(4 * t);
    case "uvec2":
      return new Uint32Array(2 * t);
    case "uvec3":
      return new Uint32Array(3 * t);
    case "uvec4":
      return new Uint32Array(4 * t);
    case "bool":
      return !1;
    case "bvec2":
      return booleanArray(2 * t);
    case "bvec3":
      return booleanArray(3 * t);
    case "bvec4":
      return booleanArray(4 * t);
    case "mat2":
      return new Float32Array([
        1,
        0,
        0,
        1
      ]);
    case "mat3":
      return new Float32Array([
        1,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        1
      ]);
    case "mat4":
      return new Float32Array([
        1,
        0,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        0,
        1
      ]);
  }
  return null;
}
var unknownContext = {}, context = unknownContext;
function getTestContext() {
  if (context === unknownContext || context && context.isContextLost()) {
    var n = settings$1.ADAPTER.createCanvas(), t = void 0;
    settings$1.PREFER_ENV >= ENV$5.WEBGL2 && (t = n.getContext("webgl2", {})), t || (t = n.getContext("webgl", {}) || n.getContext("experimental-webgl", {}), t ? t.getExtension("WEBGL_draw_buffers") : t = null), context = t;
  }
  return context;
}
var maxFragmentPrecision;
function getMaxFragmentPrecision() {
  if (!maxFragmentPrecision) {
    maxFragmentPrecision = PRECISION$5.MEDIUM;
    var n = getTestContext();
    if (n && n.getShaderPrecisionFormat) {
      var t = n.getShaderPrecisionFormat(n.FRAGMENT_SHADER, n.HIGH_FLOAT);
      maxFragmentPrecision = t.precision ? PRECISION$5.HIGH : PRECISION$5.MEDIUM;
    }
  }
  return maxFragmentPrecision;
}
function setPrecision(n, t, e) {
  if (n.substring(0, 9) !== "precision") {
    var o = t;
    return t === PRECISION$5.HIGH && e !== PRECISION$5.HIGH && (o = PRECISION$5.MEDIUM), "precision " + o + ` float;
` + n;
  } else if (e !== PRECISION$5.HIGH && n.substring(0, 15) === "precision highp")
    return n.replace("precision highp", "precision mediump");
  return n;
}
var GLSL_TO_SIZE = {
  float: 1,
  vec2: 2,
  vec3: 3,
  vec4: 4,
  int: 1,
  ivec2: 2,
  ivec3: 3,
  ivec4: 4,
  uint: 1,
  uvec2: 2,
  uvec3: 3,
  uvec4: 4,
  bool: 1,
  bvec2: 2,
  bvec3: 3,
  bvec4: 4,
  mat2: 4,
  mat3: 9,
  mat4: 16,
  sampler2D: 1
};
function mapSize(n) {
  return GLSL_TO_SIZE[n];
}
var GL_TABLE = null, GL_TO_GLSL_TYPES = {
  FLOAT: "float",
  FLOAT_VEC2: "vec2",
  FLOAT_VEC3: "vec3",
  FLOAT_VEC4: "vec4",
  INT: "int",
  INT_VEC2: "ivec2",
  INT_VEC3: "ivec3",
  INT_VEC4: "ivec4",
  UNSIGNED_INT: "uint",
  UNSIGNED_INT_VEC2: "uvec2",
  UNSIGNED_INT_VEC3: "uvec3",
  UNSIGNED_INT_VEC4: "uvec4",
  BOOL: "bool",
  BOOL_VEC2: "bvec2",
  BOOL_VEC3: "bvec3",
  BOOL_VEC4: "bvec4",
  FLOAT_MAT2: "mat2",
  FLOAT_MAT3: "mat3",
  FLOAT_MAT4: "mat4",
  SAMPLER_2D: "sampler2D",
  INT_SAMPLER_2D: "sampler2D",
  UNSIGNED_INT_SAMPLER_2D: "sampler2D",
  SAMPLER_CUBE: "samplerCube",
  INT_SAMPLER_CUBE: "samplerCube",
  UNSIGNED_INT_SAMPLER_CUBE: "samplerCube",
  SAMPLER_2D_ARRAY: "sampler2DArray",
  INT_SAMPLER_2D_ARRAY: "sampler2DArray",
  UNSIGNED_INT_SAMPLER_2D_ARRAY: "sampler2DArray"
};
function mapType(n, t) {
  if (!GL_TABLE) {
    var e = Object.keys(GL_TO_GLSL_TYPES);
    GL_TABLE = {};
    for (var o = 0; o < e.length; ++o) {
      var R = e[o];
      GL_TABLE[n[R]] = GL_TO_GLSL_TYPES[R];
    }
  }
  return GL_TABLE[t];
}
var uniformParsers = [
  {
    test: function(n) {
      return n.type === "float" && n.size === 1;
    },
    code: function(n) {
      return `
            if(uv["` + n + '"] !== ud["' + n + `"].value)
            {
                ud["` + n + '"].value = uv["' + n + `"]
                gl.uniform1f(ud["` + n + '"].location, uv["' + n + `"])
            }
            `;
    }
  },
  {
    test: function(n) {
      return (n.type === "sampler2D" || n.type === "samplerCube" || n.type === "sampler2DArray") && n.size === 1 && !n.isArray;
    },
    code: function(n) {
      return `t = syncData.textureCount++;

            renderer.texture.bind(uv["` + n + `"], t);

            if(ud["` + n + `"].value !== t)
            {
                ud["` + n + `"].value = t;
                gl.uniform1i(ud["` + n + `"].location, t);
; // eslint-disable-line max-len
            }`;
    }
  },
  {
    test: function(n, t) {
      return n.type === "mat3" && n.size === 1 && t.a !== void 0;
    },
    code: function(n) {
      return `
            gl.uniformMatrix3fv(ud["` + n + '"].location, false, uv["' + n + `"].toArray(true));
            `;
    },
    codeUbo: function(n) {
      return `
                var ` + n + "_matrix = uv." + n + `.toArray(true);

                data[offset] = ` + n + `_matrix[0];
                data[offset+1] = ` + n + `_matrix[1];
                data[offset+2] = ` + n + `_matrix[2];
        
                data[offset + 4] = ` + n + `_matrix[3];
                data[offset + 5] = ` + n + `_matrix[4];
                data[offset + 6] = ` + n + `_matrix[5];
        
                data[offset + 8] = ` + n + `_matrix[6];
                data[offset + 9] = ` + n + `_matrix[7];
                data[offset + 10] = ` + n + `_matrix[8];
            `;
    }
  },
  {
    test: function(n, t) {
      return n.type === "vec2" && n.size === 1 && t.x !== void 0;
    },
    code: function(n) {
      return `
                cv = ud["` + n + `"].value;
                v = uv["` + n + `"];

                if(cv[0] !== v.x || cv[1] !== v.y)
                {
                    cv[0] = v.x;
                    cv[1] = v.y;
                    gl.uniform2f(ud["` + n + `"].location, v.x, v.y);
                }`;
    },
    codeUbo: function(n) {
      return `
                v = uv.` + n + `;

                data[offset] = v.x;
                data[offset+1] = v.y;
            `;
    }
  },
  {
    test: function(n) {
      return n.type === "vec2" && n.size === 1;
    },
    code: function(n) {
      return `
                cv = ud["` + n + `"].value;
                v = uv["` + n + `"];

                if(cv[0] !== v[0] || cv[1] !== v[1])
                {
                    cv[0] = v[0];
                    cv[1] = v[1];
                    gl.uniform2f(ud["` + n + `"].location, v[0], v[1]);
                }
            `;
    }
  },
  {
    test: function(n, t) {
      return n.type === "vec4" && n.size === 1 && t.width !== void 0;
    },
    code: function(n) {
      return `
                cv = ud["` + n + `"].value;
                v = uv["` + n + `"];

                if(cv[0] !== v.x || cv[1] !== v.y || cv[2] !== v.width || cv[3] !== v.height)
                {
                    cv[0] = v.x;
                    cv[1] = v.y;
                    cv[2] = v.width;
                    cv[3] = v.height;
                    gl.uniform4f(ud["` + n + `"].location, v.x, v.y, v.width, v.height)
                }`;
    },
    codeUbo: function(n) {
      return `
                    v = uv.` + n + `;

                    data[offset] = v.x;
                    data[offset+1] = v.y;
                    data[offset+2] = v.width;
                    data[offset+3] = v.height;
                `;
    }
  },
  {
    test: function(n) {
      return n.type === "vec4" && n.size === 1;
    },
    code: function(n) {
      return `
                cv = ud["` + n + `"].value;
                v = uv["` + n + `"];

                if(cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3])
                {
                    cv[0] = v[0];
                    cv[1] = v[1];
                    cv[2] = v[2];
                    cv[3] = v[3];

                    gl.uniform4f(ud["` + n + `"].location, v[0], v[1], v[2], v[3])
                }`;
    }
  }
], GLSL_TO_SINGLE_SETTERS_CACHED = {
  float: `
    if (cv !== v)
    {
        cu.value = v;
        gl.uniform1f(location, v);
    }`,
  vec2: `
    if (cv[0] !== v[0] || cv[1] !== v[1])
    {
        cv[0] = v[0];
        cv[1] = v[1];

        gl.uniform2f(location, v[0], v[1])
    }`,
  vec3: `
    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2])
    {
        cv[0] = v[0];
        cv[1] = v[1];
        cv[2] = v[2];

        gl.uniform3f(location, v[0], v[1], v[2])
    }`,
  vec4: `
    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3])
    {
        cv[0] = v[0];
        cv[1] = v[1];
        cv[2] = v[2];
        cv[3] = v[3];

        gl.uniform4f(location, v[0], v[1], v[2], v[3]);
    }`,
  int: `
    if (cv !== v)
    {
        cu.value = v;

        gl.uniform1i(location, v);
    }`,
  ivec2: `
    if (cv[0] !== v[0] || cv[1] !== v[1])
    {
        cv[0] = v[0];
        cv[1] = v[1];

        gl.uniform2i(location, v[0], v[1]);
    }`,
  ivec3: `
    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2])
    {
        cv[0] = v[0];
        cv[1] = v[1];
        cv[2] = v[2];

        gl.uniform3i(location, v[0], v[1], v[2]);
    }`,
  ivec4: `
    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3])
    {
        cv[0] = v[0];
        cv[1] = v[1];
        cv[2] = v[2];
        cv[3] = v[3];

        gl.uniform4i(location, v[0], v[1], v[2], v[3]);
    }`,
  uint: `
    if (cv !== v)
    {
        cu.value = v;

        gl.uniform1ui(location, v);
    }`,
  uvec2: `
    if (cv[0] !== v[0] || cv[1] !== v[1])
    {
        cv[0] = v[0];
        cv[1] = v[1];

        gl.uniform2ui(location, v[0], v[1]);
    }`,
  uvec3: `
    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2])
    {
        cv[0] = v[0];
        cv[1] = v[1];
        cv[2] = v[2];

        gl.uniform3ui(location, v[0], v[1], v[2]);
    }`,
  uvec4: `
    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3])
    {
        cv[0] = v[0];
        cv[1] = v[1];
        cv[2] = v[2];
        cv[3] = v[3];

        gl.uniform4ui(location, v[0], v[1], v[2], v[3]);
    }`,
  bool: `
    if (cv !== v)
    {
        cu.value = v;
        gl.uniform1i(location, v);
    }`,
  bvec2: `
    if (cv[0] != v[0] || cv[1] != v[1])
    {
        cv[0] = v[0];
        cv[1] = v[1];

        gl.uniform2i(location, v[0], v[1]);
    }`,
  bvec3: `
    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2])
    {
        cv[0] = v[0];
        cv[1] = v[1];
        cv[2] = v[2];

        gl.uniform3i(location, v[0], v[1], v[2]);
    }`,
  bvec4: `
    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3])
    {
        cv[0] = v[0];
        cv[1] = v[1];
        cv[2] = v[2];
        cv[3] = v[3];

        gl.uniform4i(location, v[0], v[1], v[2], v[3]);
    }`,
  mat2: "gl.uniformMatrix2fv(location, false, v)",
  mat3: "gl.uniformMatrix3fv(location, false, v)",
  mat4: "gl.uniformMatrix4fv(location, false, v)",
  sampler2D: "gl.uniform1i(location, v)",
  samplerCube: "gl.uniform1i(location, v)",
  sampler2DArray: "gl.uniform1i(location, v)"
}, GLSL_TO_ARRAY_SETTERS = {
  float: "gl.uniform1fv(location, v)",
  vec2: "gl.uniform2fv(location, v)",
  vec3: "gl.uniform3fv(location, v)",
  vec4: "gl.uniform4fv(location, v)",
  mat4: "gl.uniformMatrix4fv(location, false, v)",
  mat3: "gl.uniformMatrix3fv(location, false, v)",
  mat2: "gl.uniformMatrix2fv(location, false, v)",
  int: "gl.uniform1iv(location, v)",
  ivec2: "gl.uniform2iv(location, v)",
  ivec3: "gl.uniform3iv(location, v)",
  ivec4: "gl.uniform4iv(location, v)",
  uint: "gl.uniform1uiv(location, v)",
  uvec2: "gl.uniform2uiv(location, v)",
  uvec3: "gl.uniform3uiv(location, v)",
  uvec4: "gl.uniform4uiv(location, v)",
  bool: "gl.uniform1iv(location, v)",
  bvec2: "gl.uniform2iv(location, v)",
  bvec3: "gl.uniform3iv(location, v)",
  bvec4: "gl.uniform4iv(location, v)",
  sampler2D: "gl.uniform1iv(location, v)",
  samplerCube: "gl.uniform1iv(location, v)",
  sampler2DArray: "gl.uniform1iv(location, v)"
};
function generateUniformsSync(n, t) {
  var e, o = [`
        var v = null;
        var cv = null;
        var cu = null;
        var t = 0;
        var gl = renderer.gl;
    `];
  for (var R in n.uniforms) {
    var N = t[R];
    if (!N) {
      !((e = n.uniforms[R]) === null || e === void 0) && e.group && (n.uniforms[R].ubo ? o.push(`
                        renderer.shader.syncUniformBufferGroup(uv.` + R + ", '" + R + `');
                    `) : o.push(`
                        renderer.shader.syncUniformGroup(uv.` + R + `, syncData);
                    `));
      continue;
    }
    for (var M = n.uniforms[R], D = !1, L = 0; L < uniformParsers.length; L++)
      if (uniformParsers[L].test(N, M)) {
        o.push(uniformParsers[L].code(R, M)), D = !0;
        break;
      }
    if (!D) {
      var B = N.size === 1 ? GLSL_TO_SINGLE_SETTERS_CACHED : GLSL_TO_ARRAY_SETTERS, $ = B[N.type].replace("location", 'ud["' + R + '"].location');
      o.push(`
            cu = ud["` + R + `"];
            cv = cu.value;
            v = uv["` + R + `"];
            ` + $ + ";");
    }
  }
  return new Function("ud", "uv", "renderer", "syncData", o.join(`
`));
}
var fragTemplate$1 = [
  "precision mediump float;",
  "void main(void){",
  "float test = 0.1;",
  "%forloop%",
  "gl_FragColor = vec4(0.0);",
  "}"
].join(`
`);
function generateIfTestSrc(n) {
  for (var t = "", e = 0; e < n; ++e)
    e > 0 && (t += `
else `), e < n - 1 && (t += "if(test == " + e + ".0){}");
  return t;
}
function checkMaxIfStatementsInShader(n, t) {
  if (n === 0)
    throw new Error("Invalid value of `0` passed to `checkMaxIfStatementsInShader`");
  for (var e = t.createShader(t.FRAGMENT_SHADER); ; ) {
    var o = fragTemplate$1.replace(/%forloop%/gi, generateIfTestSrc(n));
    if (t.shaderSource(e, o), t.compileShader(e), !t.getShaderParameter(e, t.COMPILE_STATUS))
      n = n / 2 | 0;
    else
      break;
  }
  return n;
}
var unsafeEval;
function unsafeEvalSupported() {
  if (typeof unsafeEval == "boolean")
    return unsafeEval;
  try {
    var n = new Function("param1", "param2", "param3", "return param1[param2] === param3;");
    unsafeEval = n({ a: "b" }, "a", "b") === !0;
  } catch {
    unsafeEval = !1;
  }
  return unsafeEval;
}
var defaultFragment$2 = `varying vec2 vTextureCoord;

uniform sampler2D uSampler;

void main(void){
   gl_FragColor *= texture2D(uSampler, vTextureCoord);
}`, defaultVertex$3 = `attribute vec2 aVertexPosition;
attribute vec2 aTextureCoord;

uniform mat3 projectionMatrix;

varying vec2 vTextureCoord;

void main(void){
   gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);
   vTextureCoord = aTextureCoord;
}
`, UID$1 = 0, nameCache = {}, Program = function() {
  function n(t, e, o) {
    o === void 0 && (o = "pixi-shader"), this.id = UID$1++, this.vertexSrc = t || n.defaultVertexSrc, this.fragmentSrc = e || n.defaultFragmentSrc, this.vertexSrc = this.vertexSrc.trim(), this.fragmentSrc = this.fragmentSrc.trim(), this.vertexSrc.substring(0, 8) !== "#version" && (o = o.replace(/\s+/g, "-"), nameCache[o] ? (nameCache[o]++, o += "-" + nameCache[o]) : nameCache[o] = 1, this.vertexSrc = "#define SHADER_NAME " + o + `
` + this.vertexSrc, this.fragmentSrc = "#define SHADER_NAME " + o + `
` + this.fragmentSrc, this.vertexSrc = setPrecision(this.vertexSrc, settings$1.PRECISION_VERTEX, PRECISION$5.HIGH), this.fragmentSrc = setPrecision(this.fragmentSrc, settings$1.PRECISION_FRAGMENT, getMaxFragmentPrecision())), this.glPrograms = {}, this.syncUniforms = null;
  }
  return Object.defineProperty(n, "defaultVertexSrc", {
    get: function() {
      return defaultVertex$3;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(n, "defaultFragmentSrc", {
    get: function() {
      return defaultFragment$2;
    },
    enumerable: !1,
    configurable: !0
  }), n.from = function(t, e, o) {
    var R = t + e, N = ProgramCache[R];
    return N || (ProgramCache[R] = N = new n(t, e, o)), N;
  }, n;
}(), Shader = function() {
  function n(t, e) {
    this.uniformBindCount = 0, this.program = t, e ? e instanceof UniformGroup ? this.uniformGroup = e : this.uniformGroup = new UniformGroup(e) : this.uniformGroup = new UniformGroup({});
  }
  return n.prototype.checkUniformExists = function(t, e) {
    if (e.uniforms[t])
      return !0;
    for (var o in e.uniforms) {
      var R = e.uniforms[o];
      if (R.group && this.checkUniformExists(t, R))
        return !0;
    }
    return !1;
  }, n.prototype.destroy = function() {
    this.uniformGroup = null;
  }, Object.defineProperty(n.prototype, "uniforms", {
    get: function() {
      return this.uniformGroup.uniforms;
    },
    enumerable: !1,
    configurable: !0
  }), n.from = function(t, e, o) {
    var R = Program.from(t, e);
    return new n(R, o);
  }, n;
}(), BLEND$1 = 0, OFFSET$1 = 1, CULLING$1 = 2, DEPTH_TEST$1 = 3, WINDING$1 = 4, DEPTH_MASK$1 = 5, State = function() {
  function n() {
    this.data = 0, this.blendMode = BLEND_MODES$5.NORMAL, this.polygonOffset = 0, this.blend = !0, this.depthMask = !0;
  }
  return Object.defineProperty(n.prototype, "blend", {
    get: function() {
      return !!(this.data & 1 << BLEND$1);
    },
    set: function(t) {
      !!(this.data & 1 << BLEND$1) !== t && (this.data ^= 1 << BLEND$1);
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(n.prototype, "offsets", {
    get: function() {
      return !!(this.data & 1 << OFFSET$1);
    },
    set: function(t) {
      !!(this.data & 1 << OFFSET$1) !== t && (this.data ^= 1 << OFFSET$1);
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(n.prototype, "culling", {
    get: function() {
      return !!(this.data & 1 << CULLING$1);
    },
    set: function(t) {
      !!(this.data & 1 << CULLING$1) !== t && (this.data ^= 1 << CULLING$1);
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(n.prototype, "depthTest", {
    get: function() {
      return !!(this.data & 1 << DEPTH_TEST$1);
    },
    set: function(t) {
      !!(this.data & 1 << DEPTH_TEST$1) !== t && (this.data ^= 1 << DEPTH_TEST$1);
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(n.prototype, "depthMask", {
    get: function() {
      return !!(this.data & 1 << DEPTH_MASK$1);
    },
    set: function(t) {
      !!(this.data & 1 << DEPTH_MASK$1) !== t && (this.data ^= 1 << DEPTH_MASK$1);
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(n.prototype, "clockwiseFrontFace", {
    get: function() {
      return !!(this.data & 1 << WINDING$1);
    },
    set: function(t) {
      !!(this.data & 1 << WINDING$1) !== t && (this.data ^= 1 << WINDING$1);
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(n.prototype, "blendMode", {
    get: function() {
      return this._blendMode;
    },
    set: function(t) {
      this.blend = t !== BLEND_MODES$5.NONE, this._blendMode = t;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(n.prototype, "polygonOffset", {
    get: function() {
      return this._polygonOffset;
    },
    set: function(t) {
      this.offsets = !!t, this._polygonOffset = t;
    },
    enumerable: !1,
    configurable: !0
  }), n.prototype.toString = function() {
    return "[@pixi/core:State " + ("blendMode=" + this.blendMode + " ") + ("clockwiseFrontFace=" + this.clockwiseFrontFace + " ") + ("culling=" + this.culling + " ") + ("depthMask=" + this.depthMask + " ") + ("polygonOffset=" + this.polygonOffset) + "]";
  }, n.for2d = function() {
    var t = new n();
    return t.depthTest = !1, t.blend = !0, t;
  }, n;
}(), defaultFragment$1 = `varying vec2 vTextureCoord;

uniform sampler2D uSampler;

void main(void){
   gl_FragColor = texture2D(uSampler, vTextureCoord);
}
`, defaultVertex$2 = `attribute vec2 aVertexPosition;

uniform mat3 projectionMatrix;

varying vec2 vTextureCoord;

uniform vec4 inputSize;
uniform vec4 outputFrame;

vec4 filterVertexPosition( void )
{
    vec2 position = aVertexPosition * max(outputFrame.zw, vec2(0.)) + outputFrame.xy;

    return vec4((projectionMatrix * vec3(position, 1.0)).xy, 0.0, 1.0);
}

vec2 filterTextureCoord( void )
{
    return aVertexPosition * (outputFrame.zw * inputSize.zw);
}

void main(void)
{
    gl_Position = filterVertexPosition();
    vTextureCoord = filterTextureCoord();
}
`, Filter = function(n) {
  __extends$q(t, n);
  function t(e, o, R) {
    var N = this, M = Program.from(e || t.defaultVertexSrc, o || t.defaultFragmentSrc);
    return N = n.call(this, M, R) || this, N.padding = 0, N.resolution = settings$1.FILTER_RESOLUTION, N.multisample = settings$1.FILTER_MULTISAMPLE, N.enabled = !0, N.autoFit = !0, N.state = new State(), N;
  }
  return t.prototype.apply = function(e, o, R, N, M) {
    e.applyFilter(this, o, R, N);
  }, Object.defineProperty(t.prototype, "blendMode", {
    get: function() {
      return this.state.blendMode;
    },
    set: function(e) {
      this.state.blendMode = e;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(t.prototype, "resolution", {
    get: function() {
      return this._resolution;
    },
    set: function(e) {
      this._resolution = e;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(t, "defaultVertexSrc", {
    get: function() {
      return defaultVertex$2;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(t, "defaultFragmentSrc", {
    get: function() {
      return defaultFragment$1;
    },
    enumerable: !1,
    configurable: !0
  }), t;
}(Shader), vertex$4 = `attribute vec2 aVertexPosition;
attribute vec2 aTextureCoord;

uniform mat3 projectionMatrix;
uniform mat3 otherMatrix;

varying vec2 vMaskCoord;
varying vec2 vTextureCoord;

void main(void)
{
    gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);

    vTextureCoord = aTextureCoord;
    vMaskCoord = ( otherMatrix * vec3( aTextureCoord, 1.0)  ).xy;
}
`, fragment$7 = `varying vec2 vMaskCoord;
varying vec2 vTextureCoord;

uniform sampler2D uSampler;
uniform sampler2D mask;
uniform float alpha;
uniform float npmAlpha;
uniform vec4 maskClamp;

void main(void)
{
    float clip = step(3.5,
        step(maskClamp.x, vMaskCoord.x) +
        step(maskClamp.y, vMaskCoord.y) +
        step(vMaskCoord.x, maskClamp.z) +
        step(vMaskCoord.y, maskClamp.w));

    vec4 original = texture2D(uSampler, vTextureCoord);
    vec4 masky = texture2D(mask, vMaskCoord);
    float alphaMul = 1.0 - npmAlpha * (1.0 - masky.a);

    original *= (alphaMul * masky.r * alpha * clip);

    gl_FragColor = original;
}
`, tempMat$1 = new Matrix(), TextureMatrix = function() {
  function n(t, e) {
    this._texture = t, this.mapCoord = new Matrix(), this.uClampFrame = new Float32Array(4), this.uClampOffset = new Float32Array(2), this._textureID = -1, this._updateID = 0, this.clampOffset = 0, this.clampMargin = typeof e > "u" ? 0.5 : e, this.isSimple = !1;
  }
  return Object.defineProperty(n.prototype, "texture", {
    get: function() {
      return this._texture;
    },
    set: function(t) {
      this._texture = t, this._textureID = -1;
    },
    enumerable: !1,
    configurable: !0
  }), n.prototype.multiplyUvs = function(t, e) {
    e === void 0 && (e = t);
    for (var o = this.mapCoord, R = 0; R < t.length; R += 2) {
      var N = t[R], M = t[R + 1];
      e[R] = N * o.a + M * o.c + o.tx, e[R + 1] = N * o.b + M * o.d + o.ty;
    }
    return e;
  }, n.prototype.update = function(t) {
    var e = this._texture;
    if (!e || !e.valid || !t && this._textureID === e._updateID)
      return !1;
    this._textureID = e._updateID, this._updateID++;
    var o = e._uvs;
    this.mapCoord.set(o.x1 - o.x0, o.y1 - o.y0, o.x3 - o.x0, o.y3 - o.y0, o.x0, o.y0);
    var R = e.orig, N = e.trim;
    N && (tempMat$1.set(R.width / N.width, 0, 0, R.height / N.height, -N.x / N.width, -N.y / N.height), this.mapCoord.append(tempMat$1));
    var M = e.baseTexture, D = this.uClampFrame, L = this.clampMargin / M.resolution, B = this.clampOffset;
    return D[0] = (e._frame.x + L + B) / M.width, D[1] = (e._frame.y + L + B) / M.height, D[2] = (e._frame.x + e._frame.width - L + B) / M.width, D[3] = (e._frame.y + e._frame.height - L + B) / M.height, this.uClampOffset[0] = B / M.realWidth, this.uClampOffset[1] = B / M.realHeight, this.isSimple = e._frame.width === M.width && e._frame.height === M.height && e.rotate === 0, !0;
  }, n;
}(), SpriteMaskFilter = function(n) {
  __extends$q(t, n);
  function t(e, o, R) {
    var N = this, M = null;
    return typeof e != "string" && o === void 0 && R === void 0 && (M = e, e = void 0, o = void 0, R = void 0), N = n.call(this, e || vertex$4, o || fragment$7, R) || this, N.maskSprite = M, N.maskMatrix = new Matrix(), N;
  }
  return Object.defineProperty(t.prototype, "maskSprite", {
    get: function() {
      return this._maskSprite;
    },
    set: function(e) {
      this._maskSprite = e, this._maskSprite && (this._maskSprite.renderable = !1);
    },
    enumerable: !1,
    configurable: !0
  }), t.prototype.apply = function(e, o, R, N) {
    var M = this._maskSprite, D = M._texture;
    !D.valid || (D.uvMatrix || (D.uvMatrix = new TextureMatrix(D, 0)), D.uvMatrix.update(), this.uniforms.npmAlpha = D.baseTexture.alphaMode ? 0 : 1, this.uniforms.mask = D, this.uniforms.otherMatrix = e.calculateSpriteMatrix(this.maskMatrix, M).prepend(D.uvMatrix.mapCoord), this.uniforms.alpha = M.worldAlpha, this.uniforms.maskClamp = D.uvMatrix.uClampFrame, e.applyFilter(this, o, R, N));
  }, t;
}(Filter), MaskSystem = function() {
  function n(t) {
    this.renderer = t, this.enableScissor = !0, this.alphaMaskPool = [], this.maskDataPool = [], this.maskStack = [], this.alphaMaskIndex = 0;
  }
  return n.prototype.setMaskStack = function(t) {
    this.maskStack = t, this.renderer.scissor.setMaskStack(t), this.renderer.stencil.setMaskStack(t);
  }, n.prototype.push = function(t, e) {
    var o = e;
    if (!o.isMaskData) {
      var R = this.maskDataPool.pop() || new MaskData();
      R.pooled = !0, R.maskObject = e, o = R;
    }
    var N = this.maskStack.length !== 0 ? this.maskStack[this.maskStack.length - 1] : null;
    if (o.copyCountersOrReset(N), o._colorMask = N ? N._colorMask : 15, o.autoDetect && this.detect(o), o._target = t, o.type !== MASK_TYPES$5.SPRITE && this.maskStack.push(o), o.enabled)
      switch (o.type) {
        case MASK_TYPES$5.SCISSOR:
          this.renderer.scissor.push(o);
          break;
        case MASK_TYPES$5.STENCIL:
          this.renderer.stencil.push(o);
          break;
        case MASK_TYPES$5.SPRITE:
          o.copyCountersOrReset(null), this.pushSpriteMask(o);
          break;
        case MASK_TYPES$5.COLOR:
          this.pushColorMask(o);
          break;
      }
    o.type === MASK_TYPES$5.SPRITE && this.maskStack.push(o);
  }, n.prototype.pop = function(t) {
    var e = this.maskStack.pop();
    if (!(!e || e._target !== t)) {
      if (e.enabled)
        switch (e.type) {
          case MASK_TYPES$5.SCISSOR:
            this.renderer.scissor.pop(e);
            break;
          case MASK_TYPES$5.STENCIL:
            this.renderer.stencil.pop(e.maskObject);
            break;
          case MASK_TYPES$5.SPRITE:
            this.popSpriteMask(e);
            break;
          case MASK_TYPES$5.COLOR:
            this.popColorMask(e);
            break;
        }
      if (e.reset(), e.pooled && this.maskDataPool.push(e), this.maskStack.length !== 0) {
        var o = this.maskStack[this.maskStack.length - 1];
        o.type === MASK_TYPES$5.SPRITE && o._filters && (o._filters[0].maskSprite = o.maskObject);
      }
    }
  }, n.prototype.detect = function(t) {
    var e = t.maskObject;
    e ? e.isSprite ? t.type = MASK_TYPES$5.SPRITE : this.enableScissor && this.renderer.scissor.testScissor(t) ? t.type = MASK_TYPES$5.SCISSOR : t.type = MASK_TYPES$5.STENCIL : t.type = MASK_TYPES$5.COLOR;
  }, n.prototype.pushSpriteMask = function(t) {
    var e, o, R = t.maskObject, N = t._target, M = t._filters;
    M || (M = this.alphaMaskPool[this.alphaMaskIndex], M || (M = this.alphaMaskPool[this.alphaMaskIndex] = [new SpriteMaskFilter()]));
    var D = this.renderer, L = D.renderTexture, B, $;
    if (L.current) {
      var k = L.current;
      B = t.resolution || k.resolution, $ = (e = t.multisample) !== null && e !== void 0 ? e : k.multisample;
    } else
      B = t.resolution || D.resolution, $ = (o = t.multisample) !== null && o !== void 0 ? o : D.multisample;
    M[0].resolution = B, M[0].multisample = $, M[0].maskSprite = R;
    var U = N.filterArea;
    N.filterArea = R.getBounds(!0), D.filter.push(N, M), N.filterArea = U, t._filters || this.alphaMaskIndex++;
  }, n.prototype.popSpriteMask = function(t) {
    this.renderer.filter.pop(), t._filters ? t._filters[0].maskSprite = null : (this.alphaMaskIndex--, this.alphaMaskPool[this.alphaMaskIndex][0].maskSprite = null);
  }, n.prototype.pushColorMask = function(t) {
    var e = t._colorMask, o = t._colorMask = e & t.colorMask;
    o !== e && this.renderer.gl.colorMask((o & 1) !== 0, (o & 2) !== 0, (o & 4) !== 0, (o & 8) !== 0);
  }, n.prototype.popColorMask = function(t) {
    var e = t._colorMask, o = this.maskStack.length > 0 ? this.maskStack[this.maskStack.length - 1]._colorMask : 15;
    o !== e && this.renderer.gl.colorMask((o & 1) !== 0, (o & 2) !== 0, (o & 4) !== 0, (o & 8) !== 0);
  }, n.prototype.destroy = function() {
    this.renderer = null;
  }, n;
}(), AbstractMaskSystem = function() {
  function n(t) {
    this.renderer = t, this.maskStack = [], this.glConst = 0;
  }
  return n.prototype.getStackLength = function() {
    return this.maskStack.length;
  }, n.prototype.setMaskStack = function(t) {
    var e = this.renderer.gl, o = this.getStackLength();
    this.maskStack = t;
    var R = this.getStackLength();
    R !== o && (R === 0 ? e.disable(this.glConst) : (e.enable(this.glConst), this._useCurrent()));
  }, n.prototype._useCurrent = function() {
  }, n.prototype.destroy = function() {
    this.renderer = null, this.maskStack = null;
  }, n;
}(), tempMatrix$1 = new Matrix(), rectPool = [], ScissorSystem = function(n) {
  __extends$q(t, n);
  function t(e) {
    var o = n.call(this, e) || this;
    return o.glConst = settings$1.ADAPTER.getWebGLRenderingContext().SCISSOR_TEST, o;
  }
  return t.prototype.getStackLength = function() {
    var e = this.maskStack[this.maskStack.length - 1];
    return e ? e._scissorCounter : 0;
  }, t.prototype.calcScissorRect = function(e) {
    var o;
    if (!e._scissorRectLocal) {
      var R = e._scissorRect, N = e.maskObject, M = this.renderer, D = M.renderTexture, L = N.getBounds(!0, (o = rectPool.pop()) !== null && o !== void 0 ? o : new Rectangle());
      this.roundFrameToPixels(L, D.current ? D.current.resolution : M.resolution, D.sourceFrame, D.destinationFrame, M.projection.transform), R && L.fit(R), e._scissorRectLocal = L;
    }
  }, t.isMatrixRotated = function(e) {
    if (!e)
      return !1;
    var o = e.a, R = e.b, N = e.c, M = e.d;
    return (Math.abs(R) > 1e-4 || Math.abs(N) > 1e-4) && (Math.abs(o) > 1e-4 || Math.abs(M) > 1e-4);
  }, t.prototype.testScissor = function(e) {
    var o = e.maskObject;
    if (!o.isFastRect || !o.isFastRect() || t.isMatrixRotated(o.worldTransform) || t.isMatrixRotated(this.renderer.projection.transform))
      return !1;
    this.calcScissorRect(e);
    var R = e._scissorRectLocal;
    return R.width > 0 && R.height > 0;
  }, t.prototype.roundFrameToPixels = function(e, o, R, N, M) {
    t.isMatrixRotated(M) || (M = M ? tempMatrix$1.copyFrom(M) : tempMatrix$1.identity(), M.translate(-R.x, -R.y).scale(N.width / R.width, N.height / R.height).translate(N.x, N.y), this.renderer.filter.transformAABB(M, e), e.fit(N), e.x = Math.round(e.x * o), e.y = Math.round(e.y * o), e.width = Math.round(e.width * o), e.height = Math.round(e.height * o));
  }, t.prototype.push = function(e) {
    e._scissorRectLocal || this.calcScissorRect(e);
    var o = this.renderer.gl;
    e._scissorRect || o.enable(o.SCISSOR_TEST), e._scissorCounter++, e._scissorRect = e._scissorRectLocal, this._useCurrent();
  }, t.prototype.pop = function(e) {
    var o = this.renderer.gl;
    e && rectPool.push(e._scissorRectLocal), this.getStackLength() > 0 ? this._useCurrent() : o.disable(o.SCISSOR_TEST);
  }, t.prototype._useCurrent = function() {
    var e = this.maskStack[this.maskStack.length - 1]._scissorRect, o;
    this.renderer.renderTexture.current ? o = e.y : o = this.renderer.height - e.height - e.y, this.renderer.gl.scissor(e.x, o, e.width, e.height);
  }, t;
}(AbstractMaskSystem), StencilSystem = function(n) {
  __extends$q(t, n);
  function t(e) {
    var o = n.call(this, e) || this;
    return o.glConst = settings$1.ADAPTER.getWebGLRenderingContext().STENCIL_TEST, o;
  }
  return t.prototype.getStackLength = function() {
    var e = this.maskStack[this.maskStack.length - 1];
    return e ? e._stencilCounter : 0;
  }, t.prototype.push = function(e) {
    var o = e.maskObject, R = this.renderer.gl, N = e._stencilCounter;
    N === 0 && (this.renderer.framebuffer.forceStencil(), R.clearStencil(0), R.clear(R.STENCIL_BUFFER_BIT), R.enable(R.STENCIL_TEST)), e._stencilCounter++;
    var M = e._colorMask;
    M !== 0 && (e._colorMask = 0, R.colorMask(!1, !1, !1, !1)), R.stencilFunc(R.EQUAL, N, 4294967295), R.stencilOp(R.KEEP, R.KEEP, R.INCR), o.renderable = !0, o.render(this.renderer), this.renderer.batch.flush(), o.renderable = !1, M !== 0 && (e._colorMask = M, R.colorMask((M & 1) !== 0, (M & 2) !== 0, (M & 4) !== 0, (M & 8) !== 0)), this._useCurrent();
  }, t.prototype.pop = function(e) {
    var o = this.renderer.gl;
    if (this.getStackLength() === 0)
      o.disable(o.STENCIL_TEST);
    else {
      var R = this.maskStack.length !== 0 ? this.maskStack[this.maskStack.length - 1] : null, N = R ? R._colorMask : 15;
      N !== 0 && (R._colorMask = 0, o.colorMask(!1, !1, !1, !1)), o.stencilOp(o.KEEP, o.KEEP, o.DECR), e.renderable = !0, e.render(this.renderer), this.renderer.batch.flush(), e.renderable = !1, N !== 0 && (R._colorMask = N, o.colorMask((N & 1) !== 0, (N & 2) !== 0, (N & 4) !== 0, (N & 8) !== 0)), this._useCurrent();
    }
  }, t.prototype._useCurrent = function() {
    var e = this.renderer.gl;
    e.stencilFunc(e.EQUAL, this.getStackLength(), 4294967295), e.stencilOp(e.KEEP, e.KEEP, e.KEEP);
  }, t;
}(AbstractMaskSystem), ProjectionSystem = function() {
  function n(t) {
    this.renderer = t, this.destinationFrame = null, this.sourceFrame = null, this.defaultFrame = null, this.projectionMatrix = new Matrix(), this.transform = null;
  }
  return n.prototype.update = function(t, e, o, R) {
    this.destinationFrame = t || this.destinationFrame || this.defaultFrame, this.sourceFrame = e || this.sourceFrame || t, this.calculateProjection(this.destinationFrame, this.sourceFrame, o, R), this.transform && this.projectionMatrix.append(this.transform);
    var N = this.renderer;
    N.globalUniforms.uniforms.projectionMatrix = this.projectionMatrix, N.globalUniforms.update(), N.shader.shader && N.shader.syncUniformGroup(N.shader.shader.uniforms.globals);
  }, n.prototype.calculateProjection = function(t, e, o, R) {
    var N = this.projectionMatrix, M = R ? -1 : 1;
    N.identity(), N.a = 1 / e.width * 2, N.d = M * (1 / e.height * 2), N.tx = -1 - e.x * N.a, N.ty = -M - e.y * N.d;
  }, n.prototype.setTransform = function(t) {
  }, n.prototype.destroy = function() {
    this.renderer = null;
  }, n;
}(), tempRect = new Rectangle(), tempRect2 = new Rectangle(), RenderTextureSystem = function() {
  function n(t) {
    this.renderer = t, this.clearColor = t._backgroundColorRgba, this.defaultMaskStack = [], this.current = null, this.sourceFrame = new Rectangle(), this.destinationFrame = new Rectangle(), this.viewportFrame = new Rectangle();
  }
  return n.prototype.bind = function(t, e, o) {
    t === void 0 && (t = null);
    var R = this.renderer;
    this.current = t;
    var N, M, D;
    t ? (N = t.baseTexture, D = N.resolution, e || (tempRect.width = t.frame.width, tempRect.height = t.frame.height, e = tempRect), o || (tempRect2.x = t.frame.x, tempRect2.y = t.frame.y, tempRect2.width = e.width, tempRect2.height = e.height, o = tempRect2), M = N.framebuffer) : (D = R.resolution, e || (tempRect.width = R.screen.width, tempRect.height = R.screen.height, e = tempRect), o || (o = tempRect, o.width = e.width, o.height = e.height));
    var L = this.viewportFrame;
    L.x = o.x * D, L.y = o.y * D, L.width = o.width * D, L.height = o.height * D, t || (L.y = R.view.height - (L.y + L.height)), L.ceil(), this.renderer.framebuffer.bind(M, L), this.renderer.projection.update(o, e, D, !M), t ? this.renderer.mask.setMaskStack(N.maskStack) : this.renderer.mask.setMaskStack(this.defaultMaskStack), this.sourceFrame.copyFrom(e), this.destinationFrame.copyFrom(o);
  }, n.prototype.clear = function(t, e) {
    this.current ? t = t || this.current.baseTexture.clearColor : t = t || this.clearColor;
    var o = this.destinationFrame, R = this.current ? this.current.baseTexture : this.renderer.screen, N = o.width !== R.width || o.height !== R.height;
    if (N) {
      var M = this.viewportFrame, D = M.x, L = M.y, B = M.width, $ = M.height;
      D = Math.round(D), L = Math.round(L), B = Math.round(B), $ = Math.round($), this.renderer.gl.enable(this.renderer.gl.SCISSOR_TEST), this.renderer.gl.scissor(D, L, B, $);
    }
    this.renderer.framebuffer.clear(t[0], t[1], t[2], t[3], e), N && this.renderer.scissor.pop();
  }, n.prototype.resize = function() {
    this.bind(null);
  }, n.prototype.reset = function() {
    this.bind(null);
  }, n.prototype.destroy = function() {
    this.renderer = null;
  }, n;
}();
function uboUpdate(n, t, e, o, R) {
  e.buffer.update(R);
}
var UBO_TO_SINGLE_SETTERS = {
  float: `
        data[offset] = v;
    `,
  vec2: `
        data[offset] = v[0];
        data[offset+1] = v[1];
    `,
  vec3: `
        data[offset] = v[0];
        data[offset+1] = v[1];
        data[offset+2] = v[2];

    `,
  vec4: `
        data[offset] = v[0];
        data[offset+1] = v[1];
        data[offset+2] = v[2];
        data[offset+3] = v[3];
    `,
  mat2: `
        data[offset] = v[0];
        data[offset+1] = v[1];

        data[offset+4] = v[2];
        data[offset+5] = v[3];
    `,
  mat3: `
        data[offset] = v[0];
        data[offset+1] = v[1];
        data[offset+2] = v[2];

        data[offset + 4] = v[3];
        data[offset + 5] = v[4];
        data[offset + 6] = v[5];

        data[offset + 8] = v[6];
        data[offset + 9] = v[7];
        data[offset + 10] = v[8];
    `,
  mat4: `
        for(var i = 0; i < 16; i++)
        {
            data[offset + i] = v[i];
        }
    `
}, GLSL_TO_STD40_SIZE = {
  float: 4,
  vec2: 8,
  vec3: 12,
  vec4: 16,
  int: 4,
  ivec2: 8,
  ivec3: 12,
  ivec4: 16,
  uint: 4,
  uvec2: 8,
  uvec3: 12,
  uvec4: 16,
  bool: 4,
  bvec2: 8,
  bvec3: 12,
  bvec4: 16,
  mat2: 16 * 2,
  mat3: 16 * 3,
  mat4: 16 * 4
};
function createUBOElements(n) {
  for (var t = n.map(function(L) {
    return {
      data: L,
      offset: 0,
      dataLen: 0,
      dirty: 0
    };
  }), e = 0, o = 0, R = 0, N = 0; N < t.length; N++) {
    var M = t[N];
    if (e = GLSL_TO_STD40_SIZE[M.data.type], M.data.size > 1 && (e = Math.max(e, 16) * M.data.size), M.dataLen = e, o % e !== 0 && o < 16) {
      var D = o % e % 16;
      o += D, R += D;
    }
    o + e > 16 ? (R = Math.ceil(R / 16) * 16, M.offset = R, R += e, o = e) : (M.offset = R, o += e, R += e);
  }
  return R = Math.ceil(R / 16) * 16, { uboElements: t, size: R };
}
function getUBOData(n, t) {
  var e = [];
  for (var o in n)
    t[o] && e.push(t[o]);
  return e.sort(function(R, N) {
    return R.index - N.index;
  }), e;
}
function generateUniformBufferSync(n, t) {
  if (!n.autoManage)
    return { size: 0, syncFunc: uboUpdate };
  for (var e = getUBOData(n.uniforms, t), o = createUBOElements(e), R = o.uboElements, N = o.size, M = [`
    var v = null;
    var v2 = null;
    var cv = null;
    var t = 0;
    var gl = renderer.gl
    var index = 0;
    var data = buffer.data;
    `], D = 0; D < R.length; D++) {
    for (var L = R[D], B = n.uniforms[L.data.name], $ = L.data.name, k = !1, U = 0; U < uniformParsers.length; U++) {
      var z = uniformParsers[U];
      if (z.codeUbo && z.test(L.data, B)) {
        M.push("offset = " + L.offset / 4 + ";", uniformParsers[U].codeUbo(L.data.name, B)), k = !0;
        break;
      }
    }
    if (!k)
      if (L.data.size > 1) {
        var X = mapSize(L.data.type), V = Math.max(GLSL_TO_STD40_SIZE[L.data.type] / 16, 1), W = X / V, Y = (4 - W % 4) % 4;
        M.push(`
                cv = ud.` + $ + `.value;
                v = uv.` + $ + `;
                offset = ` + L.offset / 4 + `;

                t = 0;

                for(var i=0; i < ` + L.data.size * V + `; i++)
                {
                    for(var j = 0; j < ` + W + `; j++)
                    {
                        data[offset++] = v[t++];
                    }
                    offset += ` + Y + `;
                }

                `);
      } else {
        var q = UBO_TO_SINGLE_SETTERS[L.data.type];
        M.push(`
                cv = ud.` + $ + `.value;
                v = uv.` + $ + `;
                offset = ` + L.offset / 4 + `;
                ` + q + `;
                `);
      }
  }
  return M.push(`
       renderer.buffer.update(buffer);
    `), {
    size: N,
    syncFunc: new Function("ud", "uv", "renderer", "syncData", "buffer", M.join(`
`))
  };
}
var GLProgram = function() {
  function n(t, e) {
    this.program = t, this.uniformData = e, this.uniformGroups = {}, this.uniformDirtyGroups = {}, this.uniformBufferBindings = {};
  }
  return n.prototype.destroy = function() {
    this.uniformData = null, this.uniformGroups = null, this.uniformDirtyGroups = null, this.uniformBufferBindings = null, this.program = null;
  }, n;
}();
function getAttributeData(n, t) {
  for (var e = {}, o = t.getProgramParameter(n, t.ACTIVE_ATTRIBUTES), R = 0; R < o; R++) {
    var N = t.getActiveAttrib(n, R);
    if (N.name.indexOf("gl_") !== 0) {
      var M = mapType(t, N.type), D = {
        type: M,
        name: N.name,
        size: mapSize(M),
        location: t.getAttribLocation(n, N.name)
      };
      e[N.name] = D;
    }
  }
  return e;
}
function getUniformData(n, t) {
  for (var e = {}, o = t.getProgramParameter(n, t.ACTIVE_UNIFORMS), R = 0; R < o; R++) {
    var N = t.getActiveUniform(n, R), M = N.name.replace(/\[.*?\]$/, ""), D = !!N.name.match(/\[.*?\]$/), L = mapType(t, N.type);
    e[M] = {
      name: M,
      index: R,
      type: L,
      size: N.size,
      isArray: D,
      value: defaultValue(L, N.size)
    };
  }
  return e;
}
function generateProgram(n, t) {
  var e = compileShader(n, n.VERTEX_SHADER, t.vertexSrc), o = compileShader(n, n.FRAGMENT_SHADER, t.fragmentSrc), R = n.createProgram();
  if (n.attachShader(R, e), n.attachShader(R, o), n.linkProgram(R), n.getProgramParameter(R, n.LINK_STATUS) || logProgramError(n, R, e, o), t.attributeData = getAttributeData(R, n), t.uniformData = getUniformData(R, n), !/^[ \t]*#[ \t]*version[ \t]+300[ \t]+es[ \t]*$/m.test(t.vertexSrc)) {
    var N = Object.keys(t.attributeData);
    N.sort(function($, k) {
      return $ > k ? 1 : -1;
    });
    for (var M = 0; M < N.length; M++)
      t.attributeData[N[M]].location = M, n.bindAttribLocation(R, M, N[M]);
    n.linkProgram(R);
  }
  n.deleteShader(e), n.deleteShader(o);
  var D = {};
  for (var M in t.uniformData) {
    var L = t.uniformData[M];
    D[M] = {
      location: n.getUniformLocation(R, M),
      value: defaultValue(L.type, L.size)
    };
  }
  var B = new GLProgram(R, D);
  return B;
}
var UID = 0, defaultSyncData = { textureCount: 0, uboCount: 0 }, ShaderSystem = function() {
  function n(t) {
    this.destroyed = !1, this.renderer = t, this.systemCheck(), this.gl = null, this.shader = null, this.program = null, this.cache = {}, this._uboCache = {}, this.id = UID++;
  }
  return n.prototype.systemCheck = function() {
    if (!unsafeEvalSupported())
      throw new Error("Current environment does not allow unsafe-eval, please use @pixi/unsafe-eval module to enable support.");
  }, n.prototype.contextChange = function(t) {
    this.gl = t, this.reset();
  }, n.prototype.bind = function(t, e) {
    t.uniforms.globals = this.renderer.globalUniforms;
    var o = t.program, R = o.glPrograms[this.renderer.CONTEXT_UID] || this.generateProgram(t);
    return this.shader = t, this.program !== o && (this.program = o, this.gl.useProgram(R.program)), e || (defaultSyncData.textureCount = 0, defaultSyncData.uboCount = 0, this.syncUniformGroup(t.uniformGroup, defaultSyncData)), R;
  }, n.prototype.setUniforms = function(t) {
    var e = this.shader.program, o = e.glPrograms[this.renderer.CONTEXT_UID];
    e.syncUniforms(o.uniformData, t, this.renderer);
  }, n.prototype.syncUniformGroup = function(t, e) {
    var o = this.getGlProgram();
    (!t.static || t.dirtyId !== o.uniformDirtyGroups[t.id]) && (o.uniformDirtyGroups[t.id] = t.dirtyId, this.syncUniforms(t, o, e));
  }, n.prototype.syncUniforms = function(t, e, o) {
    var R = t.syncUniforms[this.shader.program.id] || this.createSyncGroups(t);
    R(e.uniformData, t.uniforms, this.renderer, o);
  }, n.prototype.createSyncGroups = function(t) {
    var e = this.getSignature(t, this.shader.program.uniformData, "u");
    return this.cache[e] || (this.cache[e] = generateUniformsSync(t, this.shader.program.uniformData)), t.syncUniforms[this.shader.program.id] = this.cache[e], t.syncUniforms[this.shader.program.id];
  }, n.prototype.syncUniformBufferGroup = function(t, e) {
    var o = this.getGlProgram();
    if (!t.static || t.dirtyId !== 0 || !o.uniformGroups[t.id]) {
      t.dirtyId = 0;
      var R = o.uniformGroups[t.id] || this.createSyncBufferGroup(t, o, e);
      t.buffer.update(), R(o.uniformData, t.uniforms, this.renderer, defaultSyncData, t.buffer);
    }
    this.renderer.buffer.bindBufferBase(t.buffer, o.uniformBufferBindings[e]);
  }, n.prototype.createSyncBufferGroup = function(t, e, o) {
    var R = this.renderer.gl;
    this.renderer.buffer.bind(t.buffer);
    var N = this.gl.getUniformBlockIndex(e.program, o);
    e.uniformBufferBindings[o] = this.shader.uniformBindCount, R.uniformBlockBinding(e.program, N, this.shader.uniformBindCount), this.shader.uniformBindCount++;
    var M = this.getSignature(t, this.shader.program.uniformData, "ubo"), D = this._uboCache[M];
    if (D || (D = this._uboCache[M] = generateUniformBufferSync(t, this.shader.program.uniformData)), t.autoManage) {
      var L = new Float32Array(D.size / 4);
      t.buffer.update(L);
    }
    return e.uniformGroups[t.id] = D.syncFunc, e.uniformGroups[t.id];
  }, n.prototype.getSignature = function(t, e, o) {
    var R = t.uniforms, N = [o + "-"];
    for (var M in R)
      N.push(M), e[M] && N.push(e[M].type);
    return N.join("-");
  }, n.prototype.getGlProgram = function() {
    return this.shader ? this.shader.program.glPrograms[this.renderer.CONTEXT_UID] : null;
  }, n.prototype.generateProgram = function(t) {
    var e = this.gl, o = t.program, R = generateProgram(e, o);
    return o.glPrograms[this.renderer.CONTEXT_UID] = R, R;
  }, n.prototype.reset = function() {
    this.program = null, this.shader = null;
  }, n.prototype.destroy = function() {
    this.renderer = null, this.destroyed = !0;
  }, n;
}();
function mapWebGLBlendModesToPixi(n, t) {
  return t === void 0 && (t = []), t[BLEND_MODES$5.NORMAL] = [n.ONE, n.ONE_MINUS_SRC_ALPHA], t[BLEND_MODES$5.ADD] = [n.ONE, n.ONE], t[BLEND_MODES$5.MULTIPLY] = [n.DST_COLOR, n.ONE_MINUS_SRC_ALPHA, n.ONE, n.ONE_MINUS_SRC_ALPHA], t[BLEND_MODES$5.SCREEN] = [n.ONE, n.ONE_MINUS_SRC_COLOR, n.ONE, n.ONE_MINUS_SRC_ALPHA], t[BLEND_MODES$5.OVERLAY] = [n.ONE, n.ONE_MINUS_SRC_ALPHA], t[BLEND_MODES$5.DARKEN] = [n.ONE, n.ONE_MINUS_SRC_ALPHA], t[BLEND_MODES$5.LIGHTEN] = [n.ONE, n.ONE_MINUS_SRC_ALPHA], t[BLEND_MODES$5.COLOR_DODGE] = [n.ONE, n.ONE_MINUS_SRC_ALPHA], t[BLEND_MODES$5.COLOR_BURN] = [n.ONE, n.ONE_MINUS_SRC_ALPHA], t[BLEND_MODES$5.HARD_LIGHT] = [n.ONE, n.ONE_MINUS_SRC_ALPHA], t[BLEND_MODES$5.SOFT_LIGHT] = [n.ONE, n.ONE_MINUS_SRC_ALPHA], t[BLEND_MODES$5.DIFFERENCE] = [n.ONE, n.ONE_MINUS_SRC_ALPHA], t[BLEND_MODES$5.EXCLUSION] = [n.ONE, n.ONE_MINUS_SRC_ALPHA], t[BLEND_MODES$5.HUE] = [n.ONE, n.ONE_MINUS_SRC_ALPHA], t[BLEND_MODES$5.SATURATION] = [n.ONE, n.ONE_MINUS_SRC_ALPHA], t[BLEND_MODES$5.COLOR] = [n.ONE, n.ONE_MINUS_SRC_ALPHA], t[BLEND_MODES$5.LUMINOSITY] = [n.ONE, n.ONE_MINUS_SRC_ALPHA], t[BLEND_MODES$5.NONE] = [0, 0], t[BLEND_MODES$5.NORMAL_NPM] = [n.SRC_ALPHA, n.ONE_MINUS_SRC_ALPHA, n.ONE, n.ONE_MINUS_SRC_ALPHA], t[BLEND_MODES$5.ADD_NPM] = [n.SRC_ALPHA, n.ONE, n.ONE, n.ONE], t[BLEND_MODES$5.SCREEN_NPM] = [n.SRC_ALPHA, n.ONE_MINUS_SRC_COLOR, n.ONE, n.ONE_MINUS_SRC_ALPHA], t[BLEND_MODES$5.SRC_IN] = [n.DST_ALPHA, n.ZERO], t[BLEND_MODES$5.SRC_OUT] = [n.ONE_MINUS_DST_ALPHA, n.ZERO], t[BLEND_MODES$5.SRC_ATOP] = [n.DST_ALPHA, n.ONE_MINUS_SRC_ALPHA], t[BLEND_MODES$5.DST_OVER] = [n.ONE_MINUS_DST_ALPHA, n.ONE], t[BLEND_MODES$5.DST_IN] = [n.ZERO, n.SRC_ALPHA], t[BLEND_MODES$5.DST_OUT] = [n.ZERO, n.ONE_MINUS_SRC_ALPHA], t[BLEND_MODES$5.DST_ATOP] = [n.ONE_MINUS_DST_ALPHA, n.SRC_ALPHA], t[BLEND_MODES$5.XOR] = [n.ONE_MINUS_DST_ALPHA, n.ONE_MINUS_SRC_ALPHA], t[BLEND_MODES$5.SUBTRACT] = [n.ONE, n.ONE, n.ONE, n.ONE, n.FUNC_REVERSE_SUBTRACT, n.FUNC_ADD], t;
}
var BLEND = 0, OFFSET = 1, CULLING = 2, DEPTH_TEST = 3, WINDING = 4, DEPTH_MASK = 5, StateSystem = function() {
  function n() {
    this.gl = null, this.stateId = 0, this.polygonOffset = 0, this.blendMode = BLEND_MODES$5.NONE, this._blendEq = !1, this.map = [], this.map[BLEND] = this.setBlend, this.map[OFFSET] = this.setOffset, this.map[CULLING] = this.setCullFace, this.map[DEPTH_TEST] = this.setDepthTest, this.map[WINDING] = this.setFrontFace, this.map[DEPTH_MASK] = this.setDepthMask, this.checks = [], this.defaultState = new State(), this.defaultState.blend = !0;
  }
  return n.prototype.contextChange = function(t) {
    this.gl = t, this.blendModes = mapWebGLBlendModesToPixi(t), this.set(this.defaultState), this.reset();
  }, n.prototype.set = function(t) {
    if (t = t || this.defaultState, this.stateId !== t.data) {
      for (var e = this.stateId ^ t.data, o = 0; e; )
        e & 1 && this.map[o].call(this, !!(t.data & 1 << o)), e = e >> 1, o++;
      this.stateId = t.data;
    }
    for (var o = 0; o < this.checks.length; o++)
      this.checks[o](this, t);
  }, n.prototype.forceState = function(t) {
    t = t || this.defaultState;
    for (var e = 0; e < this.map.length; e++)
      this.map[e].call(this, !!(t.data & 1 << e));
    for (var e = 0; e < this.checks.length; e++)
      this.checks[e](this, t);
    this.stateId = t.data;
  }, n.prototype.setBlend = function(t) {
    this.updateCheck(n.checkBlendMode, t), this.gl[t ? "enable" : "disable"](this.gl.BLEND);
  }, n.prototype.setOffset = function(t) {
    this.updateCheck(n.checkPolygonOffset, t), this.gl[t ? "enable" : "disable"](this.gl.POLYGON_OFFSET_FILL);
  }, n.prototype.setDepthTest = function(t) {
    this.gl[t ? "enable" : "disable"](this.gl.DEPTH_TEST);
  }, n.prototype.setDepthMask = function(t) {
    this.gl.depthMask(t);
  }, n.prototype.setCullFace = function(t) {
    this.gl[t ? "enable" : "disable"](this.gl.CULL_FACE);
  }, n.prototype.setFrontFace = function(t) {
    this.gl.frontFace(this.gl[t ? "CW" : "CCW"]);
  }, n.prototype.setBlendMode = function(t) {
    if (t !== this.blendMode) {
      this.blendMode = t;
      var e = this.blendModes[t], o = this.gl;
      e.length === 2 ? o.blendFunc(e[0], e[1]) : o.blendFuncSeparate(e[0], e[1], e[2], e[3]), e.length === 6 ? (this._blendEq = !0, o.blendEquationSeparate(e[4], e[5])) : this._blendEq && (this._blendEq = !1, o.blendEquationSeparate(o.FUNC_ADD, o.FUNC_ADD));
    }
  }, n.prototype.setPolygonOffset = function(t, e) {
    this.gl.polygonOffset(t, e);
  }, n.prototype.reset = function() {
    this.gl.pixelStorei(this.gl.UNPACK_FLIP_Y_WEBGL, !1), this.forceState(this.defaultState), this._blendEq = !0, this.blendMode = -1, this.setBlendMode(0);
  }, n.prototype.updateCheck = function(t, e) {
    var o = this.checks.indexOf(t);
    e && o === -1 ? this.checks.push(t) : !e && o !== -1 && this.checks.splice(o, 1);
  }, n.checkBlendMode = function(t, e) {
    t.setBlendMode(e.blendMode);
  }, n.checkPolygonOffset = function(t, e) {
    t.setPolygonOffset(1, e.polygonOffset);
  }, n.prototype.destroy = function() {
    this.gl = null;
  }, n;
}(), TextureGCSystem = function() {
  function n(t) {
    this.renderer = t, this.count = 0, this.checkCount = 0, this.maxIdle = settings$1.GC_MAX_IDLE, this.checkCountMax = settings$1.GC_MAX_CHECK_COUNT, this.mode = settings$1.GC_MODE;
  }
  return n.prototype.postrender = function() {
    !this.renderer.renderingToScreen || (this.count++, this.mode !== GC_MODES$5.MANUAL && (this.checkCount++, this.checkCount > this.checkCountMax && (this.checkCount = 0, this.run())));
  }, n.prototype.run = function() {
    for (var t = this.renderer.texture, e = t.managedTextures, o = !1, R = 0; R < e.length; R++) {
      var N = e[R];
      !N.framebuffer && this.count - N.touched > this.maxIdle && (t.destroyTexture(N, !0), e[R] = null, o = !0);
    }
    if (o) {
      for (var M = 0, R = 0; R < e.length; R++)
        e[R] !== null && (e[M++] = e[R]);
      e.length = M;
    }
  }, n.prototype.unload = function(t) {
    var e = this.renderer.texture, o = t._texture;
    o && !o.framebuffer && e.destroyTexture(o);
    for (var R = t.children.length - 1; R >= 0; R--)
      this.unload(t.children[R]);
  }, n.prototype.destroy = function() {
    this.renderer = null;
  }, n;
}();
function mapTypeAndFormatToInternalFormat(n) {
  var t, e, o, R, N, M, D, L, B, $, k, U, z, X, V, W, Y, q, Z, J, Q, K, rt;
  return "WebGL2RenderingContext" in globalThis && n instanceof globalThis.WebGL2RenderingContext ? rt = (t = {}, t[TYPES$5.UNSIGNED_BYTE] = (e = {}, e[FORMATS$5.RGBA] = n.RGBA8, e[FORMATS$5.RGB] = n.RGB8, e[FORMATS$5.RG] = n.RG8, e[FORMATS$5.RED] = n.R8, e[FORMATS$5.RGBA_INTEGER] = n.RGBA8UI, e[FORMATS$5.RGB_INTEGER] = n.RGB8UI, e[FORMATS$5.RG_INTEGER] = n.RG8UI, e[FORMATS$5.RED_INTEGER] = n.R8UI, e[FORMATS$5.ALPHA] = n.ALPHA, e[FORMATS$5.LUMINANCE] = n.LUMINANCE, e[FORMATS$5.LUMINANCE_ALPHA] = n.LUMINANCE_ALPHA, e), t[TYPES$5.BYTE] = (o = {}, o[FORMATS$5.RGBA] = n.RGBA8_SNORM, o[FORMATS$5.RGB] = n.RGB8_SNORM, o[FORMATS$5.RG] = n.RG8_SNORM, o[FORMATS$5.RED] = n.R8_SNORM, o[FORMATS$5.RGBA_INTEGER] = n.RGBA8I, o[FORMATS$5.RGB_INTEGER] = n.RGB8I, o[FORMATS$5.RG_INTEGER] = n.RG8I, o[FORMATS$5.RED_INTEGER] = n.R8I, o), t[TYPES$5.UNSIGNED_SHORT] = (R = {}, R[FORMATS$5.RGBA_INTEGER] = n.RGBA16UI, R[FORMATS$5.RGB_INTEGER] = n.RGB16UI, R[FORMATS$5.RG_INTEGER] = n.RG16UI, R[FORMATS$5.RED_INTEGER] = n.R16UI, R[FORMATS$5.DEPTH_COMPONENT] = n.DEPTH_COMPONENT16, R), t[TYPES$5.SHORT] = (N = {}, N[FORMATS$5.RGBA_INTEGER] = n.RGBA16I, N[FORMATS$5.RGB_INTEGER] = n.RGB16I, N[FORMATS$5.RG_INTEGER] = n.RG16I, N[FORMATS$5.RED_INTEGER] = n.R16I, N), t[TYPES$5.UNSIGNED_INT] = (M = {}, M[FORMATS$5.RGBA_INTEGER] = n.RGBA32UI, M[FORMATS$5.RGB_INTEGER] = n.RGB32UI, M[FORMATS$5.RG_INTEGER] = n.RG32UI, M[FORMATS$5.RED_INTEGER] = n.R32UI, M[FORMATS$5.DEPTH_COMPONENT] = n.DEPTH_COMPONENT24, M), t[TYPES$5.INT] = (D = {}, D[FORMATS$5.RGBA_INTEGER] = n.RGBA32I, D[FORMATS$5.RGB_INTEGER] = n.RGB32I, D[FORMATS$5.RG_INTEGER] = n.RG32I, D[FORMATS$5.RED_INTEGER] = n.R32I, D), t[TYPES$5.FLOAT] = (L = {}, L[FORMATS$5.RGBA] = n.RGBA32F, L[FORMATS$5.RGB] = n.RGB32F, L[FORMATS$5.RG] = n.RG32F, L[FORMATS$5.RED] = n.R32F, L[FORMATS$5.DEPTH_COMPONENT] = n.DEPTH_COMPONENT32F, L), t[TYPES$5.HALF_FLOAT] = (B = {}, B[FORMATS$5.RGBA] = n.RGBA16F, B[FORMATS$5.RGB] = n.RGB16F, B[FORMATS$5.RG] = n.RG16F, B[FORMATS$5.RED] = n.R16F, B), t[TYPES$5.UNSIGNED_SHORT_5_6_5] = ($ = {}, $[FORMATS$5.RGB] = n.RGB565, $), t[TYPES$5.UNSIGNED_SHORT_4_4_4_4] = (k = {}, k[FORMATS$5.RGBA] = n.RGBA4, k), t[TYPES$5.UNSIGNED_SHORT_5_5_5_1] = (U = {}, U[FORMATS$5.RGBA] = n.RGB5_A1, U), t[TYPES$5.UNSIGNED_INT_2_10_10_10_REV] = (z = {}, z[FORMATS$5.RGBA] = n.RGB10_A2, z[FORMATS$5.RGBA_INTEGER] = n.RGB10_A2UI, z), t[TYPES$5.UNSIGNED_INT_10F_11F_11F_REV] = (X = {}, X[FORMATS$5.RGB] = n.R11F_G11F_B10F, X), t[TYPES$5.UNSIGNED_INT_5_9_9_9_REV] = (V = {}, V[FORMATS$5.RGB] = n.RGB9_E5, V), t[TYPES$5.UNSIGNED_INT_24_8] = (W = {}, W[FORMATS$5.DEPTH_STENCIL] = n.DEPTH24_STENCIL8, W), t[TYPES$5.FLOAT_32_UNSIGNED_INT_24_8_REV] = (Y = {}, Y[FORMATS$5.DEPTH_STENCIL] = n.DEPTH32F_STENCIL8, Y), t) : rt = (q = {}, q[TYPES$5.UNSIGNED_BYTE] = (Z = {}, Z[FORMATS$5.RGBA] = n.RGBA, Z[FORMATS$5.RGB] = n.RGB, Z[FORMATS$5.ALPHA] = n.ALPHA, Z[FORMATS$5.LUMINANCE] = n.LUMINANCE, Z[FORMATS$5.LUMINANCE_ALPHA] = n.LUMINANCE_ALPHA, Z), q[TYPES$5.UNSIGNED_SHORT_5_6_5] = (J = {}, J[FORMATS$5.RGB] = n.RGB, J), q[TYPES$5.UNSIGNED_SHORT_4_4_4_4] = (Q = {}, Q[FORMATS$5.RGBA] = n.RGBA, Q), q[TYPES$5.UNSIGNED_SHORT_5_5_5_1] = (K = {}, K[FORMATS$5.RGBA] = n.RGBA, K), q), rt;
}
var GLTexture = function() {
  function n(t) {
    this.texture = t, this.width = -1, this.height = -1, this.dirtyId = -1, this.dirtyStyleId = -1, this.mipmap = !1, this.wrapMode = 33071, this.type = TYPES$5.UNSIGNED_BYTE, this.internalFormat = FORMATS$5.RGBA, this.samplerType = 0;
  }
  return n;
}(), TextureSystem = function() {
  function n(t) {
    this.renderer = t, this.boundTextures = [], this.currentLocation = -1, this.managedTextures = [], this._unknownBoundTextures = !1, this.unknownTexture = new BaseTexture(), this.hasIntegerTextures = !1;
  }
  return n.prototype.contextChange = function() {
    var t = this.gl = this.renderer.gl;
    this.CONTEXT_UID = this.renderer.CONTEXT_UID, this.webGLVersion = this.renderer.context.webGLVersion, this.internalFormats = mapTypeAndFormatToInternalFormat(t);
    var e = t.getParameter(t.MAX_TEXTURE_IMAGE_UNITS);
    this.boundTextures.length = e;
    for (var o = 0; o < e; o++)
      this.boundTextures[o] = null;
    this.emptyTextures = {};
    var R = new GLTexture(t.createTexture());
    t.bindTexture(t.TEXTURE_2D, R.texture), t.texImage2D(t.TEXTURE_2D, 0, t.RGBA, 1, 1, 0, t.RGBA, t.UNSIGNED_BYTE, new Uint8Array(4)), this.emptyTextures[t.TEXTURE_2D] = R, this.emptyTextures[t.TEXTURE_CUBE_MAP] = new GLTexture(t.createTexture()), t.bindTexture(t.TEXTURE_CUBE_MAP, this.emptyTextures[t.TEXTURE_CUBE_MAP].texture);
    for (var o = 0; o < 6; o++)
      t.texImage2D(t.TEXTURE_CUBE_MAP_POSITIVE_X + o, 0, t.RGBA, 1, 1, 0, t.RGBA, t.UNSIGNED_BYTE, null);
    t.texParameteri(t.TEXTURE_CUBE_MAP, t.TEXTURE_MAG_FILTER, t.LINEAR), t.texParameteri(t.TEXTURE_CUBE_MAP, t.TEXTURE_MIN_FILTER, t.LINEAR);
    for (var o = 0; o < this.boundTextures.length; o++)
      this.bind(null, o);
  }, n.prototype.bind = function(t, e) {
    e === void 0 && (e = 0);
    var o = this.gl;
    if (t = t == null ? void 0 : t.castToBaseTexture(), t && t.valid && !t.parentTextureArray) {
      t.touched = this.renderer.textureGC.count;
      var R = t._glTextures[this.CONTEXT_UID] || this.initTexture(t);
      this.boundTextures[e] !== t && (this.currentLocation !== e && (this.currentLocation = e, o.activeTexture(o.TEXTURE0 + e)), o.bindTexture(t.target, R.texture)), R.dirtyId !== t.dirtyId && (this.currentLocation !== e && (this.currentLocation = e, o.activeTexture(o.TEXTURE0 + e)), this.updateTexture(t)), this.boundTextures[e] = t;
    } else
      this.currentLocation !== e && (this.currentLocation = e, o.activeTexture(o.TEXTURE0 + e)), o.bindTexture(o.TEXTURE_2D, this.emptyTextures[o.TEXTURE_2D].texture), this.boundTextures[e] = null;
  }, n.prototype.reset = function() {
    this._unknownBoundTextures = !0, this.hasIntegerTextures = !1, this.currentLocation = -1;
    for (var t = 0; t < this.boundTextures.length; t++)
      this.boundTextures[t] = this.unknownTexture;
  }, n.prototype.unbind = function(t) {
    var e = this, o = e.gl, R = e.boundTextures;
    if (this._unknownBoundTextures) {
      this._unknownBoundTextures = !1;
      for (var N = 0; N < R.length; N++)
        R[N] === this.unknownTexture && this.bind(null, N);
    }
    for (var N = 0; N < R.length; N++)
      R[N] === t && (this.currentLocation !== N && (o.activeTexture(o.TEXTURE0 + N), this.currentLocation = N), o.bindTexture(t.target, this.emptyTextures[t.target].texture), R[N] = null);
  }, n.prototype.ensureSamplerType = function(t) {
    var e = this, o = e.boundTextures, R = e.hasIntegerTextures, N = e.CONTEXT_UID;
    if (!!R)
      for (var M = t - 1; M >= 0; --M) {
        var D = o[M];
        if (D) {
          var L = D._glTextures[N];
          L.samplerType !== SAMPLER_TYPES$5.FLOAT && this.renderer.texture.unbind(D);
        }
      }
  }, n.prototype.initTexture = function(t) {
    var e = new GLTexture(this.gl.createTexture());
    return e.dirtyId = -1, t._glTextures[this.CONTEXT_UID] = e, this.managedTextures.push(t), t.on("dispose", this.destroyTexture, this), e;
  }, n.prototype.initTextureType = function(t, e) {
    var o, R;
    e.internalFormat = (R = (o = this.internalFormats[t.type]) === null || o === void 0 ? void 0 : o[t.format]) !== null && R !== void 0 ? R : t.format, this.webGLVersion === 2 && t.type === TYPES$5.HALF_FLOAT ? e.type = this.gl.HALF_FLOAT : e.type = t.type;
  }, n.prototype.updateTexture = function(t) {
    var e = t._glTextures[this.CONTEXT_UID];
    if (!!e) {
      var o = this.renderer;
      if (this.initTextureType(t, e), t.resource && t.resource.upload(o, t, e))
        e.samplerType !== SAMPLER_TYPES$5.FLOAT && (this.hasIntegerTextures = !0);
      else {
        var R = t.realWidth, N = t.realHeight, M = o.gl;
        (e.width !== R || e.height !== N || e.dirtyId < 0) && (e.width = R, e.height = N, M.texImage2D(t.target, 0, e.internalFormat, R, N, 0, t.format, e.type, null));
      }
      t.dirtyStyleId !== e.dirtyStyleId && this.updateTextureStyle(t), e.dirtyId = t.dirtyId;
    }
  }, n.prototype.destroyTexture = function(t, e) {
    var o = this.gl;
    if (t = t.castToBaseTexture(), t._glTextures[this.CONTEXT_UID] && (this.unbind(t), o.deleteTexture(t._glTextures[this.CONTEXT_UID].texture), t.off("dispose", this.destroyTexture, this), delete t._glTextures[this.CONTEXT_UID], !e)) {
      var R = this.managedTextures.indexOf(t);
      R !== -1 && removeItems(this.managedTextures, R, 1);
    }
  }, n.prototype.updateTextureStyle = function(t) {
    var e = t._glTextures[this.CONTEXT_UID];
    !e || ((t.mipmap === MIPMAP_MODES$5.POW2 || this.webGLVersion !== 2) && !t.isPowerOfTwo ? e.mipmap = !1 : e.mipmap = t.mipmap >= 1, this.webGLVersion !== 2 && !t.isPowerOfTwo ? e.wrapMode = WRAP_MODES$5.CLAMP : e.wrapMode = t.wrapMode, t.resource && t.resource.style(this.renderer, t, e) || this.setStyle(t, e), e.dirtyStyleId = t.dirtyStyleId);
  }, n.prototype.setStyle = function(t, e) {
    var o = this.gl;
    if (e.mipmap && t.mipmap !== MIPMAP_MODES$5.ON_MANUAL && o.generateMipmap(t.target), o.texParameteri(t.target, o.TEXTURE_WRAP_S, e.wrapMode), o.texParameteri(t.target, o.TEXTURE_WRAP_T, e.wrapMode), e.mipmap) {
      o.texParameteri(t.target, o.TEXTURE_MIN_FILTER, t.scaleMode === SCALE_MODES$5.LINEAR ? o.LINEAR_MIPMAP_LINEAR : o.NEAREST_MIPMAP_NEAREST);
      var R = this.renderer.context.extensions.anisotropicFiltering;
      if (R && t.anisotropicLevel > 0 && t.scaleMode === SCALE_MODES$5.LINEAR) {
        var N = Math.min(t.anisotropicLevel, o.getParameter(R.MAX_TEXTURE_MAX_ANISOTROPY_EXT));
        o.texParameterf(t.target, R.TEXTURE_MAX_ANISOTROPY_EXT, N);
      }
    } else
      o.texParameteri(t.target, o.TEXTURE_MIN_FILTER, t.scaleMode === SCALE_MODES$5.LINEAR ? o.LINEAR : o.NEAREST);
    o.texParameteri(t.target, o.TEXTURE_MAG_FILTER, t.scaleMode === SCALE_MODES$5.LINEAR ? o.LINEAR : o.NEAREST);
  }, n.prototype.destroy = function() {
    this.renderer = null;
  }, n;
}(), tempMatrix = new Matrix(), AbstractRenderer = function(n) {
  __extends$q(t, n);
  function t(e, o) {
    e === void 0 && (e = RENDERER_TYPE$5.UNKNOWN);
    var R = n.call(this) || this;
    return o = Object.assign({}, settings$1.RENDER_OPTIONS, o), R.options = o, R.type = e, R.screen = new Rectangle(0, 0, o.width, o.height), R.view = o.view || settings$1.ADAPTER.createCanvas(), R.resolution = o.resolution || settings$1.RESOLUTION, R.useContextAlpha = o.useContextAlpha, R.autoDensity = !!o.autoDensity, R.preserveDrawingBuffer = o.preserveDrawingBuffer, R.clearBeforeRender = o.clearBeforeRender, R._backgroundColor = 0, R._backgroundColorRgba = [0, 0, 0, 1], R._backgroundColorString = "#000000", R.backgroundColor = o.backgroundColor || R._backgroundColor, R.backgroundAlpha = o.backgroundAlpha, o.transparent !== void 0 && (deprecation$1("6.0.0", "Option transparent is deprecated, please use backgroundAlpha instead."), R.useContextAlpha = o.transparent, R.backgroundAlpha = o.transparent ? 0 : 1), R._lastObjectRendered = null, R.plugins = {}, R;
  }
  return t.prototype.initPlugins = function(e) {
    for (var o in e)
      this.plugins[o] = new e[o](this);
  }, Object.defineProperty(t.prototype, "width", {
    get: function() {
      return this.view.width;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(t.prototype, "height", {
    get: function() {
      return this.view.height;
    },
    enumerable: !1,
    configurable: !0
  }), t.prototype.resize = function(e, o) {
    this.view.width = Math.round(e * this.resolution), this.view.height = Math.round(o * this.resolution);
    var R = this.view.width / this.resolution, N = this.view.height / this.resolution;
    this.screen.width = R, this.screen.height = N, this.autoDensity && (this.view.style.width = R + "px", this.view.style.height = N + "px"), this.emit("resize", R, N);
  }, t.prototype.generateTexture = function(e, o, R, N) {
    o === void 0 && (o = {}), typeof o == "number" && (deprecation$1("6.1.0", "generateTexture options (scaleMode, resolution, region) are now object options."), o = { scaleMode: o, resolution: R, region: N });
    var M = o.region, D = __rest$3(o, ["region"]);
    N = M || e.getLocalBounds(null, !0), N.width === 0 && (N.width = 1), N.height === 0 && (N.height = 1);
    var L = RenderTexture.create(__assign$8({ width: N.width, height: N.height }, D));
    return tempMatrix.tx = -N.x, tempMatrix.ty = -N.y, this.render(e, {
      renderTexture: L,
      clear: !1,
      transform: tempMatrix,
      skipUpdateTransform: !!e.parent
    }), L;
  }, t.prototype.destroy = function(e) {
    for (var o in this.plugins)
      this.plugins[o].destroy(), this.plugins[o] = null;
    e && this.view.parentNode && this.view.parentNode.removeChild(this.view);
    var R = this;
    R.plugins = null, R.type = RENDERER_TYPE$5.UNKNOWN, R.view = null, R.screen = null, R._tempDisplayObjectParent = null, R.options = null, this._backgroundColorRgba = null, this._backgroundColorString = null, this._lastObjectRendered = null;
  }, Object.defineProperty(t.prototype, "backgroundColor", {
    get: function() {
      return this._backgroundColor;
    },
    set: function(e) {
      this._backgroundColor = e, this._backgroundColorString = hex2string(e), hex2rgb(e, this._backgroundColorRgba);
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(t.prototype, "backgroundAlpha", {
    get: function() {
      return this._backgroundColorRgba[3];
    },
    set: function(e) {
      this._backgroundColorRgba[3] = e;
    },
    enumerable: !1,
    configurable: !0
  }), t;
}(EventEmitter$4), GLBuffer = function() {
  function n(t) {
    this.buffer = t || null, this.updateID = -1, this.byteLength = -1, this.refCount = 0;
  }
  return n;
}(), BufferSystem = function() {
  function n(t) {
    this.renderer = t, this.managedBuffers = {}, this.boundBufferBases = {};
  }
  return n.prototype.destroy = function() {
    this.renderer = null;
  }, n.prototype.contextChange = function() {
    this.disposeAll(!0), this.gl = this.renderer.gl, this.CONTEXT_UID = this.renderer.CONTEXT_UID;
  }, n.prototype.bind = function(t) {
    var e = this, o = e.gl, R = e.CONTEXT_UID, N = t._glBuffers[R] || this.createGLBuffer(t);
    o.bindBuffer(t.type, N.buffer);
  }, n.prototype.bindBufferBase = function(t, e) {
    var o = this, R = o.gl, N = o.CONTEXT_UID;
    if (this.boundBufferBases[e] !== t) {
      var M = t._glBuffers[N] || this.createGLBuffer(t);
      this.boundBufferBases[e] = t, R.bindBufferBase(R.UNIFORM_BUFFER, e, M.buffer);
    }
  }, n.prototype.bindBufferRange = function(t, e, o) {
    var R = this, N = R.gl, M = R.CONTEXT_UID;
    o = o || 0;
    var D = t._glBuffers[M] || this.createGLBuffer(t);
    N.bindBufferRange(N.UNIFORM_BUFFER, e || 0, D.buffer, o * 256, 256);
  }, n.prototype.update = function(t) {
    var e = this, o = e.gl, R = e.CONTEXT_UID, N = t._glBuffers[R];
    if (t._updateID !== N.updateID)
      if (N.updateID = t._updateID, o.bindBuffer(t.type, N.buffer), N.byteLength >= t.data.byteLength)
        o.bufferSubData(t.type, 0, t.data);
      else {
        var M = t.static ? o.STATIC_DRAW : o.DYNAMIC_DRAW;
        N.byteLength = t.data.byteLength, o.bufferData(t.type, t.data, M);
      }
  }, n.prototype.dispose = function(t, e) {
    if (!!this.managedBuffers[t.id]) {
      delete this.managedBuffers[t.id];
      var o = t._glBuffers[this.CONTEXT_UID], R = this.gl;
      t.disposeRunner.remove(this), o && (e || R.deleteBuffer(o.buffer), delete t._glBuffers[this.CONTEXT_UID]);
    }
  }, n.prototype.disposeAll = function(t) {
    for (var e = Object.keys(this.managedBuffers), o = 0; o < e.length; o++)
      this.dispose(this.managedBuffers[e[o]], t);
  }, n.prototype.createGLBuffer = function(t) {
    var e = this, o = e.CONTEXT_UID, R = e.gl;
    return t._glBuffers[o] = new GLBuffer(R.createBuffer()), this.managedBuffers[t.id] = t, t.disposeRunner.add(this), t._glBuffers[o];
  }, n;
}(), Renderer = function(n) {
  __extends$q(t, n);
  function t(e) {
    var o = n.call(this, RENDERER_TYPE$5.WEBGL, e) || this;
    return e = o.options, o.gl = null, o.CONTEXT_UID = 0, o.runners = {
      destroy: new Runner("destroy"),
      contextChange: new Runner("contextChange"),
      reset: new Runner("reset"),
      update: new Runner("update"),
      postrender: new Runner("postrender"),
      prerender: new Runner("prerender"),
      resize: new Runner("resize")
    }, o.runners.contextChange.add(o), o.globalUniforms = new UniformGroup({
      projectionMatrix: new Matrix()
    }, !0), o.addSystem(MaskSystem, "mask").addSystem(ContextSystem, "context").addSystem(StateSystem, "state").addSystem(ShaderSystem, "shader").addSystem(TextureSystem, "texture").addSystem(BufferSystem, "buffer").addSystem(GeometrySystem, "geometry").addSystem(FramebufferSystem, "framebuffer").addSystem(ScissorSystem, "scissor").addSystem(StencilSystem, "stencil").addSystem(ProjectionSystem, "projection").addSystem(TextureGCSystem, "textureGC").addSystem(FilterSystem, "filter").addSystem(RenderTextureSystem, "renderTexture").addSystem(BatchSystem, "batch"), o.initPlugins(t.__plugins), o.multisample = void 0, e.context ? o.context.initFromContext(e.context) : o.context.initFromOptions({
      alpha: !!o.useContextAlpha,
      antialias: e.antialias,
      premultipliedAlpha: o.useContextAlpha && o.useContextAlpha !== "notMultiplied",
      stencil: !0,
      preserveDrawingBuffer: e.preserveDrawingBuffer,
      powerPreference: o.options.powerPreference
    }), o.renderingToScreen = !0, sayHello(o.context.webGLVersion === 2 ? "WebGL 2" : "WebGL 1"), o.resize(o.options.width, o.options.height), o;
  }
  return t.create = function(e) {
    if (isWebGLSupported())
      return new t(e);
    throw new Error('WebGL unsupported in this browser, use "pixi.js-legacy" for fallback canvas2d support.');
  }, t.prototype.contextChange = function() {
    var e = this.gl, o;
    if (this.context.webGLVersion === 1) {
      var R = e.getParameter(e.FRAMEBUFFER_BINDING);
      e.bindFramebuffer(e.FRAMEBUFFER, null), o = e.getParameter(e.SAMPLES), e.bindFramebuffer(e.FRAMEBUFFER, R);
    } else {
      var R = e.getParameter(e.DRAW_FRAMEBUFFER_BINDING);
      e.bindFramebuffer(e.DRAW_FRAMEBUFFER, null), o = e.getParameter(e.SAMPLES), e.bindFramebuffer(e.DRAW_FRAMEBUFFER, R);
    }
    o >= MSAA_QUALITY$5.HIGH ? this.multisample = MSAA_QUALITY$5.HIGH : o >= MSAA_QUALITY$5.MEDIUM ? this.multisample = MSAA_QUALITY$5.MEDIUM : o >= MSAA_QUALITY$5.LOW ? this.multisample = MSAA_QUALITY$5.LOW : this.multisample = MSAA_QUALITY$5.NONE;
  }, t.prototype.addSystem = function(e, o) {
    var R = new e(this);
    if (this[o])
      throw new Error('Whoops! The name "' + o + '" is already in use');
    this[o] = R;
    for (var N in this.runners)
      this.runners[N].add(R);
    return this;
  }, t.prototype.render = function(e, o) {
    var R, N, M, D;
    if (o && (o instanceof RenderTexture ? (deprecation$1("6.0.0", "Renderer#render arguments changed, use options instead."), R = o, N = arguments[2], M = arguments[3], D = arguments[4]) : (R = o.renderTexture, N = o.clear, M = o.transform, D = o.skipUpdateTransform)), this.renderingToScreen = !R, this.runners.prerender.emit(), this.emit("prerender"), this.projection.transform = M, !this.context.isLost) {
      if (R || (this._lastObjectRendered = e), !D) {
        var L = e.enableTempParent();
        e.updateTransform(), e.disableTempParent(L);
      }
      this.renderTexture.bind(R), this.batch.currentRenderer.start(), (N !== void 0 ? N : this.clearBeforeRender) && this.renderTexture.clear(), e.render(this), this.batch.currentRenderer.flush(), R && R.baseTexture.update(), this.runners.postrender.emit(), this.projection.transform = null, this.emit("postrender");
    }
  }, t.prototype.generateTexture = function(e, o, R, N) {
    o === void 0 && (o = {});
    var M = n.prototype.generateTexture.call(this, e, o, R, N);
    return this.framebuffer.blit(), M;
  }, t.prototype.resize = function(e, o) {
    n.prototype.resize.call(this, e, o), this.runners.resize.emit(this.screen.height, this.screen.width);
  }, t.prototype.reset = function() {
    return this.runners.reset.emit(), this;
  }, t.prototype.clear = function() {
    this.renderTexture.bind(), this.renderTexture.clear();
  }, t.prototype.destroy = function(e) {
    this.runners.destroy.emit();
    for (var o in this.runners)
      this.runners[o].destroy();
    n.prototype.destroy.call(this, e), this.gl = null;
  }, Object.defineProperty(t.prototype, "extract", {
    get: function() {
      return deprecation$1("6.0.0", "Renderer#extract has been deprecated, please use Renderer#plugins.extract instead."), this.plugins.extract;
    },
    enumerable: !1,
    configurable: !0
  }), t.registerPlugin = function(e, o) {
    deprecation$1("6.5.0", "Renderer.registerPlugin() has been deprecated, please use extensions.add() instead."), extensions.add({
      name: e,
      type: ExtensionType.RendererPlugin,
      ref: o
    });
  }, t.__plugins = {}, t;
}(AbstractRenderer);
extensions.handleByMap(ExtensionType.RendererPlugin, Renderer.__plugins);
function autoDetectRenderer(n) {
  return Renderer.create(n);
}
var $defaultVertex = `attribute vec2 aVertexPosition;
attribute vec2 aTextureCoord;

uniform mat3 projectionMatrix;

varying vec2 vTextureCoord;

void main(void)
{
    gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);
    vTextureCoord = aTextureCoord;
}`, $defaultFilterVertex = `attribute vec2 aVertexPosition;

uniform mat3 projectionMatrix;

varying vec2 vTextureCoord;

uniform vec4 inputSize;
uniform vec4 outputFrame;

vec4 filterVertexPosition( void )
{
    vec2 position = aVertexPosition * max(outputFrame.zw, vec2(0.)) + outputFrame.xy;

    return vec4((projectionMatrix * vec3(position, 1.0)).xy, 0.0, 1.0);
}

vec2 filterTextureCoord( void )
{
    return aVertexPosition * (outputFrame.zw * inputSize.zw);
}

void main(void)
{
    gl_Position = filterVertexPosition();
    vTextureCoord = filterTextureCoord();
}
`, defaultVertex$1 = $defaultVertex, defaultFilterVertex = $defaultFilterVertex, BatchDrawCall = function() {
  function n() {
    this.texArray = null, this.blend = 0, this.type = DRAW_MODES$5.TRIANGLES, this.start = 0, this.size = 0, this.data = null;
  }
  return n;
}(), BatchTextureArray = function() {
  function n() {
    this.elements = [], this.ids = [], this.count = 0;
  }
  return n.prototype.clear = function() {
    for (var t = 0; t < this.count; t++)
      this.elements[t] = null;
    this.count = 0;
  }, n;
}(), ViewableBuffer = function() {
  function n(t) {
    typeof t == "number" ? this.rawBinaryData = new ArrayBuffer(t) : t instanceof Uint8Array ? this.rawBinaryData = t.buffer : this.rawBinaryData = t, this.uint32View = new Uint32Array(this.rawBinaryData), this.float32View = new Float32Array(this.rawBinaryData);
  }
  return Object.defineProperty(n.prototype, "int8View", {
    get: function() {
      return this._int8View || (this._int8View = new Int8Array(this.rawBinaryData)), this._int8View;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(n.prototype, "uint8View", {
    get: function() {
      return this._uint8View || (this._uint8View = new Uint8Array(this.rawBinaryData)), this._uint8View;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(n.prototype, "int16View", {
    get: function() {
      return this._int16View || (this._int16View = new Int16Array(this.rawBinaryData)), this._int16View;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(n.prototype, "uint16View", {
    get: function() {
      return this._uint16View || (this._uint16View = new Uint16Array(this.rawBinaryData)), this._uint16View;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(n.prototype, "int32View", {
    get: function() {
      return this._int32View || (this._int32View = new Int32Array(this.rawBinaryData)), this._int32View;
    },
    enumerable: !1,
    configurable: !0
  }), n.prototype.view = function(t) {
    return this[t + "View"];
  }, n.prototype.destroy = function() {
    this.rawBinaryData = null, this._int8View = null, this._uint8View = null, this._int16View = null, this._uint16View = null, this._int32View = null, this.uint32View = null, this.float32View = null;
  }, n.sizeOf = function(t) {
    switch (t) {
      case "int8":
      case "uint8":
        return 1;
      case "int16":
      case "uint16":
        return 2;
      case "int32":
      case "uint32":
      case "float32":
        return 4;
      default:
        throw new Error(t + " isn't a valid view type");
    }
  }, n;
}(), AbstractBatchRenderer = function(n) {
  __extends$q(t, n);
  function t(e) {
    var o = n.call(this, e) || this;
    return o.shaderGenerator = null, o.geometryClass = null, o.vertexSize = null, o.state = State.for2d(), o.size = settings$1.SPRITE_BATCH_SIZE * 4, o._vertexCount = 0, o._indexCount = 0, o._bufferedElements = [], o._bufferedTextures = [], o._bufferSize = 0, o._shader = null, o._packedGeometries = [], o._packedGeometryPoolSize = 2, o._flushId = 0, o._aBuffers = {}, o._iBuffers = {}, o.MAX_TEXTURES = 1, o.renderer.on("prerender", o.onPrerender, o), e.runners.contextChange.add(o), o._dcIndex = 0, o._aIndex = 0, o._iIndex = 0, o._attributeBuffer = null, o._indexBuffer = null, o._tempBoundTextures = [], o;
  }
  return t.prototype.contextChange = function() {
    var e = this.renderer.gl;
    settings$1.PREFER_ENV === ENV$5.WEBGL_LEGACY ? this.MAX_TEXTURES = 1 : (this.MAX_TEXTURES = Math.min(e.getParameter(e.MAX_TEXTURE_IMAGE_UNITS), settings$1.SPRITE_MAX_TEXTURES), this.MAX_TEXTURES = checkMaxIfStatementsInShader(this.MAX_TEXTURES, e)), this._shader = this.shaderGenerator.generateShader(this.MAX_TEXTURES);
    for (var o = 0; o < this._packedGeometryPoolSize; o++)
      this._packedGeometries[o] = new this.geometryClass();
    this.initFlushBuffers();
  }, t.prototype.initFlushBuffers = function() {
    for (var e = t._drawCallPool, o = t._textureArrayPool, R = this.size / 4, N = Math.floor(R / this.MAX_TEXTURES) + 1; e.length < R; )
      e.push(new BatchDrawCall());
    for (; o.length < N; )
      o.push(new BatchTextureArray());
    for (var M = 0; M < this.MAX_TEXTURES; M++)
      this._tempBoundTextures[M] = null;
  }, t.prototype.onPrerender = function() {
    this._flushId = 0;
  }, t.prototype.render = function(e) {
    !e._texture.valid || (this._vertexCount + e.vertexData.length / 2 > this.size && this.flush(), this._vertexCount += e.vertexData.length / 2, this._indexCount += e.indices.length, this._bufferedTextures[this._bufferSize] = e._texture.baseTexture, this._bufferedElements[this._bufferSize++] = e);
  }, t.prototype.buildTexturesAndDrawCalls = function() {
    var e = this, o = e._bufferedTextures, R = e.MAX_TEXTURES, N = t._textureArrayPool, M = this.renderer.batch, D = this._tempBoundTextures, L = this.renderer.textureGC.count, B = ++BaseTexture._globalBatch, $ = 0, k = N[0], U = 0;
    M.copyBoundTextures(D, R);
    for (var z = 0; z < this._bufferSize; ++z) {
      var X = o[z];
      o[z] = null, X._batchEnabled !== B && (k.count >= R && (M.boundArray(k, D, B, R), this.buildDrawCalls(k, U, z), U = z, k = N[++$], ++B), X._batchEnabled = B, X.touched = L, k.elements[k.count++] = X);
    }
    k.count > 0 && (M.boundArray(k, D, B, R), this.buildDrawCalls(k, U, this._bufferSize), ++$, ++B);
    for (var z = 0; z < D.length; z++)
      D[z] = null;
    BaseTexture._globalBatch = B;
  }, t.prototype.buildDrawCalls = function(e, o, R) {
    var N = this, M = N._bufferedElements, D = N._attributeBuffer, L = N._indexBuffer, B = N.vertexSize, $ = t._drawCallPool, k = this._dcIndex, U = this._aIndex, z = this._iIndex, X = $[k];
    X.start = this._iIndex, X.texArray = e;
    for (var V = o; V < R; ++V) {
      var W = M[V], Y = W._texture.baseTexture, q = premultiplyBlendMode[Y.alphaMode ? 1 : 0][W.blendMode];
      M[V] = null, o < V && X.blend !== q && (X.size = z - X.start, o = V, X = $[++k], X.texArray = e, X.start = z), this.packInterleavedGeometry(W, D, L, U, z), U += W.vertexData.length / 2 * B, z += W.indices.length, X.blend = q;
    }
    o < R && (X.size = z - X.start, ++k), this._dcIndex = k, this._aIndex = U, this._iIndex = z;
  }, t.prototype.bindAndClearTexArray = function(e) {
    for (var o = this.renderer.texture, R = 0; R < e.count; R++)
      o.bind(e.elements[R], e.ids[R]), e.elements[R] = null;
    e.count = 0;
  }, t.prototype.updateGeometry = function() {
    var e = this, o = e._packedGeometries, R = e._attributeBuffer, N = e._indexBuffer;
    settings$1.CAN_UPLOAD_SAME_BUFFER ? (o[this._flushId]._buffer.update(R.rawBinaryData), o[this._flushId]._indexBuffer.update(N), this.renderer.geometry.updateBuffers()) : (this._packedGeometryPoolSize <= this._flushId && (this._packedGeometryPoolSize++, o[this._flushId] = new this.geometryClass()), o[this._flushId]._buffer.update(R.rawBinaryData), o[this._flushId]._indexBuffer.update(N), this.renderer.geometry.bind(o[this._flushId]), this.renderer.geometry.updateBuffers(), this._flushId++);
  }, t.prototype.drawBatches = function() {
    for (var e = this._dcIndex, o = this.renderer, R = o.gl, N = o.state, M = t._drawCallPool, D = null, L = 0; L < e; L++) {
      var B = M[L], $ = B.texArray, k = B.type, U = B.size, z = B.start, X = B.blend;
      D !== $ && (D = $, this.bindAndClearTexArray($)), this.state.blendMode = X, N.set(this.state), R.drawElements(k, U, R.UNSIGNED_SHORT, z * 2);
    }
  }, t.prototype.flush = function() {
    this._vertexCount !== 0 && (this._attributeBuffer = this.getAttributeBuffer(this._vertexCount), this._indexBuffer = this.getIndexBuffer(this._indexCount), this._aIndex = 0, this._iIndex = 0, this._dcIndex = 0, this.buildTexturesAndDrawCalls(), this.updateGeometry(), this.drawBatches(), this._bufferSize = 0, this._vertexCount = 0, this._indexCount = 0);
  }, t.prototype.start = function() {
    this.renderer.state.set(this.state), this.renderer.texture.ensureSamplerType(this.MAX_TEXTURES), this.renderer.shader.bind(this._shader), settings$1.CAN_UPLOAD_SAME_BUFFER && this.renderer.geometry.bind(this._packedGeometries[this._flushId]);
  }, t.prototype.stop = function() {
    this.flush();
  }, t.prototype.destroy = function() {
    for (var e = 0; e < this._packedGeometryPoolSize; e++)
      this._packedGeometries[e] && this._packedGeometries[e].destroy();
    this.renderer.off("prerender", this.onPrerender, this), this._aBuffers = null, this._iBuffers = null, this._packedGeometries = null, this._attributeBuffer = null, this._indexBuffer = null, this._shader && (this._shader.destroy(), this._shader = null), n.prototype.destroy.call(this);
  }, t.prototype.getAttributeBuffer = function(e) {
    var o = nextPow2(Math.ceil(e / 8)), R = log2(o), N = o * 8;
    this._aBuffers.length <= R && (this._iBuffers.length = R + 1);
    var M = this._aBuffers[N];
    return M || (this._aBuffers[N] = M = new ViewableBuffer(N * this.vertexSize * 4)), M;
  }, t.prototype.getIndexBuffer = function(e) {
    var o = nextPow2(Math.ceil(e / 12)), R = log2(o), N = o * 12;
    this._iBuffers.length <= R && (this._iBuffers.length = R + 1);
    var M = this._iBuffers[R];
    return M || (this._iBuffers[R] = M = new Uint16Array(N)), M;
  }, t.prototype.packInterleavedGeometry = function(e, o, R, N, M) {
    for (var D = o.uint32View, L = o.float32View, B = N / this.vertexSize, $ = e.uvs, k = e.indices, U = e.vertexData, z = e._texture.baseTexture._batchLocation, X = Math.min(e.worldAlpha, 1), V = X < 1 && e._texture.baseTexture.alphaMode ? premultiplyTint(e._tintRGB, X) : e._tintRGB + (X * 255 << 24), W = 0; W < U.length; W += 2)
      L[N++] = U[W], L[N++] = U[W + 1], L[N++] = $[W], L[N++] = $[W + 1], D[N++] = V, L[N++] = z;
    for (var W = 0; W < k.length; W++)
      R[M++] = B + k[W];
  }, t._drawCallPool = [], t._textureArrayPool = [], t;
}(ObjectRenderer), BatchShaderGenerator = function() {
  function n(t, e) {
    if (this.vertexSrc = t, this.fragTemplate = e, this.programCache = {}, this.defaultGroupCache = {}, e.indexOf("%count%") < 0)
      throw new Error('Fragment template must contain "%count%".');
    if (e.indexOf("%forloop%") < 0)
      throw new Error('Fragment template must contain "%forloop%".');
  }
  return n.prototype.generateShader = function(t) {
    if (!this.programCache[t]) {
      for (var e = new Int32Array(t), o = 0; o < t; o++)
        e[o] = o;
      this.defaultGroupCache[t] = UniformGroup.from({ uSamplers: e }, !0);
      var R = this.fragTemplate;
      R = R.replace(/%count%/gi, "" + t), R = R.replace(/%forloop%/gi, this.generateSampleSrc(t)), this.programCache[t] = new Program(this.vertexSrc, R);
    }
    var N = {
      tint: new Float32Array([1, 1, 1, 1]),
      translationMatrix: new Matrix(),
      default: this.defaultGroupCache[t]
    };
    return new Shader(this.programCache[t], N);
  }, n.prototype.generateSampleSrc = function(t) {
    var e = "";
    e += `
`, e += `
`;
    for (var o = 0; o < t; o++)
      o > 0 && (e += `
else `), o < t - 1 && (e += "if(vTextureId < " + o + ".5)"), e += `
{`, e += `
	color = texture2D(uSamplers[` + o + "], vTextureCoord);", e += `
}`;
    return e += `
`, e += `
`, e;
  }, n;
}(), BatchGeometry = function(n) {
  __extends$q(t, n);
  function t(e) {
    e === void 0 && (e = !1);
    var o = n.call(this) || this;
    return o._buffer = new Buffer$1(null, e, !1), o._indexBuffer = new Buffer$1(null, e, !0), o.addAttribute("aVertexPosition", o._buffer, 2, !1, TYPES$5.FLOAT).addAttribute("aTextureCoord", o._buffer, 2, !1, TYPES$5.FLOAT).addAttribute("aColor", o._buffer, 4, !0, TYPES$5.UNSIGNED_BYTE).addAttribute("aTextureId", o._buffer, 1, !0, TYPES$5.FLOAT).addIndex(o._indexBuffer), o;
  }
  return t;
}(Geometry), defaultVertex = `precision highp float;
attribute vec2 aVertexPosition;
attribute vec2 aTextureCoord;
attribute vec4 aColor;
attribute float aTextureId;

uniform mat3 projectionMatrix;
uniform mat3 translationMatrix;
uniform vec4 tint;

varying vec2 vTextureCoord;
varying vec4 vColor;
varying float vTextureId;

void main(void){
    gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);

    vTextureCoord = aTextureCoord;
    vTextureId = aTextureId;
    vColor = aColor * tint;
}
`, defaultFragment = `varying vec2 vTextureCoord;
varying vec4 vColor;
varying float vTextureId;
uniform sampler2D uSamplers[%count%];

void main(void){
    vec4 color;
    %forloop%
    gl_FragColor = color * vColor;
}
`, BatchPluginFactory = function() {
  function n() {
  }
  return n.create = function(t) {
    var e = Object.assign({
      vertex: defaultVertex,
      fragment: defaultFragment,
      geometryClass: BatchGeometry,
      vertexSize: 6
    }, t), o = e.vertex, R = e.fragment, N = e.vertexSize, M = e.geometryClass;
    return function(D) {
      __extends$q(L, D);
      function L(B) {
        var $ = D.call(this, B) || this;
        return $.shaderGenerator = new BatchShaderGenerator(o, R), $.geometryClass = M, $.vertexSize = N, $;
      }
      return L;
    }(AbstractBatchRenderer);
  }, Object.defineProperty(n, "defaultVertexSrc", {
    get: function() {
      return defaultVertex;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(n, "defaultFragmentTemplate", {
    get: function() {
      return defaultFragment;
    },
    enumerable: !1,
    configurable: !0
  }), n;
}(), BatchRenderer = BatchPluginFactory.create();
Object.assign(BatchRenderer, {
  extension: {
    name: "batch",
    type: ExtensionType.RendererPlugin
  }
});
/*!
 * @pixi/loaders - v6.5.2
 * Compiled Wed, 24 Aug 2022 13:51:19 UTC
 *
 * @pixi/loaders is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
var SignalBinding = function() {
  function n(t, e, o) {
    e === void 0 && (e = !1), this._fn = t, this._once = e, this._thisArg = o, this._next = this._prev = this._owner = null;
  }
  return n.prototype.detach = function() {
    return this._owner === null ? !1 : (this._owner.detach(this), !0);
  }, n;
}();
function _addSignalBinding(n, t) {
  return n._head ? (n._tail._next = t, t._prev = n._tail, n._tail = t) : (n._head = t, n._tail = t), t._owner = n, t;
}
var Signal = function() {
  function n() {
    this._head = this._tail = void 0;
  }
  return n.prototype.handlers = function(t) {
    t === void 0 && (t = !1);
    var e = this._head;
    if (t)
      return !!e;
    for (var o = []; e; )
      o.push(e), e = e._next;
    return o;
  }, n.prototype.has = function(t) {
    if (!(t instanceof SignalBinding))
      throw new Error("MiniSignal#has(): First arg must be a SignalBinding object.");
    return t._owner === this;
  }, n.prototype.dispatch = function() {
    for (var t = arguments, e = [], o = 0; o < arguments.length; o++)
      e[o] = t[o];
    var R = this._head;
    if (!R)
      return !1;
    for (; R; )
      R._once && this.detach(R), R._fn.apply(R._thisArg, e), R = R._next;
    return !0;
  }, n.prototype.add = function(t, e) {
    if (e === void 0 && (e = null), typeof t != "function")
      throw new Error("MiniSignal#add(): First arg must be a Function.");
    return _addSignalBinding(this, new SignalBinding(t, !1, e));
  }, n.prototype.once = function(t, e) {
    if (e === void 0 && (e = null), typeof t != "function")
      throw new Error("MiniSignal#once(): First arg must be a Function.");
    return _addSignalBinding(this, new SignalBinding(t, !0, e));
  }, n.prototype.detach = function(t) {
    if (!(t instanceof SignalBinding))
      throw new Error("MiniSignal#detach(): First arg must be a SignalBinding object.");
    return t._owner !== this ? this : (t._prev && (t._prev._next = t._next), t._next && (t._next._prev = t._prev), t === this._head ? (this._head = t._next, t._next === null && (this._tail = null)) : t === this._tail && (this._tail = t._prev, this._tail._next = null), t._owner = null, this);
  }, n.prototype.detachAll = function() {
    var t = this._head;
    if (!t)
      return this;
    for (this._head = this._tail = null; t; )
      t._owner = null, t = t._next;
    return this;
  }, n;
}();
function parseUri(n, t) {
  t = t || {};
  for (var e = {
    key: ["source", "protocol", "authority", "userInfo", "user", "password", "host", "port", "relative", "path", "directory", "file", "query", "anchor"],
    q: {
      name: "queryKey",
      parser: /(?:^|&)([^&=]*)=?([^&]*)/g
    },
    parser: {
      strict: /^(?:([^:\/?#]+):)?(?:\/\/((?:(([^:@]*)(?::([^:@]*))?)?@)?([^:\/?#]*)(?::(\d*))?))?((((?:[^?#\/]*\/)*)([^?#]*))(?:\?([^#]*))?(?:#(.*))?)/,
      loose: /^(?:(?![^:@]+:[^:@\/]*@)([^:\/?#.]+):)?(?:\/\/)?((?:(([^:@]*)(?::([^:@]*))?)?@)?([^:\/?#]*)(?::(\d*))?)(((\/(?:[^?#](?![^?#\/]*\.[^?#\/.]+(?:[?#]|$)))*\/?)?([^?#\/]*))(?:\?([^#]*))?(?:#(.*))?)/
    }
  }, o = e.parser[t.strictMode ? "strict" : "loose"].exec(n), R = {}, N = 14; N--; )
    R[e.key[N]] = o[N] || "";
  return R[e.q.name] = {}, R[e.key[12]].replace(e.q.parser, function(M, D, L) {
    D && (R[e.q.name][D] = L);
  }), R;
}
var useXdr, tempAnchor = null, STATUS_NONE = 0, STATUS_OK = 200, STATUS_EMPTY = 204, STATUS_IE_BUG_EMPTY = 1223, STATUS_TYPE_OK = 2;
function _noop$1() {
}
function setExtMap(n, t, e) {
  t && t.indexOf(".") === 0 && (t = t.substring(1)), t && (n[t] = e);
}
function reqType(n) {
  return n.toString().replace("object ", "");
}
var LoaderResource = function() {
  function n(t, e, o) {
    if (this._dequeue = _noop$1, this._onLoadBinding = null, this._elementTimer = 0, this._boundComplete = null, this._boundOnError = null, this._boundOnProgress = null, this._boundOnTimeout = null, this._boundXhrOnError = null, this._boundXhrOnTimeout = null, this._boundXhrOnAbort = null, this._boundXhrOnLoad = null, typeof t != "string" || typeof e != "string")
      throw new Error("Both name and url are required for constructing a resource.");
    o = o || {}, this._flags = 0, this._setFlag(n.STATUS_FLAGS.DATA_URL, e.indexOf("data:") === 0), this.name = t, this.url = e, this.extension = this._getExtension(), this.data = null, this.crossOrigin = o.crossOrigin === !0 ? "anonymous" : o.crossOrigin, this.timeout = o.timeout || 0, this.loadType = o.loadType || this._determineLoadType(), this.xhrType = o.xhrType, this.metadata = o.metadata || {}, this.error = null, this.xhr = null, this.children = [], this.type = n.TYPE.UNKNOWN, this.progressChunk = 0, this._dequeue = _noop$1, this._onLoadBinding = null, this._elementTimer = 0, this._boundComplete = this.complete.bind(this), this._boundOnError = this._onError.bind(this), this._boundOnProgress = this._onProgress.bind(this), this._boundOnTimeout = this._onTimeout.bind(this), this._boundXhrOnError = this._xhrOnError.bind(this), this._boundXhrOnTimeout = this._xhrOnTimeout.bind(this), this._boundXhrOnAbort = this._xhrOnAbort.bind(this), this._boundXhrOnLoad = this._xhrOnLoad.bind(this), this.onStart = new Signal(), this.onProgress = new Signal(), this.onComplete = new Signal(), this.onAfterMiddleware = new Signal();
  }
  return n.setExtensionLoadType = function(t, e) {
    setExtMap(n._loadTypeMap, t, e);
  }, n.setExtensionXhrType = function(t, e) {
    setExtMap(n._xhrTypeMap, t, e);
  }, Object.defineProperty(n.prototype, "isDataUrl", {
    get: function() {
      return this._hasFlag(n.STATUS_FLAGS.DATA_URL);
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(n.prototype, "isComplete", {
    get: function() {
      return this._hasFlag(n.STATUS_FLAGS.COMPLETE);
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(n.prototype, "isLoading", {
    get: function() {
      return this._hasFlag(n.STATUS_FLAGS.LOADING);
    },
    enumerable: !1,
    configurable: !0
  }), n.prototype.complete = function() {
    this._clearEvents(), this._finish();
  }, n.prototype.abort = function(t) {
    if (!this.error) {
      if (this.error = new Error(t), this._clearEvents(), this.xhr)
        this.xhr.abort();
      else if (this.xdr)
        this.xdr.abort();
      else if (this.data)
        if (this.data.src)
          this.data.src = n.EMPTY_GIF;
        else
          for (; this.data.firstChild; )
            this.data.removeChild(this.data.firstChild);
      this._finish();
    }
  }, n.prototype.load = function(t) {
    var e = this;
    if (!this.isLoading) {
      if (this.isComplete) {
        t && setTimeout(function() {
          return t(e);
        }, 1);
        return;
      } else
        t && this.onComplete.once(t);
      switch (this._setFlag(n.STATUS_FLAGS.LOADING, !0), this.onStart.dispatch(this), (this.crossOrigin === !1 || typeof this.crossOrigin != "string") && (this.crossOrigin = this._determineCrossOrigin(this.url)), this.loadType) {
        case n.LOAD_TYPE.IMAGE:
          this.type = n.TYPE.IMAGE, this._loadElement("image");
          break;
        case n.LOAD_TYPE.AUDIO:
          this.type = n.TYPE.AUDIO, this._loadSourceElement("audio");
          break;
        case n.LOAD_TYPE.VIDEO:
          this.type = n.TYPE.VIDEO, this._loadSourceElement("video");
          break;
        case n.LOAD_TYPE.XHR:
        default:
          typeof useXdr > "u" && (useXdr = !!(globalThis.XDomainRequest && !("withCredentials" in new XMLHttpRequest()))), useXdr && this.crossOrigin ? this._loadXdr() : this._loadXhr();
          break;
      }
    }
  }, n.prototype._hasFlag = function(t) {
    return (this._flags & t) !== 0;
  }, n.prototype._setFlag = function(t, e) {
    this._flags = e ? this._flags | t : this._flags & ~t;
  }, n.prototype._clearEvents = function() {
    clearTimeout(this._elementTimer), this.data && this.data.removeEventListener && (this.data.removeEventListener("error", this._boundOnError, !1), this.data.removeEventListener("load", this._boundComplete, !1), this.data.removeEventListener("progress", this._boundOnProgress, !1), this.data.removeEventListener("canplaythrough", this._boundComplete, !1)), this.xhr && (this.xhr.removeEventListener ? (this.xhr.removeEventListener("error", this._boundXhrOnError, !1), this.xhr.removeEventListener("timeout", this._boundXhrOnTimeout, !1), this.xhr.removeEventListener("abort", this._boundXhrOnAbort, !1), this.xhr.removeEventListener("progress", this._boundOnProgress, !1), this.xhr.removeEventListener("load", this._boundXhrOnLoad, !1)) : (this.xhr.onerror = null, this.xhr.ontimeout = null, this.xhr.onprogress = null, this.xhr.onload = null));
  }, n.prototype._finish = function() {
    if (this.isComplete)
      throw new Error("Complete called again for an already completed resource.");
    this._setFlag(n.STATUS_FLAGS.COMPLETE, !0), this._setFlag(n.STATUS_FLAGS.LOADING, !1), this.onComplete.dispatch(this);
  }, n.prototype._loadElement = function(t) {
    this.metadata.loadElement ? this.data = this.metadata.loadElement : t === "image" && typeof globalThis.Image < "u" ? this.data = new Image() : this.data = document.createElement(t), this.crossOrigin && (this.data.crossOrigin = this.crossOrigin), this.metadata.skipSource || (this.data.src = this.url), this.data.addEventListener("error", this._boundOnError, !1), this.data.addEventListener("load", this._boundComplete, !1), this.data.addEventListener("progress", this._boundOnProgress, !1), this.timeout && (this._elementTimer = setTimeout(this._boundOnTimeout, this.timeout));
  }, n.prototype._loadSourceElement = function(t) {
    if (this.metadata.loadElement ? this.data = this.metadata.loadElement : t === "audio" && typeof globalThis.Audio < "u" ? this.data = new Audio() : this.data = document.createElement(t), this.data === null) {
      this.abort("Unsupported element: " + t);
      return;
    }
    if (this.crossOrigin && (this.data.crossOrigin = this.crossOrigin), !this.metadata.skipSource)
      if (navigator.isCocoonJS)
        this.data.src = Array.isArray(this.url) ? this.url[0] : this.url;
      else if (Array.isArray(this.url))
        for (var e = this.metadata.mimeType, o = 0; o < this.url.length; ++o)
          this.data.appendChild(this._createSource(t, this.url[o], Array.isArray(e) ? e[o] : e));
      else {
        var e = this.metadata.mimeType;
        this.data.appendChild(this._createSource(t, this.url, Array.isArray(e) ? e[0] : e));
      }
    this.data.addEventListener("error", this._boundOnError, !1), this.data.addEventListener("load", this._boundComplete, !1), this.data.addEventListener("progress", this._boundOnProgress, !1), this.data.addEventListener("canplaythrough", this._boundComplete, !1), this.data.load(), this.timeout && (this._elementTimer = setTimeout(this._boundOnTimeout, this.timeout));
  }, n.prototype._loadXhr = function() {
    typeof this.xhrType != "string" && (this.xhrType = this._determineXhrType());
    var t = this.xhr = new XMLHttpRequest();
    this.crossOrigin === "use-credentials" && (t.withCredentials = !0), t.open("GET", this.url, !0), t.timeout = this.timeout, this.xhrType === n.XHR_RESPONSE_TYPE.JSON || this.xhrType === n.XHR_RESPONSE_TYPE.DOCUMENT ? t.responseType = n.XHR_RESPONSE_TYPE.TEXT : t.responseType = this.xhrType, t.addEventListener("error", this._boundXhrOnError, !1), t.addEventListener("timeout", this._boundXhrOnTimeout, !1), t.addEventListener("abort", this._boundXhrOnAbort, !1), t.addEventListener("progress", this._boundOnProgress, !1), t.addEventListener("load", this._boundXhrOnLoad, !1), t.send();
  }, n.prototype._loadXdr = function() {
    typeof this.xhrType != "string" && (this.xhrType = this._determineXhrType());
    var t = this.xhr = new globalThis.XDomainRequest();
    t.timeout = this.timeout || 5e3, t.onerror = this._boundXhrOnError, t.ontimeout = this._boundXhrOnTimeout, t.onprogress = this._boundOnProgress, t.onload = this._boundXhrOnLoad, t.open("GET", this.url, !0), setTimeout(function() {
      return t.send();
    }, 1);
  }, n.prototype._createSource = function(t, e, o) {
    o || (o = t + "/" + this._getExtension(e));
    var R = document.createElement("source");
    return R.src = e, R.type = o, R;
  }, n.prototype._onError = function(t) {
    this.abort("Failed to load element using: " + t.target.nodeName);
  }, n.prototype._onProgress = function(t) {
    t && t.lengthComputable && this.onProgress.dispatch(this, t.loaded / t.total);
  }, n.prototype._onTimeout = function() {
    this.abort("Load timed out.");
  }, n.prototype._xhrOnError = function() {
    var t = this.xhr;
    this.abort(reqType(t) + " Request failed. Status: " + t.status + ', text: "' + t.statusText + '"');
  }, n.prototype._xhrOnTimeout = function() {
    var t = this.xhr;
    this.abort(reqType(t) + " Request timed out.");
  }, n.prototype._xhrOnAbort = function() {
    var t = this.xhr;
    this.abort(reqType(t) + " Request was aborted by the user.");
  }, n.prototype._xhrOnLoad = function() {
    var t = this.xhr, e = "", o = typeof t.status > "u" ? STATUS_OK : t.status;
    (t.responseType === "" || t.responseType === "text" || typeof t.responseType > "u") && (e = t.responseText), o === STATUS_NONE && (e.length > 0 || t.responseType === n.XHR_RESPONSE_TYPE.BUFFER) ? o = STATUS_OK : o === STATUS_IE_BUG_EMPTY && (o = STATUS_EMPTY);
    var R = o / 100 | 0;
    if (R === STATUS_TYPE_OK)
      if (this.xhrType === n.XHR_RESPONSE_TYPE.TEXT)
        this.data = e, this.type = n.TYPE.TEXT;
      else if (this.xhrType === n.XHR_RESPONSE_TYPE.JSON)
        try {
          this.data = JSON.parse(e), this.type = n.TYPE.JSON;
        } catch (D) {
          this.abort("Error trying to parse loaded json: " + D);
          return;
        }
      else if (this.xhrType === n.XHR_RESPONSE_TYPE.DOCUMENT)
        try {
          if (globalThis.DOMParser) {
            var N = new DOMParser();
            this.data = N.parseFromString(e, "text/xml");
          } else {
            var M = document.createElement("div");
            M.innerHTML = e, this.data = M;
          }
          this.type = n.TYPE.XML;
        } catch (D) {
          this.abort("Error trying to parse loaded xml: " + D);
          return;
        }
      else
        this.data = t.response || e;
    else {
      this.abort("[" + t.status + "] " + t.statusText + ": " + t.responseURL);
      return;
    }
    this.complete();
  }, n.prototype._determineCrossOrigin = function(t, e) {
    if (t.indexOf("data:") === 0)
      return "";
    if (globalThis.origin !== globalThis.location.origin)
      return "anonymous";
    e = e || globalThis.location, tempAnchor || (tempAnchor = document.createElement("a")), tempAnchor.href = t;
    var o = parseUri(tempAnchor.href, { strictMode: !0 }), R = !o.port && e.port === "" || o.port === e.port, N = o.protocol ? o.protocol + ":" : "";
    return o.host !== e.hostname || !R || N !== e.protocol ? "anonymous" : "";
  }, n.prototype._determineXhrType = function() {
    return n._xhrTypeMap[this.extension] || n.XHR_RESPONSE_TYPE.TEXT;
  }, n.prototype._determineLoadType = function() {
    return n._loadTypeMap[this.extension] || n.LOAD_TYPE.XHR;
  }, n.prototype._getExtension = function(t) {
    t === void 0 && (t = this.url);
    var e = "";
    if (this.isDataUrl) {
      var o = t.indexOf("/");
      e = t.substring(o + 1, t.indexOf(";", o));
    } else {
      var R = t.indexOf("?"), N = t.indexOf("#"), M = Math.min(R > -1 ? R : t.length, N > -1 ? N : t.length);
      t = t.substring(0, M), e = t.substring(t.lastIndexOf(".") + 1);
    }
    return e.toLowerCase();
  }, n.prototype._getMimeFromXhrType = function(t) {
    switch (t) {
      case n.XHR_RESPONSE_TYPE.BUFFER:
        return "application/octet-binary";
      case n.XHR_RESPONSE_TYPE.BLOB:
        return "application/blob";
      case n.XHR_RESPONSE_TYPE.DOCUMENT:
        return "application/xml";
      case n.XHR_RESPONSE_TYPE.JSON:
        return "application/json";
      case n.XHR_RESPONSE_TYPE.DEFAULT:
      case n.XHR_RESPONSE_TYPE.TEXT:
      default:
        return "text/plain";
    }
  }, n;
}();
(function(n) {
  (function(t) {
    t[t.NONE = 0] = "NONE", t[t.DATA_URL = 1] = "DATA_URL", t[t.COMPLETE = 2] = "COMPLETE", t[t.LOADING = 4] = "LOADING";
  })(n.STATUS_FLAGS || (n.STATUS_FLAGS = {})), function(t) {
    t[t.UNKNOWN = 0] = "UNKNOWN", t[t.JSON = 1] = "JSON", t[t.XML = 2] = "XML", t[t.IMAGE = 3] = "IMAGE", t[t.AUDIO = 4] = "AUDIO", t[t.VIDEO = 5] = "VIDEO", t[t.TEXT = 6] = "TEXT";
  }(n.TYPE || (n.TYPE = {})), function(t) {
    t[t.XHR = 1] = "XHR", t[t.IMAGE = 2] = "IMAGE", t[t.AUDIO = 3] = "AUDIO", t[t.VIDEO = 4] = "VIDEO";
  }(n.LOAD_TYPE || (n.LOAD_TYPE = {})), function(t) {
    t.DEFAULT = "text", t.BUFFER = "arraybuffer", t.BLOB = "blob", t.DOCUMENT = "document", t.JSON = "json", t.TEXT = "text";
  }(n.XHR_RESPONSE_TYPE || (n.XHR_RESPONSE_TYPE = {})), n._loadTypeMap = {
    gif: n.LOAD_TYPE.IMAGE,
    png: n.LOAD_TYPE.IMAGE,
    bmp: n.LOAD_TYPE.IMAGE,
    jpg: n.LOAD_TYPE.IMAGE,
    jpeg: n.LOAD_TYPE.IMAGE,
    tif: n.LOAD_TYPE.IMAGE,
    tiff: n.LOAD_TYPE.IMAGE,
    webp: n.LOAD_TYPE.IMAGE,
    tga: n.LOAD_TYPE.IMAGE,
    svg: n.LOAD_TYPE.IMAGE,
    "svg+xml": n.LOAD_TYPE.IMAGE,
    mp3: n.LOAD_TYPE.AUDIO,
    ogg: n.LOAD_TYPE.AUDIO,
    wav: n.LOAD_TYPE.AUDIO,
    mp4: n.LOAD_TYPE.VIDEO,
    webm: n.LOAD_TYPE.VIDEO
  }, n._xhrTypeMap = {
    xhtml: n.XHR_RESPONSE_TYPE.DOCUMENT,
    html: n.XHR_RESPONSE_TYPE.DOCUMENT,
    htm: n.XHR_RESPONSE_TYPE.DOCUMENT,
    xml: n.XHR_RESPONSE_TYPE.DOCUMENT,
    tmx: n.XHR_RESPONSE_TYPE.DOCUMENT,
    svg: n.XHR_RESPONSE_TYPE.DOCUMENT,
    tsx: n.XHR_RESPONSE_TYPE.DOCUMENT,
    gif: n.XHR_RESPONSE_TYPE.BLOB,
    png: n.XHR_RESPONSE_TYPE.BLOB,
    bmp: n.XHR_RESPONSE_TYPE.BLOB,
    jpg: n.XHR_RESPONSE_TYPE.BLOB,
    jpeg: n.XHR_RESPONSE_TYPE.BLOB,
    tif: n.XHR_RESPONSE_TYPE.BLOB,
    tiff: n.XHR_RESPONSE_TYPE.BLOB,
    webp: n.XHR_RESPONSE_TYPE.BLOB,
    tga: n.XHR_RESPONSE_TYPE.BLOB,
    json: n.XHR_RESPONSE_TYPE.JSON,
    text: n.XHR_RESPONSE_TYPE.TEXT,
    txt: n.XHR_RESPONSE_TYPE.TEXT,
    ttf: n.XHR_RESPONSE_TYPE.BUFFER,
    otf: n.XHR_RESPONSE_TYPE.BUFFER
  }, n.EMPTY_GIF = "data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACH5BAEAAAAALAAAAAABAAEAAAICRAEAOw==";
})(LoaderResource || (LoaderResource = {}));
function _noop() {
}
function onlyOnce(n) {
  return function() {
    for (var e = arguments, o = [], R = 0; R < arguments.length; R++)
      o[R] = e[R];
    if (n === null)
      throw new Error("Callback was already called.");
    var N = n;
    n = null, N.apply(this, o);
  };
}
var AsyncQueueItem = function() {
  function n(t, e) {
    this.data = t, this.callback = e;
  }
  return n;
}(), AsyncQueue = function() {
  function n(t, e) {
    var o = this;
    if (e === void 0 && (e = 1), this.workers = 0, this.saturated = _noop, this.unsaturated = _noop, this.empty = _noop, this.drain = _noop, this.error = _noop, this.started = !1, this.paused = !1, this._tasks = [], this._insert = function(R, N, M) {
      if (M && typeof M != "function")
        throw new Error("task callback must be a function");
      if (o.started = !0, R == null && o.idle()) {
        setTimeout(function() {
          return o.drain();
        }, 1);
        return;
      }
      var D = new AsyncQueueItem(R, typeof M == "function" ? M : _noop);
      N ? o._tasks.unshift(D) : o._tasks.push(D), setTimeout(o.process, 1);
    }, this.process = function() {
      for (; !o.paused && o.workers < o.concurrency && o._tasks.length; ) {
        var R = o._tasks.shift();
        o._tasks.length === 0 && o.empty(), o.workers += 1, o.workers === o.concurrency && o.saturated(), o._worker(R.data, onlyOnce(o._next(R)));
      }
    }, this._worker = t, e === 0)
      throw new Error("Concurrency must not be zero");
    this.concurrency = e, this.buffer = e / 4;
  }
  return n.prototype._next = function(t) {
    var e = this;
    return function() {
      for (var o = arguments, R = [], N = 0; N < arguments.length; N++)
        R[N] = o[N];
      e.workers -= 1, t.callback.apply(t, R), R[0] != null && e.error(R[0], t.data), e.workers <= e.concurrency - e.buffer && e.unsaturated(), e.idle() && e.drain(), e.process();
    };
  }, n.prototype.push = function(t, e) {
    this._insert(t, !1, e);
  }, n.prototype.kill = function() {
    this.workers = 0, this.drain = _noop, this.started = !1, this._tasks = [];
  }, n.prototype.unshift = function(t, e) {
    this._insert(t, !0, e);
  }, n.prototype.length = function() {
    return this._tasks.length;
  }, n.prototype.running = function() {
    return this.workers;
  }, n.prototype.idle = function() {
    return this._tasks.length + this.workers === 0;
  }, n.prototype.pause = function() {
    this.paused !== !0 && (this.paused = !0);
  }, n.prototype.resume = function() {
    if (this.paused !== !1) {
      this.paused = !1;
      for (var t = 1; t <= this.concurrency; t++)
        this.process();
    }
  }, n.eachSeries = function(t, e, o, R) {
    var N = 0, M = t.length;
    function D(L) {
      if (L || N === M) {
        o && o(L);
        return;
      }
      R ? setTimeout(function() {
        e(t[N++], D);
      }, 1) : e(t[N++], D);
    }
    D();
  }, n.queue = function(t, e) {
    return new n(t, e);
  }, n;
}(), MAX_PROGRESS = 100, rgxExtractUrlHash = /(#[\w-]+)?$/, Loader = function() {
  function n(t, e) {
    var o = this;
    t === void 0 && (t = ""), e === void 0 && (e = 10), this.progress = 0, this.loading = !1, this.defaultQueryString = "", this._beforeMiddleware = [], this._afterMiddleware = [], this._resourcesParsing = [], this._boundLoadResource = function(L, B) {
      return o._loadResource(L, B);
    }, this.resources = {}, this.baseUrl = t, this._beforeMiddleware = [], this._afterMiddleware = [], this._resourcesParsing = [], this._boundLoadResource = function(L, B) {
      return o._loadResource(L, B);
    }, this._queue = AsyncQueue.queue(this._boundLoadResource, e), this._queue.pause(), this.resources = {}, this.onProgress = new Signal(), this.onError = new Signal(), this.onLoad = new Signal(), this.onStart = new Signal(), this.onComplete = new Signal();
    for (var R = 0; R < n._plugins.length; ++R) {
      var N = n._plugins[R], M = N.pre, D = N.use;
      M && this.pre(M), D && this.use(D);
    }
    this._protected = !1;
  }
  return n.prototype._add = function(t, e, o, R) {
    if (this.loading && (!o || !o.parentResource))
      throw new Error("Cannot add resources while the loader is running.");
    if (this.resources[t])
      throw new Error('Resource named "' + t + '" already exists.');
    if (e = this._prepareUrl(e), this.resources[t] = new LoaderResource(t, e, o), typeof R == "function" && this.resources[t].onAfterMiddleware.once(R), this.loading) {
      for (var N = o.parentResource, M = [], D = 0; D < N.children.length; ++D)
        N.children[D].isComplete || M.push(N.children[D]);
      var L = N.progressChunk * (M.length + 1), B = L / (M.length + 2);
      N.children.push(this.resources[t]), N.progressChunk = B;
      for (var D = 0; D < M.length; ++D)
        M[D].progressChunk = B;
      this.resources[t].progressChunk = B;
    }
    return this._queue.push(this.resources[t]), this;
  }, n.prototype.pre = function(t) {
    return this._beforeMiddleware.push(t), this;
  }, n.prototype.use = function(t) {
    return this._afterMiddleware.push(t), this;
  }, n.prototype.reset = function() {
    this.progress = 0, this.loading = !1, this._queue.kill(), this._queue.pause();
    for (var t in this.resources) {
      var e = this.resources[t];
      e._onLoadBinding && e._onLoadBinding.detach(), e.isLoading && e.abort("loader reset");
    }
    return this.resources = {}, this;
  }, n.prototype.load = function(t) {
    if (deprecation$1("6.5.0", "@pixi/loaders is being replaced with @pixi/assets in the next major release."), typeof t == "function" && this.onComplete.once(t), this.loading)
      return this;
    if (this._queue.idle())
      this._onStart(), this._onComplete();
    else {
      for (var e = this._queue._tasks.length, o = MAX_PROGRESS / e, R = 0; R < this._queue._tasks.length; ++R)
        this._queue._tasks[R].data.progressChunk = o;
      this._onStart(), this._queue.resume();
    }
    return this;
  }, Object.defineProperty(n.prototype, "concurrency", {
    get: function() {
      return this._queue.concurrency;
    },
    set: function(t) {
      this._queue.concurrency = t;
    },
    enumerable: !1,
    configurable: !0
  }), n.prototype._prepareUrl = function(t) {
    var e = parseUri(t, { strictMode: !0 }), o;
    if (e.protocol || !e.path || t.indexOf("//") === 0 ? o = t : this.baseUrl.length && this.baseUrl.lastIndexOf("/") !== this.baseUrl.length - 1 && t.charAt(0) !== "/" ? o = this.baseUrl + "/" + t : o = this.baseUrl + t, this.defaultQueryString) {
      var R = rgxExtractUrlHash.exec(o)[0];
      o = o.slice(0, o.length - R.length), o.indexOf("?") !== -1 ? o += "&" + this.defaultQueryString : o += "?" + this.defaultQueryString, o += R;
    }
    return o;
  }, n.prototype._loadResource = function(t, e) {
    var o = this;
    t._dequeue = e, AsyncQueue.eachSeries(this._beforeMiddleware, function(R, N) {
      R.call(o, t, function() {
        N(t.isComplete ? {} : null);
      });
    }, function() {
      t.isComplete ? o._onLoad(t) : (t._onLoadBinding = t.onComplete.once(o._onLoad, o), t.load());
    }, !0);
  }, n.prototype._onStart = function() {
    this.progress = 0, this.loading = !0, this.onStart.dispatch(this);
  }, n.prototype._onComplete = function() {
    this.progress = MAX_PROGRESS, this.loading = !1, this.onComplete.dispatch(this, this.resources);
  }, n.prototype._onLoad = function(t) {
    var e = this;
    t._onLoadBinding = null, this._resourcesParsing.push(t), t._dequeue(), AsyncQueue.eachSeries(this._afterMiddleware, function(o, R) {
      o.call(e, t, R);
    }, function() {
      t.onAfterMiddleware.dispatch(t), e.progress = Math.min(MAX_PROGRESS, e.progress + t.progressChunk), e.onProgress.dispatch(e, t), t.error ? e.onError.dispatch(t.error, e, t) : e.onLoad.dispatch(e, t), e._resourcesParsing.splice(e._resourcesParsing.indexOf(t), 1), e._queue.idle() && e._resourcesParsing.length === 0 && e._onComplete();
    }, !0);
  }, n.prototype.destroy = function() {
    this._protected || this.reset();
  }, Object.defineProperty(n, "shared", {
    get: function() {
      var t = n._shared;
      return t || (t = new n(), t._protected = !0, n._shared = t), t;
    },
    enumerable: !1,
    configurable: !0
  }), n.registerPlugin = function(t) {
    return deprecation$1("6.5.0", "Loader.registerPlugin() is deprecated, use extensions.add() instead."), extensions.add({
      type: ExtensionType.Loader,
      ref: t
    }), n;
  }, n._plugins = [], n;
}();
extensions.handleByList(ExtensionType.Loader, Loader._plugins);
Loader.prototype.add = function(t, e, o, R) {
  if (Array.isArray(t)) {
    for (var N = 0; N < t.length; ++N)
      this.add(t[N]);
    return this;
  }
  if (typeof t == "object" && (o = t, R = e || o.callback || o.onComplete, e = o.url, t = o.name || o.key || o.url), typeof e != "string" && (R = o, o = e, e = t), typeof e != "string")
    throw new Error("No url passed to add resource to loader.");
  return typeof o == "function" && (R = o, o = null), this._add(t, e, o, R);
};
var AppLoaderPlugin = function() {
  function n() {
  }
  return n.init = function(t) {
    t = Object.assign({
      sharedLoader: !1
    }, t), this.loader = t.sharedLoader ? Loader.shared : new Loader();
  }, n.destroy = function() {
    this.loader && (this.loader.destroy(), this.loader = null);
  }, n.extension = ExtensionType.Application, n;
}(), TextureLoader = function() {
  function n() {
  }
  return n.add = function() {
    LoaderResource.setExtensionLoadType("svg", LoaderResource.LOAD_TYPE.XHR), LoaderResource.setExtensionXhrType("svg", LoaderResource.XHR_RESPONSE_TYPE.TEXT);
  }, n.use = function(t, e) {
    if (t.data && (t.type === LoaderResource.TYPE.IMAGE || t.extension === "svg")) {
      var o = t.data, R = t.url, N = t.name, M = t.metadata;
      Texture.fromLoader(o, R, N, M).then(function(D) {
        t.texture = D, e();
      }).catch(e);
    } else
      e();
  }, n.extension = ExtensionType.Loader, n;
}(), _keyStr = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
function encodeBinary(n) {
  for (var t = "", e = 0; e < n.length; ) {
    for (var o = [0, 0, 0], R = [0, 0, 0, 0], N = 0; N < o.length; ++N)
      e < n.length ? o[N] = n.charCodeAt(e++) & 255 : o[N] = 0;
    R[0] = o[0] >> 2, R[1] = (o[0] & 3) << 4 | o[1] >> 4, R[2] = (o[1] & 15) << 2 | o[2] >> 6, R[3] = o[2] & 63;
    var M = e - (n.length - 1);
    switch (M) {
      case 2:
        R[3] = 64, R[2] = 64;
        break;
      case 1:
        R[3] = 64;
        break;
    }
    for (var N = 0; N < R.length; ++N)
      t += _keyStr.charAt(R[N]);
  }
  return t;
}
function parsing(n, t) {
  if (!n.data) {
    t();
    return;
  }
  if (n.xhr && n.xhrType === LoaderResource.XHR_RESPONSE_TYPE.BLOB) {
    if (!self.Blob || typeof n.data == "string") {
      var e = n.xhr.getResponseHeader("content-type");
      if (e && e.indexOf("image") === 0) {
        n.data = new Image(), n.data.src = "data:" + e + ";base64," + encodeBinary(n.xhr.responseText), n.type = LoaderResource.TYPE.IMAGE, n.data.onload = function() {
          n.data.onload = null, t();
        };
        return;
      }
    } else if (n.data.type.indexOf("image") === 0) {
      var o = globalThis.URL || globalThis.webkitURL, R = o.createObjectURL(n.data);
      n.blob = n.data, n.data = new Image(), n.data.src = R, n.type = LoaderResource.TYPE.IMAGE, n.data.onload = function() {
        o.revokeObjectURL(R), n.data.onload = null, t();
      };
      return;
    }
  }
  t();
}
var ParsingLoader = function() {
  function n() {
  }
  return n.extension = ExtensionType.Loader, n.use = parsing, n;
}();
extensions.add(TextureLoader, ParsingLoader);
/*!
 * @pixi/sound - v4.3.0
 * https://github.com/pixijs/pixi-sound
 * Compiled Fri, 05 Aug 2022 20:12:47 UTC
 *
 * @pixi/sound is licensed under the MIT license.
 * http://www.opensource.org/licenses/mit-license
 */
var r;
function s() {
  return r;
}
var u = function(n, t) {
  return (u = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(e, o) {
    e.__proto__ = o;
  } || function(e, o) {
    for (var R in o)
      Object.prototype.hasOwnProperty.call(o, R) && (e[R] = o[R]);
  })(n, t);
};
function a(n, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Class extends value " + String(t) + " is not a constructor or null");
  function e() {
    this.constructor = n;
  }
  u(n, t), n.prototype = t === null ? Object.create(t) : (e.prototype = t.prototype, new e());
}
var c = function() {
  return (c = Object.assign || function(n) {
    for (var t, e = 1, o = arguments.length; e < o; e++)
      for (var R in t = arguments[e])
        Object.prototype.hasOwnProperty.call(t, R) && (n[R] = t[R]);
    return n;
  }).apply(this, arguments);
}, l = ["mp3", "ogg", "oga", "opus", "mpeg", "wav", "m4a", "aiff", "wma", "mid", "caf"], p$1 = {};
function h(n) {
  var t = c({ m4a: "audio/mp4", oga: "audio/ogg", opus: 'audio/ogg; codecs="opus"', caf: 'audio/x-caf; codecs="opus"' }, n || {}), e = document.createElement("audio"), o = {}, R = /^no$/;
  l.forEach(function(N) {
    var M = e.canPlayType("audio/".concat(N)).replace(R, ""), D = t[N] ? e.canPlayType(t[N]).replace(R, "") : "";
    o[N] = !!M || !!D;
  }), Object.assign(p$1, o);
}
h();
var f = /\.(\{([^\}]+)\})(\?.*)?$/;
function d(n) {
  var t = f, e = typeof n == "string" ? n : n.url;
  if (!t.test(e))
    return e;
  for (var o = t.exec(e), R = o[2].split(","), N = R[R.length - 1], M = 0, D = R.length; M < D; M++) {
    var L = R[M];
    if (p$1[L]) {
      N = L;
      break;
    }
  }
  var B = e.replace(o[1], N);
  if (typeof n != "string") {
    var $ = n;
    $.extension = N, $.url = B;
  }
  return B;
}
var _ = function() {
  function n() {
  }
  return n.add = function() {
    n.setLegacy(s().useLegacy);
  }, n.setLegacy = function(t) {
    var e = l;
    t ? e.forEach(function(o) {
      LoaderResource.setExtensionXhrType(o, LoaderResource.XHR_RESPONSE_TYPE.DEFAULT), LoaderResource.setExtensionLoadType(o, LoaderResource.LOAD_TYPE.AUDIO);
    }) : e.forEach(function(o) {
      LoaderResource.setExtensionXhrType(o, LoaderResource.XHR_RESPONSE_TYPE.BUFFER), LoaderResource.setExtensionLoadType(o, LoaderResource.LOAD_TYPE.XHR);
    });
  }, n.pre = function(t, e) {
    d(t), e();
  }, n.use = function(t, e) {
    t.data && l.indexOf(t.extension) > -1 ? t.sound = s().add(t.name, { loaded: e, preload: !0, url: t.url, source: t.data }) : e();
  }, n;
}(), y = 0, m = function(n) {
  function t(e) {
    var o = n.call(this) || this;
    return o.id = y++, o.init(e), o;
  }
  return a(t, n), t.prototype.set = function(e, o) {
    if (this[e] === void 0)
      throw new Error("Property with name ".concat(e, " does not exist."));
    switch (e) {
      case "speed":
        this.speed = o;
        break;
      case "volume":
        this.volume = o;
        break;
      case "paused":
        this.paused = o;
        break;
      case "loop":
        this.loop = o;
        break;
      case "muted":
        this.muted = o;
    }
    return this;
  }, Object.defineProperty(t.prototype, "progress", { get: function() {
    return this._source.currentTime / this._duration;
  }, enumerable: !1, configurable: !0 }), Object.defineProperty(t.prototype, "paused", { get: function() {
    return this._paused;
  }, set: function(e) {
    this._paused = e, this.refreshPaused();
  }, enumerable: !1, configurable: !0 }), t.prototype._onPlay = function() {
    this._playing = !0;
  }, t.prototype._onPause = function() {
    this._playing = !1;
  }, t.prototype.init = function(e) {
    this._playing = !1, this._duration = e.source.duration;
    var o = this._source = e.source.cloneNode(!1);
    o.src = e.parent.url, o.onplay = this._onPlay.bind(this), o.onpause = this._onPause.bind(this), e.context.on("refresh", this.refresh, this), e.context.on("refreshPaused", this.refreshPaused, this), this._media = e;
  }, t.prototype._internalStop = function() {
    this._source && this._playing && (this._source.onended = null, this._source.pause());
  }, t.prototype.stop = function() {
    this._internalStop(), this._source && this.emit("stop");
  }, Object.defineProperty(t.prototype, "speed", { get: function() {
    return this._speed;
  }, set: function(e) {
    this._speed = e, this.refresh();
  }, enumerable: !1, configurable: !0 }), Object.defineProperty(t.prototype, "volume", { get: function() {
    return this._volume;
  }, set: function(e) {
    this._volume = e, this.refresh();
  }, enumerable: !1, configurable: !0 }), Object.defineProperty(t.prototype, "loop", { get: function() {
    return this._loop;
  }, set: function(e) {
    this._loop = e, this.refresh();
  }, enumerable: !1, configurable: !0 }), Object.defineProperty(t.prototype, "muted", { get: function() {
    return this._muted;
  }, set: function(e) {
    this._muted = e, this.refresh();
  }, enumerable: !1, configurable: !0 }), Object.defineProperty(t.prototype, "filters", { get: function() {
    return null;
  }, set: function(e) {
  }, enumerable: !1, configurable: !0 }), t.prototype.refresh = function() {
    var e = this._media.context, o = this._media.parent;
    this._source.loop = this._loop || o.loop;
    var R = e.volume * (e.muted ? 0 : 1), N = o.volume * (o.muted ? 0 : 1), M = this._volume * (this._muted ? 0 : 1);
    this._source.volume = M * R * N, this._source.playbackRate = this._speed * e.speed * o.speed;
  }, t.prototype.refreshPaused = function() {
    var e = this._media.context, o = this._media.parent, R = this._paused || o.paused || e.paused;
    R !== this._pausedReal && (this._pausedReal = R, R ? (this._internalStop(), this.emit("paused")) : (this.emit("resumed"), this.play({ start: this._source.currentTime, end: this._end, volume: this._volume, speed: this._speed, loop: this._loop })), this.emit("pause", R));
  }, t.prototype.play = function(e) {
    var o = this, R = e.start, N = e.end, M = e.speed, D = e.loop, L = e.volume, B = e.muted;
    this._speed = M, this._volume = L, this._loop = !!D, this._muted = B, this.refresh(), this.loop && N !== null && (this.loop = !1), this._start = R, this._end = N || this._duration, this._start = Math.max(0, this._start - t.PADDING), this._end = Math.min(this._end + t.PADDING, this._duration), this._source.onloadedmetadata = function() {
      o._source && (o._source.currentTime = R, o._source.onloadedmetadata = null, o.emit("progress", R, o._duration), Ticker.shared.add(o._onUpdate, o));
    }, this._source.onended = this._onComplete.bind(this), this._source.play(), this.emit("start");
  }, t.prototype._onUpdate = function() {
    this.emit("progress", this.progress, this._duration), this._source.currentTime >= this._end && !this._source.loop && this._onComplete();
  }, t.prototype._onComplete = function() {
    Ticker.shared.remove(this._onUpdate, this), this._internalStop(), this.emit("progress", 1, this._duration), this.emit("end", this);
  }, t.prototype.destroy = function() {
    Ticker.shared.remove(this._onUpdate, this), this.removeAllListeners();
    var e = this._source;
    e && (e.onended = null, e.onplay = null, e.onpause = null, this._internalStop()), this._source = null, this._speed = 1, this._volume = 1, this._loop = !1, this._end = null, this._start = 0, this._duration = 0, this._playing = !1, this._pausedReal = !1, this._paused = !1, this._muted = !1, this._media && (this._media.context.off("refresh", this.refresh, this), this._media.context.off("refreshPaused", this.refreshPaused, this), this._media = null);
  }, t.prototype.toString = function() {
    return "[HTMLAudioInstance id=".concat(this.id, "]");
  }, t.PADDING = 0.1, t;
}(EventEmitter$4), g = function(n) {
  function t() {
    return n !== null && n.apply(this, arguments) || this;
  }
  return a(t, n), t.prototype.init = function(e) {
    this.parent = e, this._source = e.options.source || new Audio(), e.url && (this._source.src = e.url);
  }, t.prototype.create = function() {
    return new m(this);
  }, Object.defineProperty(t.prototype, "isPlayable", { get: function() {
    return !!this._source && this._source.readyState === 4;
  }, enumerable: !1, configurable: !0 }), Object.defineProperty(t.prototype, "duration", { get: function() {
    return this._source.duration;
  }, enumerable: !1, configurable: !0 }), Object.defineProperty(t.prototype, "context", { get: function() {
    return this.parent.context;
  }, enumerable: !1, configurable: !0 }), Object.defineProperty(t.prototype, "filters", { get: function() {
    return null;
  }, set: function(e) {
  }, enumerable: !1, configurable: !0 }), t.prototype.destroy = function() {
    this.removeAllListeners(), this.parent = null, this._source && (this._source.src = "", this._source.load(), this._source = null);
  }, Object.defineProperty(t.prototype, "source", { get: function() {
    return this._source;
  }, enumerable: !1, configurable: !0 }), t.prototype.load = function(e) {
    var o = this._source, R = this.parent;
    if (o.readyState !== 4)
      if (R.url) {
        o.src = R.url;
        var N = function() {
          L(), R.isLoaded = !0;
          var $ = R.autoPlayStart();
          e && e(null, R, $);
        }, M = function() {
          L(), e && e(new Error("Sound loading has been aborted"));
        }, D = function() {
          L();
          var $ = "Failed to load audio element (code: ".concat(o.error.code, ")");
          e && e(new Error($));
        }, L = function() {
          o.removeEventListener("canplaythrough", N), o.removeEventListener("load", N), o.removeEventListener("abort", M), o.removeEventListener("error", D);
        };
        o.addEventListener("canplaythrough", N, !1), o.addEventListener("load", N, !1), o.addEventListener("abort", M, !1), o.addEventListener("error", D, !1), o.load();
      } else
        e(new Error("sound.url or sound.source must be set"));
    else {
      R.isLoaded = !0;
      var B = R.autoPlayStart();
      e && setTimeout(function() {
        e(null, R, B);
      }, 0);
    }
  }, t;
}(EventEmitter$4), b = function() {
  function n(t, e) {
    this.parent = t, Object.assign(this, e), this.duration = this.end - this.start;
  }
  return n.prototype.play = function(t) {
    return this.parent.play({ complete: t, speed: this.speed || this.parent.speed, end: this.end, start: this.start, loop: this.loop });
  }, n.prototype.destroy = function() {
    this.parent = null;
  }, n;
}(), v = function() {
  function n() {
  }
  return n.setParamValue = function(t, e) {
    if (t.setValueAtTime) {
      var o = s().context;
      t.setValueAtTime(e, o.audioContext.currentTime);
    } else
      t.value = e;
    return e;
  }, n;
}(), P = 0, x$1 = function(n) {
  function t(e) {
    var o = n.call(this) || this;
    return o.id = P++, o._media = null, o._paused = !1, o._muted = !1, o._elapsed = 0, o.init(e), o;
  }
  return a(t, n), t.prototype.set = function(e, o) {
    if (this[e] === void 0)
      throw new Error("Property with name ".concat(e, " does not exist."));
    switch (e) {
      case "speed":
        this.speed = o;
        break;
      case "volume":
        this.volume = o;
        break;
      case "muted":
        this.muted = o;
        break;
      case "loop":
        this.loop = o;
        break;
      case "paused":
        this.paused = o;
    }
    return this;
  }, t.prototype.stop = function() {
    this._source && (this._internalStop(), this.emit("stop"));
  }, Object.defineProperty(t.prototype, "speed", { get: function() {
    return this._speed;
  }, set: function(e) {
    this._speed = e, this.refresh(), this._update(!0);
  }, enumerable: !1, configurable: !0 }), Object.defineProperty(t.prototype, "volume", { get: function() {
    return this._volume;
  }, set: function(e) {
    this._volume = e, this.refresh();
  }, enumerable: !1, configurable: !0 }), Object.defineProperty(t.prototype, "muted", { get: function() {
    return this._muted;
  }, set: function(e) {
    this._muted = e, this.refresh();
  }, enumerable: !1, configurable: !0 }), Object.defineProperty(t.prototype, "loop", { get: function() {
    return this._loop;
  }, set: function(e) {
    this._loop = e, this.refresh();
  }, enumerable: !1, configurable: !0 }), Object.defineProperty(t.prototype, "filters", { get: function() {
    return this._filters;
  }, set: function(e) {
    var o;
    this._filters && ((o = this._filters) === null || o === void 0 || o.filter(function(R) {
      return R;
    }).forEach(function(R) {
      return R.disconnect();
    }), this._filters = null, this._source.connect(this._gain)), this._filters = e != null && e.length ? e.slice(0) : null, this.refresh();
  }, enumerable: !1, configurable: !0 }), t.prototype.refresh = function() {
    if (this._source) {
      var e = this._media.context, o = this._media.parent;
      this._source.loop = this._loop || o.loop;
      var R = e.volume * (e.muted ? 0 : 1), N = o.volume * (o.muted ? 0 : 1), M = this._volume * (this._muted ? 0 : 1);
      v.setParamValue(this._gain.gain, M * N * R), v.setParamValue(this._source.playbackRate, this._speed * o.speed * e.speed), this.applyFilters();
    }
  }, t.prototype.applyFilters = function() {
    var e;
    if (!((e = this._filters) === null || e === void 0) && e.length) {
      this._source.disconnect();
      var o = this._source;
      this._filters.forEach(function(R) {
        o.connect(R.destination), o = R;
      }), o.connect(this._gain);
    }
  }, t.prototype.refreshPaused = function() {
    var e = this._media.context, o = this._media.parent, R = this._paused || o.paused || e.paused;
    R !== this._pausedReal && (this._pausedReal = R, R ? (this._internalStop(), this.emit("paused")) : (this.emit("resumed"), this.play({ start: this._elapsed % this._duration, end: this._end, speed: this._speed, loop: this._loop, volume: this._volume })), this.emit("pause", R));
  }, t.prototype.play = function(e) {
    var o = e.start, R = e.end, N = e.speed, M = e.loop, D = e.volume, L = e.muted, B = e.filters;
    this._paused = !1;
    var $ = this._media.nodes.cloneBufferSource(), k = $.source, U = $.gain;
    this._source = k, this._gain = U, this._speed = N, this._volume = D, this._loop = !!M, this._muted = L, this._filters = B, this.refresh();
    var z = this._source.buffer.duration;
    this._duration = z, this._end = R, this._lastUpdate = this._now(), this._elapsed = o, this._source.onended = this._onComplete.bind(this), this._loop ? (this._source.loopEnd = R, this._source.loopStart = o, this._source.start(0, o)) : R ? this._source.start(0, o, R - o) : this._source.start(0, o), this.emit("start"), this._update(!0), this.enableTicker(!0);
  }, t.prototype.enableTicker = function(e) {
    Ticker.shared.remove(this._updateListener, this), e && Ticker.shared.add(this._updateListener, this);
  }, Object.defineProperty(t.prototype, "progress", { get: function() {
    return this._progress;
  }, enumerable: !1, configurable: !0 }), Object.defineProperty(t.prototype, "paused", { get: function() {
    return this._paused;
  }, set: function(e) {
    this._paused = e, this.refreshPaused();
  }, enumerable: !1, configurable: !0 }), t.prototype.destroy = function() {
    var e;
    this.removeAllListeners(), this._internalStop(), this._gain && (this._gain.disconnect(), this._gain = null), this._media && (this._media.context.events.off("refresh", this.refresh, this), this._media.context.events.off("refreshPaused", this.refreshPaused, this), this._media = null), (e = this._filters) === null || e === void 0 || e.forEach(function(o) {
      return o.disconnect();
    }), this._filters = null, this._end = null, this._speed = 1, this._volume = 1, this._loop = !1, this._elapsed = 0, this._duration = 0, this._paused = !1, this._muted = !1, this._pausedReal = !1;
  }, t.prototype.toString = function() {
    return "[WebAudioInstance id=".concat(this.id, "]");
  }, t.prototype._now = function() {
    return this._media.context.audioContext.currentTime;
  }, t.prototype._updateListener = function() {
    this._update();
  }, t.prototype._update = function(e) {
    if (e === void 0 && (e = !1), this._source) {
      var o = this._now(), R = o - this._lastUpdate;
      if (R > 0 || e) {
        var N = this._source.playbackRate.value;
        this._elapsed += R * N, this._lastUpdate = o;
        var M = this._duration, D = void 0;
        if (this._source.loopStart) {
          var L = this._source.loopEnd - this._source.loopStart;
          D = (this._source.loopStart + this._elapsed % L) / M;
        } else
          D = this._elapsed % M / M;
        this._progress = D, this.emit("progress", this._progress, M);
      }
    }
  }, t.prototype.init = function(e) {
    this._media = e, e.context.events.on("refresh", this.refresh, this), e.context.events.on("refreshPaused", this.refreshPaused, this);
  }, t.prototype._internalStop = function() {
    if (this._source) {
      this.enableTicker(!1), this._source.onended = null, this._source.stop(0), this._source.disconnect();
      try {
        this._source.buffer = null;
      } catch {
      }
      this._source = null;
    }
  }, t.prototype._onComplete = function() {
    if (this._source) {
      this.enableTicker(!1), this._source.onended = null, this._source.disconnect();
      try {
        this._source.buffer = null;
      } catch {
      }
    }
    this._source = null, this._progress = 1, this.emit("progress", 1, this._duration), this.emit("end", this);
  }, t;
}(EventEmitter$4), O = function() {
  function n(t, e) {
    this._output = e, this._input = t;
  }
  return Object.defineProperty(n.prototype, "destination", { get: function() {
    return this._input;
  }, enumerable: !1, configurable: !0 }), Object.defineProperty(n.prototype, "filters", { get: function() {
    return this._filters;
  }, set: function(t) {
    var e = this;
    if (this._filters && (this._filters.forEach(function(R) {
      R && R.disconnect();
    }), this._filters = null, this._input.connect(this._output)), t && t.length) {
      this._filters = t.slice(0), this._input.disconnect();
      var o = null;
      t.forEach(function(R) {
        o === null ? e._input.connect(R.destination) : o.connect(R.destination), o = R;
      }), o.connect(this._output);
    }
  }, enumerable: !1, configurable: !0 }), n.prototype.destroy = function() {
    this.filters = null, this._input = null, this._output = null;
  }, n;
}(), j = function(n) {
  function t(e) {
    var o = this, R = e.audioContext, N = R.createBufferSource(), M = R.createGain(), D = R.createAnalyser();
    return N.connect(D), D.connect(M), M.connect(e.destination), (o = n.call(this, D, M) || this).context = e, o.bufferSource = N, o.gain = M, o.analyser = D, o;
  }
  return a(t, n), Object.defineProperty(t.prototype, "script", { get: function() {
    return this._script || (this._script = this.context.audioContext.createScriptProcessor(t.BUFFER_SIZE), this._script.connect(this.context.destination)), this._script;
  }, enumerable: !1, configurable: !0 }), t.prototype.destroy = function() {
    n.prototype.destroy.call(this), this.bufferSource.disconnect(), this._script && this._script.disconnect(), this.gain.disconnect(), this.analyser.disconnect(), this.bufferSource = null, this._script = null, this.gain = null, this.analyser = null, this.context = null;
  }, t.prototype.cloneBufferSource = function() {
    var e = this.bufferSource, o = this.context.audioContext.createBufferSource();
    o.buffer = e.buffer, v.setParamValue(o.playbackRate, e.playbackRate.value), o.loop = e.loop;
    var R = this.context.audioContext.createGain();
    return o.connect(R), R.connect(this.destination), { source: o, gain: R };
  }, Object.defineProperty(t.prototype, "bufferSize", { get: function() {
    return this.script.bufferSize;
  }, enumerable: !1, configurable: !0 }), t.BUFFER_SIZE = 0, t;
}(O), w = function() {
  function n() {
  }
  return n.prototype.init = function(t) {
    this.parent = t, this._nodes = new j(this.context), this._source = this._nodes.bufferSource, this.source = t.options.source;
  }, n.prototype.destroy = function() {
    this.parent = null, this._nodes.destroy(), this._nodes = null;
    try {
      this._source.buffer = null;
    } catch {
    }
    this._source = null, this.source = null;
  }, n.prototype.create = function() {
    return new x$1(this);
  }, Object.defineProperty(n.prototype, "context", { get: function() {
    return this.parent.context;
  }, enumerable: !1, configurable: !0 }), Object.defineProperty(n.prototype, "isPlayable", { get: function() {
    return !!this._source && !!this._source.buffer;
  }, enumerable: !1, configurable: !0 }), Object.defineProperty(n.prototype, "filters", { get: function() {
    return this._nodes.filters;
  }, set: function(t) {
    this._nodes.filters = t;
  }, enumerable: !1, configurable: !0 }), Object.defineProperty(n.prototype, "duration", { get: function() {
    return this._source.buffer.duration;
  }, enumerable: !1, configurable: !0 }), Object.defineProperty(n.prototype, "buffer", { get: function() {
    return this._source.buffer;
  }, set: function(t) {
    this._source.buffer = t;
  }, enumerable: !1, configurable: !0 }), Object.defineProperty(n.prototype, "nodes", { get: function() {
    return this._nodes;
  }, enumerable: !1, configurable: !0 }), n.prototype.load = function(t) {
    this.source ? this._decode(this.source, t) : this.parent.url ? this._loadUrl(t) : t && t(new Error("sound.url or sound.source must be set"));
  }, n.prototype._loadUrl = function(t) {
    var e = this, o = new XMLHttpRequest(), R = this.parent.url;
    o.open("GET", R, !0), o.responseType = "arraybuffer", o.onload = function() {
      e.source = o.response, e._decode(o.response, t);
    }, o.send();
  }, n.prototype._decode = function(t, e) {
    var o = this, R = function(N, M) {
      if (N)
        e && e(N);
      else {
        o.parent.isLoaded = !0, o.buffer = M;
        var D = o.parent.autoPlayStart();
        e && e(null, o.parent, D);
      }
    };
    t instanceof AudioBuffer ? R(null, t) : this.parent.context.decode(t, R);
  }, n;
}(), A = function() {
  function n(t, e) {
    this.media = t, this.options = e, this._instances = [], this._sprites = {}, this.media.init(this);
    var o = e.complete;
    this._autoPlayOptions = o ? { complete: o } : null, this.isLoaded = !1, this.isPlaying = !1, this.autoPlay = e.autoPlay, this.singleInstance = e.singleInstance, this.preload = e.preload || this.autoPlay, this.url = e.url, this.speed = e.speed, this.volume = e.volume, this.loop = e.loop, e.sprites && this.addSprites(e.sprites), this.preload && this._preload(e.loaded);
  }
  return n.from = function(t) {
    var e = {};
    return typeof t == "string" ? e.url = t : t instanceof ArrayBuffer || t instanceof AudioBuffer || t instanceof HTMLAudioElement ? e.source = t : e = t, (e = c({ autoPlay: !1, singleInstance: !1, url: null, source: null, preload: !1, volume: 1, speed: 1, complete: null, loaded: null, loop: !1 }, e)).url && (e.url = d(e.url)), Object.freeze(e), new n(s().useLegacy ? new g() : new w(), e);
  }, Object.defineProperty(n.prototype, "context", { get: function() {
    return s().context;
  }, enumerable: !1, configurable: !0 }), n.prototype.pause = function() {
    return this.isPlaying = !1, this.paused = !0, this;
  }, n.prototype.resume = function() {
    return this.isPlaying = this._instances.length > 0, this.paused = !1, this;
  }, Object.defineProperty(n.prototype, "paused", { get: function() {
    return this._paused;
  }, set: function(t) {
    this._paused = t, this.refreshPaused();
  }, enumerable: !1, configurable: !0 }), Object.defineProperty(n.prototype, "speed", { get: function() {
    return this._speed;
  }, set: function(t) {
    this._speed = t, this.refresh();
  }, enumerable: !1, configurable: !0 }), Object.defineProperty(n.prototype, "filters", { get: function() {
    return this.media.filters;
  }, set: function(t) {
    this.media.filters = t;
  }, enumerable: !1, configurable: !0 }), n.prototype.addSprites = function(t, e) {
    if (typeof t == "object") {
      var o = {};
      for (var R in t)
        o[R] = this.addSprites(R, t[R]);
      return o;
    }
    var N = new b(this, e);
    return this._sprites[t] = N, N;
  }, n.prototype.destroy = function() {
    this._removeInstances(), this.removeSprites(), this.media.destroy(), this.media = null, this._sprites = null, this._instances = null;
  }, n.prototype.removeSprites = function(t) {
    if (t) {
      var e = this._sprites[t];
      e !== void 0 && (e.destroy(), delete this._sprites[t]);
    } else
      for (var o in this._sprites)
        this.removeSprites(o);
    return this;
  }, Object.defineProperty(n.prototype, "isPlayable", { get: function() {
    return this.isLoaded && this.media && this.media.isPlayable;
  }, enumerable: !1, configurable: !0 }), n.prototype.stop = function() {
    if (!this.isPlayable)
      return this.autoPlay = !1, this._autoPlayOptions = null, this;
    this.isPlaying = !1;
    for (var t = this._instances.length - 1; t >= 0; t--)
      this._instances[t].stop();
    return this;
  }, n.prototype.play = function(t, e) {
    var o, R = this;
    if (typeof t == "string" ? o = { sprite: M = t, loop: this.loop, complete: e } : typeof t == "function" ? (o = {}).complete = t : o = t, (o = c({ complete: null, loaded: null, sprite: null, end: null, start: 0, volume: 1, speed: 1, muted: !1, loop: !1 }, o || {})).sprite) {
      var N = o.sprite, M = this._sprites[N];
      o.start = M.start + (o.start || 0), o.end = M.end, o.speed = M.speed || 1, o.loop = M.loop || o.loop, delete o.sprite;
    }
    if (o.offset && (o.start = o.offset), !this.isLoaded)
      return new Promise(function(L, B) {
        R.autoPlay = !0, R._autoPlayOptions = o, R._preload(function($, k, U) {
          $ ? B($) : (o.loaded && o.loaded($, k, U), L(U));
        });
      });
    (this.singleInstance || o.singleInstance) && this._removeInstances();
    var D = this._createInstance();
    return this._instances.push(D), this.isPlaying = !0, D.once("end", function() {
      o.complete && o.complete(R), R._onComplete(D);
    }), D.once("stop", function() {
      R._onComplete(D);
    }), D.play(o), D;
  }, n.prototype.refresh = function() {
    for (var t = this._instances.length, e = 0; e < t; e++)
      this._instances[e].refresh();
  }, n.prototype.refreshPaused = function() {
    for (var t = this._instances.length, e = 0; e < t; e++)
      this._instances[e].refreshPaused();
  }, Object.defineProperty(n.prototype, "volume", { get: function() {
    return this._volume;
  }, set: function(t) {
    this._volume = t, this.refresh();
  }, enumerable: !1, configurable: !0 }), Object.defineProperty(n.prototype, "muted", { get: function() {
    return this._muted;
  }, set: function(t) {
    this._muted = t, this.refresh();
  }, enumerable: !1, configurable: !0 }), Object.defineProperty(n.prototype, "loop", { get: function() {
    return this._loop;
  }, set: function(t) {
    this._loop = t, this.refresh();
  }, enumerable: !1, configurable: !0 }), n.prototype._preload = function(t) {
    this.media.load(t);
  }, Object.defineProperty(n.prototype, "instances", { get: function() {
    return this._instances;
  }, enumerable: !1, configurable: !0 }), Object.defineProperty(n.prototype, "sprites", { get: function() {
    return this._sprites;
  }, enumerable: !1, configurable: !0 }), Object.defineProperty(n.prototype, "duration", { get: function() {
    return this.media.duration;
  }, enumerable: !1, configurable: !0 }), n.prototype.autoPlayStart = function() {
    var t;
    return this.autoPlay && (t = this.play(this._autoPlayOptions)), t;
  }, n.prototype._removeInstances = function() {
    for (var t = this._instances.length - 1; t >= 0; t--)
      this._poolInstance(this._instances[t]);
    this._instances.length = 0;
  }, n.prototype._onComplete = function(t) {
    if (this._instances) {
      var e = this._instances.indexOf(t);
      e > -1 && this._instances.splice(e, 1), this.isPlaying = this._instances.length > 0;
    }
    this._poolInstance(t);
  }, n.prototype._createInstance = function() {
    if (n._pool.length > 0) {
      var t = n._pool.pop();
      return t.init(this.media), t;
    }
    return this.media.create();
  }, n.prototype._poolInstance = function(t) {
    t.destroy(), n._pool.indexOf(t) < 0 && n._pool.push(t);
  }, n._pool = [], n;
}(), F = function(n) {
  function t() {
    var e = n !== null && n.apply(this, arguments) || this;
    return e.speed = 1, e.muted = !1, e.volume = 1, e.paused = !1, e;
  }
  return a(t, n), t.prototype.refresh = function() {
    this.emit("refresh");
  }, t.prototype.refreshPaused = function() {
    this.emit("refreshPaused");
  }, Object.defineProperty(t.prototype, "filters", { get: function() {
    return null;
  }, set: function(e) {
  }, enumerable: !1, configurable: !0 }), Object.defineProperty(t.prototype, "audioContext", { get: function() {
    return null;
  }, enumerable: !1, configurable: !0 }), t.prototype.toggleMute = function() {
    return this.muted = !this.muted, this.refresh(), this.muted;
  }, t.prototype.togglePause = function() {
    return this.paused = !this.paused, this.refreshPaused(), this.paused;
  }, t.prototype.destroy = function() {
    this.removeAllListeners();
  }, t;
}(EventEmitter$4), C = function(n) {
  function t() {
    var e = this, o = window, R = new t.AudioContext(), N = R.createDynamicsCompressor(), M = R.createAnalyser();
    return M.connect(N), N.connect(R.destination), (e = n.call(this, M, N) || this)._ctx = R, e._offlineCtx = new t.OfflineAudioContext(1, 2, o.OfflineAudioContext ? Math.max(8e3, Math.min(96e3, R.sampleRate)) : 44100), e._unlocked = !1, e.compressor = N, e.analyser = M, e.events = new EventEmitter$4(), e.volume = 1, e.speed = 1, e.muted = !1, e.paused = !1, R.state !== "running" && (e._unlock(), e._unlock = e._unlock.bind(e), document.addEventListener("mousedown", e._unlock, !0), document.addEventListener("touchstart", e._unlock, !0), document.addEventListener("touchend", e._unlock, !0)), e;
  }
  return a(t, n), t.prototype._unlock = function() {
    this._unlocked || (this.playEmptySound(), this._ctx.state === "running" && (document.removeEventListener("mousedown", this._unlock, !0), document.removeEventListener("touchend", this._unlock, !0), document.removeEventListener("touchstart", this._unlock, !0), this._unlocked = !0));
  }, t.prototype.playEmptySound = function() {
    var e = this._ctx.createBufferSource();
    e.buffer = this._ctx.createBuffer(1, 1, 22050), e.connect(this._ctx.destination), e.start(0, 0, 0), e.context.state === "suspended" && e.context.resume();
  }, Object.defineProperty(t, "AudioContext", { get: function() {
    var e = window;
    return e.AudioContext || e.webkitAudioContext || null;
  }, enumerable: !1, configurable: !0 }), Object.defineProperty(t, "OfflineAudioContext", { get: function() {
    var e = window;
    return e.OfflineAudioContext || e.webkitOfflineAudioContext || null;
  }, enumerable: !1, configurable: !0 }), t.prototype.destroy = function() {
    n.prototype.destroy.call(this);
    var e = this._ctx;
    e.close !== void 0 && e.close(), this.events.removeAllListeners(), this.analyser.disconnect(), this.compressor.disconnect(), this.analyser = null, this.compressor = null, this.events = null, this._offlineCtx = null, this._ctx = null;
  }, Object.defineProperty(t.prototype, "audioContext", { get: function() {
    return this._ctx;
  }, enumerable: !1, configurable: !0 }), Object.defineProperty(t.prototype, "offlineContext", { get: function() {
    return this._offlineCtx;
  }, enumerable: !1, configurable: !0 }), Object.defineProperty(t.prototype, "paused", { get: function() {
    return this._paused;
  }, set: function(e) {
    e && this._ctx.state === "running" ? this._ctx.suspend() : e || this._ctx.state !== "suspended" || this._ctx.resume(), this._paused = e;
  }, enumerable: !1, configurable: !0 }), t.prototype.refresh = function() {
    this.events.emit("refresh");
  }, t.prototype.refreshPaused = function() {
    this.events.emit("refreshPaused");
  }, t.prototype.toggleMute = function() {
    return this.muted = !this.muted, this.refresh(), this.muted;
  }, t.prototype.togglePause = function() {
    return this.paused = !this.paused, this.refreshPaused(), this._paused;
  }, t.prototype.decode = function(e, o) {
    var R = function(M) {
      o(new Error((M == null ? void 0 : M.message) || "Unable to decode file"));
    }, N = this._offlineCtx.decodeAudioData(e, function(M) {
      o(null, M);
    }, R);
    N && N.catch(R);
  }, t;
}(O), E = function() {
  function n() {
    this.init();
  }
  return n.prototype.init = function() {
    return this.supported && (this._webAudioContext = new C()), this._htmlAudioContext = new F(), this._sounds = {}, this.useLegacy = !this.supported, this;
  }, Object.defineProperty(n.prototype, "context", { get: function() {
    return this._context;
  }, enumerable: !1, configurable: !0 }), Object.defineProperty(n.prototype, "filtersAll", { get: function() {
    return this.useLegacy ? [] : this._context.filters;
  }, set: function(t) {
    this.useLegacy || (this._context.filters = t);
  }, enumerable: !1, configurable: !0 }), Object.defineProperty(n.prototype, "supported", { get: function() {
    return C.AudioContext !== null;
  }, enumerable: !1, configurable: !0 }), n.prototype.add = function(t, e) {
    if (typeof t == "object") {
      var o = {};
      for (var R in t) {
        var N = this._getOptions(t[R], e);
        o[R] = this.add(R, N);
      }
      return o;
    }
    if (e instanceof A)
      return this._sounds[t] = e, e;
    var M = this._getOptions(e), D = A.from(M);
    return this._sounds[t] = D, D;
  }, n.prototype._getOptions = function(t, e) {
    var o;
    return o = typeof t == "string" ? { url: t } : t instanceof ArrayBuffer || t instanceof AudioBuffer || t instanceof HTMLAudioElement ? { source: t } : t, o = c(c({}, o), e || {});
  }, Object.defineProperty(n.prototype, "useLegacy", { get: function() {
    return this._useLegacy;
  }, set: function(t) {
    _.setLegacy(t), this._useLegacy = t, this._context = !t && this.supported ? this._webAudioContext : this._htmlAudioContext;
  }, enumerable: !1, configurable: !0 }), n.prototype.remove = function(t) {
    return this.exists(t, !0), this._sounds[t].destroy(), delete this._sounds[t], this;
  }, Object.defineProperty(n.prototype, "volumeAll", { get: function() {
    return this._context.volume;
  }, set: function(t) {
    this._context.volume = t, this._context.refresh();
  }, enumerable: !1, configurable: !0 }), Object.defineProperty(n.prototype, "speedAll", { get: function() {
    return this._context.speed;
  }, set: function(t) {
    this._context.speed = t, this._context.refresh();
  }, enumerable: !1, configurable: !0 }), n.prototype.togglePauseAll = function() {
    return this._context.togglePause();
  }, n.prototype.pauseAll = function() {
    return this._context.paused = !0, this._context.refreshPaused(), this;
  }, n.prototype.resumeAll = function() {
    return this._context.paused = !1, this._context.refreshPaused(), this;
  }, n.prototype.toggleMuteAll = function() {
    return this._context.toggleMute();
  }, n.prototype.muteAll = function() {
    return this._context.muted = !0, this._context.refresh(), this;
  }, n.prototype.unmuteAll = function() {
    return this._context.muted = !1, this._context.refresh(), this;
  }, n.prototype.removeAll = function() {
    for (var t in this._sounds)
      this._sounds[t].destroy(), delete this._sounds[t];
    return this;
  }, n.prototype.stopAll = function() {
    for (var t in this._sounds)
      this._sounds[t].stop();
    return this;
  }, n.prototype.exists = function(t, e) {
    return !!this._sounds[t];
  }, n.prototype.find = function(t) {
    return this.exists(t, !0), this._sounds[t];
  }, n.prototype.play = function(t, e) {
    return this.find(t).play(e);
  }, n.prototype.stop = function(t) {
    return this.find(t).stop();
  }, n.prototype.pause = function(t) {
    return this.find(t).pause();
  }, n.prototype.resume = function(t) {
    return this.find(t).resume();
  }, n.prototype.volume = function(t, e) {
    var o = this.find(t);
    return e !== void 0 && (o.volume = e), o.volume;
  }, n.prototype.speed = function(t, e) {
    var o = this.find(t);
    return e !== void 0 && (o.speed = e), o.speed;
  }, n.prototype.duration = function(t) {
    return this.find(t).duration;
  }, n.prototype.close = function() {
    return this.removeAll(), this._sounds = null, this._webAudioContext && (this._webAudioContext.destroy(), this._webAudioContext = null), this._htmlAudioContext && (this._htmlAudioContext.destroy(), this._htmlAudioContext = null), this._context = null, this;
  }, n;
}(), S = function() {
  function n(t, e) {
    this.init(t, e);
  }
  return n.prototype.init = function(t, e) {
    this.destination = t, this.source = e || t;
  }, n.prototype.connect = function(t) {
    this.source.connect(t);
  }, n.prototype.disconnect = function() {
    this.source.disconnect();
  }, n.prototype.destroy = function() {
    this.disconnect(), this.destination = null, this.source = null;
  }, n;
}();
(function(n) {
  function t(e, o, R, N, M, D, L, B, $, k) {
    e === void 0 && (e = 0), o === void 0 && (o = 0), R === void 0 && (R = 0), N === void 0 && (N = 0), M === void 0 && (M = 0), D === void 0 && (D = 0), L === void 0 && (L = 0), B === void 0 && (B = 0), $ === void 0 && ($ = 0), k === void 0 && (k = 0);
    var U = this;
    if (!s().useLegacy) {
      var z = [{ f: t.F32, type: "lowshelf", gain: e }, { f: t.F64, type: "peaking", gain: o }, { f: t.F125, type: "peaking", gain: R }, { f: t.F250, type: "peaking", gain: N }, { f: t.F500, type: "peaking", gain: M }, { f: t.F1K, type: "peaking", gain: D }, { f: t.F2K, type: "peaking", gain: L }, { f: t.F4K, type: "peaking", gain: B }, { f: t.F8K, type: "peaking", gain: $ }, { f: t.F16K, type: "highshelf", gain: k }].map(function(W) {
        var Y = s().context.audioContext.createBiquadFilter();
        return Y.type = W.type, v.setParamValue(Y.Q, 1), Y.frequency.value = W.f, v.setParamValue(Y.gain, W.gain), Y;
      });
      (U = n.call(this, z[0], z[z.length - 1]) || this).bands = z, U.bandsMap = {};
      for (var X = 0; X < U.bands.length; X++) {
        var V = U.bands[X];
        X > 0 && U.bands[X - 1].connect(V), U.bandsMap[V.frequency.value] = V;
      }
      return U;
    }
    U = n.call(this, null) || this;
  }
  return a(t, n), t.prototype.setGain = function(e, o) {
    if (o === void 0 && (o = 0), !this.bandsMap[e])
      throw new Error("No band found for frequency ".concat(e));
    v.setParamValue(this.bandsMap[e].gain, o);
  }, t.prototype.getGain = function(e) {
    if (!this.bandsMap[e])
      throw new Error("No band found for frequency ".concat(e));
    return this.bandsMap[e].gain.value;
  }, Object.defineProperty(t.prototype, "f32", { get: function() {
    return this.getGain(t.F32);
  }, set: function(e) {
    this.setGain(t.F32, e);
  }, enumerable: !1, configurable: !0 }), Object.defineProperty(t.prototype, "f64", { get: function() {
    return this.getGain(t.F64);
  }, set: function(e) {
    this.setGain(t.F64, e);
  }, enumerable: !1, configurable: !0 }), Object.defineProperty(t.prototype, "f125", { get: function() {
    return this.getGain(t.F125);
  }, set: function(e) {
    this.setGain(t.F125, e);
  }, enumerable: !1, configurable: !0 }), Object.defineProperty(t.prototype, "f250", { get: function() {
    return this.getGain(t.F250);
  }, set: function(e) {
    this.setGain(t.F250, e);
  }, enumerable: !1, configurable: !0 }), Object.defineProperty(t.prototype, "f500", { get: function() {
    return this.getGain(t.F500);
  }, set: function(e) {
    this.setGain(t.F500, e);
  }, enumerable: !1, configurable: !0 }), Object.defineProperty(t.prototype, "f1k", { get: function() {
    return this.getGain(t.F1K);
  }, set: function(e) {
    this.setGain(t.F1K, e);
  }, enumerable: !1, configurable: !0 }), Object.defineProperty(t.prototype, "f2k", { get: function() {
    return this.getGain(t.F2K);
  }, set: function(e) {
    this.setGain(t.F2K, e);
  }, enumerable: !1, configurable: !0 }), Object.defineProperty(t.prototype, "f4k", { get: function() {
    return this.getGain(t.F4K);
  }, set: function(e) {
    this.setGain(t.F4K, e);
  }, enumerable: !1, configurable: !0 }), Object.defineProperty(t.prototype, "f8k", { get: function() {
    return this.getGain(t.F8K);
  }, set: function(e) {
    this.setGain(t.F8K, e);
  }, enumerable: !1, configurable: !0 }), Object.defineProperty(t.prototype, "f16k", { get: function() {
    return this.getGain(t.F16K);
  }, set: function(e) {
    this.setGain(t.F16K, e);
  }, enumerable: !1, configurable: !0 }), t.prototype.reset = function() {
    this.bands.forEach(function(e) {
      v.setParamValue(e.gain, 0);
    });
  }, t.prototype.destroy = function() {
    this.bands.forEach(function(e) {
      e.disconnect();
    }), this.bands = null, this.bandsMap = null;
  }, t.F32 = 32, t.F64 = 64, t.F125 = 125, t.F250 = 250, t.F500 = 500, t.F1K = 1e3, t.F2K = 2e3, t.F4K = 4e3, t.F8K = 8e3, t.F16K = 16e3, t;
})(S), function(n) {
  function t(e) {
    e === void 0 && (e = 0);
    var o = this;
    if (!s().useLegacy) {
      var R = s().context.audioContext.createWaveShaper();
      return (o = n.call(this, R) || this)._distortion = R, o.amount = e, o;
    }
    o = n.call(this, null) || this;
  }
  return a(t, n), Object.defineProperty(t.prototype, "amount", { get: function() {
    return this._amount;
  }, set: function(e) {
    this._amount = e;
    for (var o, R = 1e3 * e, N = 44100, M = new Float32Array(N), D = Math.PI / 180, L = 0; L < N; ++L)
      o = 2 * L / N - 1, M[L] = (3 + R) * o * 20 * D / (Math.PI + R * Math.abs(o));
    this._distortion.curve = M, this._distortion.oversample = "4x";
  }, enumerable: !1, configurable: !0 }), t.prototype.destroy = function() {
    this._distortion = null, n.prototype.destroy.call(this);
  }, t;
}(S), function(n) {
  function t(e) {
    e === void 0 && (e = 0);
    var o = this;
    if (!s().useLegacy) {
      var R, N, M, D = s().context.audioContext;
      return D.createStereoPanner ? M = R = D.createStereoPanner() : ((N = D.createPanner()).panningModel = "equalpower", M = N), (o = n.call(this, M) || this)._stereo = R, o._panner = N, o.pan = e, o;
    }
    o = n.call(this, null) || this;
  }
  return a(t, n), Object.defineProperty(t.prototype, "pan", { get: function() {
    return this._pan;
  }, set: function(e) {
    this._pan = e, this._stereo ? v.setParamValue(this._stereo.pan, e) : this._panner.setPosition(e, 0, 1 - Math.abs(e));
  }, enumerable: !1, configurable: !0 }), t.prototype.destroy = function() {
    n.prototype.destroy.call(this), this._stereo = null, this._panner = null;
  }, t;
}(S), function(n) {
  function t(e, o, R) {
    e === void 0 && (e = 3), o === void 0 && (o = 2), R === void 0 && (R = !1);
    var N = this;
    if (!s().useLegacy)
      return (N = n.call(this, null) || this)._seconds = N._clamp(e, 1, 50), N._decay = N._clamp(o, 0, 100), N._reverse = R, N._rebuild(), N;
    N = n.call(this, null) || this;
  }
  return a(t, n), t.prototype._clamp = function(e, o, R) {
    return Math.min(R, Math.max(o, e));
  }, Object.defineProperty(t.prototype, "seconds", { get: function() {
    return this._seconds;
  }, set: function(e) {
    this._seconds = this._clamp(e, 1, 50), this._rebuild();
  }, enumerable: !1, configurable: !0 }), Object.defineProperty(t.prototype, "decay", { get: function() {
    return this._decay;
  }, set: function(e) {
    this._decay = this._clamp(e, 0, 100), this._rebuild();
  }, enumerable: !1, configurable: !0 }), Object.defineProperty(t.prototype, "reverse", { get: function() {
    return this._reverse;
  }, set: function(e) {
    this._reverse = e, this._rebuild();
  }, enumerable: !1, configurable: !0 }), t.prototype._rebuild = function() {
    for (var e, o = s().context.audioContext, R = o.sampleRate, N = R * this._seconds, M = o.createBuffer(2, N, R), D = M.getChannelData(0), L = M.getChannelData(1), B = 0; B < N; B++)
      e = this._reverse ? N - B : B, D[B] = (2 * Math.random() - 1) * Math.pow(1 - e / N, this._decay), L[B] = (2 * Math.random() - 1) * Math.pow(1 - e / N, this._decay);
    var $ = s().context.audioContext.createConvolver();
    $.buffer = M, this.init($);
  }, t;
}(S), function(n) {
  function t() {
    var e = this;
    if (!s().useLegacy) {
      var o = s().context.audioContext, R = o.createChannelSplitter(), N = o.createChannelMerger();
      return N.connect(R), (e = n.call(this, N, R) || this)._merger = N, e;
    }
    e = n.call(this, null) || this;
  }
  return a(t, n), t.prototype.destroy = function() {
    this._merger.disconnect(), this._merger = null, n.prototype.destroy.call(this);
  }, t;
}(S), function(n) {
  function t() {
    var e = this;
    if (!s().useLegacy) {
      var o = s().context.audioContext, R = o.createMediaStreamDestination(), N = o.createMediaStreamSource(R.stream);
      return (e = n.call(this, R, N) || this)._stream = R.stream, e;
    }
    e = n.call(this, null) || this;
  }
  return a(t, n), Object.defineProperty(t.prototype, "stream", { get: function() {
    return this._stream;
  }, enumerable: !1, configurable: !0 }), t.prototype.destroy = function() {
    this._stream = null, n.prototype.destroy.call(this);
  }, t;
}(S), function(n) {
  function t() {
    if (!s().useLegacy) {
      var e = s().context.audioContext, o = e.createBiquadFilter(), R = e.createBiquadFilter(), N = e.createBiquadFilter(), M = e.createBiquadFilter();
      return o.type = "lowpass", v.setParamValue(o.frequency, 2e3), R.type = "lowpass", v.setParamValue(R.frequency, 2e3), N.type = "highpass", v.setParamValue(N.frequency, 500), M.type = "highpass", v.setParamValue(M.frequency, 500), o.connect(R), R.connect(N), N.connect(M), n.call(this, o, M) || this;
    }
    n.call(this, null);
  }
  return a(t, n), t;
}(S);
var T = 0, G = { __proto__: null, playOnce: function(n, t) {
  var e = "alias".concat(T++);
  return s().add(e, { url: n, preload: !0, autoPlay: !0, loaded: function(o) {
    o && (s().remove(e), t && t(o));
  }, complete: function() {
    s().remove(e), t && t(null);
  } }), e;
}, get PLAY_ID() {
  return T;
}, render: function(n, t) {
  var e = document.createElement("canvas");
  t = c({ width: 512, height: 128, fill: "black" }, t || {}), e.width = t.width, e.height = t.height;
  var o = BaseTexture.from(e);
  if (!(n.media instanceof w))
    return o;
  var R = n.media, N = e.getContext("2d");
  N.fillStyle = t.fill;
  for (var M = R.buffer.getChannelData(0), D = Math.ceil(M.length / t.width), L = t.height / 2, B = 0; B < t.width; B++) {
    for (var $ = 1, k = -1, U = 0; U < D; U++) {
      var z = M[B * D + U];
      z < $ && ($ = z), z > k && (k = z);
    }
    N.fillRect(B, (1 + $) * L, 1, Math.max(1, (k - $) * L));
  }
  return o;
}, resolveUrl: d, sineTone: function(n, t) {
  n === void 0 && (n = 200), t === void 0 && (t = 1);
  var e = A.from({ singleInstance: !0 });
  if (!(e.media instanceof w))
    return e;
  for (var o = e.media, R = e.context.audioContext.createBuffer(1, 48e3 * t, 48e3), N = R.getChannelData(0), M = 0; M < N.length; M++) {
    var D = n * (M / R.sampleRate) * Math.PI;
    N[M] = 2 * Math.sin(D);
  }
  return o.buffer = R, e.isLoaded = !0, e;
}, validateFormats: h, supported: p$1, extensions: l }, I = function(n) {
  return r = n, n;
}(new E());
Loader.registerPlugin(_);
function finallyConstructor(n) {
  var t = this.constructor;
  return this.then(
    function(e) {
      return t.resolve(n()).then(function() {
        return e;
      });
    },
    function(e) {
      return t.resolve(n()).then(function() {
        return t.reject(e);
      });
    }
  );
}
function allSettled(n) {
  var t = this;
  return new t(function(e, o) {
    if (!(n && typeof n.length < "u"))
      return o(
        new TypeError(
          typeof n + " " + n + " is not iterable(cannot read property Symbol(Symbol.iterator))"
        )
      );
    var R = Array.prototype.slice.call(n);
    if (R.length === 0)
      return e([]);
    var N = R.length;
    function M(L, B) {
      if (B && (typeof B == "object" || typeof B == "function")) {
        var $ = B.then;
        if (typeof $ == "function") {
          $.call(
            B,
            function(k) {
              M(L, k);
            },
            function(k) {
              R[L] = { status: "rejected", reason: k }, --N === 0 && e(R);
            }
          );
          return;
        }
      }
      R[L] = { status: "fulfilled", value: B }, --N === 0 && e(R);
    }
    for (var D = 0; D < R.length; D++)
      M(D, R[D]);
  });
}
var setTimeoutFunc = setTimeout;
function isArray$1(n) {
  return Boolean(n && typeof n.length < "u");
}
function noop() {
}
function bind$2(n, t) {
  return function() {
    n.apply(t, arguments);
  };
}
function Promise$1(n) {
  if (!(this instanceof Promise$1))
    throw new TypeError("Promises must be constructed via new");
  if (typeof n != "function")
    throw new TypeError("not a function");
  this._state = 0, this._handled = !1, this._value = void 0, this._deferreds = [], doResolve(n, this);
}
function handle(n, t) {
  for (; n._state === 3; )
    n = n._value;
  if (n._state === 0) {
    n._deferreds.push(t);
    return;
  }
  n._handled = !0, Promise$1._immediateFn(function() {
    var e = n._state === 1 ? t.onFulfilled : t.onRejected;
    if (e === null) {
      (n._state === 1 ? resolve : reject)(t.promise, n._value);
      return;
    }
    var o;
    try {
      o = e(n._value);
    } catch (R) {
      reject(t.promise, R);
      return;
    }
    resolve(t.promise, o);
  });
}
function resolve(n, t) {
  try {
    if (t === n)
      throw new TypeError("A promise cannot be resolved with itself.");
    if (t && (typeof t == "object" || typeof t == "function")) {
      var e = t.then;
      if (t instanceof Promise$1) {
        n._state = 3, n._value = t, finale(n);
        return;
      } else if (typeof e == "function") {
        doResolve(bind$2(e, t), n);
        return;
      }
    }
    n._state = 1, n._value = t, finale(n);
  } catch (o) {
    reject(n, o);
  }
}
function reject(n, t) {
  n._state = 2, n._value = t, finale(n);
}
function finale(n) {
  n._state === 2 && n._deferreds.length === 0 && Promise$1._immediateFn(function() {
    n._handled || Promise$1._unhandledRejectionFn(n._value);
  });
  for (var t = 0, e = n._deferreds.length; t < e; t++)
    handle(n, n._deferreds[t]);
  n._deferreds = null;
}
function Handler(n, t, e) {
  this.onFulfilled = typeof n == "function" ? n : null, this.onRejected = typeof t == "function" ? t : null, this.promise = e;
}
function doResolve(n, t) {
  var e = !1;
  try {
    n(
      function(o) {
        e || (e = !0, resolve(t, o));
      },
      function(o) {
        e || (e = !0, reject(t, o));
      }
    );
  } catch (o) {
    if (e)
      return;
    e = !0, reject(t, o);
  }
}
Promise$1.prototype.catch = function(n) {
  return this.then(null, n);
};
Promise$1.prototype.then = function(n, t) {
  var e = new this.constructor(noop);
  return handle(this, new Handler(n, t, e)), e;
};
Promise$1.prototype.finally = finallyConstructor;
Promise$1.all = function(n) {
  return new Promise$1(function(t, e) {
    if (!isArray$1(n))
      return e(new TypeError("Promise.all accepts an array"));
    var o = Array.prototype.slice.call(n);
    if (o.length === 0)
      return t([]);
    var R = o.length;
    function N(D, L) {
      try {
        if (L && (typeof L == "object" || typeof L == "function")) {
          var B = L.then;
          if (typeof B == "function") {
            B.call(
              L,
              function($) {
                N(D, $);
              },
              e
            );
            return;
          }
        }
        o[D] = L, --R === 0 && t(o);
      } catch ($) {
        e($);
      }
    }
    for (var M = 0; M < o.length; M++)
      N(M, o[M]);
  });
};
Promise$1.allSettled = allSettled;
Promise$1.resolve = function(n) {
  return n && typeof n == "object" && n.constructor === Promise$1 ? n : new Promise$1(function(t) {
    t(n);
  });
};
Promise$1.reject = function(n) {
  return new Promise$1(function(t, e) {
    e(n);
  });
};
Promise$1.race = function(n) {
  return new Promise$1(function(t, e) {
    if (!isArray$1(n))
      return e(new TypeError("Promise.race accepts an array"));
    for (var o = 0, R = n.length; o < R; o++)
      Promise$1.resolve(n[o]).then(t, e);
  });
};
Promise$1._immediateFn = typeof setImmediate == "function" && function(n) {
  setImmediate(n);
} || function(n) {
  setTimeoutFunc(n, 0);
};
Promise$1._unhandledRejectionFn = function(t) {
  typeof console < "u" && console && console.warn("Possible Unhandled Promise Rejection:", t);
};
/*
object-assign
(c) Sindre Sorhus
@license MIT
*/
var getOwnPropertySymbols = Object.getOwnPropertySymbols, hasOwnProperty$1 = Object.prototype.hasOwnProperty, propIsEnumerable = Object.prototype.propertyIsEnumerable;
function toObject(n) {
  if (n == null)
    throw new TypeError("Object.assign cannot be called with null or undefined");
  return Object(n);
}
function shouldUseNative() {
  try {
    if (!Object.assign)
      return !1;
    var n = new String("abc");
    if (n[5] = "de", Object.getOwnPropertyNames(n)[0] === "5")
      return !1;
    for (var t = {}, e = 0; e < 10; e++)
      t["_" + String.fromCharCode(e)] = e;
    var o = Object.getOwnPropertyNames(t).map(function(N) {
      return t[N];
    });
    if (o.join("") !== "0123456789")
      return !1;
    var R = {};
    return "abcdefghijklmnopqrst".split("").forEach(function(N) {
      R[N] = N;
    }), Object.keys(Object.assign({}, R)).join("") === "abcdefghijklmnopqrst";
  } catch {
    return !1;
  }
}
var objectAssign = shouldUseNative() ? Object.assign : function(n, t) {
  for (var e, o = toObject(n), R, N = 1; N < arguments.length; N++) {
    e = Object(arguments[N]);
    for (var M in e)
      hasOwnProperty$1.call(e, M) && (o[M] = e[M]);
    if (getOwnPropertySymbols) {
      R = getOwnPropertySymbols(e);
      for (var D = 0; D < R.length; D++)
        propIsEnumerable.call(e, R[D]) && (o[R[D]] = e[R[D]]);
    }
  }
  return o;
};
/*!
 * @pixi/polyfill - v6.5.2
 * Compiled Wed, 24 Aug 2022 13:51:19 UTC
 *
 * @pixi/polyfill is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
typeof globalThis > "u" && (typeof self < "u" ? self.globalThis = self : typeof global < "u" && (global.globalThis = global));
globalThis.Promise || (globalThis.Promise = Promise$1);
Object.assign || (Object.assign = objectAssign);
var ONE_FRAME_TIME = 16;
Date.now && Date.prototype.getTime || (Date.now = function() {
  return new Date().getTime();
});
if (!(globalThis.performance && globalThis.performance.now)) {
  var startTime_1 = Date.now();
  globalThis.performance || (globalThis.performance = {}), globalThis.performance.now = function() {
    return Date.now() - startTime_1;
  };
}
var lastTime = Date.now(), vendors = ["ms", "moz", "webkit", "o"];
for (var x = 0; x < vendors.length && !globalThis.requestAnimationFrame; ++x) {
  var p = vendors[x];
  globalThis.requestAnimationFrame = globalThis[p + "RequestAnimationFrame"], globalThis.cancelAnimationFrame = globalThis[p + "CancelAnimationFrame"] || globalThis[p + "CancelRequestAnimationFrame"];
}
globalThis.requestAnimationFrame || (globalThis.requestAnimationFrame = function(n) {
  if (typeof n != "function")
    throw new TypeError(n + "is not a function");
  var t = Date.now(), e = ONE_FRAME_TIME + lastTime - t;
  return e < 0 && (e = 0), lastTime = t, globalThis.self.setTimeout(function() {
    lastTime = Date.now(), n(performance.now());
  }, e);
});
globalThis.cancelAnimationFrame || (globalThis.cancelAnimationFrame = function(n) {
  return clearTimeout(n);
});
Math.sign || (Math.sign = function(t) {
  return t = Number(t), t === 0 || isNaN(t) ? t : t > 0 ? 1 : -1;
});
Number.isInteger || (Number.isInteger = function(t) {
  return typeof t == "number" && isFinite(t) && Math.floor(t) === t;
});
globalThis.ArrayBuffer || (globalThis.ArrayBuffer = Array);
globalThis.Float32Array || (globalThis.Float32Array = Array);
globalThis.Uint32Array || (globalThis.Uint32Array = Array);
globalThis.Uint16Array || (globalThis.Uint16Array = Array);
globalThis.Uint8Array || (globalThis.Uint8Array = Array);
globalThis.Int32Array || (globalThis.Int32Array = Array);
/*!
 * @pixi/display - v6.5.2
 * Compiled Wed, 24 Aug 2022 13:51:19 UTC
 *
 * @pixi/display is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
settings$1.SORTABLE_CHILDREN = !1;
var Bounds = function() {
  function n() {
    this.minX = 1 / 0, this.minY = 1 / 0, this.maxX = -1 / 0, this.maxY = -1 / 0, this.rect = null, this.updateID = -1;
  }
  return n.prototype.isEmpty = function() {
    return this.minX > this.maxX || this.minY > this.maxY;
  }, n.prototype.clear = function() {
    this.minX = 1 / 0, this.minY = 1 / 0, this.maxX = -1 / 0, this.maxY = -1 / 0;
  }, n.prototype.getRectangle = function(t) {
    return this.minX > this.maxX || this.minY > this.maxY ? Rectangle.EMPTY : (t = t || new Rectangle(0, 0, 1, 1), t.x = this.minX, t.y = this.minY, t.width = this.maxX - this.minX, t.height = this.maxY - this.minY, t);
  }, n.prototype.addPoint = function(t) {
    this.minX = Math.min(this.minX, t.x), this.maxX = Math.max(this.maxX, t.x), this.minY = Math.min(this.minY, t.y), this.maxY = Math.max(this.maxY, t.y);
  }, n.prototype.addPointMatrix = function(t, e) {
    var o = t.a, R = t.b, N = t.c, M = t.d, D = t.tx, L = t.ty, B = o * e.x + N * e.y + D, $ = R * e.x + M * e.y + L;
    this.minX = Math.min(this.minX, B), this.maxX = Math.max(this.maxX, B), this.minY = Math.min(this.minY, $), this.maxY = Math.max(this.maxY, $);
  }, n.prototype.addQuad = function(t) {
    var e = this.minX, o = this.minY, R = this.maxX, N = this.maxY, M = t[0], D = t[1];
    e = M < e ? M : e, o = D < o ? D : o, R = M > R ? M : R, N = D > N ? D : N, M = t[2], D = t[3], e = M < e ? M : e, o = D < o ? D : o, R = M > R ? M : R, N = D > N ? D : N, M = t[4], D = t[5], e = M < e ? M : e, o = D < o ? D : o, R = M > R ? M : R, N = D > N ? D : N, M = t[6], D = t[7], e = M < e ? M : e, o = D < o ? D : o, R = M > R ? M : R, N = D > N ? D : N, this.minX = e, this.minY = o, this.maxX = R, this.maxY = N;
  }, n.prototype.addFrame = function(t, e, o, R, N) {
    this.addFrameMatrix(t.worldTransform, e, o, R, N);
  }, n.prototype.addFrameMatrix = function(t, e, o, R, N) {
    var M = t.a, D = t.b, L = t.c, B = t.d, $ = t.tx, k = t.ty, U = this.minX, z = this.minY, X = this.maxX, V = this.maxY, W = M * e + L * o + $, Y = D * e + B * o + k;
    U = W < U ? W : U, z = Y < z ? Y : z, X = W > X ? W : X, V = Y > V ? Y : V, W = M * R + L * o + $, Y = D * R + B * o + k, U = W < U ? W : U, z = Y < z ? Y : z, X = W > X ? W : X, V = Y > V ? Y : V, W = M * e + L * N + $, Y = D * e + B * N + k, U = W < U ? W : U, z = Y < z ? Y : z, X = W > X ? W : X, V = Y > V ? Y : V, W = M * R + L * N + $, Y = D * R + B * N + k, U = W < U ? W : U, z = Y < z ? Y : z, X = W > X ? W : X, V = Y > V ? Y : V, this.minX = U, this.minY = z, this.maxX = X, this.maxY = V;
  }, n.prototype.addVertexData = function(t, e, o) {
    for (var R = this.minX, N = this.minY, M = this.maxX, D = this.maxY, L = e; L < o; L += 2) {
      var B = t[L], $ = t[L + 1];
      R = B < R ? B : R, N = $ < N ? $ : N, M = B > M ? B : M, D = $ > D ? $ : D;
    }
    this.minX = R, this.minY = N, this.maxX = M, this.maxY = D;
  }, n.prototype.addVertices = function(t, e, o, R) {
    this.addVerticesMatrix(t.worldTransform, e, o, R);
  }, n.prototype.addVerticesMatrix = function(t, e, o, R, N, M) {
    N === void 0 && (N = 0), M === void 0 && (M = N);
    for (var D = t.a, L = t.b, B = t.c, $ = t.d, k = t.tx, U = t.ty, z = this.minX, X = this.minY, V = this.maxX, W = this.maxY, Y = o; Y < R; Y += 2) {
      var q = e[Y], Z = e[Y + 1], J = D * q + B * Z + k, Q = $ * Z + L * q + U;
      z = Math.min(z, J - N), V = Math.max(V, J + N), X = Math.min(X, Q - M), W = Math.max(W, Q + M);
    }
    this.minX = z, this.minY = X, this.maxX = V, this.maxY = W;
  }, n.prototype.addBounds = function(t) {
    var e = this.minX, o = this.minY, R = this.maxX, N = this.maxY;
    this.minX = t.minX < e ? t.minX : e, this.minY = t.minY < o ? t.minY : o, this.maxX = t.maxX > R ? t.maxX : R, this.maxY = t.maxY > N ? t.maxY : N;
  }, n.prototype.addBoundsMask = function(t, e) {
    var o = t.minX > e.minX ? t.minX : e.minX, R = t.minY > e.minY ? t.minY : e.minY, N = t.maxX < e.maxX ? t.maxX : e.maxX, M = t.maxY < e.maxY ? t.maxY : e.maxY;
    if (o <= N && R <= M) {
      var D = this.minX, L = this.minY, B = this.maxX, $ = this.maxY;
      this.minX = o < D ? o : D, this.minY = R < L ? R : L, this.maxX = N > B ? N : B, this.maxY = M > $ ? M : $;
    }
  }, n.prototype.addBoundsMatrix = function(t, e) {
    this.addFrameMatrix(e, t.minX, t.minY, t.maxX, t.maxY);
  }, n.prototype.addBoundsArea = function(t, e) {
    var o = t.minX > e.x ? t.minX : e.x, R = t.minY > e.y ? t.minY : e.y, N = t.maxX < e.x + e.width ? t.maxX : e.x + e.width, M = t.maxY < e.y + e.height ? t.maxY : e.y + e.height;
    if (o <= N && R <= M) {
      var D = this.minX, L = this.minY, B = this.maxX, $ = this.maxY;
      this.minX = o < D ? o : D, this.minY = R < L ? R : L, this.maxX = N > B ? N : B, this.maxY = M > $ ? M : $;
    }
  }, n.prototype.pad = function(t, e) {
    t === void 0 && (t = 0), e === void 0 && (e = t), this.isEmpty() || (this.minX -= t, this.maxX += t, this.minY -= e, this.maxY += e);
  }, n.prototype.addFramePad = function(t, e, o, R, N, M) {
    t -= N, e -= M, o += N, R += M, this.minX = this.minX < t ? this.minX : t, this.maxX = this.maxX > o ? this.maxX : o, this.minY = this.minY < e ? this.minY : e, this.maxY = this.maxY > R ? this.maxY : R;
  }, n;
}();
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var extendStatics$p = function(n, t) {
  return extendStatics$p = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(e, o) {
    e.__proto__ = o;
  } || function(e, o) {
    for (var R in o)
      o.hasOwnProperty(R) && (e[R] = o[R]);
  }, extendStatics$p(n, t);
};
function __extends$p(n, t) {
  extendStatics$p(n, t);
  function e() {
    this.constructor = n;
  }
  n.prototype = t === null ? Object.create(t) : (e.prototype = t.prototype, new e());
}
var DisplayObject = function(n) {
  __extends$p(t, n);
  function t() {
    var e = n.call(this) || this;
    return e.tempDisplayObjectParent = null, e.transform = new Transform(), e.alpha = 1, e.visible = !0, e.renderable = !0, e.cullable = !1, e.cullArea = null, e.parent = null, e.worldAlpha = 1, e._lastSortedIndex = 0, e._zIndex = 0, e.filterArea = null, e.filters = null, e._enabledFilters = null, e._bounds = new Bounds(), e._localBounds = null, e._boundsID = 0, e._boundsRect = null, e._localBoundsRect = null, e._mask = null, e._maskRefCount = 0, e._destroyed = !1, e.isSprite = !1, e.isMask = !1, e;
  }
  return t.mixin = function(e) {
    for (var o = Object.keys(e), R = 0; R < o.length; ++R) {
      var N = o[R];
      Object.defineProperty(t.prototype, N, Object.getOwnPropertyDescriptor(e, N));
    }
  }, Object.defineProperty(t.prototype, "destroyed", {
    get: function() {
      return this._destroyed;
    },
    enumerable: !1,
    configurable: !0
  }), t.prototype._recursivePostUpdateTransform = function() {
    this.parent ? (this.parent._recursivePostUpdateTransform(), this.transform.updateTransform(this.parent.transform)) : this.transform.updateTransform(this._tempDisplayObjectParent.transform);
  }, t.prototype.updateTransform = function() {
    this._boundsID++, this.transform.updateTransform(this.parent.transform), this.worldAlpha = this.alpha * this.parent.worldAlpha;
  }, t.prototype.getBounds = function(e, o) {
    return e || (this.parent ? (this._recursivePostUpdateTransform(), this.updateTransform()) : (this.parent = this._tempDisplayObjectParent, this.updateTransform(), this.parent = null)), this._bounds.updateID !== this._boundsID && (this.calculateBounds(), this._bounds.updateID = this._boundsID), o || (this._boundsRect || (this._boundsRect = new Rectangle()), o = this._boundsRect), this._bounds.getRectangle(o);
  }, t.prototype.getLocalBounds = function(e) {
    e || (this._localBoundsRect || (this._localBoundsRect = new Rectangle()), e = this._localBoundsRect), this._localBounds || (this._localBounds = new Bounds());
    var o = this.transform, R = this.parent;
    this.parent = null, this.transform = this._tempDisplayObjectParent.transform;
    var N = this._bounds, M = this._boundsID;
    this._bounds = this._localBounds;
    var D = this.getBounds(!1, e);
    return this.parent = R, this.transform = o, this._bounds = N, this._bounds.updateID += this._boundsID - M, D;
  }, t.prototype.toGlobal = function(e, o, R) {
    return R === void 0 && (R = !1), R || (this._recursivePostUpdateTransform(), this.parent ? this.displayObjectUpdateTransform() : (this.parent = this._tempDisplayObjectParent, this.displayObjectUpdateTransform(), this.parent = null)), this.worldTransform.apply(e, o);
  }, t.prototype.toLocal = function(e, o, R, N) {
    return o && (e = o.toGlobal(e, R, N)), N || (this._recursivePostUpdateTransform(), this.parent ? this.displayObjectUpdateTransform() : (this.parent = this._tempDisplayObjectParent, this.displayObjectUpdateTransform(), this.parent = null)), this.worldTransform.applyInverse(e, R);
  }, t.prototype.setParent = function(e) {
    if (!e || !e.addChild)
      throw new Error("setParent: Argument must be a Container");
    return e.addChild(this), e;
  }, t.prototype.setTransform = function(e, o, R, N, M, D, L, B, $) {
    return e === void 0 && (e = 0), o === void 0 && (o = 0), R === void 0 && (R = 1), N === void 0 && (N = 1), M === void 0 && (M = 0), D === void 0 && (D = 0), L === void 0 && (L = 0), B === void 0 && (B = 0), $ === void 0 && ($ = 0), this.position.x = e, this.position.y = o, this.scale.x = R || 1, this.scale.y = N || 1, this.rotation = M, this.skew.x = D, this.skew.y = L, this.pivot.x = B, this.pivot.y = $, this;
  }, t.prototype.destroy = function(e) {
    this.parent && this.parent.removeChild(this), this._destroyed = !0, this.transform = null, this.parent = null, this._bounds = null, this.mask = null, this.cullArea = null, this.filters = null, this.filterArea = null, this.hitArea = null, this.interactive = !1, this.interactiveChildren = !1, this.emit("destroyed"), this.removeAllListeners();
  }, Object.defineProperty(t.prototype, "_tempDisplayObjectParent", {
    get: function() {
      return this.tempDisplayObjectParent === null && (this.tempDisplayObjectParent = new TemporaryDisplayObject()), this.tempDisplayObjectParent;
    },
    enumerable: !1,
    configurable: !0
  }), t.prototype.enableTempParent = function() {
    var e = this.parent;
    return this.parent = this._tempDisplayObjectParent, e;
  }, t.prototype.disableTempParent = function(e) {
    this.parent = e;
  }, Object.defineProperty(t.prototype, "x", {
    get: function() {
      return this.position.x;
    },
    set: function(e) {
      this.transform.position.x = e;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(t.prototype, "y", {
    get: function() {
      return this.position.y;
    },
    set: function(e) {
      this.transform.position.y = e;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(t.prototype, "worldTransform", {
    get: function() {
      return this.transform.worldTransform;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(t.prototype, "localTransform", {
    get: function() {
      return this.transform.localTransform;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(t.prototype, "position", {
    get: function() {
      return this.transform.position;
    },
    set: function(e) {
      this.transform.position.copyFrom(e);
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(t.prototype, "scale", {
    get: function() {
      return this.transform.scale;
    },
    set: function(e) {
      this.transform.scale.copyFrom(e);
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(t.prototype, "pivot", {
    get: function() {
      return this.transform.pivot;
    },
    set: function(e) {
      this.transform.pivot.copyFrom(e);
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(t.prototype, "skew", {
    get: function() {
      return this.transform.skew;
    },
    set: function(e) {
      this.transform.skew.copyFrom(e);
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(t.prototype, "rotation", {
    get: function() {
      return this.transform.rotation;
    },
    set: function(e) {
      this.transform.rotation = e;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(t.prototype, "angle", {
    get: function() {
      return this.transform.rotation * RAD_TO_DEG;
    },
    set: function(e) {
      this.transform.rotation = e * DEG_TO_RAD;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(t.prototype, "zIndex", {
    get: function() {
      return this._zIndex;
    },
    set: function(e) {
      this._zIndex = e, this.parent && (this.parent.sortDirty = !0);
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(t.prototype, "worldVisible", {
    get: function() {
      var e = this;
      do {
        if (!e.visible)
          return !1;
        e = e.parent;
      } while (e);
      return !0;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(t.prototype, "mask", {
    get: function() {
      return this._mask;
    },
    set: function(e) {
      if (this._mask !== e) {
        if (this._mask) {
          var o = this._mask.isMaskData ? this._mask.maskObject : this._mask;
          o && (o._maskRefCount--, o._maskRefCount === 0 && (o.renderable = !0, o.isMask = !1));
        }
        if (this._mask = e, this._mask) {
          var o = this._mask.isMaskData ? this._mask.maskObject : this._mask;
          o && (o._maskRefCount === 0 && (o.renderable = !1, o.isMask = !0), o._maskRefCount++);
        }
      }
    },
    enumerable: !1,
    configurable: !0
  }), t;
}(EventEmitter$4), TemporaryDisplayObject = function(n) {
  __extends$p(t, n);
  function t() {
    var e = n !== null && n.apply(this, arguments) || this;
    return e.sortDirty = null, e;
  }
  return t;
}(DisplayObject);
DisplayObject.prototype.displayObjectUpdateTransform = DisplayObject.prototype.updateTransform;
/*!
 * @pixi/constants - v6.5.2
 * Compiled Wed, 24 Aug 2022 13:51:19 UTC
 *
 * @pixi/constants is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
var ENV$4;
(function(n) {
  n[n.WEBGL_LEGACY = 0] = "WEBGL_LEGACY", n[n.WEBGL = 1] = "WEBGL", n[n.WEBGL2 = 2] = "WEBGL2";
})(ENV$4 || (ENV$4 = {}));
var RENDERER_TYPE$4;
(function(n) {
  n[n.UNKNOWN = 0] = "UNKNOWN", n[n.WEBGL = 1] = "WEBGL", n[n.CANVAS = 2] = "CANVAS";
})(RENDERER_TYPE$4 || (RENDERER_TYPE$4 = {}));
var BUFFER_BITS$4;
(function(n) {
  n[n.COLOR = 16384] = "COLOR", n[n.DEPTH = 256] = "DEPTH", n[n.STENCIL = 1024] = "STENCIL";
})(BUFFER_BITS$4 || (BUFFER_BITS$4 = {}));
var BLEND_MODES$4;
(function(n) {
  n[n.NORMAL = 0] = "NORMAL", n[n.ADD = 1] = "ADD", n[n.MULTIPLY = 2] = "MULTIPLY", n[n.SCREEN = 3] = "SCREEN", n[n.OVERLAY = 4] = "OVERLAY", n[n.DARKEN = 5] = "DARKEN", n[n.LIGHTEN = 6] = "LIGHTEN", n[n.COLOR_DODGE = 7] = "COLOR_DODGE", n[n.COLOR_BURN = 8] = "COLOR_BURN", n[n.HARD_LIGHT = 9] = "HARD_LIGHT", n[n.SOFT_LIGHT = 10] = "SOFT_LIGHT", n[n.DIFFERENCE = 11] = "DIFFERENCE", n[n.EXCLUSION = 12] = "EXCLUSION", n[n.HUE = 13] = "HUE", n[n.SATURATION = 14] = "SATURATION", n[n.COLOR = 15] = "COLOR", n[n.LUMINOSITY = 16] = "LUMINOSITY", n[n.NORMAL_NPM = 17] = "NORMAL_NPM", n[n.ADD_NPM = 18] = "ADD_NPM", n[n.SCREEN_NPM = 19] = "SCREEN_NPM", n[n.NONE = 20] = "NONE", n[n.SRC_OVER = 0] = "SRC_OVER", n[n.SRC_IN = 21] = "SRC_IN", n[n.SRC_OUT = 22] = "SRC_OUT", n[n.SRC_ATOP = 23] = "SRC_ATOP", n[n.DST_OVER = 24] = "DST_OVER", n[n.DST_IN = 25] = "DST_IN", n[n.DST_OUT = 26] = "DST_OUT", n[n.DST_ATOP = 27] = "DST_ATOP", n[n.ERASE = 26] = "ERASE", n[n.SUBTRACT = 28] = "SUBTRACT", n[n.XOR = 29] = "XOR";
})(BLEND_MODES$4 || (BLEND_MODES$4 = {}));
var DRAW_MODES$4;
(function(n) {
  n[n.POINTS = 0] = "POINTS", n[n.LINES = 1] = "LINES", n[n.LINE_LOOP = 2] = "LINE_LOOP", n[n.LINE_STRIP = 3] = "LINE_STRIP", n[n.TRIANGLES = 4] = "TRIANGLES", n[n.TRIANGLE_STRIP = 5] = "TRIANGLE_STRIP", n[n.TRIANGLE_FAN = 6] = "TRIANGLE_FAN";
})(DRAW_MODES$4 || (DRAW_MODES$4 = {}));
var FORMATS$4;
(function(n) {
  n[n.RGBA = 6408] = "RGBA", n[n.RGB = 6407] = "RGB", n[n.RG = 33319] = "RG", n[n.RED = 6403] = "RED", n[n.RGBA_INTEGER = 36249] = "RGBA_INTEGER", n[n.RGB_INTEGER = 36248] = "RGB_INTEGER", n[n.RG_INTEGER = 33320] = "RG_INTEGER", n[n.RED_INTEGER = 36244] = "RED_INTEGER", n[n.ALPHA = 6406] = "ALPHA", n[n.LUMINANCE = 6409] = "LUMINANCE", n[n.LUMINANCE_ALPHA = 6410] = "LUMINANCE_ALPHA", n[n.DEPTH_COMPONENT = 6402] = "DEPTH_COMPONENT", n[n.DEPTH_STENCIL = 34041] = "DEPTH_STENCIL";
})(FORMATS$4 || (FORMATS$4 = {}));
var TARGETS$4;
(function(n) {
  n[n.TEXTURE_2D = 3553] = "TEXTURE_2D", n[n.TEXTURE_CUBE_MAP = 34067] = "TEXTURE_CUBE_MAP", n[n.TEXTURE_2D_ARRAY = 35866] = "TEXTURE_2D_ARRAY", n[n.TEXTURE_CUBE_MAP_POSITIVE_X = 34069] = "TEXTURE_CUBE_MAP_POSITIVE_X", n[n.TEXTURE_CUBE_MAP_NEGATIVE_X = 34070] = "TEXTURE_CUBE_MAP_NEGATIVE_X", n[n.TEXTURE_CUBE_MAP_POSITIVE_Y = 34071] = "TEXTURE_CUBE_MAP_POSITIVE_Y", n[n.TEXTURE_CUBE_MAP_NEGATIVE_Y = 34072] = "TEXTURE_CUBE_MAP_NEGATIVE_Y", n[n.TEXTURE_CUBE_MAP_POSITIVE_Z = 34073] = "TEXTURE_CUBE_MAP_POSITIVE_Z", n[n.TEXTURE_CUBE_MAP_NEGATIVE_Z = 34074] = "TEXTURE_CUBE_MAP_NEGATIVE_Z";
})(TARGETS$4 || (TARGETS$4 = {}));
var TYPES$4;
(function(n) {
  n[n.UNSIGNED_BYTE = 5121] = "UNSIGNED_BYTE", n[n.UNSIGNED_SHORT = 5123] = "UNSIGNED_SHORT", n[n.UNSIGNED_SHORT_5_6_5 = 33635] = "UNSIGNED_SHORT_5_6_5", n[n.UNSIGNED_SHORT_4_4_4_4 = 32819] = "UNSIGNED_SHORT_4_4_4_4", n[n.UNSIGNED_SHORT_5_5_5_1 = 32820] = "UNSIGNED_SHORT_5_5_5_1", n[n.UNSIGNED_INT = 5125] = "UNSIGNED_INT", n[n.UNSIGNED_INT_10F_11F_11F_REV = 35899] = "UNSIGNED_INT_10F_11F_11F_REV", n[n.UNSIGNED_INT_2_10_10_10_REV = 33640] = "UNSIGNED_INT_2_10_10_10_REV", n[n.UNSIGNED_INT_24_8 = 34042] = "UNSIGNED_INT_24_8", n[n.UNSIGNED_INT_5_9_9_9_REV = 35902] = "UNSIGNED_INT_5_9_9_9_REV", n[n.BYTE = 5120] = "BYTE", n[n.SHORT = 5122] = "SHORT", n[n.INT = 5124] = "INT", n[n.FLOAT = 5126] = "FLOAT", n[n.FLOAT_32_UNSIGNED_INT_24_8_REV = 36269] = "FLOAT_32_UNSIGNED_INT_24_8_REV", n[n.HALF_FLOAT = 36193] = "HALF_FLOAT";
})(TYPES$4 || (TYPES$4 = {}));
var SAMPLER_TYPES$4;
(function(n) {
  n[n.FLOAT = 0] = "FLOAT", n[n.INT = 1] = "INT", n[n.UINT = 2] = "UINT";
})(SAMPLER_TYPES$4 || (SAMPLER_TYPES$4 = {}));
var SCALE_MODES$4;
(function(n) {
  n[n.NEAREST = 0] = "NEAREST", n[n.LINEAR = 1] = "LINEAR";
})(SCALE_MODES$4 || (SCALE_MODES$4 = {}));
var WRAP_MODES$4;
(function(n) {
  n[n.CLAMP = 33071] = "CLAMP", n[n.REPEAT = 10497] = "REPEAT", n[n.MIRRORED_REPEAT = 33648] = "MIRRORED_REPEAT";
})(WRAP_MODES$4 || (WRAP_MODES$4 = {}));
var MIPMAP_MODES$4;
(function(n) {
  n[n.OFF = 0] = "OFF", n[n.POW2 = 1] = "POW2", n[n.ON = 2] = "ON", n[n.ON_MANUAL = 3] = "ON_MANUAL";
})(MIPMAP_MODES$4 || (MIPMAP_MODES$4 = {}));
var ALPHA_MODES$4;
(function(n) {
  n[n.NPM = 0] = "NPM", n[n.UNPACK = 1] = "UNPACK", n[n.PMA = 2] = "PMA", n[n.NO_PREMULTIPLIED_ALPHA = 0] = "NO_PREMULTIPLIED_ALPHA", n[n.PREMULTIPLY_ON_UPLOAD = 1] = "PREMULTIPLY_ON_UPLOAD", n[n.PREMULTIPLY_ALPHA = 2] = "PREMULTIPLY_ALPHA", n[n.PREMULTIPLIED_ALPHA = 2] = "PREMULTIPLIED_ALPHA";
})(ALPHA_MODES$4 || (ALPHA_MODES$4 = {}));
var CLEAR_MODES$4;
(function(n) {
  n[n.NO = 0] = "NO", n[n.YES = 1] = "YES", n[n.AUTO = 2] = "AUTO", n[n.BLEND = 0] = "BLEND", n[n.CLEAR = 1] = "CLEAR", n[n.BLIT = 2] = "BLIT";
})(CLEAR_MODES$4 || (CLEAR_MODES$4 = {}));
var GC_MODES$4;
(function(n) {
  n[n.AUTO = 0] = "AUTO", n[n.MANUAL = 1] = "MANUAL";
})(GC_MODES$4 || (GC_MODES$4 = {}));
var PRECISION$4;
(function(n) {
  n.LOW = "lowp", n.MEDIUM = "mediump", n.HIGH = "highp";
})(PRECISION$4 || (PRECISION$4 = {}));
var MASK_TYPES$4;
(function(n) {
  n[n.NONE = 0] = "NONE", n[n.SCISSOR = 1] = "SCISSOR", n[n.STENCIL = 2] = "STENCIL", n[n.SPRITE = 3] = "SPRITE", n[n.COLOR = 4] = "COLOR";
})(MASK_TYPES$4 || (MASK_TYPES$4 = {}));
var COLOR_MASK_BITS$4;
(function(n) {
  n[n.RED = 1] = "RED", n[n.GREEN = 2] = "GREEN", n[n.BLUE = 4] = "BLUE", n[n.ALPHA = 8] = "ALPHA";
})(COLOR_MASK_BITS$4 || (COLOR_MASK_BITS$4 = {}));
var MSAA_QUALITY$4;
(function(n) {
  n[n.NONE = 0] = "NONE", n[n.LOW = 2] = "LOW", n[n.MEDIUM = 4] = "MEDIUM", n[n.HIGH = 8] = "HIGH";
})(MSAA_QUALITY$4 || (MSAA_QUALITY$4 = {}));
var BUFFER_TYPE$4;
(function(n) {
  n[n.ELEMENT_ARRAY_BUFFER = 34963] = "ELEMENT_ARRAY_BUFFER", n[n.ARRAY_BUFFER = 34962] = "ARRAY_BUFFER", n[n.UNIFORM_BUFFER = 35345] = "UNIFORM_BUFFER";
})(BUFFER_TYPE$4 || (BUFFER_TYPE$4 = {}));
function sortChildren(n, t) {
  return n.zIndex === t.zIndex ? n._lastSortedIndex - t._lastSortedIndex : n.zIndex - t.zIndex;
}
var Container = function(n) {
  __extends$p(t, n);
  function t() {
    var e = n.call(this) || this;
    return e.children = [], e.sortableChildren = settings$1.SORTABLE_CHILDREN, e.sortDirty = !1, e;
  }
  return t.prototype.onChildrenChange = function(e) {
  }, t.prototype.addChild = function() {
    for (var e = arguments, o = [], R = 0; R < arguments.length; R++)
      o[R] = e[R];
    if (o.length > 1)
      for (var N = 0; N < o.length; N++)
        this.addChild(o[N]);
    else {
      var M = o[0];
      M.parent && M.parent.removeChild(M), M.parent = this, this.sortDirty = !0, M.transform._parentID = -1, this.children.push(M), this._boundsID++, this.onChildrenChange(this.children.length - 1), this.emit("childAdded", M, this, this.children.length - 1), M.emit("added", this);
    }
    return o[0];
  }, t.prototype.addChildAt = function(e, o) {
    if (o < 0 || o > this.children.length)
      throw new Error(e + "addChildAt: The index " + o + " supplied is out of bounds " + this.children.length);
    return e.parent && e.parent.removeChild(e), e.parent = this, this.sortDirty = !0, e.transform._parentID = -1, this.children.splice(o, 0, e), this._boundsID++, this.onChildrenChange(o), e.emit("added", this), this.emit("childAdded", e, this, o), e;
  }, t.prototype.swapChildren = function(e, o) {
    if (e !== o) {
      var R = this.getChildIndex(e), N = this.getChildIndex(o);
      this.children[R] = o, this.children[N] = e, this.onChildrenChange(R < N ? R : N);
    }
  }, t.prototype.getChildIndex = function(e) {
    var o = this.children.indexOf(e);
    if (o === -1)
      throw new Error("The supplied DisplayObject must be a child of the caller");
    return o;
  }, t.prototype.setChildIndex = function(e, o) {
    if (o < 0 || o >= this.children.length)
      throw new Error("The index " + o + " supplied is out of bounds " + this.children.length);
    var R = this.getChildIndex(e);
    removeItems(this.children, R, 1), this.children.splice(o, 0, e), this.onChildrenChange(o);
  }, t.prototype.getChildAt = function(e) {
    if (e < 0 || e >= this.children.length)
      throw new Error("getChildAt: Index (" + e + ") does not exist.");
    return this.children[e];
  }, t.prototype.removeChild = function() {
    for (var e = arguments, o = [], R = 0; R < arguments.length; R++)
      o[R] = e[R];
    if (o.length > 1)
      for (var N = 0; N < o.length; N++)
        this.removeChild(o[N]);
    else {
      var M = o[0], D = this.children.indexOf(M);
      if (D === -1)
        return null;
      M.parent = null, M.transform._parentID = -1, removeItems(this.children, D, 1), this._boundsID++, this.onChildrenChange(D), M.emit("removed", this), this.emit("childRemoved", M, this, D);
    }
    return o[0];
  }, t.prototype.removeChildAt = function(e) {
    var o = this.getChildAt(e);
    return o.parent = null, o.transform._parentID = -1, removeItems(this.children, e, 1), this._boundsID++, this.onChildrenChange(e), o.emit("removed", this), this.emit("childRemoved", o, this, e), o;
  }, t.prototype.removeChildren = function(e, o) {
    e === void 0 && (e = 0), o === void 0 && (o = this.children.length);
    var R = e, N = o, M = N - R, D;
    if (M > 0 && M <= N) {
      D = this.children.splice(R, M);
      for (var L = 0; L < D.length; ++L)
        D[L].parent = null, D[L].transform && (D[L].transform._parentID = -1);
      this._boundsID++, this.onChildrenChange(e);
      for (var L = 0; L < D.length; ++L)
        D[L].emit("removed", this), this.emit("childRemoved", D[L], this, L);
      return D;
    } else if (M === 0 && this.children.length === 0)
      return [];
    throw new RangeError("removeChildren: numeric values are outside the acceptable range.");
  }, t.prototype.sortChildren = function() {
    for (var e = !1, o = 0, R = this.children.length; o < R; ++o) {
      var N = this.children[o];
      N._lastSortedIndex = o, !e && N.zIndex !== 0 && (e = !0);
    }
    e && this.children.length > 1 && this.children.sort(sortChildren), this.sortDirty = !1;
  }, t.prototype.updateTransform = function() {
    this.sortableChildren && this.sortDirty && this.sortChildren(), this._boundsID++, this.transform.updateTransform(this.parent.transform), this.worldAlpha = this.alpha * this.parent.worldAlpha;
    for (var e = 0, o = this.children.length; e < o; ++e) {
      var R = this.children[e];
      R.visible && R.updateTransform();
    }
  }, t.prototype.calculateBounds = function() {
    this._bounds.clear(), this._calculateBounds();
    for (var e = 0; e < this.children.length; e++) {
      var o = this.children[e];
      if (!(!o.visible || !o.renderable))
        if (o.calculateBounds(), o._mask) {
          var R = o._mask.isMaskData ? o._mask.maskObject : o._mask;
          R ? (R.calculateBounds(), this._bounds.addBoundsMask(o._bounds, R._bounds)) : this._bounds.addBounds(o._bounds);
        } else
          o.filterArea ? this._bounds.addBoundsArea(o._bounds, o.filterArea) : this._bounds.addBounds(o._bounds);
    }
    this._bounds.updateID = this._boundsID;
  }, t.prototype.getLocalBounds = function(e, o) {
    o === void 0 && (o = !1);
    var R = n.prototype.getLocalBounds.call(this, e);
    if (!o)
      for (var N = 0, M = this.children.length; N < M; ++N) {
        var D = this.children[N];
        D.visible && D.updateTransform();
      }
    return R;
  }, t.prototype._calculateBounds = function() {
  }, t.prototype._renderWithCulling = function(e) {
    var o = e.renderTexture.sourceFrame;
    if (o.width > 0 && o.height > 0) {
      var R, N;
      if (this.cullArea ? (R = this.cullArea, N = this.worldTransform) : this._render !== t.prototype._render && (R = this.getBounds(!0)), R && o.intersects(R, N))
        this._render(e);
      else if (this.cullArea)
        return;
      for (var M = 0, D = this.children.length; M < D; ++M) {
        var L = this.children[M], B = L.cullable;
        L.cullable = B || !this.cullArea, L.render(e), L.cullable = B;
      }
    }
  }, t.prototype.render = function(e) {
    if (!(!this.visible || this.worldAlpha <= 0 || !this.renderable))
      if (this._mask || this.filters && this.filters.length)
        this.renderAdvanced(e);
      else if (this.cullable)
        this._renderWithCulling(e);
      else {
        this._render(e);
        for (var o = 0, R = this.children.length; o < R; ++o)
          this.children[o].render(e);
      }
  }, t.prototype.renderAdvanced = function(e) {
    var o = this.filters, R = this._mask;
    if (o) {
      this._enabledFilters || (this._enabledFilters = []), this._enabledFilters.length = 0;
      for (var N = 0; N < o.length; N++)
        o[N].enabled && this._enabledFilters.push(o[N]);
    }
    var M = o && this._enabledFilters && this._enabledFilters.length || R && (!R.isMaskData || R.enabled && (R.autoDetect || R.type !== MASK_TYPES$4.NONE));
    if (M && e.batch.flush(), o && this._enabledFilters && this._enabledFilters.length && e.filter.push(this, this._enabledFilters), R && e.mask.push(this, this._mask), this.cullable)
      this._renderWithCulling(e);
    else {
      this._render(e);
      for (var N = 0, D = this.children.length; N < D; ++N)
        this.children[N].render(e);
    }
    M && e.batch.flush(), R && e.mask.pop(this), o && this._enabledFilters && this._enabledFilters.length && e.filter.pop();
  }, t.prototype._render = function(e) {
  }, t.prototype.destroy = function(e) {
    n.prototype.destroy.call(this), this.sortDirty = !1;
    var o = typeof e == "boolean" ? e : e && e.children, R = this.removeChildren(0, this.children.length);
    if (o)
      for (var N = 0; N < R.length; ++N)
        R[N].destroy(e);
  }, Object.defineProperty(t.prototype, "width", {
    get: function() {
      return this.scale.x * this.getLocalBounds().width;
    },
    set: function(e) {
      var o = this.getLocalBounds().width;
      o !== 0 ? this.scale.x = e / o : this.scale.x = 1, this._width = e;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(t.prototype, "height", {
    get: function() {
      return this.scale.y * this.getLocalBounds().height;
    },
    set: function(e) {
      var o = this.getLocalBounds().height;
      o !== 0 ? this.scale.y = e / o : this.scale.y = 1, this._height = e;
    },
    enumerable: !1,
    configurable: !0
  }), t;
}(DisplayObject);
Container.prototype.containerUpdateTransform = Container.prototype.updateTransform;
/*!
 * @pixi/accessibility - v6.5.2
 * Compiled Wed, 24 Aug 2022 13:51:19 UTC
 *
 * @pixi/accessibility is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
var accessibleTarget = {
  accessible: !1,
  accessibleTitle: null,
  accessibleHint: null,
  tabIndex: 0,
  _accessibleActive: !1,
  _accessibleDiv: null,
  accessibleType: "button",
  accessiblePointerEvents: "auto",
  accessibleChildren: !0,
  renderId: -1
};
DisplayObject.mixin(accessibleTarget);
var KEY_CODE_TAB = 9, DIV_TOUCH_SIZE = 100, DIV_TOUCH_POS_X = 0, DIV_TOUCH_POS_Y = 0, DIV_TOUCH_ZINDEX = 2, DIV_HOOK_SIZE = 1, DIV_HOOK_POS_X = -1e3, DIV_HOOK_POS_Y = -1e3, DIV_HOOK_ZINDEX = 2, AccessibilityManager = function() {
  function n(t) {
    this.debug = !1, this._isActive = !1, this._isMobileAccessibility = !1, this.pool = [], this.renderId = 0, this.children = [], this.androidUpdateCount = 0, this.androidUpdateFrequency = 500, this._hookDiv = null, (isMobile$2.tablet || isMobile$2.phone) && this.createTouchHook();
    var e = document.createElement("div");
    e.style.width = DIV_TOUCH_SIZE + "px", e.style.height = DIV_TOUCH_SIZE + "px", e.style.position = "absolute", e.style.top = DIV_TOUCH_POS_X + "px", e.style.left = DIV_TOUCH_POS_Y + "px", e.style.zIndex = DIV_TOUCH_ZINDEX.toString(), this.div = e, this.renderer = t, this._onKeyDown = this._onKeyDown.bind(this), this._onMouseMove = this._onMouseMove.bind(this), globalThis.addEventListener("keydown", this._onKeyDown, !1);
  }
  return Object.defineProperty(n.prototype, "isActive", {
    get: function() {
      return this._isActive;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(n.prototype, "isMobileAccessibility", {
    get: function() {
      return this._isMobileAccessibility;
    },
    enumerable: !1,
    configurable: !0
  }), n.prototype.createTouchHook = function() {
    var t = this, e = document.createElement("button");
    e.style.width = DIV_HOOK_SIZE + "px", e.style.height = DIV_HOOK_SIZE + "px", e.style.position = "absolute", e.style.top = DIV_HOOK_POS_X + "px", e.style.left = DIV_HOOK_POS_Y + "px", e.style.zIndex = DIV_HOOK_ZINDEX.toString(), e.style.backgroundColor = "#FF0000", e.title = "select to enable accessibility for this content", e.addEventListener("focus", function() {
      t._isMobileAccessibility = !0, t.activate(), t.destroyTouchHook();
    }), document.body.appendChild(e), this._hookDiv = e;
  }, n.prototype.destroyTouchHook = function() {
    !this._hookDiv || (document.body.removeChild(this._hookDiv), this._hookDiv = null);
  }, n.prototype.activate = function() {
    var t;
    this._isActive || (this._isActive = !0, globalThis.document.addEventListener("mousemove", this._onMouseMove, !0), globalThis.removeEventListener("keydown", this._onKeyDown, !1), this.renderer.on("postrender", this.update, this), (t = this.renderer.view.parentNode) === null || t === void 0 || t.appendChild(this.div));
  }, n.prototype.deactivate = function() {
    var t;
    !this._isActive || this._isMobileAccessibility || (this._isActive = !1, globalThis.document.removeEventListener("mousemove", this._onMouseMove, !0), globalThis.addEventListener("keydown", this._onKeyDown, !1), this.renderer.off("postrender", this.update), (t = this.div.parentNode) === null || t === void 0 || t.removeChild(this.div));
  }, n.prototype.updateAccessibleObjects = function(t) {
    if (!(!t.visible || !t.accessibleChildren)) {
      t.accessible && t.interactive && (t._accessibleActive || this.addChild(t), t.renderId = this.renderId);
      var e = t.children;
      if (e)
        for (var o = 0; o < e.length; o++)
          this.updateAccessibleObjects(e[o]);
    }
  }, n.prototype.update = function() {
    var t = performance.now();
    if (!(isMobile$2.android.device && t < this.androidUpdateCount) && (this.androidUpdateCount = t + this.androidUpdateFrequency, !!this.renderer.renderingToScreen)) {
      this.renderer._lastObjectRendered && this.updateAccessibleObjects(this.renderer._lastObjectRendered);
      var e = this.renderer.view.getBoundingClientRect(), o = e.left, R = e.top, N = e.width, M = e.height, D = this.renderer, L = D.width, B = D.height, $ = D.resolution, k = N / L * $, U = M / B * $, z = this.div;
      z.style.left = o + "px", z.style.top = R + "px", z.style.width = L + "px", z.style.height = B + "px";
      for (var X = 0; X < this.children.length; X++) {
        var V = this.children[X];
        if (V.renderId !== this.renderId)
          V._accessibleActive = !1, removeItems(this.children, X, 1), this.div.removeChild(V._accessibleDiv), this.pool.push(V._accessibleDiv), V._accessibleDiv = null, X--;
        else {
          z = V._accessibleDiv;
          var W = V.hitArea, Y = V.worldTransform;
          V.hitArea ? (z.style.left = (Y.tx + W.x * Y.a) * k + "px", z.style.top = (Y.ty + W.y * Y.d) * U + "px", z.style.width = W.width * Y.a * k + "px", z.style.height = W.height * Y.d * U + "px") : (W = V.getBounds(), this.capHitArea(W), z.style.left = W.x * k + "px", z.style.top = W.y * U + "px", z.style.width = W.width * k + "px", z.style.height = W.height * U + "px", z.title !== V.accessibleTitle && V.accessibleTitle !== null && (z.title = V.accessibleTitle), z.getAttribute("aria-label") !== V.accessibleHint && V.accessibleHint !== null && z.setAttribute("aria-label", V.accessibleHint)), (V.accessibleTitle !== z.title || V.tabIndex !== z.tabIndex) && (z.title = V.accessibleTitle, z.tabIndex = V.tabIndex, this.debug && this.updateDebugHTML(z));
        }
      }
      this.renderId++;
    }
  }, n.prototype.updateDebugHTML = function(t) {
    t.innerHTML = "type: " + t.type + "</br> title : " + t.title + "</br> tabIndex: " + t.tabIndex;
  }, n.prototype.capHitArea = function(t) {
    t.x < 0 && (t.width += t.x, t.x = 0), t.y < 0 && (t.height += t.y, t.y = 0);
    var e = this.renderer, o = e.width, R = e.height;
    t.x + t.width > o && (t.width = o - t.x), t.y + t.height > R && (t.height = R - t.y);
  }, n.prototype.addChild = function(t) {
    var e = this.pool.pop();
    e || (e = document.createElement("button"), e.style.width = DIV_TOUCH_SIZE + "px", e.style.height = DIV_TOUCH_SIZE + "px", e.style.backgroundColor = this.debug ? "rgba(255,255,255,0.5)" : "transparent", e.style.position = "absolute", e.style.zIndex = DIV_TOUCH_ZINDEX.toString(), e.style.borderStyle = "none", navigator.userAgent.toLowerCase().indexOf("chrome") > -1 ? e.setAttribute("aria-live", "off") : e.setAttribute("aria-live", "polite"), navigator.userAgent.match(/rv:.*Gecko\//) ? e.setAttribute("aria-relevant", "additions") : e.setAttribute("aria-relevant", "text"), e.addEventListener("click", this._onClick.bind(this)), e.addEventListener("focus", this._onFocus.bind(this)), e.addEventListener("focusout", this._onFocusOut.bind(this))), e.style.pointerEvents = t.accessiblePointerEvents, e.type = t.accessibleType, t.accessibleTitle && t.accessibleTitle !== null ? e.title = t.accessibleTitle : (!t.accessibleHint || t.accessibleHint === null) && (e.title = "displayObject " + t.tabIndex), t.accessibleHint && t.accessibleHint !== null && e.setAttribute("aria-label", t.accessibleHint), this.debug && this.updateDebugHTML(e), t._accessibleActive = !0, t._accessibleDiv = e, e.displayObject = t, this.children.push(t), this.div.appendChild(t._accessibleDiv), t._accessibleDiv.tabIndex = t.tabIndex;
  }, n.prototype._onClick = function(t) {
    var e = this.renderer.plugins.interaction, o = t.target.displayObject, R = e.eventData;
    e.dispatchEvent(o, "click", R), e.dispatchEvent(o, "pointertap", R), e.dispatchEvent(o, "tap", R);
  }, n.prototype._onFocus = function(t) {
    t.target.getAttribute("aria-live") || t.target.setAttribute("aria-live", "assertive");
    var e = this.renderer.plugins.interaction, o = t.target.displayObject, R = e.eventData;
    e.dispatchEvent(o, "mouseover", R);
  }, n.prototype._onFocusOut = function(t) {
    t.target.getAttribute("aria-live") || t.target.setAttribute("aria-live", "polite");
    var e = this.renderer.plugins.interaction, o = t.target.displayObject, R = e.eventData;
    e.dispatchEvent(o, "mouseout", R);
  }, n.prototype._onKeyDown = function(t) {
    t.keyCode === KEY_CODE_TAB && this.activate();
  }, n.prototype._onMouseMove = function(t) {
    t.movementX === 0 && t.movementY === 0 || this.deactivate();
  }, n.prototype.destroy = function() {
    this.destroyTouchHook(), this.div = null, globalThis.document.removeEventListener("mousemove", this._onMouseMove, !0), globalThis.removeEventListener("keydown", this._onKeyDown), this.pool = null, this.children = null, this.renderer = null;
  }, n.extension = {
    name: "accessibility",
    type: [
      ExtensionType.RendererPlugin,
      ExtensionType.CanvasRendererPlugin
    ]
  }, n;
}();
/*!
 * @pixi/interaction - v6.5.2
 * Compiled Wed, 24 Aug 2022 13:51:19 UTC
 *
 * @pixi/interaction is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
var InteractionData = function() {
  function n() {
    this.pressure = 0, this.rotationAngle = 0, this.twist = 0, this.tangentialPressure = 0, this.global = new Point(), this.target = null, this.originalEvent = null, this.identifier = null, this.isPrimary = !1, this.button = 0, this.buttons = 0, this.width = 0, this.height = 0, this.tiltX = 0, this.tiltY = 0, this.pointerType = null, this.pressure = 0, this.rotationAngle = 0, this.twist = 0, this.tangentialPressure = 0;
  }
  return Object.defineProperty(n.prototype, "pointerId", {
    get: function() {
      return this.identifier;
    },
    enumerable: !1,
    configurable: !0
  }), n.prototype.getLocalPosition = function(t, e, o) {
    return t.worldTransform.applyInverse(o || this.global, e);
  }, n.prototype.copyEvent = function(t) {
    "isPrimary" in t && t.isPrimary && (this.isPrimary = !0), this.button = "button" in t && t.button;
    var e = "buttons" in t && t.buttons;
    this.buttons = Number.isInteger(e) ? e : "which" in t && t.which, this.width = "width" in t && t.width, this.height = "height" in t && t.height, this.tiltX = "tiltX" in t && t.tiltX, this.tiltY = "tiltY" in t && t.tiltY, this.pointerType = "pointerType" in t && t.pointerType, this.pressure = "pressure" in t && t.pressure, this.rotationAngle = "rotationAngle" in t && t.rotationAngle, this.twist = "twist" in t && t.twist || 0, this.tangentialPressure = "tangentialPressure" in t && t.tangentialPressure || 0;
  }, n.prototype.reset = function() {
    this.isPrimary = !1;
  }, n;
}();
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var extendStatics$o = function(n, t) {
  return extendStatics$o = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(e, o) {
    e.__proto__ = o;
  } || function(e, o) {
    for (var R in o)
      o.hasOwnProperty(R) && (e[R] = o[R]);
  }, extendStatics$o(n, t);
};
function __extends$o(n, t) {
  extendStatics$o(n, t);
  function e() {
    this.constructor = n;
  }
  n.prototype = t === null ? Object.create(t) : (e.prototype = t.prototype, new e());
}
var InteractionEvent = function() {
  function n() {
    this.stopped = !1, this.stopsPropagatingAt = null, this.stopPropagationHint = !1, this.target = null, this.currentTarget = null, this.type = null, this.data = null;
  }
  return n.prototype.stopPropagation = function() {
    this.stopped = !0, this.stopPropagationHint = !0, this.stopsPropagatingAt = this.currentTarget;
  }, n.prototype.reset = function() {
    this.stopped = !1, this.stopsPropagatingAt = null, this.stopPropagationHint = !1, this.currentTarget = null, this.target = null;
  }, n;
}(), InteractionTrackingData = function() {
  function n(t) {
    this._pointerId = t, this._flags = n.FLAGS.NONE;
  }
  return n.prototype._doSet = function(t, e) {
    e ? this._flags = this._flags | t : this._flags = this._flags & ~t;
  }, Object.defineProperty(n.prototype, "pointerId", {
    get: function() {
      return this._pointerId;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(n.prototype, "flags", {
    get: function() {
      return this._flags;
    },
    set: function(t) {
      this._flags = t;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(n.prototype, "none", {
    get: function() {
      return this._flags === n.FLAGS.NONE;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(n.prototype, "over", {
    get: function() {
      return (this._flags & n.FLAGS.OVER) !== 0;
    },
    set: function(t) {
      this._doSet(n.FLAGS.OVER, t);
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(n.prototype, "rightDown", {
    get: function() {
      return (this._flags & n.FLAGS.RIGHT_DOWN) !== 0;
    },
    set: function(t) {
      this._doSet(n.FLAGS.RIGHT_DOWN, t);
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(n.prototype, "leftDown", {
    get: function() {
      return (this._flags & n.FLAGS.LEFT_DOWN) !== 0;
    },
    set: function(t) {
      this._doSet(n.FLAGS.LEFT_DOWN, t);
    },
    enumerable: !1,
    configurable: !0
  }), n.FLAGS = Object.freeze({
    NONE: 0,
    OVER: 1 << 0,
    LEFT_DOWN: 1 << 1,
    RIGHT_DOWN: 1 << 2
  }), n;
}(), TreeSearch = function() {
  function n() {
    this._tempPoint = new Point();
  }
  return n.prototype.recursiveFindHit = function(t, e, o, R, N) {
    var M;
    if (!e || !e.visible)
      return !1;
    var D = t.data.global;
    N = e.interactive || N;
    var L = !1, B = N, $ = !0;
    if (e.hitArea)
      R && (e.worldTransform.applyInverse(D, this._tempPoint), e.hitArea.contains(this._tempPoint.x, this._tempPoint.y) ? L = !0 : (R = !1, $ = !1)), B = !1;
    else if (e._mask && R) {
      var k = e._mask.isMaskData ? e._mask.maskObject : e._mask;
      k && !(!((M = k.containsPoint) === null || M === void 0) && M.call(k, D)) && (R = !1);
    }
    if ($ && e.interactiveChildren && e.children)
      for (var U = e.children, z = U.length - 1; z >= 0; z--) {
        var X = U[z], V = this.recursiveFindHit(t, X, o, R, B);
        if (V) {
          if (!X.parent)
            continue;
          B = !1, V && (t.target && (R = !1), L = !0);
        }
      }
    return N && (R && !t.target && !e.hitArea && e.containsPoint && e.containsPoint(D) && (L = !0), e.interactive && (L && !t.target && (t.target = e), o && o(t, e, !!L))), L;
  }, n.prototype.findHit = function(t, e, o, R) {
    this.recursiveFindHit(t, e, o, R, !1);
  }, n;
}(), interactiveTarget = {
  interactive: !1,
  interactiveChildren: !0,
  hitArea: null,
  get buttonMode() {
    return this.cursor === "pointer";
  },
  set buttonMode(n) {
    n ? this.cursor = "pointer" : this.cursor === "pointer" && (this.cursor = null);
  },
  cursor: null,
  get trackedPointers() {
    return this._trackedPointers === void 0 && (this._trackedPointers = {}), this._trackedPointers;
  },
  _trackedPointers: void 0
};
DisplayObject.mixin(interactiveTarget);
var MOUSE_POINTER_ID = 1, hitTestEvent = {
  target: null,
  data: {
    global: null
  }
}, InteractionManager = function(n) {
  __extends$o(t, n);
  function t(e, o) {
    var R = n.call(this) || this;
    return o = o || {}, R.renderer = e, R.autoPreventDefault = o.autoPreventDefault !== void 0 ? o.autoPreventDefault : !0, R.interactionFrequency = o.interactionFrequency || 10, R.mouse = new InteractionData(), R.mouse.identifier = MOUSE_POINTER_ID, R.mouse.global.set(-999999), R.activeInteractionData = {}, R.activeInteractionData[MOUSE_POINTER_ID] = R.mouse, R.interactionDataPool = [], R.eventData = new InteractionEvent(), R.interactionDOMElement = null, R.moveWhenInside = !1, R.eventsAdded = !1, R.tickerAdded = !1, R.mouseOverRenderer = !("PointerEvent" in globalThis), R.supportsTouchEvents = "ontouchstart" in globalThis, R.supportsPointerEvents = !!globalThis.PointerEvent, R.onPointerUp = R.onPointerUp.bind(R), R.processPointerUp = R.processPointerUp.bind(R), R.onPointerCancel = R.onPointerCancel.bind(R), R.processPointerCancel = R.processPointerCancel.bind(R), R.onPointerDown = R.onPointerDown.bind(R), R.processPointerDown = R.processPointerDown.bind(R), R.onPointerMove = R.onPointerMove.bind(R), R.processPointerMove = R.processPointerMove.bind(R), R.onPointerOut = R.onPointerOut.bind(R), R.processPointerOverOut = R.processPointerOverOut.bind(R), R.onPointerOver = R.onPointerOver.bind(R), R.cursorStyles = {
      default: "inherit",
      pointer: "pointer"
    }, R.currentCursorMode = null, R.cursor = null, R.resolution = 1, R.delayedEvents = [], R.search = new TreeSearch(), R._tempDisplayObject = new TemporaryDisplayObject(), R._eventListenerOptions = { capture: !0, passive: !1 }, R._useSystemTicker = o.useSystemTicker !== void 0 ? o.useSystemTicker : !0, R.setTargetElement(R.renderer.view, R.renderer.resolution), R;
  }
  return Object.defineProperty(t.prototype, "useSystemTicker", {
    get: function() {
      return this._useSystemTicker;
    },
    set: function(e) {
      this._useSystemTicker = e, e ? this.addTickerListener() : this.removeTickerListener();
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(t.prototype, "lastObjectRendered", {
    get: function() {
      return this.renderer._lastObjectRendered || this._tempDisplayObject;
    },
    enumerable: !1,
    configurable: !0
  }), t.prototype.hitTest = function(e, o) {
    return hitTestEvent.target = null, hitTestEvent.data.global = e, o || (o = this.lastObjectRendered), this.processInteractive(hitTestEvent, o, null, !0), hitTestEvent.target;
  }, t.prototype.setTargetElement = function(e, o) {
    o === void 0 && (o = 1), this.removeTickerListener(), this.removeEvents(), this.interactionDOMElement = e, this.resolution = o, this.addEvents(), this.addTickerListener();
  }, t.prototype.addTickerListener = function() {
    this.tickerAdded || !this.interactionDOMElement || !this._useSystemTicker || (Ticker.system.add(this.tickerUpdate, this, UPDATE_PRIORITY.INTERACTION), this.tickerAdded = !0);
  }, t.prototype.removeTickerListener = function() {
    !this.tickerAdded || (Ticker.system.remove(this.tickerUpdate, this), this.tickerAdded = !1);
  }, t.prototype.addEvents = function() {
    if (!(this.eventsAdded || !this.interactionDOMElement)) {
      var e = this.interactionDOMElement.style;
      globalThis.navigator.msPointerEnabled ? (e.msContentZooming = "none", e.msTouchAction = "none") : this.supportsPointerEvents && (e.touchAction = "none"), this.supportsPointerEvents ? (globalThis.document.addEventListener("pointermove", this.onPointerMove, this._eventListenerOptions), this.interactionDOMElement.addEventListener("pointerdown", this.onPointerDown, this._eventListenerOptions), this.interactionDOMElement.addEventListener("pointerleave", this.onPointerOut, this._eventListenerOptions), this.interactionDOMElement.addEventListener("pointerover", this.onPointerOver, this._eventListenerOptions), globalThis.addEventListener("pointercancel", this.onPointerCancel, this._eventListenerOptions), globalThis.addEventListener("pointerup", this.onPointerUp, this._eventListenerOptions)) : (globalThis.document.addEventListener("mousemove", this.onPointerMove, this._eventListenerOptions), this.interactionDOMElement.addEventListener("mousedown", this.onPointerDown, this._eventListenerOptions), this.interactionDOMElement.addEventListener("mouseout", this.onPointerOut, this._eventListenerOptions), this.interactionDOMElement.addEventListener("mouseover", this.onPointerOver, this._eventListenerOptions), globalThis.addEventListener("mouseup", this.onPointerUp, this._eventListenerOptions)), this.supportsTouchEvents && (this.interactionDOMElement.addEventListener("touchstart", this.onPointerDown, this._eventListenerOptions), this.interactionDOMElement.addEventListener("touchcancel", this.onPointerCancel, this._eventListenerOptions), this.interactionDOMElement.addEventListener("touchend", this.onPointerUp, this._eventListenerOptions), this.interactionDOMElement.addEventListener("touchmove", this.onPointerMove, this._eventListenerOptions)), this.eventsAdded = !0;
    }
  }, t.prototype.removeEvents = function() {
    if (!(!this.eventsAdded || !this.interactionDOMElement)) {
      var e = this.interactionDOMElement.style;
      globalThis.navigator.msPointerEnabled ? (e.msContentZooming = "", e.msTouchAction = "") : this.supportsPointerEvents && (e.touchAction = ""), this.supportsPointerEvents ? (globalThis.document.removeEventListener("pointermove", this.onPointerMove, this._eventListenerOptions), this.interactionDOMElement.removeEventListener("pointerdown", this.onPointerDown, this._eventListenerOptions), this.interactionDOMElement.removeEventListener("pointerleave", this.onPointerOut, this._eventListenerOptions), this.interactionDOMElement.removeEventListener("pointerover", this.onPointerOver, this._eventListenerOptions), globalThis.removeEventListener("pointercancel", this.onPointerCancel, this._eventListenerOptions), globalThis.removeEventListener("pointerup", this.onPointerUp, this._eventListenerOptions)) : (globalThis.document.removeEventListener("mousemove", this.onPointerMove, this._eventListenerOptions), this.interactionDOMElement.removeEventListener("mousedown", this.onPointerDown, this._eventListenerOptions), this.interactionDOMElement.removeEventListener("mouseout", this.onPointerOut, this._eventListenerOptions), this.interactionDOMElement.removeEventListener("mouseover", this.onPointerOver, this._eventListenerOptions), globalThis.removeEventListener("mouseup", this.onPointerUp, this._eventListenerOptions)), this.supportsTouchEvents && (this.interactionDOMElement.removeEventListener("touchstart", this.onPointerDown, this._eventListenerOptions), this.interactionDOMElement.removeEventListener("touchcancel", this.onPointerCancel, this._eventListenerOptions), this.interactionDOMElement.removeEventListener("touchend", this.onPointerUp, this._eventListenerOptions), this.interactionDOMElement.removeEventListener("touchmove", this.onPointerMove, this._eventListenerOptions)), this.interactionDOMElement = null, this.eventsAdded = !1;
    }
  }, t.prototype.tickerUpdate = function(e) {
    this._deltaTime += e, !(this._deltaTime < this.interactionFrequency) && (this._deltaTime = 0, this.update());
  }, t.prototype.update = function() {
    if (!!this.interactionDOMElement) {
      if (this._didMove) {
        this._didMove = !1;
        return;
      }
      this.cursor = null;
      for (var e in this.activeInteractionData)
        if (this.activeInteractionData.hasOwnProperty(e)) {
          var o = this.activeInteractionData[e];
          if (o.originalEvent && o.pointerType !== "touch") {
            var R = this.configureInteractionEventForDOMEvent(this.eventData, o.originalEvent, o);
            this.processInteractive(R, this.lastObjectRendered, this.processPointerOverOut, !0);
          }
        }
      this.setCursorMode(this.cursor);
    }
  }, t.prototype.setCursorMode = function(e) {
    e = e || "default";
    var o = !0;
    if (globalThis.OffscreenCanvas && this.interactionDOMElement instanceof OffscreenCanvas && (o = !1), this.currentCursorMode !== e) {
      this.currentCursorMode = e;
      var R = this.cursorStyles[e];
      if (R)
        switch (typeof R) {
          case "string":
            o && (this.interactionDOMElement.style.cursor = R);
            break;
          case "function":
            R(e);
            break;
          case "object":
            o && Object.assign(this.interactionDOMElement.style, R);
            break;
        }
      else
        o && typeof e == "string" && !Object.prototype.hasOwnProperty.call(this.cursorStyles, e) && (this.interactionDOMElement.style.cursor = e);
    }
  }, t.prototype.dispatchEvent = function(e, o, R) {
    (!R.stopPropagationHint || e === R.stopsPropagatingAt) && (R.currentTarget = e, R.type = o, e.emit(o, R), e[o] && e[o](R));
  }, t.prototype.delayDispatchEvent = function(e, o, R) {
    this.delayedEvents.push({ displayObject: e, eventString: o, eventData: R });
  }, t.prototype.mapPositionToPoint = function(e, o, R) {
    var N;
    this.interactionDOMElement.parentElement ? N = this.interactionDOMElement.getBoundingClientRect() : N = {
      x: 0,
      y: 0,
      width: this.interactionDOMElement.width,
      height: this.interactionDOMElement.height,
      left: 0,
      top: 0
    };
    var M = 1 / this.resolution;
    e.x = (o - N.left) * (this.interactionDOMElement.width / N.width) * M, e.y = (R - N.top) * (this.interactionDOMElement.height / N.height) * M;
  }, t.prototype.processInteractive = function(e, o, R, N) {
    var M = this.search.findHit(e, o, R, N), D = this.delayedEvents;
    if (!D.length)
      return M;
    e.stopPropagationHint = !1;
    var L = D.length;
    this.delayedEvents = [];
    for (var B = 0; B < L; B++) {
      var $ = D[B], k = $.displayObject, U = $.eventString, z = $.eventData;
      z.stopsPropagatingAt === k && (z.stopPropagationHint = !0), this.dispatchEvent(k, U, z);
    }
    return M;
  }, t.prototype.onPointerDown = function(e) {
    if (!(this.supportsTouchEvents && e.pointerType === "touch")) {
      var o = this.normalizeToPointerData(e);
      if (this.autoPreventDefault && o[0].isNormalized) {
        var R = e.cancelable || !("cancelable" in e);
        R && e.preventDefault();
      }
      for (var N = o.length, M = 0; M < N; M++) {
        var D = o[M], L = this.getInteractionDataForPointerId(D), B = this.configureInteractionEventForDOMEvent(this.eventData, D, L);
        if (B.data.originalEvent = e, this.processInteractive(B, this.lastObjectRendered, this.processPointerDown, !0), this.emit("pointerdown", B), D.pointerType === "touch")
          this.emit("touchstart", B);
        else if (D.pointerType === "mouse" || D.pointerType === "pen") {
          var $ = D.button === 2;
          this.emit($ ? "rightdown" : "mousedown", this.eventData);
        }
      }
    }
  }, t.prototype.processPointerDown = function(e, o, R) {
    var N = e.data, M = e.data.identifier;
    if (R) {
      if (o.trackedPointers[M] || (o.trackedPointers[M] = new InteractionTrackingData(M)), this.dispatchEvent(o, "pointerdown", e), N.pointerType === "touch")
        this.dispatchEvent(o, "touchstart", e);
      else if (N.pointerType === "mouse" || N.pointerType === "pen") {
        var D = N.button === 2;
        D ? o.trackedPointers[M].rightDown = !0 : o.trackedPointers[M].leftDown = !0, this.dispatchEvent(o, D ? "rightdown" : "mousedown", e);
      }
    }
  }, t.prototype.onPointerComplete = function(e, o, R) {
    var N = this.normalizeToPointerData(e), M = N.length, D = e.target;
    e.composedPath && e.composedPath().length > 0 && (D = e.composedPath()[0]);
    for (var L = D !== this.interactionDOMElement ? "outside" : "", B = 0; B < M; B++) {
      var $ = N[B], k = this.getInteractionDataForPointerId($), U = this.configureInteractionEventForDOMEvent(this.eventData, $, k);
      if (U.data.originalEvent = e, this.processInteractive(U, this.lastObjectRendered, R, o || !L), this.emit(o ? "pointercancel" : "pointerup" + L, U), $.pointerType === "mouse" || $.pointerType === "pen") {
        var z = $.button === 2;
        this.emit(z ? "rightup" + L : "mouseup" + L, U);
      } else
        $.pointerType === "touch" && (this.emit(o ? "touchcancel" : "touchend" + L, U), this.releaseInteractionDataForPointerId($.pointerId));
    }
  }, t.prototype.onPointerCancel = function(e) {
    this.supportsTouchEvents && e.pointerType === "touch" || this.onPointerComplete(e, !0, this.processPointerCancel);
  }, t.prototype.processPointerCancel = function(e, o) {
    var R = e.data, N = e.data.identifier;
    o.trackedPointers[N] !== void 0 && (delete o.trackedPointers[N], this.dispatchEvent(o, "pointercancel", e), R.pointerType === "touch" && this.dispatchEvent(o, "touchcancel", e));
  }, t.prototype.onPointerUp = function(e) {
    this.supportsTouchEvents && e.pointerType === "touch" || this.onPointerComplete(e, !1, this.processPointerUp);
  }, t.prototype.processPointerUp = function(e, o, R) {
    var N = e.data, M = e.data.identifier, D = o.trackedPointers[M], L = N.pointerType === "touch", B = N.pointerType === "mouse" || N.pointerType === "pen", $ = !1;
    if (B) {
      var k = N.button === 2, U = InteractionTrackingData.FLAGS, z = k ? U.RIGHT_DOWN : U.LEFT_DOWN, X = D !== void 0 && D.flags & z;
      R ? (this.dispatchEvent(o, k ? "rightup" : "mouseup", e), X && (this.dispatchEvent(o, k ? "rightclick" : "click", e), $ = !0)) : X && this.dispatchEvent(o, k ? "rightupoutside" : "mouseupoutside", e), D && (k ? D.rightDown = !1 : D.leftDown = !1);
    }
    R ? (this.dispatchEvent(o, "pointerup", e), L && this.dispatchEvent(o, "touchend", e), D && ((!B || $) && this.dispatchEvent(o, "pointertap", e), L && (this.dispatchEvent(o, "tap", e), D.over = !1))) : D && (this.dispatchEvent(o, "pointerupoutside", e), L && this.dispatchEvent(o, "touchendoutside", e)), D && D.none && delete o.trackedPointers[M];
  }, t.prototype.onPointerMove = function(e) {
    if (!(this.supportsTouchEvents && e.pointerType === "touch")) {
      var o = this.normalizeToPointerData(e);
      (o[0].pointerType === "mouse" || o[0].pointerType === "pen") && (this._didMove = !0, this.cursor = null);
      for (var R = o.length, N = 0; N < R; N++) {
        var M = o[N], D = this.getInteractionDataForPointerId(M), L = this.configureInteractionEventForDOMEvent(this.eventData, M, D);
        L.data.originalEvent = e, this.processInteractive(L, this.lastObjectRendered, this.processPointerMove, !0), this.emit("pointermove", L), M.pointerType === "touch" && this.emit("touchmove", L), (M.pointerType === "mouse" || M.pointerType === "pen") && this.emit("mousemove", L);
      }
      o[0].pointerType === "mouse" && this.setCursorMode(this.cursor);
    }
  }, t.prototype.processPointerMove = function(e, o, R) {
    var N = e.data, M = N.pointerType === "touch", D = N.pointerType === "mouse" || N.pointerType === "pen";
    D && this.processPointerOverOut(e, o, R), (!this.moveWhenInside || R) && (this.dispatchEvent(o, "pointermove", e), M && this.dispatchEvent(o, "touchmove", e), D && this.dispatchEvent(o, "mousemove", e));
  }, t.prototype.onPointerOut = function(e) {
    if (!(this.supportsTouchEvents && e.pointerType === "touch")) {
      var o = this.normalizeToPointerData(e), R = o[0];
      R.pointerType === "mouse" && (this.mouseOverRenderer = !1, this.setCursorMode(null));
      var N = this.getInteractionDataForPointerId(R), M = this.configureInteractionEventForDOMEvent(this.eventData, R, N);
      M.data.originalEvent = R, this.processInteractive(M, this.lastObjectRendered, this.processPointerOverOut, !1), this.emit("pointerout", M), R.pointerType === "mouse" || R.pointerType === "pen" ? this.emit("mouseout", M) : this.releaseInteractionDataForPointerId(N.identifier);
    }
  }, t.prototype.processPointerOverOut = function(e, o, R) {
    var N = e.data, M = e.data.identifier, D = N.pointerType === "mouse" || N.pointerType === "pen", L = o.trackedPointers[M];
    R && !L && (L = o.trackedPointers[M] = new InteractionTrackingData(M)), L !== void 0 && (R && this.mouseOverRenderer ? (L.over || (L.over = !0, this.delayDispatchEvent(o, "pointerover", e), D && this.delayDispatchEvent(o, "mouseover", e)), D && this.cursor === null && (this.cursor = o.cursor)) : L.over && (L.over = !1, this.dispatchEvent(o, "pointerout", this.eventData), D && this.dispatchEvent(o, "mouseout", e), L.none && delete o.trackedPointers[M]));
  }, t.prototype.onPointerOver = function(e) {
    var o = this.normalizeToPointerData(e), R = o[0], N = this.getInteractionDataForPointerId(R), M = this.configureInteractionEventForDOMEvent(this.eventData, R, N);
    M.data.originalEvent = R, R.pointerType === "mouse" && (this.mouseOverRenderer = !0), this.emit("pointerover", M), (R.pointerType === "mouse" || R.pointerType === "pen") && this.emit("mouseover", M);
  }, t.prototype.getInteractionDataForPointerId = function(e) {
    var o = e.pointerId, R;
    return o === MOUSE_POINTER_ID || e.pointerType === "mouse" ? R = this.mouse : this.activeInteractionData[o] ? R = this.activeInteractionData[o] : (R = this.interactionDataPool.pop() || new InteractionData(), R.identifier = o, this.activeInteractionData[o] = R), R.copyEvent(e), R;
  }, t.prototype.releaseInteractionDataForPointerId = function(e) {
    var o = this.activeInteractionData[e];
    o && (delete this.activeInteractionData[e], o.reset(), this.interactionDataPool.push(o));
  }, t.prototype.configureInteractionEventForDOMEvent = function(e, o, R) {
    return e.data = R, this.mapPositionToPoint(R.global, o.clientX, o.clientY), o.pointerType === "touch" && (o.globalX = R.global.x, o.globalY = R.global.y), R.originalEvent = o, e.reset(), e;
  }, t.prototype.normalizeToPointerData = function(e) {
    var o = [];
    if (this.supportsTouchEvents && e instanceof TouchEvent)
      for (var R = 0, N = e.changedTouches.length; R < N; R++) {
        var M = e.changedTouches[R];
        typeof M.button > "u" && (M.button = e.touches.length ? 1 : 0), typeof M.buttons > "u" && (M.buttons = e.touches.length ? 1 : 0), typeof M.isPrimary > "u" && (M.isPrimary = e.touches.length === 1 && e.type === "touchstart"), typeof M.width > "u" && (M.width = M.radiusX || 1), typeof M.height > "u" && (M.height = M.radiusY || 1), typeof M.tiltX > "u" && (M.tiltX = 0), typeof M.tiltY > "u" && (M.tiltY = 0), typeof M.pointerType > "u" && (M.pointerType = "touch"), typeof M.pointerId > "u" && (M.pointerId = M.identifier || 0), typeof M.pressure > "u" && (M.pressure = M.force || 0.5), typeof M.twist > "u" && (M.twist = 0), typeof M.tangentialPressure > "u" && (M.tangentialPressure = 0), typeof M.layerX > "u" && (M.layerX = M.offsetX = M.clientX), typeof M.layerY > "u" && (M.layerY = M.offsetY = M.clientY), M.isNormalized = !0, o.push(M);
      }
    else if (!globalThis.MouseEvent || e instanceof MouseEvent && (!this.supportsPointerEvents || !(e instanceof globalThis.PointerEvent))) {
      var D = e;
      typeof D.isPrimary > "u" && (D.isPrimary = !0), typeof D.width > "u" && (D.width = 1), typeof D.height > "u" && (D.height = 1), typeof D.tiltX > "u" && (D.tiltX = 0), typeof D.tiltY > "u" && (D.tiltY = 0), typeof D.pointerType > "u" && (D.pointerType = "mouse"), typeof D.pointerId > "u" && (D.pointerId = MOUSE_POINTER_ID), typeof D.pressure > "u" && (D.pressure = 0.5), typeof D.twist > "u" && (D.twist = 0), typeof D.tangentialPressure > "u" && (D.tangentialPressure = 0), D.isNormalized = !0, o.push(D);
    } else
      o.push(e);
    return o;
  }, t.prototype.destroy = function() {
    this.removeEvents(), this.removeTickerListener(), this.removeAllListeners(), this.renderer = null, this.mouse = null, this.eventData = null, this.interactionDOMElement = null, this.onPointerDown = null, this.processPointerDown = null, this.onPointerUp = null, this.processPointerUp = null, this.onPointerCancel = null, this.processPointerCancel = null, this.onPointerMove = null, this.processPointerMove = null, this.onPointerOut = null, this.processPointerOverOut = null, this.onPointerOver = null, this.search = null;
  }, t.extension = {
    name: "interaction",
    type: [
      ExtensionType.RendererPlugin,
      ExtensionType.CanvasRendererPlugin
    ]
  }, t;
}(EventEmitter$4);
/*!
 * @pixi/extract - v6.5.2
 * Compiled Wed, 24 Aug 2022 13:51:19 UTC
 *
 * @pixi/extract is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
var TEMP_RECT = new Rectangle(), BYTES_PER_PIXEL = 4, Extract = function() {
  function n(t) {
    this.renderer = t;
  }
  return n.prototype.image = function(t, e, o) {
    var R = new Image();
    return R.src = this.base64(t, e, o), R;
  }, n.prototype.base64 = function(t, e, o) {
    return this.canvas(t).toDataURL(e, o);
  }, n.prototype.canvas = function(t, e) {
    var o = this.renderer, R, N = !1, M, D = !1;
    t && (t instanceof RenderTexture ? M = t : (M = this.renderer.generateTexture(t), D = !0)), M ? (R = M.baseTexture.resolution, e = e != null ? e : M.frame, N = !1, o.renderTexture.bind(M)) : (R = o.resolution, e || (e = TEMP_RECT, e.width = o.width, e.height = o.height), N = !0, o.renderTexture.bind(null));
    var L = Math.round(e.width * R), B = Math.round(e.height * R), $ = new CanvasRenderTarget(L, B, 1), k = new Uint8Array(BYTES_PER_PIXEL * L * B), U = o.gl;
    U.readPixels(Math.round(e.x * R), Math.round(e.y * R), L, B, U.RGBA, U.UNSIGNED_BYTE, k);
    var z = $.context.getImageData(0, 0, L, B);
    if (n.arrayPostDivide(k, z.data), $.context.putImageData(z, 0, 0), N) {
      var X = new CanvasRenderTarget($.width, $.height, 1);
      X.context.scale(1, -1), X.context.drawImage($.canvas, 0, -B), $.destroy(), $ = X;
    }
    return D && M.destroy(!0), $.canvas;
  }, n.prototype.pixels = function(t, e) {
    var o = this.renderer, R, N, M = !1;
    t && (t instanceof RenderTexture ? N = t : (N = this.renderer.generateTexture(t), M = !0)), N ? (R = N.baseTexture.resolution, e = e != null ? e : N.frame, o.renderTexture.bind(N)) : (R = o.resolution, e || (e = TEMP_RECT, e.width = o.width, e.height = o.height), o.renderTexture.bind(null));
    var D = Math.round(e.width * R), L = Math.round(e.height * R), B = new Uint8Array(BYTES_PER_PIXEL * D * L), $ = o.gl;
    return $.readPixels(Math.round(e.x * R), Math.round(e.y * R), D, L, $.RGBA, $.UNSIGNED_BYTE, B), M && N.destroy(!0), n.arrayPostDivide(B, B), B;
  }, n.prototype.destroy = function() {
    this.renderer = null;
  }, n.arrayPostDivide = function(t, e) {
    for (var o = 0; o < t.length; o += 4) {
      var R = e[o + 3] = t[o + 3];
      R !== 0 ? (e[o] = Math.round(Math.min(t[o] * 255 / R, 255)), e[o + 1] = Math.round(Math.min(t[o + 1] * 255 / R, 255)), e[o + 2] = Math.round(Math.min(t[o + 2] * 255 / R, 255))) : (e[o] = t[o], e[o + 1] = t[o + 1], e[o + 2] = t[o + 2]);
    }
  }, n.extension = {
    name: "extract",
    type: ExtensionType.RendererPlugin
  }, n;
}();
/*!
 * @pixi/compressed-textures - v6.5.2
 * Compiled Wed, 24 Aug 2022 13:51:19 UTC
 *
 * @pixi/compressed-textures is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
var _a$2, INTERNAL_FORMATS;
(function(n) {
  n[n.COMPRESSED_RGB_S3TC_DXT1_EXT = 33776] = "COMPRESSED_RGB_S3TC_DXT1_EXT", n[n.COMPRESSED_RGBA_S3TC_DXT1_EXT = 33777] = "COMPRESSED_RGBA_S3TC_DXT1_EXT", n[n.COMPRESSED_RGBA_S3TC_DXT3_EXT = 33778] = "COMPRESSED_RGBA_S3TC_DXT3_EXT", n[n.COMPRESSED_RGBA_S3TC_DXT5_EXT = 33779] = "COMPRESSED_RGBA_S3TC_DXT5_EXT", n[n.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT = 35917] = "COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT", n[n.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT = 35918] = "COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT", n[n.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT = 35919] = "COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT", n[n.COMPRESSED_SRGB_S3TC_DXT1_EXT = 35916] = "COMPRESSED_SRGB_S3TC_DXT1_EXT", n[n.COMPRESSED_R11_EAC = 37488] = "COMPRESSED_R11_EAC", n[n.COMPRESSED_SIGNED_R11_EAC = 37489] = "COMPRESSED_SIGNED_R11_EAC", n[n.COMPRESSED_RG11_EAC = 37490] = "COMPRESSED_RG11_EAC", n[n.COMPRESSED_SIGNED_RG11_EAC = 37491] = "COMPRESSED_SIGNED_RG11_EAC", n[n.COMPRESSED_RGB8_ETC2 = 37492] = "COMPRESSED_RGB8_ETC2", n[n.COMPRESSED_RGBA8_ETC2_EAC = 37496] = "COMPRESSED_RGBA8_ETC2_EAC", n[n.COMPRESSED_SRGB8_ETC2 = 37493] = "COMPRESSED_SRGB8_ETC2", n[n.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC = 37497] = "COMPRESSED_SRGB8_ALPHA8_ETC2_EAC", n[n.COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2 = 37494] = "COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2", n[n.COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2 = 37495] = "COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2", n[n.COMPRESSED_RGB_PVRTC_4BPPV1_IMG = 35840] = "COMPRESSED_RGB_PVRTC_4BPPV1_IMG", n[n.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG = 35842] = "COMPRESSED_RGBA_PVRTC_4BPPV1_IMG", n[n.COMPRESSED_RGB_PVRTC_2BPPV1_IMG = 35841] = "COMPRESSED_RGB_PVRTC_2BPPV1_IMG", n[n.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG = 35843] = "COMPRESSED_RGBA_PVRTC_2BPPV1_IMG", n[n.COMPRESSED_RGB_ETC1_WEBGL = 36196] = "COMPRESSED_RGB_ETC1_WEBGL", n[n.COMPRESSED_RGB_ATC_WEBGL = 35986] = "COMPRESSED_RGB_ATC_WEBGL", n[n.COMPRESSED_RGBA_ATC_EXPLICIT_ALPHA_WEBGL = 35986] = "COMPRESSED_RGBA_ATC_EXPLICIT_ALPHA_WEBGL", n[n.COMPRESSED_RGBA_ATC_INTERPOLATED_ALPHA_WEBGL = 34798] = "COMPRESSED_RGBA_ATC_INTERPOLATED_ALPHA_WEBGL";
})(INTERNAL_FORMATS || (INTERNAL_FORMATS = {}));
var INTERNAL_FORMAT_TO_BYTES_PER_PIXEL = (_a$2 = {}, _a$2[INTERNAL_FORMATS.COMPRESSED_RGB_S3TC_DXT1_EXT] = 0.5, _a$2[INTERNAL_FORMATS.COMPRESSED_RGBA_S3TC_DXT1_EXT] = 0.5, _a$2[INTERNAL_FORMATS.COMPRESSED_RGBA_S3TC_DXT3_EXT] = 1, _a$2[INTERNAL_FORMATS.COMPRESSED_RGBA_S3TC_DXT5_EXT] = 1, _a$2[INTERNAL_FORMATS.COMPRESSED_SRGB_S3TC_DXT1_EXT] = 0.5, _a$2[INTERNAL_FORMATS.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT] = 0.5, _a$2[INTERNAL_FORMATS.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT] = 1, _a$2[INTERNAL_FORMATS.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT] = 1, _a$2[INTERNAL_FORMATS.COMPRESSED_R11_EAC] = 0.5, _a$2[INTERNAL_FORMATS.COMPRESSED_SIGNED_R11_EAC] = 0.5, _a$2[INTERNAL_FORMATS.COMPRESSED_RG11_EAC] = 1, _a$2[INTERNAL_FORMATS.COMPRESSED_SIGNED_RG11_EAC] = 1, _a$2[INTERNAL_FORMATS.COMPRESSED_RGB8_ETC2] = 0.5, _a$2[INTERNAL_FORMATS.COMPRESSED_RGBA8_ETC2_EAC] = 1, _a$2[INTERNAL_FORMATS.COMPRESSED_SRGB8_ETC2] = 0.5, _a$2[INTERNAL_FORMATS.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC] = 1, _a$2[INTERNAL_FORMATS.COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2] = 0.5, _a$2[INTERNAL_FORMATS.COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2] = 0.5, _a$2[INTERNAL_FORMATS.COMPRESSED_RGB_PVRTC_4BPPV1_IMG] = 0.5, _a$2[INTERNAL_FORMATS.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG] = 0.5, _a$2[INTERNAL_FORMATS.COMPRESSED_RGB_PVRTC_2BPPV1_IMG] = 0.25, _a$2[INTERNAL_FORMATS.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG] = 0.25, _a$2[INTERNAL_FORMATS.COMPRESSED_RGB_ETC1_WEBGL] = 0.5, _a$2[INTERNAL_FORMATS.COMPRESSED_RGB_ATC_WEBGL] = 0.5, _a$2[INTERNAL_FORMATS.COMPRESSED_RGBA_ATC_EXPLICIT_ALPHA_WEBGL] = 1, _a$2[INTERNAL_FORMATS.COMPRESSED_RGBA_ATC_INTERPOLATED_ALPHA_WEBGL] = 1, _a$2);
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var extendStatics$n = function(n, t) {
  return extendStatics$n = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(e, o) {
    e.__proto__ = o;
  } || function(e, o) {
    for (var R in o)
      o.hasOwnProperty(R) && (e[R] = o[R]);
  }, extendStatics$n(n, t);
};
function __extends$n(n, t) {
  extendStatics$n(n, t);
  function e() {
    this.constructor = n;
  }
  n.prototype = t === null ? Object.create(t) : (e.prototype = t.prototype, new e());
}
function __awaiter(n, t, e, o) {
  function R(N) {
    return N instanceof e ? N : new e(function(M) {
      M(N);
    });
  }
  return new (e || (e = Promise))(function(N, M) {
    function D($) {
      try {
        B(o.next($));
      } catch (k) {
        M(k);
      }
    }
    function L($) {
      try {
        B(o.throw($));
      } catch (k) {
        M(k);
      }
    }
    function B($) {
      $.done ? N($.value) : R($.value).then(D, L);
    }
    B((o = o.apply(n, t || [])).next());
  });
}
function __generator(n, t) {
  var e = { label: 0, sent: function() {
    if (N[0] & 1)
      throw N[1];
    return N[1];
  }, trys: [], ops: [] }, o, R, N, M;
  return M = { next: D(0), throw: D(1), return: D(2) }, typeof Symbol == "function" && (M[Symbol.iterator] = function() {
    return this;
  }), M;
  function D(B) {
    return function($) {
      return L([B, $]);
    };
  }
  function L(B) {
    if (o)
      throw new TypeError("Generator is already executing.");
    for (; e; )
      try {
        if (o = 1, R && (N = B[0] & 2 ? R.return : B[0] ? R.throw || ((N = R.return) && N.call(R), 0) : R.next) && !(N = N.call(R, B[1])).done)
          return N;
        switch (R = 0, N && (B = [B[0] & 2, N.value]), B[0]) {
          case 0:
          case 1:
            N = B;
            break;
          case 4:
            return e.label++, { value: B[1], done: !1 };
          case 5:
            e.label++, R = B[1], B = [0];
            continue;
          case 7:
            B = e.ops.pop(), e.trys.pop();
            continue;
          default:
            if (N = e.trys, !(N = N.length > 0 && N[N.length - 1]) && (B[0] === 6 || B[0] === 2)) {
              e = 0;
              continue;
            }
            if (B[0] === 3 && (!N || B[1] > N[0] && B[1] < N[3])) {
              e.label = B[1];
              break;
            }
            if (B[0] === 6 && e.label < N[1]) {
              e.label = N[1], N = B;
              break;
            }
            if (N && e.label < N[2]) {
              e.label = N[2], e.ops.push(B);
              break;
            }
            N[2] && e.ops.pop(), e.trys.pop();
            continue;
        }
        B = t.call(n, e);
      } catch ($) {
        B = [6, $], R = 0;
      } finally {
        o = N = 0;
      }
    if (B[0] & 5)
      throw B[1];
    return { value: B[0] ? B[1] : void 0, done: !0 };
  }
}
var BlobResource = function(n) {
  __extends$n(t, n);
  function t(e, o) {
    o === void 0 && (o = { width: 1, height: 1, autoLoad: !0 });
    var R = this, N, M;
    return typeof e == "string" ? (N = e, M = new Uint8Array()) : (N = null, M = e), R = n.call(this, M, o) || this, R.origin = N, R.buffer = M ? new ViewableBuffer(M) : null, R.origin && o.autoLoad !== !1 && R.load(), M && M.length && (R.loaded = !0, R.onBlobLoaded(R.buffer.rawBinaryData)), R;
  }
  return t.prototype.onBlobLoaded = function(e) {
  }, t.prototype.load = function() {
    return __awaiter(this, void 0, Promise, function() {
      var e, o, R;
      return __generator(this, function(N) {
        switch (N.label) {
          case 0:
            return [4, fetch(this.origin)];
          case 1:
            return e = N.sent(), [4, e.blob()];
          case 2:
            return o = N.sent(), [4, o.arrayBuffer()];
          case 3:
            return R = N.sent(), this.data = new Uint32Array(R), this.buffer = new ViewableBuffer(R), this.loaded = !0, this.onBlobLoaded(R), this.update(), [2, this];
        }
      });
    });
  }, t;
}(BufferResource), CompressedTextureResource = function(n) {
  __extends$n(t, n);
  function t(e, o) {
    var R = n.call(this, e, o) || this;
    return R.format = o.format, R.levels = o.levels || 1, R._width = o.width, R._height = o.height, R._extension = t._formatToExtension(R.format), (o.levelBuffers || R.buffer) && (R._levelBuffers = o.levelBuffers || t._createLevelBuffers(
      e instanceof Uint8Array ? e : R.buffer.uint8View,
      R.format,
      R.levels,
      4,
      4,
      R.width,
      R.height
    )), R;
  }
  return t.prototype.upload = function(e, o, R) {
    var N = e.gl, M = e.context.extensions[this._extension];
    if (!M)
      throw new Error(this._extension + " textures are not supported on the current machine");
    if (!this._levelBuffers)
      return !1;
    for (var D = 0, L = this.levels; D < L; D++) {
      var B = this._levelBuffers[D], $ = B.levelID, k = B.levelWidth, U = B.levelHeight, z = B.levelBuffer;
      N.compressedTexImage2D(N.TEXTURE_2D, $, this.format, k, U, 0, z);
    }
    return !0;
  }, t.prototype.onBlobLoaded = function() {
    this._levelBuffers = t._createLevelBuffers(
      this.buffer.uint8View,
      this.format,
      this.levels,
      4,
      4,
      this.width,
      this.height
    );
  }, t._formatToExtension = function(e) {
    if (e >= 33776 && e <= 33779)
      return "s3tc";
    if (e >= 37488 && e <= 37497)
      return "etc";
    if (e >= 35840 && e <= 35843)
      return "pvrtc";
    if (e >= 36196)
      return "etc1";
    if (e >= 35986 && e <= 34798)
      return "atc";
    throw new Error("Invalid (compressed) texture format given!");
  }, t._createLevelBuffers = function(e, o, R, N, M, D, L) {
    for (var B = new Array(R), $ = e.byteOffset, k = D, U = L, z = k + N - 1 & ~(N - 1), X = U + M - 1 & ~(M - 1), V = z * X * INTERNAL_FORMAT_TO_BYTES_PER_PIXEL[o], W = 0; W < R; W++)
      B[W] = {
        levelID: W,
        levelWidth: R > 1 ? k : z,
        levelHeight: R > 1 ? U : X,
        levelBuffer: new Uint8Array(e.buffer, $, V)
      }, $ += V, k = k >> 1 || 1, U = U >> 1 || 1, z = k + N - 1 & ~(N - 1), X = U + M - 1 & ~(M - 1), V = z * X * INTERNAL_FORMAT_TO_BYTES_PER_PIXEL[o];
    return B;
  }, t;
}(BlobResource), CompressedTextureLoader = function() {
  function n() {
  }
  return n.use = function(t, e) {
    var o = t.data, R = this;
    if (t.type === LoaderResource.TYPE.JSON && o && o.cacheID && o.textures) {
      for (var N = o.textures, M = void 0, D = void 0, L = 0, B = N.length; L < B; L++) {
        var $ = N[L], k = $.src, U = $.format;
        if (U || (D = k), n.textureFormats[U]) {
          M = k;
          break;
        }
      }
      if (M = M || D, !M) {
        e(new Error("Cannot load compressed-textures in " + t.url + ", make sure you provide a fallback"));
        return;
      }
      if (M === t.url) {
        e(new Error("URL of compressed texture cannot be the same as the manifest's URL"));
        return;
      }
      var z = {
        crossOrigin: t.crossOrigin,
        metadata: t.metadata.imageMetadata,
        parentResource: t
      }, X = url.resolve(t.url.replace(R.baseUrl, ""), M), V = o.cacheID;
      R.add(V, X, z, function(W) {
        if (W.error) {
          e(W.error);
          return;
        }
        var Y = W.texture, q = Y === void 0 ? null : Y, Z = W.textures, J = Z === void 0 ? {} : Z;
        Object.assign(t, { texture: q, textures: J }), e();
      });
    } else
      e();
  }, Object.defineProperty(n, "textureExtensions", {
    get: function() {
      if (!n._textureExtensions) {
        var t = settings$1.ADAPTER.createCanvas(), e = t.getContext("webgl");
        if (!e)
          return console.warn("WebGL not available for compressed textures. Silently failing."), {};
        var o = {
          s3tc: e.getExtension("WEBGL_compressed_texture_s3tc"),
          s3tc_sRGB: e.getExtension("WEBGL_compressed_texture_s3tc_srgb"),
          etc: e.getExtension("WEBGL_compressed_texture_etc"),
          etc1: e.getExtension("WEBGL_compressed_texture_etc1"),
          pvrtc: e.getExtension("WEBGL_compressed_texture_pvrtc") || e.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc"),
          atc: e.getExtension("WEBGL_compressed_texture_atc"),
          astc: e.getExtension("WEBGL_compressed_texture_astc")
        };
        n._textureExtensions = o;
      }
      return n._textureExtensions;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(n, "textureFormats", {
    get: function() {
      if (!n._textureFormats) {
        var t = n.textureExtensions;
        n._textureFormats = {};
        for (var e in t) {
          var o = t[e];
          !o || Object.assign(n._textureFormats, Object.getPrototypeOf(o));
        }
      }
      return n._textureFormats;
    },
    enumerable: !1,
    configurable: !0
  }), n.extension = ExtensionType.Loader, n;
}();
function registerCompressedTextures(n, t, e) {
  var o = {
    textures: {},
    texture: null
  };
  if (!t)
    return o;
  var R = t.map(function(N) {
    return new Texture(new BaseTexture(N, Object.assign({
      mipmap: MIPMAP_MODES$5.OFF,
      alphaMode: ALPHA_MODES$5.NO_PREMULTIPLIED_ALPHA
    }, e)));
  });
  return R.forEach(function(N, M) {
    var D = N.baseTexture, L = n + "-" + (M + 1);
    BaseTexture.addToCache(D, L), Texture.addToCache(N, L), M === 0 && (BaseTexture.addToCache(D, n), Texture.addToCache(N, n), o.texture = N), o.textures[L] = N;
  }), o;
}
var _a$1, _b$1, DDS_MAGIC_SIZE = 4, DDS_HEADER_SIZE = 124, DDS_HEADER_PF_SIZE = 32, DDS_HEADER_DX10_SIZE = 20, DDS_MAGIC = 542327876, DDS_FIELDS = {
  SIZE: 1,
  FLAGS: 2,
  HEIGHT: 3,
  WIDTH: 4,
  MIPMAP_COUNT: 7,
  PIXEL_FORMAT: 19
}, DDS_PF_FIELDS = {
  SIZE: 0,
  FLAGS: 1,
  FOURCC: 2,
  RGB_BITCOUNT: 3,
  R_BIT_MASK: 4,
  G_BIT_MASK: 5,
  B_BIT_MASK: 6,
  A_BIT_MASK: 7
}, DDS_DX10_FIELDS = {
  DXGI_FORMAT: 0,
  RESOURCE_DIMENSION: 1,
  MISC_FLAG: 2,
  ARRAY_SIZE: 3,
  MISC_FLAGS2: 4
}, DXGI_FORMAT;
(function(n) {
  n[n.DXGI_FORMAT_UNKNOWN = 0] = "DXGI_FORMAT_UNKNOWN", n[n.DXGI_FORMAT_R32G32B32A32_TYPELESS = 1] = "DXGI_FORMAT_R32G32B32A32_TYPELESS", n[n.DXGI_FORMAT_R32G32B32A32_FLOAT = 2] = "DXGI_FORMAT_R32G32B32A32_FLOAT", n[n.DXGI_FORMAT_R32G32B32A32_UINT = 3] = "DXGI_FORMAT_R32G32B32A32_UINT", n[n.DXGI_FORMAT_R32G32B32A32_SINT = 4] = "DXGI_FORMAT_R32G32B32A32_SINT", n[n.DXGI_FORMAT_R32G32B32_TYPELESS = 5] = "DXGI_FORMAT_R32G32B32_TYPELESS", n[n.DXGI_FORMAT_R32G32B32_FLOAT = 6] = "DXGI_FORMAT_R32G32B32_FLOAT", n[n.DXGI_FORMAT_R32G32B32_UINT = 7] = "DXGI_FORMAT_R32G32B32_UINT", n[n.DXGI_FORMAT_R32G32B32_SINT = 8] = "DXGI_FORMAT_R32G32B32_SINT", n[n.DXGI_FORMAT_R16G16B16A16_TYPELESS = 9] = "DXGI_FORMAT_R16G16B16A16_TYPELESS", n[n.DXGI_FORMAT_R16G16B16A16_FLOAT = 10] = "DXGI_FORMAT_R16G16B16A16_FLOAT", n[n.DXGI_FORMAT_R16G16B16A16_UNORM = 11] = "DXGI_FORMAT_R16G16B16A16_UNORM", n[n.DXGI_FORMAT_R16G16B16A16_UINT = 12] = "DXGI_FORMAT_R16G16B16A16_UINT", n[n.DXGI_FORMAT_R16G16B16A16_SNORM = 13] = "DXGI_FORMAT_R16G16B16A16_SNORM", n[n.DXGI_FORMAT_R16G16B16A16_SINT = 14] = "DXGI_FORMAT_R16G16B16A16_SINT", n[n.DXGI_FORMAT_R32G32_TYPELESS = 15] = "DXGI_FORMAT_R32G32_TYPELESS", n[n.DXGI_FORMAT_R32G32_FLOAT = 16] = "DXGI_FORMAT_R32G32_FLOAT", n[n.DXGI_FORMAT_R32G32_UINT = 17] = "DXGI_FORMAT_R32G32_UINT", n[n.DXGI_FORMAT_R32G32_SINT = 18] = "DXGI_FORMAT_R32G32_SINT", n[n.DXGI_FORMAT_R32G8X24_TYPELESS = 19] = "DXGI_FORMAT_R32G8X24_TYPELESS", n[n.DXGI_FORMAT_D32_FLOAT_S8X24_UINT = 20] = "DXGI_FORMAT_D32_FLOAT_S8X24_UINT", n[n.DXGI_FORMAT_R32_FLOAT_X8X24_TYPELESS = 21] = "DXGI_FORMAT_R32_FLOAT_X8X24_TYPELESS", n[n.DXGI_FORMAT_X32_TYPELESS_G8X24_UINT = 22] = "DXGI_FORMAT_X32_TYPELESS_G8X24_UINT", n[n.DXGI_FORMAT_R10G10B10A2_TYPELESS = 23] = "DXGI_FORMAT_R10G10B10A2_TYPELESS", n[n.DXGI_FORMAT_R10G10B10A2_UNORM = 24] = "DXGI_FORMAT_R10G10B10A2_UNORM", n[n.DXGI_FORMAT_R10G10B10A2_UINT = 25] = "DXGI_FORMAT_R10G10B10A2_UINT", n[n.DXGI_FORMAT_R11G11B10_FLOAT = 26] = "DXGI_FORMAT_R11G11B10_FLOAT", n[n.DXGI_FORMAT_R8G8B8A8_TYPELESS = 27] = "DXGI_FORMAT_R8G8B8A8_TYPELESS", n[n.DXGI_FORMAT_R8G8B8A8_UNORM = 28] = "DXGI_FORMAT_R8G8B8A8_UNORM", n[n.DXGI_FORMAT_R8G8B8A8_UNORM_SRGB = 29] = "DXGI_FORMAT_R8G8B8A8_UNORM_SRGB", n[n.DXGI_FORMAT_R8G8B8A8_UINT = 30] = "DXGI_FORMAT_R8G8B8A8_UINT", n[n.DXGI_FORMAT_R8G8B8A8_SNORM = 31] = "DXGI_FORMAT_R8G8B8A8_SNORM", n[n.DXGI_FORMAT_R8G8B8A8_SINT = 32] = "DXGI_FORMAT_R8G8B8A8_SINT", n[n.DXGI_FORMAT_R16G16_TYPELESS = 33] = "DXGI_FORMAT_R16G16_TYPELESS", n[n.DXGI_FORMAT_R16G16_FLOAT = 34] = "DXGI_FORMAT_R16G16_FLOAT", n[n.DXGI_FORMAT_R16G16_UNORM = 35] = "DXGI_FORMAT_R16G16_UNORM", n[n.DXGI_FORMAT_R16G16_UINT = 36] = "DXGI_FORMAT_R16G16_UINT", n[n.DXGI_FORMAT_R16G16_SNORM = 37] = "DXGI_FORMAT_R16G16_SNORM", n[n.DXGI_FORMAT_R16G16_SINT = 38] = "DXGI_FORMAT_R16G16_SINT", n[n.DXGI_FORMAT_R32_TYPELESS = 39] = "DXGI_FORMAT_R32_TYPELESS", n[n.DXGI_FORMAT_D32_FLOAT = 40] = "DXGI_FORMAT_D32_FLOAT", n[n.DXGI_FORMAT_R32_FLOAT = 41] = "DXGI_FORMAT_R32_FLOAT", n[n.DXGI_FORMAT_R32_UINT = 42] = "DXGI_FORMAT_R32_UINT", n[n.DXGI_FORMAT_R32_SINT = 43] = "DXGI_FORMAT_R32_SINT", n[n.DXGI_FORMAT_R24G8_TYPELESS = 44] = "DXGI_FORMAT_R24G8_TYPELESS", n[n.DXGI_FORMAT_D24_UNORM_S8_UINT = 45] = "DXGI_FORMAT_D24_UNORM_S8_UINT", n[n.DXGI_FORMAT_R24_UNORM_X8_TYPELESS = 46] = "DXGI_FORMAT_R24_UNORM_X8_TYPELESS", n[n.DXGI_FORMAT_X24_TYPELESS_G8_UINT = 47] = "DXGI_FORMAT_X24_TYPELESS_G8_UINT", n[n.DXGI_FORMAT_R8G8_TYPELESS = 48] = "DXGI_FORMAT_R8G8_TYPELESS", n[n.DXGI_FORMAT_R8G8_UNORM = 49] = "DXGI_FORMAT_R8G8_UNORM", n[n.DXGI_FORMAT_R8G8_UINT = 50] = "DXGI_FORMAT_R8G8_UINT", n[n.DXGI_FORMAT_R8G8_SNORM = 51] = "DXGI_FORMAT_R8G8_SNORM", n[n.DXGI_FORMAT_R8G8_SINT = 52] = "DXGI_FORMAT_R8G8_SINT", n[n.DXGI_FORMAT_R16_TYPELESS = 53] = "DXGI_FORMAT_R16_TYPELESS", n[n.DXGI_FORMAT_R16_FLOAT = 54] = "DXGI_FORMAT_R16_FLOAT", n[n.DXGI_FORMAT_D16_UNORM = 55] = "DXGI_FORMAT_D16_UNORM", n[n.DXGI_FORMAT_R16_UNORM = 56] = "DXGI_FORMAT_R16_UNORM", n[n.DXGI_FORMAT_R16_UINT = 57] = "DXGI_FORMAT_R16_UINT", n[n.DXGI_FORMAT_R16_SNORM = 58] = "DXGI_FORMAT_R16_SNORM", n[n.DXGI_FORMAT_R16_SINT = 59] = "DXGI_FORMAT_R16_SINT", n[n.DXGI_FORMAT_R8_TYPELESS = 60] = "DXGI_FORMAT_R8_TYPELESS", n[n.DXGI_FORMAT_R8_UNORM = 61] = "DXGI_FORMAT_R8_UNORM", n[n.DXGI_FORMAT_R8_UINT = 62] = "DXGI_FORMAT_R8_UINT", n[n.DXGI_FORMAT_R8_SNORM = 63] = "DXGI_FORMAT_R8_SNORM", n[n.DXGI_FORMAT_R8_SINT = 64] = "DXGI_FORMAT_R8_SINT", n[n.DXGI_FORMAT_A8_UNORM = 65] = "DXGI_FORMAT_A8_UNORM", n[n.DXGI_FORMAT_R1_UNORM = 66] = "DXGI_FORMAT_R1_UNORM", n[n.DXGI_FORMAT_R9G9B9E5_SHAREDEXP = 67] = "DXGI_FORMAT_R9G9B9E5_SHAREDEXP", n[n.DXGI_FORMAT_R8G8_B8G8_UNORM = 68] = "DXGI_FORMAT_R8G8_B8G8_UNORM", n[n.DXGI_FORMAT_G8R8_G8B8_UNORM = 69] = "DXGI_FORMAT_G8R8_G8B8_UNORM", n[n.DXGI_FORMAT_BC1_TYPELESS = 70] = "DXGI_FORMAT_BC1_TYPELESS", n[n.DXGI_FORMAT_BC1_UNORM = 71] = "DXGI_FORMAT_BC1_UNORM", n[n.DXGI_FORMAT_BC1_UNORM_SRGB = 72] = "DXGI_FORMAT_BC1_UNORM_SRGB", n[n.DXGI_FORMAT_BC2_TYPELESS = 73] = "DXGI_FORMAT_BC2_TYPELESS", n[n.DXGI_FORMAT_BC2_UNORM = 74] = "DXGI_FORMAT_BC2_UNORM", n[n.DXGI_FORMAT_BC2_UNORM_SRGB = 75] = "DXGI_FORMAT_BC2_UNORM_SRGB", n[n.DXGI_FORMAT_BC3_TYPELESS = 76] = "DXGI_FORMAT_BC3_TYPELESS", n[n.DXGI_FORMAT_BC3_UNORM = 77] = "DXGI_FORMAT_BC3_UNORM", n[n.DXGI_FORMAT_BC3_UNORM_SRGB = 78] = "DXGI_FORMAT_BC3_UNORM_SRGB", n[n.DXGI_FORMAT_BC4_TYPELESS = 79] = "DXGI_FORMAT_BC4_TYPELESS", n[n.DXGI_FORMAT_BC4_UNORM = 80] = "DXGI_FORMAT_BC4_UNORM", n[n.DXGI_FORMAT_BC4_SNORM = 81] = "DXGI_FORMAT_BC4_SNORM", n[n.DXGI_FORMAT_BC5_TYPELESS = 82] = "DXGI_FORMAT_BC5_TYPELESS", n[n.DXGI_FORMAT_BC5_UNORM = 83] = "DXGI_FORMAT_BC5_UNORM", n[n.DXGI_FORMAT_BC5_SNORM = 84] = "DXGI_FORMAT_BC5_SNORM", n[n.DXGI_FORMAT_B5G6R5_UNORM = 85] = "DXGI_FORMAT_B5G6R5_UNORM", n[n.DXGI_FORMAT_B5G5R5A1_UNORM = 86] = "DXGI_FORMAT_B5G5R5A1_UNORM", n[n.DXGI_FORMAT_B8G8R8A8_UNORM = 87] = "DXGI_FORMAT_B8G8R8A8_UNORM", n[n.DXGI_FORMAT_B8G8R8X8_UNORM = 88] = "DXGI_FORMAT_B8G8R8X8_UNORM", n[n.DXGI_FORMAT_R10G10B10_XR_BIAS_A2_UNORM = 89] = "DXGI_FORMAT_R10G10B10_XR_BIAS_A2_UNORM", n[n.DXGI_FORMAT_B8G8R8A8_TYPELESS = 90] = "DXGI_FORMAT_B8G8R8A8_TYPELESS", n[n.DXGI_FORMAT_B8G8R8A8_UNORM_SRGB = 91] = "DXGI_FORMAT_B8G8R8A8_UNORM_SRGB", n[n.DXGI_FORMAT_B8G8R8X8_TYPELESS = 92] = "DXGI_FORMAT_B8G8R8X8_TYPELESS", n[n.DXGI_FORMAT_B8G8R8X8_UNORM_SRGB = 93] = "DXGI_FORMAT_B8G8R8X8_UNORM_SRGB", n[n.DXGI_FORMAT_BC6H_TYPELESS = 94] = "DXGI_FORMAT_BC6H_TYPELESS", n[n.DXGI_FORMAT_BC6H_UF16 = 95] = "DXGI_FORMAT_BC6H_UF16", n[n.DXGI_FORMAT_BC6H_SF16 = 96] = "DXGI_FORMAT_BC6H_SF16", n[n.DXGI_FORMAT_BC7_TYPELESS = 97] = "DXGI_FORMAT_BC7_TYPELESS", n[n.DXGI_FORMAT_BC7_UNORM = 98] = "DXGI_FORMAT_BC7_UNORM", n[n.DXGI_FORMAT_BC7_UNORM_SRGB = 99] = "DXGI_FORMAT_BC7_UNORM_SRGB", n[n.DXGI_FORMAT_AYUV = 100] = "DXGI_FORMAT_AYUV", n[n.DXGI_FORMAT_Y410 = 101] = "DXGI_FORMAT_Y410", n[n.DXGI_FORMAT_Y416 = 102] = "DXGI_FORMAT_Y416", n[n.DXGI_FORMAT_NV12 = 103] = "DXGI_FORMAT_NV12", n[n.DXGI_FORMAT_P010 = 104] = "DXGI_FORMAT_P010", n[n.DXGI_FORMAT_P016 = 105] = "DXGI_FORMAT_P016", n[n.DXGI_FORMAT_420_OPAQUE = 106] = "DXGI_FORMAT_420_OPAQUE", n[n.DXGI_FORMAT_YUY2 = 107] = "DXGI_FORMAT_YUY2", n[n.DXGI_FORMAT_Y210 = 108] = "DXGI_FORMAT_Y210", n[n.DXGI_FORMAT_Y216 = 109] = "DXGI_FORMAT_Y216", n[n.DXGI_FORMAT_NV11 = 110] = "DXGI_FORMAT_NV11", n[n.DXGI_FORMAT_AI44 = 111] = "DXGI_FORMAT_AI44", n[n.DXGI_FORMAT_IA44 = 112] = "DXGI_FORMAT_IA44", n[n.DXGI_FORMAT_P8 = 113] = "DXGI_FORMAT_P8", n[n.DXGI_FORMAT_A8P8 = 114] = "DXGI_FORMAT_A8P8", n[n.DXGI_FORMAT_B4G4R4A4_UNORM = 115] = "DXGI_FORMAT_B4G4R4A4_UNORM", n[n.DXGI_FORMAT_P208 = 116] = "DXGI_FORMAT_P208", n[n.DXGI_FORMAT_V208 = 117] = "DXGI_FORMAT_V208", n[n.DXGI_FORMAT_V408 = 118] = "DXGI_FORMAT_V408", n[n.DXGI_FORMAT_SAMPLER_FEEDBACK_MIN_MIP_OPAQUE = 119] = "DXGI_FORMAT_SAMPLER_FEEDBACK_MIN_MIP_OPAQUE", n[n.DXGI_FORMAT_SAMPLER_FEEDBACK_MIP_REGION_USED_OPAQUE = 120] = "DXGI_FORMAT_SAMPLER_FEEDBACK_MIP_REGION_USED_OPAQUE", n[n.DXGI_FORMAT_FORCE_UINT = 121] = "DXGI_FORMAT_FORCE_UINT";
})(DXGI_FORMAT || (DXGI_FORMAT = {}));
var D3D10_RESOURCE_DIMENSION;
(function(n) {
  n[n.DDS_DIMENSION_TEXTURE1D = 2] = "DDS_DIMENSION_TEXTURE1D", n[n.DDS_DIMENSION_TEXTURE2D = 3] = "DDS_DIMENSION_TEXTURE2D", n[n.DDS_DIMENSION_TEXTURE3D = 6] = "DDS_DIMENSION_TEXTURE3D";
})(D3D10_RESOURCE_DIMENSION || (D3D10_RESOURCE_DIMENSION = {}));
var PF_FLAGS = 1, DDPF_ALPHA = 2, DDPF_FOURCC = 4, DDPF_RGB = 64, DDPF_YUV = 512, DDPF_LUMINANCE = 131072, FOURCC_DXT1 = 827611204, FOURCC_DXT3 = 861165636, FOURCC_DXT5 = 894720068, FOURCC_DX10 = 808540228, DDS_RESOURCE_MISC_TEXTURECUBE = 4, FOURCC_TO_FORMAT = (_a$1 = {}, _a$1[FOURCC_DXT1] = INTERNAL_FORMATS.COMPRESSED_RGBA_S3TC_DXT1_EXT, _a$1[FOURCC_DXT3] = INTERNAL_FORMATS.COMPRESSED_RGBA_S3TC_DXT3_EXT, _a$1[FOURCC_DXT5] = INTERNAL_FORMATS.COMPRESSED_RGBA_S3TC_DXT5_EXT, _a$1), DXGI_TO_FORMAT = (_b$1 = {}, _b$1[DXGI_FORMAT.DXGI_FORMAT_BC1_TYPELESS] = INTERNAL_FORMATS.COMPRESSED_RGBA_S3TC_DXT1_EXT, _b$1[DXGI_FORMAT.DXGI_FORMAT_BC1_UNORM] = INTERNAL_FORMATS.COMPRESSED_RGBA_S3TC_DXT1_EXT, _b$1[DXGI_FORMAT.DXGI_FORMAT_BC2_TYPELESS] = INTERNAL_FORMATS.COMPRESSED_RGBA_S3TC_DXT3_EXT, _b$1[DXGI_FORMAT.DXGI_FORMAT_BC2_UNORM] = INTERNAL_FORMATS.COMPRESSED_RGBA_S3TC_DXT3_EXT, _b$1[DXGI_FORMAT.DXGI_FORMAT_BC3_TYPELESS] = INTERNAL_FORMATS.COMPRESSED_RGBA_S3TC_DXT5_EXT, _b$1[DXGI_FORMAT.DXGI_FORMAT_BC3_UNORM] = INTERNAL_FORMATS.COMPRESSED_RGBA_S3TC_DXT5_EXT, _b$1[DXGI_FORMAT.DXGI_FORMAT_BC1_UNORM_SRGB] = INTERNAL_FORMATS.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT, _b$1[DXGI_FORMAT.DXGI_FORMAT_BC2_UNORM_SRGB] = INTERNAL_FORMATS.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT, _b$1[DXGI_FORMAT.DXGI_FORMAT_BC3_UNORM_SRGB] = INTERNAL_FORMATS.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT, _b$1);
function parseDDS(n) {
  var t = new Uint32Array(n), e = t[0];
  if (e !== DDS_MAGIC)
    throw new Error("Invalid DDS file magic word");
  var o = new Uint32Array(n, 0, DDS_HEADER_SIZE / Uint32Array.BYTES_PER_ELEMENT), R = o[DDS_FIELDS.HEIGHT], N = o[DDS_FIELDS.WIDTH], M = o[DDS_FIELDS.MIPMAP_COUNT], D = new Uint32Array(n, DDS_FIELDS.PIXEL_FORMAT * Uint32Array.BYTES_PER_ELEMENT, DDS_HEADER_PF_SIZE / Uint32Array.BYTES_PER_ELEMENT), L = D[PF_FLAGS];
  if (L & DDPF_FOURCC) {
    var B = D[DDS_PF_FIELDS.FOURCC];
    if (B !== FOURCC_DX10) {
      var $ = FOURCC_TO_FORMAT[B], k = DDS_MAGIC_SIZE + DDS_HEADER_SIZE, U = new Uint8Array(n, k), z = new CompressedTextureResource(U, {
        format: $,
        width: N,
        height: R,
        levels: M
      });
      return [z];
    }
    var X = DDS_MAGIC_SIZE + DDS_HEADER_SIZE, V = new Uint32Array(t.buffer, X, DDS_HEADER_DX10_SIZE / Uint32Array.BYTES_PER_ELEMENT), W = V[DDS_DX10_FIELDS.DXGI_FORMAT], Y = V[DDS_DX10_FIELDS.RESOURCE_DIMENSION], q = V[DDS_DX10_FIELDS.MISC_FLAG], Z = V[DDS_DX10_FIELDS.ARRAY_SIZE], J = DXGI_TO_FORMAT[W];
    if (J === void 0)
      throw new Error("DDSParser cannot parse texture data with DXGI format " + W);
    if (q === DDS_RESOURCE_MISC_TEXTURECUBE)
      throw new Error("DDSParser does not support cubemap textures");
    if (Y === D3D10_RESOURCE_DIMENSION.DDS_DIMENSION_TEXTURE3D)
      throw new Error("DDSParser does not supported 3D texture data");
    var Q = new Array(), K = DDS_MAGIC_SIZE + DDS_HEADER_SIZE + DDS_HEADER_DX10_SIZE;
    if (Z === 1)
      Q.push(new Uint8Array(n, K));
    else {
      for (var rt = INTERNAL_FORMAT_TO_BYTES_PER_PIXEL[J], tt = 0, nt = N, at = R, lt = 0; lt < M; lt++) {
        var ut = Math.max(1, nt + 3 & -4), dt = Math.max(1, at + 3 & -4), yt = ut * dt * rt;
        tt += yt, nt = nt >>> 1, at = at >>> 1;
      }
      for (var pt = K, lt = 0; lt < Z; lt++)
        Q.push(new Uint8Array(n, pt, tt)), pt += tt;
    }
    return Q.map(function(gt) {
      return new CompressedTextureResource(gt, {
        format: J,
        width: N,
        height: R,
        levels: M
      });
    });
  }
  throw L & DDPF_RGB ? new Error("DDSParser does not support uncompressed texture data.") : L & DDPF_YUV ? new Error("DDSParser does not supported YUV uncompressed texture data.") : L & DDPF_LUMINANCE ? new Error("DDSParser does not support single-channel (lumninance) texture data!") : L & DDPF_ALPHA ? new Error("DDSParser does not support single-channel (alpha) texture data!") : new Error("DDSParser failed to load a texture file due to an unknown reason!");
}
var _a$3, _b, _c, FILE_IDENTIFIER = [171, 75, 84, 88, 32, 49, 49, 187, 13, 10, 26, 10], ENDIANNESS = 67305985, KTX_FIELDS = {
  FILE_IDENTIFIER: 0,
  ENDIANNESS: 12,
  GL_TYPE: 16,
  GL_TYPE_SIZE: 20,
  GL_FORMAT: 24,
  GL_INTERNAL_FORMAT: 28,
  GL_BASE_INTERNAL_FORMAT: 32,
  PIXEL_WIDTH: 36,
  PIXEL_HEIGHT: 40,
  PIXEL_DEPTH: 44,
  NUMBER_OF_ARRAY_ELEMENTS: 48,
  NUMBER_OF_FACES: 52,
  NUMBER_OF_MIPMAP_LEVELS: 56,
  BYTES_OF_KEY_VALUE_DATA: 60
}, FILE_HEADER_SIZE = 64, TYPES_TO_BYTES_PER_COMPONENT = (_a$3 = {}, _a$3[TYPES$5.UNSIGNED_BYTE] = 1, _a$3[TYPES$5.UNSIGNED_SHORT] = 2, _a$3[TYPES$5.INT] = 4, _a$3[TYPES$5.UNSIGNED_INT] = 4, _a$3[TYPES$5.FLOAT] = 4, _a$3[TYPES$5.HALF_FLOAT] = 8, _a$3), FORMATS_TO_COMPONENTS = (_b = {}, _b[FORMATS$5.RGBA] = 4, _b[FORMATS$5.RGB] = 3, _b[FORMATS$5.RG] = 2, _b[FORMATS$5.RED] = 1, _b[FORMATS$5.LUMINANCE] = 1, _b[FORMATS$5.LUMINANCE_ALPHA] = 2, _b[FORMATS$5.ALPHA] = 1, _b), TYPES_TO_BYTES_PER_PIXEL = (_c = {}, _c[TYPES$5.UNSIGNED_SHORT_4_4_4_4] = 2, _c[TYPES$5.UNSIGNED_SHORT_5_5_5_1] = 2, _c[TYPES$5.UNSIGNED_SHORT_5_6_5] = 2, _c);
function parseKTX(n, t, e) {
  e === void 0 && (e = !1);
  var o = new DataView(t);
  if (!validate(n, o))
    return null;
  var R = o.getUint32(KTX_FIELDS.ENDIANNESS, !0) === ENDIANNESS, N = o.getUint32(KTX_FIELDS.GL_TYPE, R), M = o.getUint32(KTX_FIELDS.GL_FORMAT, R), D = o.getUint32(KTX_FIELDS.GL_INTERNAL_FORMAT, R), L = o.getUint32(KTX_FIELDS.PIXEL_WIDTH, R), B = o.getUint32(KTX_FIELDS.PIXEL_HEIGHT, R) || 1, $ = o.getUint32(KTX_FIELDS.PIXEL_DEPTH, R) || 1, k = o.getUint32(KTX_FIELDS.NUMBER_OF_ARRAY_ELEMENTS, R) || 1, U = o.getUint32(KTX_FIELDS.NUMBER_OF_FACES, R), z = o.getUint32(KTX_FIELDS.NUMBER_OF_MIPMAP_LEVELS, R), X = o.getUint32(KTX_FIELDS.BYTES_OF_KEY_VALUE_DATA, R);
  if (B === 0 || $ !== 1)
    throw new Error("Only 2D textures are supported");
  if (U !== 1)
    throw new Error("CubeTextures are not supported by KTXLoader yet!");
  if (k !== 1)
    throw new Error("WebGL does not support array textures");
  var V = 4, W = 4, Y = L + 3 & -4, q = B + 3 & -4, Z = new Array(k), J = L * B;
  N === 0 && (J = Y * q);
  var Q;
  if (N !== 0 ? TYPES_TO_BYTES_PER_COMPONENT[N] ? Q = TYPES_TO_BYTES_PER_COMPONENT[N] * FORMATS_TO_COMPONENTS[M] : Q = TYPES_TO_BYTES_PER_PIXEL[N] : Q = INTERNAL_FORMAT_TO_BYTES_PER_PIXEL[D], Q === void 0)
    throw new Error("Unable to resolve the pixel format stored in the *.ktx file!");
  for (var K = e ? parseKvData(o, X, R) : null, rt = J * Q, tt = rt, nt = L, at = B, lt = Y, ut = q, dt = FILE_HEADER_SIZE + X, yt = 0; yt < z; yt++) {
    for (var pt = o.getUint32(dt, R), gt = dt + 4, xt = 0; xt < k; xt++) {
      var Lt = Z[xt];
      Lt || (Lt = Z[xt] = new Array(z)), Lt[yt] = {
        levelID: yt,
        levelWidth: z > 1 || N !== 0 ? nt : lt,
        levelHeight: z > 1 || N !== 0 ? at : ut,
        levelBuffer: new Uint8Array(t, gt, tt)
      }, gt += tt;
    }
    dt += pt + 4, dt = dt % 4 !== 0 ? dt + 4 - dt % 4 : dt, nt = nt >> 1 || 1, at = at >> 1 || 1, lt = nt + V - 1 & ~(V - 1), ut = at + W - 1 & ~(W - 1), tt = lt * ut * Q;
  }
  return N !== 0 ? {
    uncompressed: Z.map(function(mt) {
      var ct = mt[0].levelBuffer, vt = !1;
      return N === TYPES$5.FLOAT ? ct = new Float32Array(mt[0].levelBuffer.buffer, mt[0].levelBuffer.byteOffset, mt[0].levelBuffer.byteLength / 4) : N === TYPES$5.UNSIGNED_INT ? (vt = !0, ct = new Uint32Array(mt[0].levelBuffer.buffer, mt[0].levelBuffer.byteOffset, mt[0].levelBuffer.byteLength / 4)) : N === TYPES$5.INT && (vt = !0, ct = new Int32Array(mt[0].levelBuffer.buffer, mt[0].levelBuffer.byteOffset, mt[0].levelBuffer.byteLength / 4)), {
        resource: new BufferResource(ct, {
          width: mt[0].levelWidth,
          height: mt[0].levelHeight
        }),
        type: N,
        format: vt ? convertFormatToInteger(M) : M
      };
    }),
    kvData: K
  } : {
    compressed: Z.map(function(mt) {
      return new CompressedTextureResource(null, {
        format: D,
        width: L,
        height: B,
        levels: z,
        levelBuffers: mt
      });
    }),
    kvData: K
  };
}
function validate(n, t) {
  for (var e = 0; e < FILE_IDENTIFIER.length; e++)
    if (t.getUint8(e) !== FILE_IDENTIFIER[e])
      return console.error(n + " is not a valid *.ktx file!"), !1;
  return !0;
}
function convertFormatToInteger(n) {
  switch (n) {
    case FORMATS$5.RGBA:
      return FORMATS$5.RGBA_INTEGER;
    case FORMATS$5.RGB:
      return FORMATS$5.RGB_INTEGER;
    case FORMATS$5.RG:
      return FORMATS$5.RG_INTEGER;
    case FORMATS$5.RED:
      return FORMATS$5.RED_INTEGER;
    default:
      return n;
  }
}
function parseKvData(n, t, e) {
  for (var o = /* @__PURE__ */ new Map(), R = 0; R < t; ) {
    var N = n.getUint32(FILE_HEADER_SIZE + R, e), M = FILE_HEADER_SIZE + R + 4, D = 3 - (N + 3) % 4;
    if (N === 0 || N > t - R) {
      console.error("KTXLoader: keyAndValueByteSize out of bounds");
      break;
    }
    for (var L = 0; L < N && n.getUint8(M + L) !== 0; L++)
      ;
    if (L === -1) {
      console.error("KTXLoader: Failed to find null byte terminating kvData key");
      break;
    }
    var B = new TextDecoder().decode(new Uint8Array(n.buffer, M, L)), $ = new DataView(n.buffer, M + L + 1, N - L - 1);
    o.set(B, $), R += 4 + N + D;
  }
  return o;
}
LoaderResource.setExtensionXhrType("dds", LoaderResource.XHR_RESPONSE_TYPE.BUFFER);
var DDSLoader = function() {
  function n() {
  }
  return n.use = function(t, e) {
    if (t.extension === "dds" && t.data)
      try {
        Object.assign(t, registerCompressedTextures(t.name || t.url, parseDDS(t.data), t.metadata));
      } catch (o) {
        e(o);
        return;
      }
    e();
  }, n.extension = ExtensionType.Loader, n;
}();
LoaderResource.setExtensionXhrType("ktx", LoaderResource.XHR_RESPONSE_TYPE.BUFFER);
var KTXLoader = function() {
  function n() {
  }
  return n.use = function(t, e) {
    if (t.extension === "ktx" && t.data)
      try {
        var o = t.name || t.url, R = parseKTX(o, t.data, this.loadKeyValueData), N = R.compressed, M = R.uncompressed, D = R.kvData;
        if (N) {
          var L = registerCompressedTextures(o, N, t.metadata);
          if (D && L.textures)
            for (var B in L.textures)
              L.textures[B].baseTexture.ktxKeyValueData = D;
          Object.assign(t, L);
        } else if (M) {
          var $ = {};
          M.forEach(function(k, U) {
            var z = new Texture(new BaseTexture(k.resource, {
              mipmap: MIPMAP_MODES$5.OFF,
              alphaMode: ALPHA_MODES$5.NO_PREMULTIPLIED_ALPHA,
              type: k.type,
              format: k.format
            })), X = o + "-" + (U + 1);
            D && (z.baseTexture.ktxKeyValueData = D), BaseTexture.addToCache(z.baseTexture, X), Texture.addToCache(z, X), U === 0 && ($[o] = z, BaseTexture.addToCache(z.baseTexture, o), Texture.addToCache(z, o)), $[X] = z;
          }), Object.assign(t, { textures: $ });
        }
      } catch (k) {
        e(k);
        return;
      }
    e();
  }, n.extension = ExtensionType.Loader, n.loadKeyValueData = !1, n;
}();
/*!
 * @pixi/particle-container - v6.5.2
 * Compiled Wed, 24 Aug 2022 13:51:19 UTC
 *
 * @pixi/particle-container is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var extendStatics$m = function(n, t) {
  return extendStatics$m = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(e, o) {
    e.__proto__ = o;
  } || function(e, o) {
    for (var R in o)
      o.hasOwnProperty(R) && (e[R] = o[R]);
  }, extendStatics$m(n, t);
};
function __extends$m(n, t) {
  extendStatics$m(n, t);
  function e() {
    this.constructor = n;
  }
  n.prototype = t === null ? Object.create(t) : (e.prototype = t.prototype, new e());
}
(function(n) {
  __extends$m(t, n);
  function t(e, o, R, N) {
    e === void 0 && (e = 1500), R === void 0 && (R = 16384), N === void 0 && (N = !1);
    var M = n.call(this) || this, D = 16384;
    return R > D && (R = D), M._properties = [!1, !0, !1, !1, !1], M._maxSize = e, M._batchSize = R, M._buffers = null, M._bufferUpdateIDs = [], M._updateID = 0, M.interactiveChildren = !1, M.blendMode = BLEND_MODES$5.NORMAL, M.autoResize = N, M.roundPixels = !0, M.baseTexture = null, M.setProperties(o), M._tint = 0, M.tintRgb = new Float32Array(4), M.tint = 16777215, M;
  }
  return t.prototype.setProperties = function(e) {
    e && (this._properties[0] = "vertices" in e || "scale" in e ? !!e.vertices || !!e.scale : this._properties[0], this._properties[1] = "position" in e ? !!e.position : this._properties[1], this._properties[2] = "rotation" in e ? !!e.rotation : this._properties[2], this._properties[3] = "uvs" in e ? !!e.uvs : this._properties[3], this._properties[4] = "tint" in e || "alpha" in e ? !!e.tint || !!e.alpha : this._properties[4]);
  }, t.prototype.updateTransform = function() {
    this.displayObjectUpdateTransform();
  }, Object.defineProperty(t.prototype, "tint", {
    get: function() {
      return this._tint;
    },
    set: function(e) {
      this._tint = e, hex2rgb(e, this.tintRgb);
    },
    enumerable: !1,
    configurable: !0
  }), t.prototype.render = function(e) {
    var o = this;
    !this.visible || this.worldAlpha <= 0 || !this.children.length || !this.renderable || (this.baseTexture || (this.baseTexture = this.children[0]._texture.baseTexture, this.baseTexture.valid || this.baseTexture.once("update", function() {
      return o.onChildrenChange(0);
    })), e.batch.setObjectRenderer(e.plugins.particle), e.plugins.particle.render(this));
  }, t.prototype.onChildrenChange = function(e) {
    for (var o = Math.floor(e / this._batchSize); this._bufferUpdateIDs.length < o; )
      this._bufferUpdateIDs.push(0);
    this._bufferUpdateIDs[o] = ++this._updateID;
  }, t.prototype.dispose = function() {
    if (this._buffers) {
      for (var e = 0; e < this._buffers.length; ++e)
        this._buffers[e].destroy();
      this._buffers = null;
    }
  }, t.prototype.destroy = function(e) {
    n.prototype.destroy.call(this, e), this.dispose(), this._properties = null, this._buffers = null, this._bufferUpdateIDs = null;
  }, t;
})(Container);
var ParticleBuffer = function() {
  function n(t, e, o) {
    this.geometry = new Geometry(), this.indexBuffer = null, this.size = o, this.dynamicProperties = [], this.staticProperties = [];
    for (var R = 0; R < t.length; ++R) {
      var N = t[R];
      N = {
        attributeName: N.attributeName,
        size: N.size,
        uploadFunction: N.uploadFunction,
        type: N.type || TYPES$5.FLOAT,
        offset: N.offset
      }, e[R] ? this.dynamicProperties.push(N) : this.staticProperties.push(N);
    }
    this.staticStride = 0, this.staticBuffer = null, this.staticData = null, this.staticDataUint32 = null, this.dynamicStride = 0, this.dynamicBuffer = null, this.dynamicData = null, this.dynamicDataUint32 = null, this._updateID = 0, this.initBuffers();
  }
  return n.prototype.initBuffers = function() {
    var t = this.geometry, e = 0;
    this.indexBuffer = new Buffer$1(createIndicesForQuads(this.size), !0, !0), t.addIndex(this.indexBuffer), this.dynamicStride = 0;
    for (var o = 0; o < this.dynamicProperties.length; ++o) {
      var R = this.dynamicProperties[o];
      R.offset = e, e += R.size, this.dynamicStride += R.size;
    }
    var N = new ArrayBuffer(this.size * this.dynamicStride * 4 * 4);
    this.dynamicData = new Float32Array(N), this.dynamicDataUint32 = new Uint32Array(N), this.dynamicBuffer = new Buffer$1(this.dynamicData, !1, !1);
    var M = 0;
    this.staticStride = 0;
    for (var o = 0; o < this.staticProperties.length; ++o) {
      var R = this.staticProperties[o];
      R.offset = M, M += R.size, this.staticStride += R.size;
    }
    var D = new ArrayBuffer(this.size * this.staticStride * 4 * 4);
    this.staticData = new Float32Array(D), this.staticDataUint32 = new Uint32Array(D), this.staticBuffer = new Buffer$1(this.staticData, !0, !1);
    for (var o = 0; o < this.dynamicProperties.length; ++o) {
      var R = this.dynamicProperties[o];
      t.addAttribute(R.attributeName, this.dynamicBuffer, 0, R.type === TYPES$5.UNSIGNED_BYTE, R.type, this.dynamicStride * 4, R.offset * 4);
    }
    for (var o = 0; o < this.staticProperties.length; ++o) {
      var R = this.staticProperties[o];
      t.addAttribute(R.attributeName, this.staticBuffer, 0, R.type === TYPES$5.UNSIGNED_BYTE, R.type, this.staticStride * 4, R.offset * 4);
    }
  }, n.prototype.uploadDynamic = function(t, e, o) {
    for (var R = 0; R < this.dynamicProperties.length; R++) {
      var N = this.dynamicProperties[R];
      N.uploadFunction(t, e, o, N.type === TYPES$5.UNSIGNED_BYTE ? this.dynamicDataUint32 : this.dynamicData, this.dynamicStride, N.offset);
    }
    this.dynamicBuffer._updateID++;
  }, n.prototype.uploadStatic = function(t, e, o) {
    for (var R = 0; R < this.staticProperties.length; R++) {
      var N = this.staticProperties[R];
      N.uploadFunction(t, e, o, N.type === TYPES$5.UNSIGNED_BYTE ? this.staticDataUint32 : this.staticData, this.staticStride, N.offset);
    }
    this.staticBuffer._updateID++;
  }, n.prototype.destroy = function() {
    this.indexBuffer = null, this.dynamicProperties = null, this.dynamicBuffer = null, this.dynamicData = null, this.dynamicDataUint32 = null, this.staticProperties = null, this.staticBuffer = null, this.staticData = null, this.staticDataUint32 = null, this.geometry.destroy();
  }, n;
}(), fragment$6 = `varying vec2 vTextureCoord;
varying vec4 vColor;

uniform sampler2D uSampler;

void main(void){
    vec4 color = texture2D(uSampler, vTextureCoord) * vColor;
    gl_FragColor = color;
}`, vertex$3 = `attribute vec2 aVertexPosition;
attribute vec2 aTextureCoord;
attribute vec4 aColor;

attribute vec2 aPositionCoord;
attribute float aRotation;

uniform mat3 translationMatrix;
uniform vec4 uColor;

varying vec2 vTextureCoord;
varying vec4 vColor;

void main(void){
    float x = (aVertexPosition.x) * cos(aRotation) - (aVertexPosition.y) * sin(aRotation);
    float y = (aVertexPosition.x) * sin(aRotation) + (aVertexPosition.y) * cos(aRotation);

    vec2 v = vec2(x, y);
    v = v + aPositionCoord;

    gl_Position = vec4((translationMatrix * vec3(v, 1.0)).xy, 0.0, 1.0);

    vTextureCoord = aTextureCoord;
    vColor = aColor * uColor;
}
`, ParticleRenderer = function(n) {
  __extends$m(t, n);
  function t(e) {
    var o = n.call(this, e) || this;
    return o.shader = null, o.properties = null, o.tempMatrix = new Matrix(), o.properties = [
      {
        attributeName: "aVertexPosition",
        size: 2,
        uploadFunction: o.uploadVertices,
        offset: 0
      },
      {
        attributeName: "aPositionCoord",
        size: 2,
        uploadFunction: o.uploadPosition,
        offset: 0
      },
      {
        attributeName: "aRotation",
        size: 1,
        uploadFunction: o.uploadRotation,
        offset: 0
      },
      {
        attributeName: "aTextureCoord",
        size: 2,
        uploadFunction: o.uploadUvs,
        offset: 0
      },
      {
        attributeName: "aColor",
        size: 1,
        type: TYPES$5.UNSIGNED_BYTE,
        uploadFunction: o.uploadTint,
        offset: 0
      }
    ], o.shader = Shader.from(vertex$3, fragment$6, {}), o.state = State.for2d(), o;
  }
  return t.prototype.render = function(e) {
    var o = e.children, R = e._maxSize, N = e._batchSize, M = this.renderer, D = o.length;
    if (D !== 0) {
      D > R && !e.autoResize && (D = R);
      var L = e._buffers;
      L || (L = e._buffers = this.generateBuffers(e));
      var B = o[0]._texture.baseTexture, $ = B.alphaMode > 0;
      this.state.blendMode = correctBlendMode(e.blendMode, $), M.state.set(this.state);
      var k = M.gl, U = e.worldTransform.copyTo(this.tempMatrix);
      U.prepend(M.globalUniforms.uniforms.projectionMatrix), this.shader.uniforms.translationMatrix = U.toArray(!0), this.shader.uniforms.uColor = premultiplyRgba(e.tintRgb, e.worldAlpha, this.shader.uniforms.uColor, $), this.shader.uniforms.uSampler = B, this.renderer.shader.bind(this.shader);
      for (var z = !1, X = 0, V = 0; X < D; X += N, V += 1) {
        var W = D - X;
        W > N && (W = N), V >= L.length && L.push(this._generateOneMoreBuffer(e));
        var Y = L[V];
        Y.uploadDynamic(o, X, W);
        var q = e._bufferUpdateIDs[V] || 0;
        z = z || Y._updateID < q, z && (Y._updateID = e._updateID, Y.uploadStatic(o, X, W)), M.geometry.bind(Y.geometry), k.drawElements(k.TRIANGLES, W * 6, k.UNSIGNED_SHORT, 0);
      }
    }
  }, t.prototype.generateBuffers = function(e) {
    for (var o = [], R = e._maxSize, N = e._batchSize, M = e._properties, D = 0; D < R; D += N)
      o.push(new ParticleBuffer(this.properties, M, N));
    return o;
  }, t.prototype._generateOneMoreBuffer = function(e) {
    var o = e._batchSize, R = e._properties;
    return new ParticleBuffer(this.properties, R, o);
  }, t.prototype.uploadVertices = function(e, o, R, N, M, D) {
    for (var L = 0, B = 0, $ = 0, k = 0, U = 0; U < R; ++U) {
      var z = e[o + U], X = z._texture, V = z.scale.x, W = z.scale.y, Y = X.trim, q = X.orig;
      Y ? (B = Y.x - z.anchor.x * q.width, L = B + Y.width, k = Y.y - z.anchor.y * q.height, $ = k + Y.height) : (L = q.width * (1 - z.anchor.x), B = q.width * -z.anchor.x, $ = q.height * (1 - z.anchor.y), k = q.height * -z.anchor.y), N[D] = B * V, N[D + 1] = k * W, N[D + M] = L * V, N[D + M + 1] = k * W, N[D + M * 2] = L * V, N[D + M * 2 + 1] = $ * W, N[D + M * 3] = B * V, N[D + M * 3 + 1] = $ * W, D += M * 4;
    }
  }, t.prototype.uploadPosition = function(e, o, R, N, M, D) {
    for (var L = 0; L < R; L++) {
      var B = e[o + L].position;
      N[D] = B.x, N[D + 1] = B.y, N[D + M] = B.x, N[D + M + 1] = B.y, N[D + M * 2] = B.x, N[D + M * 2 + 1] = B.y, N[D + M * 3] = B.x, N[D + M * 3 + 1] = B.y, D += M * 4;
    }
  }, t.prototype.uploadRotation = function(e, o, R, N, M, D) {
    for (var L = 0; L < R; L++) {
      var B = e[o + L].rotation;
      N[D] = B, N[D + M] = B, N[D + M * 2] = B, N[D + M * 3] = B, D += M * 4;
    }
  }, t.prototype.uploadUvs = function(e, o, R, N, M, D) {
    for (var L = 0; L < R; ++L) {
      var B = e[o + L]._texture._uvs;
      B ? (N[D] = B.x0, N[D + 1] = B.y0, N[D + M] = B.x1, N[D + M + 1] = B.y1, N[D + M * 2] = B.x2, N[D + M * 2 + 1] = B.y2, N[D + M * 3] = B.x3, N[D + M * 3 + 1] = B.y3, D += M * 4) : (N[D] = 0, N[D + 1] = 0, N[D + M] = 0, N[D + M + 1] = 0, N[D + M * 2] = 0, N[D + M * 2 + 1] = 0, N[D + M * 3] = 0, N[D + M * 3 + 1] = 0, D += M * 4);
    }
  }, t.prototype.uploadTint = function(e, o, R, N, M, D) {
    for (var L = 0; L < R; ++L) {
      var B = e[o + L], $ = B._texture.baseTexture.alphaMode > 0, k = B.alpha, U = k < 1 && $ ? premultiplyTint(B._tintRGB, k) : B._tintRGB + (k * 255 << 24);
      N[D] = U, N[D + M] = U, N[D + M * 2] = U, N[D + M * 3] = U, D += M * 4;
    }
  }, t.prototype.destroy = function() {
    n.prototype.destroy.call(this), this.shader && (this.shader.destroy(), this.shader = null), this.tempMatrix = null;
  }, t.extension = {
    name: "particle",
    type: ExtensionType.RendererPlugin
  }, t;
}(ObjectRenderer);
/*!
 * @pixi/graphics - v6.5.2
 * Compiled Wed, 24 Aug 2022 13:51:19 UTC
 *
 * @pixi/graphics is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
var LINE_JOIN;
(function(n) {
  n.MITER = "miter", n.BEVEL = "bevel", n.ROUND = "round";
})(LINE_JOIN || (LINE_JOIN = {}));
var LINE_CAP;
(function(n) {
  n.BUTT = "butt", n.ROUND = "round", n.SQUARE = "square";
})(LINE_CAP || (LINE_CAP = {}));
var GRAPHICS_CURVES = {
  adaptive: !0,
  maxLength: 10,
  minSegments: 8,
  maxSegments: 2048,
  epsilon: 1e-4,
  _segmentsCount: function(n, t) {
    if (t === void 0 && (t = 20), !this.adaptive || !n || isNaN(n))
      return t;
    var e = Math.ceil(n / this.maxLength);
    return e < this.minSegments ? e = this.minSegments : e > this.maxSegments && (e = this.maxSegments), e;
  }
}, FillStyle = function() {
  function n() {
    this.color = 16777215, this.alpha = 1, this.texture = Texture.WHITE, this.matrix = null, this.visible = !1, this.reset();
  }
  return n.prototype.clone = function() {
    var t = new n();
    return t.color = this.color, t.alpha = this.alpha, t.texture = this.texture, t.matrix = this.matrix, t.visible = this.visible, t;
  }, n.prototype.reset = function() {
    this.color = 16777215, this.alpha = 1, this.texture = Texture.WHITE, this.matrix = null, this.visible = !1;
  }, n.prototype.destroy = function() {
    this.texture = null, this.matrix = null;
  }, n;
}();
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var extendStatics$l = function(n, t) {
  return extendStatics$l = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(e, o) {
    e.__proto__ = o;
  } || function(e, o) {
    for (var R in o)
      o.hasOwnProperty(R) && (e[R] = o[R]);
  }, extendStatics$l(n, t);
};
function __extends$l(n, t) {
  extendStatics$l(n, t);
  function e() {
    this.constructor = n;
  }
  n.prototype = t === null ? Object.create(t) : (e.prototype = t.prototype, new e());
}
function fixOrientation(n, t) {
  var e, o;
  t === void 0 && (t = !1);
  var R = n.length;
  if (!(R < 6)) {
    for (var N = 0, M = 0, D = n[R - 2], L = n[R - 1]; M < R; M += 2) {
      var B = n[M], $ = n[M + 1];
      N += (B - D) * ($ + L), D = B, L = $;
    }
    if (!t && N > 0 || t && N <= 0)
      for (var k = R / 2, M = k + k % 2; M < R; M += 2) {
        var U = R - M - 2, z = R - M - 1, X = M, V = M + 1;
        e = [n[X], n[U]], n[U] = e[0], n[X] = e[1], o = [n[V], n[z]], n[z] = o[0], n[V] = o[1];
      }
  }
}
var buildPoly = {
  build: function(n) {
    n.points = n.shape.points.slice();
  },
  triangulate: function(n, t) {
    var e = n.points, o = n.holes, R = t.points, N = t.indices;
    if (e.length >= 6) {
      fixOrientation(e, !1);
      for (var M = [], D = 0; D < o.length; D++) {
        var L = o[D];
        fixOrientation(L.points, !0), M.push(e.length / 2), e = e.concat(L.points);
      }
      var B = earcut$1.exports(e, M, 2);
      if (!B)
        return;
      for (var $ = R.length / 2, D = 0; D < B.length; D += 3)
        N.push(B[D] + $), N.push(B[D + 1] + $), N.push(B[D + 2] + $);
      for (var D = 0; D < e.length; D++)
        R.push(e[D]);
    }
  }
}, buildCircle = {
  build: function(n) {
    var t = n.points, e, o, R, N, M, D;
    if (n.type === SHAPES.CIRC) {
      var L = n.shape;
      e = L.x, o = L.y, M = D = L.radius, R = N = 0;
    } else if (n.type === SHAPES.ELIP) {
      var B = n.shape;
      e = B.x, o = B.y, M = B.width, D = B.height, R = N = 0;
    } else {
      var $ = n.shape, k = $.width / 2, U = $.height / 2;
      e = $.x + k, o = $.y + U, M = D = Math.max(0, Math.min($.radius, Math.min(k, U))), R = k - M, N = U - D;
    }
    if (!(M >= 0 && D >= 0 && R >= 0 && N >= 0)) {
      t.length = 0;
      return;
    }
    var z = Math.ceil(2.3 * Math.sqrt(M + D)), X = z * 8 + (R ? 4 : 0) + (N ? 4 : 0);
    if (t.length = X, X !== 0) {
      if (z === 0) {
        t.length = 8, t[0] = t[6] = e + R, t[1] = t[3] = o + N, t[2] = t[4] = e - R, t[5] = t[7] = o - N;
        return;
      }
      var V = 0, W = z * 4 + (R ? 2 : 0) + 2, Y = W, q = X;
      {
        var Z = R + M, J = N, Q = e + Z, K = e - Z, rt = o + J;
        if (t[V++] = Q, t[V++] = rt, t[--W] = rt, t[--W] = K, N) {
          var tt = o - J;
          t[Y++] = K, t[Y++] = tt, t[--q] = tt, t[--q] = Q;
        }
      }
      for (var nt = 1; nt < z; nt++) {
        var at = Math.PI / 2 * (nt / z), Z = R + Math.cos(at) * M, J = N + Math.sin(at) * D, Q = e + Z, K = e - Z, rt = o + J, tt = o - J;
        t[V++] = Q, t[V++] = rt, t[--W] = rt, t[--W] = K, t[Y++] = K, t[Y++] = tt, t[--q] = tt, t[--q] = Q;
      }
      {
        var Z = R, J = N + D, Q = e + Z, K = e - Z, rt = o + J, tt = o - J;
        t[V++] = Q, t[V++] = rt, t[--q] = tt, t[--q] = Q, R && (t[V++] = K, t[V++] = rt, t[--q] = tt, t[--q] = K);
      }
    }
  },
  triangulate: function(n, t) {
    var e = n.points, o = t.points, R = t.indices;
    if (e.length !== 0) {
      var N = o.length / 2, M = N, D, L;
      if (n.type !== SHAPES.RREC) {
        var B = n.shape;
        D = B.x, L = B.y;
      } else {
        var $ = n.shape;
        D = $.x + $.width / 2, L = $.y + $.height / 2;
      }
      var k = n.matrix;
      o.push(n.matrix ? k.a * D + k.c * L + k.tx : D, n.matrix ? k.b * D + k.d * L + k.ty : L), N++, o.push(e[0], e[1]);
      for (var U = 2; U < e.length; U += 2)
        o.push(e[U], e[U + 1]), R.push(N++, M, N);
      R.push(M + 1, M, N);
    }
  }
}, buildRectangle = {
  build: function(n) {
    var t = n.shape, e = t.x, o = t.y, R = t.width, N = t.height, M = n.points;
    M.length = 0, M.push(e, o, e + R, o, e + R, o + N, e, o + N);
  },
  triangulate: function(n, t) {
    var e = n.points, o = t.points, R = o.length / 2;
    o.push(e[0], e[1], e[2], e[3], e[6], e[7], e[4], e[5]), t.indices.push(R, R + 1, R + 2, R + 1, R + 2, R + 3);
  }
};
function getPt(n, t, e) {
  var o = t - n;
  return n + o * e;
}
function quadraticBezierCurve(n, t, e, o, R, N, M) {
  M === void 0 && (M = []);
  for (var D = 20, L = M, B = 0, $ = 0, k = 0, U = 0, z = 0, X = 0, V = 0, W = 0; V <= D; ++V)
    W = V / D, B = getPt(n, e, W), $ = getPt(t, o, W), k = getPt(e, R, W), U = getPt(o, N, W), z = getPt(B, k, W), X = getPt($, U, W), !(V === 0 && L[L.length - 2] === z && L[L.length - 1] === X) && L.push(z, X);
  return L;
}
var buildRoundedRectangle = {
  build: function(n) {
    if (Graphics.nextRoundedRectBehavior) {
      buildCircle.build(n);
      return;
    }
    var t = n.shape, e = n.points, o = t.x, R = t.y, N = t.width, M = t.height, D = Math.max(0, Math.min(t.radius, Math.min(N, M) / 2));
    e.length = 0, D ? (quadraticBezierCurve(o, R + D, o, R, o + D, R, e), quadraticBezierCurve(o + N - D, R, o + N, R, o + N, R + D, e), quadraticBezierCurve(o + N, R + M - D, o + N, R + M, o + N - D, R + M, e), quadraticBezierCurve(o + D, R + M, o, R + M, o, R + M - D, e)) : e.push(o, R, o + N, R, o + N, R + M, o, R + M);
  },
  triangulate: function(n, t) {
    if (Graphics.nextRoundedRectBehavior) {
      buildCircle.triangulate(n, t);
      return;
    }
    for (var e = n.points, o = t.points, R = t.indices, N = o.length / 2, M = earcut$1.exports(e, null, 2), D = 0, L = M.length; D < L; D += 3)
      R.push(M[D] + N), R.push(M[D + 1] + N), R.push(M[D + 2] + N);
    for (var D = 0, L = e.length; D < L; D++)
      o.push(e[D], e[++D]);
  }
};
function square(n, t, e, o, R, N, M, D) {
  var L = n - e * R, B = t - o * R, $ = n + e * N, k = t + o * N, U, z;
  M ? (U = o, z = -e) : (U = -o, z = e);
  var X = L + U, V = B + z, W = $ + U, Y = k + z;
  return D.push(X, V), D.push(W, Y), 2;
}
function round$1(n, t, e, o, R, N, M, D) {
  var L = e - n, B = o - t, $ = Math.atan2(L, B), k = Math.atan2(R - n, N - t);
  D && $ < k ? $ += Math.PI * 2 : !D && $ > k && (k += Math.PI * 2);
  var U = $, z = k - $, X = Math.abs(z), V = Math.sqrt(L * L + B * B), W = (15 * X * Math.sqrt(V) / Math.PI >> 0) + 1, Y = z / W;
  if (U += Y, D) {
    M.push(n, t), M.push(e, o);
    for (var q = 1, Z = U; q < W; q++, Z += Y)
      M.push(n, t), M.push(n + Math.sin(Z) * V, t + Math.cos(Z) * V);
    M.push(n, t), M.push(R, N);
  } else {
    M.push(e, o), M.push(n, t);
    for (var q = 1, Z = U; q < W; q++, Z += Y)
      M.push(n + Math.sin(Z) * V, t + Math.cos(Z) * V), M.push(n, t);
    M.push(R, N), M.push(n, t);
  }
  return W * 2;
}
function buildNonNativeLine(n, t) {
  var e = n.shape, o = n.points || e.points.slice(), R = t.closePointEps;
  if (o.length !== 0) {
    var N = n.lineStyle, M = new Point(o[0], o[1]), D = new Point(o[o.length - 2], o[o.length - 1]), L = e.type !== SHAPES.POLY || e.closeStroke, B = Math.abs(M.x - D.x) < R && Math.abs(M.y - D.y) < R;
    if (L) {
      o = o.slice(), B && (o.pop(), o.pop(), D.set(o[o.length - 2], o[o.length - 1]));
      var $ = (M.x + D.x) * 0.5, k = (D.y + M.y) * 0.5;
      o.unshift($, k), o.push($, k);
    }
    var U = t.points, z = o.length / 2, X = o.length, V = U.length / 2, W = N.width / 2, Y = W * W, q = N.miterLimit * N.miterLimit, Z = o[0], J = o[1], Q = o[2], K = o[3], rt = 0, tt = 0, nt = -(J - K), at = Z - Q, lt = 0, ut = 0, dt = Math.sqrt(nt * nt + at * at);
    nt /= dt, at /= dt, nt *= W, at *= W;
    var yt = N.alignment, pt = (1 - yt) * 2, gt = yt * 2;
    L || (N.cap === LINE_CAP.ROUND ? X += round$1(Z - nt * (pt - gt) * 0.5, J - at * (pt - gt) * 0.5, Z - nt * pt, J - at * pt, Z + nt * gt, J + at * gt, U, !0) + 2 : N.cap === LINE_CAP.SQUARE && (X += square(Z, J, nt, at, pt, gt, !0, U))), U.push(Z - nt * pt, J - at * pt), U.push(Z + nt * gt, J + at * gt);
    for (var xt = 1; xt < z - 1; ++xt) {
      Z = o[(xt - 1) * 2], J = o[(xt - 1) * 2 + 1], Q = o[xt * 2], K = o[xt * 2 + 1], rt = o[(xt + 1) * 2], tt = o[(xt + 1) * 2 + 1], nt = -(J - K), at = Z - Q, dt = Math.sqrt(nt * nt + at * at), nt /= dt, at /= dt, nt *= W, at *= W, lt = -(K - tt), ut = Q - rt, dt = Math.sqrt(lt * lt + ut * ut), lt /= dt, ut /= dt, lt *= W, ut *= W;
      var Lt = Q - Z, mt = J - K, ct = Q - rt, vt = tt - K, Tt = mt * ct - vt * Lt, Pt = Tt < 0;
      if (Math.abs(Tt) < 0.1) {
        U.push(Q - nt * pt, K - at * pt), U.push(Q + nt * gt, K + at * gt);
        continue;
      }
      var wt = (-nt + Z) * (-at + K) - (-nt + Q) * (-at + J), Mt = (-lt + rt) * (-ut + K) - (-lt + Q) * (-ut + tt), ht = (Lt * Mt - ct * wt) / Tt, $t = (vt * wt - mt * Mt) / Tt, At = (ht - Q) * (ht - Q) + ($t - K) * ($t - K), kt = Q + (ht - Q) * pt, Ot = K + ($t - K) * pt, _t = Q - (ht - Q) * gt, Gt = K - ($t - K) * gt, St = Math.min(Lt * Lt + mt * mt, ct * ct + vt * vt), Et = Pt ? pt : gt, Rt = St + Et * Et * Y, Dt = At <= Rt;
      Dt ? N.join === LINE_JOIN.BEVEL || At / Y > q ? (Pt ? (U.push(kt, Ot), U.push(Q + nt * gt, K + at * gt), U.push(kt, Ot), U.push(Q + lt * gt, K + ut * gt)) : (U.push(Q - nt * pt, K - at * pt), U.push(_t, Gt), U.push(Q - lt * pt, K - ut * pt), U.push(_t, Gt)), X += 2) : N.join === LINE_JOIN.ROUND ? Pt ? (U.push(kt, Ot), U.push(Q + nt * gt, K + at * gt), X += round$1(Q, K, Q + nt * gt, K + at * gt, Q + lt * gt, K + ut * gt, U, !0) + 4, U.push(kt, Ot), U.push(Q + lt * gt, K + ut * gt)) : (U.push(Q - nt * pt, K - at * pt), U.push(_t, Gt), X += round$1(Q, K, Q - nt * pt, K - at * pt, Q - lt * pt, K - ut * pt, U, !1) + 4, U.push(Q - lt * pt, K - ut * pt), U.push(_t, Gt)) : (U.push(kt, Ot), U.push(_t, Gt)) : (U.push(Q - nt * pt, K - at * pt), U.push(Q + nt * gt, K + at * gt), N.join === LINE_JOIN.ROUND ? Pt ? X += round$1(Q, K, Q + nt * gt, K + at * gt, Q + lt * gt, K + ut * gt, U, !0) + 2 : X += round$1(Q, K, Q - nt * pt, K - at * pt, Q - lt * pt, K - ut * pt, U, !1) + 2 : N.join === LINE_JOIN.MITER && At / Y <= q && (Pt ? (U.push(_t, Gt), U.push(_t, Gt)) : (U.push(kt, Ot), U.push(kt, Ot)), X += 2), U.push(Q - lt * pt, K - ut * pt), U.push(Q + lt * gt, K + ut * gt), X += 2);
    }
    Z = o[(z - 2) * 2], J = o[(z - 2) * 2 + 1], Q = o[(z - 1) * 2], K = o[(z - 1) * 2 + 1], nt = -(J - K), at = Z - Q, dt = Math.sqrt(nt * nt + at * at), nt /= dt, at /= dt, nt *= W, at *= W, U.push(Q - nt * pt, K - at * pt), U.push(Q + nt * gt, K + at * gt), L || (N.cap === LINE_CAP.ROUND ? X += round$1(Q - nt * (pt - gt) * 0.5, K - at * (pt - gt) * 0.5, Q - nt * pt, K - at * pt, Q + nt * gt, K + at * gt, U, !1) + 2 : N.cap === LINE_CAP.SQUARE && (X += square(Q, K, nt, at, pt, gt, !1, U)));
    for (var Ct = t.indices, Zt = GRAPHICS_CURVES.epsilon * GRAPHICS_CURVES.epsilon, xt = V; xt < X + V - 2; ++xt)
      Z = U[xt * 2], J = U[xt * 2 + 1], Q = U[(xt + 1) * 2], K = U[(xt + 1) * 2 + 1], rt = U[(xt + 2) * 2], tt = U[(xt + 2) * 2 + 1], !(Math.abs(Z * (K - tt) + Q * (tt - J) + rt * (J - K)) < Zt) && Ct.push(xt, xt + 1, xt + 2);
  }
}
function buildNativeLine(n, t) {
  var e = 0, o = n.shape, R = n.points || o.points, N = o.type !== SHAPES.POLY || o.closeStroke;
  if (R.length !== 0) {
    var M = t.points, D = t.indices, L = R.length / 2, B = M.length / 2, $ = B;
    for (M.push(R[0], R[1]), e = 1; e < L; e++)
      M.push(R[e * 2], R[e * 2 + 1]), D.push($, $ + 1), $++;
    N && D.push($, B);
  }
}
function buildLine(n, t) {
  n.lineStyle.native ? buildNativeLine(n, t) : buildNonNativeLine(n, t);
}
var ArcUtils = function() {
  function n() {
  }
  return n.curveTo = function(t, e, o, R, N, M) {
    var D = M[M.length - 2], L = M[M.length - 1], B = L - e, $ = D - t, k = R - e, U = o - t, z = Math.abs(B * U - $ * k);
    if (z < 1e-8 || N === 0)
      return (M[M.length - 2] !== t || M[M.length - 1] !== e) && M.push(t, e), null;
    var X = B * B + $ * $, V = k * k + U * U, W = B * k + $ * U, Y = N * Math.sqrt(X) / z, q = N * Math.sqrt(V) / z, Z = Y * W / X, J = q * W / V, Q = Y * U + q * $, K = Y * k + q * B, rt = $ * (q + Z), tt = B * (q + Z), nt = U * (Y + J), at = k * (Y + J), lt = Math.atan2(tt - K, rt - Q), ut = Math.atan2(at - K, nt - Q);
    return {
      cx: Q + t,
      cy: K + e,
      radius: N,
      startAngle: lt,
      endAngle: ut,
      anticlockwise: $ * k > U * B
    };
  }, n.arc = function(t, e, o, R, N, M, D, L, B) {
    for (var $ = D - M, k = GRAPHICS_CURVES._segmentsCount(Math.abs($) * N, Math.ceil(Math.abs($) / PI_2) * 40), U = $ / (k * 2), z = U * 2, X = Math.cos(U), V = Math.sin(U), W = k - 1, Y = W % 1 / W, q = 0; q <= W; ++q) {
      var Z = q + Y * q, J = U + M + z * Z, Q = Math.cos(J), K = -Math.sin(J);
      B.push((X * Q + V * K) * N + o, (X * -K + V * Q) * N + R);
    }
  }, n;
}(), BezierUtils = function() {
  function n() {
  }
  return n.curveLength = function(t, e, o, R, N, M, D, L) {
    for (var B = 10, $ = 0, k = 0, U = 0, z = 0, X = 0, V = 0, W = 0, Y = 0, q = 0, Z = 0, J = 0, Q = t, K = e, rt = 1; rt <= B; ++rt)
      k = rt / B, U = k * k, z = U * k, X = 1 - k, V = X * X, W = V * X, Y = W * t + 3 * V * k * o + 3 * X * U * N + z * D, q = W * e + 3 * V * k * R + 3 * X * U * M + z * L, Z = Q - Y, J = K - q, Q = Y, K = q, $ += Math.sqrt(Z * Z + J * J);
    return $;
  }, n.curveTo = function(t, e, o, R, N, M, D) {
    var L = D[D.length - 2], B = D[D.length - 1];
    D.length -= 2;
    var $ = GRAPHICS_CURVES._segmentsCount(n.curveLength(L, B, t, e, o, R, N, M)), k = 0, U = 0, z = 0, X = 0, V = 0;
    D.push(L, B);
    for (var W = 1, Y = 0; W <= $; ++W)
      Y = W / $, k = 1 - Y, U = k * k, z = U * k, X = Y * Y, V = X * Y, D.push(z * L + 3 * U * Y * t + 3 * k * X * o + V * N, z * B + 3 * U * Y * e + 3 * k * X * R + V * M);
  }, n;
}(), QuadraticUtils = function() {
  function n() {
  }
  return n.curveLength = function(t, e, o, R, N, M) {
    var D = t - 2 * o + N, L = e - 2 * R + M, B = 2 * o - 2 * t, $ = 2 * R - 2 * e, k = 4 * (D * D + L * L), U = 4 * (D * B + L * $), z = B * B + $ * $, X = 2 * Math.sqrt(k + U + z), V = Math.sqrt(k), W = 2 * k * V, Y = 2 * Math.sqrt(z), q = U / V;
    return (W * X + V * U * (X - Y) + (4 * z * k - U * U) * Math.log((2 * V + q + X) / (q + Y))) / (4 * W);
  }, n.curveTo = function(t, e, o, R, N) {
    for (var M = N[N.length - 2], D = N[N.length - 1], L = GRAPHICS_CURVES._segmentsCount(n.curveLength(M, D, t, e, o, R)), B = 0, $ = 0, k = 1; k <= L; ++k) {
      var U = k / L;
      B = M + (t - M) * U, $ = D + (e - D) * U, N.push(B + (t + (o - t) * U - B) * U, $ + (e + (R - e) * U - $) * U);
    }
  }, n;
}(), BatchPart = function() {
  function n() {
    this.reset();
  }
  return n.prototype.begin = function(t, e, o) {
    this.reset(), this.style = t, this.start = e, this.attribStart = o;
  }, n.prototype.end = function(t, e) {
    this.attribSize = e - this.attribStart, this.size = t - this.start;
  }, n.prototype.reset = function() {
    this.style = null, this.size = 0, this.start = 0, this.attribStart = 0, this.attribSize = 0;
  }, n;
}(), _a, FILL_COMMANDS = (_a = {}, _a[SHAPES.POLY] = buildPoly, _a[SHAPES.CIRC] = buildCircle, _a[SHAPES.ELIP] = buildCircle, _a[SHAPES.RECT] = buildRectangle, _a[SHAPES.RREC] = buildRoundedRectangle, _a), BATCH_POOL = [], DRAW_CALL_POOL = [], GraphicsData = function() {
  function n(t, e, o, R) {
    e === void 0 && (e = null), o === void 0 && (o = null), R === void 0 && (R = null), this.points = [], this.holes = [], this.shape = t, this.lineStyle = o, this.fillStyle = e, this.matrix = R, this.type = t.type;
  }
  return n.prototype.clone = function() {
    return new n(this.shape, this.fillStyle, this.lineStyle, this.matrix);
  }, n.prototype.destroy = function() {
    this.shape = null, this.holes.length = 0, this.holes = null, this.points.length = 0, this.points = null, this.lineStyle = null, this.fillStyle = null;
  }, n;
}(), tmpPoint = new Point(), GraphicsGeometry = function(n) {
  __extends$l(t, n);
  function t() {
    var e = n.call(this) || this;
    return e.closePointEps = 1e-4, e.boundsPadding = 0, e.uvsFloat32 = null, e.indicesUint16 = null, e.batchable = !1, e.points = [], e.colors = [], e.uvs = [], e.indices = [], e.textureIds = [], e.graphicsData = [], e.drawCalls = [], e.batchDirty = -1, e.batches = [], e.dirty = 0, e.cacheDirty = -1, e.clearDirty = 0, e.shapeIndex = 0, e._bounds = new Bounds(), e.boundsDirty = -1, e;
  }
  return Object.defineProperty(t.prototype, "bounds", {
    get: function() {
      return this.updateBatches(), this.boundsDirty !== this.dirty && (this.boundsDirty = this.dirty, this.calculateBounds()), this._bounds;
    },
    enumerable: !1,
    configurable: !0
  }), t.prototype.invalidate = function() {
    this.boundsDirty = -1, this.dirty++, this.batchDirty++, this.shapeIndex = 0, this.points.length = 0, this.colors.length = 0, this.uvs.length = 0, this.indices.length = 0, this.textureIds.length = 0;
    for (var e = 0; e < this.drawCalls.length; e++)
      this.drawCalls[e].texArray.clear(), DRAW_CALL_POOL.push(this.drawCalls[e]);
    this.drawCalls.length = 0;
    for (var e = 0; e < this.batches.length; e++) {
      var o = this.batches[e];
      o.reset(), BATCH_POOL.push(o);
    }
    this.batches.length = 0;
  }, t.prototype.clear = function() {
    return this.graphicsData.length > 0 && (this.invalidate(), this.clearDirty++, this.graphicsData.length = 0), this;
  }, t.prototype.drawShape = function(e, o, R, N) {
    o === void 0 && (o = null), R === void 0 && (R = null), N === void 0 && (N = null);
    var M = new GraphicsData(e, o, R, N);
    return this.graphicsData.push(M), this.dirty++, this;
  }, t.prototype.drawHole = function(e, o) {
    if (o === void 0 && (o = null), !this.graphicsData.length)
      return null;
    var R = new GraphicsData(e, null, null, o), N = this.graphicsData[this.graphicsData.length - 1];
    return R.lineStyle = N.lineStyle, N.holes.push(R), this.dirty++, this;
  }, t.prototype.destroy = function() {
    n.prototype.destroy.call(this);
    for (var e = 0; e < this.graphicsData.length; ++e)
      this.graphicsData[e].destroy();
    this.points.length = 0, this.points = null, this.colors.length = 0, this.colors = null, this.uvs.length = 0, this.uvs = null, this.indices.length = 0, this.indices = null, this.indexBuffer.destroy(), this.indexBuffer = null, this.graphicsData.length = 0, this.graphicsData = null, this.drawCalls.length = 0, this.drawCalls = null, this.batches.length = 0, this.batches = null, this._bounds = null;
  }, t.prototype.containsPoint = function(e) {
    for (var o = this.graphicsData, R = 0; R < o.length; ++R) {
      var N = o[R];
      if (!!N.fillStyle.visible && N.shape && (N.matrix ? N.matrix.applyInverse(e, tmpPoint) : tmpPoint.copyFrom(e), N.shape.contains(tmpPoint.x, tmpPoint.y))) {
        var M = !1;
        if (N.holes)
          for (var D = 0; D < N.holes.length; D++) {
            var L = N.holes[D];
            if (L.shape.contains(tmpPoint.x, tmpPoint.y)) {
              M = !0;
              break;
            }
          }
        if (!M)
          return !0;
      }
    }
    return !1;
  }, t.prototype.updateBatches = function() {
    if (!this.graphicsData.length) {
      this.batchable = !0;
      return;
    }
    if (!!this.validateBatching()) {
      this.cacheDirty = this.dirty;
      var e = this.uvs, o = this.graphicsData, R = null, N = null;
      this.batches.length > 0 && (R = this.batches[this.batches.length - 1], N = R.style);
      for (var M = this.shapeIndex; M < o.length; M++) {
        this.shapeIndex++;
        var D = o[M], L = D.fillStyle, B = D.lineStyle, $ = FILL_COMMANDS[D.type];
        $.build(D), D.matrix && this.transformPoints(D.points, D.matrix), (L.visible || B.visible) && this.processHoles(D.holes);
        for (var k = 0; k < 2; k++) {
          var U = k === 0 ? L : B;
          if (!!U.visible) {
            var z = U.texture.baseTexture, X = this.indices.length, V = this.points.length / 2;
            z.wrapMode = WRAP_MODES$5.REPEAT, k === 0 ? this.processFill(D) : this.processLine(D);
            var W = this.points.length / 2 - V;
            W !== 0 && (R && !this._compareStyles(N, U) && (R.end(X, V), R = null), R || (R = BATCH_POOL.pop() || new BatchPart(), R.begin(U, X, V), this.batches.push(R), N = U), this.addUvs(this.points, e, U.texture, V, W, U.matrix));
          }
        }
      }
      var Y = this.indices.length, q = this.points.length / 2;
      if (R && R.end(Y, q), this.batches.length === 0) {
        this.batchable = !0;
        return;
      }
      var Z = q > 65535;
      this.indicesUint16 && this.indices.length === this.indicesUint16.length && Z === this.indicesUint16.BYTES_PER_ELEMENT > 2 ? this.indicesUint16.set(this.indices) : this.indicesUint16 = Z ? new Uint32Array(this.indices) : new Uint16Array(this.indices), this.batchable = this.isBatchable(), this.batchable ? this.packBatches() : this.buildDrawCalls();
    }
  }, t.prototype._compareStyles = function(e, o) {
    return !(!e || !o || e.texture.baseTexture !== o.texture.baseTexture || e.color + e.alpha !== o.color + o.alpha || !!e.native != !!o.native);
  }, t.prototype.validateBatching = function() {
    if (this.dirty === this.cacheDirty || !this.graphicsData.length)
      return !1;
    for (var e = 0, o = this.graphicsData.length; e < o; e++) {
      var R = this.graphicsData[e], N = R.fillStyle, M = R.lineStyle;
      if (N && !N.texture.baseTexture.valid || M && !M.texture.baseTexture.valid)
        return !1;
    }
    return !0;
  }, t.prototype.packBatches = function() {
    this.batchDirty++, this.uvsFloat32 = new Float32Array(this.uvs);
    for (var e = this.batches, o = 0, R = e.length; o < R; o++)
      for (var N = e[o], M = 0; M < N.size; M++) {
        var D = N.start + M;
        this.indicesUint16[D] = this.indicesUint16[D] - N.attribStart;
      }
  }, t.prototype.isBatchable = function() {
    if (this.points.length > 65535 * 2)
      return !1;
    for (var e = this.batches, o = 0; o < e.length; o++)
      if (e[o].style.native)
        return !1;
    return this.points.length < t.BATCHABLE_SIZE * 2;
  }, t.prototype.buildDrawCalls = function() {
    for (var e = ++BaseTexture._globalBatch, o = 0; o < this.drawCalls.length; o++)
      this.drawCalls[o].texArray.clear(), DRAW_CALL_POOL.push(this.drawCalls[o]);
    this.drawCalls.length = 0;
    var R = this.colors, N = this.textureIds, M = DRAW_CALL_POOL.pop();
    M || (M = new BatchDrawCall(), M.texArray = new BatchTextureArray()), M.texArray.count = 0, M.start = 0, M.size = 0, M.type = DRAW_MODES$5.TRIANGLES;
    var D = 0, L = null, B = 0, $ = !1, k = DRAW_MODES$5.TRIANGLES, U = 0;
    this.drawCalls.push(M);
    for (var o = 0; o < this.batches.length; o++) {
      var z = this.batches[o], X = 8, V = z.style, W = V.texture.baseTexture;
      $ !== !!V.native && ($ = !!V.native, k = $ ? DRAW_MODES$5.LINES : DRAW_MODES$5.TRIANGLES, L = null, D = X, e++), L !== W && (L = W, W._batchEnabled !== e && (D === X && (e++, D = 0, M.size > 0 && (M = DRAW_CALL_POOL.pop(), M || (M = new BatchDrawCall(), M.texArray = new BatchTextureArray()), this.drawCalls.push(M)), M.start = U, M.size = 0, M.texArray.count = 0, M.type = k), W.touched = 1, W._batchEnabled = e, W._batchLocation = D, W.wrapMode = WRAP_MODES$5.REPEAT, M.texArray.elements[M.texArray.count++] = W, D++)), M.size += z.size, U += z.size, B = W._batchLocation, this.addColors(R, V.color, V.alpha, z.attribSize, z.attribStart), this.addTextureIds(N, B, z.attribSize, z.attribStart);
    }
    BaseTexture._globalBatch = e, this.packAttributes();
  }, t.prototype.packAttributes = function() {
    for (var e = this.points, o = this.uvs, R = this.colors, N = this.textureIds, M = new ArrayBuffer(e.length * 3 * 4), D = new Float32Array(M), L = new Uint32Array(M), B = 0, $ = 0; $ < e.length / 2; $++)
      D[B++] = e[$ * 2], D[B++] = e[$ * 2 + 1], D[B++] = o[$ * 2], D[B++] = o[$ * 2 + 1], L[B++] = R[$], D[B++] = N[$];
    this._buffer.update(M), this._indexBuffer.update(this.indicesUint16);
  }, t.prototype.processFill = function(e) {
    if (e.holes.length)
      buildPoly.triangulate(e, this);
    else {
      var o = FILL_COMMANDS[e.type];
      o.triangulate(e, this);
    }
  }, t.prototype.processLine = function(e) {
    buildLine(e, this);
    for (var o = 0; o < e.holes.length; o++)
      buildLine(e.holes[o], this);
  }, t.prototype.processHoles = function(e) {
    for (var o = 0; o < e.length; o++) {
      var R = e[o], N = FILL_COMMANDS[R.type];
      N.build(R), R.matrix && this.transformPoints(R.points, R.matrix);
    }
  }, t.prototype.calculateBounds = function() {
    var e = this._bounds;
    e.clear(), e.addVertexData(this.points, 0, this.points.length), e.pad(this.boundsPadding, this.boundsPadding);
  }, t.prototype.transformPoints = function(e, o) {
    for (var R = 0; R < e.length / 2; R++) {
      var N = e[R * 2], M = e[R * 2 + 1];
      e[R * 2] = o.a * N + o.c * M + o.tx, e[R * 2 + 1] = o.b * N + o.d * M + o.ty;
    }
  }, t.prototype.addColors = function(e, o, R, N, M) {
    M === void 0 && (M = 0);
    var D = (o >> 16) + (o & 65280) + ((o & 255) << 16), L = premultiplyTint(D, R);
    e.length = Math.max(e.length, M + N);
    for (var B = 0; B < N; B++)
      e[M + B] = L;
  }, t.prototype.addTextureIds = function(e, o, R, N) {
    N === void 0 && (N = 0), e.length = Math.max(e.length, N + R);
    for (var M = 0; M < R; M++)
      e[N + M] = o;
  }, t.prototype.addUvs = function(e, o, R, N, M, D) {
    D === void 0 && (D = null);
    for (var L = 0, B = o.length, $ = R.frame; L < M; ) {
      var k = e[(N + L) * 2], U = e[(N + L) * 2 + 1];
      if (D) {
        var z = D.a * k + D.c * U + D.tx;
        U = D.b * k + D.d * U + D.ty, k = z;
      }
      L++, o.push(k / $.width, U / $.height);
    }
    var X = R.baseTexture;
    ($.width < X.width || $.height < X.height) && this.adjustUvs(o, R, B, M);
  }, t.prototype.adjustUvs = function(e, o, R, N) {
    for (var M = o.baseTexture, D = 1e-6, L = R + N * 2, B = o.frame, $ = B.width / M.width, k = B.height / M.height, U = B.x / B.width, z = B.y / B.height, X = Math.floor(e[R] + D), V = Math.floor(e[R + 1] + D), W = R + 2; W < L; W += 2)
      X = Math.min(X, Math.floor(e[W] + D)), V = Math.min(V, Math.floor(e[W + 1] + D));
    U -= X, z -= V;
    for (var W = R; W < L; W += 2)
      e[W] = (e[W] + U) * $, e[W + 1] = (e[W + 1] + z) * k;
  }, t.BATCHABLE_SIZE = 100, t;
}(BatchGeometry), LineStyle = function(n) {
  __extends$l(t, n);
  function t() {
    var e = n !== null && n.apply(this, arguments) || this;
    return e.width = 0, e.alignment = 0.5, e.native = !1, e.cap = LINE_CAP.BUTT, e.join = LINE_JOIN.MITER, e.miterLimit = 10, e;
  }
  return t.prototype.clone = function() {
    var e = new t();
    return e.color = this.color, e.alpha = this.alpha, e.texture = this.texture, e.matrix = this.matrix, e.visible = this.visible, e.width = this.width, e.alignment = this.alignment, e.native = this.native, e.cap = this.cap, e.join = this.join, e.miterLimit = this.miterLimit, e;
  }, t.prototype.reset = function() {
    n.prototype.reset.call(this), this.color = 0, this.alignment = 0.5, this.width = 0, this.native = !1;
  }, t;
}(FillStyle), temp = new Float32Array(3), DEFAULT_SHADERS = {}, Graphics = function(n) {
  __extends$l(t, n);
  function t(e) {
    e === void 0 && (e = null);
    var o = n.call(this) || this;
    return o.shader = null, o.pluginName = "batch", o.currentPath = null, o.batches = [], o.batchTint = -1, o.batchDirty = -1, o.vertexData = null, o._fillStyle = new FillStyle(), o._lineStyle = new LineStyle(), o._matrix = null, o._holeMode = !1, o.state = State.for2d(), o._geometry = e || new GraphicsGeometry(), o._geometry.refCount++, o._transformID = -1, o.tint = 16777215, o.blendMode = BLEND_MODES$5.NORMAL, o;
  }
  return Object.defineProperty(t.prototype, "geometry", {
    get: function() {
      return this._geometry;
    },
    enumerable: !1,
    configurable: !0
  }), t.prototype.clone = function() {
    return this.finishPoly(), new t(this._geometry);
  }, Object.defineProperty(t.prototype, "blendMode", {
    get: function() {
      return this.state.blendMode;
    },
    set: function(e) {
      this.state.blendMode = e;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(t.prototype, "tint", {
    get: function() {
      return this._tint;
    },
    set: function(e) {
      this._tint = e;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(t.prototype, "fill", {
    get: function() {
      return this._fillStyle;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(t.prototype, "line", {
    get: function() {
      return this._lineStyle;
    },
    enumerable: !1,
    configurable: !0
  }), t.prototype.lineStyle = function(e, o, R, N, M) {
    return e === void 0 && (e = null), o === void 0 && (o = 0), R === void 0 && (R = 1), N === void 0 && (N = 0.5), M === void 0 && (M = !1), typeof e == "number" && (e = { width: e, color: o, alpha: R, alignment: N, native: M }), this.lineTextureStyle(e);
  }, t.prototype.lineTextureStyle = function(e) {
    e = Object.assign({
      width: 0,
      texture: Texture.WHITE,
      color: e && e.texture ? 16777215 : 0,
      alpha: 1,
      matrix: null,
      alignment: 0.5,
      native: !1,
      cap: LINE_CAP.BUTT,
      join: LINE_JOIN.MITER,
      miterLimit: 10
    }, e), this.currentPath && this.startPoly();
    var o = e.width > 0 && e.alpha > 0;
    return o ? (e.matrix && (e.matrix = e.matrix.clone(), e.matrix.invert()), Object.assign(this._lineStyle, { visible: o }, e)) : this._lineStyle.reset(), this;
  }, t.prototype.startPoly = function() {
    if (this.currentPath) {
      var e = this.currentPath.points, o = this.currentPath.points.length;
      o > 2 && (this.drawShape(this.currentPath), this.currentPath = new Polygon(), this.currentPath.closeStroke = !1, this.currentPath.points.push(e[o - 2], e[o - 1]));
    } else
      this.currentPath = new Polygon(), this.currentPath.closeStroke = !1;
  }, t.prototype.finishPoly = function() {
    this.currentPath && (this.currentPath.points.length > 2 ? (this.drawShape(this.currentPath), this.currentPath = null) : this.currentPath.points.length = 0);
  }, t.prototype.moveTo = function(e, o) {
    return this.startPoly(), this.currentPath.points[0] = e, this.currentPath.points[1] = o, this;
  }, t.prototype.lineTo = function(e, o) {
    this.currentPath || this.moveTo(0, 0);
    var R = this.currentPath.points, N = R[R.length - 2], M = R[R.length - 1];
    return (N !== e || M !== o) && R.push(e, o), this;
  }, t.prototype._initCurve = function(e, o) {
    e === void 0 && (e = 0), o === void 0 && (o = 0), this.currentPath ? this.currentPath.points.length === 0 && (this.currentPath.points = [e, o]) : this.moveTo(e, o);
  }, t.prototype.quadraticCurveTo = function(e, o, R, N) {
    this._initCurve();
    var M = this.currentPath.points;
    return M.length === 0 && this.moveTo(0, 0), QuadraticUtils.curveTo(e, o, R, N, M), this;
  }, t.prototype.bezierCurveTo = function(e, o, R, N, M, D) {
    return this._initCurve(), BezierUtils.curveTo(e, o, R, N, M, D, this.currentPath.points), this;
  }, t.prototype.arcTo = function(e, o, R, N, M) {
    this._initCurve(e, o);
    var D = this.currentPath.points, L = ArcUtils.curveTo(e, o, R, N, M, D);
    if (L) {
      var B = L.cx, $ = L.cy, k = L.radius, U = L.startAngle, z = L.endAngle, X = L.anticlockwise;
      this.arc(B, $, k, U, z, X);
    }
    return this;
  }, t.prototype.arc = function(e, o, R, N, M, D) {
    if (D === void 0 && (D = !1), N === M)
      return this;
    !D && M <= N ? M += PI_2 : D && N <= M && (N += PI_2);
    var L = M - N;
    if (L === 0)
      return this;
    var B = e + Math.cos(N) * R, $ = o + Math.sin(N) * R, k = this._geometry.closePointEps, U = this.currentPath ? this.currentPath.points : null;
    if (U) {
      var z = Math.abs(U[U.length - 2] - B), X = Math.abs(U[U.length - 1] - $);
      z < k && X < k || U.push(B, $);
    } else
      this.moveTo(B, $), U = this.currentPath.points;
    return ArcUtils.arc(B, $, e, o, R, N, M, D, U), this;
  }, t.prototype.beginFill = function(e, o) {
    return e === void 0 && (e = 0), o === void 0 && (o = 1), this.beginTextureFill({ texture: Texture.WHITE, color: e, alpha: o });
  }, t.prototype.beginTextureFill = function(e) {
    e = Object.assign({
      texture: Texture.WHITE,
      color: 16777215,
      alpha: 1,
      matrix: null
    }, e), this.currentPath && this.startPoly();
    var o = e.alpha > 0;
    return o ? (e.matrix && (e.matrix = e.matrix.clone(), e.matrix.invert()), Object.assign(this._fillStyle, { visible: o }, e)) : this._fillStyle.reset(), this;
  }, t.prototype.endFill = function() {
    return this.finishPoly(), this._fillStyle.reset(), this;
  }, t.prototype.drawRect = function(e, o, R, N) {
    return this.drawShape(new Rectangle(e, o, R, N));
  }, t.prototype.drawRoundedRect = function(e, o, R, N, M) {
    return this.drawShape(new RoundedRectangle(e, o, R, N, M));
  }, t.prototype.drawCircle = function(e, o, R) {
    return this.drawShape(new Circle(e, o, R));
  }, t.prototype.drawEllipse = function(e, o, R, N) {
    return this.drawShape(new Ellipse(e, o, R, N));
  }, t.prototype.drawPolygon = function() {
    for (var e = arguments, o = [], R = 0; R < arguments.length; R++)
      o[R] = e[R];
    var N, M = !0, D = o[0];
    D.points ? (M = D.closeStroke, N = D.points) : Array.isArray(o[0]) ? N = o[0] : N = o;
    var L = new Polygon(N);
    return L.closeStroke = M, this.drawShape(L), this;
  }, t.prototype.drawShape = function(e) {
    return this._holeMode ? this._geometry.drawHole(e, this._matrix) : this._geometry.drawShape(e, this._fillStyle.clone(), this._lineStyle.clone(), this._matrix), this;
  }, t.prototype.clear = function() {
    return this._geometry.clear(), this._lineStyle.reset(), this._fillStyle.reset(), this._boundsID++, this._matrix = null, this._holeMode = !1, this.currentPath = null, this;
  }, t.prototype.isFastRect = function() {
    var e = this._geometry.graphicsData;
    return e.length === 1 && e[0].shape.type === SHAPES.RECT && !e[0].matrix && !e[0].holes.length && !(e[0].lineStyle.visible && e[0].lineStyle.width);
  }, t.prototype._render = function(e) {
    this.finishPoly();
    var o = this._geometry;
    o.updateBatches(), o.batchable ? (this.batchDirty !== o.batchDirty && this._populateBatches(), this._renderBatched(e)) : (e.batch.flush(), this._renderDirect(e));
  }, t.prototype._populateBatches = function() {
    var e = this._geometry, o = this.blendMode, R = e.batches.length;
    this.batchTint = -1, this._transformID = -1, this.batchDirty = e.batchDirty, this.batches.length = R, this.vertexData = new Float32Array(e.points);
    for (var N = 0; N < R; N++) {
      var M = e.batches[N], D = M.style.color, L = new Float32Array(this.vertexData.buffer, M.attribStart * 4 * 2, M.attribSize * 2), B = new Float32Array(e.uvsFloat32.buffer, M.attribStart * 4 * 2, M.attribSize * 2), $ = new Uint16Array(e.indicesUint16.buffer, M.start * 2, M.size), k = {
        vertexData: L,
        blendMode: o,
        indices: $,
        uvs: B,
        _batchRGB: hex2rgb(D),
        _tintRGB: D,
        _texture: M.style.texture,
        alpha: M.style.alpha,
        worldAlpha: 1
      };
      this.batches[N] = k;
    }
  }, t.prototype._renderBatched = function(e) {
    if (!!this.batches.length) {
      e.batch.setObjectRenderer(e.plugins[this.pluginName]), this.calculateVertices(), this.calculateTints();
      for (var o = 0, R = this.batches.length; o < R; o++) {
        var N = this.batches[o];
        N.worldAlpha = this.worldAlpha * N.alpha, e.plugins[this.pluginName].render(N);
      }
    }
  }, t.prototype._renderDirect = function(e) {
    var o = this._resolveDirectShader(e), R = this._geometry, N = this.tint, M = this.worldAlpha, D = o.uniforms, L = R.drawCalls;
    D.translationMatrix = this.transform.worldTransform, D.tint[0] = (N >> 16 & 255) / 255 * M, D.tint[1] = (N >> 8 & 255) / 255 * M, D.tint[2] = (N & 255) / 255 * M, D.tint[3] = M, e.shader.bind(o), e.geometry.bind(R, o), e.state.set(this.state);
    for (var B = 0, $ = L.length; B < $; B++)
      this._renderDrawCallDirect(e, R.drawCalls[B]);
  }, t.prototype._renderDrawCallDirect = function(e, o) {
    for (var R = o.texArray, N = o.type, M = o.size, D = o.start, L = R.count, B = 0; B < L; B++)
      e.texture.bind(R.elements[B], B);
    e.geometry.draw(N, M, D);
  }, t.prototype._resolveDirectShader = function(e) {
    var o = this.shader, R = this.pluginName;
    if (!o) {
      if (!DEFAULT_SHADERS[R]) {
        for (var N = e.plugins[R].MAX_TEXTURES, M = new Int32Array(N), D = 0; D < N; D++)
          M[D] = D;
        var L = {
          tint: new Float32Array([1, 1, 1, 1]),
          translationMatrix: new Matrix(),
          default: UniformGroup.from({ uSamplers: M }, !0)
        }, B = e.plugins[R]._shader.program;
        DEFAULT_SHADERS[R] = new Shader(B, L);
      }
      o = DEFAULT_SHADERS[R];
    }
    return o;
  }, t.prototype._calculateBounds = function() {
    this.finishPoly();
    var e = this._geometry;
    if (!!e.graphicsData.length) {
      var o = e.bounds, R = o.minX, N = o.minY, M = o.maxX, D = o.maxY;
      this._bounds.addFrame(this.transform, R, N, M, D);
    }
  }, t.prototype.containsPoint = function(e) {
    return this.worldTransform.applyInverse(e, t._TEMP_POINT), this._geometry.containsPoint(t._TEMP_POINT);
  }, t.prototype.calculateTints = function() {
    if (this.batchTint !== this.tint) {
      this.batchTint = this.tint;
      for (var e = hex2rgb(this.tint, temp), o = 0; o < this.batches.length; o++) {
        var R = this.batches[o], N = R._batchRGB, M = e[0] * N[0] * 255, D = e[1] * N[1] * 255, L = e[2] * N[2] * 255, B = (M << 16) + (D << 8) + (L | 0);
        R._tintRGB = (B >> 16) + (B & 65280) + ((B & 255) << 16);
      }
    }
  }, t.prototype.calculateVertices = function() {
    var e = this.transform._worldID;
    if (this._transformID !== e) {
      this._transformID = e;
      for (var o = this.transform.worldTransform, R = o.a, N = o.b, M = o.c, D = o.d, L = o.tx, B = o.ty, $ = this._geometry.points, k = this.vertexData, U = 0, z = 0; z < $.length; z += 2) {
        var X = $[z], V = $[z + 1];
        k[U++] = R * X + M * V + L, k[U++] = D * V + N * X + B;
      }
    }
  }, t.prototype.closePath = function() {
    var e = this.currentPath;
    return e && (e.closeStroke = !0, this.finishPoly()), this;
  }, t.prototype.setMatrix = function(e) {
    return this._matrix = e, this;
  }, t.prototype.beginHole = function() {
    return this.finishPoly(), this._holeMode = !0, this;
  }, t.prototype.endHole = function() {
    return this.finishPoly(), this._holeMode = !1, this;
  }, t.prototype.destroy = function(e) {
    this._geometry.refCount--, this._geometry.refCount === 0 && this._geometry.dispose(), this._matrix = null, this.currentPath = null, this._lineStyle.destroy(), this._lineStyle = null, this._fillStyle.destroy(), this._fillStyle = null, this._geometry = null, this.shader = null, this.vertexData = null, this.batches.length = 0, this.batches = null, n.prototype.destroy.call(this, e);
  }, t.nextRoundedRectBehavior = !1, t._TEMP_POINT = new Point(), t;
}(Container);
/*!
 * @pixi/sprite - v6.5.2
 * Compiled Wed, 24 Aug 2022 13:51:19 UTC
 *
 * @pixi/sprite is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var extendStatics$k = function(n, t) {
  return extendStatics$k = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(e, o) {
    e.__proto__ = o;
  } || function(e, o) {
    for (var R in o)
      o.hasOwnProperty(R) && (e[R] = o[R]);
  }, extendStatics$k(n, t);
};
function __extends$k(n, t) {
  extendStatics$k(n, t);
  function e() {
    this.constructor = n;
  }
  n.prototype = t === null ? Object.create(t) : (e.prototype = t.prototype, new e());
}
var tempPoint$2 = new Point(), indices = new Uint16Array([0, 1, 2, 0, 2, 3]), Sprite = function(n) {
  __extends$k(t, n);
  function t(e) {
    var o = n.call(this) || this;
    return o._anchor = new ObservablePoint(o._onAnchorUpdate, o, e ? e.defaultAnchor.x : 0, e ? e.defaultAnchor.y : 0), o._texture = null, o._width = 0, o._height = 0, o._tint = null, o._tintRGB = null, o.tint = 16777215, o.blendMode = BLEND_MODES$5.NORMAL, o._cachedTint = 16777215, o.uvs = null, o.texture = e || Texture.EMPTY, o.vertexData = new Float32Array(8), o.vertexTrimmedData = null, o._transformID = -1, o._textureID = -1, o._transformTrimmedID = -1, o._textureTrimmedID = -1, o.indices = indices, o.pluginName = "batch", o.isSprite = !0, o._roundPixels = settings$1.ROUND_PIXELS, o;
  }
  return t.prototype._onTextureUpdate = function() {
    this._textureID = -1, this._textureTrimmedID = -1, this._cachedTint = 16777215, this._width && (this.scale.x = sign(this.scale.x) * this._width / this._texture.orig.width), this._height && (this.scale.y = sign(this.scale.y) * this._height / this._texture.orig.height);
  }, t.prototype._onAnchorUpdate = function() {
    this._transformID = -1, this._transformTrimmedID = -1;
  }, t.prototype.calculateVertices = function() {
    var e = this._texture;
    if (!(this._transformID === this.transform._worldID && this._textureID === e._updateID)) {
      this._textureID !== e._updateID && (this.uvs = this._texture._uvs.uvsFloat32), this._transformID = this.transform._worldID, this._textureID = e._updateID;
      var o = this.transform.worldTransform, R = o.a, N = o.b, M = o.c, D = o.d, L = o.tx, B = o.ty, $ = this.vertexData, k = e.trim, U = e.orig, z = this._anchor, X = 0, V = 0, W = 0, Y = 0;
      if (k ? (V = k.x - z._x * U.width, X = V + k.width, Y = k.y - z._y * U.height, W = Y + k.height) : (V = -z._x * U.width, X = V + U.width, Y = -z._y * U.height, W = Y + U.height), $[0] = R * V + M * Y + L, $[1] = D * Y + N * V + B, $[2] = R * X + M * Y + L, $[3] = D * Y + N * X + B, $[4] = R * X + M * W + L, $[5] = D * W + N * X + B, $[6] = R * V + M * W + L, $[7] = D * W + N * V + B, this._roundPixels)
        for (var q = settings$1.RESOLUTION, Z = 0; Z < $.length; ++Z)
          $[Z] = Math.round(($[Z] * q | 0) / q);
    }
  }, t.prototype.calculateTrimmedVertices = function() {
    if (!this.vertexTrimmedData)
      this.vertexTrimmedData = new Float32Array(8);
    else if (this._transformTrimmedID === this.transform._worldID && this._textureTrimmedID === this._texture._updateID)
      return;
    this._transformTrimmedID = this.transform._worldID, this._textureTrimmedID = this._texture._updateID;
    var e = this._texture, o = this.vertexTrimmedData, R = e.orig, N = this._anchor, M = this.transform.worldTransform, D = M.a, L = M.b, B = M.c, $ = M.d, k = M.tx, U = M.ty, z = -N._x * R.width, X = z + R.width, V = -N._y * R.height, W = V + R.height;
    o[0] = D * z + B * V + k, o[1] = $ * V + L * z + U, o[2] = D * X + B * V + k, o[3] = $ * V + L * X + U, o[4] = D * X + B * W + k, o[5] = $ * W + L * X + U, o[6] = D * z + B * W + k, o[7] = $ * W + L * z + U;
  }, t.prototype._render = function(e) {
    this.calculateVertices(), e.batch.setObjectRenderer(e.plugins[this.pluginName]), e.plugins[this.pluginName].render(this);
  }, t.prototype._calculateBounds = function() {
    var e = this._texture.trim, o = this._texture.orig;
    !e || e.width === o.width && e.height === o.height ? (this.calculateVertices(), this._bounds.addQuad(this.vertexData)) : (this.calculateTrimmedVertices(), this._bounds.addQuad(this.vertexTrimmedData));
  }, t.prototype.getLocalBounds = function(e) {
    return this.children.length === 0 ? (this._localBounds || (this._localBounds = new Bounds()), this._localBounds.minX = this._texture.orig.width * -this._anchor._x, this._localBounds.minY = this._texture.orig.height * -this._anchor._y, this._localBounds.maxX = this._texture.orig.width * (1 - this._anchor._x), this._localBounds.maxY = this._texture.orig.height * (1 - this._anchor._y), e || (this._localBoundsRect || (this._localBoundsRect = new Rectangle()), e = this._localBoundsRect), this._localBounds.getRectangle(e)) : n.prototype.getLocalBounds.call(this, e);
  }, t.prototype.containsPoint = function(e) {
    this.worldTransform.applyInverse(e, tempPoint$2);
    var o = this._texture.orig.width, R = this._texture.orig.height, N = -o * this.anchor.x, M = 0;
    return tempPoint$2.x >= N && tempPoint$2.x < N + o && (M = -R * this.anchor.y, tempPoint$2.y >= M && tempPoint$2.y < M + R);
  }, t.prototype.destroy = function(e) {
    n.prototype.destroy.call(this, e), this._texture.off("update", this._onTextureUpdate, this), this._anchor = null;
    var o = typeof e == "boolean" ? e : e && e.texture;
    if (o) {
      var R = typeof e == "boolean" ? e : e && e.baseTexture;
      this._texture.destroy(!!R);
    }
    this._texture = null;
  }, t.from = function(e, o) {
    var R = e instanceof Texture ? e : Texture.from(e, o);
    return new t(R);
  }, Object.defineProperty(t.prototype, "roundPixels", {
    get: function() {
      return this._roundPixels;
    },
    set: function(e) {
      this._roundPixels !== e && (this._transformID = -1), this._roundPixels = e;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(t.prototype, "width", {
    get: function() {
      return Math.abs(this.scale.x) * this._texture.orig.width;
    },
    set: function(e) {
      var o = sign(this.scale.x) || 1;
      this.scale.x = o * e / this._texture.orig.width, this._width = e;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(t.prototype, "height", {
    get: function() {
      return Math.abs(this.scale.y) * this._texture.orig.height;
    },
    set: function(e) {
      var o = sign(this.scale.y) || 1;
      this.scale.y = o * e / this._texture.orig.height, this._height = e;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(t.prototype, "anchor", {
    get: function() {
      return this._anchor;
    },
    set: function(e) {
      this._anchor.copyFrom(e);
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(t.prototype, "tint", {
    get: function() {
      return this._tint;
    },
    set: function(e) {
      this._tint = e, this._tintRGB = (e >> 16) + (e & 65280) + ((e & 255) << 16);
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(t.prototype, "texture", {
    get: function() {
      return this._texture;
    },
    set: function(e) {
      this._texture !== e && (this._texture && this._texture.off("update", this._onTextureUpdate, this), this._texture = e || Texture.EMPTY, this._cachedTint = 16777215, this._textureID = -1, this._textureTrimmedID = -1, e && (e.baseTexture.valid ? this._onTextureUpdate() : e.once("update", this._onTextureUpdate, this)));
    },
    enumerable: !1,
    configurable: !0
  }), t;
}(Container);
/*!
 * @pixi/text - v6.5.2
 * Compiled Wed, 24 Aug 2022 13:51:19 UTC
 *
 * @pixi/text is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var extendStatics$j = function(n, t) {
  return extendStatics$j = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(e, o) {
    e.__proto__ = o;
  } || function(e, o) {
    for (var R in o)
      o.hasOwnProperty(R) && (e[R] = o[R]);
  }, extendStatics$j(n, t);
};
function __extends$j(n, t) {
  extendStatics$j(n, t);
  function e() {
    this.constructor = n;
  }
  n.prototype = t === null ? Object.create(t) : (e.prototype = t.prototype, new e());
}
var TEXT_GRADIENT;
(function(n) {
  n[n.LINEAR_VERTICAL = 0] = "LINEAR_VERTICAL", n[n.LINEAR_HORIZONTAL = 1] = "LINEAR_HORIZONTAL";
})(TEXT_GRADIENT || (TEXT_GRADIENT = {}));
var defaultStyle = {
  align: "left",
  breakWords: !1,
  dropShadow: !1,
  dropShadowAlpha: 1,
  dropShadowAngle: Math.PI / 6,
  dropShadowBlur: 0,
  dropShadowColor: "black",
  dropShadowDistance: 5,
  fill: "black",
  fillGradientType: TEXT_GRADIENT.LINEAR_VERTICAL,
  fillGradientStops: [],
  fontFamily: "Arial",
  fontSize: 26,
  fontStyle: "normal",
  fontVariant: "normal",
  fontWeight: "normal",
  letterSpacing: 0,
  lineHeight: 0,
  lineJoin: "miter",
  miterLimit: 10,
  padding: 0,
  stroke: "black",
  strokeThickness: 0,
  textBaseline: "alphabetic",
  trim: !1,
  whiteSpace: "pre",
  wordWrap: !1,
  wordWrapWidth: 100,
  leading: 0
}, genericFontFamilies = [
  "serif",
  "sans-serif",
  "monospace",
  "cursive",
  "fantasy",
  "system-ui"
], TextStyle = function() {
  function n(t) {
    this.styleID = 0, this.reset(), deepCopyProperties(this, t, t);
  }
  return n.prototype.clone = function() {
    var t = {};
    return deepCopyProperties(t, this, defaultStyle), new n(t);
  }, n.prototype.reset = function() {
    deepCopyProperties(this, defaultStyle, defaultStyle);
  }, Object.defineProperty(n.prototype, "align", {
    get: function() {
      return this._align;
    },
    set: function(t) {
      this._align !== t && (this._align = t, this.styleID++);
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(n.prototype, "breakWords", {
    get: function() {
      return this._breakWords;
    },
    set: function(t) {
      this._breakWords !== t && (this._breakWords = t, this.styleID++);
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(n.prototype, "dropShadow", {
    get: function() {
      return this._dropShadow;
    },
    set: function(t) {
      this._dropShadow !== t && (this._dropShadow = t, this.styleID++);
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(n.prototype, "dropShadowAlpha", {
    get: function() {
      return this._dropShadowAlpha;
    },
    set: function(t) {
      this._dropShadowAlpha !== t && (this._dropShadowAlpha = t, this.styleID++);
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(n.prototype, "dropShadowAngle", {
    get: function() {
      return this._dropShadowAngle;
    },
    set: function(t) {
      this._dropShadowAngle !== t && (this._dropShadowAngle = t, this.styleID++);
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(n.prototype, "dropShadowBlur", {
    get: function() {
      return this._dropShadowBlur;
    },
    set: function(t) {
      this._dropShadowBlur !== t && (this._dropShadowBlur = t, this.styleID++);
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(n.prototype, "dropShadowColor", {
    get: function() {
      return this._dropShadowColor;
    },
    set: function(t) {
      var e = getColor(t);
      this._dropShadowColor !== e && (this._dropShadowColor = e, this.styleID++);
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(n.prototype, "dropShadowDistance", {
    get: function() {
      return this._dropShadowDistance;
    },
    set: function(t) {
      this._dropShadowDistance !== t && (this._dropShadowDistance = t, this.styleID++);
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(n.prototype, "fill", {
    get: function() {
      return this._fill;
    },
    set: function(t) {
      var e = getColor(t);
      this._fill !== e && (this._fill = e, this.styleID++);
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(n.prototype, "fillGradientType", {
    get: function() {
      return this._fillGradientType;
    },
    set: function(t) {
      this._fillGradientType !== t && (this._fillGradientType = t, this.styleID++);
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(n.prototype, "fillGradientStops", {
    get: function() {
      return this._fillGradientStops;
    },
    set: function(t) {
      areArraysEqual(this._fillGradientStops, t) || (this._fillGradientStops = t, this.styleID++);
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(n.prototype, "fontFamily", {
    get: function() {
      return this._fontFamily;
    },
    set: function(t) {
      this.fontFamily !== t && (this._fontFamily = t, this.styleID++);
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(n.prototype, "fontSize", {
    get: function() {
      return this._fontSize;
    },
    set: function(t) {
      this._fontSize !== t && (this._fontSize = t, this.styleID++);
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(n.prototype, "fontStyle", {
    get: function() {
      return this._fontStyle;
    },
    set: function(t) {
      this._fontStyle !== t && (this._fontStyle = t, this.styleID++);
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(n.prototype, "fontVariant", {
    get: function() {
      return this._fontVariant;
    },
    set: function(t) {
      this._fontVariant !== t && (this._fontVariant = t, this.styleID++);
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(n.prototype, "fontWeight", {
    get: function() {
      return this._fontWeight;
    },
    set: function(t) {
      this._fontWeight !== t && (this._fontWeight = t, this.styleID++);
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(n.prototype, "letterSpacing", {
    get: function() {
      return this._letterSpacing;
    },
    set: function(t) {
      this._letterSpacing !== t && (this._letterSpacing = t, this.styleID++);
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(n.prototype, "lineHeight", {
    get: function() {
      return this._lineHeight;
    },
    set: function(t) {
      this._lineHeight !== t && (this._lineHeight = t, this.styleID++);
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(n.prototype, "leading", {
    get: function() {
      return this._leading;
    },
    set: function(t) {
      this._leading !== t && (this._leading = t, this.styleID++);
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(n.prototype, "lineJoin", {
    get: function() {
      return this._lineJoin;
    },
    set: function(t) {
      this._lineJoin !== t && (this._lineJoin = t, this.styleID++);
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(n.prototype, "miterLimit", {
    get: function() {
      return this._miterLimit;
    },
    set: function(t) {
      this._miterLimit !== t && (this._miterLimit = t, this.styleID++);
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(n.prototype, "padding", {
    get: function() {
      return this._padding;
    },
    set: function(t) {
      this._padding !== t && (this._padding = t, this.styleID++);
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(n.prototype, "stroke", {
    get: function() {
      return this._stroke;
    },
    set: function(t) {
      var e = getColor(t);
      this._stroke !== e && (this._stroke = e, this.styleID++);
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(n.prototype, "strokeThickness", {
    get: function() {
      return this._strokeThickness;
    },
    set: function(t) {
      this._strokeThickness !== t && (this._strokeThickness = t, this.styleID++);
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(n.prototype, "textBaseline", {
    get: function() {
      return this._textBaseline;
    },
    set: function(t) {
      this._textBaseline !== t && (this._textBaseline = t, this.styleID++);
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(n.prototype, "trim", {
    get: function() {
      return this._trim;
    },
    set: function(t) {
      this._trim !== t && (this._trim = t, this.styleID++);
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(n.prototype, "whiteSpace", {
    get: function() {
      return this._whiteSpace;
    },
    set: function(t) {
      this._whiteSpace !== t && (this._whiteSpace = t, this.styleID++);
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(n.prototype, "wordWrap", {
    get: function() {
      return this._wordWrap;
    },
    set: function(t) {
      this._wordWrap !== t && (this._wordWrap = t, this.styleID++);
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(n.prototype, "wordWrapWidth", {
    get: function() {
      return this._wordWrapWidth;
    },
    set: function(t) {
      this._wordWrapWidth !== t && (this._wordWrapWidth = t, this.styleID++);
    },
    enumerable: !1,
    configurable: !0
  }), n.prototype.toFontString = function() {
    var t = typeof this.fontSize == "number" ? this.fontSize + "px" : this.fontSize, e = this.fontFamily;
    Array.isArray(this.fontFamily) || (e = this.fontFamily.split(","));
    for (var o = e.length - 1; o >= 0; o--) {
      var R = e[o].trim();
      !/([\"\'])[^\'\"]+\1/.test(R) && genericFontFamilies.indexOf(R) < 0 && (R = '"' + R + '"'), e[o] = R;
    }
    return this.fontStyle + " " + this.fontVariant + " " + this.fontWeight + " " + t + " " + e.join(",");
  }, n;
}();
function getSingleColor(n) {
  return typeof n == "number" ? hex2string(n) : (typeof n == "string" && n.indexOf("0x") === 0 && (n = n.replace("0x", "#")), n);
}
function getColor(n) {
  if (Array.isArray(n)) {
    for (var t = 0; t < n.length; ++t)
      n[t] = getSingleColor(n[t]);
    return n;
  } else
    return getSingleColor(n);
}
function areArraysEqual(n, t) {
  if (!Array.isArray(n) || !Array.isArray(t) || n.length !== t.length)
    return !1;
  for (var e = 0; e < n.length; ++e)
    if (n[e] !== t[e])
      return !1;
  return !0;
}
function deepCopyProperties(n, t, e) {
  for (var o in e)
    Array.isArray(t[o]) ? n[o] = t[o].slice() : n[o] = t[o];
}
var TextMetrics = function() {
  function n(t, e, o, R, N, M, D, L, B) {
    this.text = t, this.style = e, this.width = o, this.height = R, this.lines = N, this.lineWidths = M, this.lineHeight = D, this.maxLineWidth = L, this.fontProperties = B;
  }
  return n.measureText = function(t, e, o, R) {
    R === void 0 && (R = n._canvas), o = o == null ? e.wordWrap : o;
    var N = e.toFontString(), M = n.measureFont(N);
    M.fontSize === 0 && (M.fontSize = e.fontSize, M.ascent = e.fontSize);
    var D = R.getContext("2d");
    D.font = N;
    for (var L = o ? n.wordWrap(t, e, R) : t, B = L.split(/(?:\r\n|\r|\n)/), $ = new Array(B.length), k = 0, U = 0; U < B.length; U++) {
      var z = D.measureText(B[U]).width + (B[U].length - 1) * e.letterSpacing;
      $[U] = z, k = Math.max(k, z);
    }
    var X = k + e.strokeThickness;
    e.dropShadow && (X += e.dropShadowDistance);
    var V = e.lineHeight || M.fontSize + e.strokeThickness, W = Math.max(V, M.fontSize + e.strokeThickness) + (B.length - 1) * (V + e.leading);
    return e.dropShadow && (W += e.dropShadowDistance), new n(t, e, X, W, B, $, V + e.leading, k, M);
  }, n.wordWrap = function(t, e, o) {
    o === void 0 && (o = n._canvas);
    for (var R = o.getContext("2d"), N = 0, M = "", D = "", L = /* @__PURE__ */ Object.create(null), B = e.letterSpacing, $ = e.whiteSpace, k = n.collapseSpaces($), U = n.collapseNewlines($), z = !k, X = e.wordWrapWidth + B, V = n.tokenize(t), W = 0; W < V.length; W++) {
      var Y = V[W];
      if (n.isNewline(Y)) {
        if (!U) {
          D += n.addLine(M), z = !k, M = "", N = 0;
          continue;
        }
        Y = " ";
      }
      if (k) {
        var q = n.isBreakingSpace(Y), Z = n.isBreakingSpace(M[M.length - 1]);
        if (q && Z)
          continue;
      }
      var J = n.getFromCache(Y, B, L, R);
      if (J > X)
        if (M !== "" && (D += n.addLine(M), M = "", N = 0), n.canBreakWords(Y, e.breakWords))
          for (var Q = n.wordWrapSplit(Y), K = 0; K < Q.length; K++) {
            for (var rt = Q[K], tt = 1; Q[K + tt]; ) {
              var nt = Q[K + tt], at = rt[rt.length - 1];
              if (!n.canBreakChars(at, nt, Y, K, e.breakWords))
                rt += nt;
              else
                break;
              tt++;
            }
            K += rt.length - 1;
            var lt = n.getFromCache(rt, B, L, R);
            lt + N > X && (D += n.addLine(M), z = !1, M = "", N = 0), M += rt, N += lt;
          }
        else {
          M.length > 0 && (D += n.addLine(M), M = "", N = 0);
          var ut = W === V.length - 1;
          D += n.addLine(Y, !ut), z = !1, M = "", N = 0;
        }
      else
        J + N > X && (z = !1, D += n.addLine(M), M = "", N = 0), (M.length > 0 || !n.isBreakingSpace(Y) || z) && (M += Y, N += J);
    }
    return D += n.addLine(M, !1), D;
  }, n.addLine = function(t, e) {
    return e === void 0 && (e = !0), t = n.trimRight(t), t = e ? t + `
` : t, t;
  }, n.getFromCache = function(t, e, o, R) {
    var N = o[t];
    if (typeof N != "number") {
      var M = t.length * e;
      N = R.measureText(t).width + M, o[t] = N;
    }
    return N;
  }, n.collapseSpaces = function(t) {
    return t === "normal" || t === "pre-line";
  }, n.collapseNewlines = function(t) {
    return t === "normal";
  }, n.trimRight = function(t) {
    if (typeof t != "string")
      return "";
    for (var e = t.length - 1; e >= 0; e--) {
      var o = t[e];
      if (!n.isBreakingSpace(o))
        break;
      t = t.slice(0, -1);
    }
    return t;
  }, n.isNewline = function(t) {
    return typeof t != "string" ? !1 : n._newlines.indexOf(t.charCodeAt(0)) >= 0;
  }, n.isBreakingSpace = function(t, e) {
    return typeof t != "string" ? !1 : n._breakingSpaces.indexOf(t.charCodeAt(0)) >= 0;
  }, n.tokenize = function(t) {
    var e = [], o = "";
    if (typeof t != "string")
      return e;
    for (var R = 0; R < t.length; R++) {
      var N = t[R], M = t[R + 1];
      if (n.isBreakingSpace(N, M) || n.isNewline(N)) {
        o !== "" && (e.push(o), o = ""), e.push(N);
        continue;
      }
      o += N;
    }
    return o !== "" && e.push(o), e;
  }, n.canBreakWords = function(t, e) {
    return e;
  }, n.canBreakChars = function(t, e, o, R, N) {
    return !0;
  }, n.wordWrapSplit = function(t) {
    return t.split("");
  }, n.measureFont = function(t) {
    if (n._fonts[t])
      return n._fonts[t];
    var e = {
      ascent: 0,
      descent: 0,
      fontSize: 0
    }, o = n._canvas, R = n._context;
    R.font = t;
    var N = n.METRICS_STRING + n.BASELINE_SYMBOL, M = Math.ceil(R.measureText(N).width), D = Math.ceil(R.measureText(n.BASELINE_SYMBOL).width), L = Math.ceil(n.HEIGHT_MULTIPLIER * D);
    D = D * n.BASELINE_MULTIPLIER | 0, o.width = M, o.height = L, R.fillStyle = "#f00", R.fillRect(0, 0, M, L), R.font = t, R.textBaseline = "alphabetic", R.fillStyle = "#000", R.fillText(N, 0, D);
    var B = R.getImageData(0, 0, M, L).data, $ = B.length, k = M * 4, U = 0, z = 0, X = !1;
    for (U = 0; U < D; ++U) {
      for (var V = 0; V < k; V += 4)
        if (B[z + V] !== 255) {
          X = !0;
          break;
        }
      if (!X)
        z += k;
      else
        break;
    }
    for (e.ascent = D - U, z = $ - k, X = !1, U = L; U > D; --U) {
      for (var V = 0; V < k; V += 4)
        if (B[z + V] !== 255) {
          X = !0;
          break;
        }
      if (!X)
        z -= k;
      else
        break;
    }
    return e.descent = U - D, e.fontSize = e.ascent + e.descent, n._fonts[t] = e, e;
  }, n.clearMetrics = function(t) {
    t === void 0 && (t = ""), t ? delete n._fonts[t] : n._fonts = {};
  }, Object.defineProperty(n, "_canvas", {
    get: function() {
      if (!n.__canvas) {
        var t = void 0;
        try {
          var e = new OffscreenCanvas(0, 0), o = e.getContext("2d");
          if (o && o.measureText)
            return n.__canvas = e, e;
          t = settings$1.ADAPTER.createCanvas();
        } catch {
          t = settings$1.ADAPTER.createCanvas();
        }
        t.width = t.height = 10, n.__canvas = t;
      }
      return n.__canvas;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(n, "_context", {
    get: function() {
      return n.__context || (n.__context = n._canvas.getContext("2d")), n.__context;
    },
    enumerable: !1,
    configurable: !0
  }), n;
}();
TextMetrics._fonts = {};
TextMetrics.METRICS_STRING = "|\xC9q\xC5";
TextMetrics.BASELINE_SYMBOL = "M";
TextMetrics.BASELINE_MULTIPLIER = 1.4;
TextMetrics.HEIGHT_MULTIPLIER = 2;
TextMetrics._newlines = [
  10,
  13
];
TextMetrics._breakingSpaces = [
  9,
  32,
  8192,
  8193,
  8194,
  8195,
  8196,
  8197,
  8198,
  8200,
  8201,
  8202,
  8287,
  12288
];
var defaultDestroyOptions = {
  texture: !0,
  children: !1,
  baseTexture: !0
}, Text = function(n) {
  __extends$j(t, n);
  function t(e, o, R) {
    var N = this, M = !1;
    R || (R = settings$1.ADAPTER.createCanvas(), M = !0), R.width = 3, R.height = 3;
    var D = Texture.from(R);
    return D.orig = new Rectangle(), D.trim = new Rectangle(), N = n.call(this, D) || this, N._ownCanvas = M, N.canvas = R, N.context = R.getContext("2d"), N._resolution = settings$1.RESOLUTION, N._autoResolution = !0, N._text = null, N._style = null, N._styleListener = null, N._font = "", N.text = e, N.style = o, N.localStyleID = -1, N;
  }
  return t.prototype.updateText = function(e) {
    var o = this._style;
    if (this.localStyleID !== o.styleID && (this.dirty = !0, this.localStyleID = o.styleID), !(!this.dirty && e)) {
      this._font = this._style.toFontString();
      var R = this.context, N = TextMetrics.measureText(this._text || " ", this._style, this._style.wordWrap, this.canvas), M = N.width, D = N.height, L = N.lines, B = N.lineHeight, $ = N.lineWidths, k = N.maxLineWidth, U = N.fontProperties;
      this.canvas.width = Math.ceil(Math.ceil(Math.max(1, M) + o.padding * 2) * this._resolution), this.canvas.height = Math.ceil(Math.ceil(Math.max(1, D) + o.padding * 2) * this._resolution), R.scale(this._resolution, this._resolution), R.clearRect(0, 0, this.canvas.width, this.canvas.height), R.font = this._font, R.lineWidth = o.strokeThickness, R.textBaseline = o.textBaseline, R.lineJoin = o.lineJoin, R.miterLimit = o.miterLimit;
      for (var z, X, V = o.dropShadow ? 2 : 1, W = 0; W < V; ++W) {
        var Y = o.dropShadow && W === 0, q = Y ? Math.ceil(Math.max(1, D) + o.padding * 2) : 0, Z = q * this._resolution;
        if (Y) {
          R.fillStyle = "black", R.strokeStyle = "black";
          var J = o.dropShadowColor, Q = hex2rgb(typeof J == "number" ? J : string2hex(J)), K = o.dropShadowBlur * this._resolution, rt = o.dropShadowDistance * this._resolution;
          R.shadowColor = "rgba(" + Q[0] * 255 + "," + Q[1] * 255 + "," + Q[2] * 255 + "," + o.dropShadowAlpha + ")", R.shadowBlur = K, R.shadowOffsetX = Math.cos(o.dropShadowAngle) * rt, R.shadowOffsetY = Math.sin(o.dropShadowAngle) * rt + Z;
        } else
          R.fillStyle = this._generateFillStyle(o, L, N), R.strokeStyle = o.stroke, R.shadowColor = "black", R.shadowBlur = 0, R.shadowOffsetX = 0, R.shadowOffsetY = 0;
        var tt = (B - U.fontSize) / 2;
        (!t.nextLineHeightBehavior || B - U.fontSize < 0) && (tt = 0);
        for (var nt = 0; nt < L.length; nt++)
          z = o.strokeThickness / 2, X = o.strokeThickness / 2 + nt * B + U.ascent + tt, o.align === "right" ? z += k - $[nt] : o.align === "center" && (z += (k - $[nt]) / 2), o.stroke && o.strokeThickness && this.drawLetterSpacing(L[nt], z + o.padding, X + o.padding - q, !0), o.fill && this.drawLetterSpacing(L[nt], z + o.padding, X + o.padding - q);
      }
      this.updateTexture();
    }
  }, t.prototype.drawLetterSpacing = function(e, o, R, N) {
    N === void 0 && (N = !1);
    var M = this._style, D = M.letterSpacing, L = t.experimentalLetterSpacing && ("letterSpacing" in CanvasRenderingContext2D.prototype || "textLetterSpacing" in CanvasRenderingContext2D.prototype);
    if (D === 0 || L) {
      L && (this.context.letterSpacing = D, this.context.textLetterSpacing = D), N ? this.context.strokeText(e, o, R) : this.context.fillText(e, o, R);
      return;
    }
    for (var B = o, $ = Array.from ? Array.from(e) : e.split(""), k = this.context.measureText(e).width, U = 0, z = 0; z < $.length; ++z) {
      var X = $[z];
      N ? this.context.strokeText(X, B, R) : this.context.fillText(X, B, R);
      for (var V = "", W = z + 1; W < $.length; ++W)
        V += $[W];
      U = this.context.measureText(V).width, B += k - U + D, k = U;
    }
  }, t.prototype.updateTexture = function() {
    var e = this.canvas;
    if (this._style.trim) {
      var o = trimCanvas(e);
      o.data && (e.width = o.width, e.height = o.height, this.context.putImageData(o.data, 0, 0));
    }
    var R = this._texture, N = this._style, M = N.trim ? 0 : N.padding, D = R.baseTexture;
    R.trim.width = R._frame.width = e.width / this._resolution, R.trim.height = R._frame.height = e.height / this._resolution, R.trim.x = -M, R.trim.y = -M, R.orig.width = R._frame.width - M * 2, R.orig.height = R._frame.height - M * 2, this._onTextureUpdate(), D.setRealSize(e.width, e.height, this._resolution), R.updateUvs(), this.dirty = !1;
  }, t.prototype._render = function(e) {
    this._autoResolution && this._resolution !== e.resolution && (this._resolution = e.resolution, this.dirty = !0), this.updateText(!0), n.prototype._render.call(this, e);
  }, t.prototype.updateTransform = function() {
    this.updateText(!0), n.prototype.updateTransform.call(this);
  }, t.prototype.getBounds = function(e, o) {
    return this.updateText(!0), this._textureID === -1 && (e = !1), n.prototype.getBounds.call(this, e, o);
  }, t.prototype.getLocalBounds = function(e) {
    return this.updateText(!0), n.prototype.getLocalBounds.call(this, e);
  }, t.prototype._calculateBounds = function() {
    this.calculateVertices(), this._bounds.addQuad(this.vertexData);
  }, t.prototype._generateFillStyle = function(e, o, R) {
    var N = e.fill;
    if (Array.isArray(N)) {
      if (N.length === 1)
        return N[0];
    } else
      return N;
    var M, D = e.dropShadow ? e.dropShadowDistance : 0, L = e.padding || 0, B = this.canvas.width / this._resolution - D - L * 2, $ = this.canvas.height / this._resolution - D - L * 2, k = N.slice(), U = e.fillGradientStops.slice();
    if (!U.length)
      for (var z = k.length + 1, X = 1; X < z; ++X)
        U.push(X / z);
    if (k.unshift(N[0]), U.unshift(0), k.push(N[N.length - 1]), U.push(1), e.fillGradientType === TEXT_GRADIENT.LINEAR_VERTICAL) {
      M = this.context.createLinearGradient(B / 2, L, B / 2, $ + L);
      for (var V = R.fontProperties.fontSize + e.strokeThickness, X = 0; X < o.length; X++) {
        var W = R.lineHeight * (X - 1) + V, Y = R.lineHeight * X, q = Y;
        X > 0 && W > Y && (q = (Y + W) / 2);
        var Z = Y + V, J = R.lineHeight * (X + 1), Q = Z;
        X + 1 < o.length && J < Z && (Q = (Z + J) / 2);
        for (var K = (Q - q) / $, rt = 0; rt < k.length; rt++) {
          var tt = 0;
          typeof U[rt] == "number" ? tt = U[rt] : tt = rt / k.length;
          var nt = Math.min(1, Math.max(0, q / $ + tt * K));
          nt = Number(nt.toFixed(5)), M.addColorStop(nt, k[rt]);
        }
      }
    } else {
      M = this.context.createLinearGradient(L, $ / 2, B + L, $ / 2);
      for (var at = k.length + 1, lt = 1, X = 0; X < k.length; X++) {
        var ut = void 0;
        typeof U[X] == "number" ? ut = U[X] : ut = lt / at, M.addColorStop(ut, k[X]), lt++;
      }
    }
    return M;
  }, t.prototype.destroy = function(e) {
    typeof e == "boolean" && (e = { children: e }), e = Object.assign({}, defaultDestroyOptions, e), n.prototype.destroy.call(this, e), this._ownCanvas && (this.canvas.height = this.canvas.width = 0), this.context = null, this.canvas = null, this._style = null;
  }, Object.defineProperty(t.prototype, "width", {
    get: function() {
      return this.updateText(!0), Math.abs(this.scale.x) * this._texture.orig.width;
    },
    set: function(e) {
      this.updateText(!0);
      var o = sign(this.scale.x) || 1;
      this.scale.x = o * e / this._texture.orig.width, this._width = e;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(t.prototype, "height", {
    get: function() {
      return this.updateText(!0), Math.abs(this.scale.y) * this._texture.orig.height;
    },
    set: function(e) {
      this.updateText(!0);
      var o = sign(this.scale.y) || 1;
      this.scale.y = o * e / this._texture.orig.height, this._height = e;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(t.prototype, "style", {
    get: function() {
      return this._style;
    },
    set: function(e) {
      e = e || {}, e instanceof TextStyle ? this._style = e : this._style = new TextStyle(e), this.localStyleID = -1, this.dirty = !0;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(t.prototype, "text", {
    get: function() {
      return this._text;
    },
    set: function(e) {
      e = String(e == null ? "" : e), this._text !== e && (this._text = e, this.dirty = !0);
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(t.prototype, "resolution", {
    get: function() {
      return this._resolution;
    },
    set: function(e) {
      this._autoResolution = !1, this._resolution !== e && (this._resolution = e, this.dirty = !0);
    },
    enumerable: !1,
    configurable: !0
  }), t.nextLineHeightBehavior = !1, t.experimentalLetterSpacing = !1, t;
}(Sprite);
/*!
 * @pixi/prepare - v6.5.2
 * Compiled Wed, 24 Aug 2022 13:51:19 UTC
 *
 * @pixi/prepare is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
settings$1.UPLOADS_PER_FRAME = 4;
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var extendStatics$i = function(n, t) {
  return extendStatics$i = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(e, o) {
    e.__proto__ = o;
  } || function(e, o) {
    for (var R in o)
      o.hasOwnProperty(R) && (e[R] = o[R]);
  }, extendStatics$i(n, t);
};
function __extends$i(n, t) {
  extendStatics$i(n, t);
  function e() {
    this.constructor = n;
  }
  n.prototype = t === null ? Object.create(t) : (e.prototype = t.prototype, new e());
}
var CountLimiter = function() {
  function n(t) {
    this.maxItemsPerFrame = t, this.itemsLeft = 0;
  }
  return n.prototype.beginFrame = function() {
    this.itemsLeft = this.maxItemsPerFrame;
  }, n.prototype.allowedToUpload = function() {
    return this.itemsLeft-- > 0;
  }, n;
}();
function findMultipleBaseTextures(n, t) {
  var e = !1;
  if (n && n._textures && n._textures.length) {
    for (var o = 0; o < n._textures.length; o++)
      if (n._textures[o] instanceof Texture) {
        var R = n._textures[o].baseTexture;
        t.indexOf(R) === -1 && (t.push(R), e = !0);
      }
  }
  return e;
}
function findBaseTexture(n, t) {
  if (n.baseTexture instanceof BaseTexture) {
    var e = n.baseTexture;
    return t.indexOf(e) === -1 && t.push(e), !0;
  }
  return !1;
}
function findTexture(n, t) {
  if (n._texture && n._texture instanceof Texture) {
    var e = n._texture.baseTexture;
    return t.indexOf(e) === -1 && t.push(e), !0;
  }
  return !1;
}
function drawText(n, t) {
  return t instanceof Text ? (t.updateText(!0), !0) : !1;
}
function calculateTextStyle(n, t) {
  if (t instanceof TextStyle) {
    var e = t.toFontString();
    return TextMetrics.measureFont(e), !0;
  }
  return !1;
}
function findText(n, t) {
  if (n instanceof Text) {
    t.indexOf(n.style) === -1 && t.push(n.style), t.indexOf(n) === -1 && t.push(n);
    var e = n._texture.baseTexture;
    return t.indexOf(e) === -1 && t.push(e), !0;
  }
  return !1;
}
function findTextStyle(n, t) {
  return n instanceof TextStyle ? (t.indexOf(n) === -1 && t.push(n), !0) : !1;
}
var BasePrepare = function() {
  function n(t) {
    var e = this;
    this.limiter = new CountLimiter(settings$1.UPLOADS_PER_FRAME), this.renderer = t, this.uploadHookHelper = null, this.queue = [], this.addHooks = [], this.uploadHooks = [], this.completes = [], this.ticking = !1, this.delayedTick = function() {
      !e.queue || e.prepareItems();
    }, this.registerFindHook(findText), this.registerFindHook(findTextStyle), this.registerFindHook(findMultipleBaseTextures), this.registerFindHook(findBaseTexture), this.registerFindHook(findTexture), this.registerUploadHook(drawText), this.registerUploadHook(calculateTextStyle);
  }
  return n.prototype.upload = function(t, e) {
    var o = this;
    return typeof t == "function" && (e = t, t = null), e && deprecation$1("6.5.0", "BasePrepare.upload callback is deprecated, use the return Promise instead."), new Promise(function(R) {
      t && o.add(t);
      var N = function() {
        e == null || e(), R();
      };
      o.queue.length ? (o.completes.push(N), o.ticking || (o.ticking = !0, Ticker.system.addOnce(o.tick, o, UPDATE_PRIORITY.UTILITY))) : N();
    });
  }, n.prototype.tick = function() {
    setTimeout(this.delayedTick, 0);
  }, n.prototype.prepareItems = function() {
    for (this.limiter.beginFrame(); this.queue.length && this.limiter.allowedToUpload(); ) {
      var t = this.queue[0], e = !1;
      if (t && !t._destroyed) {
        for (var o = 0, R = this.uploadHooks.length; o < R; o++)
          if (this.uploadHooks[o](this.uploadHookHelper, t)) {
            this.queue.shift(), e = !0;
            break;
          }
      }
      e || this.queue.shift();
    }
    if (this.queue.length)
      Ticker.system.addOnce(this.tick, this, UPDATE_PRIORITY.UTILITY);
    else {
      this.ticking = !1;
      var N = this.completes.slice(0);
      this.completes.length = 0;
      for (var o = 0, R = N.length; o < R; o++)
        N[o]();
    }
  }, n.prototype.registerFindHook = function(t) {
    return t && this.addHooks.push(t), this;
  }, n.prototype.registerUploadHook = function(t) {
    return t && this.uploadHooks.push(t), this;
  }, n.prototype.add = function(t) {
    for (var e = 0, o = this.addHooks.length; e < o && !this.addHooks[e](t, this.queue); e++)
      ;
    if (t instanceof Container)
      for (var e = t.children.length - 1; e >= 0; e--)
        this.add(t.children[e]);
    return this;
  }, n.prototype.destroy = function() {
    this.ticking && Ticker.system.remove(this.tick, this), this.ticking = !1, this.addHooks = null, this.uploadHooks = null, this.renderer = null, this.completes = null, this.queue = null, this.limiter = null, this.uploadHookHelper = null;
  }, n;
}();
function uploadBaseTextures(n, t) {
  return t instanceof BaseTexture ? (t._glTextures[n.CONTEXT_UID] || n.texture.bind(t), !0) : !1;
}
function uploadGraphics(n, t) {
  if (!(t instanceof Graphics))
    return !1;
  var e = t.geometry;
  t.finishPoly(), e.updateBatches();
  for (var o = e.batches, R = 0; R < o.length; R++) {
    var N = o[R].style.texture;
    N && uploadBaseTextures(n, N.baseTexture);
  }
  return e.batchable || n.geometry.bind(e, t._resolveDirectShader(n)), !0;
}
function findGraphics(n, t) {
  return n instanceof Graphics ? (t.push(n), !0) : !1;
}
var Prepare = function(n) {
  __extends$i(t, n);
  function t(e) {
    var o = n.call(this, e) || this;
    return o.uploadHookHelper = o.renderer, o.registerFindHook(findGraphics), o.registerUploadHook(uploadBaseTextures), o.registerUploadHook(uploadGraphics), o;
  }
  return t.extension = {
    name: "prepare",
    type: ExtensionType.RendererPlugin
  }, t;
}(BasePrepare);
/*!
 * @pixi/spritesheet - v6.5.2
 * Compiled Wed, 24 Aug 2022 13:51:19 UTC
 *
 * @pixi/spritesheet is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
var Spritesheet = function() {
  function n(t, e, o) {
    o === void 0 && (o = null), this.linkedSheets = [], this._texture = t instanceof Texture ? t : null, this.baseTexture = t instanceof BaseTexture ? t : this._texture.baseTexture, this.textures = {}, this.animations = {}, this.data = e;
    var R = this.baseTexture.resource;
    this.resolution = this._updateResolution(o || (R ? R.url : null)), this._frames = this.data.frames, this._frameKeys = Object.keys(this._frames), this._batchIndex = 0, this._callback = null;
  }
  return n.prototype._updateResolution = function(t) {
    t === void 0 && (t = null);
    var e = this.data.meta.scale, o = getResolutionOfUrl(t, null);
    return o === null && (o = e !== void 0 ? parseFloat(e) : 1), o !== 1 && this.baseTexture.setResolution(o), o;
  }, n.prototype.parse = function(t) {
    var e = this;
    return t && deprecation$1("6.5.0", "Spritesheet.parse callback is deprecated, use the return Promise instead."), new Promise(function(o) {
      e._callback = function(R) {
        t == null || t(R), o(R);
      }, e._batchIndex = 0, e._frameKeys.length <= n.BATCH_SIZE ? (e._processFrames(0), e._processAnimations(), e._parseComplete()) : e._nextBatch();
    });
  }, n.prototype._processFrames = function(t) {
    for (var e = t, o = n.BATCH_SIZE; e - t < o && e < this._frameKeys.length; ) {
      var R = this._frameKeys[e], N = this._frames[R], M = N.frame;
      if (M) {
        var D = null, L = null, B = N.trimmed !== !1 && N.sourceSize ? N.sourceSize : N.frame, $ = new Rectangle(0, 0, Math.floor(B.w) / this.resolution, Math.floor(B.h) / this.resolution);
        N.rotated ? D = new Rectangle(Math.floor(M.x) / this.resolution, Math.floor(M.y) / this.resolution, Math.floor(M.h) / this.resolution, Math.floor(M.w) / this.resolution) : D = new Rectangle(Math.floor(M.x) / this.resolution, Math.floor(M.y) / this.resolution, Math.floor(M.w) / this.resolution, Math.floor(M.h) / this.resolution), N.trimmed !== !1 && N.spriteSourceSize && (L = new Rectangle(Math.floor(N.spriteSourceSize.x) / this.resolution, Math.floor(N.spriteSourceSize.y) / this.resolution, Math.floor(M.w) / this.resolution, Math.floor(M.h) / this.resolution)), this.textures[R] = new Texture(this.baseTexture, D, $, L, N.rotated ? 2 : 0, N.anchor), Texture.addToCache(this.textures[R], R);
      }
      e++;
    }
  }, n.prototype._processAnimations = function() {
    var t = this.data.animations || {};
    for (var e in t) {
      this.animations[e] = [];
      for (var o = 0; o < t[e].length; o++) {
        var R = t[e][o];
        this.animations[e].push(this.textures[R]);
      }
    }
  }, n.prototype._parseComplete = function() {
    var t = this._callback;
    this._callback = null, this._batchIndex = 0, t.call(this, this.textures);
  }, n.prototype._nextBatch = function() {
    var t = this;
    this._processFrames(this._batchIndex * n.BATCH_SIZE), this._batchIndex++, setTimeout(function() {
      t._batchIndex * n.BATCH_SIZE < t._frameKeys.length ? t._nextBatch() : (t._processAnimations(), t._parseComplete());
    }, 0);
  }, n.prototype.destroy = function(t) {
    var e;
    t === void 0 && (t = !1);
    for (var o in this.textures)
      this.textures[o].destroy();
    this._frames = null, this._frameKeys = null, this.data = null, this.textures = null, t && ((e = this._texture) === null || e === void 0 || e.destroy(), this.baseTexture.destroy()), this._texture = null, this.baseTexture = null, this.linkedSheets = [];
  }, n.BATCH_SIZE = 1e3, n;
}(), SpritesheetLoader = function() {
  function n() {
  }
  return n.use = function(t, e) {
    var o, R, N = this, M = t.name + "_image";
    if (!t.data || t.type !== LoaderResource.TYPE.JSON || !t.data.frames || N.resources[M]) {
      e();
      return;
    }
    var D = (R = (o = t.data) === null || o === void 0 ? void 0 : o.meta) === null || R === void 0 ? void 0 : R.related_multi_packs;
    if (Array.isArray(D))
      for (var L = function(X) {
        if (typeof X != "string")
          return "continue";
        var V = X.replace(".json", ""), W = url.resolve(t.url.replace(N.baseUrl, ""), X);
        if (N.resources[V] || Object.values(N.resources).some(function(q) {
          return url.format(url.parse(q.url)) === W;
        }))
          return "continue";
        var Y = {
          crossOrigin: t.crossOrigin,
          loadType: LoaderResource.LOAD_TYPE.XHR,
          xhrType: LoaderResource.XHR_RESPONSE_TYPE.JSON,
          parentResource: t,
          metadata: t.metadata
        };
        N.add(V, W, Y);
      }, B = 0, $ = D; B < $.length; B++) {
        var k = $[B];
        L(k);
      }
    var U = {
      crossOrigin: t.crossOrigin,
      metadata: t.metadata.imageMetadata,
      parentResource: t
    }, z = n.getResourcePath(t, N.baseUrl);
    N.add(M, z, U, function(V) {
      if (V.error) {
        e(V.error);
        return;
      }
      var W = new Spritesheet(V.texture, t.data, t.url);
      W.parse().then(function() {
        t.spritesheet = W, t.textures = W.textures, e();
      });
    });
  }, n.getResourcePath = function(t, e) {
    return t.isDataUrl ? t.data.meta.image : url.resolve(t.url.replace(e, ""), t.data.meta.image);
  }, n.extension = ExtensionType.Loader, n;
}();
/*!
 * @pixi/sprite-tiling - v6.5.2
 * Compiled Wed, 24 Aug 2022 13:51:19 UTC
 *
 * @pixi/sprite-tiling is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var extendStatics$h = function(n, t) {
  return extendStatics$h = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(e, o) {
    e.__proto__ = o;
  } || function(e, o) {
    for (var R in o)
      o.hasOwnProperty(R) && (e[R] = o[R]);
  }, extendStatics$h(n, t);
};
function __extends$h(n, t) {
  extendStatics$h(n, t);
  function e() {
    this.constructor = n;
  }
  n.prototype = t === null ? Object.create(t) : (e.prototype = t.prototype, new e());
}
var tempPoint$1 = new Point();
(function(n) {
  __extends$h(t, n);
  function t(e, o, R) {
    o === void 0 && (o = 100), R === void 0 && (R = 100);
    var N = n.call(this, e) || this;
    return N.tileTransform = new Transform(), N._width = o, N._height = R, N.uvMatrix = N.texture.uvMatrix || new TextureMatrix(e), N.pluginName = "tilingSprite", N.uvRespectAnchor = !1, N;
  }
  return Object.defineProperty(t.prototype, "clampMargin", {
    get: function() {
      return this.uvMatrix.clampMargin;
    },
    set: function(e) {
      this.uvMatrix.clampMargin = e, this.uvMatrix.update(!0);
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(t.prototype, "tileScale", {
    get: function() {
      return this.tileTransform.scale;
    },
    set: function(e) {
      this.tileTransform.scale.copyFrom(e);
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(t.prototype, "tilePosition", {
    get: function() {
      return this.tileTransform.position;
    },
    set: function(e) {
      this.tileTransform.position.copyFrom(e);
    },
    enumerable: !1,
    configurable: !0
  }), t.prototype._onTextureUpdate = function() {
    this.uvMatrix && (this.uvMatrix.texture = this._texture), this._cachedTint = 16777215;
  }, t.prototype._render = function(e) {
    var o = this._texture;
    !o || !o.valid || (this.tileTransform.updateLocalTransform(), this.uvMatrix.update(), e.batch.setObjectRenderer(e.plugins[this.pluginName]), e.plugins[this.pluginName].render(this));
  }, t.prototype._calculateBounds = function() {
    var e = this._width * -this._anchor._x, o = this._height * -this._anchor._y, R = this._width * (1 - this._anchor._x), N = this._height * (1 - this._anchor._y);
    this._bounds.addFrame(this.transform, e, o, R, N);
  }, t.prototype.getLocalBounds = function(e) {
    return this.children.length === 0 ? (this._bounds.minX = this._width * -this._anchor._x, this._bounds.minY = this._height * -this._anchor._y, this._bounds.maxX = this._width * (1 - this._anchor._x), this._bounds.maxY = this._height * (1 - this._anchor._y), e || (this._localBoundsRect || (this._localBoundsRect = new Rectangle()), e = this._localBoundsRect), this._bounds.getRectangle(e)) : n.prototype.getLocalBounds.call(this, e);
  }, t.prototype.containsPoint = function(e) {
    this.worldTransform.applyInverse(e, tempPoint$1);
    var o = this._width, R = this._height, N = -o * this.anchor._x;
    if (tempPoint$1.x >= N && tempPoint$1.x < N + o) {
      var M = -R * this.anchor._y;
      if (tempPoint$1.y >= M && tempPoint$1.y < M + R)
        return !0;
    }
    return !1;
  }, t.prototype.destroy = function(e) {
    n.prototype.destroy.call(this, e), this.tileTransform = null, this.uvMatrix = null;
  }, t.from = function(e, o) {
    var R = e instanceof Texture ? e : Texture.from(e, o);
    return new t(R, o.width, o.height);
  }, Object.defineProperty(t.prototype, "width", {
    get: function() {
      return this._width;
    },
    set: function(e) {
      this._width = e;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(t.prototype, "height", {
    get: function() {
      return this._height;
    },
    set: function(e) {
      this._height = e;
    },
    enumerable: !1,
    configurable: !0
  }), t;
})(Sprite);
var fragmentSimpleSrc = `#version 100
#define SHADER_NAME Tiling-Sprite-Simple-100

precision lowp float;

varying vec2 vTextureCoord;

uniform sampler2D uSampler;
uniform vec4 uColor;

void main(void)
{
    vec4 texSample = texture2D(uSampler, vTextureCoord);
    gl_FragColor = texSample * uColor;
}
`, gl1VertexSrc = `#version 100
#define SHADER_NAME Tiling-Sprite-100

precision lowp float;

attribute vec2 aVertexPosition;
attribute vec2 aTextureCoord;

uniform mat3 projectionMatrix;
uniform mat3 translationMatrix;
uniform mat3 uTransform;

varying vec2 vTextureCoord;

void main(void)
{
    gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);

    vTextureCoord = (uTransform * vec3(aTextureCoord, 1.0)).xy;
}
`, gl1FragmentSrc = `#version 100
#ifdef GL_EXT_shader_texture_lod
    #extension GL_EXT_shader_texture_lod : enable
#endif
#define SHADER_NAME Tiling-Sprite-100

precision lowp float;

varying vec2 vTextureCoord;

uniform sampler2D uSampler;
uniform vec4 uColor;
uniform mat3 uMapCoord;
uniform vec4 uClampFrame;
uniform vec2 uClampOffset;

void main(void)
{
    vec2 coord = vTextureCoord + ceil(uClampOffset - vTextureCoord);
    coord = (uMapCoord * vec3(coord, 1.0)).xy;
    vec2 unclamped = coord;
    coord = clamp(coord, uClampFrame.xy, uClampFrame.zw);

    #ifdef GL_EXT_shader_texture_lod
        vec4 texSample = unclamped == coord
            ? texture2D(uSampler, coord) 
            : texture2DLodEXT(uSampler, coord, 0);
    #else
        vec4 texSample = texture2D(uSampler, coord);
    #endif

    gl_FragColor = texSample * uColor;
}
`, gl2VertexSrc = `#version 300 es
#define SHADER_NAME Tiling-Sprite-300

precision lowp float;

in vec2 aVertexPosition;
in vec2 aTextureCoord;

uniform mat3 projectionMatrix;
uniform mat3 translationMatrix;
uniform mat3 uTransform;

out vec2 vTextureCoord;

void main(void)
{
    gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);

    vTextureCoord = (uTransform * vec3(aTextureCoord, 1.0)).xy;
}
`, gl2FragmentSrc = `#version 300 es
#define SHADER_NAME Tiling-Sprite-100

precision lowp float;

in vec2 vTextureCoord;

out vec4 fragmentColor;

uniform sampler2D uSampler;
uniform vec4 uColor;
uniform mat3 uMapCoord;
uniform vec4 uClampFrame;
uniform vec2 uClampOffset;

void main(void)
{
    vec2 coord = vTextureCoord + ceil(uClampOffset - vTextureCoord);
    coord = (uMapCoord * vec3(coord, 1.0)).xy;
    vec2 unclamped = coord;
    coord = clamp(coord, uClampFrame.xy, uClampFrame.zw);

    vec4 texSample = texture(uSampler, coord, unclamped == coord ? 0.0f : -32.0f);// lod-bias very negative to force lod 0

    fragmentColor = texSample * uColor;
}
`, tempMat = new Matrix(), TilingSpriteRenderer = function(n) {
  __extends$h(t, n);
  function t(e) {
    var o = n.call(this, e) || this;
    return e.runners.contextChange.add(o), o.quad = new QuadUv(), o.state = State.for2d(), o;
  }
  return t.prototype.contextChange = function() {
    var e = this.renderer, o = { globals: e.globalUniforms };
    this.simpleShader = Shader.from(gl1VertexSrc, fragmentSimpleSrc, o), this.shader = e.context.webGLVersion > 1 ? Shader.from(gl2VertexSrc, gl2FragmentSrc, o) : Shader.from(gl1VertexSrc, gl1FragmentSrc, o);
  }, t.prototype.render = function(e) {
    var o = this.renderer, R = this.quad, N = R.vertices;
    N[0] = N[6] = e._width * -e.anchor.x, N[1] = N[3] = e._height * -e.anchor.y, N[2] = N[4] = e._width * (1 - e.anchor.x), N[5] = N[7] = e._height * (1 - e.anchor.y);
    var M = e.uvRespectAnchor ? e.anchor.x : 0, D = e.uvRespectAnchor ? e.anchor.y : 0;
    N = R.uvs, N[0] = N[6] = -M, N[1] = N[3] = -D, N[2] = N[4] = 1 - M, N[5] = N[7] = 1 - D, R.invalidate();
    var L = e._texture, B = L.baseTexture, $ = B.alphaMode > 0, k = e.tileTransform.localTransform, U = e.uvMatrix, z = B.isPowerOfTwo && L.frame.width === B.width && L.frame.height === B.height;
    z && (B._glTextures[o.CONTEXT_UID] ? z = B.wrapMode !== WRAP_MODES$5.CLAMP : B.wrapMode === WRAP_MODES$5.CLAMP && (B.wrapMode = WRAP_MODES$5.REPEAT));
    var X = z ? this.simpleShader : this.shader, V = L.width, W = L.height, Y = e._width, q = e._height;
    tempMat.set(k.a * V / Y, k.b * V / q, k.c * W / Y, k.d * W / q, k.tx / Y, k.ty / q), tempMat.invert(), z ? tempMat.prepend(U.mapCoord) : (X.uniforms.uMapCoord = U.mapCoord.toArray(!0), X.uniforms.uClampFrame = U.uClampFrame, X.uniforms.uClampOffset = U.uClampOffset), X.uniforms.uTransform = tempMat.toArray(!0), X.uniforms.uColor = premultiplyTintToRgba(e.tint, e.worldAlpha, X.uniforms.uColor, $), X.uniforms.translationMatrix = e.transform.worldTransform.toArray(!0), X.uniforms.uSampler = L, o.shader.bind(X), o.geometry.bind(R), this.state.blendMode = correctBlendMode(e.blendMode, $), o.state.set(this.state), o.geometry.draw(this.renderer.gl.TRIANGLES, 6, 0);
  }, t.extension = {
    name: "tilingSprite",
    type: ExtensionType.RendererPlugin
  }, t;
}(ObjectRenderer);
/*!
 * @pixi/mesh - v6.5.2
 * Compiled Wed, 24 Aug 2022 13:51:19 UTC
 *
 * @pixi/mesh is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var extendStatics$g = function(n, t) {
  return extendStatics$g = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(e, o) {
    e.__proto__ = o;
  } || function(e, o) {
    for (var R in o)
      o.hasOwnProperty(R) && (e[R] = o[R]);
  }, extendStatics$g(n, t);
};
function __extends$g(n, t) {
  extendStatics$g(n, t);
  function e() {
    this.constructor = n;
  }
  n.prototype = t === null ? Object.create(t) : (e.prototype = t.prototype, new e());
}
var MeshBatchUvs = function() {
  function n(t, e) {
    this.uvBuffer = t, this.uvMatrix = e, this.data = null, this._bufferUpdateId = -1, this._textureUpdateId = -1, this._updateID = 0;
  }
  return n.prototype.update = function(t) {
    if (!(!t && this._bufferUpdateId === this.uvBuffer._updateID && this._textureUpdateId === this.uvMatrix._updateID)) {
      this._bufferUpdateId = this.uvBuffer._updateID, this._textureUpdateId = this.uvMatrix._updateID;
      var e = this.uvBuffer.data;
      (!this.data || this.data.length !== e.length) && (this.data = new Float32Array(e.length)), this.uvMatrix.multiplyUvs(e, this.data), this._updateID++;
    }
  }, n;
}(), tempPoint = new Point(), tempPolygon = new Polygon(), Mesh = function(n) {
  __extends$g(t, n);
  function t(e, o, R, N) {
    N === void 0 && (N = DRAW_MODES$5.TRIANGLES);
    var M = n.call(this) || this;
    return M.geometry = e, M.shader = o, M.state = R || State.for2d(), M.drawMode = N, M.start = 0, M.size = 0, M.uvs = null, M.indices = null, M.vertexData = new Float32Array(1), M.vertexDirty = -1, M._transformID = -1, M._roundPixels = settings$1.ROUND_PIXELS, M.batchUvs = null, M;
  }
  return Object.defineProperty(t.prototype, "geometry", {
    get: function() {
      return this._geometry;
    },
    set: function(e) {
      this._geometry !== e && (this._geometry && (this._geometry.refCount--, this._geometry.refCount === 0 && this._geometry.dispose()), this._geometry = e, this._geometry && this._geometry.refCount++, this.vertexDirty = -1);
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(t.prototype, "uvBuffer", {
    get: function() {
      return this.geometry.buffers[1];
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(t.prototype, "verticesBuffer", {
    get: function() {
      return this.geometry.buffers[0];
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(t.prototype, "material", {
    get: function() {
      return this.shader;
    },
    set: function(e) {
      this.shader = e;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(t.prototype, "blendMode", {
    get: function() {
      return this.state.blendMode;
    },
    set: function(e) {
      this.state.blendMode = e;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(t.prototype, "roundPixels", {
    get: function() {
      return this._roundPixels;
    },
    set: function(e) {
      this._roundPixels !== e && (this._transformID = -1), this._roundPixels = e;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(t.prototype, "tint", {
    get: function() {
      return "tint" in this.shader ? this.shader.tint : null;
    },
    set: function(e) {
      this.shader.tint = e;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(t.prototype, "texture", {
    get: function() {
      return "texture" in this.shader ? this.shader.texture : null;
    },
    set: function(e) {
      this.shader.texture = e;
    },
    enumerable: !1,
    configurable: !0
  }), t.prototype._render = function(e) {
    var o = this.geometry.buffers[0].data, R = this.shader;
    R.batchable && this.drawMode === DRAW_MODES$5.TRIANGLES && o.length < t.BATCHABLE_SIZE * 2 ? this._renderToBatch(e) : this._renderDefault(e);
  }, t.prototype._renderDefault = function(e) {
    var o = this.shader;
    o.alpha = this.worldAlpha, o.update && o.update(), e.batch.flush(), o.uniforms.translationMatrix = this.transform.worldTransform.toArray(!0), e.shader.bind(o), e.state.set(this.state), e.geometry.bind(this.geometry, o), e.geometry.draw(this.drawMode, this.size, this.start, this.geometry.instanceCount);
  }, t.prototype._renderToBatch = function(e) {
    var o = this.geometry, R = this.shader;
    R.uvMatrix && (R.uvMatrix.update(), this.calculateUvs()), this.calculateVertices(), this.indices = o.indexBuffer.data, this._tintRGB = R._tintRGB, this._texture = R.texture;
    var N = this.material.pluginName;
    e.batch.setObjectRenderer(e.plugins[N]), e.plugins[N].render(this);
  }, t.prototype.calculateVertices = function() {
    var e = this.geometry, o = e.buffers[0], R = o.data, N = o._updateID;
    if (!(N === this.vertexDirty && this._transformID === this.transform._worldID)) {
      this._transformID = this.transform._worldID, this.vertexData.length !== R.length && (this.vertexData = new Float32Array(R.length));
      for (var M = this.transform.worldTransform, D = M.a, L = M.b, B = M.c, $ = M.d, k = M.tx, U = M.ty, z = this.vertexData, X = 0; X < z.length / 2; X++) {
        var V = R[X * 2], W = R[X * 2 + 1];
        z[X * 2] = D * V + B * W + k, z[X * 2 + 1] = L * V + $ * W + U;
      }
      if (this._roundPixels)
        for (var Y = settings$1.RESOLUTION, X = 0; X < z.length; ++X)
          z[X] = Math.round((z[X] * Y | 0) / Y);
      this.vertexDirty = N;
    }
  }, t.prototype.calculateUvs = function() {
    var e = this.geometry.buffers[1], o = this.shader;
    o.uvMatrix.isSimple ? this.uvs = e.data : (this.batchUvs || (this.batchUvs = new MeshBatchUvs(e, o.uvMatrix)), this.batchUvs.update(), this.uvs = this.batchUvs.data);
  }, t.prototype._calculateBounds = function() {
    this.calculateVertices(), this._bounds.addVertexData(this.vertexData, 0, this.vertexData.length);
  }, t.prototype.containsPoint = function(e) {
    if (!this.getBounds().contains(e.x, e.y))
      return !1;
    this.worldTransform.applyInverse(e, tempPoint);
    for (var o = this.geometry.getBuffer("aVertexPosition").data, R = tempPolygon.points, N = this.geometry.getIndex().data, M = N.length, D = this.drawMode === 4 ? 3 : 1, L = 0; L + 2 < M; L += D) {
      var B = N[L] * 2, $ = N[L + 1] * 2, k = N[L + 2] * 2;
      if (R[0] = o[B], R[1] = o[B + 1], R[2] = o[$], R[3] = o[$ + 1], R[4] = o[k], R[5] = o[k + 1], tempPolygon.contains(tempPoint.x, tempPoint.y))
        return !0;
    }
    return !1;
  }, t.prototype.destroy = function(e) {
    n.prototype.destroy.call(this, e), this._cachedTexture && (this._cachedTexture.destroy(), this._cachedTexture = null), this.geometry = null, this.shader = null, this.state = null, this.uvs = null, this.indices = null, this.vertexData = null;
  }, t.BATCHABLE_SIZE = 100, t;
}(Container), fragment$5 = `varying vec2 vTextureCoord;
uniform vec4 uColor;

uniform sampler2D uSampler;

void main(void)
{
    gl_FragColor = texture2D(uSampler, vTextureCoord) * uColor;
}
`, vertex$2 = `attribute vec2 aVertexPosition;
attribute vec2 aTextureCoord;

uniform mat3 projectionMatrix;
uniform mat3 translationMatrix;
uniform mat3 uTextureMatrix;

varying vec2 vTextureCoord;

void main(void)
{
    gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);

    vTextureCoord = (uTextureMatrix * vec3(aTextureCoord, 1.0)).xy;
}
`, MeshMaterial = function(n) {
  __extends$g(t, n);
  function t(e, o) {
    var R = this, N = {
      uSampler: e,
      alpha: 1,
      uTextureMatrix: Matrix.IDENTITY,
      uColor: new Float32Array([1, 1, 1, 1])
    };
    return o = Object.assign({
      tint: 16777215,
      alpha: 1,
      pluginName: "batch"
    }, o), o.uniforms && Object.assign(N, o.uniforms), R = n.call(this, o.program || Program.from(vertex$2, fragment$5), N) || this, R._colorDirty = !1, R.uvMatrix = new TextureMatrix(e), R.batchable = o.program === void 0, R.pluginName = o.pluginName, R.tint = o.tint, R.alpha = o.alpha, R;
  }
  return Object.defineProperty(t.prototype, "texture", {
    get: function() {
      return this.uniforms.uSampler;
    },
    set: function(e) {
      this.uniforms.uSampler !== e && (!this.uniforms.uSampler.baseTexture.alphaMode != !e.baseTexture.alphaMode && (this._colorDirty = !0), this.uniforms.uSampler = e, this.uvMatrix.texture = e);
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(t.prototype, "alpha", {
    get: function() {
      return this._alpha;
    },
    set: function(e) {
      e !== this._alpha && (this._alpha = e, this._colorDirty = !0);
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(t.prototype, "tint", {
    get: function() {
      return this._tint;
    },
    set: function(e) {
      e !== this._tint && (this._tint = e, this._tintRGB = (e >> 16) + (e & 65280) + ((e & 255) << 16), this._colorDirty = !0);
    },
    enumerable: !1,
    configurable: !0
  }), t.prototype.update = function() {
    if (this._colorDirty) {
      this._colorDirty = !1;
      var e = this.texture.baseTexture;
      premultiplyTintToRgba(this._tint, this._alpha, this.uniforms.uColor, e.alphaMode);
    }
    this.uvMatrix.update() && (this.uniforms.uTextureMatrix = this.uvMatrix.mapCoord);
  }, t;
}(Shader), MeshGeometry = function(n) {
  __extends$g(t, n);
  function t(e, o, R) {
    var N = n.call(this) || this, M = new Buffer$1(e), D = new Buffer$1(o, !0), L = new Buffer$1(R, !0, !0);
    return N.addAttribute("aVertexPosition", M, 2, !1, TYPES$5.FLOAT).addAttribute("aTextureCoord", D, 2, !1, TYPES$5.FLOAT).addIndex(L), N._updateId = -1, N;
  }
  return Object.defineProperty(t.prototype, "vertexDirtyId", {
    get: function() {
      return this.buffers[0]._updateID;
    },
    enumerable: !1,
    configurable: !0
  }), t;
}(Geometry);
/*!
 * @pixi/text-bitmap - v6.5.2
 * Compiled Wed, 24 Aug 2022 13:51:19 UTC
 *
 * @pixi/text-bitmap is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var extendStatics$f = function(n, t) {
  return extendStatics$f = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(e, o) {
    e.__proto__ = o;
  } || function(e, o) {
    for (var R in o)
      o.hasOwnProperty(R) && (e[R] = o[R]);
  }, extendStatics$f(n, t);
};
function __extends$f(n, t) {
  extendStatics$f(n, t);
  function e() {
    this.constructor = n;
  }
  n.prototype = t === null ? Object.create(t) : (e.prototype = t.prototype, new e());
}
var BitmapFontData = function() {
  function n() {
    this.info = [], this.common = [], this.page = [], this.char = [], this.kerning = [], this.distanceField = [];
  }
  return n;
}(), TextFormat = function() {
  function n() {
  }
  return n.test = function(t) {
    return typeof t == "string" && t.indexOf("info face=") === 0;
  }, n.parse = function(t) {
    var e = t.match(/^[a-z]+\s+.+$/gm), o = {
      info: [],
      common: [],
      page: [],
      char: [],
      chars: [],
      kerning: [],
      kernings: [],
      distanceField: []
    };
    for (var R in e) {
      var N = e[R].match(/^[a-z]+/gm)[0], M = e[R].match(/[a-zA-Z]+=([^\s"']+|"([^"]*)")/gm), D = {};
      for (var L in M) {
        var B = M[L].split("="), $ = B[0], k = B[1].replace(/"/gm, ""), U = parseFloat(k), z = isNaN(U) ? k : U;
        D[$] = z;
      }
      o[N].push(D);
    }
    var X = new BitmapFontData();
    return o.info.forEach(function(V) {
      return X.info.push({
        face: V.face,
        size: parseInt(V.size, 10)
      });
    }), o.common.forEach(function(V) {
      return X.common.push({
        lineHeight: parseInt(V.lineHeight, 10)
      });
    }), o.page.forEach(function(V) {
      return X.page.push({
        id: parseInt(V.id, 10),
        file: V.file
      });
    }), o.char.forEach(function(V) {
      return X.char.push({
        id: parseInt(V.id, 10),
        page: parseInt(V.page, 10),
        x: parseInt(V.x, 10),
        y: parseInt(V.y, 10),
        width: parseInt(V.width, 10),
        height: parseInt(V.height, 10),
        xoffset: parseInt(V.xoffset, 10),
        yoffset: parseInt(V.yoffset, 10),
        xadvance: parseInt(V.xadvance, 10)
      });
    }), o.kerning.forEach(function(V) {
      return X.kerning.push({
        first: parseInt(V.first, 10),
        second: parseInt(V.second, 10),
        amount: parseInt(V.amount, 10)
      });
    }), o.distanceField.forEach(function(V) {
      return X.distanceField.push({
        distanceRange: parseInt(V.distanceRange, 10),
        fieldType: V.fieldType
      });
    }), X;
  }, n;
}(), XMLFormat = function() {
  function n() {
  }
  return n.test = function(t) {
    return t instanceof XMLDocument && t.getElementsByTagName("page").length && t.getElementsByTagName("info")[0].getAttribute("face") !== null;
  }, n.parse = function(t) {
    for (var e = new BitmapFontData(), o = t.getElementsByTagName("info"), R = t.getElementsByTagName("common"), N = t.getElementsByTagName("page"), M = t.getElementsByTagName("char"), D = t.getElementsByTagName("kerning"), L = t.getElementsByTagName("distanceField"), B = 0; B < o.length; B++)
      e.info.push({
        face: o[B].getAttribute("face"),
        size: parseInt(o[B].getAttribute("size"), 10)
      });
    for (var B = 0; B < R.length; B++)
      e.common.push({
        lineHeight: parseInt(R[B].getAttribute("lineHeight"), 10)
      });
    for (var B = 0; B < N.length; B++)
      e.page.push({
        id: parseInt(N[B].getAttribute("id"), 10) || 0,
        file: N[B].getAttribute("file")
      });
    for (var B = 0; B < M.length; B++) {
      var $ = M[B];
      e.char.push({
        id: parseInt($.getAttribute("id"), 10),
        page: parseInt($.getAttribute("page"), 10) || 0,
        x: parseInt($.getAttribute("x"), 10),
        y: parseInt($.getAttribute("y"), 10),
        width: parseInt($.getAttribute("width"), 10),
        height: parseInt($.getAttribute("height"), 10),
        xoffset: parseInt($.getAttribute("xoffset"), 10),
        yoffset: parseInt($.getAttribute("yoffset"), 10),
        xadvance: parseInt($.getAttribute("xadvance"), 10)
      });
    }
    for (var B = 0; B < D.length; B++)
      e.kerning.push({
        first: parseInt(D[B].getAttribute("first"), 10),
        second: parseInt(D[B].getAttribute("second"), 10),
        amount: parseInt(D[B].getAttribute("amount"), 10)
      });
    for (var B = 0; B < L.length; B++)
      e.distanceField.push({
        fieldType: L[B].getAttribute("fieldType"),
        distanceRange: parseInt(L[B].getAttribute("distanceRange"), 10)
      });
    return e;
  }, n;
}(), XMLStringFormat = function() {
  function n() {
  }
  return n.test = function(t) {
    if (typeof t == "string" && t.indexOf("<font>") > -1) {
      var e = new globalThis.DOMParser().parseFromString(t, "text/xml");
      return XMLFormat.test(e);
    }
    return !1;
  }, n.parse = function(t) {
    var e = new globalThis.DOMParser().parseFromString(t, "text/xml");
    return XMLFormat.parse(e);
  }, n;
}(), formats = [
  TextFormat,
  XMLFormat,
  XMLStringFormat
];
function autoDetectFormat(n) {
  for (var t = 0; t < formats.length; t++)
    if (formats[t].test(n))
      return formats[t];
  return null;
}
function generateFillStyle(n, t, e, o, R, N) {
  var M = e.fill;
  if (Array.isArray(M)) {
    if (M.length === 1)
      return M[0];
  } else
    return M;
  var D, L = e.dropShadow ? e.dropShadowDistance : 0, B = e.padding || 0, $ = n.width / o - L - B * 2, k = n.height / o - L - B * 2, U = M.slice(), z = e.fillGradientStops.slice();
  if (!z.length)
    for (var X = U.length + 1, V = 1; V < X; ++V)
      z.push(V / X);
  if (U.unshift(M[0]), z.unshift(0), U.push(M[M.length - 1]), z.push(1), e.fillGradientType === TEXT_GRADIENT.LINEAR_VERTICAL) {
    D = t.createLinearGradient($ / 2, B, $ / 2, k + B);
    for (var W = 0, Y = N.fontProperties.fontSize + e.strokeThickness, q = Y / k, V = 0; V < R.length; V++)
      for (var Z = N.lineHeight * V, J = 0; J < U.length; J++) {
        var Q = 0;
        typeof z[J] == "number" ? Q = z[J] : Q = J / U.length;
        var K = Z / k + Q * q, rt = Math.max(W, K);
        rt = Math.min(rt, 1), D.addColorStop(rt, U[J]), W = rt;
      }
  } else {
    D = t.createLinearGradient(B, k / 2, $ + B, k / 2);
    for (var tt = U.length + 1, nt = 1, V = 0; V < U.length; V++) {
      var at = void 0;
      typeof z[V] == "number" ? at = z[V] : at = nt / tt, D.addColorStop(at, U[V]), nt++;
    }
  }
  return D;
}
function drawGlyph(n, t, e, o, R, N, M) {
  var D = e.text, L = e.fontProperties;
  t.translate(o, R), t.scale(N, N);
  var B = M.strokeThickness / 2, $ = -(M.strokeThickness / 2);
  if (t.font = M.toFontString(), t.lineWidth = M.strokeThickness, t.textBaseline = M.textBaseline, t.lineJoin = M.lineJoin, t.miterLimit = M.miterLimit, t.fillStyle = generateFillStyle(n, t, M, N, [D], e), t.strokeStyle = M.stroke, M.dropShadow) {
    var k = M.dropShadowColor, U = hex2rgb(typeof k == "number" ? k : string2hex(k)), z = M.dropShadowBlur * N, X = M.dropShadowDistance * N;
    t.shadowColor = "rgba(" + U[0] * 255 + "," + U[1] * 255 + "," + U[2] * 255 + "," + M.dropShadowAlpha + ")", t.shadowBlur = z, t.shadowOffsetX = Math.cos(M.dropShadowAngle) * X, t.shadowOffsetY = Math.sin(M.dropShadowAngle) * X;
  } else
    t.shadowColor = "black", t.shadowBlur = 0, t.shadowOffsetX = 0, t.shadowOffsetY = 0;
  M.stroke && M.strokeThickness && t.strokeText(D, B, $ + e.lineHeight - L.descent), M.fill && t.fillText(D, B, $ + e.lineHeight - L.descent), t.setTransform(1, 0, 0, 1, 0, 0), t.fillStyle = "rgba(0, 0, 0, 0)";
}
function splitTextToCharacters(n) {
  return Array.from ? Array.from(n) : n.split("");
}
function resolveCharacters(n) {
  typeof n == "string" && (n = [n]);
  for (var t = [], e = 0, o = n.length; e < o; e++) {
    var R = n[e];
    if (Array.isArray(R)) {
      if (R.length !== 2)
        throw new Error("[BitmapFont]: Invalid character range length, expecting 2 got " + R.length + ".");
      var N = R[0].charCodeAt(0), M = R[1].charCodeAt(0);
      if (M < N)
        throw new Error("[BitmapFont]: Invalid character range.");
      for (var D = N, L = M; D <= L; D++)
        t.push(String.fromCharCode(D));
    } else
      t.push.apply(t, splitTextToCharacters(R));
  }
  if (t.length === 0)
    throw new Error("[BitmapFont]: Empty set when resolving characters.");
  return t;
}
function extractCharCode(n) {
  return n.codePointAt ? n.codePointAt(0) : n.charCodeAt(0);
}
var BitmapFont = function() {
  function n(t, e, o) {
    var R, N, M = t.info[0], D = t.common[0], L = t.page[0], B = t.distanceField[0], $ = getResolutionOfUrl(L.file), k = {};
    this._ownsTextures = o, this.font = M.face, this.size = M.size, this.lineHeight = D.lineHeight / $, this.chars = {}, this.pageTextures = k;
    for (var U = 0; U < t.page.length; U++) {
      var z = t.page[U], X = z.id, V = z.file;
      k[X] = e instanceof Array ? e[U] : e[V], (B == null ? void 0 : B.fieldType) && B.fieldType !== "none" && (k[X].baseTexture.alphaMode = ALPHA_MODES$5.NO_PREMULTIPLIED_ALPHA);
    }
    for (var U = 0; U < t.char.length; U++) {
      var W = t.char[U], X = W.id, Y = W.page, q = t.char[U], Z = q.x, J = q.y, Q = q.width, K = q.height, rt = q.xoffset, tt = q.yoffset, nt = q.xadvance;
      Z /= $, J /= $, Q /= $, K /= $, rt /= $, tt /= $, nt /= $;
      var at = new Rectangle(Z + k[Y].frame.x / $, J + k[Y].frame.y / $, Q, K);
      this.chars[X] = {
        xOffset: rt,
        yOffset: tt,
        xAdvance: nt,
        kerning: {},
        texture: new Texture(k[Y].baseTexture, at),
        page: Y
      };
    }
    for (var U = 0; U < t.kerning.length; U++) {
      var lt = t.kerning[U], ut = lt.first, dt = lt.second, yt = lt.amount;
      ut /= $, dt /= $, yt /= $, this.chars[dt] && (this.chars[dt].kerning[ut] = yt);
    }
    this.distanceFieldRange = B == null ? void 0 : B.distanceRange, this.distanceFieldType = (N = (R = B == null ? void 0 : B.fieldType) === null || R === void 0 ? void 0 : R.toLowerCase()) !== null && N !== void 0 ? N : "none";
  }
  return n.prototype.destroy = function() {
    for (var t in this.chars)
      this.chars[t].texture.destroy(), this.chars[t].texture = null;
    for (var t in this.pageTextures)
      this._ownsTextures && this.pageTextures[t].destroy(!0), this.pageTextures[t] = null;
    this.chars = null, this.pageTextures = null;
  }, n.install = function(t, e, o) {
    var R;
    if (t instanceof BitmapFontData)
      R = t;
    else {
      var N = autoDetectFormat(t);
      if (!N)
        throw new Error("Unrecognized data format for font.");
      R = N.parse(t);
    }
    e instanceof Texture && (e = [e]);
    var M = new n(R, e, o);
    return n.available[M.font] = M, M;
  }, n.uninstall = function(t) {
    var e = n.available[t];
    if (!e)
      throw new Error("No font found named '" + t + "'");
    e.destroy(), delete n.available[t];
  }, n.from = function(t, e, o) {
    if (!t)
      throw new Error("[BitmapFont] Property `name` is required.");
    var R = Object.assign({}, n.defaultOptions, o), N = R.chars, M = R.padding, D = R.resolution, L = R.textureWidth, B = R.textureHeight, $ = resolveCharacters(N), k = e instanceof TextStyle ? e : new TextStyle(e), U = L, z = new BitmapFontData();
    z.info[0] = {
      face: k.fontFamily,
      size: k.fontSize
    }, z.common[0] = {
      lineHeight: k.fontSize
    };
    for (var X = 0, V = 0, W, Y, q, Z = 0, J = [], Q = 0; Q < $.length; Q++) {
      W || (W = settings$1.ADAPTER.createCanvas(), W.width = L, W.height = B, Y = W.getContext("2d"), q = new BaseTexture(W, { resolution: D }), J.push(new Texture(q)), z.page.push({
        id: J.length - 1,
        file: ""
      }));
      var K = TextMetrics.measureText($[Q], k, !1, W), rt = K.width, tt = Math.ceil(K.height), nt = Math.ceil((k.fontStyle === "italic" ? 2 : 1) * rt);
      if (V >= B - tt * D) {
        if (V === 0)
          throw new Error("[BitmapFont] textureHeight " + B + "px is " + ("too small for " + k.fontSize + "px fonts"));
        --Q, W = null, Y = null, q = null, V = 0, X = 0, Z = 0;
        continue;
      }
      if (Z = Math.max(tt + K.fontProperties.descent, Z), nt * D + X >= U) {
        --Q, V += Z * D, V = Math.ceil(V), X = 0, Z = 0;
        continue;
      }
      drawGlyph(W, Y, K, X, V, D, k);
      var at = extractCharCode(K.text);
      z.char.push({
        id: at,
        page: J.length - 1,
        x: X / D,
        y: V / D,
        width: nt,
        height: tt,
        xoffset: 0,
        yoffset: 0,
        xadvance: Math.ceil(rt - (k.dropShadow ? k.dropShadowDistance : 0) - (k.stroke ? k.strokeThickness : 0))
      }), X += (nt + 2 * M) * D, X = Math.ceil(X);
    }
    for (var Q = 0, lt = $.length; Q < lt; Q++)
      for (var ut = $[Q], dt = 0; dt < lt; dt++) {
        var yt = $[dt], pt = Y.measureText(ut).width, gt = Y.measureText(yt).width, xt = Y.measureText(ut + yt).width, Lt = xt - (pt + gt);
        Lt && z.kerning.push({
          first: extractCharCode(ut),
          second: extractCharCode(yt),
          amount: Lt
        });
      }
    var mt = new n(z, J, !0);
    return n.available[t] !== void 0 && n.uninstall(t), n.available[t] = mt, mt;
  }, n.ALPHA = [["a", "z"], ["A", "Z"], " "], n.NUMERIC = [["0", "9"]], n.ALPHANUMERIC = [["a", "z"], ["A", "Z"], ["0", "9"], " "], n.ASCII = [[" ", "~"]], n.defaultOptions = {
    resolution: 1,
    textureWidth: 512,
    textureHeight: 512,
    padding: 4,
    chars: n.ALPHANUMERIC
  }, n.available = {}, n;
}(), msdfFrag = `// Pixi texture info\r
varying vec2 vTextureCoord;\r
uniform sampler2D uSampler;\r
\r
// Tint\r
uniform vec4 uColor;\r
\r
// on 2D applications fwidth is screenScale / glyphAtlasScale * distanceFieldRange\r
uniform float uFWidth;\r
\r
void main(void) {\r
\r
  // To stack MSDF and SDF we need a non-pre-multiplied-alpha texture.\r
  vec4 texColor = texture2D(uSampler, vTextureCoord);\r
\r
  // MSDF\r
  float median = texColor.r + texColor.g + texColor.b -\r
                  min(texColor.r, min(texColor.g, texColor.b)) -\r
                  max(texColor.r, max(texColor.g, texColor.b));\r
  // SDF\r
  median = min(median, texColor.a);\r
\r
  float screenPxDistance = uFWidth * (median - 0.5);\r
  float alpha = clamp(screenPxDistance + 0.5, 0.0, 1.0);\r
\r
  // NPM Textures, NPM outputs\r
  gl_FragColor = vec4(uColor.rgb, uColor.a * alpha);\r
\r
}\r
`, msdfVert = `// Mesh material default fragment\r
attribute vec2 aVertexPosition;\r
attribute vec2 aTextureCoord;\r
\r
uniform mat3 projectionMatrix;\r
uniform mat3 translationMatrix;\r
uniform mat3 uTextureMatrix;\r
\r
varying vec2 vTextureCoord;\r
\r
void main(void)\r
{\r
    gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\r
\r
    vTextureCoord = (uTextureMatrix * vec3(aTextureCoord, 1.0)).xy;\r
}\r
`, pageMeshDataDefaultPageMeshData = [], pageMeshDataMSDFPageMeshData = [], charRenderDataPool = [];
(function(n) {
  __extends$f(t, n);
  function t(e, o) {
    o === void 0 && (o = {});
    var R = n.call(this) || this;
    R._tint = 16777215;
    var N = Object.assign({}, t.styleDefaults, o), M = N.align, D = N.tint, L = N.maxWidth, B = N.letterSpacing, $ = N.fontName, k = N.fontSize;
    if (!BitmapFont.available[$])
      throw new Error('Missing BitmapFont "' + $ + '"');
    return R._activePagesMeshData = [], R._textWidth = 0, R._textHeight = 0, R._align = M, R._tint = D, R._fontName = $, R._fontSize = k || BitmapFont.available[$].size, R.text = e, R._maxWidth = L, R._maxLineHeight = 0, R._letterSpacing = B, R._anchor = new ObservablePoint(function() {
      R.dirty = !0;
    }, R, 0, 0), R._roundPixels = settings$1.ROUND_PIXELS, R.dirty = !0, R._resolution = settings$1.RESOLUTION, R._autoResolution = !0, R._textureCache = {}, R;
  }
  return t.prototype.updateText = function() {
    for (var e, o = BitmapFont.available[this._fontName], R = this._fontSize / o.size, N = new Point(), M = [], D = [], L = [], B = this._text.replace(/(?:\r\n|\r)/g, `
`) || " ", $ = splitTextToCharacters(B), k = this._maxWidth * o.size / this._fontSize, U = o.distanceFieldType === "none" ? pageMeshDataDefaultPageMeshData : pageMeshDataMSDFPageMeshData, z = null, X = 0, V = 0, W = 0, Y = -1, q = 0, Z = 0, J = 0, Q = 0, K = 0; K < $.length; K++) {
      var rt = $[K], tt = extractCharCode(rt);
      if (/(?:\s)/.test(rt) && (Y = K, q = X, Q++), rt === "\r" || rt === `
`) {
        D.push(X), L.push(-1), V = Math.max(V, X), ++W, ++Z, N.x = 0, N.y += o.lineHeight, z = null, Q = 0;
        continue;
      }
      var nt = o.chars[tt];
      if (!!nt) {
        z && nt.kerning[z] && (N.x += nt.kerning[z]);
        var at = charRenderDataPool.pop() || {
          texture: Texture.EMPTY,
          line: 0,
          charCode: 0,
          prevSpaces: 0,
          position: new Point()
        };
        at.texture = nt.texture, at.line = W, at.charCode = tt, at.position.x = N.x + nt.xOffset + this._letterSpacing / 2, at.position.y = N.y + nt.yOffset, at.prevSpaces = Q, M.push(at), X = at.position.x + Math.max(nt.xAdvance - nt.xOffset, nt.texture.orig.width), N.x += nt.xAdvance + this._letterSpacing, J = Math.max(J, nt.yOffset + nt.texture.height), z = tt, Y !== -1 && k > 0 && N.x > k && (++Z, removeItems(M, 1 + Y - Z, 1 + K - Y), K = Y, Y = -1, D.push(q), L.push(M.length > 0 ? M[M.length - 1].prevSpaces : 0), V = Math.max(V, q), W++, N.x = 0, N.y += o.lineHeight, z = null, Q = 0);
      }
    }
    var lt = $[$.length - 1];
    lt !== "\r" && lt !== `
` && (/(?:\s)/.test(lt) && (X = q), D.push(X), V = Math.max(V, X), L.push(-1));
    for (var ut = [], K = 0; K <= W; K++) {
      var dt = 0;
      this._align === "right" ? dt = V - D[K] : this._align === "center" ? dt = (V - D[K]) / 2 : this._align === "justify" && (dt = L[K] < 0 ? 0 : (V - D[K]) / L[K]), ut.push(dt);
    }
    for (var yt = M.length, pt = {}, gt = [], xt = this._activePagesMeshData, K = 0; K < xt.length; K++)
      U.push(xt[K]);
    for (var K = 0; K < yt; K++) {
      var Lt = M[K].texture, mt = Lt.baseTexture.uid;
      if (!pt[mt]) {
        var ct = U.pop();
        if (!ct) {
          var vt = new MeshGeometry(), Tt = void 0, Pt = void 0;
          o.distanceFieldType === "none" ? (Tt = new MeshMaterial(Texture.EMPTY), Pt = BLEND_MODES$5.NORMAL) : (Tt = new MeshMaterial(Texture.EMPTY, { program: Program.from(msdfVert, msdfFrag), uniforms: { uFWidth: 0 } }), Pt = BLEND_MODES$5.NORMAL_NPM);
          var wt = new Mesh(vt, Tt);
          wt.blendMode = Pt, ct = {
            index: 0,
            indexCount: 0,
            vertexCount: 0,
            uvsCount: 0,
            total: 0,
            mesh: wt,
            vertices: null,
            uvs: null,
            indices: null
          };
        }
        ct.index = 0, ct.indexCount = 0, ct.vertexCount = 0, ct.uvsCount = 0, ct.total = 0;
        var Mt = this._textureCache;
        Mt[mt] = Mt[mt] || new Texture(Lt.baseTexture), ct.mesh.texture = Mt[mt], ct.mesh.tint = this._tint, gt.push(ct), pt[mt] = ct;
      }
      pt[mt].total++;
    }
    for (var K = 0; K < xt.length; K++)
      gt.indexOf(xt[K]) === -1 && this.removeChild(xt[K].mesh);
    for (var K = 0; K < gt.length; K++)
      gt[K].mesh.parent !== this && this.addChild(gt[K].mesh);
    this._activePagesMeshData = gt;
    for (var K in pt) {
      var ct = pt[K], ht = ct.total;
      if (!(((e = ct.indices) === null || e === void 0 ? void 0 : e.length) > 6 * ht) || ct.vertices.length < Mesh.BATCHABLE_SIZE * 2)
        ct.vertices = new Float32Array(4 * 2 * ht), ct.uvs = new Float32Array(4 * 2 * ht), ct.indices = new Uint16Array(6 * ht);
      else
        for (var $t = ct.total, At = ct.vertices, kt = $t * 4 * 2; kt < At.length; kt++)
          At[kt] = 0;
      ct.mesh.size = 6 * ht;
    }
    for (var K = 0; K < yt; K++) {
      var rt = M[K], Ot = rt.position.x + ut[rt.line] * (this._align === "justify" ? rt.prevSpaces : 1);
      this._roundPixels && (Ot = Math.round(Ot));
      var _t = Ot * R, Gt = rt.position.y * R, Lt = rt.texture, St = pt[Lt.baseTexture.uid], Et = Lt.frame, Rt = Lt._uvs, Dt = St.index++;
      St.indices[Dt * 6 + 0] = 0 + Dt * 4, St.indices[Dt * 6 + 1] = 1 + Dt * 4, St.indices[Dt * 6 + 2] = 2 + Dt * 4, St.indices[Dt * 6 + 3] = 0 + Dt * 4, St.indices[Dt * 6 + 4] = 2 + Dt * 4, St.indices[Dt * 6 + 5] = 3 + Dt * 4, St.vertices[Dt * 8 + 0] = _t, St.vertices[Dt * 8 + 1] = Gt, St.vertices[Dt * 8 + 2] = _t + Et.width * R, St.vertices[Dt * 8 + 3] = Gt, St.vertices[Dt * 8 + 4] = _t + Et.width * R, St.vertices[Dt * 8 + 5] = Gt + Et.height * R, St.vertices[Dt * 8 + 6] = _t, St.vertices[Dt * 8 + 7] = Gt + Et.height * R, St.uvs[Dt * 8 + 0] = Rt.x0, St.uvs[Dt * 8 + 1] = Rt.y0, St.uvs[Dt * 8 + 2] = Rt.x1, St.uvs[Dt * 8 + 3] = Rt.y1, St.uvs[Dt * 8 + 4] = Rt.x2, St.uvs[Dt * 8 + 5] = Rt.y2, St.uvs[Dt * 8 + 6] = Rt.x3, St.uvs[Dt * 8 + 7] = Rt.y3;
    }
    this._textWidth = V * R, this._textHeight = (N.y + o.lineHeight) * R;
    for (var K in pt) {
      var ct = pt[K];
      if (this.anchor.x !== 0 || this.anchor.y !== 0)
        for (var Ct = 0, Zt = this._textWidth * this.anchor.x, Yt = this._textHeight * this.anchor.y, se = 0; se < ct.total; se++)
          ct.vertices[Ct++] -= Zt, ct.vertices[Ct++] -= Yt, ct.vertices[Ct++] -= Zt, ct.vertices[Ct++] -= Yt, ct.vertices[Ct++] -= Zt, ct.vertices[Ct++] -= Yt, ct.vertices[Ct++] -= Zt, ct.vertices[Ct++] -= Yt;
      this._maxLineHeight = J * R;
      var xe = ct.mesh.geometry.getBuffer("aVertexPosition"), Oe = ct.mesh.geometry.getBuffer("aTextureCoord"), Qt = ct.mesh.geometry.getIndex();
      xe.data = ct.vertices, Oe.data = ct.uvs, Qt.data = ct.indices, xe.update(), Oe.update(), Qt.update();
    }
    for (var K = 0; K < M.length; K++)
      charRenderDataPool.push(M[K]);
  }, t.prototype.updateTransform = function() {
    this.validate(), this.containerUpdateTransform();
  }, t.prototype._render = function(e) {
    this._autoResolution && this._resolution !== e.resolution && (this._resolution = e.resolution, this.dirty = !0);
    var o = BitmapFont.available[this._fontName], R = o.distanceFieldRange, N = o.distanceFieldType, M = o.size;
    if (N !== "none")
      for (var D = this.worldTransform, L = D.a, B = D.b, $ = D.c, k = D.d, U = Math.sqrt(L * L + B * B), z = Math.sqrt($ * $ + k * k), X = (Math.abs(U) + Math.abs(z)) / 2, V = this._fontSize / M, W = 0, Y = this._activePagesMeshData; W < Y.length; W++) {
        var q = Y[W];
        q.mesh.shader.uniforms.uFWidth = X * R * V * this._resolution;
      }
    n.prototype._render.call(this, e);
  }, t.prototype.getLocalBounds = function() {
    return this.validate(), n.prototype.getLocalBounds.call(this);
  }, t.prototype.validate = function() {
    this.dirty && (this.updateText(), this.dirty = !1);
  }, Object.defineProperty(t.prototype, "tint", {
    get: function() {
      return this._tint;
    },
    set: function(e) {
      if (this._tint !== e) {
        this._tint = e;
        for (var o = 0; o < this._activePagesMeshData.length; o++)
          this._activePagesMeshData[o].mesh.tint = e;
      }
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(t.prototype, "align", {
    get: function() {
      return this._align;
    },
    set: function(e) {
      this._align !== e && (this._align = e, this.dirty = !0);
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(t.prototype, "fontName", {
    get: function() {
      return this._fontName;
    },
    set: function(e) {
      if (!BitmapFont.available[e])
        throw new Error('Missing BitmapFont "' + e + '"');
      this._fontName !== e && (this._fontName = e, this.dirty = !0);
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(t.prototype, "fontSize", {
    get: function() {
      return this._fontSize;
    },
    set: function(e) {
      this._fontSize !== e && (this._fontSize = e, this.dirty = !0);
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(t.prototype, "anchor", {
    get: function() {
      return this._anchor;
    },
    set: function(e) {
      typeof e == "number" ? this._anchor.set(e) : this._anchor.copyFrom(e);
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(t.prototype, "text", {
    get: function() {
      return this._text;
    },
    set: function(e) {
      e = String(e == null ? "" : e), this._text !== e && (this._text = e, this.dirty = !0);
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(t.prototype, "maxWidth", {
    get: function() {
      return this._maxWidth;
    },
    set: function(e) {
      this._maxWidth !== e && (this._maxWidth = e, this.dirty = !0);
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(t.prototype, "maxLineHeight", {
    get: function() {
      return this.validate(), this._maxLineHeight;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(t.prototype, "textWidth", {
    get: function() {
      return this.validate(), this._textWidth;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(t.prototype, "letterSpacing", {
    get: function() {
      return this._letterSpacing;
    },
    set: function(e) {
      this._letterSpacing !== e && (this._letterSpacing = e, this.dirty = !0);
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(t.prototype, "roundPixels", {
    get: function() {
      return this._roundPixels;
    },
    set: function(e) {
      e !== this._roundPixels && (this._roundPixels = e, this.dirty = !0);
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(t.prototype, "textHeight", {
    get: function() {
      return this.validate(), this._textHeight;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(t.prototype, "resolution", {
    get: function() {
      return this._resolution;
    },
    set: function(e) {
      this._autoResolution = !1, this._resolution !== e && (this._resolution = e, this.dirty = !0);
    },
    enumerable: !1,
    configurable: !0
  }), t.prototype.destroy = function(e) {
    var o = this._textureCache;
    for (var R in o) {
      var N = o[R];
      N.destroy(), delete o[R];
    }
    this._textureCache = null, n.prototype.destroy.call(this, e);
  }, t.styleDefaults = {
    align: "left",
    tint: 16777215,
    maxWidth: 0,
    letterSpacing: 0
  }, t;
})(Container);
var BitmapFontLoader = function() {
  function n() {
  }
  return n.add = function() {
    LoaderResource.setExtensionXhrType("fnt", LoaderResource.XHR_RESPONSE_TYPE.TEXT);
  }, n.use = function(t, e) {
    var o = autoDetectFormat(t.data);
    if (!o) {
      e();
      return;
    }
    for (var R = n.getBaseUrl(this, t), N = o.parse(t.data), M = {}, D = function(V) {
      M[V.metadata.pageFile] = V.texture, Object.keys(M).length === N.page.length && (t.bitmapFont = BitmapFont.install(N, M, !0), e());
    }, L = 0; L < N.page.length; ++L) {
      var B = N.page[L].file, $ = R + B, k = !1;
      for (var U in this.resources) {
        var z = this.resources[U];
        if (z.url === $) {
          z.metadata.pageFile = B, z.texture ? D(z) : z.onAfterMiddleware.add(D), k = !0;
          break;
        }
      }
      if (!k) {
        var X = {
          crossOrigin: t.crossOrigin,
          loadType: LoaderResource.LOAD_TYPE.IMAGE,
          metadata: Object.assign({ pageFile: B }, t.metadata.imageMetadata),
          parentResource: t
        };
        this.add($, X, D);
      }
    }
  }, n.getBaseUrl = function(t, e) {
    var o = e.isDataUrl ? "" : n.dirname(e.url);
    return e.isDataUrl && (o === "." && (o = ""), t.baseUrl && o && t.baseUrl.charAt(t.baseUrl.length - 1) === "/" && (o += "/")), o = o.replace(t.baseUrl, ""), o && o.charAt(o.length - 1) !== "/" && (o += "/"), o;
  }, n.dirname = function(t) {
    var e = t.replace(/\\/g, "/").replace(/\/$/, "").replace(/\/[^\/]*$/, "");
    return e === t ? "." : e === "" ? "/" : e;
  }, n.extension = ExtensionType.Loader, n;
}();
/*!
 * @pixi/filter-alpha - v6.5.2
 * Compiled Wed, 24 Aug 2022 13:51:19 UTC
 *
 * @pixi/filter-alpha is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var extendStatics$e = function(n, t) {
  return extendStatics$e = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(e, o) {
    e.__proto__ = o;
  } || function(e, o) {
    for (var R in o)
      o.hasOwnProperty(R) && (e[R] = o[R]);
  }, extendStatics$e(n, t);
};
function __extends$e(n, t) {
  extendStatics$e(n, t);
  function e() {
    this.constructor = n;
  }
  n.prototype = t === null ? Object.create(t) : (e.prototype = t.prototype, new e());
}
var fragment$4 = `varying vec2 vTextureCoord;

uniform sampler2D uSampler;
uniform float uAlpha;

void main(void)
{
   gl_FragColor = texture2D(uSampler, vTextureCoord) * uAlpha;
}
`;
(function(n) {
  __extends$e(t, n);
  function t(e) {
    e === void 0 && (e = 1);
    var o = n.call(this, defaultVertex$1, fragment$4, { uAlpha: 1 }) || this;
    return o.alpha = e, o;
  }
  return Object.defineProperty(t.prototype, "alpha", {
    get: function() {
      return this.uniforms.uAlpha;
    },
    set: function(e) {
      this.uniforms.uAlpha = e;
    },
    enumerable: !1,
    configurable: !0
  }), t;
})(Filter);
/*!
 * @pixi/filter-blur - v6.5.2
 * Compiled Wed, 24 Aug 2022 13:51:19 UTC
 *
 * @pixi/filter-blur is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var extendStatics$d = function(n, t) {
  return extendStatics$d = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(e, o) {
    e.__proto__ = o;
  } || function(e, o) {
    for (var R in o)
      o.hasOwnProperty(R) && (e[R] = o[R]);
  }, extendStatics$d(n, t);
};
function __extends$d(n, t) {
  extendStatics$d(n, t);
  function e() {
    this.constructor = n;
  }
  n.prototype = t === null ? Object.create(t) : (e.prototype = t.prototype, new e());
}
var vertTemplate = `
    attribute vec2 aVertexPosition;

    uniform mat3 projectionMatrix;

    uniform float strength;

    varying vec2 vBlurTexCoords[%size%];

    uniform vec4 inputSize;
    uniform vec4 outputFrame;

    vec4 filterVertexPosition( void )
    {
        vec2 position = aVertexPosition * max(outputFrame.zw, vec2(0.)) + outputFrame.xy;

        return vec4((projectionMatrix * vec3(position, 1.0)).xy, 0.0, 1.0);
    }

    vec2 filterTextureCoord( void )
    {
        return aVertexPosition * (outputFrame.zw * inputSize.zw);
    }

    void main(void)
    {
        gl_Position = filterVertexPosition();

        vec2 textureCoord = filterTextureCoord();
        %blur%
    }`;
function generateBlurVertSource(n, t) {
  var e = Math.ceil(n / 2), o = vertTemplate, R = "", N;
  t ? N = "vBlurTexCoords[%index%] =  textureCoord + vec2(%sampleIndex% * strength, 0.0);" : N = "vBlurTexCoords[%index%] =  textureCoord + vec2(0.0, %sampleIndex% * strength);";
  for (var M = 0; M < n; M++) {
    var D = N.replace("%index%", M.toString());
    D = D.replace("%sampleIndex%", M - (e - 1) + ".0"), R += D, R += `
`;
  }
  return o = o.replace("%blur%", R), o = o.replace("%size%", n.toString()), o;
}
var GAUSSIAN_VALUES = {
  5: [0.153388, 0.221461, 0.250301],
  7: [0.071303, 0.131514, 0.189879, 0.214607],
  9: [0.028532, 0.067234, 0.124009, 0.179044, 0.20236],
  11: [93e-4, 0.028002, 0.065984, 0.121703, 0.175713, 0.198596],
  13: [2406e-6, 9255e-6, 0.027867, 0.065666, 0.121117, 0.174868, 0.197641],
  15: [489e-6, 2403e-6, 9246e-6, 0.02784, 0.065602, 0.120999, 0.174697, 0.197448]
}, fragTemplate = [
  "varying vec2 vBlurTexCoords[%size%];",
  "uniform sampler2D uSampler;",
  "void main(void)",
  "{",
  "    gl_FragColor = vec4(0.0);",
  "    %blur%",
  "}"
].join(`
`);
function generateBlurFragSource(n) {
  for (var t = GAUSSIAN_VALUES[n], e = t.length, o = fragTemplate, R = "", N = "gl_FragColor += texture2D(uSampler, vBlurTexCoords[%index%]) * %value%;", M, D = 0; D < n; D++) {
    var L = N.replace("%index%", D.toString());
    M = D, D >= e && (M = n - D - 1), L = L.replace("%value%", t[M].toString()), R += L, R += `
`;
  }
  return o = o.replace("%blur%", R), o = o.replace("%size%", n.toString()), o;
}
/*!
 * @pixi/constants - v6.5.2
 * Compiled Wed, 24 Aug 2022 13:51:19 UTC
 *
 * @pixi/constants is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
var ENV$3;
(function(n) {
  n[n.WEBGL_LEGACY = 0] = "WEBGL_LEGACY", n[n.WEBGL = 1] = "WEBGL", n[n.WEBGL2 = 2] = "WEBGL2";
})(ENV$3 || (ENV$3 = {}));
var RENDERER_TYPE$3;
(function(n) {
  n[n.UNKNOWN = 0] = "UNKNOWN", n[n.WEBGL = 1] = "WEBGL", n[n.CANVAS = 2] = "CANVAS";
})(RENDERER_TYPE$3 || (RENDERER_TYPE$3 = {}));
var BUFFER_BITS$3;
(function(n) {
  n[n.COLOR = 16384] = "COLOR", n[n.DEPTH = 256] = "DEPTH", n[n.STENCIL = 1024] = "STENCIL";
})(BUFFER_BITS$3 || (BUFFER_BITS$3 = {}));
var BLEND_MODES$3;
(function(n) {
  n[n.NORMAL = 0] = "NORMAL", n[n.ADD = 1] = "ADD", n[n.MULTIPLY = 2] = "MULTIPLY", n[n.SCREEN = 3] = "SCREEN", n[n.OVERLAY = 4] = "OVERLAY", n[n.DARKEN = 5] = "DARKEN", n[n.LIGHTEN = 6] = "LIGHTEN", n[n.COLOR_DODGE = 7] = "COLOR_DODGE", n[n.COLOR_BURN = 8] = "COLOR_BURN", n[n.HARD_LIGHT = 9] = "HARD_LIGHT", n[n.SOFT_LIGHT = 10] = "SOFT_LIGHT", n[n.DIFFERENCE = 11] = "DIFFERENCE", n[n.EXCLUSION = 12] = "EXCLUSION", n[n.HUE = 13] = "HUE", n[n.SATURATION = 14] = "SATURATION", n[n.COLOR = 15] = "COLOR", n[n.LUMINOSITY = 16] = "LUMINOSITY", n[n.NORMAL_NPM = 17] = "NORMAL_NPM", n[n.ADD_NPM = 18] = "ADD_NPM", n[n.SCREEN_NPM = 19] = "SCREEN_NPM", n[n.NONE = 20] = "NONE", n[n.SRC_OVER = 0] = "SRC_OVER", n[n.SRC_IN = 21] = "SRC_IN", n[n.SRC_OUT = 22] = "SRC_OUT", n[n.SRC_ATOP = 23] = "SRC_ATOP", n[n.DST_OVER = 24] = "DST_OVER", n[n.DST_IN = 25] = "DST_IN", n[n.DST_OUT = 26] = "DST_OUT", n[n.DST_ATOP = 27] = "DST_ATOP", n[n.ERASE = 26] = "ERASE", n[n.SUBTRACT = 28] = "SUBTRACT", n[n.XOR = 29] = "XOR";
})(BLEND_MODES$3 || (BLEND_MODES$3 = {}));
var DRAW_MODES$3;
(function(n) {
  n[n.POINTS = 0] = "POINTS", n[n.LINES = 1] = "LINES", n[n.LINE_LOOP = 2] = "LINE_LOOP", n[n.LINE_STRIP = 3] = "LINE_STRIP", n[n.TRIANGLES = 4] = "TRIANGLES", n[n.TRIANGLE_STRIP = 5] = "TRIANGLE_STRIP", n[n.TRIANGLE_FAN = 6] = "TRIANGLE_FAN";
})(DRAW_MODES$3 || (DRAW_MODES$3 = {}));
var FORMATS$3;
(function(n) {
  n[n.RGBA = 6408] = "RGBA", n[n.RGB = 6407] = "RGB", n[n.RG = 33319] = "RG", n[n.RED = 6403] = "RED", n[n.RGBA_INTEGER = 36249] = "RGBA_INTEGER", n[n.RGB_INTEGER = 36248] = "RGB_INTEGER", n[n.RG_INTEGER = 33320] = "RG_INTEGER", n[n.RED_INTEGER = 36244] = "RED_INTEGER", n[n.ALPHA = 6406] = "ALPHA", n[n.LUMINANCE = 6409] = "LUMINANCE", n[n.LUMINANCE_ALPHA = 6410] = "LUMINANCE_ALPHA", n[n.DEPTH_COMPONENT = 6402] = "DEPTH_COMPONENT", n[n.DEPTH_STENCIL = 34041] = "DEPTH_STENCIL";
})(FORMATS$3 || (FORMATS$3 = {}));
var TARGETS$3;
(function(n) {
  n[n.TEXTURE_2D = 3553] = "TEXTURE_2D", n[n.TEXTURE_CUBE_MAP = 34067] = "TEXTURE_CUBE_MAP", n[n.TEXTURE_2D_ARRAY = 35866] = "TEXTURE_2D_ARRAY", n[n.TEXTURE_CUBE_MAP_POSITIVE_X = 34069] = "TEXTURE_CUBE_MAP_POSITIVE_X", n[n.TEXTURE_CUBE_MAP_NEGATIVE_X = 34070] = "TEXTURE_CUBE_MAP_NEGATIVE_X", n[n.TEXTURE_CUBE_MAP_POSITIVE_Y = 34071] = "TEXTURE_CUBE_MAP_POSITIVE_Y", n[n.TEXTURE_CUBE_MAP_NEGATIVE_Y = 34072] = "TEXTURE_CUBE_MAP_NEGATIVE_Y", n[n.TEXTURE_CUBE_MAP_POSITIVE_Z = 34073] = "TEXTURE_CUBE_MAP_POSITIVE_Z", n[n.TEXTURE_CUBE_MAP_NEGATIVE_Z = 34074] = "TEXTURE_CUBE_MAP_NEGATIVE_Z";
})(TARGETS$3 || (TARGETS$3 = {}));
var TYPES$3;
(function(n) {
  n[n.UNSIGNED_BYTE = 5121] = "UNSIGNED_BYTE", n[n.UNSIGNED_SHORT = 5123] = "UNSIGNED_SHORT", n[n.UNSIGNED_SHORT_5_6_5 = 33635] = "UNSIGNED_SHORT_5_6_5", n[n.UNSIGNED_SHORT_4_4_4_4 = 32819] = "UNSIGNED_SHORT_4_4_4_4", n[n.UNSIGNED_SHORT_5_5_5_1 = 32820] = "UNSIGNED_SHORT_5_5_5_1", n[n.UNSIGNED_INT = 5125] = "UNSIGNED_INT", n[n.UNSIGNED_INT_10F_11F_11F_REV = 35899] = "UNSIGNED_INT_10F_11F_11F_REV", n[n.UNSIGNED_INT_2_10_10_10_REV = 33640] = "UNSIGNED_INT_2_10_10_10_REV", n[n.UNSIGNED_INT_24_8 = 34042] = "UNSIGNED_INT_24_8", n[n.UNSIGNED_INT_5_9_9_9_REV = 35902] = "UNSIGNED_INT_5_9_9_9_REV", n[n.BYTE = 5120] = "BYTE", n[n.SHORT = 5122] = "SHORT", n[n.INT = 5124] = "INT", n[n.FLOAT = 5126] = "FLOAT", n[n.FLOAT_32_UNSIGNED_INT_24_8_REV = 36269] = "FLOAT_32_UNSIGNED_INT_24_8_REV", n[n.HALF_FLOAT = 36193] = "HALF_FLOAT";
})(TYPES$3 || (TYPES$3 = {}));
var SAMPLER_TYPES$3;
(function(n) {
  n[n.FLOAT = 0] = "FLOAT", n[n.INT = 1] = "INT", n[n.UINT = 2] = "UINT";
})(SAMPLER_TYPES$3 || (SAMPLER_TYPES$3 = {}));
var SCALE_MODES$3;
(function(n) {
  n[n.NEAREST = 0] = "NEAREST", n[n.LINEAR = 1] = "LINEAR";
})(SCALE_MODES$3 || (SCALE_MODES$3 = {}));
var WRAP_MODES$3;
(function(n) {
  n[n.CLAMP = 33071] = "CLAMP", n[n.REPEAT = 10497] = "REPEAT", n[n.MIRRORED_REPEAT = 33648] = "MIRRORED_REPEAT";
})(WRAP_MODES$3 || (WRAP_MODES$3 = {}));
var MIPMAP_MODES$3;
(function(n) {
  n[n.OFF = 0] = "OFF", n[n.POW2 = 1] = "POW2", n[n.ON = 2] = "ON", n[n.ON_MANUAL = 3] = "ON_MANUAL";
})(MIPMAP_MODES$3 || (MIPMAP_MODES$3 = {}));
var ALPHA_MODES$3;
(function(n) {
  n[n.NPM = 0] = "NPM", n[n.UNPACK = 1] = "UNPACK", n[n.PMA = 2] = "PMA", n[n.NO_PREMULTIPLIED_ALPHA = 0] = "NO_PREMULTIPLIED_ALPHA", n[n.PREMULTIPLY_ON_UPLOAD = 1] = "PREMULTIPLY_ON_UPLOAD", n[n.PREMULTIPLY_ALPHA = 2] = "PREMULTIPLY_ALPHA", n[n.PREMULTIPLIED_ALPHA = 2] = "PREMULTIPLIED_ALPHA";
})(ALPHA_MODES$3 || (ALPHA_MODES$3 = {}));
var CLEAR_MODES$3;
(function(n) {
  n[n.NO = 0] = "NO", n[n.YES = 1] = "YES", n[n.AUTO = 2] = "AUTO", n[n.BLEND = 0] = "BLEND", n[n.CLEAR = 1] = "CLEAR", n[n.BLIT = 2] = "BLIT";
})(CLEAR_MODES$3 || (CLEAR_MODES$3 = {}));
var GC_MODES$3;
(function(n) {
  n[n.AUTO = 0] = "AUTO", n[n.MANUAL = 1] = "MANUAL";
})(GC_MODES$3 || (GC_MODES$3 = {}));
var PRECISION$3;
(function(n) {
  n.LOW = "lowp", n.MEDIUM = "mediump", n.HIGH = "highp";
})(PRECISION$3 || (PRECISION$3 = {}));
var MASK_TYPES$3;
(function(n) {
  n[n.NONE = 0] = "NONE", n[n.SCISSOR = 1] = "SCISSOR", n[n.STENCIL = 2] = "STENCIL", n[n.SPRITE = 3] = "SPRITE", n[n.COLOR = 4] = "COLOR";
})(MASK_TYPES$3 || (MASK_TYPES$3 = {}));
var COLOR_MASK_BITS$3;
(function(n) {
  n[n.RED = 1] = "RED", n[n.GREEN = 2] = "GREEN", n[n.BLUE = 4] = "BLUE", n[n.ALPHA = 8] = "ALPHA";
})(COLOR_MASK_BITS$3 || (COLOR_MASK_BITS$3 = {}));
var MSAA_QUALITY$3;
(function(n) {
  n[n.NONE = 0] = "NONE", n[n.LOW = 2] = "LOW", n[n.MEDIUM = 4] = "MEDIUM", n[n.HIGH = 8] = "HIGH";
})(MSAA_QUALITY$3 || (MSAA_QUALITY$3 = {}));
var BUFFER_TYPE$3;
(function(n) {
  n[n.ELEMENT_ARRAY_BUFFER = 34963] = "ELEMENT_ARRAY_BUFFER", n[n.ARRAY_BUFFER = 34962] = "ARRAY_BUFFER", n[n.UNIFORM_BUFFER = 35345] = "UNIFORM_BUFFER";
})(BUFFER_TYPE$3 || (BUFFER_TYPE$3 = {}));
var BlurFilterPass = function(n) {
  __extends$d(t, n);
  function t(e, o, R, N, M) {
    o === void 0 && (o = 8), R === void 0 && (R = 4), N === void 0 && (N = settings$1.FILTER_RESOLUTION), M === void 0 && (M = 5);
    var D = this, L = generateBlurVertSource(M, e), B = generateBlurFragSource(M);
    return D = n.call(
      this,
      L,
      B
    ) || this, D.horizontal = e, D.resolution = N, D._quality = 0, D.quality = R, D.blur = o, D;
  }
  return t.prototype.apply = function(e, o, R, N) {
    if (R ? this.horizontal ? this.uniforms.strength = 1 / R.width * (R.width / o.width) : this.uniforms.strength = 1 / R.height * (R.height / o.height) : this.horizontal ? this.uniforms.strength = 1 / e.renderer.width * (e.renderer.width / o.width) : this.uniforms.strength = 1 / e.renderer.height * (e.renderer.height / o.height), this.uniforms.strength *= this.strength, this.uniforms.strength /= this.passes, this.passes === 1)
      e.applyFilter(this, o, R, N);
    else {
      var M = e.getFilterTexture(), D = e.renderer, L = o, B = M;
      this.state.blend = !1, e.applyFilter(this, L, B, CLEAR_MODES$3.CLEAR);
      for (var $ = 1; $ < this.passes - 1; $++) {
        e.bindAndClear(L, CLEAR_MODES$3.BLIT), this.uniforms.uSampler = B;
        var k = B;
        B = L, L = k, D.shader.bind(this), D.geometry.draw(5);
      }
      this.state.blend = !0, e.applyFilter(this, B, R, N), e.returnFilterTexture(M);
    }
  }, Object.defineProperty(t.prototype, "blur", {
    get: function() {
      return this.strength;
    },
    set: function(e) {
      this.padding = 1 + Math.abs(e) * 2, this.strength = e;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(t.prototype, "quality", {
    get: function() {
      return this._quality;
    },
    set: function(e) {
      this._quality = e, this.passes = e;
    },
    enumerable: !1,
    configurable: !0
  }), t;
}(Filter);
(function(n) {
  __extends$d(t, n);
  function t(e, o, R, N) {
    e === void 0 && (e = 8), o === void 0 && (o = 4), R === void 0 && (R = settings$1.FILTER_RESOLUTION), N === void 0 && (N = 5);
    var M = n.call(this) || this;
    return M.blurXFilter = new BlurFilterPass(!0, e, o, R, N), M.blurYFilter = new BlurFilterPass(!1, e, o, R, N), M.resolution = R, M.quality = o, M.blur = e, M.repeatEdgePixels = !1, M;
  }
  return t.prototype.apply = function(e, o, R, N) {
    var M = Math.abs(this.blurXFilter.strength), D = Math.abs(this.blurYFilter.strength);
    if (M && D) {
      var L = e.getFilterTexture();
      this.blurXFilter.apply(e, o, L, CLEAR_MODES$3.CLEAR), this.blurYFilter.apply(e, L, R, N), e.returnFilterTexture(L);
    } else
      D ? this.blurYFilter.apply(e, o, R, N) : this.blurXFilter.apply(e, o, R, N);
  }, t.prototype.updatePadding = function() {
    this._repeatEdgePixels ? this.padding = 0 : this.padding = Math.max(Math.abs(this.blurXFilter.strength), Math.abs(this.blurYFilter.strength)) * 2;
  }, Object.defineProperty(t.prototype, "blur", {
    get: function() {
      return this.blurXFilter.blur;
    },
    set: function(e) {
      this.blurXFilter.blur = this.blurYFilter.blur = e, this.updatePadding();
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(t.prototype, "quality", {
    get: function() {
      return this.blurXFilter.quality;
    },
    set: function(e) {
      this.blurXFilter.quality = this.blurYFilter.quality = e;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(t.prototype, "blurX", {
    get: function() {
      return this.blurXFilter.blur;
    },
    set: function(e) {
      this.blurXFilter.blur = e, this.updatePadding();
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(t.prototype, "blurY", {
    get: function() {
      return this.blurYFilter.blur;
    },
    set: function(e) {
      this.blurYFilter.blur = e, this.updatePadding();
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(t.prototype, "blendMode", {
    get: function() {
      return this.blurYFilter.blendMode;
    },
    set: function(e) {
      this.blurYFilter.blendMode = e;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(t.prototype, "repeatEdgePixels", {
    get: function() {
      return this._repeatEdgePixels;
    },
    set: function(e) {
      this._repeatEdgePixels = e, this.updatePadding();
    },
    enumerable: !1,
    configurable: !0
  }), t;
})(Filter);
/*!
 * @pixi/filter-color-matrix - v6.5.2
 * Compiled Wed, 24 Aug 2022 13:51:19 UTC
 *
 * @pixi/filter-color-matrix is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var extendStatics$c = function(n, t) {
  return extendStatics$c = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(e, o) {
    e.__proto__ = o;
  } || function(e, o) {
    for (var R in o)
      o.hasOwnProperty(R) && (e[R] = o[R]);
  }, extendStatics$c(n, t);
};
function __extends$c(n, t) {
  extendStatics$c(n, t);
  function e() {
    this.constructor = n;
  }
  n.prototype = t === null ? Object.create(t) : (e.prototype = t.prototype, new e());
}
var fragment$3 = `varying vec2 vTextureCoord;
uniform sampler2D uSampler;
uniform float m[20];
uniform float uAlpha;

void main(void)
{
    vec4 c = texture2D(uSampler, vTextureCoord);

    if (uAlpha == 0.0) {
        gl_FragColor = c;
        return;
    }

    // Un-premultiply alpha before applying the color matrix. See issue #3539.
    if (c.a > 0.0) {
      c.rgb /= c.a;
    }

    vec4 result;

    result.r = (m[0] * c.r);
        result.r += (m[1] * c.g);
        result.r += (m[2] * c.b);
        result.r += (m[3] * c.a);
        result.r += m[4];

    result.g = (m[5] * c.r);
        result.g += (m[6] * c.g);
        result.g += (m[7] * c.b);
        result.g += (m[8] * c.a);
        result.g += m[9];

    result.b = (m[10] * c.r);
       result.b += (m[11] * c.g);
       result.b += (m[12] * c.b);
       result.b += (m[13] * c.a);
       result.b += m[14];

    result.a = (m[15] * c.r);
       result.a += (m[16] * c.g);
       result.a += (m[17] * c.b);
       result.a += (m[18] * c.a);
       result.a += m[19];

    vec3 rgb = mix(c.rgb, result.rgb, uAlpha);

    // Premultiply alpha again.
    rgb *= result.a;

    gl_FragColor = vec4(rgb, result.a);
}
`, ColorMatrixFilter = function(n) {
  __extends$c(t, n);
  function t() {
    var e = this, o = {
      m: new Float32Array([
        1,
        0,
        0,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        0,
        0,
        1,
        0
      ]),
      uAlpha: 1
    };
    return e = n.call(this, defaultFilterVertex, fragment$3, o) || this, e.alpha = 1, e;
  }
  return t.prototype._loadMatrix = function(e, o) {
    o === void 0 && (o = !1);
    var R = e;
    o && (this._multiply(R, this.uniforms.m, e), R = this._colorMatrix(R)), this.uniforms.m = R;
  }, t.prototype._multiply = function(e, o, R) {
    return e[0] = o[0] * R[0] + o[1] * R[5] + o[2] * R[10] + o[3] * R[15], e[1] = o[0] * R[1] + o[1] * R[6] + o[2] * R[11] + o[3] * R[16], e[2] = o[0] * R[2] + o[1] * R[7] + o[2] * R[12] + o[3] * R[17], e[3] = o[0] * R[3] + o[1] * R[8] + o[2] * R[13] + o[3] * R[18], e[4] = o[0] * R[4] + o[1] * R[9] + o[2] * R[14] + o[3] * R[19] + o[4], e[5] = o[5] * R[0] + o[6] * R[5] + o[7] * R[10] + o[8] * R[15], e[6] = o[5] * R[1] + o[6] * R[6] + o[7] * R[11] + o[8] * R[16], e[7] = o[5] * R[2] + o[6] * R[7] + o[7] * R[12] + o[8] * R[17], e[8] = o[5] * R[3] + o[6] * R[8] + o[7] * R[13] + o[8] * R[18], e[9] = o[5] * R[4] + o[6] * R[9] + o[7] * R[14] + o[8] * R[19] + o[9], e[10] = o[10] * R[0] + o[11] * R[5] + o[12] * R[10] + o[13] * R[15], e[11] = o[10] * R[1] + o[11] * R[6] + o[12] * R[11] + o[13] * R[16], e[12] = o[10] * R[2] + o[11] * R[7] + o[12] * R[12] + o[13] * R[17], e[13] = o[10] * R[3] + o[11] * R[8] + o[12] * R[13] + o[13] * R[18], e[14] = o[10] * R[4] + o[11] * R[9] + o[12] * R[14] + o[13] * R[19] + o[14], e[15] = o[15] * R[0] + o[16] * R[5] + o[17] * R[10] + o[18] * R[15], e[16] = o[15] * R[1] + o[16] * R[6] + o[17] * R[11] + o[18] * R[16], e[17] = o[15] * R[2] + o[16] * R[7] + o[17] * R[12] + o[18] * R[17], e[18] = o[15] * R[3] + o[16] * R[8] + o[17] * R[13] + o[18] * R[18], e[19] = o[15] * R[4] + o[16] * R[9] + o[17] * R[14] + o[18] * R[19] + o[19], e;
  }, t.prototype._colorMatrix = function(e) {
    var o = new Float32Array(e);
    return o[4] /= 255, o[9] /= 255, o[14] /= 255, o[19] /= 255, o;
  }, t.prototype.brightness = function(e, o) {
    var R = [
      e,
      0,
      0,
      0,
      0,
      0,
      e,
      0,
      0,
      0,
      0,
      0,
      e,
      0,
      0,
      0,
      0,
      0,
      1,
      0
    ];
    this._loadMatrix(R, o);
  }, t.prototype.tint = function(e, o) {
    var R = e >> 16 & 255, N = e >> 8 & 255, M = e & 255, D = [
      R / 255,
      0,
      0,
      0,
      0,
      0,
      N / 255,
      0,
      0,
      0,
      0,
      0,
      M / 255,
      0,
      0,
      0,
      0,
      0,
      1,
      0
    ];
    this._loadMatrix(D, o);
  }, t.prototype.greyscale = function(e, o) {
    var R = [
      e,
      e,
      e,
      0,
      0,
      e,
      e,
      e,
      0,
      0,
      e,
      e,
      e,
      0,
      0,
      0,
      0,
      0,
      1,
      0
    ];
    this._loadMatrix(R, o);
  }, t.prototype.blackAndWhite = function(e) {
    var o = [
      0.3,
      0.6,
      0.1,
      0,
      0,
      0.3,
      0.6,
      0.1,
      0,
      0,
      0.3,
      0.6,
      0.1,
      0,
      0,
      0,
      0,
      0,
      1,
      0
    ];
    this._loadMatrix(o, e);
  }, t.prototype.hue = function(e, o) {
    e = (e || 0) / 180 * Math.PI;
    var R = Math.cos(e), N = Math.sin(e), M = Math.sqrt, D = 1 / 3, L = M(D), B = R + (1 - R) * D, $ = D * (1 - R) - L * N, k = D * (1 - R) + L * N, U = D * (1 - R) + L * N, z = R + D * (1 - R), X = D * (1 - R) - L * N, V = D * (1 - R) - L * N, W = D * (1 - R) + L * N, Y = R + D * (1 - R), q = [
      B,
      $,
      k,
      0,
      0,
      U,
      z,
      X,
      0,
      0,
      V,
      W,
      Y,
      0,
      0,
      0,
      0,
      0,
      1,
      0
    ];
    this._loadMatrix(q, o);
  }, t.prototype.contrast = function(e, o) {
    var R = (e || 0) + 1, N = -0.5 * (R - 1), M = [
      R,
      0,
      0,
      0,
      N,
      0,
      R,
      0,
      0,
      N,
      0,
      0,
      R,
      0,
      N,
      0,
      0,
      0,
      1,
      0
    ];
    this._loadMatrix(M, o);
  }, t.prototype.saturate = function(e, o) {
    e === void 0 && (e = 0);
    var R = e * 2 / 3 + 1, N = (R - 1) * -0.5, M = [
      R,
      N,
      N,
      0,
      0,
      N,
      R,
      N,
      0,
      0,
      N,
      N,
      R,
      0,
      0,
      0,
      0,
      0,
      1,
      0
    ];
    this._loadMatrix(M, o);
  }, t.prototype.desaturate = function() {
    this.saturate(-1);
  }, t.prototype.negative = function(e) {
    var o = [
      -1,
      0,
      0,
      1,
      0,
      0,
      -1,
      0,
      1,
      0,
      0,
      0,
      -1,
      1,
      0,
      0,
      0,
      0,
      1,
      0
    ];
    this._loadMatrix(o, e);
  }, t.prototype.sepia = function(e) {
    var o = [
      0.393,
      0.7689999,
      0.18899999,
      0,
      0,
      0.349,
      0.6859999,
      0.16799999,
      0,
      0,
      0.272,
      0.5339999,
      0.13099999,
      0,
      0,
      0,
      0,
      0,
      1,
      0
    ];
    this._loadMatrix(o, e);
  }, t.prototype.technicolor = function(e) {
    var o = [
      1.9125277891456083,
      -0.8545344976951645,
      -0.09155508482755585,
      0,
      11.793603434377337,
      -0.3087833385928097,
      1.7658908555458428,
      -0.10601743074722245,
      0,
      -70.35205161461398,
      -0.231103377548616,
      -0.7501899197440212,
      1.847597816108189,
      0,
      30.950940869491138,
      0,
      0,
      0,
      1,
      0
    ];
    this._loadMatrix(o, e);
  }, t.prototype.polaroid = function(e) {
    var o = [
      1.438,
      -0.062,
      -0.062,
      0,
      0,
      -0.122,
      1.378,
      -0.122,
      0,
      0,
      -0.016,
      -0.016,
      1.483,
      0,
      0,
      0,
      0,
      0,
      1,
      0
    ];
    this._loadMatrix(o, e);
  }, t.prototype.toBGR = function(e) {
    var o = [
      0,
      0,
      1,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      1,
      0
    ];
    this._loadMatrix(o, e);
  }, t.prototype.kodachrome = function(e) {
    var o = [
      1.1285582396593525,
      -0.3967382283601348,
      -0.03992559172921793,
      0,
      63.72958762196502,
      -0.16404339962244616,
      1.0835251566291304,
      -0.05498805115633132,
      0,
      24.732407896706203,
      -0.16786010706155763,
      -0.5603416277695248,
      1.6014850761964943,
      0,
      35.62982807460946,
      0,
      0,
      0,
      1,
      0
    ];
    this._loadMatrix(o, e);
  }, t.prototype.browni = function(e) {
    var o = [
      0.5997023498159715,
      0.34553243048391263,
      -0.2708298674538042,
      0,
      47.43192855600873,
      -0.037703249837783157,
      0.8609577587992641,
      0.15059552388459913,
      0,
      -36.96841498319127,
      0.24113635128153335,
      -0.07441037908422492,
      0.44972182064877153,
      0,
      -7.562075277591283,
      0,
      0,
      0,
      1,
      0
    ];
    this._loadMatrix(o, e);
  }, t.prototype.vintage = function(e) {
    var o = [
      0.6279345635605994,
      0.3202183420819367,
      -0.03965408211312453,
      0,
      9.651285835294123,
      0.02578397704808868,
      0.6441188644374771,
      0.03259127616149294,
      0,
      7.462829176470591,
      0.0466055556782719,
      -0.0851232987247891,
      0.5241648018700465,
      0,
      5.159190588235296,
      0,
      0,
      0,
      1,
      0
    ];
    this._loadMatrix(o, e);
  }, t.prototype.colorTone = function(e, o, R, N, M) {
    e = e || 0.2, o = o || 0.15, R = R || 16770432, N = N || 3375104;
    var D = (R >> 16 & 255) / 255, L = (R >> 8 & 255) / 255, B = (R & 255) / 255, $ = (N >> 16 & 255) / 255, k = (N >> 8 & 255) / 255, U = (N & 255) / 255, z = [
      0.3,
      0.59,
      0.11,
      0,
      0,
      D,
      L,
      B,
      e,
      0,
      $,
      k,
      U,
      o,
      0,
      D - $,
      L - k,
      B - U,
      0,
      0
    ];
    this._loadMatrix(z, M);
  }, t.prototype.night = function(e, o) {
    e = e || 0.1;
    var R = [
      e * -2,
      -e,
      0,
      0,
      0,
      -e,
      0,
      e,
      0,
      0,
      0,
      e,
      e * 2,
      0,
      0,
      0,
      0,
      0,
      1,
      0
    ];
    this._loadMatrix(R, o);
  }, t.prototype.predator = function(e, o) {
    var R = [
      11.224130630493164 * e,
      -4.794486999511719 * e,
      -2.8746118545532227 * e,
      0 * e,
      0.40342438220977783 * e,
      -3.6330697536468506 * e,
      9.193157196044922 * e,
      -2.951810836791992 * e,
      0 * e,
      -1.316135048866272 * e,
      -3.2184197902679443 * e,
      -4.2375030517578125 * e,
      7.476448059082031 * e,
      0 * e,
      0.8044459223747253 * e,
      0,
      0,
      0,
      1,
      0
    ];
    this._loadMatrix(R, o);
  }, t.prototype.lsd = function(e) {
    var o = [
      2,
      -0.4,
      0.5,
      0,
      0,
      -0.5,
      2,
      -0.4,
      0,
      0,
      -0.4,
      -0.5,
      3,
      0,
      0,
      0,
      0,
      0,
      1,
      0
    ];
    this._loadMatrix(o, e);
  }, t.prototype.reset = function() {
    var e = [
      1,
      0,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      1,
      0
    ];
    this._loadMatrix(e, !1);
  }, Object.defineProperty(t.prototype, "matrix", {
    get: function() {
      return this.uniforms.m;
    },
    set: function(e) {
      this.uniforms.m = e;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(t.prototype, "alpha", {
    get: function() {
      return this.uniforms.uAlpha;
    },
    set: function(e) {
      this.uniforms.uAlpha = e;
    },
    enumerable: !1,
    configurable: !0
  }), t;
}(Filter);
ColorMatrixFilter.prototype.grayscale = ColorMatrixFilter.prototype.greyscale;
/*!
 * @pixi/filter-displacement - v6.5.2
 * Compiled Wed, 24 Aug 2022 13:51:19 UTC
 *
 * @pixi/filter-displacement is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var extendStatics$b = function(n, t) {
  return extendStatics$b = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(e, o) {
    e.__proto__ = o;
  } || function(e, o) {
    for (var R in o)
      o.hasOwnProperty(R) && (e[R] = o[R]);
  }, extendStatics$b(n, t);
};
function __extends$b(n, t) {
  extendStatics$b(n, t);
  function e() {
    this.constructor = n;
  }
  n.prototype = t === null ? Object.create(t) : (e.prototype = t.prototype, new e());
}
var fragment$2 = `varying vec2 vFilterCoord;
varying vec2 vTextureCoord;

uniform vec2 scale;
uniform mat2 rotation;
uniform sampler2D uSampler;
uniform sampler2D mapSampler;

uniform highp vec4 inputSize;
uniform vec4 inputClamp;

void main(void)
{
  vec4 map =  texture2D(mapSampler, vFilterCoord);

  map -= 0.5;
  map.xy = scale * inputSize.zw * (rotation * map.xy);

  gl_FragColor = texture2D(uSampler, clamp(vec2(vTextureCoord.x + map.x, vTextureCoord.y + map.y), inputClamp.xy, inputClamp.zw));
}
`, vertex$1 = `attribute vec2 aVertexPosition;

uniform mat3 projectionMatrix;
uniform mat3 filterMatrix;

varying vec2 vTextureCoord;
varying vec2 vFilterCoord;

uniform vec4 inputSize;
uniform vec4 outputFrame;

vec4 filterVertexPosition( void )
{
    vec2 position = aVertexPosition * max(outputFrame.zw, vec2(0.)) + outputFrame.xy;

    return vec4((projectionMatrix * vec3(position, 1.0)).xy, 0.0, 1.0);
}

vec2 filterTextureCoord( void )
{
    return aVertexPosition * (outputFrame.zw * inputSize.zw);
}

void main(void)
{
	gl_Position = filterVertexPosition();
	vTextureCoord = filterTextureCoord();
	vFilterCoord = ( filterMatrix * vec3( vTextureCoord, 1.0)  ).xy;
}
`;
(function(n) {
  __extends$b(t, n);
  function t(e, o) {
    var R = this, N = new Matrix();
    return e.renderable = !1, R = n.call(this, vertex$1, fragment$2, {
      mapSampler: e._texture,
      filterMatrix: N,
      scale: { x: 1, y: 1 },
      rotation: new Float32Array([1, 0, 0, 1])
    }) || this, R.maskSprite = e, R.maskMatrix = N, o == null && (o = 20), R.scale = new Point(o, o), R;
  }
  return t.prototype.apply = function(e, o, R, N) {
    this.uniforms.filterMatrix = e.calculateSpriteMatrix(this.maskMatrix, this.maskSprite), this.uniforms.scale.x = this.scale.x, this.uniforms.scale.y = this.scale.y;
    var M = this.maskSprite.worldTransform, D = Math.sqrt(M.a * M.a + M.b * M.b), L = Math.sqrt(M.c * M.c + M.d * M.d);
    D !== 0 && L !== 0 && (this.uniforms.rotation[0] = M.a / D, this.uniforms.rotation[1] = M.b / D, this.uniforms.rotation[2] = M.c / L, this.uniforms.rotation[3] = M.d / L), e.applyFilter(this, o, R, N);
  }, Object.defineProperty(t.prototype, "map", {
    get: function() {
      return this.uniforms.mapSampler;
    },
    set: function(e) {
      this.uniforms.mapSampler = e;
    },
    enumerable: !1,
    configurable: !0
  }), t;
})(Filter);
/*!
 * @pixi/filter-fxaa - v6.5.2
 * Compiled Wed, 24 Aug 2022 13:51:19 UTC
 *
 * @pixi/filter-fxaa is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var extendStatics$a = function(n, t) {
  return extendStatics$a = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(e, o) {
    e.__proto__ = o;
  } || function(e, o) {
    for (var R in o)
      o.hasOwnProperty(R) && (e[R] = o[R]);
  }, extendStatics$a(n, t);
};
function __extends$a(n, t) {
  extendStatics$a(n, t);
  function e() {
    this.constructor = n;
  }
  n.prototype = t === null ? Object.create(t) : (e.prototype = t.prototype, new e());
}
var vertex = `
attribute vec2 aVertexPosition;

uniform mat3 projectionMatrix;

varying vec2 v_rgbNW;
varying vec2 v_rgbNE;
varying vec2 v_rgbSW;
varying vec2 v_rgbSE;
varying vec2 v_rgbM;

varying vec2 vFragCoord;

uniform vec4 inputSize;
uniform vec4 outputFrame;

vec4 filterVertexPosition( void )
{
    vec2 position = aVertexPosition * max(outputFrame.zw, vec2(0.)) + outputFrame.xy;

    return vec4((projectionMatrix * vec3(position, 1.0)).xy, 0.0, 1.0);
}

void texcoords(vec2 fragCoord, vec2 inverseVP,
               out vec2 v_rgbNW, out vec2 v_rgbNE,
               out vec2 v_rgbSW, out vec2 v_rgbSE,
               out vec2 v_rgbM) {
    v_rgbNW = (fragCoord + vec2(-1.0, -1.0)) * inverseVP;
    v_rgbNE = (fragCoord + vec2(1.0, -1.0)) * inverseVP;
    v_rgbSW = (fragCoord + vec2(-1.0, 1.0)) * inverseVP;
    v_rgbSE = (fragCoord + vec2(1.0, 1.0)) * inverseVP;
    v_rgbM = vec2(fragCoord * inverseVP);
}

void main(void) {

   gl_Position = filterVertexPosition();

   vFragCoord = aVertexPosition * outputFrame.zw;

   texcoords(vFragCoord, inputSize.zw, v_rgbNW, v_rgbNE, v_rgbSW, v_rgbSE, v_rgbM);
}
`, fragment$1 = `varying vec2 v_rgbNW;
varying vec2 v_rgbNE;
varying vec2 v_rgbSW;
varying vec2 v_rgbSE;
varying vec2 v_rgbM;

varying vec2 vFragCoord;
uniform sampler2D uSampler;
uniform highp vec4 inputSize;


/**
 Basic FXAA implementation based on the code on geeks3d.com with the
 modification that the texture2DLod stuff was removed since it's
 unsupported by WebGL.

 --

 From:
 https://github.com/mitsuhiko/webgl-meincraft

 Copyright (c) 2011 by Armin Ronacher.

 Some rights reserved.

 Redistribution and use in source and binary forms, with or without
 modification, are permitted provided that the following conditions are
 met:

 * Redistributions of source code must retain the above copyright
 notice, this list of conditions and the following disclaimer.

 * Redistributions in binary form must reproduce the above
 copyright notice, this list of conditions and the following
 disclaimer in the documentation and/or other materials provided
 with the distribution.

 * The names of the contributors may not be used to endorse or
 promote products derived from this software without specific
 prior written permission.

 THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#ifndef FXAA_REDUCE_MIN
#define FXAA_REDUCE_MIN   (1.0/ 128.0)
#endif
#ifndef FXAA_REDUCE_MUL
#define FXAA_REDUCE_MUL   (1.0 / 8.0)
#endif
#ifndef FXAA_SPAN_MAX
#define FXAA_SPAN_MAX     8.0
#endif

//optimized version for mobile, where dependent
//texture reads can be a bottleneck
vec4 fxaa(sampler2D tex, vec2 fragCoord, vec2 inverseVP,
          vec2 v_rgbNW, vec2 v_rgbNE,
          vec2 v_rgbSW, vec2 v_rgbSE,
          vec2 v_rgbM) {
    vec4 color;
    vec3 rgbNW = texture2D(tex, v_rgbNW).xyz;
    vec3 rgbNE = texture2D(tex, v_rgbNE).xyz;
    vec3 rgbSW = texture2D(tex, v_rgbSW).xyz;
    vec3 rgbSE = texture2D(tex, v_rgbSE).xyz;
    vec4 texColor = texture2D(tex, v_rgbM);
    vec3 rgbM  = texColor.xyz;
    vec3 luma = vec3(0.299, 0.587, 0.114);
    float lumaNW = dot(rgbNW, luma);
    float lumaNE = dot(rgbNE, luma);
    float lumaSW = dot(rgbSW, luma);
    float lumaSE = dot(rgbSE, luma);
    float lumaM  = dot(rgbM,  luma);
    float lumaMin = min(lumaM, min(min(lumaNW, lumaNE), min(lumaSW, lumaSE)));
    float lumaMax = max(lumaM, max(max(lumaNW, lumaNE), max(lumaSW, lumaSE)));

    mediump vec2 dir;
    dir.x = -((lumaNW + lumaNE) - (lumaSW + lumaSE));
    dir.y =  ((lumaNW + lumaSW) - (lumaNE + lumaSE));

    float dirReduce = max((lumaNW + lumaNE + lumaSW + lumaSE) *
                          (0.25 * FXAA_REDUCE_MUL), FXAA_REDUCE_MIN);

    float rcpDirMin = 1.0 / (min(abs(dir.x), abs(dir.y)) + dirReduce);
    dir = min(vec2(FXAA_SPAN_MAX, FXAA_SPAN_MAX),
              max(vec2(-FXAA_SPAN_MAX, -FXAA_SPAN_MAX),
                  dir * rcpDirMin)) * inverseVP;

    vec3 rgbA = 0.5 * (
                       texture2D(tex, fragCoord * inverseVP + dir * (1.0 / 3.0 - 0.5)).xyz +
                       texture2D(tex, fragCoord * inverseVP + dir * (2.0 / 3.0 - 0.5)).xyz);
    vec3 rgbB = rgbA * 0.5 + 0.25 * (
                                     texture2D(tex, fragCoord * inverseVP + dir * -0.5).xyz +
                                     texture2D(tex, fragCoord * inverseVP + dir * 0.5).xyz);

    float lumaB = dot(rgbB, luma);
    if ((lumaB < lumaMin) || (lumaB > lumaMax))
        color = vec4(rgbA, texColor.a);
    else
        color = vec4(rgbB, texColor.a);
    return color;
}

void main() {

      vec4 color;

      color = fxaa(uSampler, vFragCoord, inputSize.zw, v_rgbNW, v_rgbNE, v_rgbSW, v_rgbSE, v_rgbM);

      gl_FragColor = color;
}
`;
(function(n) {
  __extends$a(t, n);
  function t() {
    return n.call(this, vertex, fragment$1) || this;
  }
  return t;
})(Filter);
/*!
 * @pixi/filter-noise - v6.5.2
 * Compiled Wed, 24 Aug 2022 13:51:19 UTC
 *
 * @pixi/filter-noise is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var extendStatics$9 = function(n, t) {
  return extendStatics$9 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(e, o) {
    e.__proto__ = o;
  } || function(e, o) {
    for (var R in o)
      o.hasOwnProperty(R) && (e[R] = o[R]);
  }, extendStatics$9(n, t);
};
function __extends$9(n, t) {
  extendStatics$9(n, t);
  function e() {
    this.constructor = n;
  }
  n.prototype = t === null ? Object.create(t) : (e.prototype = t.prototype, new e());
}
var fragment = `precision highp float;

varying vec2 vTextureCoord;
varying vec4 vColor;

uniform float uNoise;
uniform float uSeed;
uniform sampler2D uSampler;

float rand(vec2 co)
{
    return fract(sin(dot(co.xy, vec2(12.9898, 78.233))) * 43758.5453);
}

void main()
{
    vec4 color = texture2D(uSampler, vTextureCoord);
    float randomValue = rand(gl_FragCoord.xy * uSeed);
    float diff = (randomValue - 0.5) * uNoise;

    // Un-premultiply alpha before applying the color matrix. See issue #3539.
    if (color.a > 0.0) {
        color.rgb /= color.a;
    }

    color.r += diff;
    color.g += diff;
    color.b += diff;

    // Premultiply alpha again.
    color.rgb *= color.a;

    gl_FragColor = color;
}
`;
(function(n) {
  __extends$9(t, n);
  function t(e, o) {
    e === void 0 && (e = 0.5), o === void 0 && (o = Math.random());
    var R = n.call(this, defaultFilterVertex, fragment, {
      uNoise: 0,
      uSeed: 0
    }) || this;
    return R.noise = e, R.seed = o, R;
  }
  return Object.defineProperty(t.prototype, "noise", {
    get: function() {
      return this.uniforms.uNoise;
    },
    set: function(e) {
      this.uniforms.uNoise = e;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(t.prototype, "seed", {
    get: function() {
      return this.uniforms.uSeed;
    },
    set: function(e) {
      this.uniforms.uSeed = e;
    },
    enumerable: !1,
    configurable: !0
  }), t;
})(Filter);
/*!
 * @pixi/mixin-cache-as-bitmap - v6.5.2
 * Compiled Wed, 24 Aug 2022 13:51:19 UTC
 *
 * @pixi/mixin-cache-as-bitmap is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
/*!
 * @pixi/constants - v6.5.2
 * Compiled Wed, 24 Aug 2022 13:51:19 UTC
 *
 * @pixi/constants is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
var ENV$2;
(function(n) {
  n[n.WEBGL_LEGACY = 0] = "WEBGL_LEGACY", n[n.WEBGL = 1] = "WEBGL", n[n.WEBGL2 = 2] = "WEBGL2";
})(ENV$2 || (ENV$2 = {}));
var RENDERER_TYPE$2;
(function(n) {
  n[n.UNKNOWN = 0] = "UNKNOWN", n[n.WEBGL = 1] = "WEBGL", n[n.CANVAS = 2] = "CANVAS";
})(RENDERER_TYPE$2 || (RENDERER_TYPE$2 = {}));
var BUFFER_BITS$2;
(function(n) {
  n[n.COLOR = 16384] = "COLOR", n[n.DEPTH = 256] = "DEPTH", n[n.STENCIL = 1024] = "STENCIL";
})(BUFFER_BITS$2 || (BUFFER_BITS$2 = {}));
var BLEND_MODES$2;
(function(n) {
  n[n.NORMAL = 0] = "NORMAL", n[n.ADD = 1] = "ADD", n[n.MULTIPLY = 2] = "MULTIPLY", n[n.SCREEN = 3] = "SCREEN", n[n.OVERLAY = 4] = "OVERLAY", n[n.DARKEN = 5] = "DARKEN", n[n.LIGHTEN = 6] = "LIGHTEN", n[n.COLOR_DODGE = 7] = "COLOR_DODGE", n[n.COLOR_BURN = 8] = "COLOR_BURN", n[n.HARD_LIGHT = 9] = "HARD_LIGHT", n[n.SOFT_LIGHT = 10] = "SOFT_LIGHT", n[n.DIFFERENCE = 11] = "DIFFERENCE", n[n.EXCLUSION = 12] = "EXCLUSION", n[n.HUE = 13] = "HUE", n[n.SATURATION = 14] = "SATURATION", n[n.COLOR = 15] = "COLOR", n[n.LUMINOSITY = 16] = "LUMINOSITY", n[n.NORMAL_NPM = 17] = "NORMAL_NPM", n[n.ADD_NPM = 18] = "ADD_NPM", n[n.SCREEN_NPM = 19] = "SCREEN_NPM", n[n.NONE = 20] = "NONE", n[n.SRC_OVER = 0] = "SRC_OVER", n[n.SRC_IN = 21] = "SRC_IN", n[n.SRC_OUT = 22] = "SRC_OUT", n[n.SRC_ATOP = 23] = "SRC_ATOP", n[n.DST_OVER = 24] = "DST_OVER", n[n.DST_IN = 25] = "DST_IN", n[n.DST_OUT = 26] = "DST_OUT", n[n.DST_ATOP = 27] = "DST_ATOP", n[n.ERASE = 26] = "ERASE", n[n.SUBTRACT = 28] = "SUBTRACT", n[n.XOR = 29] = "XOR";
})(BLEND_MODES$2 || (BLEND_MODES$2 = {}));
var DRAW_MODES$2;
(function(n) {
  n[n.POINTS = 0] = "POINTS", n[n.LINES = 1] = "LINES", n[n.LINE_LOOP = 2] = "LINE_LOOP", n[n.LINE_STRIP = 3] = "LINE_STRIP", n[n.TRIANGLES = 4] = "TRIANGLES", n[n.TRIANGLE_STRIP = 5] = "TRIANGLE_STRIP", n[n.TRIANGLE_FAN = 6] = "TRIANGLE_FAN";
})(DRAW_MODES$2 || (DRAW_MODES$2 = {}));
var FORMATS$2;
(function(n) {
  n[n.RGBA = 6408] = "RGBA", n[n.RGB = 6407] = "RGB", n[n.RG = 33319] = "RG", n[n.RED = 6403] = "RED", n[n.RGBA_INTEGER = 36249] = "RGBA_INTEGER", n[n.RGB_INTEGER = 36248] = "RGB_INTEGER", n[n.RG_INTEGER = 33320] = "RG_INTEGER", n[n.RED_INTEGER = 36244] = "RED_INTEGER", n[n.ALPHA = 6406] = "ALPHA", n[n.LUMINANCE = 6409] = "LUMINANCE", n[n.LUMINANCE_ALPHA = 6410] = "LUMINANCE_ALPHA", n[n.DEPTH_COMPONENT = 6402] = "DEPTH_COMPONENT", n[n.DEPTH_STENCIL = 34041] = "DEPTH_STENCIL";
})(FORMATS$2 || (FORMATS$2 = {}));
var TARGETS$2;
(function(n) {
  n[n.TEXTURE_2D = 3553] = "TEXTURE_2D", n[n.TEXTURE_CUBE_MAP = 34067] = "TEXTURE_CUBE_MAP", n[n.TEXTURE_2D_ARRAY = 35866] = "TEXTURE_2D_ARRAY", n[n.TEXTURE_CUBE_MAP_POSITIVE_X = 34069] = "TEXTURE_CUBE_MAP_POSITIVE_X", n[n.TEXTURE_CUBE_MAP_NEGATIVE_X = 34070] = "TEXTURE_CUBE_MAP_NEGATIVE_X", n[n.TEXTURE_CUBE_MAP_POSITIVE_Y = 34071] = "TEXTURE_CUBE_MAP_POSITIVE_Y", n[n.TEXTURE_CUBE_MAP_NEGATIVE_Y = 34072] = "TEXTURE_CUBE_MAP_NEGATIVE_Y", n[n.TEXTURE_CUBE_MAP_POSITIVE_Z = 34073] = "TEXTURE_CUBE_MAP_POSITIVE_Z", n[n.TEXTURE_CUBE_MAP_NEGATIVE_Z = 34074] = "TEXTURE_CUBE_MAP_NEGATIVE_Z";
})(TARGETS$2 || (TARGETS$2 = {}));
var TYPES$2;
(function(n) {
  n[n.UNSIGNED_BYTE = 5121] = "UNSIGNED_BYTE", n[n.UNSIGNED_SHORT = 5123] = "UNSIGNED_SHORT", n[n.UNSIGNED_SHORT_5_6_5 = 33635] = "UNSIGNED_SHORT_5_6_5", n[n.UNSIGNED_SHORT_4_4_4_4 = 32819] = "UNSIGNED_SHORT_4_4_4_4", n[n.UNSIGNED_SHORT_5_5_5_1 = 32820] = "UNSIGNED_SHORT_5_5_5_1", n[n.UNSIGNED_INT = 5125] = "UNSIGNED_INT", n[n.UNSIGNED_INT_10F_11F_11F_REV = 35899] = "UNSIGNED_INT_10F_11F_11F_REV", n[n.UNSIGNED_INT_2_10_10_10_REV = 33640] = "UNSIGNED_INT_2_10_10_10_REV", n[n.UNSIGNED_INT_24_8 = 34042] = "UNSIGNED_INT_24_8", n[n.UNSIGNED_INT_5_9_9_9_REV = 35902] = "UNSIGNED_INT_5_9_9_9_REV", n[n.BYTE = 5120] = "BYTE", n[n.SHORT = 5122] = "SHORT", n[n.INT = 5124] = "INT", n[n.FLOAT = 5126] = "FLOAT", n[n.FLOAT_32_UNSIGNED_INT_24_8_REV = 36269] = "FLOAT_32_UNSIGNED_INT_24_8_REV", n[n.HALF_FLOAT = 36193] = "HALF_FLOAT";
})(TYPES$2 || (TYPES$2 = {}));
var SAMPLER_TYPES$2;
(function(n) {
  n[n.FLOAT = 0] = "FLOAT", n[n.INT = 1] = "INT", n[n.UINT = 2] = "UINT";
})(SAMPLER_TYPES$2 || (SAMPLER_TYPES$2 = {}));
var SCALE_MODES$2;
(function(n) {
  n[n.NEAREST = 0] = "NEAREST", n[n.LINEAR = 1] = "LINEAR";
})(SCALE_MODES$2 || (SCALE_MODES$2 = {}));
var WRAP_MODES$2;
(function(n) {
  n[n.CLAMP = 33071] = "CLAMP", n[n.REPEAT = 10497] = "REPEAT", n[n.MIRRORED_REPEAT = 33648] = "MIRRORED_REPEAT";
})(WRAP_MODES$2 || (WRAP_MODES$2 = {}));
var MIPMAP_MODES$2;
(function(n) {
  n[n.OFF = 0] = "OFF", n[n.POW2 = 1] = "POW2", n[n.ON = 2] = "ON", n[n.ON_MANUAL = 3] = "ON_MANUAL";
})(MIPMAP_MODES$2 || (MIPMAP_MODES$2 = {}));
var ALPHA_MODES$2;
(function(n) {
  n[n.NPM = 0] = "NPM", n[n.UNPACK = 1] = "UNPACK", n[n.PMA = 2] = "PMA", n[n.NO_PREMULTIPLIED_ALPHA = 0] = "NO_PREMULTIPLIED_ALPHA", n[n.PREMULTIPLY_ON_UPLOAD = 1] = "PREMULTIPLY_ON_UPLOAD", n[n.PREMULTIPLY_ALPHA = 2] = "PREMULTIPLY_ALPHA", n[n.PREMULTIPLIED_ALPHA = 2] = "PREMULTIPLIED_ALPHA";
})(ALPHA_MODES$2 || (ALPHA_MODES$2 = {}));
var CLEAR_MODES$2;
(function(n) {
  n[n.NO = 0] = "NO", n[n.YES = 1] = "YES", n[n.AUTO = 2] = "AUTO", n[n.BLEND = 0] = "BLEND", n[n.CLEAR = 1] = "CLEAR", n[n.BLIT = 2] = "BLIT";
})(CLEAR_MODES$2 || (CLEAR_MODES$2 = {}));
var GC_MODES$2;
(function(n) {
  n[n.AUTO = 0] = "AUTO", n[n.MANUAL = 1] = "MANUAL";
})(GC_MODES$2 || (GC_MODES$2 = {}));
var PRECISION$2;
(function(n) {
  n.LOW = "lowp", n.MEDIUM = "mediump", n.HIGH = "highp";
})(PRECISION$2 || (PRECISION$2 = {}));
var MASK_TYPES$2;
(function(n) {
  n[n.NONE = 0] = "NONE", n[n.SCISSOR = 1] = "SCISSOR", n[n.STENCIL = 2] = "STENCIL", n[n.SPRITE = 3] = "SPRITE", n[n.COLOR = 4] = "COLOR";
})(MASK_TYPES$2 || (MASK_TYPES$2 = {}));
var COLOR_MASK_BITS$2;
(function(n) {
  n[n.RED = 1] = "RED", n[n.GREEN = 2] = "GREEN", n[n.BLUE = 4] = "BLUE", n[n.ALPHA = 8] = "ALPHA";
})(COLOR_MASK_BITS$2 || (COLOR_MASK_BITS$2 = {}));
var MSAA_QUALITY$2;
(function(n) {
  n[n.NONE = 0] = "NONE", n[n.LOW = 2] = "LOW", n[n.MEDIUM = 4] = "MEDIUM", n[n.HIGH = 8] = "HIGH";
})(MSAA_QUALITY$2 || (MSAA_QUALITY$2 = {}));
var BUFFER_TYPE$2;
(function(n) {
  n[n.ELEMENT_ARRAY_BUFFER = 34963] = "ELEMENT_ARRAY_BUFFER", n[n.ARRAY_BUFFER = 34962] = "ARRAY_BUFFER", n[n.UNIFORM_BUFFER = 35345] = "UNIFORM_BUFFER";
})(BUFFER_TYPE$2 || (BUFFER_TYPE$2 = {}));
var _tempMatrix = new Matrix();
DisplayObject.prototype._cacheAsBitmap = !1;
DisplayObject.prototype._cacheData = null;
DisplayObject.prototype._cacheAsBitmapResolution = null;
DisplayObject.prototype._cacheAsBitmapMultisample = MSAA_QUALITY$2.NONE;
var CacheData = function() {
  function n() {
    this.textureCacheId = null, this.originalRender = null, this.originalRenderCanvas = null, this.originalCalculateBounds = null, this.originalGetLocalBounds = null, this.originalUpdateTransform = null, this.originalDestroy = null, this.originalMask = null, this.originalFilterArea = null, this.originalContainsPoint = null, this.sprite = null;
  }
  return n;
}();
Object.defineProperties(DisplayObject.prototype, {
  cacheAsBitmapResolution: {
    get: function() {
      return this._cacheAsBitmapResolution;
    },
    set: function(n) {
      n !== this._cacheAsBitmapResolution && (this._cacheAsBitmapResolution = n, this.cacheAsBitmap && (this.cacheAsBitmap = !1, this.cacheAsBitmap = !0));
    }
  },
  cacheAsBitmapMultisample: {
    get: function() {
      return this._cacheAsBitmapMultisample;
    },
    set: function(n) {
      n !== this._cacheAsBitmapMultisample && (this._cacheAsBitmapMultisample = n, this.cacheAsBitmap && (this.cacheAsBitmap = !1, this.cacheAsBitmap = !0));
    }
  },
  cacheAsBitmap: {
    get: function() {
      return this._cacheAsBitmap;
    },
    set: function(n) {
      if (this._cacheAsBitmap !== n) {
        this._cacheAsBitmap = n;
        var t;
        n ? (this._cacheData || (this._cacheData = new CacheData()), t = this._cacheData, t.originalRender = this.render, t.originalRenderCanvas = this.renderCanvas, t.originalUpdateTransform = this.updateTransform, t.originalCalculateBounds = this.calculateBounds, t.originalGetLocalBounds = this.getLocalBounds, t.originalDestroy = this.destroy, t.originalContainsPoint = this.containsPoint, t.originalMask = this._mask, t.originalFilterArea = this.filterArea, this.render = this._renderCached, this.renderCanvas = this._renderCachedCanvas, this.destroy = this._cacheAsBitmapDestroy) : (t = this._cacheData, t.sprite && this._destroyCachedDisplayObject(), this.render = t.originalRender, this.renderCanvas = t.originalRenderCanvas, this.calculateBounds = t.originalCalculateBounds, this.getLocalBounds = t.originalGetLocalBounds, this.destroy = t.originalDestroy, this.updateTransform = t.originalUpdateTransform, this.containsPoint = t.originalContainsPoint, this._mask = t.originalMask, this.filterArea = t.originalFilterArea);
      }
    }
  }
});
DisplayObject.prototype._renderCached = function(t) {
  !this.visible || this.worldAlpha <= 0 || !this.renderable || (this._initCachedDisplayObject(t), this._cacheData.sprite.transform._worldID = this.transform._worldID, this._cacheData.sprite.worldAlpha = this.worldAlpha, this._cacheData.sprite._render(t));
};
DisplayObject.prototype._initCachedDisplayObject = function(t) {
  var e;
  if (!(this._cacheData && this._cacheData.sprite)) {
    var o = this.alpha;
    this.alpha = 1, t.batch.flush();
    var R = this.getLocalBounds(null, !0).clone();
    if (this.filters && this.filters.length) {
      var N = this.filters[0].padding;
      R.pad(N);
    }
    R.ceil(settings$1.RESOLUTION);
    var M = t.renderTexture.current, D = t.renderTexture.sourceFrame.clone(), L = t.renderTexture.destinationFrame.clone(), B = t.projection.transform, $ = RenderTexture.create({
      width: R.width,
      height: R.height,
      resolution: this.cacheAsBitmapResolution || t.resolution,
      multisample: (e = this.cacheAsBitmapMultisample) !== null && e !== void 0 ? e : t.multisample
    }), k = "cacheAsBitmap_" + uid();
    this._cacheData.textureCacheId = k, BaseTexture.addToCache($.baseTexture, k), Texture.addToCache($, k);
    var U = this.transform.localTransform.copyTo(_tempMatrix).invert().translate(-R.x, -R.y);
    this.render = this._cacheData.originalRender, t.render(this, { renderTexture: $, clear: !0, transform: U, skipUpdateTransform: !1 }), t.framebuffer.blit(), t.projection.transform = B, t.renderTexture.bind(M, D, L), this.render = this._renderCached, this.updateTransform = this.displayObjectUpdateTransform, this.calculateBounds = this._calculateCachedBounds, this.getLocalBounds = this._getCachedLocalBounds, this._mask = null, this.filterArea = null, this.alpha = o;
    var z = new Sprite($);
    z.transform.worldTransform = this.transform.worldTransform, z.anchor.x = -(R.x / R.width), z.anchor.y = -(R.y / R.height), z.alpha = o, z._bounds = this._bounds, this._cacheData.sprite = z, this.transform._parentID = -1, this.parent ? this.updateTransform() : (this.enableTempParent(), this.updateTransform(), this.disableTempParent(null)), this.containsPoint = z.containsPoint.bind(z);
  }
};
DisplayObject.prototype._renderCachedCanvas = function(t) {
  !this.visible || this.worldAlpha <= 0 || !this.renderable || (this._initCachedDisplayObjectCanvas(t), this._cacheData.sprite.worldAlpha = this.worldAlpha, this._cacheData.sprite._renderCanvas(t));
};
DisplayObject.prototype._initCachedDisplayObjectCanvas = function(t) {
  if (!(this._cacheData && this._cacheData.sprite)) {
    var e = this.getLocalBounds(null, !0), o = this.alpha;
    this.alpha = 1;
    var R = t.context, N = t._projTransform;
    e.ceil(settings$1.RESOLUTION);
    var M = RenderTexture.create({ width: e.width, height: e.height }), D = "cacheAsBitmap_" + uid();
    this._cacheData.textureCacheId = D, BaseTexture.addToCache(M.baseTexture, D), Texture.addToCache(M, D);
    var L = _tempMatrix;
    this.transform.localTransform.copyTo(L), L.invert(), L.tx -= e.x, L.ty -= e.y, this.renderCanvas = this._cacheData.originalRenderCanvas, t.render(this, { renderTexture: M, clear: !0, transform: L, skipUpdateTransform: !1 }), t.context = R, t._projTransform = N, this.renderCanvas = this._renderCachedCanvas, this.updateTransform = this.displayObjectUpdateTransform, this.calculateBounds = this._calculateCachedBounds, this.getLocalBounds = this._getCachedLocalBounds, this._mask = null, this.filterArea = null, this.alpha = o;
    var B = new Sprite(M);
    B.transform.worldTransform = this.transform.worldTransform, B.anchor.x = -(e.x / e.width), B.anchor.y = -(e.y / e.height), B.alpha = o, B._bounds = this._bounds, this._cacheData.sprite = B, this.transform._parentID = -1, this.parent ? this.updateTransform() : (this.parent = t._tempDisplayObjectParent, this.updateTransform(), this.parent = null), this.containsPoint = B.containsPoint.bind(B);
  }
};
DisplayObject.prototype._calculateCachedBounds = function() {
  this._bounds.clear(), this._cacheData.sprite.transform._worldID = this.transform._worldID, this._cacheData.sprite._calculateBounds(), this._bounds.updateID = this._boundsID;
};
DisplayObject.prototype._getCachedLocalBounds = function() {
  return this._cacheData.sprite.getLocalBounds(null);
};
DisplayObject.prototype._destroyCachedDisplayObject = function() {
  this._cacheData.sprite._texture.destroy(!0), this._cacheData.sprite = null, BaseTexture.removeFromCache(this._cacheData.textureCacheId), Texture.removeFromCache(this._cacheData.textureCacheId), this._cacheData.textureCacheId = null;
};
DisplayObject.prototype._cacheAsBitmapDestroy = function(t) {
  this.cacheAsBitmap = !1, this.destroy(t);
};
/*!
 * @pixi/mixin-get-child-by-name - v6.5.2
 * Compiled Wed, 24 Aug 2022 13:51:19 UTC
 *
 * @pixi/mixin-get-child-by-name is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
DisplayObject.prototype.name = null;
Container.prototype.getChildByName = function(t, e) {
  for (var o = 0, R = this.children.length; o < R; o++)
    if (this.children[o].name === t)
      return this.children[o];
  if (e)
    for (var o = 0, R = this.children.length; o < R; o++) {
      var N = this.children[o];
      if (!!N.getChildByName) {
        var M = N.getChildByName(t, !0);
        if (M)
          return M;
      }
    }
  return null;
};
/*!
 * @pixi/mixin-get-global-position - v6.5.2
 * Compiled Wed, 24 Aug 2022 13:51:19 UTC
 *
 * @pixi/mixin-get-global-position is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
DisplayObject.prototype.getGlobalPosition = function(t, e) {
  return t === void 0 && (t = new Point()), e === void 0 && (e = !1), this.parent ? this.parent.toGlobal(this.position, t, e) : (t.x = this.position.x, t.y = this.position.y), t;
};
/*!
 * @pixi/app - v6.5.2
 * Compiled Wed, 24 Aug 2022 13:51:19 UTC
 *
 * @pixi/app is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
var ResizePlugin = function() {
  function n() {
  }
  return n.init = function(t) {
    var e = this;
    Object.defineProperty(
      this,
      "resizeTo",
      {
        set: function(o) {
          globalThis.removeEventListener("resize", this.queueResize), this._resizeTo = o, o && (globalThis.addEventListener("resize", this.queueResize), this.resize());
        },
        get: function() {
          return this._resizeTo;
        }
      }
    ), this.queueResize = function() {
      !e._resizeTo || (e.cancelResize(), e._resizeId = requestAnimationFrame(function() {
        return e.resize();
      }));
    }, this.cancelResize = function() {
      e._resizeId && (cancelAnimationFrame(e._resizeId), e._resizeId = null);
    }, this.resize = function() {
      if (!!e._resizeTo) {
        e.cancelResize();
        var o, R;
        if (e._resizeTo === globalThis.window)
          o = globalThis.innerWidth, R = globalThis.innerHeight;
        else {
          var N = e._resizeTo, M = N.clientWidth, D = N.clientHeight;
          o = M, R = D;
        }
        e.renderer.resize(o, R);
      }
    }, this._resizeId = null, this._resizeTo = null, this.resizeTo = t.resizeTo || null;
  }, n.destroy = function() {
    globalThis.removeEventListener("resize", this.queueResize), this.cancelResize(), this.cancelResize = null, this.queueResize = null, this.resizeTo = null, this.resize = null;
  }, n.extension = ExtensionType.Application, n;
}();
/*!
 * @pixi/settings - v6.5.2
 * Compiled Wed, 24 Aug 2022 13:51:19 UTC
 *
 * @pixi/settings is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
/*!
 * @pixi/constants - v6.5.2
 * Compiled Wed, 24 Aug 2022 13:51:19 UTC
 *
 * @pixi/constants is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
var ENV$1;
(function(n) {
  n[n.WEBGL_LEGACY = 0] = "WEBGL_LEGACY", n[n.WEBGL = 1] = "WEBGL", n[n.WEBGL2 = 2] = "WEBGL2";
})(ENV$1 || (ENV$1 = {}));
var RENDERER_TYPE$1;
(function(n) {
  n[n.UNKNOWN = 0] = "UNKNOWN", n[n.WEBGL = 1] = "WEBGL", n[n.CANVAS = 2] = "CANVAS";
})(RENDERER_TYPE$1 || (RENDERER_TYPE$1 = {}));
var BUFFER_BITS$1;
(function(n) {
  n[n.COLOR = 16384] = "COLOR", n[n.DEPTH = 256] = "DEPTH", n[n.STENCIL = 1024] = "STENCIL";
})(BUFFER_BITS$1 || (BUFFER_BITS$1 = {}));
var BLEND_MODES$1;
(function(n) {
  n[n.NORMAL = 0] = "NORMAL", n[n.ADD = 1] = "ADD", n[n.MULTIPLY = 2] = "MULTIPLY", n[n.SCREEN = 3] = "SCREEN", n[n.OVERLAY = 4] = "OVERLAY", n[n.DARKEN = 5] = "DARKEN", n[n.LIGHTEN = 6] = "LIGHTEN", n[n.COLOR_DODGE = 7] = "COLOR_DODGE", n[n.COLOR_BURN = 8] = "COLOR_BURN", n[n.HARD_LIGHT = 9] = "HARD_LIGHT", n[n.SOFT_LIGHT = 10] = "SOFT_LIGHT", n[n.DIFFERENCE = 11] = "DIFFERENCE", n[n.EXCLUSION = 12] = "EXCLUSION", n[n.HUE = 13] = "HUE", n[n.SATURATION = 14] = "SATURATION", n[n.COLOR = 15] = "COLOR", n[n.LUMINOSITY = 16] = "LUMINOSITY", n[n.NORMAL_NPM = 17] = "NORMAL_NPM", n[n.ADD_NPM = 18] = "ADD_NPM", n[n.SCREEN_NPM = 19] = "SCREEN_NPM", n[n.NONE = 20] = "NONE", n[n.SRC_OVER = 0] = "SRC_OVER", n[n.SRC_IN = 21] = "SRC_IN", n[n.SRC_OUT = 22] = "SRC_OUT", n[n.SRC_ATOP = 23] = "SRC_ATOP", n[n.DST_OVER = 24] = "DST_OVER", n[n.DST_IN = 25] = "DST_IN", n[n.DST_OUT = 26] = "DST_OUT", n[n.DST_ATOP = 27] = "DST_ATOP", n[n.ERASE = 26] = "ERASE", n[n.SUBTRACT = 28] = "SUBTRACT", n[n.XOR = 29] = "XOR";
})(BLEND_MODES$1 || (BLEND_MODES$1 = {}));
var DRAW_MODES$1;
(function(n) {
  n[n.POINTS = 0] = "POINTS", n[n.LINES = 1] = "LINES", n[n.LINE_LOOP = 2] = "LINE_LOOP", n[n.LINE_STRIP = 3] = "LINE_STRIP", n[n.TRIANGLES = 4] = "TRIANGLES", n[n.TRIANGLE_STRIP = 5] = "TRIANGLE_STRIP", n[n.TRIANGLE_FAN = 6] = "TRIANGLE_FAN";
})(DRAW_MODES$1 || (DRAW_MODES$1 = {}));
var FORMATS$1;
(function(n) {
  n[n.RGBA = 6408] = "RGBA", n[n.RGB = 6407] = "RGB", n[n.RG = 33319] = "RG", n[n.RED = 6403] = "RED", n[n.RGBA_INTEGER = 36249] = "RGBA_INTEGER", n[n.RGB_INTEGER = 36248] = "RGB_INTEGER", n[n.RG_INTEGER = 33320] = "RG_INTEGER", n[n.RED_INTEGER = 36244] = "RED_INTEGER", n[n.ALPHA = 6406] = "ALPHA", n[n.LUMINANCE = 6409] = "LUMINANCE", n[n.LUMINANCE_ALPHA = 6410] = "LUMINANCE_ALPHA", n[n.DEPTH_COMPONENT = 6402] = "DEPTH_COMPONENT", n[n.DEPTH_STENCIL = 34041] = "DEPTH_STENCIL";
})(FORMATS$1 || (FORMATS$1 = {}));
var TARGETS$1;
(function(n) {
  n[n.TEXTURE_2D = 3553] = "TEXTURE_2D", n[n.TEXTURE_CUBE_MAP = 34067] = "TEXTURE_CUBE_MAP", n[n.TEXTURE_2D_ARRAY = 35866] = "TEXTURE_2D_ARRAY", n[n.TEXTURE_CUBE_MAP_POSITIVE_X = 34069] = "TEXTURE_CUBE_MAP_POSITIVE_X", n[n.TEXTURE_CUBE_MAP_NEGATIVE_X = 34070] = "TEXTURE_CUBE_MAP_NEGATIVE_X", n[n.TEXTURE_CUBE_MAP_POSITIVE_Y = 34071] = "TEXTURE_CUBE_MAP_POSITIVE_Y", n[n.TEXTURE_CUBE_MAP_NEGATIVE_Y = 34072] = "TEXTURE_CUBE_MAP_NEGATIVE_Y", n[n.TEXTURE_CUBE_MAP_POSITIVE_Z = 34073] = "TEXTURE_CUBE_MAP_POSITIVE_Z", n[n.TEXTURE_CUBE_MAP_NEGATIVE_Z = 34074] = "TEXTURE_CUBE_MAP_NEGATIVE_Z";
})(TARGETS$1 || (TARGETS$1 = {}));
var TYPES$1;
(function(n) {
  n[n.UNSIGNED_BYTE = 5121] = "UNSIGNED_BYTE", n[n.UNSIGNED_SHORT = 5123] = "UNSIGNED_SHORT", n[n.UNSIGNED_SHORT_5_6_5 = 33635] = "UNSIGNED_SHORT_5_6_5", n[n.UNSIGNED_SHORT_4_4_4_4 = 32819] = "UNSIGNED_SHORT_4_4_4_4", n[n.UNSIGNED_SHORT_5_5_5_1 = 32820] = "UNSIGNED_SHORT_5_5_5_1", n[n.UNSIGNED_INT = 5125] = "UNSIGNED_INT", n[n.UNSIGNED_INT_10F_11F_11F_REV = 35899] = "UNSIGNED_INT_10F_11F_11F_REV", n[n.UNSIGNED_INT_2_10_10_10_REV = 33640] = "UNSIGNED_INT_2_10_10_10_REV", n[n.UNSIGNED_INT_24_8 = 34042] = "UNSIGNED_INT_24_8", n[n.UNSIGNED_INT_5_9_9_9_REV = 35902] = "UNSIGNED_INT_5_9_9_9_REV", n[n.BYTE = 5120] = "BYTE", n[n.SHORT = 5122] = "SHORT", n[n.INT = 5124] = "INT", n[n.FLOAT = 5126] = "FLOAT", n[n.FLOAT_32_UNSIGNED_INT_24_8_REV = 36269] = "FLOAT_32_UNSIGNED_INT_24_8_REV", n[n.HALF_FLOAT = 36193] = "HALF_FLOAT";
})(TYPES$1 || (TYPES$1 = {}));
var SAMPLER_TYPES$1;
(function(n) {
  n[n.FLOAT = 0] = "FLOAT", n[n.INT = 1] = "INT", n[n.UINT = 2] = "UINT";
})(SAMPLER_TYPES$1 || (SAMPLER_TYPES$1 = {}));
var SCALE_MODES$1;
(function(n) {
  n[n.NEAREST = 0] = "NEAREST", n[n.LINEAR = 1] = "LINEAR";
})(SCALE_MODES$1 || (SCALE_MODES$1 = {}));
var WRAP_MODES$1;
(function(n) {
  n[n.CLAMP = 33071] = "CLAMP", n[n.REPEAT = 10497] = "REPEAT", n[n.MIRRORED_REPEAT = 33648] = "MIRRORED_REPEAT";
})(WRAP_MODES$1 || (WRAP_MODES$1 = {}));
var MIPMAP_MODES$1;
(function(n) {
  n[n.OFF = 0] = "OFF", n[n.POW2 = 1] = "POW2", n[n.ON = 2] = "ON", n[n.ON_MANUAL = 3] = "ON_MANUAL";
})(MIPMAP_MODES$1 || (MIPMAP_MODES$1 = {}));
var ALPHA_MODES$1;
(function(n) {
  n[n.NPM = 0] = "NPM", n[n.UNPACK = 1] = "UNPACK", n[n.PMA = 2] = "PMA", n[n.NO_PREMULTIPLIED_ALPHA = 0] = "NO_PREMULTIPLIED_ALPHA", n[n.PREMULTIPLY_ON_UPLOAD = 1] = "PREMULTIPLY_ON_UPLOAD", n[n.PREMULTIPLY_ALPHA = 2] = "PREMULTIPLY_ALPHA", n[n.PREMULTIPLIED_ALPHA = 2] = "PREMULTIPLIED_ALPHA";
})(ALPHA_MODES$1 || (ALPHA_MODES$1 = {}));
var CLEAR_MODES$1;
(function(n) {
  n[n.NO = 0] = "NO", n[n.YES = 1] = "YES", n[n.AUTO = 2] = "AUTO", n[n.BLEND = 0] = "BLEND", n[n.CLEAR = 1] = "CLEAR", n[n.BLIT = 2] = "BLIT";
})(CLEAR_MODES$1 || (CLEAR_MODES$1 = {}));
var GC_MODES$1;
(function(n) {
  n[n.AUTO = 0] = "AUTO", n[n.MANUAL = 1] = "MANUAL";
})(GC_MODES$1 || (GC_MODES$1 = {}));
var PRECISION$1;
(function(n) {
  n.LOW = "lowp", n.MEDIUM = "mediump", n.HIGH = "highp";
})(PRECISION$1 || (PRECISION$1 = {}));
var MASK_TYPES$1;
(function(n) {
  n[n.NONE = 0] = "NONE", n[n.SCISSOR = 1] = "SCISSOR", n[n.STENCIL = 2] = "STENCIL", n[n.SPRITE = 3] = "SPRITE", n[n.COLOR = 4] = "COLOR";
})(MASK_TYPES$1 || (MASK_TYPES$1 = {}));
var COLOR_MASK_BITS$1;
(function(n) {
  n[n.RED = 1] = "RED", n[n.GREEN = 2] = "GREEN", n[n.BLUE = 4] = "BLUE", n[n.ALPHA = 8] = "ALPHA";
})(COLOR_MASK_BITS$1 || (COLOR_MASK_BITS$1 = {}));
var MSAA_QUALITY$1;
(function(n) {
  n[n.NONE = 0] = "NONE", n[n.LOW = 2] = "LOW", n[n.MEDIUM = 4] = "MEDIUM", n[n.HIGH = 8] = "HIGH";
})(MSAA_QUALITY$1 || (MSAA_QUALITY$1 = {}));
var BUFFER_TYPE$1;
(function(n) {
  n[n.ELEMENT_ARRAY_BUFFER = 34963] = "ELEMENT_ARRAY_BUFFER", n[n.ARRAY_BUFFER = 34962] = "ARRAY_BUFFER", n[n.UNIFORM_BUFFER = 35345] = "UNIFORM_BUFFER";
})(BUFFER_TYPE$1 || (BUFFER_TYPE$1 = {}));
var BrowserAdapter = {
  createCanvas: function(n, t) {
    var e = document.createElement("canvas");
    return e.width = n, e.height = t, e;
  },
  getWebGLRenderingContext: function() {
    return WebGLRenderingContext;
  },
  getNavigator: function() {
    return navigator;
  },
  getBaseUrl: function() {
    var n;
    return (n = document.baseURI) !== null && n !== void 0 ? n : window.location.href;
  },
  fetch: function(n, t) {
    return fetch(n, t);
  }
}, appleIphone = /iPhone/i, appleIpod = /iPod/i, appleTablet = /iPad/i, appleUniversal = /\biOS-universal(?:.+)Mac\b/i, androidPhone = /\bAndroid(?:.+)Mobile\b/i, androidTablet = /Android/i, amazonPhone = /(?:SD4930UR|\bSilk(?:.+)Mobile\b)/i, amazonTablet = /Silk/i, windowsPhone = /Windows Phone/i, windowsTablet = /\bWindows(?:.+)ARM\b/i, otherBlackBerry = /BlackBerry/i, otherBlackBerry10 = /BB10/i, otherOpera = /Opera Mini/i, otherChrome = /\b(CriOS|Chrome)(?:.+)Mobile/i, otherFirefox = /Mobile(?:.+)Firefox\b/i, isAppleTabletOnIos13 = function(n) {
  return typeof n < "u" && n.platform === "MacIntel" && typeof n.maxTouchPoints == "number" && n.maxTouchPoints > 1 && typeof MSStream > "u";
};
function createMatch(n) {
  return function(t) {
    return t.test(n);
  };
}
function isMobile$1(n) {
  var t = {
    userAgent: "",
    platform: "",
    maxTouchPoints: 0
  };
  !n && typeof navigator < "u" ? t = {
    userAgent: navigator.userAgent,
    platform: navigator.platform,
    maxTouchPoints: navigator.maxTouchPoints || 0
  } : typeof n == "string" ? t.userAgent = n : n && n.userAgent && (t = {
    userAgent: n.userAgent,
    platform: n.platform,
    maxTouchPoints: n.maxTouchPoints || 0
  });
  var e = t.userAgent, o = e.split("[FBAN");
  typeof o[1] < "u" && (e = o[0]), o = e.split("Twitter"), typeof o[1] < "u" && (e = o[0]);
  var R = createMatch(e), N = {
    apple: {
      phone: R(appleIphone) && !R(windowsPhone),
      ipod: R(appleIpod),
      tablet: !R(appleIphone) && (R(appleTablet) || isAppleTabletOnIos13(t)) && !R(windowsPhone),
      universal: R(appleUniversal),
      device: (R(appleIphone) || R(appleIpod) || R(appleTablet) || R(appleUniversal) || isAppleTabletOnIos13(t)) && !R(windowsPhone)
    },
    amazon: {
      phone: R(amazonPhone),
      tablet: !R(amazonPhone) && R(amazonTablet),
      device: R(amazonPhone) || R(amazonTablet)
    },
    android: {
      phone: !R(windowsPhone) && R(amazonPhone) || !R(windowsPhone) && R(androidPhone),
      tablet: !R(windowsPhone) && !R(amazonPhone) && !R(androidPhone) && (R(amazonTablet) || R(androidTablet)),
      device: !R(windowsPhone) && (R(amazonPhone) || R(amazonTablet) || R(androidPhone) || R(androidTablet)) || R(/\bokhttp\b/i)
    },
    windows: {
      phone: R(windowsPhone),
      tablet: R(windowsTablet),
      device: R(windowsPhone) || R(windowsTablet)
    },
    other: {
      blackberry: R(otherBlackBerry),
      blackberry10: R(otherBlackBerry10),
      opera: R(otherOpera),
      firefox: R(otherFirefox),
      chrome: R(otherChrome),
      device: R(otherBlackBerry) || R(otherBlackBerry10) || R(otherOpera) || R(otherFirefox) || R(otherChrome)
    },
    any: !1,
    phone: !1,
    tablet: !1
  };
  return N.any = N.apple.device || N.android.device || N.windows.device || N.other.device, N.phone = N.apple.phone || N.android.phone || N.windows.phone, N.tablet = N.apple.tablet || N.android.tablet || N.windows.tablet, N;
}
var isMobile = isMobile$1(globalThis.navigator);
function canUploadSameBuffer() {
  return !isMobile.apple.device;
}
function maxRecommendedTextures(n) {
  var t = !0;
  if (isMobile.tablet || isMobile.phone) {
    if (isMobile.apple.device) {
      var e = navigator.userAgent.match(/OS (\d+)_(\d+)?/);
      if (e) {
        var o = parseInt(e[1], 10);
        o < 11 && (t = !1);
      }
    }
    if (isMobile.android.device) {
      var e = navigator.userAgent.match(/Android\s([0-9.]*)/);
      if (e) {
        var o = parseInt(e[1], 10);
        o < 7 && (t = !1);
      }
    }
  }
  return t ? n : 4;
}
var settings = {
  ADAPTER: BrowserAdapter,
  MIPMAP_TEXTURES: MIPMAP_MODES$1.POW2,
  ANISOTROPIC_LEVEL: 0,
  RESOLUTION: 1,
  FILTER_RESOLUTION: 1,
  FILTER_MULTISAMPLE: MSAA_QUALITY$1.NONE,
  SPRITE_MAX_TEXTURES: maxRecommendedTextures(32),
  SPRITE_BATCH_SIZE: 4096,
  RENDER_OPTIONS: {
    view: null,
    antialias: !1,
    autoDensity: !1,
    backgroundColor: 0,
    backgroundAlpha: 1,
    useContextAlpha: !0,
    clearBeforeRender: !0,
    preserveDrawingBuffer: !1,
    width: 800,
    height: 600,
    legacy: !1
  },
  GC_MODE: GC_MODES$1.AUTO,
  GC_MAX_IDLE: 60 * 60,
  GC_MAX_CHECK_COUNT: 60 * 10,
  WRAP_MODE: WRAP_MODES$1.CLAMP,
  SCALE_MODE: SCALE_MODES$1.LINEAR,
  PRECISION_VERTEX: PRECISION$1.HIGH,
  PRECISION_FRAGMENT: isMobile.apple.device ? PRECISION$1.HIGH : PRECISION$1.MEDIUM,
  CAN_UPLOAD_SAME_BUFFER: canUploadSameBuffer(),
  CREATE_IMAGE_BITMAP: !1,
  ROUND_PIXELS: !1
}, commonjsGlobal = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function createCommonjsModule(n, t, e) {
  return e = {
    path: t,
    exports: {},
    require: function(o, R) {
      return commonjsRequire(o, R == null ? e.path : R);
    }
  }, n(e, e.exports), e.exports;
}
function commonjsRequire() {
  throw new Error("Dynamic requires are not currently supported by @rollup/plugin-commonjs");
}
createCommonjsModule(function(n) {
  var t = Object.prototype.hasOwnProperty, e = "~";
  function o() {
  }
  Object.create && (o.prototype = /* @__PURE__ */ Object.create(null), new o().__proto__ || (e = !1));
  function R(L, B, $) {
    this.fn = L, this.context = B, this.once = $ || !1;
  }
  function N(L, B, $, k, U) {
    if (typeof $ != "function")
      throw new TypeError("The listener must be a function");
    var z = new R($, k || L, U), X = e ? e + B : B;
    return L._events[X] ? L._events[X].fn ? L._events[X] = [L._events[X], z] : L._events[X].push(z) : (L._events[X] = z, L._eventsCount++), L;
  }
  function M(L, B) {
    --L._eventsCount === 0 ? L._events = new o() : delete L._events[B];
  }
  function D() {
    this._events = new o(), this._eventsCount = 0;
  }
  D.prototype.eventNames = function() {
    var B = [], $, k;
    if (this._eventsCount === 0)
      return B;
    for (k in $ = this._events)
      t.call($, k) && B.push(e ? k.slice(1) : k);
    return Object.getOwnPropertySymbols ? B.concat(Object.getOwnPropertySymbols($)) : B;
  }, D.prototype.listeners = function(B) {
    var $ = e ? e + B : B, k = this._events[$];
    if (!k)
      return [];
    if (k.fn)
      return [k.fn];
    for (var U = 0, z = k.length, X = new Array(z); U < z; U++)
      X[U] = k[U].fn;
    return X;
  }, D.prototype.listenerCount = function(B) {
    var $ = e ? e + B : B, k = this._events[$];
    return k ? k.fn ? 1 : k.length : 0;
  }, D.prototype.emit = function(B, $, k, U, z, X) {
    var V = arguments, W = e ? e + B : B;
    if (!this._events[W])
      return !1;
    var Y = this._events[W], q = arguments.length, Z, J;
    if (Y.fn) {
      switch (Y.once && this.removeListener(B, Y.fn, void 0, !0), q) {
        case 1:
          return Y.fn.call(Y.context), !0;
        case 2:
          return Y.fn.call(Y.context, $), !0;
        case 3:
          return Y.fn.call(Y.context, $, k), !0;
        case 4:
          return Y.fn.call(Y.context, $, k, U), !0;
        case 5:
          return Y.fn.call(Y.context, $, k, U, z), !0;
        case 6:
          return Y.fn.call(Y.context, $, k, U, z, X), !0;
      }
      for (J = 1, Z = new Array(q - 1); J < q; J++)
        Z[J - 1] = V[J];
      Y.fn.apply(Y.context, Z);
    } else {
      var Q = Y.length, K;
      for (J = 0; J < Q; J++)
        switch (Y[J].once && this.removeListener(B, Y[J].fn, void 0, !0), q) {
          case 1:
            Y[J].fn.call(Y[J].context);
            break;
          case 2:
            Y[J].fn.call(Y[J].context, $);
            break;
          case 3:
            Y[J].fn.call(Y[J].context, $, k);
            break;
          case 4:
            Y[J].fn.call(Y[J].context, $, k, U);
            break;
          default:
            if (!Z)
              for (K = 1, Z = new Array(q - 1); K < q; K++)
                Z[K - 1] = V[K];
            Y[J].fn.apply(Y[J].context, Z);
        }
    }
    return !0;
  }, D.prototype.on = function(B, $, k) {
    return N(this, B, $, k, !1);
  }, D.prototype.once = function(B, $, k) {
    return N(this, B, $, k, !0);
  }, D.prototype.removeListener = function(B, $, k, U) {
    var z = e ? e + B : B;
    if (!this._events[z])
      return this;
    if (!$)
      return M(this, z), this;
    var X = this._events[z];
    if (X.fn)
      X.fn === $ && (!U || X.once) && (!k || X.context === k) && M(this, z);
    else {
      for (var V = 0, W = [], Y = X.length; V < Y; V++)
        (X[V].fn !== $ || U && !X[V].once || k && X[V].context !== k) && W.push(X[V]);
      W.length ? this._events[z] = W.length === 1 ? W[0] : W : M(this, z);
    }
    return this;
  }, D.prototype.removeAllListeners = function(B) {
    var $;
    return B ? ($ = e ? e + B : B, this._events[$] && M(this, $)) : (this._events = new o(), this._eventsCount = 0), this;
  }, D.prototype.off = D.prototype.removeListener, D.prototype.addListener = D.prototype.on, D.prefixed = e, D.EventEmitter = D, n.exports = D;
});
createCommonjsModule(function(n, t) {
  (function(e) {
    var o = t && !t.nodeType && t, R = n && !n.nodeType && n, N = typeof commonjsGlobal == "object" && commonjsGlobal;
    (N.global === N || N.window === N || N.self === N) && (e = N);
    var M, D = 2147483647, L = 36, B = 1, $ = 26, k = 38, U = 700, z = 72, X = 128, V = "-", W = /^xn--/, Y = /[^\x20-\x7E]/, q = /[\x2E\u3002\uFF0E\uFF61]/g, Z = {
      overflow: "Overflow: input needs wider integers to process",
      "not-basic": "Illegal input >= 0x80 (not a basic code point)",
      "invalid-input": "Invalid input"
    }, J = L - B, Q = Math.floor, K = String.fromCharCode, rt;
    function tt(ct) {
      throw RangeError(Z[ct]);
    }
    function nt(ct, vt) {
      for (var Tt = ct.length, Pt = []; Tt--; )
        Pt[Tt] = vt(ct[Tt]);
      return Pt;
    }
    function at(ct, vt) {
      var Tt = ct.split("@"), Pt = "";
      Tt.length > 1 && (Pt = Tt[0] + "@", ct = Tt[1]), ct = ct.replace(q, ".");
      var wt = ct.split("."), Mt = nt(wt, vt).join(".");
      return Pt + Mt;
    }
    function lt(ct) {
      for (var vt = [], Tt = 0, Pt = ct.length, wt, Mt; Tt < Pt; )
        wt = ct.charCodeAt(Tt++), wt >= 55296 && wt <= 56319 && Tt < Pt ? (Mt = ct.charCodeAt(Tt++), (Mt & 64512) == 56320 ? vt.push(((wt & 1023) << 10) + (Mt & 1023) + 65536) : (vt.push(wt), Tt--)) : vt.push(wt);
      return vt;
    }
    function ut(ct) {
      return nt(ct, function(vt) {
        var Tt = "";
        return vt > 65535 && (vt -= 65536, Tt += K(vt >>> 10 & 1023 | 55296), vt = 56320 | vt & 1023), Tt += K(vt), Tt;
      }).join("");
    }
    function dt(ct) {
      return ct - 48 < 10 ? ct - 22 : ct - 65 < 26 ? ct - 65 : ct - 97 < 26 ? ct - 97 : L;
    }
    function yt(ct, vt) {
      return ct + 22 + 75 * (ct < 26) - ((vt != 0) << 5);
    }
    function pt(ct, vt, Tt) {
      var Pt = 0;
      for (ct = Tt ? Q(ct / U) : ct >> 1, ct += Q(ct / vt); ct > J * $ >> 1; Pt += L)
        ct = Q(ct / J);
      return Q(Pt + (J + 1) * ct / (ct + k));
    }
    function gt(ct) {
      var vt = [], Tt = ct.length, Pt, wt = 0, Mt = X, ht = z, $t, At, kt, Ot, _t, Gt, St, Et, Rt;
      for ($t = ct.lastIndexOf(V), $t < 0 && ($t = 0), At = 0; At < $t; ++At)
        ct.charCodeAt(At) >= 128 && tt("not-basic"), vt.push(ct.charCodeAt(At));
      for (kt = $t > 0 ? $t + 1 : 0; kt < Tt; ) {
        for (Ot = wt, _t = 1, Gt = L; kt >= Tt && tt("invalid-input"), St = dt(ct.charCodeAt(kt++)), (St >= L || St > Q((D - wt) / _t)) && tt("overflow"), wt += St * _t, Et = Gt <= ht ? B : Gt >= ht + $ ? $ : Gt - ht, !(St < Et); Gt += L)
          Rt = L - Et, _t > Q(D / Rt) && tt("overflow"), _t *= Rt;
        Pt = vt.length + 1, ht = pt(wt - Ot, Pt, Ot == 0), Q(wt / Pt) > D - Mt && tt("overflow"), Mt += Q(wt / Pt), wt %= Pt, vt.splice(wt++, 0, Mt);
      }
      return ut(vt);
    }
    function xt(ct) {
      var vt, Tt, Pt, wt, Mt, ht, $t, At, kt, Ot, _t, Gt = [], St, Et, Rt, Dt;
      for (ct = lt(ct), St = ct.length, vt = X, Tt = 0, Mt = z, ht = 0; ht < St; ++ht)
        _t = ct[ht], _t < 128 && Gt.push(K(_t));
      for (Pt = wt = Gt.length, wt && Gt.push(V); Pt < St; ) {
        for ($t = D, ht = 0; ht < St; ++ht)
          _t = ct[ht], _t >= vt && _t < $t && ($t = _t);
        for (Et = Pt + 1, $t - vt > Q((D - Tt) / Et) && tt("overflow"), Tt += ($t - vt) * Et, vt = $t, ht = 0; ht < St; ++ht)
          if (_t = ct[ht], _t < vt && ++Tt > D && tt("overflow"), _t == vt) {
            for (At = Tt, kt = L; Ot = kt <= Mt ? B : kt >= Mt + $ ? $ : kt - Mt, !(At < Ot); kt += L)
              Dt = At - Ot, Rt = L - Ot, Gt.push(
                K(yt(Ot + Dt % Rt, 0))
              ), At = Q(Dt / Rt);
            Gt.push(K(yt(At, 0))), Mt = pt(Tt, Et, Pt == wt), Tt = 0, ++Pt;
          }
        ++Tt, ++vt;
      }
      return Gt.join("");
    }
    function Lt(ct) {
      return at(ct, function(vt) {
        return W.test(vt) ? gt(vt.slice(4).toLowerCase()) : vt;
      });
    }
    function mt(ct) {
      return at(ct, function(vt) {
        return Y.test(vt) ? "xn--" + xt(vt) : vt;
      });
    }
    if (M = {
      version: "1.3.2",
      ucs2: {
        decode: lt,
        encode: ut
      },
      decode: gt,
      encode: xt,
      toASCII: mt,
      toUnicode: Lt
    }, o && R)
      if (n.exports == o)
        R.exports = M;
      else
        for (rt in M)
          M.hasOwnProperty(rt) && (o[rt] = M[rt]);
    else
      e.punycode = M;
  })(commonjsGlobal);
});
function hasOwnProperty(n, t) {
  return Object.prototype.hasOwnProperty.call(n, t);
}
var decode = function(n, t, e, o) {
  t = t || "&", e = e || "=";
  var R = {};
  if (typeof n != "string" || n.length === 0)
    return R;
  var N = /\+/g;
  n = n.split(t);
  var M = 1e3;
  o && typeof o.maxKeys == "number" && (M = o.maxKeys);
  var D = n.length;
  M > 0 && D > M && (D = M);
  for (var L = 0; L < D; ++L) {
    var B = n[L].replace(N, "%20"), $ = B.indexOf(e), k, U, z, X;
    $ >= 0 ? (k = B.substr(0, $), U = B.substr($ + 1)) : (k = B, U = ""), z = decodeURIComponent(k), X = decodeURIComponent(U), hasOwnProperty(R, z) ? Array.isArray(R[z]) ? R[z].push(X) : R[z] = [R[z], X] : R[z] = X;
  }
  return R;
}, stringifyPrimitive = function(n) {
  switch (typeof n) {
    case "string":
      return n;
    case "boolean":
      return n ? "true" : "false";
    case "number":
      return isFinite(n) ? n : "";
    default:
      return "";
  }
}, encode = function(n, t, e, o) {
  return t = t || "&", e = e || "=", n === null && (n = void 0), typeof n == "object" ? Object.keys(n).map(function(R) {
    var N = encodeURIComponent(stringifyPrimitive(R)) + e;
    return Array.isArray(n[R]) ? n[R].map(function(M) {
      return N + encodeURIComponent(stringifyPrimitive(M));
    }).join(t) : N + encodeURIComponent(stringifyPrimitive(n[R]));
  }).join(t) : o ? encodeURIComponent(stringifyPrimitive(o)) + e + encodeURIComponent(stringifyPrimitive(n)) : "";
};
createCommonjsModule(function(n, t) {
  t.decode = t.parse = decode, t.encode = t.stringify = encode;
});
/*!
 * @pixi/constants - v6.5.2
 * Compiled Wed, 24 Aug 2022 13:51:19 UTC
 *
 * @pixi/constants is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
var ENV;
(function(n) {
  n[n.WEBGL_LEGACY = 0] = "WEBGL_LEGACY", n[n.WEBGL = 1] = "WEBGL", n[n.WEBGL2 = 2] = "WEBGL2";
})(ENV || (ENV = {}));
var RENDERER_TYPE;
(function(n) {
  n[n.UNKNOWN = 0] = "UNKNOWN", n[n.WEBGL = 1] = "WEBGL", n[n.CANVAS = 2] = "CANVAS";
})(RENDERER_TYPE || (RENDERER_TYPE = {}));
var BUFFER_BITS;
(function(n) {
  n[n.COLOR = 16384] = "COLOR", n[n.DEPTH = 256] = "DEPTH", n[n.STENCIL = 1024] = "STENCIL";
})(BUFFER_BITS || (BUFFER_BITS = {}));
var BLEND_MODES;
(function(n) {
  n[n.NORMAL = 0] = "NORMAL", n[n.ADD = 1] = "ADD", n[n.MULTIPLY = 2] = "MULTIPLY", n[n.SCREEN = 3] = "SCREEN", n[n.OVERLAY = 4] = "OVERLAY", n[n.DARKEN = 5] = "DARKEN", n[n.LIGHTEN = 6] = "LIGHTEN", n[n.COLOR_DODGE = 7] = "COLOR_DODGE", n[n.COLOR_BURN = 8] = "COLOR_BURN", n[n.HARD_LIGHT = 9] = "HARD_LIGHT", n[n.SOFT_LIGHT = 10] = "SOFT_LIGHT", n[n.DIFFERENCE = 11] = "DIFFERENCE", n[n.EXCLUSION = 12] = "EXCLUSION", n[n.HUE = 13] = "HUE", n[n.SATURATION = 14] = "SATURATION", n[n.COLOR = 15] = "COLOR", n[n.LUMINOSITY = 16] = "LUMINOSITY", n[n.NORMAL_NPM = 17] = "NORMAL_NPM", n[n.ADD_NPM = 18] = "ADD_NPM", n[n.SCREEN_NPM = 19] = "SCREEN_NPM", n[n.NONE = 20] = "NONE", n[n.SRC_OVER = 0] = "SRC_OVER", n[n.SRC_IN = 21] = "SRC_IN", n[n.SRC_OUT = 22] = "SRC_OUT", n[n.SRC_ATOP = 23] = "SRC_ATOP", n[n.DST_OVER = 24] = "DST_OVER", n[n.DST_IN = 25] = "DST_IN", n[n.DST_OUT = 26] = "DST_OUT", n[n.DST_ATOP = 27] = "DST_ATOP", n[n.ERASE = 26] = "ERASE", n[n.SUBTRACT = 28] = "SUBTRACT", n[n.XOR = 29] = "XOR";
})(BLEND_MODES || (BLEND_MODES = {}));
var DRAW_MODES;
(function(n) {
  n[n.POINTS = 0] = "POINTS", n[n.LINES = 1] = "LINES", n[n.LINE_LOOP = 2] = "LINE_LOOP", n[n.LINE_STRIP = 3] = "LINE_STRIP", n[n.TRIANGLES = 4] = "TRIANGLES", n[n.TRIANGLE_STRIP = 5] = "TRIANGLE_STRIP", n[n.TRIANGLE_FAN = 6] = "TRIANGLE_FAN";
})(DRAW_MODES || (DRAW_MODES = {}));
var FORMATS;
(function(n) {
  n[n.RGBA = 6408] = "RGBA", n[n.RGB = 6407] = "RGB", n[n.RG = 33319] = "RG", n[n.RED = 6403] = "RED", n[n.RGBA_INTEGER = 36249] = "RGBA_INTEGER", n[n.RGB_INTEGER = 36248] = "RGB_INTEGER", n[n.RG_INTEGER = 33320] = "RG_INTEGER", n[n.RED_INTEGER = 36244] = "RED_INTEGER", n[n.ALPHA = 6406] = "ALPHA", n[n.LUMINANCE = 6409] = "LUMINANCE", n[n.LUMINANCE_ALPHA = 6410] = "LUMINANCE_ALPHA", n[n.DEPTH_COMPONENT = 6402] = "DEPTH_COMPONENT", n[n.DEPTH_STENCIL = 34041] = "DEPTH_STENCIL";
})(FORMATS || (FORMATS = {}));
var TARGETS;
(function(n) {
  n[n.TEXTURE_2D = 3553] = "TEXTURE_2D", n[n.TEXTURE_CUBE_MAP = 34067] = "TEXTURE_CUBE_MAP", n[n.TEXTURE_2D_ARRAY = 35866] = "TEXTURE_2D_ARRAY", n[n.TEXTURE_CUBE_MAP_POSITIVE_X = 34069] = "TEXTURE_CUBE_MAP_POSITIVE_X", n[n.TEXTURE_CUBE_MAP_NEGATIVE_X = 34070] = "TEXTURE_CUBE_MAP_NEGATIVE_X", n[n.TEXTURE_CUBE_MAP_POSITIVE_Y = 34071] = "TEXTURE_CUBE_MAP_POSITIVE_Y", n[n.TEXTURE_CUBE_MAP_NEGATIVE_Y = 34072] = "TEXTURE_CUBE_MAP_NEGATIVE_Y", n[n.TEXTURE_CUBE_MAP_POSITIVE_Z = 34073] = "TEXTURE_CUBE_MAP_POSITIVE_Z", n[n.TEXTURE_CUBE_MAP_NEGATIVE_Z = 34074] = "TEXTURE_CUBE_MAP_NEGATIVE_Z";
})(TARGETS || (TARGETS = {}));
var TYPES;
(function(n) {
  n[n.UNSIGNED_BYTE = 5121] = "UNSIGNED_BYTE", n[n.UNSIGNED_SHORT = 5123] = "UNSIGNED_SHORT", n[n.UNSIGNED_SHORT_5_6_5 = 33635] = "UNSIGNED_SHORT_5_6_5", n[n.UNSIGNED_SHORT_4_4_4_4 = 32819] = "UNSIGNED_SHORT_4_4_4_4", n[n.UNSIGNED_SHORT_5_5_5_1 = 32820] = "UNSIGNED_SHORT_5_5_5_1", n[n.UNSIGNED_INT = 5125] = "UNSIGNED_INT", n[n.UNSIGNED_INT_10F_11F_11F_REV = 35899] = "UNSIGNED_INT_10F_11F_11F_REV", n[n.UNSIGNED_INT_2_10_10_10_REV = 33640] = "UNSIGNED_INT_2_10_10_10_REV", n[n.UNSIGNED_INT_24_8 = 34042] = "UNSIGNED_INT_24_8", n[n.UNSIGNED_INT_5_9_9_9_REV = 35902] = "UNSIGNED_INT_5_9_9_9_REV", n[n.BYTE = 5120] = "BYTE", n[n.SHORT = 5122] = "SHORT", n[n.INT = 5124] = "INT", n[n.FLOAT = 5126] = "FLOAT", n[n.FLOAT_32_UNSIGNED_INT_24_8_REV = 36269] = "FLOAT_32_UNSIGNED_INT_24_8_REV", n[n.HALF_FLOAT = 36193] = "HALF_FLOAT";
})(TYPES || (TYPES = {}));
var SAMPLER_TYPES;
(function(n) {
  n[n.FLOAT = 0] = "FLOAT", n[n.INT = 1] = "INT", n[n.UINT = 2] = "UINT";
})(SAMPLER_TYPES || (SAMPLER_TYPES = {}));
var SCALE_MODES;
(function(n) {
  n[n.NEAREST = 0] = "NEAREST", n[n.LINEAR = 1] = "LINEAR";
})(SCALE_MODES || (SCALE_MODES = {}));
var WRAP_MODES;
(function(n) {
  n[n.CLAMP = 33071] = "CLAMP", n[n.REPEAT = 10497] = "REPEAT", n[n.MIRRORED_REPEAT = 33648] = "MIRRORED_REPEAT";
})(WRAP_MODES || (WRAP_MODES = {}));
var MIPMAP_MODES;
(function(n) {
  n[n.OFF = 0] = "OFF", n[n.POW2 = 1] = "POW2", n[n.ON = 2] = "ON", n[n.ON_MANUAL = 3] = "ON_MANUAL";
})(MIPMAP_MODES || (MIPMAP_MODES = {}));
var ALPHA_MODES;
(function(n) {
  n[n.NPM = 0] = "NPM", n[n.UNPACK = 1] = "UNPACK", n[n.PMA = 2] = "PMA", n[n.NO_PREMULTIPLIED_ALPHA = 0] = "NO_PREMULTIPLIED_ALPHA", n[n.PREMULTIPLY_ON_UPLOAD = 1] = "PREMULTIPLY_ON_UPLOAD", n[n.PREMULTIPLY_ALPHA = 2] = "PREMULTIPLY_ALPHA", n[n.PREMULTIPLIED_ALPHA = 2] = "PREMULTIPLIED_ALPHA";
})(ALPHA_MODES || (ALPHA_MODES = {}));
var CLEAR_MODES;
(function(n) {
  n[n.NO = 0] = "NO", n[n.YES = 1] = "YES", n[n.AUTO = 2] = "AUTO", n[n.BLEND = 0] = "BLEND", n[n.CLEAR = 1] = "CLEAR", n[n.BLIT = 2] = "BLIT";
})(CLEAR_MODES || (CLEAR_MODES = {}));
var GC_MODES;
(function(n) {
  n[n.AUTO = 0] = "AUTO", n[n.MANUAL = 1] = "MANUAL";
})(GC_MODES || (GC_MODES = {}));
var PRECISION;
(function(n) {
  n.LOW = "lowp", n.MEDIUM = "mediump", n.HIGH = "highp";
})(PRECISION || (PRECISION = {}));
var MASK_TYPES;
(function(n) {
  n[n.NONE = 0] = "NONE", n[n.SCISSOR = 1] = "SCISSOR", n[n.STENCIL = 2] = "STENCIL", n[n.SPRITE = 3] = "SPRITE", n[n.COLOR = 4] = "COLOR";
})(MASK_TYPES || (MASK_TYPES = {}));
var COLOR_MASK_BITS;
(function(n) {
  n[n.RED = 1] = "RED", n[n.GREEN = 2] = "GREEN", n[n.BLUE = 4] = "BLUE", n[n.ALPHA = 8] = "ALPHA";
})(COLOR_MASK_BITS || (COLOR_MASK_BITS = {}));
var MSAA_QUALITY;
(function(n) {
  n[n.NONE = 0] = "NONE", n[n.LOW = 2] = "LOW", n[n.MEDIUM = 4] = "MEDIUM", n[n.HIGH = 8] = "HIGH";
})(MSAA_QUALITY || (MSAA_QUALITY = {}));
var BUFFER_TYPE;
(function(n) {
  n[n.ELEMENT_ARRAY_BUFFER = 34963] = "ELEMENT_ARRAY_BUFFER", n[n.ARRAY_BUFFER = 34962] = "ARRAY_BUFFER", n[n.UNIFORM_BUFFER = 35345] = "UNIFORM_BUFFER";
})(BUFFER_TYPE || (BUFFER_TYPE = {}));
/*!
 * @pixi/utils - v6.5.2
 * Compiled Wed, 24 Aug 2022 13:51:19 UTC
 *
 * @pixi/utils is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
settings.RETINA_PREFIX = /@([0-9\.]+)x/;
settings.FAIL_IF_MAJOR_PERFORMANCE_CAVEAT = !1;
function mapPremultipliedBlendModes() {
  for (var n = [], t = [], e = 0; e < 32; e++)
    n[e] = e, t[e] = e;
  n[BLEND_MODES.NORMAL_NPM] = BLEND_MODES.NORMAL, n[BLEND_MODES.ADD_NPM] = BLEND_MODES.ADD, n[BLEND_MODES.SCREEN_NPM] = BLEND_MODES.SCREEN, t[BLEND_MODES.NORMAL] = BLEND_MODES.NORMAL_NPM, t[BLEND_MODES.ADD] = BLEND_MODES.ADD_NPM, t[BLEND_MODES.SCREEN] = BLEND_MODES.SCREEN_NPM;
  var o = [];
  return o.push(t), o.push(n), o;
}
mapPremultipliedBlendModes();
var warnings = {};
function deprecation(n, t, e) {
  if (e === void 0 && (e = 3), !warnings[t]) {
    var o = new Error().stack;
    typeof o > "u" ? console.warn("PixiJS Deprecation Warning: ", t + `
Deprecated since v` + n) : (o = o.split(`
`).splice(e).join(`
`), console.groupCollapsed ? (console.groupCollapsed("%cPixiJS Deprecation Warning: %c%s", "color:#614108;background:#fffbe6", "font-weight:normal;color:#614108;background:#fffbe6", t + `
Deprecated since v` + n), console.warn(o), console.groupEnd()) : (console.warn("PixiJS Deprecation Warning: ", t + `
Deprecated since v` + n), console.warn(o))), warnings[t] = !0;
  }
}
(function() {
  function n(t, e, o) {
    this.canvas = settings.ADAPTER.createCanvas(), this.context = this.canvas.getContext("2d"), this.resolution = o || settings.RESOLUTION, this.resize(t, e);
  }
  return n.prototype.clear = function() {
    this.context.setTransform(1, 0, 0, 1, 0, 0), this.context.clearRect(0, 0, this.canvas.width, this.canvas.height);
  }, n.prototype.resize = function(t, e) {
    this.canvas.width = Math.round(t * this.resolution), this.canvas.height = Math.round(e * this.resolution);
  }, n.prototype.destroy = function() {
    this.context = null, this.canvas = null;
  }, Object.defineProperty(n.prototype, "width", {
    get: function() {
      return this.canvas.width;
    },
    set: function(t) {
      this.canvas.width = Math.round(t);
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(n.prototype, "height", {
    get: function() {
      return this.canvas.height;
    },
    set: function(t) {
      this.canvas.height = Math.round(t);
    },
    enumerable: !1,
    configurable: !0
  }), n;
})();
var Application = function() {
  function n(t) {
    var e = this;
    this.stage = new Container(), t = Object.assign({
      forceCanvas: !1
    }, t), this.renderer = autoDetectRenderer(t), n._plugins.forEach(function(o) {
      o.init.call(e, t);
    });
  }
  return n.registerPlugin = function(t) {
    deprecation("6.5.0", "Application.registerPlugin() is deprecated, use extensions.add()"), extensions.add({
      type: ExtensionType.Application,
      ref: t
    });
  }, n.prototype.render = function() {
    this.renderer.render(this.stage);
  }, Object.defineProperty(n.prototype, "view", {
    get: function() {
      return this.renderer.view;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(n.prototype, "screen", {
    get: function() {
      return this.renderer.screen;
    },
    enumerable: !1,
    configurable: !0
  }), n.prototype.destroy = function(t, e) {
    var o = this, R = n._plugins.slice(0);
    R.reverse(), R.forEach(function(N) {
      N.destroy.call(o);
    }), this.stage.destroy(e), this.stage = null, this.renderer.destroy(t), this.renderer = null;
  }, n._plugins = [], n;
}();
extensions.handleByList(ExtensionType.Application, Application._plugins);
extensions.add(ResizePlugin);
/*!
 * @pixi/mesh-extras - v6.5.2
 * Compiled Wed, 24 Aug 2022 13:51:19 UTC
 *
 * @pixi/mesh-extras is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var extendStatics$8 = function(n, t) {
  return extendStatics$8 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(e, o) {
    e.__proto__ = o;
  } || function(e, o) {
    for (var R in o)
      o.hasOwnProperty(R) && (e[R] = o[R]);
  }, extendStatics$8(n, t);
};
function __extends$8(n, t) {
  extendStatics$8(n, t);
  function e() {
    this.constructor = n;
  }
  n.prototype = t === null ? Object.create(t) : (e.prototype = t.prototype, new e());
}
var PlaneGeometry = function(n) {
  __extends$8(t, n);
  function t(e, o, R, N) {
    e === void 0 && (e = 100), o === void 0 && (o = 100), R === void 0 && (R = 10), N === void 0 && (N = 10);
    var M = n.call(this) || this;
    return M.segWidth = R, M.segHeight = N, M.width = e, M.height = o, M.build(), M;
  }
  return t.prototype.build = function() {
    for (var e = this.segWidth * this.segHeight, o = [], R = [], N = [], M = this.segWidth - 1, D = this.segHeight - 1, L = this.width / M, B = this.height / D, $ = 0; $ < e; $++) {
      var k = $ % this.segWidth, U = $ / this.segWidth | 0;
      o.push(k * L, U * B), R.push(k / M, U / D);
    }
    for (var z = M * D, $ = 0; $ < z; $++) {
      var X = $ % M, V = $ / M | 0, W = V * this.segWidth + X, Y = V * this.segWidth + X + 1, q = (V + 1) * this.segWidth + X, Z = (V + 1) * this.segWidth + X + 1;
      N.push(W, Y, q, Y, Z, q);
    }
    this.buffers[0].data = new Float32Array(o), this.buffers[1].data = new Float32Array(R), this.indexBuffer.data = new Uint16Array(N), this.buffers[0].update(), this.buffers[1].update(), this.indexBuffer.update();
  }, t;
}(MeshGeometry), RopeGeometry = function(n) {
  __extends$8(t, n);
  function t(e, o, R) {
    e === void 0 && (e = 200), R === void 0 && (R = 0);
    var N = n.call(this, new Float32Array(o.length * 4), new Float32Array(o.length * 4), new Uint16Array((o.length - 1) * 6)) || this;
    return N.points = o, N._width = e, N.textureScale = R, N.build(), N;
  }
  return Object.defineProperty(t.prototype, "width", {
    get: function() {
      return this._width;
    },
    enumerable: !1,
    configurable: !0
  }), t.prototype.build = function() {
    var e = this.points;
    if (!!e) {
      var o = this.getBuffer("aVertexPosition"), R = this.getBuffer("aTextureCoord"), N = this.getIndex();
      if (!(e.length < 1)) {
        o.data.length / 4 !== e.length && (o.data = new Float32Array(e.length * 4), R.data = new Float32Array(e.length * 4), N.data = new Uint16Array((e.length - 1) * 6));
        var M = R.data, D = N.data;
        M[0] = 0, M[1] = 0, M[2] = 0, M[3] = 1;
        for (var L = 0, B = e[0], $ = this._width * this.textureScale, k = e.length, U = 0; U < k; U++) {
          var z = U * 4;
          if (this.textureScale > 0) {
            var X = B.x - e[U].x, V = B.y - e[U].y, W = Math.sqrt(X * X + V * V);
            B = e[U], L += W / $;
          } else
            L = U / (k - 1);
          M[z] = L, M[z + 1] = 0, M[z + 2] = L, M[z + 3] = 1;
        }
        for (var Y = 0, U = 0; U < k - 1; U++) {
          var z = U * 2;
          D[Y++] = z, D[Y++] = z + 1, D[Y++] = z + 2, D[Y++] = z + 2, D[Y++] = z + 1, D[Y++] = z + 3;
        }
        R.update(), N.update(), this.updateVertices();
      }
    }
  }, t.prototype.updateVertices = function() {
    var e = this.points;
    if (!(e.length < 1)) {
      for (var o = e[0], R, N = 0, M = 0, D = this.buffers[0].data, L = e.length, B = 0; B < L; B++) {
        var $ = e[B], k = B * 4;
        B < e.length - 1 ? R = e[B + 1] : R = $, M = -(R.x - o.x), N = R.y - o.y;
        var U = Math.sqrt(N * N + M * M), z = this.textureScale > 0 ? this.textureScale * this._width / 2 : this._width / 2;
        N /= U, M /= U, N *= z, M *= z, D[k] = $.x + N, D[k + 1] = $.y + M, D[k + 2] = $.x - N, D[k + 3] = $.y - M, o = $;
      }
      this.buffers[0].update();
    }
  }, t.prototype.update = function() {
    this.textureScale > 0 ? this.build() : this.updateVertices();
  }, t;
}(MeshGeometry);
(function(n) {
  __extends$8(t, n);
  function t(e, o, R) {
    R === void 0 && (R = 0);
    var N = this, M = new RopeGeometry(e.height, o, R), D = new MeshMaterial(e);
    return R > 0 && (e.baseTexture.wrapMode = WRAP_MODES$5.REPEAT), N = n.call(this, M, D) || this, N.autoUpdate = !0, N;
  }
  return t.prototype._render = function(e) {
    var o = this.geometry;
    (this.autoUpdate || o._width !== this.shader.texture.height) && (o._width = this.shader.texture.height, o.update()), n.prototype._render.call(this, e);
  }, t;
})(Mesh);
var SimplePlane = function(n) {
  __extends$8(t, n);
  function t(e, o, R) {
    var N = this, M = new PlaneGeometry(e.width, e.height, o, R), D = new MeshMaterial(Texture.WHITE);
    return N = n.call(this, M, D) || this, N.texture = e, N.autoResize = !0, N;
  }
  return t.prototype.textureUpdated = function() {
    this._textureID = this.shader.texture._updateID;
    var e = this.geometry, o = this.shader.texture, R = o.width, N = o.height;
    this.autoResize && (e.width !== R || e.height !== N) && (e.width = this.shader.texture.width, e.height = this.shader.texture.height, e.build());
  }, Object.defineProperty(t.prototype, "texture", {
    get: function() {
      return this.shader.texture;
    },
    set: function(e) {
      this.shader.texture !== e && (this.shader.texture = e, this._textureID = -1, e.baseTexture.valid ? this.textureUpdated() : e.once("update", this.textureUpdated, this));
    },
    enumerable: !1,
    configurable: !0
  }), t.prototype._render = function(e) {
    this._textureID !== this.shader.texture._updateID && this.textureUpdated(), n.prototype._render.call(this, e);
  }, t.prototype.destroy = function(e) {
    this.shader.texture.off("update", this.textureUpdated, this), n.prototype.destroy.call(this, e);
  }, t;
}(Mesh);
(function(n) {
  __extends$8(t, n);
  function t(e, o, R, N, M) {
    e === void 0 && (e = Texture.EMPTY);
    var D = this, L = new MeshGeometry(o, R, N);
    L.getBuffer("aVertexPosition").static = !1;
    var B = new MeshMaterial(e);
    return D = n.call(this, L, B, null, M) || this, D.autoUpdate = !0, D;
  }
  return Object.defineProperty(t.prototype, "vertices", {
    get: function() {
      return this.geometry.getBuffer("aVertexPosition").data;
    },
    set: function(e) {
      this.geometry.getBuffer("aVertexPosition").data = e;
    },
    enumerable: !1,
    configurable: !0
  }), t.prototype._render = function(e) {
    this.autoUpdate && this.geometry.getBuffer("aVertexPosition").update(), n.prototype._render.call(this, e);
  }, t;
})(Mesh);
var DEFAULT_BORDER_SIZE = 10;
(function(n) {
  __extends$8(t, n);
  function t(e, o, R, N, M) {
    o === void 0 && (o = DEFAULT_BORDER_SIZE), R === void 0 && (R = DEFAULT_BORDER_SIZE), N === void 0 && (N = DEFAULT_BORDER_SIZE), M === void 0 && (M = DEFAULT_BORDER_SIZE);
    var D = n.call(this, Texture.WHITE, 4, 4) || this;
    return D._origWidth = e.orig.width, D._origHeight = e.orig.height, D._width = D._origWidth, D._height = D._origHeight, D._leftWidth = o, D._rightWidth = N, D._topHeight = R, D._bottomHeight = M, D.texture = e, D;
  }
  return t.prototype.textureUpdated = function() {
    this._textureID = this.shader.texture._updateID, this._refresh();
  }, Object.defineProperty(t.prototype, "vertices", {
    get: function() {
      return this.geometry.getBuffer("aVertexPosition").data;
    },
    set: function(e) {
      this.geometry.getBuffer("aVertexPosition").data = e;
    },
    enumerable: !1,
    configurable: !0
  }), t.prototype.updateHorizontalVertices = function() {
    var e = this.vertices, o = this._getMinScale();
    e[9] = e[11] = e[13] = e[15] = this._topHeight * o, e[17] = e[19] = e[21] = e[23] = this._height - this._bottomHeight * o, e[25] = e[27] = e[29] = e[31] = this._height;
  }, t.prototype.updateVerticalVertices = function() {
    var e = this.vertices, o = this._getMinScale();
    e[2] = e[10] = e[18] = e[26] = this._leftWidth * o, e[4] = e[12] = e[20] = e[28] = this._width - this._rightWidth * o, e[6] = e[14] = e[22] = e[30] = this._width;
  }, t.prototype._getMinScale = function() {
    var e = this._leftWidth + this._rightWidth, o = this._width > e ? 1 : this._width / e, R = this._topHeight + this._bottomHeight, N = this._height > R ? 1 : this._height / R, M = Math.min(o, N);
    return M;
  }, Object.defineProperty(t.prototype, "width", {
    get: function() {
      return this._width;
    },
    set: function(e) {
      this._width = e, this._refresh();
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(t.prototype, "height", {
    get: function() {
      return this._height;
    },
    set: function(e) {
      this._height = e, this._refresh();
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(t.prototype, "leftWidth", {
    get: function() {
      return this._leftWidth;
    },
    set: function(e) {
      this._leftWidth = e, this._refresh();
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(t.prototype, "rightWidth", {
    get: function() {
      return this._rightWidth;
    },
    set: function(e) {
      this._rightWidth = e, this._refresh();
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(t.prototype, "topHeight", {
    get: function() {
      return this._topHeight;
    },
    set: function(e) {
      this._topHeight = e, this._refresh();
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(t.prototype, "bottomHeight", {
    get: function() {
      return this._bottomHeight;
    },
    set: function(e) {
      this._bottomHeight = e, this._refresh();
    },
    enumerable: !1,
    configurable: !0
  }), t.prototype._refresh = function() {
    var e = this.texture, o = this.geometry.buffers[1].data;
    this._origWidth = e.orig.width, this._origHeight = e.orig.height;
    var R = 1 / this._origWidth, N = 1 / this._origHeight;
    o[0] = o[8] = o[16] = o[24] = 0, o[1] = o[3] = o[5] = o[7] = 0, o[6] = o[14] = o[22] = o[30] = 1, o[25] = o[27] = o[29] = o[31] = 1, o[2] = o[10] = o[18] = o[26] = R * this._leftWidth, o[4] = o[12] = o[20] = o[28] = 1 - R * this._rightWidth, o[9] = o[11] = o[13] = o[15] = N * this._topHeight, o[17] = o[19] = o[21] = o[23] = 1 - N * this._bottomHeight, this.updateHorizontalVertices(), this.updateVerticalVertices(), this.geometry.buffers[0].update(), this.geometry.buffers[1].update();
  }, t;
})(SimplePlane);
/*!
 * @pixi/sprite-animated - v6.5.2
 * Compiled Wed, 24 Aug 2022 13:51:19 UTC
 *
 * @pixi/sprite-animated is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var extendStatics$7 = function(n, t) {
  return extendStatics$7 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(e, o) {
    e.__proto__ = o;
  } || function(e, o) {
    for (var R in o)
      o.hasOwnProperty(R) && (e[R] = o[R]);
  }, extendStatics$7(n, t);
};
function __extends$7(n, t) {
  extendStatics$7(n, t);
  function e() {
    this.constructor = n;
  }
  n.prototype = t === null ? Object.create(t) : (e.prototype = t.prototype, new e());
}
var AnimatedSprite = function(n) {
  __extends$7(t, n);
  function t(e, o) {
    o === void 0 && (o = !0);
    var R = n.call(this, e[0] instanceof Texture ? e[0] : e[0].texture) || this;
    return R._textures = null, R._durations = null, R._autoUpdate = o, R._isConnectedToTicker = !1, R.animationSpeed = 1, R.loop = !0, R.updateAnchor = !1, R.onComplete = null, R.onFrameChange = null, R.onLoop = null, R._currentTime = 0, R._playing = !1, R._previousFrame = null, R.textures = e, R;
  }
  return t.prototype.stop = function() {
    !this._playing || (this._playing = !1, this._autoUpdate && this._isConnectedToTicker && (Ticker.shared.remove(this.update, this), this._isConnectedToTicker = !1));
  }, t.prototype.play = function() {
    this._playing || (this._playing = !0, this._autoUpdate && !this._isConnectedToTicker && (Ticker.shared.add(this.update, this, UPDATE_PRIORITY.HIGH), this._isConnectedToTicker = !0));
  }, t.prototype.gotoAndStop = function(e) {
    this.stop();
    var o = this.currentFrame;
    this._currentTime = e, o !== this.currentFrame && this.updateTexture();
  }, t.prototype.gotoAndPlay = function(e) {
    var o = this.currentFrame;
    this._currentTime = e, o !== this.currentFrame && this.updateTexture(), this.play();
  }, t.prototype.update = function(e) {
    if (!!this._playing) {
      var o = this.animationSpeed * e, R = this.currentFrame;
      if (this._durations !== null) {
        var N = this._currentTime % 1 * this._durations[this.currentFrame];
        for (N += o / 60 * 1e3; N < 0; )
          this._currentTime--, N += this._durations[this.currentFrame];
        var M = Math.sign(this.animationSpeed * e);
        for (this._currentTime = Math.floor(this._currentTime); N >= this._durations[this.currentFrame]; )
          N -= this._durations[this.currentFrame] * M, this._currentTime += M;
        this._currentTime += N / this._durations[this.currentFrame];
      } else
        this._currentTime += o;
      this._currentTime < 0 && !this.loop ? (this.gotoAndStop(0), this.onComplete && this.onComplete()) : this._currentTime >= this._textures.length && !this.loop ? (this.gotoAndStop(this._textures.length - 1), this.onComplete && this.onComplete()) : R !== this.currentFrame && (this.loop && this.onLoop && (this.animationSpeed > 0 && this.currentFrame < R ? this.onLoop() : this.animationSpeed < 0 && this.currentFrame > R && this.onLoop()), this.updateTexture());
    }
  }, t.prototype.updateTexture = function() {
    var e = this.currentFrame;
    this._previousFrame !== e && (this._previousFrame = e, this._texture = this._textures[e], this._textureID = -1, this._textureTrimmedID = -1, this._cachedTint = 16777215, this.uvs = this._texture._uvs.uvsFloat32, this.updateAnchor && this._anchor.copyFrom(this._texture.defaultAnchor), this.onFrameChange && this.onFrameChange(this.currentFrame));
  }, t.prototype.destroy = function(e) {
    this.stop(), n.prototype.destroy.call(this, e), this.onComplete = null, this.onFrameChange = null, this.onLoop = null;
  }, t.fromFrames = function(e) {
    for (var o = [], R = 0; R < e.length; ++R)
      o.push(Texture.from(e[R]));
    return new t(o);
  }, t.fromImages = function(e) {
    for (var o = [], R = 0; R < e.length; ++R)
      o.push(Texture.from(e[R]));
    return new t(o);
  }, Object.defineProperty(t.prototype, "totalFrames", {
    get: function() {
      return this._textures.length;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(t.prototype, "textures", {
    get: function() {
      return this._textures;
    },
    set: function(e) {
      if (e[0] instanceof Texture)
        this._textures = e, this._durations = null;
      else {
        this._textures = [], this._durations = [];
        for (var o = 0; o < e.length; o++)
          this._textures.push(e[o].texture), this._durations.push(e[o].time);
      }
      this._previousFrame = null, this.gotoAndStop(0), this.updateTexture();
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(t.prototype, "currentFrame", {
    get: function() {
      var e = Math.floor(this._currentTime) % this._textures.length;
      return e < 0 && (e += this._textures.length), e;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(t.prototype, "playing", {
    get: function() {
      return this._playing;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(t.prototype, "autoUpdate", {
    get: function() {
      return this._autoUpdate;
    },
    set: function(e) {
      e !== this._autoUpdate && (this._autoUpdate = e, !this._autoUpdate && this._isConnectedToTicker ? (Ticker.shared.remove(this.update, this), this._isConnectedToTicker = !1) : this._autoUpdate && !this._isConnectedToTicker && this._playing && (Ticker.shared.add(this.update, this), this._isConnectedToTicker = !0));
    },
    enumerable: !1,
    configurable: !0
  }), t;
}(Sprite);
/*!
 * pixi.js - v6.5.2
 * Compiled Wed, 24 Aug 2022 13:51:19 UTC
 *
 * pixi.js is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
extensions.add(
  AccessibilityManager,
  Extract,
  InteractionManager,
  ParticleRenderer,
  Prepare,
  BatchRenderer,
  TilingSpriteRenderer,
  BitmapFontLoader,
  CompressedTextureLoader,
  DDSLoader,
  KTXLoader,
  SpritesheetLoader,
  TickerPlugin,
  AppLoaderPlugin
);
var ye, Me, _i, Tu, rc, ns, jo, Su, ic, Cu, nc, Ba, oh, Qi, da, $a, uh, ss, as, Vo, tn, pa, ka, os, Xo, Iu, sc, Pr, fi, wu, ac, Ga, lh, en, va, Ru, oc, Ua, hh, Pu, uc, Au, lc, us, Wo;
const Ta = class {
  constructor(t, e, o, R, N) {
    it(this, Tu);
    it(this, ns);
    it(this, Su);
    it(this, Cu);
    it(this, Ba);
    it(this, Qi);
    it(this, $a);
    it(this, as);
    it(this, tn);
    it(this, os);
    it(this, Iu);
    it(this, Pr);
    it(this, wu);
    it(this, Ga);
    it(this, en);
    it(this, Ru);
    it(this, Ua);
    it(this, Pu);
    it(this, Au);
    it(this, us);
    it(this, ye, {});
    it(this, Me, {});
    it(this, _i, void 0);
    it(this, ka, () => {
      I.volumeAll = Number(this.val.getVal("sys:sn.sound.global_volume", 1)), et(this, ka, () => {
      });
    });
    this.cfg = t, this.val = o, this.main = R, this.sys = N, e.volume = (M) => st(this, Tu, rc).call(this, M), e.fadebgm = (M) => st(this, Ba, oh).call(this, M), e.fadeoutbgm = (M) => st(this, Su, ic).call(this, M), e.fadeoutse = (M) => st(this, Cu, nc).call(this, M), e.fadese = (M) => st(this, Qi, da).call(this, M), e.playbgm = (M) => st(this, $a, uh).call(this, M), e.playse = (M) => st(this, as, Vo).call(this, M), e.stop_allse = () => st(this, os, Xo).call(this), e.stopbgm = (M) => st(this, Iu, sc).call(this, M), e.stopse = (M) => st(this, Pr, fi).call(this, M), e.wb = (M) => st(this, wu, ac).call(this, M), e.wf = (M) => st(this, Ga, lh).call(this, M), e.stopfadese = (M) => st(this, en, va).call(this, M), e.wl = (M) => st(this, Ru, oc).call(this, M), e.ws = (M) => st(this, Ua, hh).call(this, M), e.xchgbuf = (M) => st(this, Pu, uc).call(this, M), this.val.setVal_Nochk("save", "const.sn.loopPlaying", "{}"), o.setVal_Nochk("tmp", "const.sn.sound.codecs", JSON.stringify(G.supported));
  }
  setEvtMng(t) {
    et(this, _i, t);
  }
  setNoticeChgVolume(t, e) {
    this.val.defValTrg("sys:sn.sound.global_volume", (o, R) => t(I.volumeAll = Number(R))), this.val.defValTrg("sys:sn.sound.movie_volume", (o, R) => e(Number(R))), this.val.setVal_Nochk("sys", "sn.sound.global_volume", this.val.getVal("sys:sn.sound.global_volume", 1)), this.val.setVal_Nochk("sys", "sn.sound.movie_volume", this.val.getVal("sys:sn.sound.movie_volume", 1));
  }
  clearCache() {
    I.removeAll();
  }
  loadAheadSnd(t) {
    [t.clickse, t.enterse, t.leavese].forEach((e) => {
      !e || I.exists(e) || st(this, tn, pa).call(this, "", e, { preload: !0, autoPlay: !1 });
    });
  }
  playLoopFromSaveObj() {
    const t = String(this.val.getVal("save:const.sn.loopPlaying", "{}"));
    if (this.val.flush(), t === "{}") {
      st(this, os, Xo).call(this);
      return;
    }
    const e = [];
    et(this, Me, JSON.parse(t));
    for (const o in H(this, Me)) {
      const R = "save:const.sn.sound." + o + ".", N = {
        fn: String(this.val.getVal(R + "fn")),
        buf: o,
        join: !1,
        loop: !0,
        volume: Number(this.val.getVal(R + "volume")),
        start_ms: Number(this.val.getVal(R + "start_ms")),
        end_ms: Number(this.val.getVal(R + "end_ms")),
        ret_ms: Number(this.val.getVal(R + "ret_ms"))
      };
      e.push(() => {
        N.buf === "BGM" ? st(this, $a, uh).call(this, N) : st(this, as, Vo).call(this, N);
      });
    }
    st(this, os, Xo).call(this), e.forEach((o) => o());
  }
};
let SoundMng = Ta;
ye = new WeakMap(), Me = new WeakMap(), _i = new WeakMap(), Tu = new WeakSet(), rc = function(t) {
  const { buf: e = "SE" } = t, o = "const.sn.sound." + e + ".volume", R = st(this, ns, jo).call(this, t, 1);
  return Number(this.val.getVal("sys:" + o)) === R ? !1 : (this.val.setVal_Nochk("sys", o, R), this.val.flush(), t.time = 0, t.volume = Number(this.val.getVal("save:" + o)), st(this, Qi, da).call(this, t));
}, ns = new WeakSet(), jo = function(t, e) {
  const o = argChk_Num(t, "volume", e);
  return o < 0 ? 0 : o > 1 ? 1 : o;
}, Su = new WeakSet(), ic = function(t) {
  return t.volume = 0, st(this, Ba, oh).call(this, t);
}, Cu = new WeakSet(), nc = function(t) {
  return t.volume = 0, st(this, Qi, da).call(this, t);
}, Ba = new WeakSet(), oh = function(t) {
  return t.buf = "BGM", st(this, Qi, da).call(this, t);
}, Qi = new WeakSet(), da = function(t) {
  st(this, en, va).call(this, t);
  const { buf: e = "SE" } = t, o = H(this, ye)[e];
  if (!(o != null && o.playing()) || !o.snd)
    return !1;
  const R = "const.sn.sound." + e + ".volume", N = st(this, ns, jo).call(this, t, NaN);
  this.val.setVal_Nochk("save", R, N);
  const M = N * Number(this.val.getVal("sys:" + R, 1)), D = argChk_Boolean(t, "stop", N === 0);
  D && (st(this, us, Wo).call(this, e), this.val.setVal_Nochk("save", "const.sn.sound." + e + ".fn", "")), this.val.flush();
  const L = argChk_Num(t, "time", NaN), B = argChk_Num(t, "delay", 0);
  if (L === 0 && B === 0 || this.val.getVal("tmp:sn.skip.enabled") || H(this, _i).isSkippingByKeyDown())
    return o.snd.volume = M, D && st(this, Pr, fi).call(this, t), !1;
  const $ = argChk_Num(t, "repeat", 1);
  return o.twFade = new Tween({ v: o.snd.volume }).to({ v: M }, L).delay(B).easing(CmnTween.ease(t.ease)).repeat($ === 0 ? 1 / 0 : $ - 1).yoyo(argChk_Boolean(t, "yoyo", !1)).onUpdate((k) => {
    o.playing() && (o.snd.volume = k.v);
  }).onComplete(() => {
    const k = H(this, ye)[t.buf = o.now_buf];
    !(k != null && k.twFade) || (delete k.twFade, D && st(this, Pr, fi).call(this, t), k.resumeFade && this.main.resume());
  }).start(), !1;
}, $a = new WeakSet(), uh = function(t) {
  return t.buf = "BGM", t.canskip = !1, argChk_Boolean(t, "loop", !0), st(this, as, Vo).call(this, t);
}, ss = new WeakMap(), as = new WeakSet(), Vo = function(t) {
  const { buf: e = "SE", fn: o } = t;
  if (st(this, Pr, fi).call(this, { buf: e }), !o)
    throw `[playse] fn\u306F\u5FC5\u9808\u3067\u3059 buf:${e}`;
  if (argChk_Boolean(t, "canskip", !0) && H(this, _i).isSkippingByKeyDown())
    return !1;
  const R = argChk_Boolean(t, "loop", !1);
  st(this, Au, lc).call(this, e, R);
  const N = "const.sn.sound." + e + ".";
  this.val.setVal_Nochk("save", N + "fn", o);
  const M = st(this, ns, jo).call(this, t, 1);
  this.val.setVal_Nochk("save", N + "volume", M);
  const D = M * Number(this.val.getVal("sys:" + N + "volume", 1)), L = argChk_Num(t, "start_ms", 0), B = argChk_Num(t, "end_ms", H(Ta, ss)), $ = argChk_Num(t, "ret_ms", 0);
  if (L < 0)
    throw `[playse] start_ms:${L} \u304C\u8CA0\u306E\u5024\u3067\u3059`;
  if ($ < 0)
    throw `[playse] ret_ms:${$} \u304C\u8CA0\u306E\u5024\u3067\u3059`;
  if (B > 0) {
    if (L >= B)
      throw `[playse] start_ms:${L} >= end_ms:${B} \u306F\u7570\u5E38\u5024\u3067\u3059`;
    if ($ >= B)
      throw `[playse] ret_ms:${$} >= end_ms:${B} \u306F\u7570\u5E38\u5024\u3067\u3059`;
  }
  this.val.setVal_Nochk("save", N + "start_ms", L), this.val.setVal_Nochk("save", N + "end_ms", B), this.val.setVal_Nochk("save", N + "ret_ms", $), this.val.flush();
  const k = I.find(o), U = H(this, ye)[e] = {
    now_buf: e,
    snd: k,
    loop: R,
    start_ms: L,
    end_ms: B,
    ret_ms: $,
    resume: !1,
    playing: () => !0,
    onend: () => {
      const W = H(this, ye)[t.buf = U.now_buf];
      !W || (delete H(this, ye)[t.buf], W.playing = () => !1, st(this, en, va).call(this, t), W.resume && this.main.resume());
    }
  }, z = {
    loop: R,
    volume: D,
    speed: argChk_Num(t, "speed", 1),
    sprites: {},
    loaded: (W, Y) => {
      if (W) {
        this.main.errScript(`Sound \u30ED\u30FC\u30C9\u5931\u6557\u3067\u3059a fn:${o} ${W}`, !1);
        return;
      }
      if (!Y)
        return;
      const q = H(this, ye)[U.now_buf];
      q && (q.snd = Y);
    }
  };
  let X = "";
  if (L > 0 || B < H(Ta, ss)) {
    X = `${o};${L};${B};${$}`;
    const W = z.sprites[X] = {
      start: L / 1e3,
      end: B / 1e3
    };
    z.preload = !0;
    const Y = z.loaded;
    z.loaded = (q, Z) => {
      if (q) {
        this.main.errScript(`Sound \u30ED\u30FC\u30C9\u5931\u6557\u3067\u3059b fn:${o} ${q}`, !1);
        return;
      }
      if (!Z)
        return;
      const J = Z.duration;
      if (Y == null || Y(q, Z), W.end < 0) {
        if (W.end += J, Z.removeSprites(X), Z.addSprites(X, W), W.start >= W.end)
          throw `[playse] start_ms:${L} >= end_ms:${B}(${W.end * 1e3}) \u306F\u7570\u5E38\u5024\u3067\u3059`;
        if ($ >= W.end * 1e3)
          throw `[playse] ret_ms:${$} >= end_ms:${B}(${W.end * 1e3}) \u306F\u7570\u5E38\u5024\u3067\u3059`;
      }
      if (W.start >= J)
        throw `[playse] start_ms:${L} >= \u97F3\u58F0\u30D5\u30A1\u30A4\u30EB\u518D\u751F\u6642\u9593:${J} \u306F\u7570\u5E38\u5024\u3067\u3059`;
      if (B !== H(Ta, ss) && W.end >= J)
        throw `[playse] end_ms:${B} >= \u97F3\u58F0\u30D5\u30A1\u30A4\u30EB\u518D\u751F\u6642\u9593:${J} \u306F\u7570\u5E38\u5024\u3067\u3059`;
      Z.play(X, z.complete);
    };
  } else
    z.autoPlay = !0;
  if (R ? $ !== 0 && (z.loop = !1, z.complete = (W) => {
    const Y = W.duration, q = `${o};loop2;${B};${$}`, Z = {
      preload: !0,
      loop: !0,
      volume: D,
      speed: z.speed,
      sprites: {},
      loaded: (Q, K) => {
        if (!K)
          return;
        const rt = H(this, ye)[U.now_buf];
        rt && (rt.snd = K), K.play(q);
      }
    }, J = Z.sprites[q] = {
      start: $ / 1e3,
      end: B / 1e3
    };
    if (J.end < 0 && (J.end += Y, W.removeSprites(q), W.addSprites(q, J)), J.start >= Y)
      throw `[playse] ret_ms:${$} >= \u97F3\u58F0\u30D5\u30A1\u30A4\u30EB\u518D\u751F\u6642\u9593:${Y} \u306F\u7570\u5E38\u5024\u3067\u3059`;
    st(this, tn, pa).call(this, e, o, Z);
  }) : z.complete = () => {
    var W;
    return (W = H(this, ye)[U.now_buf]) == null ? void 0 : W.onend();
  }, H(this, ka).call(this), k) {
    if (k.volume = D, X)
      st(this, tn, pa).call(this, e, o, z);
    else if (k.isPlayable) {
      const W = k.options.source;
      !(W instanceof ArrayBuffer) || W.byteLength === 0 ? k.play(z) : U.snd = A.from({
        ...z,
        url: k.options.url,
        source: W
      });
    }
    return !1;
  }
  const V = argChk_Boolean(t, "join", !0);
  if (V) {
    const W = z.loaded;
    z.loaded = (Y, q) => {
      W == null || W(Y, q), this.main.resume();
    };
  }
  return st(this, tn, pa).call(this, e, o, z), V;
}, tn = new WeakSet(), pa = function(t, e, o) {
  const R = this.cfg.searchPath(e, Config.EXT_SOUND);
  if (R.slice(-4) !== ".bin") {
    o.url = R;
    const N = A.from(o);
    t && (H(this, ye)[t].snd = N), o.loop || I.add(e, N);
    return;
  }
  new Loader().add({ name: e, url: R, xhrType: LoaderResource.XHR_RESPONSE_TYPE.BUFFER }).use((N, M) => {
    this.sys.dec(N.extension, N.data).then((D) => {
      N.data = D, M == null || M();
    }).catch((D) => this.main.errScript(`Sound \u30ED\u30FC\u30C9\u5931\u6557\u3067\u3059 fn:${N.name} ${D}`, !1));
  }).load((N, M) => {
    var L;
    o.source = (L = M[e]) == null ? void 0 : L.data;
    const D = A.from(o);
    t && (H(this, ye)[t].snd = D), o.loop || I.add(e, D);
  });
}, ka = new WeakMap(), os = new WeakSet(), Xo = function() {
  for (const t in H(this, ye))
    st(this, Pr, fi).call(this, { buf: t });
  return et(this, ye, {}), I.stopAll(), !1;
}, Iu = new WeakSet(), sc = function(t) {
  return t.buf = "BGM", st(this, Pr, fi).call(this, t);
}, Pr = new WeakSet(), fi = function(t) {
  var R;
  const { buf: e = "SE" } = t;
  st(this, us, Wo).call(this, e);
  const o = H(this, ye)[e];
  return o && ((R = o.snd) == null || R.stop(), o.onend()), !1;
}, wu = new WeakSet(), ac = function(t) {
  return t.buf = "BGM", st(this, Ga, lh).call(this, t);
}, Ga = new WeakSet(), lh = function(t) {
  const { buf: e = "SE" } = t, o = H(this, ye)[e];
  return !(o != null && o.twFade) || !o.playing() ? !1 : o.resumeFade = H(this, _i).waitEvent(
    () => st(this, en, va).call(this, t),
    argChk_Boolean(t, "canskip", !0),
    argChk_Boolean(t, "global", !1)
  );
}, en = new WeakSet(), va = function(t) {
  var o, R;
  const { buf: e = "SE" } = t;
  return (R = (o = H(this, ye)[e]) == null ? void 0 : o.twFade) == null || R.stop().end(), !1;
}, Ru = new WeakSet(), oc = function(t) {
  return t.buf = "BGM", st(this, Ua, hh).call(this, t);
}, Ua = new WeakSet(), hh = function(t) {
  const { buf: e = "SE" } = t, o = H(this, ye)[e];
  return !(o != null && o.playing()) || o.loop ? !1 : o.resume = H(this, _i).waitEvent(
    () => {
      t.buf = o.now_buf, st(this, Pr, fi).call(this, t);
      const R = H(this, ye)[t.buf];
      !(R != null && R.playing()) || R.loop || R.onend();
    },
    argChk_Boolean(t, "canskip", !1),
    argChk_Boolean(t, "global", !1)
  );
}, Pu = new WeakSet(), uc = function(t) {
  const { buf: e = "SE", buf2: o = "SE" } = t;
  if (e === o)
    return !1;
  const R = H(this, ye)[e];
  R && (R.now_buf = o);
  const N = H(this, ye)[o];
  N && (N.now_buf = e), [H(this, ye)[e], H(this, ye)[o]] = [N, R];
  const M = "const.sn.sound." + e + ".", D = Number(this.val.getVal("save:" + M + "volume")), L = Number(this.val.getVal("save:" + M + "fn")), B = "const.sn.sound." + o + ".", $ = Number(this.val.getVal("save:" + B + "volume")), k = Number(this.val.getVal("save:" + B + "fn"));
  return this.val.setVal_Nochk("save", M + "volume", $), this.val.setVal_Nochk("save", B + "volume", D), this.val.setVal_Nochk("save", M + "fn", k), this.val.setVal_Nochk("save", B + "fn", L), e in H(this, Me) == o in H(this, Me) && (e in H(this, Me) ? (delete H(this, Me)[e], H(this, Me)[o] = 0) : (delete H(this, Me)[o], H(this, Me)[e] = 0), this.val.setVal_Nochk("save", "const.sn.loopPlaying", JSON.stringify(H(this, Me)))), this.val.flush(), !1;
}, Au = new WeakSet(), lc = function(t, e) {
  if (!e) {
    st(this, us, Wo).call(this, t);
    return;
  }
  H(this, Me)[t] = 0, this.val.setVal_Nochk("save", "const.sn.loopPlaying", JSON.stringify(H(this, Me))), this.val.flush();
}, us = new WeakSet(), Wo = function(t) {
  delete H(this, Me)[t], this.val.setVal_Nochk("save", "const.sn.loopPlaying", JSON.stringify(H(this, Me))), this.val.flush();
}, it(SoundMng, ss, 999e3);
var oe;
const Fh = class {
  constructor(t, e, o, R, N, M, D, L) {
    it(this, oe, void 0);
    this.cls = e, this.hArg = N, this.sys = M, this.val = D, this.ret = L, this.lay = (U) => this.getPage(U).lay(U), this.getPage = (U) => Fh.argChk_page(U, "fore") !== "back" ? H(this, oe).fore : H(this, oe).back;
    const B = M.hFactoryCls[e];
    if (!B)
      throw `\u5C5E\u6027 class\u3010${e}\u3011\u304C\u4E0D\u6B63\u3067\u3059`;
    et(this, oe, { fore: B(), back: B() }), H(this, oe).fore.layname = H(this, oe).back.layname = t;
    const $ = N[":id_tag"] = `layer:${t} cls:${e}`;
    H(this, oe).fore.name = `${$} page:A`, H(this, oe).back.name = `${$} page:B`, o.addChild(this.fore.spLay), R.addChild(this.back.spLay), argChk_Boolean(N, "visible", !0), argChk_Boolean(N, "visible", !0), L.isWait = this.fore.lay(N) || this.back.lay(N);
    const k = `const.sn.lay.${t}`;
    D.setVal_Nochk("tmp", k, !0), D.defTmp(k + ".fore.alpha", () => H(this, oe).fore.alpha), D.defTmp(k + ".back.alpha", () => H(this, oe).back.alpha), D.defTmp(k + ".fore.height", () => H(this, oe).fore.height), D.defTmp(k + ".back.height", () => H(this, oe).back.height), D.defTmp(k + ".fore.visible", () => H(this, oe).fore.spLay.visible), D.defTmp(k + ".back.visible", () => H(this, oe).back.spLay.visible), D.defTmp(k + ".fore.width", () => H(this, oe).fore.width), D.defTmp(k + ".back.width", () => H(this, oe).back.width), D.defTmp(k + ".fore.x", () => H(this, oe).fore.x), D.defTmp(k + ".back.x", () => H(this, oe).back.x), D.defTmp(k + ".fore.y", () => H(this, oe).fore.y), D.defTmp(k + ".back.y", () => H(this, oe).back.y);
  }
  destroy() {
    H(this, oe).fore.destroy(), H(this, oe).back.destroy();
  }
  static argChk_page(t, e) {
    var R;
    const o = (R = t.page) != null ? R : e;
    if (o === "fore" || o === "back")
      return t.page = o;
    throw Error("\u5C5E\u6027 page\u3010" + o + "\u3011\u304C\u4E0D\u6B63\u3067\u3059");
  }
  get fore() {
    return H(this, oe).fore;
  }
  get back() {
    return H(this, oe).back;
  }
  transPage(t) {
    [H(this, oe).back, H(this, oe).fore] = [H(this, oe).fore, H(this, oe).back], H(this, oe).back.copy(H(this, oe).fore, t);
  }
};
let Pages = Fh;
oe = new WeakMap();
var Ou, Nu;
const pi = class {
  constructor() {
    this.layname = "", this.name_ = "", this.spLay = new Sprite(Texture.EMPTY);
  }
  set name(t) {
    this.name_ = t;
  }
  get name() {
    return this.name_;
  }
  get alpha() {
    return this.spLay.alpha;
  }
  set alpha(t) {
    this.spLay.alpha = t;
  }
  get height() {
    return this.spLay.height;
  }
  get rotation() {
    return this.spLay.angle;
  }
  set rotation(t) {
    this.spLay.angle = t;
  }
  get scale_x() {
    return this.spLay.scale.x;
  }
  set scale_x(t) {
    this.spLay.scale.x = t;
  }
  get scale_y() {
    return this.spLay.scale.y;
  }
  set scale_y(t) {
    this.spLay.scale.y = t;
  }
  get width() {
    return this.spLay.width;
  }
  get x() {
    return this.spLay.x;
  }
  set x(t) {
    this.spLay.x = t;
  }
  get y() {
    return this.spLay.y;
  }
  set y(t) {
    this.spLay.y = t;
  }
  destroy() {
  }
  lay(t) {
    return "alpha" in t && (this.spLay.alpha = argChk_Num(t, "alpha", 1)), pi.setBlendmode(this.spLay, t), ("pivot_x" in t || "pivot_y" in t) && this.spLay.pivot.set(
      argChk_Num(t, "pivot_x", this.spLay.pivot.x),
      argChk_Num(t, "pivot_y", this.spLay.pivot.y)
    ), "rotation" in t && (this.spLay.angle = argChk_Num(t, "rotation", 0)), ("scale_x" in t || "scale_y" in t) && this.spLay.scale.set(
      argChk_Num(t, "scale_x", this.spLay.scale.x),
      argChk_Num(t, "scale_y", this.spLay.scale.y)
    ), "visible" in t && (this.spLay.visible = argChk_Boolean(t, "visible", !0)), !1;
  }
  static setBlendmode(t, e) {
    const { blendmode: o } = e;
    if (!o)
      return;
    const R = pi.getBlendmodeNum(o), N = t;
    N && (N.blendMode = R), t.children.forEach((M) => {
      const D = M;
      D && (D.blendMode = R);
    });
  }
  static getBlendmodeNum(t) {
    if (!t)
      return BLEND_MODES$5.NORMAL;
    const e = H(pi, Ou)[t];
    if (e !== void 0)
      return e;
    throw `${t} \u306F\u30B5\u30DD\u30FC\u30C8\u3055\u308C\u306A\u3044 blendmode \u3067\u3059`;
  }
  static getNum2Blendmode(t) {
    var e;
    return (e = H(pi, Nu)[t]) != null ? e : "normal";
  }
  get containMovement() {
    return !1;
  }
  renderStart() {
  }
  renderEnd() {
  }
  clearLay(t) {
    this.spLay.alpha = 1, this.spLay.blendMode = BLEND_MODES$5.NORMAL, this.spLay.pivot.set(0, 0), this.spLay.angle = 0, this.spLay.scale.set(1, 1), argChk_Boolean(t, "filter", !1) && (this.spLay.filters = []);
  }
  copy(t, e) {
    const o = this.name_;
    this.playback(t.record(), e), this.name = o;
  }
  record() {
    return {
      name: this.name_,
      idx: this.spLay.parent.getChildIndex(this.spLay),
      alpha: this.spLay.alpha,
      blendMode: this.spLay.blendMode,
      rotation: this.spLay.angle,
      scale_x: this.spLay.scale.x,
      scale_y: this.spLay.scale.y,
      pivot_x: this.spLay.pivot.x,
      pivot_y: this.spLay.pivot.y,
      x: this.spLay.x,
      y: this.spLay.y,
      visible: this.spLay.visible
    };
  }
  playback(t, e) {
    this.name = t.name, this.clearLay({ filter: "true" }), this.spLay.alpha = t.alpha, this.spLay.blendMode = t.blendMode, this.spLay.angle = t.rotation, this.spLay.scale.set(t.scale_x, t.scale_y), this.spLay.pivot.set(t.pivot_x, t.pivot_y), this.spLay.position.set(t.x, t.y), this.spLay.visible = t.visible;
  }
  snapshot(t, e) {
    t.render(this.spLay, { clear: !1 }), e();
  }
  snapshot_end() {
  }
  makeDesignCast(t) {
  }
  makeDesignCastChildren(t) {
  }
  showDesignCast() {
  }
  showDesignCastChildren() {
  }
  cvsResize() {
  }
  cvsResizeChildren() {
  }
  dump() {
    return ` "idx":${this.spLay.parent.getChildIndex(this.spLay)}, "visible":"${this.spLay.visible}", "left":${this.spLay.x}, "top":${this.spLay.y}, "alpha":${this.spLay.alpha}, "rotation":${this.spLay.angle}, "name":"${this.name_}", "scale_x":${this.spLay.scale.x}, "scale_y":${this.spLay.scale.y}`;
  }
  static setXY(t, e, o, R = !1, N = !1) {
    if (e.pos) {
      pi.setXYByPos(t, e.pos, o);
      return;
    }
    const M = t.getBounds(), D = o.scale.x < 0 ? -o.scale.x : o.scale.x, L = D === 1 ? M.width : M.width * D, B = o.scale.y < 0 ? -o.scale.y : o.scale.y, $ = B === 1 ? M.height : M.height * B;
    let k = o.x;
    "left" in e ? (k = argChk_Num(e, "left", 0), k > -1 && k < 1 && (k *= CmnLib.stageW)) : "center" in e ? (k = argChk_Num(e, "center", 0), k > -1 && k < 1 && (k *= CmnLib.stageW), k = k - (N ? L / 3 : L) / 2) : "right" in e ? (k = argChk_Num(e, "right", 0), k > -1 && k < 1 && (k *= CmnLib.stageW), k = k - (N ? L / 3 : L)) : "s_right" in e && (k = argChk_Num(e, "s_right", 0), k > -1 && k < 1 && (k *= CmnLib.stageW), k = CmnLib.stageW - k - (N ? L / 3 : L)), o.x = int(o.scale.x < 0 ? k + (N ? L / 3 : L) : k);
    let U = o.y;
    "top" in e ? (U = argChk_Num(e, "top", 0), U > -1 && U < 1 && (U *= CmnLib.stageH)) : "middle" in e ? (U = argChk_Num(e, "middle", 0), U > -1 && U < 1 && (U *= CmnLib.stageH), U = U - $ / 2) : "bottom" in e ? (U = argChk_Num(e, "bottom", 0), U > -1 && U < 1 && (U *= CmnLib.stageH), U = U - $) : "s_bottom" in e && (U = argChk_Num(e, "s_bottom", 0), U > -1 && U < 1 && (U *= CmnLib.stageH), U = CmnLib.stageH - U - $), o.y = int(o.scale.y < 0 ? U + $ : U), R && !("left" in e) && !("center" in e) && !("right" in e) && !("s_right" in e) && !("top" in e) && !("middle" in e) && !("bottom" in e) && !("s_bottom" in e) && pi.setXYByPos(t, "c", o);
  }
  static setXYByPos(t, e, o) {
    if (e === "stay")
      return;
    if (t === void 0)
      throw "setXYByPos base === undefined";
    if (o === void 0)
      throw "setXYByPos result === undefined";
    const R = t.getBounds(), N = o.scale.x < 0 ? -o.scale.x : o.scale.x, M = N === 1 ? R.width : R.width * N, D = o.scale.y < 0 ? -o.scale.y : o.scale.y, L = D === 1 ? R.height : R.height * D;
    let B = 0;
    !e || e === "c" ? B = CmnLib.stageW * 0.5 : e === "r" ? B = CmnLib.stageW - M * 0.5 : e === "l" ? B = M * 0.5 : B = int(e), o.x = int(B - M * 0.5), o.y = CmnLib.stageH - L, o.scale.x < 0 && (o.x += M), o.scale.y < 0 && (o.y += L);
  }
  static setXYCenter(t) {
    const e = t.getBounds();
    t.x = (CmnLib.stageW - e.width) * 0.5, t.y = (CmnLib.stageH - e.height) * 0.5;
  }
};
let Layer = pi;
Ou = new WeakMap(), Nu = new WeakMap(), it(Layer, Ou, {
  normal: BLEND_MODES$5.NORMAL,
  add: BLEND_MODES$5.ADD,
  multiply: BLEND_MODES$5.MULTIPLY,
  screen: BLEND_MODES$5.SCREEN
}), it(Layer, Nu, {
  0: "normal",
  1: "add",
  2: "multiply",
  3: "screen"
});
var mi;
class EventListenerCtn {
  constructor() {
    it(this, mi, []);
  }
  add(t, e, o, R = {}) {
    if (t instanceof BaseTexture) {
      switch (e) {
        case "loaded":
        case "update":
        case "error":
        case "dispose":
          t.on(e, o, R), H(this, mi).push(() => t.off(e, o, R));
          break;
      }
      return;
    }
    if (t instanceof EventEmitter$4) {
      t.on(e, o, R), H(this, mi).push(() => t.off(e, o, R));
      return;
    }
    t.addEventListener(e, o, R), H(this, mi).push(() => {
      var N;
      return t.removeEventListener(e, o, { capture: (N = R.capture) != null ? N : !1 });
    });
  }
  clear() {
    H(this, mi).forEach((t) => t()), et(this, mi, []);
  }
}
mi = new WeakMap();
function prefixNames(n) {
  for (var t = [], e = 1; e < arguments.length; e++)
    t[e - 1] = arguments[e];
  return t.map(function(o) {
    return o.split(" ").map(function(R) {
      return R ? "" + n + R : "";
    }).join(" ");
  }).join(" ");
}
function prefixCSS(n, t) {
  return t.replace(/([^}{]*){/gm, function(e, o) {
    return o.replace(/\.([^{,\s\d.]+)/g, "." + n + "$1") + "{";
  });
}
function ref(n, t) {
  return function(e) {
    e && (n[t] = e);
  };
}
function refs(n, t, e) {
  return function(o) {
    o && (n[t][e] = o);
  };
}
function Properties(n, t) {
  return function(e) {
    var o = e.prototype;
    n.forEach(function(R) {
      t(o, R);
    });
  };
}
function withMethods(n, t) {
  return t === void 0 && (t = {}), function(e, o) {
    n.forEach(function(R) {
      var N = t[R] || R;
      N in e || (e[N] = function() {
        for (var M, D = [], L = 0; L < arguments.length; L++)
          D[L] = arguments[L];
        var B = (M = this[o])[R].apply(M, D);
        return B === this[o] ? this : B;
      });
    });
  };
}
var PolyMap = /* @__PURE__ */ function() {
  function n() {
    this.keys = [], this.values = [];
  }
  var t = n.prototype;
  return t.get = function(e) {
    return this.values[this.keys.indexOf(e)];
  }, t.set = function(e, o) {
    var R = this.keys, N = this.values, M = R.indexOf(e), D = M === -1 ? R.length : M;
    R[D] = e, N[D] = o;
  }, n;
}(), HashMap = /* @__PURE__ */ function() {
  function n() {
    this.object = {};
  }
  var t = n.prototype;
  return t.get = function(e) {
    return this.object[e];
  }, t.set = function(e, o) {
    this.object[e] = o;
  }, n;
}(), SUPPORT_MAP = typeof Map == "function", Link = /* @__PURE__ */ function() {
  function n() {
  }
  var t = n.prototype;
  return t.connect = function(e, o) {
    this.prev = e, this.next = o, e && (e.next = this), o && (o.prev = this);
  }, t.disconnect = function() {
    var e = this.prev, o = this.next;
    e && (e.next = o), o && (o.prev = e);
  }, t.getIndex = function() {
    for (var e = this, o = -1; e; )
      e = e.prev, ++o;
    return o;
  }, n;
}();
function orderChanged(n, t) {
  var e = [], o = [];
  return n.forEach(function(R) {
    var N = R[0], M = R[1], D = new Link();
    e[N] = D, o[M] = D;
  }), e.forEach(function(R, N) {
    R.connect(e[N - 1]);
  }), n.filter(function(R, N) {
    return !t[N];
  }).map(function(R, N) {
    var M = R[0], D = R[1];
    if (M === D)
      return [0, 0];
    var L = e[M], B = o[D - 1], $ = L.getIndex();
    L.disconnect(), B ? L.connect(B, B.next) : L.connect(void 0, e[0]);
    var k = L.getIndex();
    return [$, k];
  });
}
var Result = /* @__PURE__ */ function() {
  function n(e, o, R, N, M, D, L, B) {
    this.prevList = e, this.list = o, this.added = R, this.removed = N, this.changed = M, this.maintained = D, this.changedBeforeAdded = L, this.fixed = B;
  }
  var t = n.prototype;
  return Object.defineProperty(t, "ordered", {
    get: function() {
      return this.cacheOrdered || this.caculateOrdered(), this.cacheOrdered;
    },
    enumerable: !0,
    configurable: !0
  }), Object.defineProperty(t, "pureChanged", {
    get: function() {
      return this.cachePureChanged || this.caculateOrdered(), this.cachePureChanged;
    },
    enumerable: !0,
    configurable: !0
  }), t.caculateOrdered = function() {
    var e = orderChanged(this.changedBeforeAdded, this.fixed), o = this.changed, R = [];
    this.cacheOrdered = e.filter(function(N, M) {
      var D = N[0], L = N[1], B = o[M], $ = B[0], k = B[1];
      if (D !== L)
        return R.push([$, k]), !0;
    }), this.cachePureChanged = R;
  }, n;
}();
function diff$1(n, t, e) {
  var o = SUPPORT_MAP ? Map : e ? HashMap : PolyMap, R = e || function(q) {
    return q;
  }, N = [], M = [], D = [], L = n.map(R), B = t.map(R), $ = new o(), k = new o(), U = [], z = [], X = {}, V = [], W = 0, Y = 0;
  return L.forEach(function(q, Z) {
    $.set(q, Z);
  }), B.forEach(function(q, Z) {
    k.set(q, Z);
  }), L.forEach(function(q, Z) {
    var J = k.get(q);
    typeof J > "u" ? (++Y, M.push(Z)) : X[J] = Y;
  }), B.forEach(function(q, Z) {
    var J = $.get(q);
    typeof J > "u" ? (N.push(Z), ++W) : (D.push([J, Z]), Y = X[Z] || 0, U.push([J - Y, Z - W]), z.push(Z === J), J !== Z && V.push([J, Z]));
  }), M.reverse(), new Result(n, t, N, M, V, D, U, z);
}
var ListDiffer = /* @__PURE__ */ function() {
  function n(e, o) {
    e === void 0 && (e = []), this.findKeyCallback = o, this.list = [].slice.call(e);
  }
  var t = n.prototype;
  return t.update = function(e) {
    var o = [].slice.call(e), R = diff$1(this.list, o, this.findKeyCallback);
    return this.list = o, R;
  }, n;
}(), FUNCTION$1 = "function", OBJECT = "object", STRING$1 = "string", NUMBER = "number", UNDEFINED = "undefined", IS_WINDOW = typeof window !== UNDEFINED, OPEN_CLOSED_CHARACTERS = [{
  open: "(",
  close: ")"
}, {
  open: '"',
  close: '"'
}, {
  open: "'",
  close: "'"
}, {
  open: '\\"',
  close: '\\"'
}, {
  open: "\\'",
  close: "\\'"
}], TINY_NUM$1 = 1e-7, DEFAULT_UNIT_PRESETS = {
  cm: function(n) {
    return n * 96 / 2.54;
  },
  mm: function(n) {
    return n * 96 / 254;
  },
  in: function(n) {
    return n * 96;
  },
  pt: function(n) {
    return n * 96 / 72;
  },
  pc: function(n) {
    return n * 96 / 6;
  },
  "%": function(n, t) {
    return n * t / 100;
  },
  vw: function(n, t) {
    return t === void 0 && (t = window.innerWidth), n / 100 * t;
  },
  vh: function(n, t) {
    return t === void 0 && (t = window.innerHeight), n / 100 * t;
  },
  vmax: function(n, t) {
    return t === void 0 && (t = Math.max(window.innerWidth, window.innerHeight)), n / 100 * t;
  },
  vmin: function(n, t) {
    return t === void 0 && (t = Math.min(window.innerWidth, window.innerHeight)), n / 100 * t;
  }
};
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
function __spreadArrays$4() {
  for (var n = 0, t = 0, e = arguments.length; t < e; t++)
    n += arguments[t].length;
  for (var o = Array(n), R = 0, t = 0; t < e; t++)
    for (var N = arguments[t], M = 0, D = N.length; M < D; M++, R++)
      o[R] = N[M];
  return o;
}
function dot(n, t, e, o) {
  return (n * o + t * e) / (e + o);
}
function isUndefined(n) {
  return typeof n === UNDEFINED;
}
function isObject$2(n) {
  return n && typeof n === OBJECT;
}
function isArray(n) {
  return Array.isArray(n);
}
function isString$1(n) {
  return typeof n === STRING$1;
}
function isNumber(n) {
  return typeof n === NUMBER;
}
function isFunction$3(n) {
  return typeof n === FUNCTION$1;
}
function isEqualSeparator(n, t) {
  var e = n === "" || n == " ", o = t === "" || t == " ";
  return o && e || n === t;
}
function findOpen(n, t, e, o, R) {
  var N = findIgnore(n, t, e);
  return N ? e : findClose(n, t, e + 1, o, R);
}
function findIgnore(n, t, e) {
  if (!n.ignore)
    return null;
  var o = t.slice(Math.max(e - 3, 0), e + 3).join("");
  return new RegExp(n.ignore).exec(o);
}
function findClose(n, t, e, o, R) {
  for (var N = function(B) {
    var $ = t[B].trim();
    if ($ === n.close && !findIgnore(n, t, B))
      return {
        value: B
      };
    var k = B, U = find$1(R, function(z) {
      var X = z.open;
      return X === $;
    });
    if (U && (k = findOpen(U, t, B, o, R)), k === -1)
      return M = B, "break";
    B = k, M = B;
  }, M, D = e; D < o; ++D) {
    var L = N(D);
    if (D = M, typeof L == "object")
      return L.value;
    if (L === "break")
      break;
  }
  return -1;
}
function splitText(n, t) {
  var e = isString$1(t) ? {
    separator: t
  } : t, o = e.separator, R = o === void 0 ? "," : o, N = e.isSeparateFirst, M = e.isSeparateOnlyOpenClose, D = e.isSeparateOpenClose, L = D === void 0 ? M : D, B = e.openCloseCharacters, $ = B === void 0 ? OPEN_CLOSED_CHARACTERS : B, k = $.map(function(rt) {
    var tt = rt.open, nt = rt.close;
    return tt === nt ? tt : tt + "|" + nt;
  }).join("|"), U = "(\\s*" + R + "\\s*|" + k + "|\\s+)", z = new RegExp(U, "g"), X = n.split(z).filter(Boolean), V = X.length, W = [], Y = [];
  function q() {
    return Y.length ? (W.push(Y.join("")), Y = [], !0) : !1;
  }
  for (var Z = function(rt) {
    var tt = X[rt].trim(), nt = rt, at = find$1($, function(dt) {
      var yt = dt.open;
      return yt === tt;
    }), lt = find$1($, function(dt) {
      var yt = dt.close;
      return yt === tt;
    });
    if (at) {
      if (nt = findOpen(at, X, rt, V, $), nt !== -1 && L)
        return q() && N || (W.push(X.slice(rt, nt + 1).join("")), rt = nt, N) ? (J = rt, "break") : (J = rt, "continue");
    } else if (lt && !findIgnore(lt, X, rt)) {
      var ut = __spreadArrays$4($);
      return ut.splice($.indexOf(lt), 1), {
        value: splitText(n, {
          separator: R,
          isSeparateFirst: N,
          isSeparateOnlyOpenClose: M,
          isSeparateOpenClose: L,
          openCloseCharacters: ut
        })
      };
    } else if (isEqualSeparator(tt, R) && !M)
      return q(), N ? (J = rt, "break") : (J = rt, "continue");
    nt === -1 && (nt = V - 1), Y.push(X.slice(rt, nt + 1).join("")), rt = nt, J = rt;
  }, J, Q = 0; Q < V; ++Q) {
    var K = Z(Q);
    if (Q = J, typeof K == "object")
      return K.value;
    if (K === "break")
      break;
  }
  return Y.length && W.push(Y.join("")), W;
}
function splitSpace(n) {
  return splitText(n, "");
}
function splitComma(n) {
  return splitText(n, ",");
}
function splitBracket(n) {
  var t = /([^(]*)\(([\s\S]*)\)([\s\S]*)/g.exec(n);
  return !t || t.length < 4 ? {} : {
    prefix: t[1],
    value: t[2],
    suffix: t[3]
  };
}
function splitUnit(n) {
  var t = /^([^\d|e|\-|\+]*)((?:\d|\.|-|e-|e\+)+)(\S*)$/g.exec(n);
  if (!t)
    return {
      prefix: "",
      unit: "",
      value: NaN
    };
  var e = t[1], o = t[2], R = t[3];
  return {
    prefix: e,
    unit: R,
    value: parseFloat(o)
  };
}
function camelize(n) {
  return n.replace(/[\s-_]([a-z])/g, function(t, e) {
    return e.toUpperCase();
  });
}
function decamelize(n, t) {
  return t === void 0 && (t = "-"), n.replace(/([a-z])([A-Z])/g, function(e, o, R) {
    return "" + o + t + R.toLowerCase();
  });
}
function now$1() {
  return Date.now ? Date.now() : new Date().getTime();
}
function findIndex(n, t, e) {
  e === void 0 && (e = -1);
  for (var o = n.length, R = 0; R < o; ++R)
    if (t(n[R], R, n))
      return R;
  return e;
}
function find$1(n, t, e) {
  var o = findIndex(n, t);
  return o > -1 ? n[o] : e;
}
var requestAnimationFrame$1 = /* @__PURE__ */ function() {
  var n = now$1(), t = IS_WINDOW && (window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.msRequestAnimationFrame);
  return t ? t.bind(window) : function(e) {
    var o = now$1(), R = window.setTimeout(function() {
      e(o - n);
    }, 1e3 / 60);
    return R;
  };
}(), cancelAnimationFrame$1 = /* @__PURE__ */ function() {
  var n = IS_WINDOW && (window.cancelAnimationFrame || window.webkitCancelAnimationFrame || window.mozCancelAnimationFrame || window.msCancelAnimationFrame);
  return n ? n.bind(window) : function(t) {
    clearTimeout(t);
  };
}();
function getKeys(n) {
  return Object.keys(n);
}
function convertUnitSize(n, t) {
  var e = splitUnit(n), o = e.value, R = e.unit;
  if (isObject$2(t)) {
    var N = t[R];
    if (N) {
      if (isFunction$3(N))
        return N(o);
      if (DEFAULT_UNIT_PRESETS[R])
        return DEFAULT_UNIT_PRESETS[R](o, N);
    }
  } else if (R === "%")
    return o * t / 100;
  return DEFAULT_UNIT_PRESETS[R] ? DEFAULT_UNIT_PRESETS[R](o) : o;
}
function between(n, t, e) {
  return Math.max(t, Math.min(n, e));
}
function checkBoundSize(n, t, e, o) {
  return o === void 0 && (o = n[0] / n[1]), [[throttle(t[0], TINY_NUM$1), throttle(t[0] / o, TINY_NUM$1)], [throttle(t[1] * o, TINY_NUM$1), throttle(t[1], TINY_NUM$1)]].filter(function(R) {
    return R.every(function(N, M) {
      var D = t[M], L = throttle(D, TINY_NUM$1);
      return e ? N <= D || N <= L : N >= D || N >= L;
    });
  })[0] || n;
}
function calculateBoundSize(n, t, e, o) {
  if (!o)
    return n.map(function(z, X) {
      return between(z, t[X], e[X]);
    });
  var R = n[0], N = n[1], M = o === !0 ? R / N : o, D = checkBoundSize(n, t, !1, M), L = D[0], B = D[1], $ = checkBoundSize(n, e, !0, M), k = $[0], U = $[1];
  return R < L || N < B ? (R = L, N = B) : (R > k || N > U) && (R = k, N = U), [R, N];
}
function sum(n) {
  for (var t = n.length, e = 0, o = t - 1; o >= 0; --o)
    e += n[o];
  return e;
}
function average(n) {
  for (var t = n.length, e = 0, o = t - 1; o >= 0; --o)
    e += n[o];
  return t ? e / t : 0;
}
function getRad$1(n, t) {
  var e = t[0] - n[0], o = t[1] - n[1], R = Math.atan2(o, e);
  return R >= 0 ? R : R + Math.PI * 2;
}
function getCenterPoint(n) {
  return [0, 1].map(function(t) {
    return average(n.map(function(e) {
      return e[t];
    }));
  });
}
function getShapeDirection(n) {
  var t = getCenterPoint(n), e = getRad$1(t, n[0]), o = getRad$1(t, n[1]);
  return e < o && o - e < Math.PI || e > o && o - e < -Math.PI ? 1 : -1;
}
function getDist$2(n, t) {
  return Math.sqrt(Math.pow((t ? t[0] : 0) - n[0], 2) + Math.pow((t ? t[1] : 0) - n[1], 2));
}
function throttle(n, t) {
  if (!t)
    return n;
  var e = 1 / t;
  return Math.round(n / t) / e;
}
function throttleArray(n, t) {
  return n.forEach(function(e, o) {
    n[o] = throttle(n[o], t);
  }), n;
}
function hasClass(n, t) {
  return n.classList ? n.classList.contains(t) : !!n.className.match(new RegExp("(\\s|^)" + t + "(\\s|$)"));
}
function addClass(n, t) {
  n.classList ? n.classList.add(t) : n.className += " " + t;
}
function removeClass(n, t) {
  if (n.classList)
    n.classList.remove(t);
  else {
    var e = new RegExp("(\\s|^)" + t + "(\\s|$)");
    n.className = n.className.replace(e, " ");
  }
}
function addEvent(n, t, e, o) {
  n.addEventListener(t, e, o);
}
function removeEvent(n, t, e, o) {
  n.removeEventListener(t, e, o);
}
/*! *****************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */
var extendStatics$6 = function(n, t) {
  return extendStatics$6 = Object.setPrototypeOf || {
    __proto__: []
  } instanceof Array && function(e, o) {
    e.__proto__ = o;
  } || function(e, o) {
    for (var R in o)
      o.hasOwnProperty(R) && (e[R] = o[R]);
  }, extendStatics$6(n, t);
};
function __extends$6(n, t) {
  extendStatics$6(n, t);
  function e() {
    this.constructor = n;
  }
  n.prototype = t === null ? Object.create(t) : (e.prototype = t.prototype, new e());
}
var __assign$7 = function() {
  return __assign$7 = Object.assign || function(t) {
    for (var e, o = 1, R = arguments.length; o < R; o++) {
      e = arguments[o];
      for (var N in e)
        Object.prototype.hasOwnProperty.call(e, N) && (t[N] = e[N]);
    }
    return t;
  }, __assign$7.apply(this, arguments);
};
function __rest$2(n, t) {
  var e = {};
  for (var o in n)
    Object.prototype.hasOwnProperty.call(n, o) && t.indexOf(o) < 0 && (e[o] = n[o]);
  if (n != null && typeof Object.getOwnPropertySymbols == "function")
    for (var R = 0, o = Object.getOwnPropertySymbols(n); R < o.length; R++)
      t.indexOf(o[R]) < 0 && Object.prototype.propertyIsEnumerable.call(n, o[R]) && (e[o[R]] = n[o[R]]);
  return e;
}
function __spreadArrays$3() {
  for (var n = 0, t = 0, e = arguments.length; t < e; t++)
    n += arguments[t].length;
  for (var o = Array(n), R = 0, t = 0; t < e; t++)
    for (var N = arguments[t], M = 0, D = N.length; M < D; M++, R++)
      o[R] = N[M];
  return o;
}
function isDiff(n, t) {
  if (n === t)
    return !1;
  for (var e in n)
    if (!(e in t))
      return !0;
  for (var e in t)
    if (n[e] !== t[e])
      return !0;
  return !1;
}
function diffObject(n, t) {
  var e = Object.keys(n), o = Object.keys(t), R = diff$1(e, o, function(L) {
    return L;
  }), N = {}, M = {}, D = {};
  return R.added.forEach(function(L) {
    var B = o[L];
    N[B] = t[B];
  }), R.removed.forEach(function(L) {
    var B = e[L];
    M[B] = n[B];
  }), R.maintained.forEach(function(L) {
    var B = L[0], $ = e[B], k = [n[$], t[$]];
    n[$] !== t[$] && (D[$] = k);
  }), {
    added: N,
    removed: M,
    changed: D
  };
}
function executeHooks(n) {
  n.forEach(function(t) {
    t();
  });
}
function fillKeys(n) {
  var t = 0;
  return n.map(function(e) {
    return e == null ? "$compat" + ++t : "" + e;
  });
}
function createProvider(n, t, e, o) {
  if (isString$1(n) || isNumber(n))
    return new TextProvider("text_" + n, t, e, o, null, {});
  var R = typeof n.type == "string" ? ElementProvider : n.type.prototype.render ? ComponentProvider : FunctionProvider;
  return new R(n.type, t, e, o, n.ref, n.props);
}
function flat$1(n) {
  var t = [];
  return n.forEach(function(e) {
    t = t.concat(isArray(e) ? flat$1(e) : e);
  }), t;
}
function getAttributes(n) {
  var t = n.className, e = __rest$2(n, ["className"]);
  return t != null && (e.class = t), delete e.style, delete e.children, e;
}
function fillProps(n, t) {
  if (!t)
    return n;
  for (var e in t)
    isUndefined(n[e]) && (n[e] = t[e]);
  return n;
}
function createElement(n, t) {
  for (var e = [], o = 2; o < arguments.length; o++)
    e[o - 2] = arguments[o];
  var R = t || {}, N = R.key, M = R.ref, D = __rest$2(R, ["key", "ref"]);
  return {
    type: n,
    key: N,
    ref: M,
    props: __assign$7(__assign$7({}, D), {
      children: flat$1(e).filter(function(L) {
        return L != null && L !== !1;
      })
    })
  };
}
var Provider = /* @__PURE__ */ function() {
  function n(e, o, R, N, M, D) {
    D === void 0 && (D = {}), this.type = e, this.key = o, this.index = R, this.container = N, this.ref = M, this.props = D, this._providers = [];
  }
  var t = n.prototype;
  return t._should = function(e, o) {
    return !0;
  }, t._update = function(e, o, R, N) {
    if (this.base && !isString$1(o) && !N && !this._should(o.props, R))
      return !1;
    this.original = o, this._setState(R);
    var M = this.props;
    return isString$1(o) || (this.props = o.props, this.ref = o.ref), this._render(e, this.base ? M : {}, R), !0;
  }, t._mounted = function() {
    var e = this.ref;
    e && e(this.base);
  }, t._setState = function(e) {
  }, t._updated = function() {
    var e = this.ref;
    e && e(this.base);
  }, t._destroy = function() {
    var e = this.ref;
    e && e(null);
  }, n;
}();
function diffAttributes(n, t, e) {
  var o = diffObject(n, t), R = o.added, N = o.removed, M = o.changed;
  for (var D in R)
    e.setAttribute(D, R[D]);
  for (var D in M)
    e.setAttribute(D, M[D][1]);
  for (var D in N)
    e.removeAttribute(D);
}
function diffEvents(n, t, e) {
  var o = diffObject(n, t), R = o.added, N = o.removed, M = o.changed;
  for (var D in N)
    e.removeEventListener(D);
  for (var D in R)
    e.addEventListener(D, R[D]);
  for (var D in M)
    e.removeEventListener(D), e.addEventListener(D, M[D][1]);
  for (var D in N)
    e.removeEventListener(D);
}
function diffStyle(n, t, e) {
  var o = e.style, R = diffObject(n, t), N = R.added, M = R.removed, D = R.changed;
  for (var L in N) {
    var B = decamelize(L, "-");
    o.setProperty ? o.setProperty(B, N[L]) : o[B] = N[L];
  }
  for (var L in D) {
    var B = decamelize(L, "-");
    o.setProperty ? o.setProperty(B, D[L][1]) : o[B] = D[L][1];
  }
  for (var L in M) {
    var B = decamelize(L, "-");
    o.removeProperty ? o.removeProperty(B) : o[B] = "";
  }
}
function splitProps(n) {
  var t = {}, e = {};
  for (var o in n)
    o.indexOf("on") === 0 ? e[o.replace("on", "").toLowerCase()] = n[o] : t[o] = n[o];
  return {
    attributes: t,
    events: e
  };
}
var TextProvider = /* @__PURE__ */ function(n) {
  __extends$6(t, n);
  function t() {
    return n !== null && n.apply(this, arguments) || this;
  }
  var e = t.prototype;
  return e._render = function(o) {
    var R = this, N = !this.base;
    return N && (this.base = document.createTextNode(this.type.replace("text_", ""))), o.push(function() {
      N ? R._mounted() : R._updated();
    }), !0;
  }, e._unmount = function() {
    this.base.parentNode.removeChild(this.base);
  }, t;
}(Provider), ElementProvider = /* @__PURE__ */ function(n) {
  __extends$6(t, n);
  function t() {
    var o = n !== null && n.apply(this, arguments) || this;
    return o.events = {}, o._isSVG = !1, o;
  }
  var e = t.prototype;
  return e.addEventListener = function(o, R) {
    var N = this.events;
    N[o] = function(M) {
      M.nativeEvent = M, R(M);
    }, this.base.addEventListener(o, N[o]);
  }, e.removeEventListener = function(o) {
    var R = this.events;
    this.base.removeEventListener(o, R[o]), delete R[o];
  }, e._should = function(o) {
    return isDiff(this.props, o);
  }, e._render = function(o, R) {
    var N = this, M = !this.base;
    if (M) {
      var D = this._hasSVG();
      this._isSVG = D;
      var L = this.props.portalContainer;
      if (!L) {
        var B = this.type;
        D ? L = document.createElementNS("http://www.w3.org/2000/svg", B) : L = document.createElement(B);
      }
      this.base = L;
    }
    renderProviders(this, this._providers, this.props.children, o, null);
    var $ = this.base, k = splitProps(R), U = k.attributes, z = k.events, X = splitProps(this.props), V = X.attributes, W = X.events;
    return diffAttributes(getAttributes(U), getAttributes(V), $), diffEvents(z, W, this), diffStyle(R.style || {}, this.props.style || {}, $), o.push(function() {
      M ? N._mounted() : N._updated();
    }), !0;
  }, e._unmount = function() {
    var o = this.events, R = this.base;
    for (var N in o)
      R.removeEventListener(N, o[N]);
    this._providers.forEach(function(M) {
      M._unmount();
    }), this.events = {}, this.props.portalContainer || R.parentNode.removeChild(R);
  }, e._hasSVG = function() {
    if (this._isSVG || this.type === "svg")
      return !0;
    var o = findContainerNode(this.container);
    return o && "ownerSVGElement" in o;
  }, t;
}(Provider);
function findContainerNode(n) {
  if (!n)
    return null;
  var t = n.base;
  return t instanceof Node ? t : findContainerNode(n.container);
}
function findDOMNode(n) {
  if (!n)
    return null;
  if (n instanceof Node)
    return n;
  var t = n.$_provider._providers;
  return t.length ? findDOMNode(t[0].base) : null;
}
var FunctionProvider = /* @__PURE__ */ function(n) {
  __extends$6(t, n);
  function t() {
    return n !== null && n.apply(this, arguments) || this;
  }
  var e = t.prototype;
  return e._render = function(o) {
    var R = this.type(this.props);
    return renderProviders(this, this._providers, R ? [R] : [], o), !0;
  }, e._unmount = function() {
    this._providers.forEach(function(o) {
      o._unmount();
    });
  }, t;
}(Provider), ContainerProvider = /* @__PURE__ */ function(n) {
  __extends$6(t, n);
  function t(o) {
    var R = n.call(this, "container", "container", 0, null) || this;
    return R.base = o, R;
  }
  var e = t.prototype;
  return e._render = function() {
    return !0;
  }, e._unmount = function() {
  }, t;
}(Provider), ComponentProvider = /* @__PURE__ */ function(n) {
  __extends$6(t, n);
  function t(o, R, N, M, D, L) {
    return L === void 0 && (L = {}), n.call(this, o, R, N, M, D, fillProps(L, o.defaultProps)) || this;
  }
  var e = t.prototype;
  return e._should = function(o, R) {
    return this.base.shouldComponentUpdate(fillProps(o, this.type.defaultProps), R || this.base.state);
  }, e._render = function(o, R) {
    var N = this;
    this.props = fillProps(this.props, this.type.defaultProps);
    var M = !this.base;
    M ? (this.base = new this.type(this.props), this.base.$_provider = this) : this.base.props = this.props;
    var D = this.base, L = D.state, B = D.render();
    B && B.props && !B.props.children.length && (B.props.children = this.props.children), renderProviders(this, this._providers, B ? [B] : [], o), o.push(function() {
      M ? (N._mounted(), D.componentDidMount()) : (N._updated(), D.componentDidUpdate(R, L));
    });
  }, e._setState = function(o) {
    var R = this.base;
    !R || !o || (R.state = o);
  }, e._unmount = function() {
    this._providers.forEach(function(o) {
      o._unmount();
    }), clearTimeout(this.base.$_timer), this.base.componentWillUnmount();
  }, t;
}(Provider), Component = /* @__PURE__ */ function() {
  function n(e) {
    e === void 0 && (e = {}), this.props = e, this.state = {}, this.$_timer = 0, this.$_state = {};
  }
  var t = n.prototype;
  return t.shouldComponentUpdate = function(e, o) {
    return !0;
  }, t.render = function() {
    return null;
  }, t.setState = function(e, o, R) {
    var N = this;
    this.$_timer || (this.$_state = {}), clearTimeout(this.$_timer), this.$_timer = 0, this.$_state = __assign$7(__assign$7({}, this.$_state), e), R ? this.$_setState(o, R) : this.$_timer = setTimeout(function() {
      N.$_timer = 0, N.$_setState(o, R);
    });
  }, t.forceUpdate = function(e) {
    this.setState({}, e, !0);
  }, t.componentDidMount = function() {
  }, t.componentDidUpdate = function(e, o) {
  }, t.componentWillUnmount = function() {
  }, t.$_setState = function(e, o) {
    var R = [], N = this.$_provider, M = renderProviders(N.container, [N], [N.original], R, __assign$7(__assign$7({}, this.state), this.$_state), o);
    M && (e && R.push(e), executeHooks(R));
  }, n;
}(), PureComponent = /* @__PURE__ */ function(n) {
  __extends$6(t, n);
  function t() {
    return n !== null && n.apply(this, arguments) || this;
  }
  var e = t.prototype;
  return e.shouldComponentUpdate = function(o, R) {
    return isDiff(this.props, o) || isDiff(this.state, R);
  }, t;
}(Component), _Portal = /* @__PURE__ */ function(n) {
  __extends$6(t, n);
  function t() {
    return n !== null && n.apply(this, arguments) || this;
  }
  var e = t.prototype;
  return e.componentDidMount = function() {
    var o = this.props, R = o.element, N = o.container;
    this._portalProvider = new ContainerProvider(N), renderProvider(R, N, this._portalProvider);
  }, e.componentDidUpdate = function() {
    var o = this.props, R = o.element, N = o.container;
    renderProvider(R, N, this._portalProvider);
  }, e.componentWillUnmount = function() {
    var o = this.props.container;
    renderProvider(null, o, this._portalProvider), this._portalProvider = null;
  }, t;
}(PureComponent);
function updateProvider(n, t, e) {
  var o = [];
  renderProviders(n, n._providers, t, o, e), executeHooks(o);
}
function getNextSibiling(n, t) {
  for (var e = n._providers, o = e.length, R = t.index + 1; R < o; ++R) {
    var N = findDOMNode(e[R].base);
    if (N)
      return N;
  }
  return null;
}
function diffProviders(n, t, e) {
  var o = e.map(function(L) {
    return isString$1(L) ? null : L.key;
  }), R = fillKeys(t.map(function(L) {
    return L.key;
  })), N = fillKeys(o), M = diff$1(R, N, function(L) {
    return L;
  });
  M.removed.forEach(function(L) {
    t.splice(L, 1)[0]._unmount();
  }), M.ordered.forEach(function(L) {
    var B = L[0], $ = L[1], k = t.splice(B, 1)[0];
    t.splice($, 0, k);
    var U = findDOMNode(k.base), z = findDOMNode(t[$ + 1] && t[$ + 1].base);
    U && U.parentNode.insertBefore(U, z);
  }), M.added.forEach(function(L) {
    t.splice(L, 0, createProvider(e[L], o[L], L, n));
  });
  var D = M.maintained.filter(function(L) {
    L[0];
    var B = L[1], $ = e[B], k = t[B], U = isString$1($) ? "text_" + $ : $.type;
    return U !== k.type ? (k._unmount(), t.splice(B, 1, createProvider($, o[B], B, n)), !0) : (k.index = B, !1);
  });
  return __spreadArrays$3(M.added, D.map(function(L) {
    L[0];
    var B = L[1];
    return B;
  }));
}
function renderProviders(n, t, e, o, R, N) {
  var M = diffProviders(n, t, e), D = t.filter(function(B, $) {
    return B._update(o, e[$], R, N);
  }), L = findContainerNode(n);
  return L && M.reverse().forEach(function(B) {
    var $ = t[B], k = findDOMNode($.base);
    if (!!k && L !== k && !k.parentNode) {
      var U = getNextSibiling(n, $);
      L.insertBefore(k, U);
    }
  }), D.length > 0;
}
function renderProvider(n, t, e) {
  e === void 0 && (e = t.__REACT_COMPAT__);
  var o = !!e;
  return e || (e = new ContainerProvider(t)), updateProvider(e, n ? [n] : []), o || (t.__REACT_COMPAT__ = e), e;
}
function render(n, t, e) {
  var o = t.__REACT_COMPAT__;
  n && !o && (t.innerHTML = ""), renderProvider(n, t, o), e && e();
}
function createPortal(n, t) {
  return createElement(_Portal, {
    element: n,
    container: t
  });
}
var version = "simple-1.1.0";
function some(n, t) {
  for (var e = n.length, o = 0; o < e; ++o)
    if (t(n[o], o))
      return !0;
  return !1;
}
function find(n, t) {
  for (var e = n.length, o = 0; o < e; ++o)
    if (t(n[o], o))
      return n[o];
  return null;
}
function getUserAgentString(n) {
  var t = n;
  if (typeof t > "u") {
    if (typeof navigator > "u" || !navigator)
      return "";
    t = navigator.userAgent || "";
  }
  return t.toLowerCase();
}
function execRegExp(n, t) {
  try {
    return new RegExp(n, "g").exec(t);
  } catch {
    return null;
  }
}
function hasUserAgentData() {
  if (typeof navigator > "u" || !navigator || !navigator.userAgentData)
    return !1;
  var n = navigator.userAgentData, t = n.brands || n.uaList;
  return !!(t && t.length);
}
function findVersion(n, t) {
  var e = execRegExp("(" + n + ")((?:\\/|\\s|:)([0-9|\\.|_]+))", t);
  return e ? e[3] : "";
}
function convertVersion(n) {
  return n.replace(/_/g, ".");
}
function findPreset(n, t) {
  var e = null, o = "-1";
  return some(n, function(R) {
    var N = execRegExp("(" + R.test + ")((?:\\/|\\s|:)([0-9|\\.|_]+))?", t);
    return !N || R.brand ? !1 : (e = R, o = N[3] || "-1", R.versionAlias ? o = R.versionAlias : R.versionTest && (o = findVersion(R.versionTest.toLowerCase(), t) || o), o = convertVersion(o), !0);
  }), {
    preset: e,
    version: o
  };
}
function findPresetBrand(n, t) {
  var e = {
    brand: "",
    version: "-1"
  };
  return some(n, function(o) {
    var R = findBrand(t, o);
    return R ? (e.brand = o.id, e.version = o.versionAlias || R.version, e.version !== "-1") : !1;
  }), e;
}
function findBrand(n, t) {
  return find(n, function(e) {
    var o = e.brand;
    return execRegExp("" + t.test, o.toLowerCase());
  });
}
var BROWSER_PRESETS = [{
  test: "phantomjs",
  id: "phantomjs"
}, {
  test: "whale",
  id: "whale"
}, {
  test: "edgios|edge|edg",
  id: "edge"
}, {
  test: "msie|trident|windows phone",
  id: "ie",
  versionTest: "iemobile|msie|rv"
}, {
  test: "miuibrowser",
  id: "miui browser"
}, {
  test: "samsungbrowser",
  id: "samsung internet"
}, {
  test: "samsung",
  id: "samsung internet",
  versionTest: "version"
}, {
  test: "chrome|crios",
  id: "chrome"
}, {
  test: "firefox|fxios",
  id: "firefox"
}, {
  test: "android",
  id: "android browser",
  versionTest: "version"
}, {
  test: "safari|iphone|ipad|ipod",
  id: "safari",
  versionTest: "version"
}], CHROMIUM_PRESETS = [{
  test: "(?=.*applewebkit/(53[0-7]|5[0-2]|[0-4]))(?=.*\\schrome)",
  id: "chrome",
  versionTest: "chrome"
}, {
  test: "chromium",
  id: "chrome"
}, {
  test: "whale",
  id: "chrome",
  versionAlias: "-1",
  brand: !0
}], WEBKIT_PRESETS = [{
  test: "applewebkit",
  id: "webkit",
  versionTest: "applewebkit|safari"
}], WEBVIEW_PRESETS = [{
  test: "(?=(iphone|ipad))(?!(.*version))",
  id: "webview"
}, {
  test: "(?=(android|iphone|ipad))(?=.*(naver|daum|; wv))",
  id: "webview"
}, {
  test: "webview",
  id: "webview"
}], OS_PRESETS = [{
  test: "windows phone",
  id: "windows phone"
}, {
  test: "windows 2000",
  id: "window",
  versionAlias: "5.0"
}, {
  test: "windows nt",
  id: "window"
}, {
  test: "win32|windows",
  id: "window"
}, {
  test: "iphone|ipad|ipod",
  id: "ios",
  versionTest: "iphone os|cpu os"
}, {
  test: "macos|macintel|mac os x",
  id: "mac"
}, {
  test: "android|linux armv81",
  id: "android"
}, {
  test: "tizen",
  id: "tizen"
}, {
  test: "webos|web0s",
  id: "webos"
}];
function isWebView(n) {
  return !!findPreset(WEBVIEW_PRESETS, n).preset;
}
function getLegacyAgent(n) {
  var t = getUserAgentString(n), e = !!/mobi/g.exec(t), o = {
    name: "unknown",
    version: "-1",
    majorVersion: -1,
    webview: isWebView(t),
    chromium: !1,
    chromiumVersion: "-1",
    webkit: !1,
    webkitVersion: "-1"
  }, R = {
    name: "unknown",
    version: "-1",
    majorVersion: -1
  }, N = findPreset(BROWSER_PRESETS, t), M = N.preset, D = N.version, L = findPreset(OS_PRESETS, t), B = L.preset, $ = L.version, k = findPreset(CHROMIUM_PRESETS, t);
  if (o.chromium = !!k.preset, o.chromiumVersion = k.version, !o.chromium) {
    var U = findPreset(WEBKIT_PRESETS, t);
    o.webkit = !!U.preset, o.webkitVersion = U.version;
  }
  return B && (R.name = B.id, R.version = $, R.majorVersion = parseInt($, 10)), M && (o.name = M.id, o.version = D, o.webview && R.name === "ios" && o.name !== "safari" && (o.webview = !1)), o.majorVersion = parseInt(o.version, 10), {
    browser: o,
    os: R,
    isMobile: e,
    isHints: !1
  };
}
function getClientHintsAgent(n) {
  var t = navigator.userAgentData, e = (t.uaList || t.brands).slice(), o = n && n.fullVersionList, R = t.mobile || !1, N = e[0], M = (n && n.platform || t.platform || navigator.platform).toLowerCase(), D = {
    name: N.brand,
    version: N.version,
    majorVersion: -1,
    webkit: !1,
    webkitVersion: "-1",
    chromium: !1,
    chromiumVersion: "-1",
    webview: !!findPresetBrand(WEBVIEW_PRESETS, e).brand || isWebView(getUserAgentString())
  }, L = {
    name: "unknown",
    version: "-1",
    majorVersion: -1
  };
  D.webkit = !D.chromium && some(WEBKIT_PRESETS, function(X) {
    return findBrand(e, X);
  });
  var B = findPresetBrand(CHROMIUM_PRESETS, e);
  if (D.chromium = !!B.brand, D.chromiumVersion = B.version, !D.chromium) {
    var $ = findPresetBrand(WEBKIT_PRESETS, e);
    D.webkit = !!$.brand, D.webkitVersion = $.version;
  }
  var k = find(OS_PRESETS, function(X) {
    return new RegExp("" + X.test, "g").exec(M);
  });
  if (L.name = k ? k.id : "", n && (L.version = n.platformVersion), o && o.length) {
    var U = findPresetBrand(BROWSER_PRESETS, o);
    D.name = U.brand || D.name, D.version = U.version || D.version;
  } else {
    var z = findPresetBrand(BROWSER_PRESETS, e);
    D.name = z.brand || D.name, D.version = z.brand && n ? n.uaFullVersion : z.version;
  }
  return D.webkit && (L.name = R ? "ios" : "mac"), L.name === "ios" && D.webview && (D.version = "-1"), L.version = convertVersion(L.version), D.version = convertVersion(D.version), L.majorVersion = parseInt(L.version, 10), D.majorVersion = parseInt(D.version, 10), {
    browser: D,
    os: L,
    isMobile: R,
    isHints: !0
  };
}
function agent$1(n) {
  return typeof n > "u" && hasUserAgentData() ? getClientHintsAgent() : getLegacyAgent(n);
}
function add(n, t, e, o, R, N) {
  for (var M = 0; M < R; ++M) {
    var D = e + M * R, L = o + M * R;
    n[D] += n[L] * N, t[D] += t[L] * N;
  }
}
function swap(n, t, e, o, R) {
  for (var N = 0; N < R; ++N) {
    var M = e + N * R, D = o + N * R, L = n[M], B = t[M];
    n[M] = n[D], n[D] = L, t[M] = t[D], t[D] = B;
  }
}
function divide(n, t, e, o, R) {
  for (var N = 0; N < o; ++N) {
    var M = e + N * o;
    n[M] /= R, t[M] /= R;
  }
}
function ignoreDimension(n, t, e) {
  e === void 0 && (e = Math.sqrt(n.length));
  for (var o = n.slice(), R = 0; R < e; ++R)
    o[R * e + t - 1] = 0, o[(t - 1) * e + R] = 0;
  return o[(t - 1) * (e + 1)] = 1, o;
}
function invert(n, t) {
  t === void 0 && (t = Math.sqrt(n.length));
  for (var e = n.slice(), o = createIdentityMatrix(t), R = 0; R < t; ++R) {
    var N = t * R + R;
    if (!throttle(e[N], TINY_NUM$1)) {
      for (var M = R + 1; M < t; ++M)
        if (e[t * R + M]) {
          swap(e, o, R, M, t);
          break;
        }
    }
    if (!throttle(e[N], TINY_NUM$1))
      return [];
    divide(e, o, R, t, e[N]);
    for (var M = 0; M < t; ++M) {
      var D = M, L = M + R * t, B = e[L];
      !throttle(B, TINY_NUM$1) || R === M || add(e, o, D, R, t, -B);
    }
  }
  return o;
}
function transpose(n, t) {
  t === void 0 && (t = Math.sqrt(n.length));
  for (var e = [], o = 0; o < t; ++o)
    for (var R = 0; R < t; ++R)
      e[R * t + o] = n[t * o + R];
  return e;
}
function getOrigin(n, t) {
  t === void 0 && (t = Math.sqrt(n.length));
  for (var e = [], o = n[t * t - 1], R = 0; R < t - 1; ++R)
    e[R] = n[t * (t - 1) + R] / o;
  return e[t - 1] = 0, e;
}
function fromTranslation(n, t) {
  for (var e = createIdentityMatrix(t), o = 0; o < t - 1; ++o)
    e[t * (t - 1) + o] = n[o] || 0;
  return e;
}
function convertPositionMatrix(n, t) {
  for (var e = n.slice(), o = n.length; o < t - 1; ++o)
    e[o] = 0;
  return e[t - 1] = 1, e;
}
function convertDimension(n, t, e) {
  if (t === void 0 && (t = Math.sqrt(n.length)), t === e)
    return n;
  for (var o = createIdentityMatrix(e), R = Math.min(t, e), N = 0; N < R - 1; ++N) {
    for (var M = 0; M < R - 1; ++M)
      o[N * e + M] = n[N * t + M];
    o[(N + 1) * e - 1] = n[(N + 1) * t - 1], o[(e - 1) * e + N] = n[(t - 1) * t + N];
  }
  return o[e * e - 1] = n[t * t - 1], o;
}
function multiplies(n) {
  for (var t = [], e = 1; e < arguments.length; e++)
    t[e - 1] = arguments[e];
  var o = createIdentityMatrix(n);
  return t.forEach(function(R) {
    o = multiply(o, R, n);
  }), o;
}
function multiply(n, t, e) {
  e === void 0 && (e = Math.sqrt(n.length));
  var o = [], R = n.length / e, N = t.length / R;
  if (R) {
    if (!N)
      return n;
  } else
    return t;
  for (var M = 0; M < e; ++M)
    for (var D = 0; D < N; ++D) {
      o[D * e + M] = 0;
      for (var L = 0; L < R; ++L)
        o[D * e + M] += n[L * e + M] * t[D * R + L];
    }
  return o;
}
function plus(n, t) {
  for (var e = Math.min(n.length, t.length), o = n.slice(), R = 0; R < e; ++R)
    o[R] = o[R] + t[R];
  return o;
}
function minus(n, t) {
  for (var e = Math.min(n.length, t.length), o = n.slice(), R = 0; R < e; ++R)
    o[R] = o[R] - t[R];
  return o;
}
function convertCSStoMatrix(n, t) {
  return t === void 0 && (t = n.length === 6), t ? [n[0], n[1], 0, n[2], n[3], 0, n[4], n[5], 1] : n;
}
function convertMatrixtoCSS(n, t) {
  return t === void 0 && (t = n.length === 9), t ? [n[0], n[1], n[3], n[4], n[6], n[7]] : n;
}
function calculate(n, t, e) {
  e === void 0 && (e = t.length);
  var o = multiply(n, t, e), R = o[e - 1];
  return o.map(function(N) {
    return N / R;
  });
}
function rotateX3d(n, t) {
  return multiply(n, [1, 0, 0, 0, 0, Math.cos(t), Math.sin(t), 0, 0, -Math.sin(t), Math.cos(t), 0, 0, 0, 0, 1], 4);
}
function rotateY3d(n, t) {
  return multiply(n, [Math.cos(t), 0, -Math.sin(t), 0, 0, 1, 0, 0, Math.sin(t), 0, Math.cos(t), 0, 0, 0, 0, 1], 4);
}
function rotateZ3d(n, t) {
  return multiply(n, createRotateMatrix(t, 4));
}
function scale3d(n, t) {
  var e = t[0], o = e === void 0 ? 1 : e, R = t[1], N = R === void 0 ? 1 : R, M = t[2], D = M === void 0 ? 1 : M;
  return multiply(n, [o, 0, 0, 0, 0, N, 0, 0, 0, 0, D, 0, 0, 0, 0, 1], 4);
}
function rotate(n, t) {
  return calculate(createRotateMatrix(t, 3), convertPositionMatrix(n, 3));
}
function translate3d(n, t) {
  var e = t[0], o = e === void 0 ? 0 : e, R = t[1], N = R === void 0 ? 0 : R, M = t[2], D = M === void 0 ? 0 : M;
  return multiply(n, [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, o, N, D, 1], 4);
}
function matrix3d(n, t) {
  return multiply(n, t, 4);
}
function createRotateMatrix(n, t) {
  var e = Math.cos(n), o = Math.sin(n), R = createIdentityMatrix(t);
  return R[0] = e, R[1] = o, R[t] = -o, R[t + 1] = e, R;
}
function createIdentityMatrix(n) {
  for (var t = n * n, e = [], o = 0; o < t; ++o)
    e[o] = o % (n + 1) ? 0 : 1;
  return e;
}
function createScaleMatrix(n, t) {
  for (var e = createIdentityMatrix(t), o = Math.min(n.length, t - 1), R = 0; R < o; ++R)
    e[(t + 1) * R] = n[R];
  return e;
}
function createOriginMatrix(n, t) {
  for (var e = createIdentityMatrix(t), o = Math.min(n.length, t - 1), R = 0; R < o; ++R)
    e[t * (t - 1) + R] = n[R];
  return e;
}
function createWarpMatrix(n, t, e, o, R, N, M, D) {
  var L = n[0], B = n[1], $ = t[0], k = t[1], U = e[0], z = e[1], X = o[0], V = o[1], W = R[0], Y = R[1], q = N[0], Z = N[1], J = M[0], Q = M[1], K = D[0], rt = D[1], tt = [L, 0, $, 0, U, 0, X, 0, B, 0, k, 0, z, 0, V, 0, 1, 0, 1, 0, 1, 0, 1, 0, 0, L, 0, $, 0, U, 0, X, 0, B, 0, k, 0, z, 0, V, 0, 1, 0, 1, 0, 1, 0, 1, -W * L, -Y * L, -q * $, -Z * $, -J * U, -Q * U, -K * X, -rt * X, -W * B, -Y * B, -q * k, -Z * k, -J * z, -Q * z, -K * V, -rt * V], nt = invert(tt, 8);
  if (!nt.length)
    return [];
  var at = multiply(nt, [W, Y, q, Z, J, Q, K, rt], 8);
  return at[8] = 1, convertDimension(transpose(at), 3, 4);
}
function createMatrix() {
  return [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
}
function parseMat(n) {
  return toMat(parse(n));
}
function calculateMatrixDist(n, t) {
  var e = calculate(n, [t[0], t[1] || 0, t[2] || 0, 1], 4), o = e[3] || 1;
  return [e[0] / o, e[1] / o, e[2] / o];
}
function toMat(n) {
  var t = createMatrix();
  return n.forEach(function(e) {
    var o = e.matrixFunction, R = e.functionValue;
    !o || (t = o(t, R));
  }), t;
}
function parse(n) {
  var t = isArray(n) ? n : splitSpace(n);
  return t.map(function(e) {
    var o = splitBracket(e), R = o.prefix, N = o.value, M = null, D = R, L = "";
    if (R === "translate" || R === "translateX" || R === "translate3d") {
      var B = splitComma(N).map(function(at) {
        return parseFloat(at);
      }), $ = B[0], k = B[1], U = k === void 0 ? 0 : k, z = B[2], X = z === void 0 ? 0 : z;
      M = translate3d, L = [$, U, X];
    } else if (R === "translateY") {
      var U = parseFloat(N);
      M = translate3d, L = [0, U, 0];
    } else if (R === "translateZ") {
      var X = parseFloat(N);
      M = translate3d, L = [0, 0, X];
    } else if (R === "scale" || R === "scale3d") {
      var V = splitComma(N).map(function(at) {
        return parseFloat(at);
      }), W = V[0], Y = V[1], q = Y === void 0 ? W : Y, Z = V[2], J = Z === void 0 ? 1 : Z;
      M = scale3d, L = [W, q, J];
    } else if (R === "scaleX") {
      var W = parseFloat(N);
      M = scale3d, L = [W, 1, 1];
    } else if (R === "scaleY") {
      var q = parseFloat(N);
      M = scale3d, L = [1, q, 1];
    } else if (R === "scaleZ") {
      var J = parseFloat(N);
      M = scale3d, L = [1, 1, J];
    } else if (R === "rotate" || R === "rotateZ" || R === "rotateX" || R === "rotateY") {
      var Q = splitUnit(N), K = Q.unit, rt = Q.value, tt = K === "rad" ? rt : rt * Math.PI / 180;
      R === "rotate" || R === "rotateZ" ? (D = "rotateZ", M = rotateZ3d) : R === "rotateX" ? M = rotateX3d : R === "rotateY" && (M = rotateY3d), L = tt;
    } else if (R === "matrix3d")
      M = matrix3d, L = splitComma(N).map(function(at) {
        return parseFloat(at);
      });
    else if (R === "matrix") {
      var nt = splitComma(N).map(function(at) {
        return parseFloat(at);
      });
      M = matrix3d, L = [nt[0], nt[1], 0, 0, nt[2], nt[3], 0, 0, 0, 0, 1, 0, nt[4], nt[5], 0, 1];
    } else
      D = "";
    return {
      name: R,
      functionName: D,
      value: N,
      matrixFunction: M,
      functionValue: L
    };
  });
}
/*! *****************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */
var extendStatics$5 = function(n, t) {
  return extendStatics$5 = Object.setPrototypeOf || {
    __proto__: []
  } instanceof Array && function(e, o) {
    e.__proto__ = o;
  } || function(e, o) {
    for (var R in o)
      o.hasOwnProperty(R) && (e[R] = o[R]);
  }, extendStatics$5(n, t);
};
function __extends$5(n, t) {
  extendStatics$5(n, t);
  function e() {
    this.constructor = n;
  }
  n.prototype = t === null ? Object.create(t) : (e.prototype = t.prototype, new e());
}
var findKeyCallback = typeof Map == "function" ? void 0 : function() {
  var n = 0;
  return function(t) {
    return t.__DIFF_KEY__ || (t.__DIFF_KEY__ = ++n);
  };
}(), ChildrenDiffer = /* @__PURE__ */ function(n) {
  __extends$5(t, n);
  function t(e) {
    return e === void 0 && (e = []), n.call(this, e, findKeyCallback) || this;
  }
  return t;
}(ListDiffer);
function diff(n, t) {
  return diff$1(n, t, findKeyCallback);
}
const ChildrenDiffer$1 = ChildrenDiffer;
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
function __spreadArrays$2() {
  for (var n = 0, t = 0, e = arguments.length; t < e; t++)
    n += arguments[t].length;
  for (var o = Array(n), R = 0, t = 0; t < e; t++)
    for (var N = arguments[t], M = 0, D = N.length; M < D; M++, R++)
      o[R] = N[M];
  return o;
}
function tinyThrottle(n) {
  return throttle(n, TINY_NUM$1);
}
function isSameConstants(n, t) {
  return n.every(function(e, o) {
    return tinyThrottle(e - t[o]) === 0;
  });
}
function isSamePoint(n, t) {
  return !tinyThrottle(n[0] - t[0]) && !tinyThrottle(n[1] - t[1]);
}
function getAreaSize(n) {
  return n.length < 3 ? 0 : Math.abs(sum(n.map(function(t, e) {
    var o = n[e + 1] || n[0];
    return t[0] * o[1] - o[0] * t[1];
  }))) / 2;
}
function fitPoints(n, t) {
  var e = t.width, o = t.height, R = t.left, N = t.top, M = getMinMaxs(n), D = M.minX, L = M.minY, B = M.maxX, $ = M.maxY, k = e / (B - D), U = o / ($ - L);
  return n.map(function(z) {
    return [R + (z[0] - D) * k, N + (z[1] - L) * U];
  });
}
function getMinMaxs(n) {
  var t = n.map(function(o) {
    return o[0];
  }), e = n.map(function(o) {
    return o[1];
  });
  return {
    minX: Math.min.apply(Math, t),
    minY: Math.min.apply(Math, e),
    maxX: Math.max.apply(Math, t),
    maxY: Math.max.apply(Math, e)
  };
}
function isInside(n, t, e) {
  var o = n[0], R = n[1], N = getMinMaxs(t), M = N.minX, D = N.maxX, L = [[M, R], [D, R]], B = getLinearConstants(L[0], L[1]), $ = convertLines(t), k = [];
  if ($.forEach(function(X) {
    var V = getLinearConstants(X[0], X[1]), W = X[0];
    if (isSameConstants(B, V))
      k.push({
        pos: n,
        line: X,
        type: "line"
      });
    else {
      var Y = getPointsOnLines(getIntersectionPointsByConstants(B, V), [L, X]);
      Y.forEach(function(q) {
        X.some(function(Z) {
          return isSamePoint(Z, q);
        }) ? k.push({
          pos: q,
          line: X,
          type: "point"
        }) : tinyThrottle(W[1] - R) !== 0 && k.push({
          pos: q,
          line: X,
          type: "intersection"
        });
      });
    }
  }), !e && find$1(k, function(X) {
    return X[0] === o;
  }))
    return !0;
  var U = 0, z = {};
  return k.forEach(function(X) {
    var V = X.pos, W = X.type, Y = X.line;
    if (!(V[0] > o))
      if (W === "intersection")
        ++U;
      else {
        if (W === "line")
          return;
        if (W === "point") {
          var q = find$1(Y, function(Q) {
            return Q[1] !== R;
          }), Z = z[V[0]], J = q[1] > R ? 1 : -1;
          Z ? Z !== J && ++U : z[V[0]] = J;
        }
      }
  }), U % 2 === 1;
}
function getLinearConstants(n, t) {
  var e = n[0], o = n[1], R = t[0], N = t[1], M = R - e, D = N - o;
  Math.abs(M) < TINY_NUM$1 && (M = 0), Math.abs(D) < TINY_NUM$1 && (D = 0);
  var L = 0, B = 0, $ = 0;
  return M ? D ? (L = -D / M, B = 1, $ = -L * e - o) : (B = 1, $ = -o) : D && (L = -1, $ = e), [L, B, $];
}
function getIntersectionPointsByConstants(n, t) {
  var e = n[0], o = n[1], R = n[2], N = t[0], M = t[1], D = t[2], L = e === 0 && N === 0, B = o === 0 && M === 0, $ = [];
  if (L && B)
    return [];
  if (L) {
    var k = -R / o, U = -D / M;
    return k !== U ? [] : [[-1 / 0, k], [1 / 0, k]];
  } else if (B) {
    var z = -R / e, X = -D / N;
    return z !== X ? [] : [[z, -1 / 0], [z, 1 / 0]];
  } else if (e === 0) {
    var V = -R / o, W = -(M * V + D) / N;
    $ = [[W, V]];
  } else if (N === 0) {
    var V = -D / M, W = -(o * V + R) / e;
    $ = [[W, V]];
  } else if (o === 0) {
    var W = -R / e, V = -(N * W + D) / M;
    $ = [[W, V]];
  } else if (M === 0) {
    var W = -D / N, V = -(e * W + R) / o;
    $ = [[W, V]];
  } else {
    var W = (o * D - M * R) / (M * e - o * N), V = -(e * W + R) / o;
    $ = [[W, V]];
  }
  return $.map(function(Y) {
    return [Y[0], Y[1]];
  });
}
function getPointsOnLines(n, t) {
  var e = t.map(function(k) {
    return [0, 1].map(function(U) {
      return [Math.min(k[0][U], k[1][U]), Math.max(k[0][U], k[1][U])];
    });
  }), o = [];
  if (n.length === 2) {
    var R = n[0], N = R[0], M = R[1];
    if (tinyThrottle(N - n[1][0])) {
      if (!tinyThrottle(M - n[1][1])) {
        var B = Math.max.apply(Math, e.map(function(k) {
          return k[0][0];
        })), $ = Math.min.apply(Math, e.map(function(k) {
          return k[0][1];
        }));
        if (tinyThrottle(B - $) > 0)
          return [];
        o = [[B, M], [$, M]];
      }
    } else {
      var D = Math.max.apply(Math, e.map(function(k) {
        return k[1][0];
      })), L = Math.min.apply(Math, e.map(function(k) {
        return k[1][1];
      }));
      if (tinyThrottle(D - L) > 0)
        return [];
      o = [[N, D], [N, L]];
    }
  }
  return o.length || (o = n.filter(function(k) {
    var U = k[0], z = k[1];
    return e.every(function(X) {
      return 0 <= tinyThrottle(U - X[0][0]) && 0 <= tinyThrottle(X[0][1] - U) && 0 <= tinyThrottle(z - X[1][0]) && 0 <= tinyThrottle(X[1][1] - z);
    });
  })), o.map(function(k) {
    return [tinyThrottle(k[0]), tinyThrottle(k[1])];
  });
}
function convertLines(n) {
  return __spreadArrays$2(n.slice(1), [n[0]]).map(function(t, e) {
    return [n[e], t];
  });
}
function getOverlapPointInfos(n, t) {
  var e = n.slice(), o = t.slice();
  getShapeDirection(e) === -1 && e.reverse(), getShapeDirection(o) === -1 && o.reverse();
  var R = convertLines(e), N = convertLines(o), M = R.map(function($) {
    return getLinearConstants($[0], $[1]);
  }), D = N.map(function($) {
    return getLinearConstants($[0], $[1]);
  }), L = [];
  M.forEach(function($, k) {
    var U = R[k], z = [];
    D.forEach(function(X, V) {
      var W = getIntersectionPointsByConstants($, X), Y = getPointsOnLines(W, [U, N[V]]);
      z.push.apply(z, Y.map(function(q) {
        return {
          index1: k,
          index2: V,
          pos: q,
          type: "intersection"
        };
      }));
    }), z.sort(function(X, V) {
      return getDist$2(U[0], X.pos) - getDist$2(U[0], V.pos);
    }), L.push.apply(L, z), isInside(U[1], o) && L.push({
      index1: k,
      index2: -1,
      pos: U[1],
      type: "inside"
    });
  }), N.forEach(function($, k) {
    if (!!isInside($[1], e)) {
      var U = !1, z = findIndex(L, function(X) {
        var V = X.index2;
        return V === k ? (U = !0, !1) : !!U;
      });
      z === -1 && (U = !1, z = findIndex(L, function(X) {
        var V = X.index1, W = X.index2;
        return V === -1 && W + 1 === k ? (U = !0, !1) : !!U;
      })), z === -1 ? L.push({
        index1: -1,
        index2: k,
        pos: $[1],
        type: "inside"
      }) : L.splice(z, 0, {
        index1: -1,
        index2: k,
        pos: $[1],
        type: "inside"
      });
    }
  });
  var B = {};
  return L.filter(function($) {
    var k = $.pos, U = k[0] + "x" + k[1];
    return B[U] ? !1 : (B[U] = !0, !0);
  });
}
function getOverlapPoints(n, t) {
  var e = getOverlapPointInfos(n, t);
  return e.map(function(o) {
    var R = o.pos;
    return R;
  });
}
function getOverlapSize(n, t) {
  var e = getOverlapPoints(n, t);
  return getAreaSize(e);
}
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var __assign$6 = function() {
  return __assign$6 = Object.assign || function(t) {
    for (var e, o = 1, R = arguments.length; o < R; o++) {
      e = arguments[o];
      for (var N in e)
        Object.prototype.hasOwnProperty.call(e, N) && (t[N] = e[N]);
    }
    return t;
  }, __assign$6.apply(this, arguments);
};
function __spreadArrays$1() {
  for (var n = 0, t = 0, e = arguments.length; t < e; t++)
    n += arguments[t].length;
  for (var o = Array(n), R = 0, t = 0; t < e; t++)
    for (var N = arguments[t], M = 0, D = N.length; M < D; M++, R++)
      o[R] = N[M];
  return o;
}
var EventEmitter$2 = /* @__PURE__ */ function() {
  function n() {
    this._events = {};
  }
  var t = n.prototype;
  return t.on = function(e, o) {
    if (isObject$2(e))
      for (var R in e)
        this.on(R, e[R]);
    else
      this._addEvent(e, o, {});
    return this;
  }, t.off = function(e, o) {
    if (!e)
      this._events = {};
    else if (isObject$2(e))
      for (var R in e)
        this.off(R);
    else if (!o)
      this._events[e] = [];
    else {
      var N = this._events[e];
      if (N) {
        var M = findIndex(N, function(D) {
          return D.listener === o;
        });
        M > -1 && N.splice(M, 1);
      }
    }
    return this;
  }, t.once = function(e, o) {
    var R = this;
    return o && this._addEvent(e, o, {
      once: !0
    }), new Promise(function(N) {
      R._addEvent(e, N, {
        once: !0
      });
    });
  }, t.emit = function(e, o) {
    var R = this;
    o === void 0 && (o = {});
    var N = this._events[e];
    if (!e || !N)
      return !0;
    var M = !1;
    return o.eventType = e, o.stop = function() {
      M = !0;
    }, o.currentTarget = this, __spreadArrays$1(N).forEach(function(D) {
      D.listener(o), D.once && R.off(e, D.listener);
    }), !M;
  }, t.trigger = function(e, o) {
    return o === void 0 && (o = {}), this.emit(e, o);
  }, t._addEvent = function(e, o, R) {
    var N = this._events;
    N[e] = N[e] || [];
    var M = N[e];
    M.push(__assign$6({
      listener: o
    }, R));
  }, n;
}();
const EventEmitter$3 = EventEmitter$2;
var FUNCTION = "function", STRING = "string";
function isString(n) {
  return typeof n === STRING;
}
function isFunction$2(n) {
  return typeof n === FUNCTION;
}
function now() {
  return Date.now ? Date.now() : new Date().getTime();
}
/*! *****************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */
var extendStatics$4 = function(n, t) {
  return extendStatics$4 = Object.setPrototypeOf || {
    __proto__: []
  } instanceof Array && function(e, o) {
    e.__proto__ = o;
  } || function(e, o) {
    for (var R in o)
      o.hasOwnProperty(R) && (e[R] = o[R]);
  }, extendStatics$4(n, t);
};
function __extends$4(n, t) {
  extendStatics$4(n, t);
  function e() {
    this.constructor = n;
  }
  n.prototype = t === null ? Object.create(t) : (e.prototype = t.prototype, new e());
}
var __assign$5 = function() {
  return __assign$5 = Object.assign || function(t) {
    for (var e, o = 1, R = arguments.length; o < R; o++) {
      e = arguments[o];
      for (var N in e)
        Object.prototype.hasOwnProperty.call(e, N) && (t[N] = e[N]);
    }
    return t;
  }, __assign$5.apply(this, arguments);
};
function getDefaultScrollPosition$1(n) {
  var t = n.container;
  return t === document.body ? [t.scrollLeft || document.documentElement.scrollLeft, t.scrollTop || document.documentElement.scrollTop] : [t.scrollLeft, t.scrollTop];
}
function getContainerElement(n) {
  if (n) {
    if (isString(n))
      return document.querySelector(n);
  } else
    return null;
  if (isFunction$2(n))
    return n();
  if (n instanceof Element)
    return n;
  if ("current" in n)
    return n.current;
  if ("value" in n)
    return n.value;
}
var DragScroll = /* @__PURE__ */ function(n) {
  __extends$4(t, n);
  function t() {
    var o = n !== null && n.apply(this, arguments) || this;
    return o._startRect = null, o._startPos = [], o._prevTime = 0, o._timer = 0, o._prevScrollPos = [0, 0], o._isWait = !1, o._flag = !1, o;
  }
  var e = t.prototype;
  return e.dragStart = function(o, R) {
    var N = getContainerElement(R.container);
    if (!N) {
      this._flag = !1;
      return;
    }
    var M = 0, D = 0, L = 0, B = 0;
    if (N === document.body)
      L = window.innerWidth, B = window.innerHeight;
    else {
      var $ = N.getBoundingClientRect();
      M = $.top, D = $.left, L = $.width, B = $.height;
    }
    this._flag = !0, this._startPos = [o.clientX, o.clientY], this._startRect = {
      top: M,
      left: D,
      width: L,
      height: B
    }, this._prevScrollPos = this._getScrollPosition([0, 0], R);
  }, e.drag = function(o, R) {
    if (!!this._flag) {
      var N = o.clientX, M = o.clientY, D = R.threshold, L = D === void 0 ? 0 : D, B = this, $ = B._startRect, k = B._startPos, U = [0, 0];
      return $.top > M - L ? (k[1] > $.top || M < k[1]) && (U[1] = -1) : $.top + $.height < M + L && (k[1] < $.top + $.height || M > k[1]) && (U[1] = 1), $.left > N - L ? (k[0] > $.left || N < k[0]) && (U[0] = -1) : $.left + $.width < N + L && (k[0] < $.left + $.width || N > k[0]) && (U[0] = 1), clearTimeout(this._timer), !U[0] && !U[1] ? !1 : this._continueDrag(__assign$5(__assign$5({}, R), {
        direction: U,
        inputEvent: o,
        isDrag: !0
      }));
    }
  }, e.checkScroll = function(o) {
    var R = this;
    if (this._isWait)
      return !1;
    var N = o.prevScrollPos, M = N === void 0 ? this._prevScrollPos : N, D = o.direction, L = o.throttleTime, B = L === void 0 ? 0 : L, $ = o.inputEvent, k = o.isDrag, U = this._getScrollPosition(D || [0, 0], o), z = U[0] - M[0], X = U[1] - M[1], V = D || [z ? Math.abs(z) / z : 0, X ? Math.abs(X) / X : 0];
    return this._prevScrollPos = U, !z && !X ? !1 : (this.trigger("move", {
      offsetX: V[0] ? z : 0,
      offsetY: V[1] ? X : 0,
      inputEvent: $
    }), B && k && (this._timer = window.setTimeout(function() {
      R._continueDrag(o);
    }, B)), !0);
  }, e.dragEnd = function() {
    clearTimeout(this._timer);
  }, e._getScrollPosition = function(o, R) {
    var N = R.container, M = R.getScrollPosition, D = M === void 0 ? getDefaultScrollPosition$1 : M;
    return D({
      container: getContainerElement(N),
      direction: o
    });
  }, e._continueDrag = function(o) {
    var R = this, N = o.container, M = o.direction, D = o.throttleTime, L = o.useScroll, B = o.isDrag, $ = o.inputEvent;
    if (!(B && this._isWait)) {
      var k = now(), U = Math.max(D + this._prevTime - k, 0);
      if (U > 0)
        return this._timer = window.setTimeout(function() {
          R._continueDrag(o);
        }, U), !1;
      this._prevTime = k;
      var z = this._getScrollPosition(M, o);
      return this._prevScrollPos = z, B && (this._isWait = !0), this.trigger("scroll", {
        container: getContainerElement(N),
        direction: M,
        inputEvent: $
      }), this._isWait = !1, L || this.checkScroll(__assign$5(__assign$5({}, o), {
        prevScrollPos: z,
        direction: M,
        inputEvent: $
      }));
    }
  }, t;
}(EventEmitter$3);
const DragScroll$1 = DragScroll;
/*! *****************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */
var extendStatics$3 = function(n, t) {
  return extendStatics$3 = Object.setPrototypeOf || {
    __proto__: []
  } instanceof Array && function(e, o) {
    e.__proto__ = o;
  } || function(e, o) {
    for (var R in o)
      o.hasOwnProperty(R) && (e[R] = o[R]);
  }, extendStatics$3(n, t);
};
function __extends$3(n, t) {
  extendStatics$3(n, t);
  function e() {
    this.constructor = n;
  }
  n.prototype = t === null ? Object.create(t) : (e.prototype = t.prototype, new e());
}
var __assign$4 = function() {
  return __assign$4 = Object.assign || function(t) {
    for (var e, o = 1, R = arguments.length; o < R; o++) {
      e = arguments[o];
      for (var N in e)
        Object.prototype.hasOwnProperty.call(e, N) && (t[N] = e[N]);
    }
    return t;
  }, __assign$4.apply(this, arguments);
};
function getRad(n, t) {
  var e = t[0] - n[0], o = t[1] - n[1], R = Math.atan2(o, e);
  return R >= 0 ? R : R + Math.PI * 2;
}
function getRotatiion(n) {
  return getRad([n[0].clientX, n[0].clientY], [n[1].clientX, n[1].clientY]) / Math.PI * 180;
}
function isMultiTouch(n) {
  return n.touches && n.touches.length >= 2;
}
function getEventClients(n) {
  return n ? n.touches ? getClients(n.touches) : [getClient(n)] : [];
}
function isMouseEvent(n) {
  return n && (n.type.indexOf("mouse") > -1 || "button" in n);
}
function getPosition(n, t, e) {
  var o = e.length, R = getAverageClient(n, o), N = R.clientX, M = R.clientY, D = R.originalClientX, L = R.originalClientY, B = getAverageClient(t, o), $ = B.clientX, k = B.clientY, U = getAverageClient(e, o), z = U.clientX, X = U.clientY, V = N - $, W = M - k, Y = N - z, q = M - X;
  return {
    clientX: D,
    clientY: L,
    deltaX: V,
    deltaY: W,
    distX: Y,
    distY: q
  };
}
function getDist$1(n) {
  return Math.sqrt(Math.pow(n[0].clientX - n[1].clientX, 2) + Math.pow(n[0].clientY - n[1].clientY, 2));
}
function getClients(n) {
  for (var t = Math.min(n.length, 2), e = [], o = 0; o < t; ++o)
    e.push(getClient(n[o]));
  return e;
}
function getClient(n) {
  return {
    clientX: n.clientX,
    clientY: n.clientY
  };
}
function getAverageClient(n, t) {
  t === void 0 && (t = n.length);
  for (var e = {
    clientX: 0,
    clientY: 0,
    originalClientX: 0,
    originalClientY: 0
  }, o = 0; o < t; ++o) {
    var R = n[o];
    e.originalClientX += "originalClientX" in R ? R.originalClientX : R.clientX, e.originalClientY += "originalClientY" in R ? R.originalClientY : R.clientY, e.clientX += R.clientX, e.clientY += R.clientY;
  }
  return t ? {
    clientX: e.clientX / t,
    clientY: e.clientY / t,
    originalClientX: e.originalClientX / t,
    originalClientY: e.originalClientY / t
  } : e;
}
var ClientStore = /* @__PURE__ */ function() {
  function n(e) {
    this.prevClients = [], this.startClients = [], this.movement = 0, this.length = 0, this.startClients = e, this.prevClients = e, this.length = e.length;
  }
  var t = n.prototype;
  return t.getAngle = function(e) {
    return e === void 0 && (e = this.prevClients), getRotatiion(e);
  }, t.getRotation = function(e) {
    return e === void 0 && (e = this.prevClients), getRotatiion(e) - getRotatiion(this.startClients);
  }, t.getPosition = function(e, o) {
    e === void 0 && (e = this.prevClients);
    var R = getPosition(e || this.prevClients, this.prevClients, this.startClients), N = R.deltaX, M = R.deltaY;
    return this.movement += Math.sqrt(N * N + M * M), this.prevClients = e, R;
  }, t.getPositions = function(e) {
    e === void 0 && (e = this.prevClients);
    var o = this.prevClients;
    return this.startClients.map(function(R, N) {
      return getPosition([e[N]], [o[N]], [R]);
    });
  }, t.getMovement = function(e) {
    var o = this.movement;
    if (!e)
      return o;
    var R = getAverageClient(e, this.length), N = getAverageClient(this.prevClients, this.length), M = R.clientX - N.clientX, D = R.clientY - N.clientY;
    return Math.sqrt(M * M + D * D) + o;
  }, t.getDistance = function(e) {
    return e === void 0 && (e = this.prevClients), getDist$1(e);
  }, t.getScale = function(e) {
    return e === void 0 && (e = this.prevClients), getDist$1(e) / getDist$1(this.startClients);
  }, t.move = function(e, o) {
    this.startClients.forEach(function(R) {
      R.clientX -= e, R.clientY -= o;
    });
  }, n;
}(), INPUT_TAGNAMES = ["textarea", "input"], Gesto = /* @__PURE__ */ function(n) {
  __extends$3(t, n);
  function t(o, R) {
    R === void 0 && (R = {});
    var N = n.call(this) || this;
    N.options = {}, N.flag = !1, N.pinchFlag = !1, N.data = {}, N.isDrag = !1, N.isPinch = !1, N.isMouse = !1, N.isTouch = !1, N.clientStores = [], N.targets = [], N.prevTime = 0, N.doubleFlag = !1, N._dragFlag = !1, N._isMouseEvent = !1, N._isSecondaryButton = !1, N._preventMouseEvent = !1, N.onDragStart = function(U, z) {
      if (z === void 0 && (z = !0), !(!N.flag && U.cancelable === !1)) {
        var X = N.options, V = X.container, W = X.pinchOutside, Y = X.preventWheelClick, q = X.preventRightClick, Z = X.preventDefault, J = X.checkInput, Q = X.preventClickEventOnDragStart, K = X.preventClickEventOnDrag, rt = X.preventClickEventByCondition, tt = N.isTouch, nt = !N.flag;
        if (N._isSecondaryButton = U.which === 3 || U.button === 2, Y && (U.which === 2 || U.button === 1) || q && (U.which === 3 || U.button === 2))
          return N.stop(), !1;
        if (nt) {
          var at = document.activeElement, lt = U.target, ut = lt.tagName.toLowerCase(), dt = INPUT_TAGNAMES.indexOf(ut) > -1, yt = lt.isContentEditable;
          if (dt || yt) {
            if (J || at === lt || at && yt && at.isContentEditable && at.contains(lt))
              return !1;
          } else if ((Z || U.type === "touchstart") && at) {
            var pt = at.tagName;
            (at.isContentEditable || INPUT_TAGNAMES.indexOf(pt) > -1) && at.blur();
          }
          (Q || K || rt) && addEvent(window, "click", N._onClick, !0), N.clientStores = [new ClientStore(getEventClients(U))], N.flag = !0, N.isDrag = !1, N._dragFlag = !0, N.data = {}, N.doubleFlag = now$1() - N.prevTime < 200, N._isMouseEvent = isMouseEvent(U), !N._isMouseEvent && N._preventMouseEvent && (N._preventMouseEvent = !1);
          var gt = N._preventMouseEvent || N.emit("dragStart", __assign$4(__assign$4({
            data: N.data,
            datas: N.data,
            inputEvent: U,
            isMouseEvent: N._isMouseEvent,
            isSecondaryButton: N._isSecondaryButton,
            isTrusted: z,
            isDouble: N.doubleFlag
          }, N.getCurrentStore().getPosition()), {
            preventDefault: function() {
              U.preventDefault();
            },
            preventDrag: function() {
              N._dragFlag = !1;
            }
          }));
          gt === !1 && N.stop(), N._isMouseEvent && N.flag && Z && U.preventDefault();
        }
        if (!N.flag)
          return !1;
        var xt = 0;
        if (nt ? (N._attchDragEvent(), tt && W && (xt = setTimeout(function() {
          addEvent(V, "touchstart", N.onDragStart, {
            passive: !1
          });
        }))) : tt && W && removeEvent(V, "touchstart", N.onDragStart), N.flag && isMultiTouch(U)) {
          if (clearTimeout(xt), nt && U.touches.length !== U.changedTouches.length)
            return;
          N.pinchFlag || N.onPinchStart(U);
        }
      }
    }, N.onDrag = function(U, z) {
      if (!!N.flag) {
        var X = N.options.preventDefault;
        !N._isMouseEvent && X && U.preventDefault();
        var V = getEventClients(U), W = N.moveClients(V, U, !1);
        if (N._dragFlag) {
          if (N.pinchFlag || W.deltaX || W.deltaY) {
            var Y = N._preventMouseEvent || N.emit("drag", __assign$4(__assign$4({}, W), {
              isScroll: !!z,
              inputEvent: U
            }));
            if (Y === !1) {
              N.stop();
              return;
            }
          }
          N.pinchFlag && N.onPinch(U, V);
        }
        N.getCurrentStore().getPosition(V, !0);
      }
    }, N.onDragEnd = function(U) {
      if (!!N.flag) {
        var z = N.options, X = z.pinchOutside, V = z.container, W = z.preventClickEventOnDrag, Y = z.preventClickEventOnDragStart, q = z.preventClickEventByCondition, Z = N.isDrag;
        (W || Y || q) && requestAnimationFrame(function() {
          N._allowClickEvent();
        }), !q && !Y && W && !Z && N._allowClickEvent(), N.isTouch && X && removeEvent(V, "touchstart", N.onDragStart), N.pinchFlag && N.onPinchEnd(U);
        var J = U != null && U.touches ? getEventClients(U) : [], Q = J.length;
        Q === 0 || !N.options.keepDragging ? N.flag = !1 : N._addStore(new ClientStore(J));
        var K = N._getPosition(), rt = now$1(), tt = !Z && N.doubleFlag;
        N.prevTime = Z || tt ? 0 : rt, N.flag || (N._dettachDragEvent(), N._preventMouseEvent || N.emit("dragEnd", __assign$4({
          data: N.data,
          datas: N.data,
          isDouble: tt,
          isDrag: Z,
          isClick: !Z,
          isMouseEvent: N._isMouseEvent,
          isSecondaryButton: N._isSecondaryButton,
          inputEvent: U
        }, K)), N.clientStores = [], N._isMouseEvent || (N._preventMouseEvent = !0, requestAnimationFrame(function() {
          requestAnimationFrame(function() {
            N._preventMouseEvent = !1;
          });
        })));
      }
    }, N.onBlur = function() {
      N.onDragEnd();
    }, N._allowClickEvent = function() {
      removeEvent(window, "click", N._onClick, !0);
    }, N._onClick = function(U) {
      N._preventMouseEvent = !1;
      var z = N.options.preventClickEventByCondition;
      z != null && z(U) || (U.stopPropagation(), U.preventDefault());
    }, N._onContextMenu = function(U) {
      var z = N.options;
      z.preventRightClick ? N.onDragEnd(U) : U.preventDefault();
    }, N._passCallback = function() {
    };
    var M = [].concat(o);
    N.options = __assign$4({
      checkInput: !1,
      container: M.length > 1 ? window : M[0],
      preventRightClick: !0,
      preventWheelClick: !0,
      preventClickEventOnDragStart: !1,
      preventClickEventOnDrag: !1,
      preventClickEventByCondition: null,
      preventDefault: !0,
      checkWindowBlur: !1,
      keepDragging: !1,
      pinchThreshold: 0,
      events: ["touch", "mouse"]
    }, R);
    var D = N.options, L = D.container, B = D.events, $ = D.checkWindowBlur;
    if (N.isTouch = B.indexOf("touch") > -1, N.isMouse = B.indexOf("mouse") > -1, N.targets = M, N.isMouse && (M.forEach(function(U) {
      addEvent(U, "mousedown", N.onDragStart), addEvent(U, "mousemove", N._passCallback);
    }), addEvent(L, "contextmenu", N._onContextMenu)), $ && addEvent(window, "blur", N.onBlur), N.isTouch) {
      var k = {
        passive: !1
      };
      M.forEach(function(U) {
        addEvent(U, "touchstart", N.onDragStart, k), addEvent(U, "touchmove", N._passCallback, k);
      });
    }
    return N;
  }
  var e = t.prototype;
  return e.stop = function() {
    this.isDrag = !1, this.data = {}, this.clientStores = [], this.pinchFlag = !1, this.doubleFlag = !1, this.prevTime = 0, this.flag = !1, this._allowClickEvent(), this._dettachDragEvent();
  }, e.getMovement = function(o) {
    return this.getCurrentStore().getMovement(o) + this.clientStores.slice(1).reduce(function(R, N) {
      return R + N.movement;
    }, 0);
  }, e.isDragging = function() {
    return this.isDrag;
  }, e.isFlag = function() {
    return this.flag;
  }, e.isPinchFlag = function() {
    return this.pinchFlag;
  }, e.isDoubleFlag = function() {
    return this.doubleFlag;
  }, e.isPinching = function() {
    return this.isPinch;
  }, e.scrollBy = function(o, R, N, M) {
    M === void 0 && (M = !0), this.flag && (this.clientStores[0].move(o, R), M && this.onDrag(N, !0));
  }, e.move = function(o, R) {
    var N = o[0], M = o[1], D = this.getCurrentStore(), L = D.prevClients;
    return this.moveClients(L.map(function(B) {
      var $ = B.clientX, k = B.clientY;
      return {
        clientX: $ + N,
        clientY: k + M,
        originalClientX: $,
        originalClientY: k
      };
    }), R, !0);
  }, e.triggerDragStart = function(o) {
    this.onDragStart(o, !1);
  }, e.setEventData = function(o) {
    var R = this.data;
    for (var N in o)
      R[N] = o[N];
    return this;
  }, e.setEventDatas = function(o) {
    return this.setEventData(o);
  }, e.getCurrentEvent = function(o) {
    return __assign$4(__assign$4({
      data: this.data,
      datas: this.data
    }, this._getPosition()), {
      movement: this.getMovement(),
      isDrag: this.isDrag,
      isPinch: this.isPinch,
      isScroll: !1,
      inputEvent: o
    });
  }, e.getEventData = function() {
    return this.data;
  }, e.getEventDatas = function() {
    return this.data;
  }, e.unset = function() {
    var o = this, R = this.targets, N = this.options.container;
    this.off(), removeEvent(window, "blur", this.onBlur), this.isMouse && (R.forEach(function(M) {
      removeEvent(M, "mousedown", o.onDragStart);
    }), removeEvent(N, "contextmenu", this._onContextMenu)), this.isTouch && (R.forEach(function(M) {
      removeEvent(M, "touchstart", o.onDragStart);
    }), removeEvent(N, "touchstart", this.onDragStart)), this._dettachDragEvent();
  }, e.onPinchStart = function(o) {
    var R = this.options.pinchThreshold;
    if (!(this.isDrag && this.getMovement() > R)) {
      var N = new ClientStore(getEventClients(o));
      this.pinchFlag = !0, this._addStore(N);
      var M = this.emit("pinchStart", __assign$4(__assign$4({
        data: this.data,
        datas: this.data,
        angle: N.getAngle(),
        touches: this.getCurrentStore().getPositions()
      }, N.getPosition()), {
        inputEvent: o
      }));
      M === !1 && (this.pinchFlag = !1);
    }
  }, e.onPinch = function(o, R) {
    if (!(!this.flag || !this.pinchFlag || R.length < 2)) {
      var N = this.getCurrentStore();
      this.isPinch = !0, this.emit("pinch", __assign$4(__assign$4({
        data: this.data,
        datas: this.data,
        movement: this.getMovement(R),
        angle: N.getAngle(R),
        rotation: N.getRotation(R),
        touches: N.getPositions(R),
        scale: N.getScale(R),
        distance: N.getDistance(R)
      }, N.getPosition(R)), {
        inputEvent: o
      }));
    }
  }, e.onPinchEnd = function(o) {
    if (!!this.pinchFlag) {
      var R = this.isPinch;
      this.isPinch = !1, this.pinchFlag = !1;
      var N = this.getCurrentStore();
      this.emit("pinchEnd", __assign$4(__assign$4({
        data: this.data,
        datas: this.data,
        isPinch: R,
        touches: N.getPositions()
      }, N.getPosition()), {
        inputEvent: o
      }));
    }
  }, e.getCurrentStore = function() {
    return this.clientStores[0];
  }, e.moveClients = function(o, R, N) {
    var M = this._getPosition(o, N);
    return (M.deltaX || M.deltaY) && (this.isDrag = !0), __assign$4(__assign$4({
      data: this.data,
      datas: this.data
    }, M), {
      movement: this.getMovement(o),
      isDrag: this.isDrag,
      isPinch: this.isPinch,
      isScroll: !1,
      isMouseEvent: this._isMouseEvent,
      isSecondaryButton: this._isSecondaryButton,
      inputEvent: R
    });
  }, e._addStore = function(o) {
    this.clientStores.splice(0, 0, o);
  }, e._getPosition = function(o, R) {
    var N = this.getCurrentStore(), M = N.getPosition(o, R), D = this.clientStores.slice(1).reduce(function($, k) {
      var U = k.getPosition();
      return $.distX += U.distX, $.distY += U.distY, $;
    }, M), L = D.distX, B = D.distY;
    return __assign$4(__assign$4({}, M), {
      distX: L,
      distY: B
    });
  }, e._attchDragEvent = function() {
    var o = this.options.container, R = {
      passive: !1
    };
    this.isMouse && (addEvent(o, "mousemove", this.onDrag), addEvent(o, "mouseup", this.onDragEnd)), this.isTouch && (addEvent(o, "touchmove", this.onDrag, R), addEvent(o, "touchend", this.onDragEnd, R), addEvent(o, "touchcancel", this.onDragEnd, R));
  }, e._dettachDragEvent = function() {
    var o = this.options.container;
    this.isMouse && (removeEvent(o, "mousemove", this.onDrag), removeEvent(o, "mouseup", this.onDragEnd)), this.isTouch && (removeEvent(o, "touchstart", this.onDragStart), removeEvent(o, "touchmove", this.onDrag), removeEvent(o, "touchend", this.onDragEnd), removeEvent(o, "touchcancel", this.onDragEnd));
  }, t;
}(EventEmitter$3);
const Gesto$1 = Gesto;
function hash$2(n) {
  for (var t = 5381, e = n.length; e; )
    t = t * 33 ^ n.charCodeAt(--e);
  return t >>> 0;
}
var stringHash = hash$2;
function getHash(n) {
  return stringHash(n).toString(36);
}
function getShadowRoot$1(n) {
  if (n && n.getRootNode) {
    var t = n.getRootNode();
    if (t.nodeType === 11)
      return t;
  }
}
function replaceStyle(n, t, e) {
  return e.original ? t : t.replace(/([^};{\s}][^};{]*|^\s*){/mg, function(o, R) {
    var N = R.trim();
    return (N ? splitComma(N) : [""]).map(function(M) {
      var D = M.trim();
      return D.indexOf("@") === 0 ? D : D.indexOf(":global") > -1 ? D.replace(/\:global/g, "") : D.indexOf(":host") > -1 ? "" + D.replace(/\:host/g, "." + n) : D ? "." + n + " " + D : "." + n;
    }).join(", ") + " {";
  });
}
function injectStyle(n, t, e, o) {
  var R = document.createElement("style");
  return R.setAttribute("type", "text/css"), R.setAttribute("data-styled-id", n), e.nonce && R.setAttribute("nonce", e.nonce), R.innerHTML = replaceStyle(n, t, e), (o || document.head || document.body).appendChild(R), R;
}
function styled$1(n) {
  var t = "rCS" + getHash(n), e = 0, o;
  return {
    className: t,
    inject: function(R, N) {
      N === void 0 && (N = {});
      var M = getShadowRoot$1(R), D = e === 0, L;
      return (M || D) && (L = injectStyle(t, n, N, M)), D && (o = L), M || ++e, {
        destroy: function() {
          M ? (R.removeChild(L), L = null) : (e > 0 && --e, e === 0 && o && (o.parentNode.removeChild(o), o = null));
        }
      };
    }
  };
}
/*! *****************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */
var extendStatics$2 = function(n, t) {
  return extendStatics$2 = Object.setPrototypeOf || {
    __proto__: []
  } instanceof Array && function(e, o) {
    e.__proto__ = o;
  } || function(e, o) {
    for (var R in o)
      o.hasOwnProperty(R) && (e[R] = o[R]);
  }, extendStatics$2(n, t);
};
function __extends$2(n, t) {
  extendStatics$2(n, t);
  function e() {
    this.constructor = n;
  }
  n.prototype = t === null ? Object.create(t) : (e.prototype = t.prototype, new e());
}
var __assign$3 = function() {
  return __assign$3 = Object.assign || function(t) {
    for (var e, o = 1, R = arguments.length; o < R; o++) {
      e = arguments[o];
      for (var N in e)
        Object.prototype.hasOwnProperty.call(e, N) && (t[N] = e[N]);
    }
    return t;
  }, __assign$3.apply(this, arguments);
};
function __rest$1(n, t) {
  var e = {};
  for (var o in n)
    Object.prototype.hasOwnProperty.call(n, o) && t.indexOf(o) < 0 && (e[o] = n[o]);
  if (n != null && typeof Object.getOwnPropertySymbols == "function")
    for (var R = 0, o = Object.getOwnPropertySymbols(n); R < o.length; R++)
      t.indexOf(o[R]) < 0 && Object.prototype.propertyIsEnumerable.call(n, o[R]) && (e[o[R]] = n[o[R]]);
  return e;
}
var StyledElement = /* @__PURE__ */ function(n) {
  __extends$2(t, n);
  function t() {
    var o = n !== null && n.apply(this, arguments) || this;
    return o.injectResult = null, o.tag = "div", o;
  }
  var e = t.prototype;
  return e.render = function() {
    var o = this.props, R = o.className, N = R === void 0 ? "" : R;
    o.cspNonce;
    var M = o.portalContainer, D = __rest$1(o, ["className", "cspNonce", "portalContainer"]), L = this.injector.className, B = this.tag, $ = {};
    return version.indexOf("simple") > -1 && M && ($ = {
      portalContainer: M
    }), createElement(B, __assign$3({
      ref: ref(this, "element"),
      "data-styled-id": L,
      className: N + " " + L
    }, $, D));
  }, e.componentDidMount = function() {
    this.injectResult = this.injector.inject(this.element, {
      nonce: this.props.cspNonce
    });
  }, e.componentWillUnmount = function() {
    this.injectResult.destroy(), this.injectResult = null;
  }, e.getElement = function() {
    return this.element;
  }, t;
}(Component);
function styled(n, t) {
  var e = styled$1(t);
  return /* @__PURE__ */ function(o) {
    __extends$2(R, o);
    function R() {
      var N = o !== null && o.apply(this, arguments) || this;
      return N.injector = e, N.tag = n, N;
    }
    return R;
  }(StyledElement);
}
var extendStatics$1 = function(n, t) {
  return extendStatics$1 = Object.setPrototypeOf || {
    __proto__: []
  } instanceof Array && function(e, o) {
    e.__proto__ = o;
  } || function(e, o) {
    for (var R in o)
      Object.prototype.hasOwnProperty.call(o, R) && (e[R] = o[R]);
  }, extendStatics$1(n, t);
};
function __extends$1(n, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Class extends value " + String(t) + " is not a constructor or null");
  extendStatics$1(n, t);
  function e() {
    this.constructor = n;
  }
  n.prototype = t === null ? Object.create(t) : (e.prototype = t.prototype, new e());
}
var __assign$2 = function() {
  return __assign$2 = Object.assign || function(t) {
    for (var e, o = 1, R = arguments.length; o < R; o++) {
      e = arguments[o];
      for (var N in e)
        Object.prototype.hasOwnProperty.call(e, N) && (t[N] = e[N]);
    }
    return t;
  }, __assign$2.apply(this, arguments);
};
function __rest(n, t) {
  var e = {};
  for (var o in n)
    Object.prototype.hasOwnProperty.call(n, o) && t.indexOf(o) < 0 && (e[o] = n[o]);
  if (n != null && typeof Object.getOwnPropertySymbols == "function")
    for (var R = 0, o = Object.getOwnPropertySymbols(n); R < o.length; R++)
      t.indexOf(o[R]) < 0 && Object.prototype.propertyIsEnumerable.call(n, o[R]) && (e[o[R]] = n[o[R]]);
  return e;
}
function __decorate$1(n, t, e, o) {
  var R = arguments.length, N = R < 3 ? t : o === null ? o = Object.getOwnPropertyDescriptor(t, e) : o, M;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    N = Reflect.decorate(n, t, e, o);
  else
    for (var D = n.length - 1; D >= 0; D--)
      (M = n[D]) && (N = (R < 3 ? M(N) : R > 3 ? M(t, e, N) : M(t, e)) || N);
  return R > 3 && N && Object.defineProperty(t, e, N), N;
}
function __spreadArray(n, t, e) {
  if (e || arguments.length === 2)
    for (var o = 0, R = t.length, N; o < R; o++)
      (N || !(o in t)) && (N || (N = Array.prototype.slice.call(t, 0, o)), N[o] = t[o]);
  return n.concat(N || Array.prototype.slice.call(t));
}
function makeAble(n, t) {
  var e;
  return __assign$2({
    events: {},
    props: (e = {}, e[n] = Boolean, e),
    name: n
  }, t);
}
function getSVGCursor(n, t) {
  return 'data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="'.concat(32 * n, 'px" height="').concat(32 * n, 'px" viewBox="0 0 32 32" ><path d="M 16,5 L 12,10 L 14.5,10 L 14.5,22 L 12,22 L 16,27 L 20,22 L 17.5,22 L 17.5,10 L 20, 10 L 16,5 Z" stroke-linejoin="round" stroke-width="1.2" fill="black" stroke="white" style="transform:rotate(').concat(t, 'deg);transform-origin: 16px 16px"></path></svg>');
}
function getCursorCSS(n) {
  var t = getSVGCursor(1, n), e = Math.round(n / 45) * 45 % 180, o = "ns-resize";
  return e === 135 ? o = "nwse-resize" : e === 45 ? o = "nesw-resize" : e === 90 && (o = "ew-resize"), "cursor:".concat(o, ";cursor: url('").concat(t, "') 16 16, ").concat(o, ";");
}
var agent = agent$1(), IS_WEBKIT = agent.browser.webkit, IS_WEBKIT605 = IS_WEBKIT && function() {
  var n = typeof window > "u" ? {
    userAgent: ""
  } : window.navigator, t = /applewebkit\/([^\s]+)/g.exec(n.userAgent.toLowerCase());
  return t ? parseFloat(t[1]) < 605 : !1;
}(), IS_FIREFOX = agent.browser.name === "firefox", IS_SAFARI_ABOVE15 = parseInt(agent.browser.webkitVersion, 10) >= 612 || parseInt(agent.browser.version, 10) >= 15, PREFIX = "moveable-", MOVEABLE_CSS = `
{
	position: absolute;
	width: 1px;
	height: 1px;
	left: 0;
	top: 0;
    z-index: 3000;
    --moveable-color: #4af;
    --zoom: 1;
    --zoompx: 1px;
    will-change: transform;
}
.control-box {
    z-index: 0;
}
.line, .control {
    position: absolute;
	left: 0;
    top: 0;
    will-change: transform;
}
.control {
	width: 14px;
	height: 14px;
	border-radius: 50%;
	border: 2px solid #fff;
	box-sizing: border-box;
    background: #4af;
    background: var(--moveable-color);
	margin-top: -7px;
    margin-left: -7px;
    border: 2px solid #fff;
    z-index: 10;
}
.padding {
    position: absolute;
    top: 0px;
    left: 0px;
    width: 100px;
    height: 100px;
    transform-origin: 0 0;
}
.line {
	width: 1px;
    height: 1px;
    background: #4af;
    background: var(--moveable-color);
	transform-origin: 0px 50%;
}
.line.edge {
    z-index: 1;
    background: transparent;
}
.line.dashed {
    box-sizing: border-box;
    background: transparent;
}
.line.dashed.horizontal {
    border-top: 1px dashed #4af;
    border-top-color: #4af;
    border-top-color: var(--moveable-color);
}
.line.dashed.vertical {
    border-left: 1px dashed #4af;
    border-left-color: #4af;
    border-left-color: var(--moveable-color);
}
.line.vertical {
    transform: translateX(-50%);
}
.line.horizontal {
    transform: translateY(-50%);
}
.line.vertical.bold {
    width: 2px;
}
.line.horizontal.bold {
    height: 2px;
}

.control.origin {
	border-color: #f55;
	background: #fff;
	width: 12px;
	height: 12px;
	margin-top: -6px;
    margin-left: -6px;
	pointer-events: none;
}
`.concat([0, 15, 30, 45, 60, 75, 90, 105, 120, 135, 150, 165].map(function(n) {
  return `
.direction[data-rotation="`.concat(n, `"] {
	`).concat(getCursorCSS(n), `
}
`);
}).join(`
`), `
.group {
    z-index: -1;
}
.area {
    position: absolute;
}
.area-pieces {
    position: absolute;
    top: 0;
    left: 0;
    display: none;
}
.area.avoid, .area.pass {
    pointer-events: none;
}
.area.avoid+.area-pieces {
    display: block;
}
.area-piece {
    position: absolute;
}

`).concat(IS_WEBKIT605 ? `:global svg *:before {
	content:"";
	transform-origin: inherit;
}` : "", `
`), NEARBY_POS = [[0, 1, 2], [1, 0, 3], [2, 0, 3], [3, 1, 2]], FLOAT_POINT_NUM = 1e-4, TINY_NUM = 1e-7, MIN_SCALE = 1e-9, MAX_NUM = Math.pow(10, 10), MIN_NUM = -MAX_NUM, DIRECTIONS4 = ["n", "w", "s", "e"], DIRECTIONS = ["n", "w", "s", "e", "nw", "ne", "sw", "se"], DIRECTION_REGION_TO_DIRECTION = {
  n: [0, -1],
  e: [1, 0],
  s: [0, 1],
  w: [-1, 0],
  nw: [-1, -1],
  ne: [1, -1],
  sw: [-1, 1],
  se: [1, 1]
}, DIRECTION_INDEXES = {
  n: [0, 1],
  e: [1, 3],
  s: [3, 2],
  w: [2, 0],
  nw: [0],
  ne: [1],
  sw: [2],
  se: [3]
}, DIRECTION_ROTATIONS = {
  n: 0,
  s: 180,
  w: 270,
  e: 90,
  nw: 315,
  ne: 45,
  sw: 225,
  se: 135
}, MOVEABLE_METHODS = ["isMoveableElement", "updateRect", "updateTarget", "destroy", "dragStart", "isInside", "hitTest", "setState", "getRect", "request", "isDragging", "getManager", "forceUpdate", "waitToChangeTarget"];
function setCustomDrag(n, t, e, o, R, N) {
  N === void 0 && (N = "draggable");
  var M = t.gestos[N].move(e, n.inputEvent), D = M.originalDatas || M.datas, L = D[N] || (D[N] = {});
  return __assign$2(__assign$2({}, R ? convertDragDist(t, M) : M), {
    isPinch: !!o,
    parentEvent: !0,
    datas: L,
    originalDatas: n.originalDatas
  });
}
var CustomGesto = /* @__PURE__ */ function() {
  function n(e) {
    var o;
    e === void 0 && (e = "draggable"), this.ableName = e, this.prevX = 0, this.prevY = 0, this.startX = 0, this.startY = 0, this.isDrag = !1, this.isFlag = !1, this.datas = {
      draggable: {}
    }, this.datas = (o = {}, o[e] = {}, o);
  }
  var t = n.prototype;
  return t.dragStart = function(e, o) {
    this.isDrag = !1, this.isFlag = !1;
    var R = o.originalDatas;
    return this.datas = R, R[this.ableName] || (R[this.ableName] = {}), __assign$2(__assign$2({}, this.move(e, o.inputEvent)), {
      type: "dragstart"
    });
  }, t.drag = function(e, o) {
    return this.move([e[0] - this.prevX, e[1] - this.prevY], o);
  }, t.move = function(e, o) {
    var R, N;
    return this.isFlag ? (R = this.prevX + e[0], N = this.prevY + e[1], (e[0] || e[1]) && (this.isDrag = !0)) : (this.prevX = e[0], this.prevY = e[1], this.startX = e[0], this.startY = e[1], R = e[0], N = e[1], this.isFlag = !0), this.prevX = R, this.prevY = N, {
      type: "drag",
      clientX: R,
      clientY: N,
      inputEvent: o,
      isDrag: this.isDrag,
      distX: R - this.startX,
      distY: N - this.startY,
      deltaX: e[0],
      deltaY: e[1],
      datas: this.datas[this.ableName],
      originalDatas: this.datas,
      parentEvent: !0,
      parentGesto: this
    };
  }, n;
}();
function calculatePointerDist(n, t) {
  var e = t.clientX, o = t.clientY, R = t.datas, N = n.state, M = N.moveableClientRect, D = N.rootMatrix, L = N.is3d, B = N.pos1, $ = M.left, k = M.top, U = L ? 4 : 3, z = minus(calculateInversePosition(D, [e - $, o - k], U), B), X = z[0], V = z[1], W = getDragDist({
    datas: R,
    distX: X,
    distY: V
  }), Y = W[0], q = W[1];
  return [Y, q];
}
function setDragStart(n, t) {
  var e = t.datas, o = n.state, R = o.allMatrix, N = o.beforeMatrix, M = o.is3d, D = o.left, L = o.top, B = o.origin, $ = o.offsetMatrix, k = o.targetMatrix, U = o.transformOrigin, z = M ? 4 : 3;
  e.is3d = M, e.matrix = R, e.targetMatrix = k, e.beforeMatrix = N, e.offsetMatrix = $, e.transformOrigin = U, e.inverseMatrix = invert(R, z), e.inverseBeforeMatrix = invert(N, z), e.absoluteOrigin = convertPositionMatrix(plus([D, L], B), z), e.startDragBeforeDist = calculate(e.inverseBeforeMatrix, e.absoluteOrigin, z), e.startDragDist = calculate(e.inverseMatrix, e.absoluteOrigin, z);
}
function getTransformDirection(n) {
  return calculateMoveablePosition(n.datas.beforeTransform, [50, 50], 100, 100).direction;
}
function resolveTransformEvent(n, t) {
  var e = n.datas, o = n.originalDatas.beforeRenderable, R = e.transformIndex, N = o.nextTransforms, M = N.length, D = o.nextTransformAppendedIndexes, L = 0;
  R === -1 ? (L = N.length, e.transformIndex = L) : find$1(D, function(U) {
    return U.index === R && U.functionName === t;
  }) ? L = R : L = R + D.filter(function(U) {
    return U.index < R;
  }).length;
  var B = convertTransformInfo(N, L), $ = B.targetFunction, k = t === "rotate" ? "rotateZ" : t;
  e.beforeFunctionTexts = B.beforeFunctionTexts, e.afterFunctionTexts = B.afterFunctionTexts, e.beforeTransform = B.beforeFunctionMatrix, e.beforeTransform2 = B.beforeFunctionMatrix2, e.targetTansform = B.targetFunctionMatrix, e.afterTransform = B.afterFunctionMatrix, e.afterTransform2 = B.afterFunctionMatrix2, e.targetAllTransform = B.allFunctionMatrix, $.functionName === k ? (e.afterFunctionTexts.splice(0, 1), e.isAppendTransform = !1) : M > L && (e.isAppendTransform = !0, o.nextTransformAppendedIndexes = __spreadArray(__spreadArray([], D, !0), [{
    functionName: t,
    index: L,
    isAppend: !0
  }], !1));
}
function convertTransformFormat(n, t, e) {
  return "".concat(n.beforeFunctionTexts.join(" "), " ").concat(n.isAppendTransform ? e : t, " ").concat(n.afterFunctionTexts.join(" "));
}
function getTransformDist(n) {
  var t = n.datas, e = n.distX, o = n.distY, R = getBeforeDragDist({
    datas: t,
    distX: e,
    distY: o
  }), N = R[0], M = R[1], D = getTransfromMatrix(t, fromTranslation([N, M], 4));
  return calculate(D, convertPositionMatrix([0, 0, 0], 4), 4);
}
function getTransfromMatrix(n, t, e) {
  var o = n.beforeTransform, R = n.afterTransform, N = n.beforeTransform2, M = n.afterTransform2, D = n.targetAllTransform, L = e ? multiply(D, t, 4) : multiply(t, D, 4), B = multiply(invert(e ? N : o, 4), L, 4), $ = multiply(B, invert(e ? M : R, 4), 4);
  return $;
}
function getBeforeDragDist(n) {
  var t = n.datas, e = n.distX, o = n.distY, R = t.inverseBeforeMatrix, N = t.is3d, M = t.startDragBeforeDist, D = t.absoluteOrigin, L = N ? 4 : 3;
  return minus(calculate(R, plus(D, [e, o]), L), M);
}
function getDragDist(n, t) {
  var e = n.datas, o = n.distX, R = n.distY, N = e.inverseBeforeMatrix, M = e.inverseMatrix, D = e.is3d, L = e.startDragBeforeDist, B = e.startDragDist, $ = e.absoluteOrigin, k = D ? 4 : 3;
  return minus(calculate(t ? N : M, plus($, [o, R]), k), t ? L : B);
}
function getInverseDragDist(n, t) {
  var e = n.datas, o = n.distX, R = n.distY, N = e.beforeMatrix, M = e.matrix, D = e.is3d, L = e.startDragBeforeDist, B = e.startDragDist, $ = e.absoluteOrigin, k = D ? 4 : 3;
  return minus(calculate(t ? N : M, plus(t ? L : B, [o, R]), k), $);
}
function calculateTransformOrigin(n, t, e, o, R, N) {
  return o === void 0 && (o = t), R === void 0 && (R = e), N === void 0 && (N = [0, 0]), n ? n.map(function(M, D) {
    var L = splitUnit(M), B = L.value, $ = L.unit, k = D ? R : o, U = D ? e : t;
    if (M === "%" || isNaN(B)) {
      var z = k ? N[D] / k : 0;
      return U * z;
    } else if ($ !== "%")
      return B;
    return U * B / 100;
  }) : N;
}
function getPosIndexesByDirection(n) {
  var t = [];
  return n[1] >= 0 && (n[0] >= 0 && t.push(3), n[0] <= 0 && t.push(2)), n[1] <= 0 && (n[0] >= 0 && t.push(1), n[0] <= 0 && t.push(0)), t;
}
function getPosesByDirection(n, t) {
  return getPosIndexesByDirection(t).map(function(e) {
    return n[e];
  });
}
function getPosByDirection(n, t) {
  var e = (t[0] + 1) / 2, o = (t[1] + 1) / 2, R = [dot(n[0][0], n[1][0], e, 1 - e), dot(n[0][1], n[1][1], e, 1 - e)], N = [dot(n[2][0], n[3][0], e, 1 - e), dot(n[2][1], n[3][1], e, 1 - e)];
  return [dot(R[0], N[0], o, 1 - o), dot(R[1], N[1], o, 1 - o)];
}
function getDist(n, t, e, o, R, N) {
  var M = calculatePoses(t, e, o, R), D = getPosByDirection(M, N), L = n[0] - D[0], B = n[1] - D[1];
  return [L, B];
}
function getNextMatrix(n, t, e, o) {
  return multiply(n, getAbsoluteMatrix(t, o, e), o);
}
function getNextTransformMatrix(n, t, e) {
  var o = n.transformOrigin, R = n.offsetMatrix, N = n.is3d, M = t.beforeTransform, D = t.afterTransform, L = N ? 4 : 3, B = parseMat([e]);
  return getNextMatrix(R, convertDimension(multiply(multiply(M, B, 4), D, 4), 4, L), o, L);
}
function scaleMatrix(n, t) {
  var e = n.transformOrigin, o = n.offsetMatrix, R = n.is3d, N = n.targetMatrix, M = R ? 4 : 3;
  return getNextMatrix(o, multiply(N, createScaleMatrix(t, M), M), e, M);
}
function fillTransformStartEvent(n) {
  var t = getBeforeRenderableDatas(n);
  return {
    setTransform: function(e, o) {
      o === void 0 && (o = -1), t.startTransforms = isArray(e) ? e : splitSpace(e), setTransformIndex(n, o);
    },
    setTransformIndex: function(e) {
      setTransformIndex(n, e);
    }
  };
}
function setDefaultTransformIndex(n, t) {
  var e = getBeforeRenderableDatas(n), o = e.startTransforms;
  setTransformIndex(n, findIndex(o, function(R) {
    return R.indexOf("".concat(t, "(")) === 0;
  }));
}
function setTransformIndex(n, t) {
  var e = getBeforeRenderableDatas(n), o = n.datas;
  if (o.transformIndex = t, t !== -1) {
    var R = e.startTransforms[t];
    if (!!R) {
      var N = parse([R]);
      o.startValue = N[0].functionValue;
    }
  }
}
function fillOriginalTransform(n, t) {
  var e = getBeforeRenderableDatas(n);
  e.nextTransforms = splitSpace(t);
}
function getBeforeRenderableDatas(n) {
  return n.originalDatas.beforeRenderable;
}
function getNextTransforms(n) {
  var t = n.originalDatas.beforeRenderable;
  return t.nextTransforms;
}
function getNextTransformText(n) {
  return getNextTransforms(n).join(" ");
}
function getNextStyle(n) {
  return getBeforeRenderableDatas(n).nextStyle;
}
function fillTransformEvent(n, t, e, o, R) {
  fillOriginalTransform(R, t);
  var N = Draggable.drag(n, setCustomDrag(R, n.state, e, o, !1)), M = N ? N.transform : t;
  return __assign$2(__assign$2({
    transform: t,
    drag: N
  }, fillCSSObject({
    transform: M
  }, R)), {
    afterTransform: M
  });
}
function getTranslateDist(n, t, e, o, R) {
  var N = n.state, M = N.left, D = N.top, L = n.props.groupable, B = getNextTransformMatrix(n.state, R, t), $ = L ? M : 0, k = L ? D : 0, U = getDirectionOffset(n, e, B), z = minus(o, U);
  return minus(z, [$, k]);
}
function getScaleDist(n, t, e, o, R) {
  var N = getTranslateDist(n, "scale(".concat(t.join(", "), ")"), e, o, R);
  return N;
}
function getOriginDirection(n) {
  var t = n.state, e = t.width, o = t.height, R = t.transformOrigin;
  return [-1 + R[0] / (e / 2), -1 + R[1] / (o / 2)];
}
function getDirectionOffset(n, t, e) {
  e === void 0 && (e = n.state.allMatrix);
  var o = n.state, R = o.width, N = o.height, M = o.is3d, D = M ? 4 : 3, L = [R / 2 * (1 + t[0]), N / 2 * (1 + t[1])];
  return calculatePosition(e, L, D);
}
function getRotateDist(n, t, e) {
  var o = e.fixedDirection, R = e.fixedPosition;
  return getTranslateDist(n, "rotate(".concat(t, "deg)"), o, R, e);
}
function getResizeDist(n, t, e, o, R, N) {
  var M = n.props.groupable, D = n.state, L = D.transformOrigin, B = D.offsetMatrix, $ = D.is3d, k = D.width, U = D.height, z = D.left, X = D.top, V = N.fixedDirection, W = N.nextTargetMatrix || D.targetMatrix, Y = $ ? 4 : 3, q = calculateTransformOrigin(R, t, e, k, U, L), Z = M ? z : 0, J = M ? X : 0, Q = getNextMatrix(B, W, q, Y), K = getDist(o, Q, t, e, Y, V);
  return minus(K, [Z, J]);
}
function getAbsolutePosition(n, t) {
  return getPosByDirection(getAbsolutePosesByState(n.state), t);
}
function multiply2(n, t) {
  return [n[0] * t[0], n[1] * t[1]];
}
function prefix() {
  for (var n = [], t = 0; t < arguments.length; t++)
    n[t] = arguments[t];
  return prefixNames.apply(void 0, __spreadArray([PREFIX], n, !1));
}
function defaultSync(n) {
  n();
}
function getTransformMatrix(n) {
  return !n || n === "none" ? [1, 0, 0, 1, 0, 0] : isObject$2(n) ? n : parseMat(n);
}
function getAbsoluteMatrix(n, t, e) {
  return multiplies(t, createOriginMatrix(e, t), n, createOriginMatrix(e.map(function(o) {
    return -o;
  }), t));
}
function measureSVGSize(n, t, e) {
  if (t === "%") {
    var o = getSVGViewBox(n.ownerSVGElement);
    return o[e ? "width" : "height"] / 100;
  }
  return 1;
}
function getBeforeTransformOrigin(n) {
  var t = getTransformOrigin(getComputedStyle$1$1(n, ":before"));
  return t.map(function(e, o) {
    var R = splitUnit(e), N = R.value, M = R.unit;
    return N * measureSVGSize(n, M, o === 0);
  });
}
function getTransformOrigin(n) {
  var t = n.transformOrigin;
  return t ? t.split(" ") : ["0", "0"];
}
function getElementTransform(n, t) {
  t === void 0 && (t = getComputedStyle$1$1(n));
  var e = t.transform;
  if (e && e !== "none")
    return t.transform;
  if ("transform" in n) {
    var o = n.transform, R = o.baseVal;
    if (!R)
      return "";
    var N = R.length;
    if (!N)
      return "";
    for (var M = [], D = function(B) {
      var $ = R[B].matrix;
      M.push("matrix(".concat(["a", "b", "c", "d", "e", "f"].map(function(k) {
        return $[k];
      }).join(", "), ")"));
    }, L = 0; L < N; ++L)
      D(L);
    return M.join(" ");
  }
  return "";
}
function getOffsetInfo(n, t, e) {
  var o, R, N = document.body, M = !1, D, L;
  if (!n || e)
    D = n;
  else {
    var B = (o = n == null ? void 0 : n.assignedSlot) === null || o === void 0 ? void 0 : o.parentElement, $ = n.parentElement;
    B ? (M = !0, L = $, D = B) : D = $;
  }
  for (var k = !1, U = n === t || D === t, z = "relative"; D && D !== N; ) {
    t === D && (U = !0);
    var X = getComputedStyle$1$1(D), V = D.tagName.toLowerCase(), W = getElementTransform(D, X), Y = X.willChange;
    if (z = X.position, V === "svg" || z !== "static" || W && W !== "none" || Y === "transform")
      break;
    var q = (R = n == null ? void 0 : n.assignedSlot) === null || R === void 0 ? void 0 : R.parentNode, Z = D.parentNode;
    q && (M = !0, L = Z);
    var J = q || Z;
    if (J && J.nodeType === 11) {
      D = J.host, k = !0;
      break;
    }
    D = J, z = "relative";
  }
  return {
    hasSlot: M,
    parentSlotElement: L,
    isCustomElement: k,
    isStatic: z === "static",
    isEnd: U || !D || D === N,
    offsetParent: D || N
  };
}
function getOffsetPosInfo(n, t, e) {
  var o, R = n.tagName.toLowerCase(), N = n.offsetLeft, M = n.offsetTop, D = isUndefined(N), L = !D, B, $;
  return !L && R !== "svg" ? (B = IS_WEBKIT605 ? getBeforeTransformOrigin(n) : getTransformOrigin(e).map(function(k) {
    return parseFloat(k);
  }), $ = B.slice(), L = !0, o = getSVGGraphicsOffset(n, B, n === t && t.tagName.toLowerCase() === "g"), N = o[0], M = o[1], B[0] = o[2], B[1] = o[3]) : (B = getTransformOrigin(e).map(function(k) {
    return parseFloat(k);
  }), $ = B.slice()), {
    tagName: R,
    isSVG: D,
    hasOffset: L,
    offset: [N || 0, M || 0],
    origin: B,
    targetOrigin: $
  };
}
function getBodyOffset(n, t, e) {
  e === void 0 && (e = getComputedStyle$1$1(n));
  var o = getComputedStyle$1$1(document.body), R = o.position;
  if (!t && (!R || R === "static"))
    return [0, 0];
  var N = parseInt(o.marginLeft, 10), M = parseInt(o.marginTop, 10);
  return e.position === "absolute" && ((e.top !== "auto" || e.bottom !== "auto") && (M = 0), (e.left !== "auto" || e.right !== "auto") && (N = 0)), [N, M];
}
function convert3DMatrixes(n) {
  n.forEach(function(t) {
    var e = t.matrix;
    e && (t.matrix = convertDimension(e, 3, 4));
  });
}
function getBodyScrollPos() {
  return [document.documentElement.scrollLeft || document.body.scrollLeft, document.documentElement.scrollTop || document.body.scrollTop];
}
function getPositionFixedInfo(n) {
  for (var t = n.parentElement, e = !1; t; ) {
    var o = getComputedStyle$1$1(t).transform;
    if (o && o !== "none") {
      e = !0;
      break;
    }
    if (t === document.body)
      break;
    t = t.parentElement;
  }
  return {
    fixedContainer: t || document.body,
    hasTransform: e
  };
}
function makeMatrixCSS(n, t) {
  return t === void 0 && (t = n.length > 9), "".concat(t ? "matrix3d" : "matrix", "(").concat(convertMatrixtoCSS(n, !t).join(","), ")");
}
function getSVGViewBox(n) {
  var t = n.clientWidth, e = n.clientHeight;
  if (!n)
    return {
      x: 0,
      y: 0,
      width: 0,
      height: 0,
      clientWidth: t,
      clientHeight: e
    };
  var o = n.viewBox, R = o && o.baseVal || {
    x: 0,
    y: 0,
    width: 0,
    height: 0
  };
  return {
    x: R.x,
    y: R.y,
    width: R.width || t,
    height: R.height || e,
    clientWidth: t,
    clientHeight: e
  };
}
function getSVGMatrix(n, t) {
  var e = getSVGViewBox(n), o = e.width, R = e.height, N = e.clientWidth, M = e.clientHeight, D = N / o, L = M / R, B = n.preserveAspectRatio.baseVal, $ = B.align, k = B.meetOrSlice, U = [0, 0], z = [D, L], X = [0, 0];
  if ($ !== 1) {
    var V = ($ - 2) % 3, W = Math.floor(($ - 2) / 3);
    U[0] = o * V / 2, U[1] = R * W / 2;
    var Y = k === 2 ? Math.max(L, D) : Math.min(D, L);
    z[0] = Y, z[1] = Y, X[0] = (N - o) / 2 * V, X[1] = (M - R) / 2 * W;
  }
  var q = createScaleMatrix(z, t);
  return q[t * (t - 1)] = X[0], q[t * (t - 1) + 1] = X[1], getAbsoluteMatrix(q, t, U);
}
function getSVGGraphicsOffset(n, t, e) {
  if (!n.getBBox || !e && n.tagName.toLowerCase() === "g")
    return [0, 0, 0, 0];
  var o = n.getBBox(), R = getSVGViewBox(n.ownerSVGElement), N = o.x - R.x, M = o.y - R.y;
  return [N, M, t[0] - N, t[1] - M];
}
function calculatePosition(n, t, e) {
  return calculate(n, convertPositionMatrix(t, e), e);
}
function calculatePoses(n, t, e, o) {
  return [[0, 0], [t, 0], [0, e], [t, e]].map(function(R) {
    return calculatePosition(n, R, o);
  });
}
function getRect(n) {
  var t = n.map(function(B) {
    return B[0];
  }), e = n.map(function(B) {
    return B[1];
  }), o = Math.min.apply(Math, t), R = Math.min.apply(Math, e), N = Math.max.apply(Math, t), M = Math.max.apply(Math, e), D = N - o, L = M - R;
  return {
    left: o,
    top: R,
    right: N,
    bottom: M,
    width: D,
    height: L
  };
}
function calculateRect(n, t, e, o) {
  var R = calculatePoses(n, t, e, o);
  return getRect(R);
}
function getSVGOffset(n, t, e, o, R) {
  var N, M = n.target, D = n.origin, L = t.matrix, B = getSize(M), $ = B.offsetWidth, k = B.offsetHeight, U = e.getBoundingClientRect(), z = [0, 0];
  e === document.body && (z = getBodyOffset(M, !0));
  for (var X = M.getBoundingClientRect(), V = X.left - U.left + e.scrollLeft - (e.clientLeft || 0) + z[0], W = X.top - U.top + e.scrollTop - (e.clientTop || 0) + z[1], Y = X.width, q = X.height, Z = multiplies(o, R, L), J = calculateRect(Z, $, k, o), Q = J.left, K = J.top, rt = J.width, tt = J.height, nt = calculatePosition(Z, D, o), at = minus(nt, [Q, K]), lt = [V + at[0] * Y / rt, W + at[1] * q / tt], ut = [0, 0], dt = 0; ++dt < 10; ) {
    var yt = invert(R, o);
    N = minus(calculatePosition(yt, lt, o), calculatePosition(yt, nt, o)), ut[0] = N[0], ut[1] = N[1];
    var pt = multiplies(o, R, createOriginMatrix(ut, o), L), gt = calculateRect(pt, $, k, o), xt = gt.left, Lt = gt.top, mt = xt - V, ct = Lt - W;
    if (Math.abs(mt) < 2 && Math.abs(ct) < 2)
      break;
    lt[0] -= mt, lt[1] -= ct;
  }
  return ut.map(function(vt) {
    return Math.round(vt);
  });
}
function calculateMoveableClientPositions(n, t, e) {
  var o = n.length === 16, R = o ? 4 : 3, N = t.map(function(L) {
    return calculatePosition(n, L, R);
  }), M = e.left, D = e.top;
  return N.map(function(L) {
    return [L[0] + M, L[1] + D];
  });
}
function calculateMoveablePosition(n, t, e, o) {
  var R = n.length === 16, N = R ? 4 : 3, M = calculatePoses(n, e, o, N), D = M[0], L = D[0], B = D[1], $ = M[1], k = $[0], U = $[1], z = M[2], X = z[0], V = z[1], W = M[3], Y = W[0], q = W[1], Z = calculatePosition(n, t, N), J = Z[0], Q = Z[1], K = Math.min(L, k, X, Y), rt = Math.min(B, U, V, q), tt = Math.max(L, k, X, Y), nt = Math.max(B, U, V, q);
  L = L - K || 0, k = k - K || 0, X = X - K || 0, Y = Y - K || 0, B = B - rt || 0, U = U - rt || 0, V = V - rt || 0, q = q - rt || 0, J = J - K || 0, Q = Q - rt || 0;
  var at = getShapeDirection(M);
  return {
    left: K,
    top: rt,
    right: tt,
    bottom: nt,
    origin: [J, Q],
    pos1: [L, B],
    pos2: [k, U],
    pos3: [X, V],
    pos4: [Y, q],
    direction: at
  };
}
function getDistSize(n) {
  return Math.sqrt(n[0] * n[0] + n[1] * n[1]);
}
function getDiagonalSize(n, t) {
  return getDistSize([t[0] - n[0], t[1] - n[1]]);
}
function getLineStyle(n, t, e, o) {
  e === void 0 && (e = 1), o === void 0 && (o = getRad$1(n, t));
  var R = getDiagonalSize(n, t);
  return {
    transform: "translateY(-50%) translate(".concat(n[0], "px, ").concat(n[1], "px) rotate(").concat(o, "rad) scaleY(").concat(e, ")"),
    width: "".concat(R, "px")
  };
}
function getControlTransform(n, t) {
  for (var e = [], o = 2; o < arguments.length; o++)
    e[o - 2] = arguments[o];
  var R = e.length, N = e.reduce(function(D, L) {
    return D + L[0];
  }, 0) / R, M = e.reduce(function(D, L) {
    return D + L[1];
  }, 0) / R;
  return {
    transform: "translateZ(0px) translate(".concat(N, "px, ").concat(M, "px) rotate(").concat(n, "rad) scale(").concat(t, ")")
  };
}
function getProps(n, t) {
  var e = n[t];
  return isObject$2(e) ? __assign$2(__assign$2({}, n), e) : n;
}
function getSize(n, t) {
  t === void 0 && (t = n ? getComputedStyle$1$1(n) : null);
  var e = n && !isUndefined(n.offsetWidth), o = 0, R = 0, N = 0, M = 0, D = 0, L = 0, B = 0, $ = 0, k = 0, U = 0, z = 0, X = 0, V = 1 / 0, W = 1 / 0, Y = 1 / 0, q = 1 / 0, Z = !1;
  if (n)
    if (!e && n.tagName.toLowerCase() !== "svg") {
      var J = n.getBBox();
      Z = !0, o = J.width, R = J.height, D = o, L = R, B = o, $ = R, N = o, M = R;
    } else {
      var Q = n.style, K = t.boxSizing === "border-box", rt = parseFloat(t.borderLeftWidth) || 0, tt = parseFloat(t.borderRightWidth) || 0, nt = parseFloat(t.borderTopWidth) || 0, at = parseFloat(t.borderBottomWidth) || 0, lt = parseFloat(t.paddingLeft) || 0, ut = parseFloat(t.paddingRight) || 0, dt = parseFloat(t.paddingTop) || 0, yt = parseFloat(t.paddingBottom) || 0, pt = lt + ut, gt = dt + yt, xt = rt + tt, Lt = nt + at, mt = pt + xt, ct = gt + Lt;
      k = Math.max(pt, convertUnitSize(t.minWidth, 0) || 0), U = Math.max(gt, convertUnitSize(t.minHeight, 0) || 0), V = convertUnitSize(t.maxWidth, 0), W = convertUnitSize(t.maxHeight, 0), isNaN(V) && (V = 1 / 0, W = 1 / 0);
      var vt = convertUnitSize(Q.width, 0) || 0, Tt = convertUnitSize(Q.height, 0) || 0, Pt = parseFloat(t.width) || 0, wt = parseFloat(t.height) || 0;
      D = parseFloat(t.width), L = parseFloat(t.height), B = Math.abs(Pt - vt) < 1 ? between(k, vt || D, V) : Pt, $ = Math.abs(wt - Tt) < 1 ? between(U, Tt || L, W) : wt, o = B, R = $, N = B, M = $, K ? (Y = V, q = W, z = k, X = U, B = o - mt, $ = R - ct) : (Y = V + mt, q = W + ct, z = k + mt, X = U + ct, o = B + mt, R = $ + ct), N = B + pt, M = $ + gt;
    }
  return {
    svg: Z,
    offsetWidth: o,
    offsetHeight: R,
    clientWidth: N,
    clientHeight: M,
    contentWidth: B,
    contentHeight: $,
    cssWidth: D,
    cssHeight: L,
    minWidth: k,
    minHeight: U,
    maxWidth: V,
    maxHeight: W,
    minOffsetWidth: z,
    minOffsetHeight: X,
    maxOffsetWidth: Y,
    maxOffsetHeight: q
  };
}
function getRotationRad(n, t) {
  return getRad$1(t > 0 ? n[0] : n[1], t > 0 ? n[1] : n[0]);
}
function resetClientRect() {
  return {
    left: 0,
    top: 0,
    width: 0,
    height: 0,
    right: 0,
    bottom: 0,
    clientLeft: 0,
    clientTop: 0,
    clientWidth: 0,
    clientHeight: 0,
    scrollWidth: 0,
    scrollHeight: 0
  };
}
function getClientRect(n, t) {
  var e, o = 0, R = 0, N = 0, M = 0;
  if (n)
    if (n === document.body || n === document.documentElement) {
      N = window.innerWidth, M = window.innerHeight;
      var D = getBodyScrollPos();
      e = [-D[0], -D[1]], o = e[0], R = e[1];
    } else {
      var L = n.getBoundingClientRect();
      o = L.left, R = L.top, N = L.width, M = L.height;
    }
  var B = {
    left: o,
    top: R,
    width: N,
    height: M,
    right: o + N,
    bottom: R + M
  };
  return n && t && (B.clientLeft = n.clientLeft, B.clientTop = n.clientTop, B.clientWidth = n.clientWidth, B.clientHeight = n.clientHeight, B.scrollWidth = n.scrollWidth, B.scrollHeight = n.scrollHeight, B.overflow = getComputedStyle$1$1(n).overflow !== "visible"), B;
}
function getDirection(n) {
  if (!!n) {
    var t = n.getAttribute("data-direction");
    if (!!t) {
      var e = [0, 0];
      return t.indexOf("w") > -1 && (e[0] = -1), t.indexOf("e") > -1 && (e[0] = 1), t.indexOf("n") > -1 && (e[1] = -1), t.indexOf("s") > -1 && (e[1] = 1), e;
    }
  }
}
function getAbsolutePoses(n, t) {
  return [plus(t, n[0]), plus(t, n[1]), plus(t, n[2]), plus(t, n[3])];
}
function getAbsolutePosesByState(n) {
  var t = n.left, e = n.top, o = n.pos1, R = n.pos2, N = n.pos3, M = n.pos4;
  return getAbsolutePoses([o, R, N, M], [t, e]);
}
function roundSign(n) {
  return Math.round(n % 1 === -0.5 ? n - 1 : n);
}
function unset(n, t) {
  var e;
  (e = n[t]) === null || e === void 0 || e.unset(), n[t] = null;
}
function fillCSSObject(n, t) {
  if (t) {
    var e = getBeforeRenderableDatas(t);
    e.nextStyle = __assign$2(__assign$2({}, e.nextStyle), n);
  }
  return {
    style: n,
    cssText: getKeys(n).map(function(o) {
      return "".concat(o, ": ").concat(n[o], ";");
    }).join("")
  };
}
function fillAfterTransform(n, t, e) {
  var o = t.afterTransform || t.transform;
  return __assign$2(__assign$2({}, fillCSSObject(__assign$2(__assign$2(__assign$2({}, n.style), t.style), {
    transform: o
  }), e)), {
    afterTransform: o,
    transform: n.transform
  });
}
function fillParams(n, t, e, o) {
  var R = t.datas;
  R.datas || (R.datas = {});
  var N = __assign$2(__assign$2({}, e), {
    target: n.state.target,
    clientX: t.clientX,
    clientY: t.clientY,
    inputEvent: t.inputEvent,
    currentTarget: n,
    moveable: n,
    datas: R.datas,
    stopDrag: function() {
      var M;
      (M = t.stop) === null || M === void 0 || M.call(t);
    }
  });
  return R.isStartEvent ? o || (R.lastEvent = N) : R.isStartEvent = !0, N;
}
function fillEndParams(n, t, e) {
  var o = t.datas, R = "isDrag" in e ? e.isDrag : t.isDrag;
  return o.datas || (o.datas = {}), __assign$2(__assign$2({
    isDrag: R
  }, e), {
    moveable: n,
    target: n.state.target,
    clientX: t.clientX,
    clientY: t.clientY,
    inputEvent: t.inputEvent,
    currentTarget: n,
    lastEvent: o.lastEvent,
    isDouble: t.isDouble,
    datas: o.datas
  });
}
function catchEvent(n, t, e) {
  n._emitter.on(t, e);
}
function triggerEvent(n, t, e, o) {
  return n.triggerEvent(t, e, o);
}
function getComputedStyle$1$1(n, t) {
  return window.getComputedStyle(n, t);
}
function filterAbles(n, t, e) {
  var o = {}, R = {};
  return n.filter(function(N) {
    var M = N.name;
    if (o[M] || !t.some(function(D) {
      return N[D];
    }))
      return !1;
    if (!e && N.ableGroup) {
      if (R[N.ableGroup])
        return !1;
      R[N.ableGroup] = !0;
    }
    return o[M] = !0, !0;
  });
}
function equals(n, t) {
  return n === t || n == null && t == null;
}
function selectValue() {
  for (var n = [], t = 0; t < arguments.length; t++)
    n[t] = arguments[t];
  for (var e = n.length - 1, o = 0; o < e; ++o) {
    var R = n[o];
    if (!isUndefined(R))
      return R;
  }
  return n[e];
}
function groupBy(n, t) {
  var e = [], o = [];
  return n.forEach(function(R, N) {
    var M = t(R, N, n), D = o.indexOf(M), L = e[D] || [];
    D === -1 && (o.push(M), e.push(L)), L.push(R);
  }), e;
}
function groupByMap(n, t) {
  var e = [], o = {};
  return n.forEach(function(R, N) {
    var M = t(R, N, n), D = o[M];
    D || (D = [], o[M] = D, e.push(D)), D.push(R);
  }), e;
}
function flat(n) {
  return n.reduce(function(t, e) {
    return t.concat(e);
  }, []);
}
function maxOffset() {
  for (var n = [], t = 0; t < arguments.length; t++)
    n[t] = arguments[t];
  return n.sort(function(e, o) {
    return Math.abs(o) - Math.abs(e);
  }), n[0];
}
function calculateInversePosition(n, t, e) {
  return calculate(invert(n, e), convertPositionMatrix(t, e), e);
}
function convertDragDist(n, t) {
  var e, o = n.is3d, R = n.rootMatrix, N = o ? 4 : 3;
  return e = calculateInversePosition(R, [t.distX, t.distY], N), t.distX = e[0], t.distY = e[1], t;
}
function calculatePadding(n, t, e, o, R) {
  return minus(calculatePosition(n, plus(e, t), R), o);
}
function convertCSSSize(n, t, e) {
  return e ? "".concat(n / t * 100, "%") : "".concat(n, "px");
}
function getTinyDist(n) {
  return Math.abs(n) <= TINY_NUM ? 0 : n;
}
function getDirectionCondition(n, t) {
  return t === void 0 && (t = [n]), function(e, o) {
    if (o.isRequest)
      return t.some(function(N) {
        return o.requestAble === N;
      }) ? o.parentDirection : !1;
    var R = o.inputEvent.target;
    return hasClass(R, prefix("direction")) && (!n || hasClass(R, prefix(n)));
  };
}
function invertObject(n) {
  var t = {};
  for (var e in n)
    t[n[e]] = e;
  return t;
}
function convertTransformInfo(n, t) {
  var e = n.slice(0, t < 0 ? void 0 : t), o = n.slice(0, t < 0 ? void 0 : t + 1), R = n[t] || "", N = t < 0 ? [] : n.slice(t), M = t < 0 ? [] : n.slice(t + 1), D = parse(e), L = parse(o), B = parse([R]), $ = parse(N), k = parse(M), U = toMat(D), z = toMat(L), X = toMat($), V = toMat(k), W = multiply(U, X, 4);
  return {
    transforms: n,
    beforeFunctionMatrix: U,
    beforeFunctionMatrix2: z,
    targetFunctionMatrix: toMat(B),
    afterFunctionMatrix: X,
    afterFunctionMatrix2: V,
    allFunctionMatrix: W,
    beforeFunctions: D,
    beforeFunctions2: L,
    targetFunction: B[0],
    afterFunctions: $,
    afterFunctions2: k,
    beforeFunctionTexts: e,
    beforeFunctionTexts2: o,
    targetFunctionText: R,
    afterFunctionTexts: N,
    afterFunctionTexts2: M
  };
}
function isArrayFormat(n) {
  return !n || !isObject$2(n) || n instanceof Element ? !1 : isArray(n) || "length" in n;
}
function getRefTarget(n, t) {
  return n ? n instanceof Element ? n : isString$1(n) ? t ? document.querySelector(n) : n : isFunction$3(n) ? n() : "current" in n ? n.current : n : null;
}
function getRefTargets(n, t) {
  if (!n)
    return [];
  var e = isArrayFormat(n) ? [].slice.call(n) : [n];
  return e.reduce(function(o, R) {
    return isString$1(R) && t ? __spreadArray(__spreadArray([], o, !0), [].slice.call(document.querySelectorAll(R)), !0) : (o.push(getRefTarget(R, t)), o);
  }, []);
}
function getElementTargets(n, t) {
  var e = [];
  return n.forEach(function(o) {
    if (!!o) {
      if (isString$1(o)) {
        t[o] && e.push.apply(e, t[o]);
        return;
      }
      e.push(o);
    }
  }), e;
}
function getAbsoluteRotation(n, t, e) {
  var o = getRad$1(n, t) / Math.PI * 180;
  return o = e >= 0 ? o : 180 - o, o = o >= 0 ? o : 360 + o, o;
}
function getDragDistByState(n, t) {
  var e = n.rootMatrix, o = n.is3d, R = o ? 4 : 3, N = invert(e, R);
  return o || (N = convertDimension(N, 3, 4)), N[12] = 0, N[13] = 0, N[14] = 0, calculateMatrixDist(N, t);
}
function getSizeDistByDist(n, t, e, o, R) {
  var N = n[0], M = n[1], D = 0, L = 0;
  if (R && N && M) {
    var B = getRad$1([0, 0], t), $ = getRad$1([0, 0], o), k = getDistSize(t), U = Math.cos(B - $) * k;
    if (!o[0])
      L = U, D = L * e;
    else if (!o[1])
      D = U, L = D / e;
    else {
      var z = o[0] * 2 * N, X = o[1] * 2 * M, V = getDistSize([z + t[0], X + t[1]]) - getDistSize([z, X]), W = getRad$1([0, 0], [e, 1]);
      D = Math.cos(W) * V, L = Math.sin(W) * V;
    }
  } else
    D = o[0] * t[0], L = o[1] * t[1];
  return [D, L];
}
function getOffsetSizeDist(n, t, e, o) {
  var R, N = e.ratio, M = e.startOffsetWidth, D = e.startOffsetHeight, L = 0, B = 0, $ = o.distX, k = o.distY, U = o.parentDistance, z = o.parentDist, X = o.parentScale, V = e.fixedDirection, W = [0, 1].map(function(K) {
    return Math.abs(n[K] - V[K]);
  }), Y = [0, 1].map(function(K) {
    var rt = W[K];
    return rt !== 0 && (rt = 2 / rt), rt;
  });
  if (z)
    L = z[0], B = z[1], t && (L ? B || (B = L / N) : L = B * N);
  else if (X)
    L = (X[0] - 1) * M, B = (X[1] - 1) * D;
  else if (U) {
    var q = M * W[0], Z = D * W[1], J = getDistSize([q, Z]);
    L = U / J * q * Y[0], B = U / J * Z * Y[1];
  } else {
    var Q = getDragDist({
      datas: e,
      distX: $,
      distY: k
    });
    Q = Y.map(function(K, rt) {
      return Q[rt] * K;
    }), R = getSizeDistByDist([M, D], Q, N, n, t), L = R[0], B = R[1];
  }
  return {
    distWidth: L,
    distHeight: B
  };
}
var Pinchable = makeAble("pinchable", {
  events: {
    onPinchStart: "pinchStart",
    onPinch: "pinch",
    onPinchEnd: "pinchEnd",
    onPinchGroupStart: "pinchGroupStart",
    onPinchGroup: "pinchGroup",
    onPinchGroupEnd: "pinchGroupEnd"
  },
  dragStart: function() {
    return !0;
  },
  pinchStart: function(n, t) {
    var e = t.datas, o = t.targets, R = t.angle, N = t.originalDatas, M = n.props, D = M.pinchable, L = M.ables;
    if (!D)
      return !1;
    var B = "onPinch".concat(o ? "Group" : "", "Start"), $ = "drag".concat(o ? "Group" : "", "ControlStart"), k = (D === !0 ? n.controlAbles : L.filter(function(V) {
      return D.indexOf(V.name) > -1;
    })).filter(function(V) {
      return V.canPinch && V[$];
    }), U = fillParams(n, t, {});
    o && (U.targets = o);
    var z = triggerEvent(n, B, U);
    e.isPinch = z !== !1, e.ables = k;
    var X = e.isPinch;
    return X ? (k.forEach(function(V) {
      if (N[V.name] = N[V.name] || {}, !!V[$]) {
        var W = __assign$2(__assign$2({}, t), {
          datas: N[V.name],
          parentRotate: R,
          isPinch: !0
        });
        V[$](n, W);
      }
    }), n.state.snapRenderInfo = {
      request: t.isRequest,
      direction: [0, 0]
    }, X) : !1;
  },
  pinch: function(n, t) {
    var e = t.datas, o = t.scale, R = t.distance, N = t.originalDatas, M = t.inputEvent, D = t.targets, L = t.angle;
    if (!!e.isPinch) {
      var B = R * (1 - 1 / o), $ = fillParams(n, t, {});
      D && ($.targets = D);
      var k = "onPinch".concat(D ? "Group" : "");
      triggerEvent(n, k, $);
      var U = e.ables, z = "drag".concat(D ? "Group" : "", "Control");
      return U.forEach(function(X) {
        !X[z] || X[z](n, __assign$2(__assign$2({}, t), {
          datas: N[X.name],
          inputEvent: M,
          parentDistance: B,
          parentRotate: L,
          isPinch: !0
        }));
      }), $;
    }
  },
  pinchEnd: function(n, t) {
    var e = t.datas, o = t.isPinch, R = t.inputEvent, N = t.targets, M = t.originalDatas;
    if (!!e.isPinch) {
      var D = "onPinch".concat(N ? "Group" : "", "End"), L = fillEndParams(n, t, {
        isDrag: o
      });
      N && (L.targets = N), triggerEvent(n, D, L);
      var B = e.ables, $ = "drag".concat(N ? "Group" : "", "ControlEnd");
      return B.forEach(function(k) {
        !k[$] || k[$](n, __assign$2(__assign$2({}, t), {
          isDrag: o,
          datas: M[k.name],
          inputEvent: R,
          isPinch: !0
        }));
      }), o;
    }
  },
  pinchGroupStart: function(n, t) {
    return this.pinchStart(n, __assign$2(__assign$2({}, t), {
      targets: n.props.targets
    }));
  },
  pinchGroup: function(n, t) {
    return this.pinch(n, __assign$2(__assign$2({}, t), {
      targets: n.props.targets
    }));
  },
  pinchGroupEnd: function(n, t) {
    return this.pinchEnd(n, __assign$2(__assign$2({}, t), {
      targets: n.props.targets
    }));
  }
});
function fillChildEvents(n, t, e) {
  var o = e.originalDatas;
  o.groupable = o.groupable || {};
  var R = o.groupable;
  R.childDatas = R.childDatas || [];
  var N = R.childDatas;
  return n.moveables.map(function(M, D) {
    return N[D] = N[D] || {}, N[D][t] = N[D][t] || {}, __assign$2(__assign$2({}, e), {
      datas: N[D][t],
      originalDatas: N[D]
    });
  });
}
function triggerChildGesto(n, t, e, o, R, N, M) {
  var D = !!e.match(/Start$/g), L = !!e.match(/End$/g), B = R.isPinch, $ = R.datas, k = fillChildEvents(n, t.name, R), U = n.moveables, z = k.map(function(X, V) {
    var W = U[V], Y = W.state, q = Y.gestos, Z = X;
    if (D)
      Z = new CustomGesto(M).dragStart(o, X);
    else {
      if (q[M] || (q[M] = $.childGestos[V]), !q[M])
        return;
      Z = setCustomDrag(X, Y, o, B, N, M);
    }
    var J = t[e](W, __assign$2(__assign$2({}, Z), {
      parentFlag: !0
    }));
    return L && (q[M] = null), J;
  });
  return D && ($.childGestos = U.map(function(X) {
    return X.state.gestos[M];
  })), z;
}
function triggerChildAbles(n, t, e, o, R, N) {
  R === void 0 && (R = function($, k) {
    return k;
  });
  var M = !!e.match(/End$/g), D = fillChildEvents(n, t.name, o), L = n.moveables, B = D.map(function($, k) {
    var U = L[k], z = $;
    z = R(U, $);
    var X = t[e](U, __assign$2(__assign$2({}, z), {
      parentFlag: !0
    }));
    return X && N && N(U, $, X, k), M && (U.state.gestos = {}), X;
  });
  return B;
}
var VERTICAL_NAMES = ["left", "right", "center"], HORIZONTAL_NAMES = ["top", "bottom", "middle"], VERTICAL_NAMES_MAP = {
  start: "left",
  end: "right",
  center: "center"
}, HORIZONTAL_NAMES_MAP = {
  start: "top",
  end: "bottom",
  center: "middle"
};
function hasGuidelines(n, t) {
  var e = n.props, o = e.snappable, R = e.bounds, N = e.innerBounds, M = e.verticalGuidelines, D = e.horizontalGuidelines, L = e.snapGridWidth, B = e.snapGridHeight, $ = n.state, k = $.guidelines, U = $.enableSnap;
  return !o || !U || t && o !== !0 && o.indexOf(t) < 0 ? !1 : !!(L || B || R || N || k && k.length || M && M.length || D && D.length);
}
function getSnapDirections(n) {
  return n === !1 ? {} : n === !0 || !n ? {
    left: !0,
    right: !0,
    top: !0,
    bottom: !0
  } : n;
}
function mapSnapDirectionPoses(n, t) {
  var e = getSnapDirections(n), o = {};
  for (var R in e)
    R in t && e[R] && (o[R] = t[R]);
  return o;
}
function splitSnapDirectionPoses(n, t) {
  var e = mapSnapDirectionPoses(n, t), o = HORIZONTAL_NAMES.filter(function(N) {
    return N in e;
  }), R = VERTICAL_NAMES.filter(function(N) {
    return N in e;
  });
  return {
    horizontal: o.map(function(N) {
      return e[N];
    }),
    vertical: R.map(function(N) {
      return e[N];
    })
  };
}
function calculateContainerPos(n, t, e) {
  var o = calculatePosition(n, [t.clientLeft, t.clientTop], e);
  return [t.left + o[0], t.top + o[1]];
}
function solveLineConstants(n) {
  var t = n[0], e = n[1], o = e[0] - t[0], R = e[1] - t[1];
  Math.abs(o) < TINY_NUM$1 && (o = 0), Math.abs(R) < TINY_NUM$1 && (R = 0);
  var N = 0, M = 0, D = 0;
  return o ? R ? (N = -R / o, M = 1, D = N * t[0] - t[1]) : (M = 1, D = -t[1]) : (N = -1, D = t[0]), [N, M, D].map(function(L) {
    return throttle(L, TINY_NUM$1);
  });
}
function checkMoveableSnapPoses(n, t, e, o) {
  var R = n.props, N = selectValue(o, R.snapThreshold, 5);
  return checkSnapPoses(n.state.guidelines, t, e, N);
}
function checkSnapPoses(n, t, e, o) {
  return {
    vertical: checkSnap(n, "vertical", t, o),
    horizontal: checkSnap(n, "horizontal", e, o)
  };
}
function checkSnapKeepRatio(n, t, e) {
  var o = e[0], R = e[1], N = t[0], M = t[1], D = minus(e, t), L = D[0], B = D[1], $ = B > 0, k = L > 0;
  L = getTinyDist(L), B = getTinyDist(B);
  var U = {
    isSnap: !1,
    offset: 0,
    pos: 0
  }, z = {
    isSnap: !1,
    offset: 0,
    pos: 0
  };
  if (L === 0 && B === 0)
    return {
      vertical: U,
      horizontal: z
    };
  var X = checkMoveableSnapPoses(n, L ? [o] : [], B ? [R] : []), V = X.vertical, W = X.horizontal;
  V.posInfos.filter(function(yt) {
    var pt = yt.pos;
    return k ? pt >= N : pt <= N;
  }), W.posInfos.filter(function(yt) {
    var pt = yt.pos;
    return $ ? pt >= M : pt <= M;
  }), V.isSnap = V.posInfos.length > 0, W.isSnap = W.posInfos.length > 0;
  var Y = getNearestSnapGuidelineInfo(V), q = Y.isSnap, Z = Y.guideline, J = getNearestSnapGuidelineInfo(W), Q = J.isSnap, K = J.guideline, rt = Q ? K.pos[1] : 0, tt = q ? Z.pos[0] : 0;
  if (L === 0)
    Q && (z.isSnap = !0, z.pos = K.pos[1], z.offset = R - z.pos);
  else if (B === 0)
    q && (U.isSnap = !0, U.pos = tt, U.offset = o - tt);
  else {
    var nt = B / L, at = e[1] - nt * o, lt = 0, ut = 0, dt = !1;
    q ? (ut = tt, lt = nt * ut + at, dt = !0) : Q && (lt = rt, ut = (lt - at) / nt, dt = !0), dt && (U.isSnap = !0, U.pos = ut, U.offset = o - ut, z.isSnap = !0, z.pos = lt, z.offset = R - lt);
  }
  return {
    vertical: U,
    horizontal: z
  };
}
function checkSnaps(n, t, e) {
  var o = splitSnapDirectionPoses(n.props.snapDirections, t);
  return checkMoveableSnapPoses(n, o.vertical, o.horizontal, e);
}
function getNearestSnapGuidelineInfo(n) {
  var t = n.isSnap;
  if (!t)
    return {
      isSnap: !1,
      offset: 0,
      dist: -1,
      pos: 0,
      guideline: null
    };
  var e = n.posInfos[0], o = e.guidelineInfos[0], R = o.offset, N = o.dist, M = o.guideline;
  return {
    isSnap: t,
    offset: R,
    dist: N,
    pos: e.pos,
    guideline: M
  };
}
function checkSnap(n, t, e, o) {
  if (!n || !n.length)
    return {
      isSnap: !1,
      index: -1,
      posInfos: []
    };
  var R = t === "vertical", N = R ? 0 : 1, M = e.map(function(L, B) {
    var $ = n.map(function(k) {
      var U = k.pos, z = L - U[N];
      return {
        offset: z,
        dist: Math.abs(z),
        guideline: k
      };
    }).filter(function(k) {
      var U = k.guideline, z = k.dist, X = U.type;
      return !(X !== t || z > o);
    }).sort(function(k, U) {
      return k.dist - U.dist;
    });
    return {
      pos: L,
      index: B,
      guidelineInfos: $
    };
  }).filter(function(L) {
    return L.guidelineInfos.length > 0;
  }).sort(function(L, B) {
    return L.guidelineInfos[0].dist - B.guidelineInfos[0].dist;
  }), D = M.length > 0;
  return {
    isSnap: D,
    index: D ? M[0].index : -1,
    posInfos: M
  };
}
function getSnapInfosByDirection(n, t, e) {
  var o = [];
  if (e[0] && e[1])
    o = [e, [-e[0], e[1]], [e[0], -e[1]]].map(function(M) {
      return getPosByDirection(t, M);
    });
  else if (!e[0] && !e[1])
    for (var R = [t[0], t[1], t[3], t[2], t[0]], N = 0; N < 4; ++N)
      o.push(R[N]), o.push([(R[N][0] + R[N + 1][0]) / 2, (R[N][1] + R[N + 1][1]) / 2]);
  else
    n.props.keepRatio ? o = [[-1, -1], [-1, 1], [1, -1], [1, 1], e].map(function(M) {
      return getPosByDirection(t, M);
    }) : (o = getPosesByDirection(t, e), o.length > 1 && o.push([(o[0][0] + o[1][0]) / 2, (o[0][1] + o[1][1]) / 2]));
  return checkMoveableSnapPoses(n, o.map(function(M) {
    return M[0];
  }), o.map(function(M) {
    return M[1];
  }), 1);
}
function checkSnapBoundPriority(n, t) {
  var e = Math.abs(n.offset), o = Math.abs(t.offset);
  return n.isBound && t.isBound ? o - e : n.isBound ? -1 : t.isBound ? 1 : n.isSnap && t.isSnap ? o - e : n.isSnap ? -1 : t.isSnap || e < TINY_NUM ? 1 : o < TINY_NUM ? -1 : e - o;
}
function getNearOffsetInfo(n, t) {
  return n.slice().sort(function(e, o) {
    var R = e.sign[t], N = o.sign[t], M = e.offset[t], D = o.offset[t];
    if (R) {
      if (!N)
        return -1;
    } else
      return 1;
    return checkSnapBoundPriority({
      isBound: e.isBound,
      isSnap: e.isSnap,
      offset: M
    }, {
      isBound: o.isBound,
      isSnap: o.isSnap,
      offset: D
    });
  })[0];
}
function getCheckSnapDirections(n, t, e) {
  var o = [];
  if (e)
    Math.abs(t[0]) !== 1 || Math.abs(t[1]) !== 1 ? o.push([t, [-1, -1]], [t, [-1, 1]], [t, [1, -1]], [t, [1, 1]]) : o.push([t, [n[0], -n[1]]], [t, [-n[0], n[1]]]), o.push([t, n]);
  else if (n[0] && n[1] || !n[0] && !n[1]) {
    var R = n[0] ? n : [1, 1];
    [1, -1].forEach(function(M) {
      [1, -1].forEach(function(D) {
        var L = [M * R[0], D * R[1]];
        t[0] === L[0] && t[1] === L[1] || o.push([t, L]);
      });
    });
  } else if (n[0]) {
    var N = Math.abs(t[0]) === 1 ? [1] : [1, -1];
    N.forEach(function(M) {
      o.push([[t[0], -1], [M * n[0], -1]], [[t[0], 0], [M * n[0], 0]], [[t[0], 1], [M * n[0], 1]]);
    });
  } else if (n[1]) {
    var N = Math.abs(t[1]) === 1 ? [1] : [1, -1];
    N.forEach(function(D) {
      o.push([[-1, t[1]], [-1, D * n[1]]], [[0, t[1]], [0, D * n[1]]], [[1, t[1]], [1, D * n[1]]]);
    });
  }
  return o;
}
function isStartLine(n, t) {
  var e = average([t[0][0], t[1][0]]), o = average([t[0][1], t[1][1]]);
  return {
    vertical: e <= n[0],
    horizontal: o <= n[1]
  };
}
function hitTestLine(n, t) {
  var e = t[0], o = t[1], R = o[0] - e[0], N = o[1] - e[1];
  Math.abs(R) < TINY_NUM && (R = 0), Math.abs(N) < TINY_NUM && (N = 0);
  var M, D;
  if (!R)
    M = e[0], D = n[0];
  else if (!N)
    M = e[1], D = n[1];
  else {
    var L = N / R;
    M = L * (n[0] - e[0]) + e[1], D = n[1];
  }
  return M - D;
}
function isSameStartLine(n, t, e, o) {
  return o === void 0 && (o = TINY_NUM), n.every(function(R) {
    var N = hitTestLine(R, t), M = N <= 0;
    return M === e || Math.abs(N) <= o;
  });
}
function checkInnerBoundDot(n, t, e, o, R) {
  return R === void 0 && (R = 0), o && t - R <= n || !o && n <= e + R ? {
    isBound: !0,
    offset: o ? t - n : e - n
  } : {
    isBound: !1,
    offset: 0
  };
}
function checkInnerBound(n, t) {
  var e = t.line, o = t.centerSign, R = t.verticalSign, N = t.horizontalSign, M = t.lineConstants, D = n.props.innerBounds;
  if (!D)
    return {
      isAllBound: !1,
      isBound: !1,
      isVerticalBound: !1,
      isHorizontalBound: !1,
      offset: [0, 0]
    };
  var L = D.left, B = D.top, $ = D.width, k = D.height, U = [[L, B], [L, B + k]], z = [[L, B], [L + $, B]], X = [[L + $, B], [L + $, B + k]], V = [[L, B + k], [L + $, B + k]];
  if (isSameStartLine([[L, B], [L + $, B], [L, B + k], [L + $, B + k]], e, o))
    return {
      isAllBound: !1,
      isBound: !1,
      isVerticalBound: !1,
      isHorizontalBound: !1,
      offset: [0, 0]
    };
  var W = checkLineBoundCollision(e, M, z, R), Y = checkLineBoundCollision(e, M, V, R), q = checkLineBoundCollision(e, M, U, N), Z = checkLineBoundCollision(e, M, X, N), J = W.isBound && Y.isBound, Q = W.isBound || Y.isBound, K = q.isBound && Z.isBound, rt = q.isBound || Z.isBound, tt = maxOffset(W.offset, Y.offset), nt = maxOffset(q.offset, Z.offset), at = [0, 0], lt = !1, ut = !1;
  return Math.abs(nt) < Math.abs(tt) ? (at = [tt, 0], lt = Q, ut = J) : (at = [0, nt], lt = rt, ut = K), {
    isAllBound: ut,
    isVerticalBound: Q,
    isHorizontalBound: rt,
    isBound: lt,
    offset: at
  };
}
function checkLineBoundCollision(n, t, e, o, R, N) {
  var M = t[0], D = t[1], L = n[0], B = e[0], $ = e[1], k = getTinyDist($[1] - B[1]), U = getTinyDist($[0] - B[0]), z = D, X = M, V = -M / D;
  if (U) {
    if (!k) {
      if (N && !z)
        return {
          isBound: !1,
          offset: 0
        };
      if (X) {
        var Z = (B[1] - L[1]) / V + L[0];
        return checkInnerBoundDot(Z, B[0], $[0], o, R);
      } else {
        var Y = B[1] - L[1], q = Math.abs(Y) <= (R || 0);
        return {
          isBound: q,
          offset: q ? Y : 0
        };
      }
    }
  } else {
    if (N && !X)
      return {
        isBound: !1,
        offset: 0
      };
    if (z) {
      var W = V * (B[0] - L[0]) + L[1];
      return checkInnerBoundDot(W, B[1], $[1], o, R);
    } else {
      var Y = B[0] - L[0], q = Math.abs(Y) <= (R || 0);
      return {
        isBound: q,
        offset: q ? Y : 0
      };
    }
  }
  return {
    isBound: !1,
    offset: 0
  };
}
function getInnerBoundInfo(n, t, e) {
  return t.map(function(o) {
    var R = checkInnerBound(n, o), N = R.isBound, M = R.offset, D = R.isVerticalBound, L = R.isHorizontalBound, B = o.multiple, $ = getDragDist({
      datas: e,
      distX: M[0],
      distY: M[1]
    }).map(function(k, U) {
      return k * (B[U] ? 2 / B[U] : 0);
    });
    return {
      sign: B,
      isBound: N,
      isVerticalBound: D,
      isHorizontalBound: L,
      isSnap: !1,
      offset: $
    };
  });
}
function getInnerBoundDragInfo(n, t, e) {
  var o, R = getCheckInnerBoundLineInfos(n, t, [0, 0], !1).map(function(U) {
    return __assign$2(__assign$2({}, U), {
      multiple: U.multiple.map(function(z) {
        return Math.abs(z) * 2;
      })
    });
  }), N = getInnerBoundInfo(n, R, e), M = getNearOffsetInfo(N, 0), D = getNearOffsetInfo(N, 1), L = 0, B = 0, $ = M.isVerticalBound || D.isVerticalBound, k = M.isHorizontalBound || D.isHorizontalBound;
  return ($ || k) && (o = getInverseDragDist({
    datas: e,
    distX: -M.offset[0],
    distY: -D.offset[1]
  }), L = o[0], B = o[1]), {
    vertical: {
      isBound: $,
      offset: L
    },
    horizontal: {
      isBound: k,
      offset: B
    }
  };
}
function getCheckSnapLineDirections(n, t) {
  var e = [], o = n[0], R = n[1];
  return o && R ? e.push([[0, R * 2], n, [-o, R]], [[o * 2, 0], n, [o, -R]]) : o ? (e.push([[o * 2, 0], [o, 1], [o, -1]]), t && e.push([[0, -1], [o, -1], [-o, -1]], [[0, 1], [o, 1], [-o, 1]])) : R ? (e.push([[0, R * 2], [1, R], [-1, R]]), t && e.push([[-1, 0], [-1, R], [-1, -R]], [[1, 0], [1, R], [1, -R]])) : e.push([[-1, 0], [-1, -1], [-1, 1]], [[1, 0], [1, -1], [1, 1]], [[0, -1], [-1, -1], [1, -1]], [[0, 1], [-1, 1], [1, 1]]), e;
}
function getCheckInnerBoundLineInfos(n, t, e, o) {
  var R = n.state, N = R.allMatrix, M = R.is3d, D = calculatePoses(N, 100, 100, M ? 4 : 3), L = getPosByDirection(D, [0, 0]);
  return getCheckSnapLineDirections(e, o).map(function(B) {
    var $ = B[0], k = B[1], U = B[2], z = [getPosByDirection(D, k), getPosByDirection(D, U)], X = solveLineConstants(z), V = isStartLine(L, z), W = V.vertical, Y = V.horizontal, q = hitTestLine(L, z) <= 0;
    return {
      multiple: $,
      centerSign: q,
      verticalSign: W,
      horizontalSign: Y,
      lineConstants: X,
      line: [getPosByDirection(t, k), getPosByDirection(t, U)]
    };
  });
}
function isBoundRotate$1(n, t, e, o) {
  var R = o ? n.map(function(N) {
    return rotate(N, o);
  }) : n;
  return [[R[0], R[1]], [R[1], R[3]], [R[3], R[2]], [R[2], R[0]]].some(function(N) {
    var M = hitTestLine(e, N) <= 0;
    return !isSameStartLine(t, N, M);
  });
}
function getDistPointLine(n) {
  var t = n[0], e = n[1], o = e[0] - t[0], R = e[1] - t[1];
  if (!o)
    return Math.abs(t[0]);
  if (!R)
    return Math.abs(t[1]);
  var N = R / o;
  return Math.abs((-N * t[0] + t[1]) / Math.sqrt(Math.pow(N, 2) + 1));
}
function solveReverseLine(n) {
  var t = n[0], e = n[1], o = e[0] - t[0], R = e[1] - t[1];
  if (!o)
    return [t[0], 0];
  if (!R)
    return [0, t[1]];
  var N = R / o, M = -N * t[0] + t[1];
  return [-M / (N + 1 / N), M / (N * N + 1)];
}
function checkRotateInnerBounds(n, t, e, o, R) {
  var N = n.props.innerBounds, M = R * Math.PI / 180;
  if (!N)
    return [];
  var D = N.left, L = N.top, B = N.width, $ = N.height, k = D - o[0], U = D + B - o[0], z = L - o[1], X = L + $ - o[1], V = [[k, z], [U, z], [k, X], [U, X]], W = getPosByDirection(e, [0, 0]);
  if (!isBoundRotate$1(e, V, W, 0))
    return [];
  var Y = [], q = V.map(function(Z) {
    return [getDistSize(Z), getRad$1([0, 0], Z)];
  });
  return [[e[0], e[1]], [e[1], e[3]], [e[3], e[2]], [e[2], e[0]]].forEach(function(Z) {
    var J = getRad$1([0, 0], solveReverseLine(Z)), Q = getDistPointLine(Z);
    Y.push.apply(Y, q.filter(function(K) {
      var rt = K[0];
      return rt && Q <= rt;
    }).map(function(K) {
      var rt = K[0], tt = K[1], nt = Math.acos(rt ? Q / rt : 0), at = tt + nt, lt = tt - nt;
      return [M + at - J, M + lt - J];
    }).reduce(function(K, rt) {
      return K.push.apply(K, rt), K;
    }, []).filter(function(K) {
      return !isBoundRotate$1(t, V, W, K);
    }).map(function(K) {
      return throttle(K * 180 / Math.PI, TINY_NUM);
    }));
  }), Y;
}
function checkInnerBoundPoses(n) {
  var t = n.props.innerBounds;
  if (!t)
    return {
      vertical: [],
      horizontal: []
    };
  var e = n.getRect(), o = e.pos1, R = e.pos2, N = e.pos3, M = e.pos4, D = [o, R, N, M], L = getPosByDirection(D, [0, 0]), B = t.left, $ = t.top, k = t.width, U = t.height, z = [[B, $], [B, $ + U]], X = [[B, $], [B + k, $]], V = [[B + k, $], [B + k, $ + U]], W = [[B, $ + U], [B + k, $ + U]], Y = getCheckInnerBoundLineInfos(n, D, [0, 0], !1), q = [], Z = [], J = {
    top: !1,
    bottom: !1,
    left: !1,
    right: !1
  };
  return Y.forEach(function(Q) {
    var K = Q.line, rt = Q.lineConstants, tt = isStartLine(L, K), nt = tt.horizontal, at = tt.vertical, lt = checkLineBoundCollision(K, rt, X, at, 1, !0), ut = checkLineBoundCollision(K, rt, W, at, 1, !0), dt = checkLineBoundCollision(K, rt, z, nt, 1, !0), yt = checkLineBoundCollision(K, rt, V, nt, 1, !0);
    lt.isBound && !J.top && (q.push($), J.top = !0), ut.isBound && !J.bottom && (q.push($ + U), J.bottom = !0), dt.isBound && !J.left && (Z.push(B), J.left = !0), yt.isBound && !J.right && (Z.push(B + k), J.right = !0);
  }), {
    horizontal: q,
    vertical: Z
  };
}
function checkBoundPoses(n, t, e) {
  var o = n || {}, R = o.position, N = R === void 0 ? "client" : R, M = o.left, D = M === void 0 ? -1 / 0 : M, L = o.top, B = L === void 0 ? -1 / 0 : L, $ = o.right, k = $ === void 0 ? 1 / 0 : $, U = o.bottom, z = U === void 0 ? 1 / 0 : U, X = {
    position: N,
    left: D,
    top: B,
    right: k,
    bottom: z
  };
  return {
    vertical: checkBounds(X, t, !0),
    horizontal: checkBounds(X, e, !1)
  };
}
function getBounds(n, t) {
  var e = n.state, o = e.containerClientRect, R = o.clientHeight, N = o.clientWidth, M = o.clientLeft, D = o.clientTop, L = e.snapOffset, B = L.left, $ = L.top, k = L.right, U = L.bottom, z = t || n.props.bounds || {}, X = z.position || "client", V = X === "css", W = z.left, Y = W === void 0 ? -1 / 0 : W, q = z.top, Z = q === void 0 ? -1 / 0 : q, J = z.right, Q = J === void 0 ? V ? -1 / 0 : 1 / 0 : J, K = z.bottom, rt = K === void 0 ? V ? -1 / 0 : 1 / 0 : K;
  return V && (Q = N + k - B - Q, rt = R + U - $ - rt), {
    left: Y + B - M,
    right: Q + B - M,
    top: Z + $ - D,
    bottom: rt + $ - D
  };
}
function checkBoundKeepRatio(n, t, e) {
  var o = getBounds(n), R = o.left, N = o.top, M = o.right, D = o.bottom, L = e[0], B = e[1], $ = minus(e, t), k = $[0], U = $[1];
  Math.abs(k) < TINY_NUM && (k = 0), Math.abs(U) < TINY_NUM && (U = 0);
  var z = U > 0, X = k > 0, V = {
    isBound: !1,
    offset: 0,
    pos: 0
  }, W = {
    isBound: !1,
    offset: 0,
    pos: 0
  };
  if (k === 0 && U === 0)
    return {
      vertical: V,
      horizontal: W
    };
  if (k === 0)
    z ? D < B && (W.pos = D, W.offset = B - D) : N > B && (W.pos = N, W.offset = B - N);
  else if (U === 0)
    X ? M < L && (V.pos = M, V.offset = L - M) : R > L && (V.pos = R, V.offset = L - R);
  else {
    var Y = U / k, q = e[1] - Y * L, Z = 0, J = 0, Q = !1;
    X && M <= L ? (Z = Y * M + q, J = M, Q = !0) : !X && L <= R && (Z = Y * R + q, J = R, Q = !0), Q && (Z < N || Z > D) && (Q = !1), Q || (z && D <= B ? (Z = D, J = (Z - q) / Y, Q = !0) : !z && B <= N && (Z = N, J = (Z - q) / Y, Q = !0)), Q && (V.isBound = !0, V.pos = J, V.offset = L - J, W.isBound = !0, W.pos = Z, W.offset = B - Z);
  }
  return {
    vertical: V,
    horizontal: W
  };
}
function checkBounds(n, t, e) {
  var o = n[e ? "left" : "top"], R = n[e ? "right" : "bottom"], N = Math.min.apply(Math, t), M = Math.max.apply(Math, t), D = [];
  return o + 1 > N && D.push({
    isBound: !0,
    offset: N - o,
    pos: o
  }), R - 1 < M && D.push({
    isBound: !0,
    offset: M - R,
    pos: R
  }), D.length || D.push({
    isBound: !1,
    offset: 0,
    pos: 0
  }), D.sort(function(L, B) {
    return Math.abs(B.offset) - Math.abs(L.offset);
  });
}
function isBoundRotate(n, t, e) {
  var o = e ? n.map(function(R) {
    return rotate(R, e);
  }) : n;
  return o.some(function(R) {
    return R[0] < t.left && Math.abs(R[0] - t.left) > 0.1 || R[0] > t.right && Math.abs(R[0] - t.right) > 0.1 || R[1] < t.top && Math.abs(R[1] - t.top) > 0.1 || R[1] > t.bottom && Math.abs(R[1] - t.bottom) > 0.1;
  });
}
function boundRotate(n, t, e) {
  var o = getDistSize(n), R = Math.sqrt(o * o - t * t) || 0;
  return [R, -R].sort(function(N, M) {
    return Math.abs(N - n[e ? 0 : 1]) - Math.abs(M - n[e ? 0 : 1]);
  }).map(function(N) {
    return getRad$1([0, 0], e ? [N, t] : [t, N]);
  });
}
function checkRotateBounds(n, t, e, o, R) {
  if (!n.props.bounds)
    return [];
  var N = R * Math.PI / 180, M = getBounds(n), D = M.left, L = M.top, B = M.right, $ = M.bottom, k = D - o[0], U = B - o[0], z = L - o[1], X = $ - o[1], V = {
    left: k,
    top: z,
    right: U,
    bottom: X
  };
  if (!isBoundRotate(e, V, 0))
    return [];
  var W = [];
  return [[k, 0], [U, 0], [z, 1], [X, 1]].forEach(function(Y) {
    var q = Y[0], Z = Y[1];
    e.forEach(function(J) {
      var Q = getRad$1([0, 0], J);
      W.push.apply(W, boundRotate(J, q, Z).map(function(K) {
        return N + K - Q;
      }).filter(function(K) {
        return !isBoundRotate(t, V, K);
      }).map(function(K) {
        return throttle(K * 180 / Math.PI, TINY_NUM);
      }));
    });
  }), W;
}
function renderGuideline(n, t) {
  var e, o = n.direction, R = n.classNames, N = n.size, M = n.pos, D = n.zoom, L = n.key, B = o === "horizontal", $ = B ? "Y" : "X";
  return t.createElement("div", {
    key: L,
    className: R.join(" "),
    style: (e = {}, e[B ? "width" : "height"] = "".concat(N), e.transform = "translate(".concat(M[0], ", ").concat(M[1], ") translate").concat($, "(-50%) scale").concat($, "(").concat(D, ")"), e)
  });
}
function renderInnerGuideline(n, t) {
  return renderGuideline(__assign$2(__assign$2({}, n), {
    classNames: __spreadArray([prefix("line", "guideline", n.direction)], n.classNames, !0).filter(function(e) {
      return e;
    }),
    size: n.size || "".concat(n.sizeValue, "px"),
    pos: n.pos || n.posValue.map(function(e) {
      return "".concat(throttle(e, 0.1), "px");
    })
  }), t);
}
function renderSnapPoses(n, t, e, o, R, N, M, D) {
  var L = n.props.zoom;
  return e.map(function(B, $) {
    var k = B.type, U = B.pos, z = [0, 0];
    return z[M] = o, z[M ? 0 : 1] = -R + U, renderInnerGuideline({
      key: "".concat(t, "TargetGuideline").concat($),
      classNames: [prefix("target", "bold", k)],
      posValue: z,
      sizeValue: N,
      zoom: L,
      direction: t
    }, D);
  });
}
function renderGuidelines(n, t, e, o, R, N) {
  var M = n.props, D = M.zoom, L = M.isDisplayInnerSnapDigit, B = t === "horizontal" ? VERTICAL_NAMES_MAP : HORIZONTAL_NAMES_MAP, $ = R[B.start], k = R[B.end];
  return e.filter(function(U) {
    var z = U.hide, X = U.elementRect;
    if (z)
      return !1;
    if (L && X) {
      var V = X.rect;
      if (V[B.start] <= $ && k <= V[B.end])
        return !1;
    }
    return !0;
  }).map(function(U, z) {
    var X = U.pos, V = U.size, W = U.element, Y = U.className, q = [-o[0] + X[0], -o[1] + X[1]];
    return renderInnerGuideline({
      key: "".concat(t, "-default-guideline-").concat(z),
      classNames: W ? [prefix("bold"), Y] : [prefix("normal"), Y],
      direction: t,
      posValue: q,
      sizeValue: V,
      zoom: D
    }, N);
  });
}
function renderDigitLine(n, t, e, o, R, N, M, D) {
  var L, B = n.props, $ = B.snapDigit, k = $ === void 0 ? 0 : $, U = B.isDisplaySnapDigit, z = U === void 0 ? !0 : U, X = B.snapDistFormat, V = X === void 0 ? function(Q, K) {
    return Q;
  } : X, W = B.zoom, Y = t === "horizontal" ? "X" : "Y", q = t === "vertical" ? "height" : "width", Z = Math.abs(R), J = z ? parseFloat(Z.toFixed(k)) : 0;
  return D.createElement("div", {
    key: "".concat(t, "-").concat(e, "-guideline-").concat(o),
    className: prefix("guideline-group", t),
    style: (L = {
      left: "".concat(N[0], "px"),
      top: "".concat(N[1], "px")
    }, L[q] = "".concat(Z, "px"), L)
  }, renderInnerGuideline({
    direction: t,
    classNames: [prefix(e), M],
    size: "100%",
    posValue: [0, 0],
    sizeValue: Z,
    zoom: W
  }, D), D.createElement("div", {
    className: prefix("size-value", "gap"),
    style: {
      transform: "translate".concat(Y, "(-50%) scale(").concat(W, ")")
    }
  }, J > 0 ? V(J, t) : ""));
}
function groupByElementGuidelines(n, t, e, o) {
  var R = n === "vertical" ? 0 : 1, N = n === "vertical" ? 1 : 0, M = R ? VERTICAL_NAMES_MAP : HORIZONTAL_NAMES_MAP, D = e[M.start], L = e[M.end];
  return groupBy(t, function(B) {
    return B.pos[R];
  }).map(function(B) {
    var $ = [], k = [], U = [];
    return B.forEach(function(z) {
      var X, V, W = z.element, Y = z.elementRect.rect;
      if (Y[M.end] < D)
        $.push(z);
      else if (L < Y[M.start])
        k.push(z);
      else if (Y[M.start] <= D && L <= Y[M.end] && o) {
        var q = z.pos, Z = {
          element: W,
          rect: __assign$2(__assign$2({}, Y), (X = {}, X[M.end] = Y[M.start], X))
        }, J = {
          element: W,
          rect: __assign$2(__assign$2({}, Y), (V = {}, V[M.start] = Y[M.end], V))
        }, Q = [0, 0], K = [0, 0];
        Q[R] = q[R], Q[N] = q[N], K[R] = q[R], K[N] = q[N] + z.size, $.push({
          type: n,
          pos: Q,
          size: 0,
          elementRect: Z
        }), k.push({
          type: n,
          pos: K,
          size: 0,
          elementRect: J
        });
      }
    }), $.sort(function(z, X) {
      return X.pos[N] - z.pos[N];
    }), k.sort(function(z, X) {
      return z.pos[N] - X.pos[N];
    }), {
      total: B,
      start: $,
      end: k,
      inner: U
    };
  });
}
function renderDashedGuidelines(n, t, e, o, R) {
  var N = n.props.isDisplayInnerSnapDigit, M = [];
  return ["vertical", "horizontal"].forEach(function(D) {
    var L = t.filter(function(W) {
      return W.type === D;
    }), B = D === "vertical" ? 1 : 0, $ = B ? 0 : 1, k = groupByElementGuidelines(D, L, o, N), U = B ? HORIZONTAL_NAMES_MAP : VERTICAL_NAMES_MAP, z = B ? VERTICAL_NAMES_MAP : HORIZONTAL_NAMES_MAP, X = o[U.start], V = o[U.end];
    k.forEach(function(W) {
      var Y = W.total, q = W.start, Z = W.end, J = W.inner, Q = e[$] + Y[0].pos[$] - o[z.start], K = o;
      q.forEach(function(rt) {
        var tt = rt.elementRect.rect, nt = K[U.start] - tt[U.end];
        if (nt > 0) {
          var at = [0, 0];
          at[B] = e[B] + K[U.start] - X - nt, at[$] = Q, M.push(renderDigitLine(n, D, "dashed", M.length, nt, at, rt.className, R));
        }
        K = tt;
      }), K = o, Z.forEach(function(rt) {
        var tt = rt.elementRect.rect, nt = tt[U.start] - K[U.end];
        if (nt > 0) {
          var at = [0, 0];
          at[B] = e[B] + K[U.end] - X, at[$] = Q, M.push(renderDigitLine(n, D, "dashed", M.length, nt, at, rt.className, R));
        }
        K = tt;
      }), J.forEach(function(rt) {
        var tt = rt.elementRect.rect, nt = X - tt[U.start], at = tt[U.end] - V, lt = [0, 0], ut = [0, 0];
        lt[B] = e[B] - nt, lt[$] = Q, ut[B] = e[B] + V - X, ut[$] = Q, M.push(renderDigitLine(n, D, "dashed", M.length, nt, lt, rt.className, R)), M.push(renderDigitLine(n, D, "dashed", M.length, at, ut, rt.className, R));
      });
    });
  }), M;
}
function renderGapGuidelines(n, t, e, o, R) {
  var N = [];
  return ["horizontal", "vertical"].forEach(function(M) {
    var D = t.filter(function(W) {
      return W.type === M;
    }).slice(0, 1), L = M === "vertical" ? 0 : 1, B = L ? 0 : 1, $ = L ? HORIZONTAL_NAMES_MAP : VERTICAL_NAMES_MAP, k = L ? VERTICAL_NAMES_MAP : HORIZONTAL_NAMES_MAP, U = o[$.start], z = o[$.end], X = o[k.start], V = o[k.end];
    D.forEach(function(W) {
      var Y = W.gap, q = W.gapRects, Z = Math.max.apply(Math, __spreadArray([X], q.map(function(K) {
        var rt = K.rect;
        return rt[k.start];
      }), !1)), J = Math.min.apply(Math, __spreadArray([V], q.map(function(K) {
        var rt = K.rect;
        return rt[k.end];
      }), !1)), Q = (Z + J) / 2;
      Z === J || Q === (X + V) / 2 || q.forEach(function(K) {
        var rt = K.rect, tt = K.className, nt = [e[0], e[1]];
        if (rt[$.end] < U)
          nt[L] += rt[$.end] - U;
        else if (z < rt[$.start])
          nt[L] += rt[$.start] - U - Y;
        else
          return;
        nt[B] += Q - X, N.push(renderDigitLine(n, L ? "vertical" : "horizontal", "gap", N.length, Y, nt, tt, R));
      });
    });
  }), N;
}
function solveEquation(n, t, e, o) {
  var R = t[0] - n[0], N = t[1] - n[1];
  if (Math.abs(R) < TINY_NUM$1 && (R = 0), Math.abs(N) < TINY_NUM$1 && (N = 0), !R)
    return o ? [0, 0] : [0, e];
  if (!N)
    return o ? [e, 0] : [0, 0];
  var M = N / R, D = n[1] - M * n[0];
  if (o) {
    var L = M * (t[0] + e) + D;
    return [e, L - t[1]];
  } else {
    var B = (t[1] + e - D) / M;
    return [B - t[0], e];
  }
}
function solveNextOffset(n, t, e, o, R) {
  var N = solveEquation(n, t, e, o);
  if (!N)
    return {
      isOutside: !1,
      offset: [0, 0]
    };
  var M = getDist$2(n, t), D = getDist$2(N, n), L = getDist$2(N, t), B = D > M || L > M, $ = getDragDist({
    datas: R,
    distX: N[0],
    distY: N[1]
  }), k = $[0], U = $[1];
  return {
    offset: [k, U],
    isOutside: B
  };
}
function getSnapBound(n, t) {
  return n.isBound ? n.offset : t.isSnap ? getNearestSnapGuidelineInfo(t).offset : 0;
}
function checkThrottleDragRotate(n, t, e, o, R) {
  var N = t[0], M = t[1], D = e[0], L = e[1], B = o[0], $ = o[1], k = R[0], U = R[1], z = -k, X = -U;
  if (n && N && M) {
    z = 0, X = 0;
    var V = [];
    if (D && L ? V.push([0, U], [k, 0]) : D ? V.push([k, 0]) : L ? V.push([0, U]) : B && $ ? V.push([0, U], [k, 0]) : B ? V.push([k, 0]) : $ && V.push([0, U]), V.length) {
      V.sort(function(Z, J) {
        return getDistSize(minus([N, M], Z)) - getDistSize(minus([N, M], J));
      });
      var W = V[0];
      if (W[0] && Math.abs(N) > TINY_NUM$1)
        z = -W[0], X = M * Math.abs(N + z) / Math.abs(N) - M;
      else if (W[1] && Math.abs(M) > TINY_NUM$1) {
        var Y = M;
        X = -W[1], z = N * Math.abs(M + X) / Math.abs(Y) - N;
      }
      if (n && L && D)
        if (Math.abs(z) > TINY_NUM$1 && Math.abs(z) < Math.abs(k)) {
          var q = Math.abs(k) / Math.abs(z);
          z *= q, X *= q;
        } else if (Math.abs(X) > TINY_NUM$1 && Math.abs(X) < Math.abs(U)) {
          var q = Math.abs(U) / Math.abs(X);
          z *= q, X *= q;
        } else
          z = maxOffset(-k, z), X = maxOffset(-U, X);
    }
  } else
    z = N || D ? -k : 0, X = M || L ? -U : 0;
  return [z, X];
}
function checkSnapBoundsDrag(n, t, e, o, R, N) {
  if (!hasGuidelines(n, "draggable"))
    return [{
      isSnap: !1,
      isBound: !1,
      offset: 0
    }, {
      isSnap: !1,
      isBound: !1,
      offset: 0
    }];
  var M = getAbsolutePoses(N.absolutePoses, [t, e]), D = getRect(M), L = D.left, B = D.right, $ = D.top, k = D.bottom, U = {
    horizontal: M.map(function(yt) {
      return yt[1];
    }),
    vertical: M.map(function(yt) {
      return yt[0];
    })
  }, z = getSnapDirections(n.props.snapDirections), X = splitSnapDirectionPoses(z, {
    left: L,
    right: B,
    top: $,
    bottom: k,
    center: (L + B) / 2,
    middle: ($ + k) / 2
  }), V = checkMoveableSnapBounds(n, R, X, U), W = V.vertical, Y = V.horizontal, q = getInnerBoundDragInfo(n, M, N), Z = q.vertical, J = q.horizontal, Q = W.isSnap, K = Y.isSnap, rt = W.isBound || Z.isBound, tt = Y.isBound || J.isBound, nt = maxOffset(W.offset, Z.offset), at = maxOffset(Y.offset, J.offset), lt = checkThrottleDragRotate(o, [t, e], [rt, tt], [Q, K], [nt, at]), ut = lt[0], dt = lt[1];
  return [{
    isBound: rt,
    isSnap: Q,
    offset: ut
  }, {
    isBound: tt,
    isSnap: K,
    offset: dt
  }];
}
function checkMoveableSnapBounds(n, t, e, o) {
  o === void 0 && (o = e);
  var R = checkBoundPoses(getBounds(n), o.vertical, o.horizontal), N = R.horizontal, M = R.vertical, D = t ? {
    horizontal: {
      isSnap: !1,
      index: -1
    },
    vertical: {
      isSnap: !1,
      index: -1
    }
  } : checkMoveableSnapPoses(n, e.vertical, e.horizontal), L = D.horizontal, B = D.vertical, $ = getSnapBound(N[0], L), k = getSnapBound(M[0], B), U = Math.abs($), z = Math.abs(k);
  return {
    horizontal: {
      isBound: N[0].isBound,
      isSnap: L.isSnap,
      snapIndex: L.index,
      offset: $,
      dist: U,
      bounds: N,
      snap: L
    },
    vertical: {
      isBound: M[0].isBound,
      isSnap: B.isSnap,
      snapIndex: B.index,
      offset: k,
      dist: z,
      bounds: M,
      snap: B
    }
  };
}
function checkSnapBounds(n, t, e, o, R) {
  var N = checkBoundPoses(t, e, o), M = N.horizontal, D = N.vertical, L = checkSnapPoses(n, e, o, R), B = L.horizontal, $ = L.vertical, k = getSnapBound(M[0], B), U = getSnapBound(D[0], $), z = Math.abs(k), X = Math.abs(U);
  return {
    horizontal: {
      isBound: M[0].isBound,
      isSnap: B.isSnap,
      snapIndex: B.index,
      offset: k,
      dist: z,
      bounds: M,
      snap: B
    },
    vertical: {
      isBound: D[0].isBound,
      isSnap: $.isSnap,
      snapIndex: $.index,
      offset: U,
      dist: X,
      bounds: D,
      snap: $
    }
  };
}
function checkSnapRightLine(n, t, e, o) {
  var R = getRad$1(n, t) / Math.PI * 180, N = e.vertical, M = N.isBound, D = N.isSnap, L = N.dist, B = e.horizontal, $ = B.isBound, k = B.isSnap, U = B.dist, z = R % 180, X = z < 3 || z > 177, V = z > 87 && z < 93;
  return U < L && (M || D && !V && (!o || !X)) ? "vertical" : $ || k && !X && (!o || !V) ? "horizontal" : "";
}
function getSnapBoundInfo(n, t, e, o, R, N) {
  return e.map(function(M) {
    var D = M[0], L = M[1], B = getPosByDirection(t, D), $ = getPosByDirection(t, L), k = o ? checkSnapBoundsKeepRatio(n, B, $, R) : checkMoveableSnapBounds(n, R, {
      vertical: [$[0]],
      horizontal: [$[1]]
    }), U = k.horizontal, z = U.offset, X = U.isBound, V = U.isSnap, W = k.vertical, Y = W.offset, q = W.isBound, Z = W.isSnap, J = minus(L, D);
    if (!Y && !z)
      return {
        isBound: q || X,
        isSnap: Z || V,
        sign: J,
        offset: [0, 0]
      };
    var Q = checkSnapRightLine(B, $, k, o);
    if (!Q)
      return {
        sign: J,
        isBound: !1,
        isSnap: !1,
        offset: [0, 0]
      };
    var K = Q === "vertical", rt = [0, 0];
    return !o && Math.abs(L[0]) === 1 && Math.abs(L[1]) === 1 && D[0] !== L[0] && D[1] !== L[1] ? rt = getDragDist({
      datas: N,
      distX: -Y,
      distY: -z
    }) : rt = solveNextOffset(B, $, -(K ? Y : z), K, N).offset, rt = rt.map(function(tt, nt) {
      return tt * (J[nt] ? 2 / J[nt] : 0);
    }), {
      sign: J,
      isBound: K ? q : X,
      isSnap: K ? Z : V,
      offset: rt
    };
  });
}
function getSnapBoundOffset(n, t) {
  return n.isBound ? n.offset : t.isSnap ? t.offset : 0;
}
function checkSnapBoundsKeepRatio(n, t, e, o) {
  var R = checkBoundKeepRatio(n, t, e), N = R.horizontal, M = R.vertical, D = o ? {
    horizontal: {
      isSnap: !1
    },
    vertical: {
      isSnap: !1
    }
  } : checkSnapKeepRatio(n, t, e), L = D.horizontal, B = D.vertical, $ = getSnapBoundOffset(N, L), k = getSnapBoundOffset(M, B), U = Math.abs($), z = Math.abs(k);
  return {
    horizontal: {
      isBound: N.isBound,
      isSnap: L.isSnap,
      offset: $,
      dist: U
    },
    vertical: {
      isBound: M.isBound,
      isSnap: B.isSnap,
      offset: k,
      dist: z
    }
  };
}
function checkMaxBounds(n, t, e, o, R) {
  var N = [-e[0], -e[1]], M = n.state, D = M.width, L = M.height, B = n.props.bounds, $ = 1 / 0, k = 1 / 0;
  if (B) {
    var U = [[e[0], -e[1]], [-e[0], e[1]]], z = B.left, X = z === void 0 ? -1 / 0 : z, V = B.top, W = V === void 0 ? -1 / 0 : V, Y = B.right, q = Y === void 0 ? 1 / 0 : Y, Z = B.bottom, J = Z === void 0 ? 1 / 0 : Z;
    U.forEach(function(Q) {
      var K = Q[0] !== N[0], rt = Q[1] !== N[1], tt = getPosByDirection(t, Q), nt = getRad$1(o, tt) * 360 / Math.PI;
      if (rt) {
        var at = tt.slice();
        (Math.abs(nt - 360) < 2 || Math.abs(nt - 180) < 2) && (at[1] = o[1]);
        var lt = solveNextOffset(o, at, (o[1] < tt[1] ? J : W) - tt[1], !1, R), ut = lt.offset, dt = ut[1], yt = lt.isOutside;
        isNaN(dt) || (k = L + (yt ? 1 : -1) * Math.abs(dt));
      }
      if (K) {
        var at = tt.slice();
        (Math.abs(nt - 90) < 2 || Math.abs(nt - 270) < 2) && (at[0] = o[0]);
        var pt = solveNextOffset(o, at, (o[0] < tt[0] ? q : X) - tt[0], !0, R), gt = pt.offset[0], xt = pt.isOutside;
        isNaN(gt) || ($ = D + (xt ? 1 : -1) * Math.abs(gt));
      }
    });
  }
  return {
    maxWidth: $,
    maxHeight: k
  };
}
function getTotalGuidelines(n) {
  var t = n.state, e = t.snapOffset, o = t.containerClientRect, R = o.overflow, N = o.scrollHeight, M = o.scrollWidth, D = o.clientHeight, L = o.clientWidth, B = o.clientLeft, $ = o.clientTop, k = n.props, U = k.snapGap, z = U === void 0 ? !0 : U, X = k.verticalGuidelines, V = k.horizontalGuidelines, W = k.snapThreshold, Y = W === void 0 ? 5 : W, q = k.snapGridWidth, Z = q === void 0 ? 0 : q, J = k.snapGridHeight, Q = J === void 0 ? 0 : J, K = k.maxSnapElementGuidelineDistance, rt = K === void 0 ? 1 / 0 : K, tt = getRect(getAbsolutePosesByState(n.state)), nt = tt.top, at = tt.left, lt = tt.bottom, ut = tt.right, dt = {
    top: nt,
    left: at,
    bottom: lt,
    right: ut,
    center: (at + ut) / 2,
    middle: (nt + lt) / 2
  }, yt = getElementGuidelines(n), pt = __spreadArray([], yt, !0);
  return z && pt.push.apply(pt, getGapGuidelines(n, dt, Y)), pt.push.apply(pt, getGridGuidelines(Z, Q, R ? M : L, R ? N : D, B, $)), pt.push.apply(pt, getDefaultGuidelines(V || !1, X || !1, R ? M : L, R ? N : D, B, $, e)), pt = pt.filter(function(gt) {
    var xt = gt.element, Lt = gt.elementRect, mt = gt.type;
    if (!xt || !Lt)
      return !0;
    var ct = Lt.rect;
    return checkBetweenRects(dt, ct, mt, rt);
  }), pt;
}
function getGapGuidelines(n, t, e) {
  var o = n.props, R = o.maxSnapElementGuidelineDistance, N = R === void 0 ? 1 / 0 : R, M = o.maxSnapElementGapDistance, D = M === void 0 ? 1 / 0 : M, L = n.state.elementRects, B = [];
  return [["vertical", VERTICAL_NAMES_MAP, HORIZONTAL_NAMES_MAP], ["horizontal", HORIZONTAL_NAMES_MAP, VERTICAL_NAMES_MAP]].forEach(function($) {
    var k = $[0], U = $[1], z = $[2], X = t[U.start], V = t[U.end], W = t[U.center], Y = t[z.start], q = t[z.end];
    function Z(K) {
      var rt = K.rect;
      return rt[U.end] < X + e ? X - rt[U.end] : V - e < rt[U.start] ? rt[U.start] - V : -1;
    }
    var J = L.filter(function(K) {
      var rt = K.rect;
      return rt[z.start] > q || rt[z.end] < Y ? !1 : Z(K) > 0;
    }).sort(function(K, rt) {
      return Z(K) - Z(rt);
    }), Q = [];
    J.forEach(function(K) {
      J.forEach(function(rt) {
        if (K !== rt) {
          var tt = K.rect, nt = rt.rect, at = tt[z.start], lt = tt[z.end], ut = nt[z.start], dt = nt[z.end];
          at > dt || ut > lt || Q.push([K, rt]);
        }
      });
    }), Q.forEach(function(K) {
      var rt = K[0], tt = K[1], nt = rt.rect, at = tt.rect, lt = nt[U.start], ut = nt[U.end], dt = at[U.start], yt = at[U.end], pt = 0, gt = 0, xt = !1, Lt = !1, mt = !1;
      if (ut <= X && V <= dt) {
        if (Lt = !0, pt = (dt - ut - (V - X)) / 2, gt = ut + pt + (V - X) / 2, Math.abs(gt - W) > e)
          return;
      } else if (ut < dt && yt < X + e) {
        if (xt = !0, pt = dt - ut, gt = yt + pt, Math.abs(gt - X) > e)
          return;
      } else if (ut < dt && V - e < lt) {
        if (mt = !0, pt = dt - ut, gt = lt - pt, Math.abs(gt - V) > e)
          return;
      } else
        return;
      !pt || !checkBetweenRects(t, at, k, N) || pt > D || B.push({
        type: k,
        pos: k === "vertical" ? [gt, 0] : [0, gt],
        element: tt.element,
        size: 0,
        className: tt.className,
        isStart: xt,
        isCenter: Lt,
        isEnd: mt,
        gap: pt,
        hide: !0,
        gapRects: [rt, tt]
      });
    });
  }), B;
}
function getGridGuidelines(n, t, e, o, R, N) {
  R === void 0 && (R = 0), N === void 0 && (N = 0);
  var M = [];
  if (t)
    for (var D = 0; D <= o; D += t)
      M.push({
        type: "horizontal",
        pos: [0, throttle(D - N, 0.1)],
        size: e,
        hide: !0
      });
  if (n)
    for (var D = 0; D <= e; D += n)
      M.push({
        type: "vertical",
        pos: [throttle(D - R, 0.1), 0],
        size: o,
        hide: !0
      });
  return M;
}
function checkBetweenRects(n, t, e, o) {
  return e === "horizontal" ? Math.abs(n.right - t.left) <= o || Math.abs(n.left - t.right) <= o || n.left <= t.right && t.left <= n.right : e === "vertical" ? Math.abs(n.bottom - t.top) <= o || Math.abs(n.top - t.bottom) <= o || n.top <= t.bottom && t.top <= n.bottom : !0;
}
function getElementGuidelines(n) {
  var t = n.state, e = n.props.elementGuidelines, o = e === void 0 ? [] : e;
  if (!o.length)
    return t.elementRects = [], [];
  var R = (t.elementRects || []).filter(function(U) {
    return !U.refresh;
  }), N = o.map(function(U) {
    return isObject$2(U) && "element" in U ? __assign$2(__assign$2({}, U), {
      element: getRefTarget(U.element, !0)
    }) : {
      element: getRefTarget(U, !0)
    };
  }).filter(function(U) {
    return U.element;
  }), M = diff(R.map(function(U) {
    return U.element;
  }), N.map(function(U) {
    return U.element;
  })), D = M.maintained, L = M.added, B = [];
  D.forEach(function(U) {
    var z = U[0], X = U[1];
    B[X] = R[z];
  }), getSnapElementRects(n, L.map(function(U) {
    return N[U];
  })).map(function(U, z) {
    B[L[z]] = U;
  }), t.elementRects = B;
  var $ = getSnapDirections(n.props.elementSnapDirections), k = [];
  return B.forEach(function(U) {
    var z = U.element, X = U.top, V = X === void 0 ? $.top : X, W = U.left, Y = W === void 0 ? $.left : W, q = U.right, Z = q === void 0 ? $.right : q, J = U.bottom, Q = J === void 0 ? $.bottom : J, K = U.center, rt = K === void 0 ? $.center : K, tt = U.middle, nt = tt === void 0 ? $.middle : tt, at = U.className, lt = U.rect, ut = splitSnapDirectionPoses({
      top: V,
      right: Z,
      left: Y,
      bottom: Q,
      center: rt,
      middle: nt
    }, lt), dt = ut.horizontal, yt = ut.vertical, pt = lt.top, gt = lt.left, xt = lt.right - gt, Lt = lt.bottom - pt, mt = [xt, Lt];
    yt.forEach(function(ct) {
      k.push({
        type: "vertical",
        element: z,
        pos: [throttle(ct, 0.1), pt],
        size: Lt,
        sizes: mt,
        className: at,
        elementRect: U
      });
    }), dt.forEach(function(ct) {
      k.push({
        type: "horizontal",
        element: z,
        pos: [gt, throttle(ct, 0.1)],
        size: xt,
        sizes: mt,
        className: at,
        elementRect: U
      });
    });
  }), k;
}
function getDefaultGuidelines(n, t, e, o, R, N, M) {
  R === void 0 && (R = 0), N === void 0 && (N = 0), M === void 0 && (M = {
    left: 0,
    top: 0,
    right: 0,
    bottom: 0
  });
  var D = [], L = M.left, B = M.top, $ = M.bottom, k = M.right, U = e + k - L, z = o + $ - B;
  return n && n.forEach(function(X) {
    var V = isObject$2(X) ? X : {
      pos: X
    };
    D.push({
      type: "horizontal",
      pos: [L, throttle(V.pos - N + B, 0.1)],
      size: U,
      className: V.className
    });
  }), t && t.forEach(function(X) {
    var V = isObject$2(X) ? X : {
      pos: X
    };
    D.push({
      type: "vertical",
      pos: [throttle(V.pos - R + L, 0.1), B],
      size: z,
      className: V.className
    });
  }), D;
}
function getSnapElementRects(n, t) {
  if (!t.length)
    return [];
  var e = n.state, o = e.containerClientRect, R = e.targetClientRect, N = R.top, M = R.left, D = e.rootMatrix, L = e.is3d, B = L ? 4 : 3, $ = calculateContainerPos(D, o, B), k = $[0], U = $[1], z = getAbsolutePosesByState(e), X = getMinMaxs(z), V = X.minX, W = X.minY, Y = minus([V, W], calculateInversePosition(D, [M - k, N - U], B)).map(function(J) {
    return roundSign(J);
  }), q = Y[0], Z = Y[1];
  return t.map(function(J) {
    var Q = J.element.getBoundingClientRect(), K = Q.left - k, rt = Q.top - U, tt = rt + Q.height, nt = K + Q.width, at = calculateInversePosition(D, [K, rt], B), lt = at[0], ut = at[1], dt = calculateInversePosition(D, [nt, tt], B), yt = dt[0], pt = dt[1];
    return __assign$2(__assign$2({}, J), {
      rect: {
        left: lt + q,
        right: yt + q,
        top: ut + Z,
        bottom: pt + Z,
        center: (lt + yt) / 2 + q,
        middle: (ut + pt) / 2 + Z
      }
    });
  });
}
function snapStart(n) {
  var t = n.state;
  if (!(t.guidelines && t.guidelines.length)) {
    var e = n.state.container, o = n.props.snapContainer || e, R = t.containerClientRect, N = {
      left: 0,
      top: 0,
      bottom: 0,
      right: 0
    };
    if (e !== o) {
      var M = getRefTarget(o, !0);
      if (M) {
        var D = getClientRect(M), L = getDragDistByState(t, [D.left - R.left, D.top - R.top]), B = getDragDistByState(t, [D.right - R.right, D.bottom - R.bottom]);
        N.left = throttle(L[0], 1e-5), N.top = throttle(L[1], 1e-5), N.right = throttle(B[0], 1e-5), N.bottom = throttle(B[1], 1e-5);
      }
    }
    t.snapOffset = N, t.guidelines = getTotalGuidelines(n), t.enableSnap = !0;
  }
}
function getNextFixedPoses(n, t, e, o, R, N) {
  var M = calculatePoses(n, t, e, N ? 4 : 3), D = getPosByDirection(M, o);
  return getAbsolutePoses(M, minus(R, D));
}
function getSizeOffsetInfo(n, t, e, o, R, N) {
  var M = N.fixedDirection, D = getCheckSnapDirections(e, M, o), L = getCheckInnerBoundLineInfos(n, t, e, o), B = __spreadArray(__spreadArray([], getSnapBoundInfo(n, t, D, o, R, N), !0), getInnerBoundInfo(n, L, N), !0), $ = getNearOffsetInfo(B, 0), k = getNearOffsetInfo(B, 1);
  return {
    width: {
      isBound: $.isBound,
      offset: $.offset[0]
    },
    height: {
      isBound: k.isBound,
      offset: k.offset[1]
    }
  };
}
function recheckSizeByTwoDirection(n, t, e, o, R, N, M, D, L) {
  var B = getPosByDirection(t, M), $ = checkMoveableSnapBounds(n, D, {
    vertical: [B[0]],
    horizontal: [B[1]]
  }), k = $.horizontal.offset, U = $.vertical.offset;
  if (U || k) {
    var z = getDragDist({
      datas: L,
      distX: -U,
      distY: -k
    }), X = z[0], V = z[1], W = Math.min(R || 1 / 0, e + M[0] * X), Y = Math.min(N || 1 / 0, o + M[1] * V);
    return [W - e, Y - o];
  }
  return [0, 0];
}
function checkSizeDist(n, t, e, o, R, N, M, D) {
  for (var L = getAbsolutePosesByState(n.state), B = n.props.keepRatio, $ = 0, k = 0, U = 0; U < 2; ++U) {
    var z = t($, k), X = getSizeOffsetInfo(n, z, R, B, M, D), V = X.width, W = X.height, Y = V.isBound, q = W.isBound, Z = V.offset, J = W.offset;
    if (U === 1 && (Y || (Z = 0), q || (J = 0)), U === 0 && M && !Y && !q)
      return [0, 0];
    if (B) {
      var Q = Math.abs(Z) * (e ? 1 / e : 1), K = Math.abs(J) * (o ? 1 / o : 1), rt = Y && q ? Q < K : q || !Y && Q < K;
      rt ? Z = e * J / o : J = o * Z / e;
    }
    $ += Z, k += J;
  }
  if (R[0] && R[1]) {
    var tt = checkMaxBounds(n, L, R, N, D), nt = tt.maxWidth, at = tt.maxHeight, lt = recheckSizeByTwoDirection(n, t($, k).map(function(yt) {
      return yt.map(function(pt) {
        return throttle(pt, FLOAT_POINT_NUM);
      });
    }), e + $, o + k, nt, at, R, M, D), Z = lt[0], J = lt[1];
    $ += Z, k += J;
  }
  return [$, k];
}
function checkSnapRotate(n, t, e, o) {
  if (!hasGuidelines(n, "rotatable"))
    return o;
  var R = t.pos1, N = t.pos2, M = t.pos3, D = t.pos4, L = o * Math.PI / 180, B = [R, N, M, D].map(function(U) {
    return minus(U, e);
  }), $ = B.map(function(U) {
    return rotate(U, L);
  }), k = __spreadArray(__spreadArray([], checkRotateBounds(n, B, $, e, o), !0), checkRotateInnerBounds(n, B, $, e, o), !0);
  return k.sort(function(U, z) {
    return Math.abs(U - o) - Math.abs(z - o);
  }), k.length ? k[0] : o;
}
function checkSnapResize(n, t, e, o, R, N, M) {
  if (!hasGuidelines(n, "resizable"))
    return [0, 0];
  var D = M.fixedDirection, L = M.nextAllMatrix, B = n.state, $ = B.allMatrix, k = B.is3d;
  return checkSizeDist(n, function(U, z) {
    return getNextFixedPoses(L || $, t + U, e + z, D, R, k);
  }, t, e, o, R, N, M);
}
function checkSnapScale(n, t, e, o, R) {
  if (!hasGuidelines(n, "scalable"))
    return [0, 0];
  var N = R.startOffsetWidth, M = R.startOffsetHeight, D = R.fixedPosition, L = R.fixedDirection, B = R.is3d, $ = checkSizeDist(n, function(k, U) {
    return getNextFixedPoses(scaleMatrix(R, plus(t, [k / N, U / M])), N, M, L, D, B);
  }, N, M, e, D, o, R);
  return [$[0] / N, $[1] / M];
}
function startCheckSnapDrag(n, t) {
  t.absolutePoses = getAbsolutePosesByState(n.state);
}
function getSnapGuidelines(n) {
  var t = [];
  return n.forEach(function(e) {
    e.guidelineInfos.forEach(function(o) {
      var R = o.guideline;
      t.indexOf(R) > -1 || t.push(R);
    });
  }), t;
}
function addBoundGuidelines(n, t, e, o, R, N) {
  var M = checkBoundPoses(getBounds(n, N), t, e), D = M.vertical, L = M.horizontal;
  D.forEach(function(U) {
    U.isBound && o.push({
      type: "bounds",
      pos: U.pos
    });
  }), L.forEach(function(U) {
    U.isBound && R.push({
      type: "bounds",
      pos: U.pos
    });
  });
  var B = checkInnerBoundPoses(n), $ = B.vertical, k = B.horizontal;
  $.forEach(function(U) {
    findIndex(o, function(z) {
      var X = z.type, V = z.pos;
      return X === "bounds" && V === U;
    }) >= 0 || o.push({
      type: "bounds",
      pos: U
    });
  }), k.forEach(function(U) {
    findIndex(R, function(z) {
      var X = z.type, V = z.pos;
      return X === "bounds" && V === U;
    }) >= 0 || R.push({
      type: "bounds",
      pos: U
    });
  });
}
var directionCondition$2 = getDirectionCondition("", ["resizable", "scalable"]), Snappable = {
  name: "snappable",
  dragRelation: "strong",
  props: {
    snappable: [Boolean, Array],
    snapContainer: Object,
    snapDirections: [Boolean, Object],
    elementSnapDirections: [Boolean, Object],
    snapGap: Boolean,
    snapGridWidth: Number,
    snapGridHeight: Number,
    isDisplaySnapDigit: Boolean,
    isDisplayInnerSnapDigit: Boolean,
    snapDigit: Number,
    snapThreshold: Number,
    horizontalGuidelines: Array,
    verticalGuidelines: Array,
    elementGuidelines: Array,
    bounds: Object,
    innerBounds: Object,
    snapDistFormat: Function,
    maxSnapElementGuidelineDistance: Number,
    maxSnapElementGapDistance: Number
  },
  events: {
    onSnap: "snap"
  },
  css: [`:host {
    --bounds-color: #d66;
}
.guideline {
    pointer-events: none;
    z-index: 2;
}
.guideline.bounds {
    background: #d66;
    background: var(--bounds-color);
}
.guideline-group {
    position: absolute;
    top: 0;
    left: 0;
}
.guideline-group .size-value {
    position: absolute;
    color: #f55;
    font-size: 12px;
    font-weight: bold;
}
.guideline-group.horizontal .size-value {
    transform-origin: 50% 100%;
    transform: translateX(-50%);
    left: 50%;
    bottom: 5px;
}
.guideline-group.vertical .size-value {
    transform-origin: 0% 50%;
    top: 50%;
    transform: translateY(-50%);
    left: 5px;
}
.guideline.gap {
    background: #f55;
}
.size-value.gap {
    color: #f55;
}
`],
  render: function(n, t) {
    var e = n.state, o = e.top, R = e.left, N = e.pos1, M = e.pos2, D = e.pos3, L = e.pos4, B = e.snapRenderInfo;
    if (!B || !hasGuidelines(n, ""))
      return [];
    e.guidelines = getTotalGuidelines(n);
    var $ = Math.min(N[0], M[0], D[0], L[0]), k = Math.min(N[1], M[1], D[1], L[1]), U = B.externalPoses || [], z = getAbsolutePosesByState(n.state), X = [], V = [], W = [], Y = [], q = [], Z = getRect(z), J = Z.width, Q = Z.height, K = Z.top, rt = Z.left, tt = Z.bottom, nt = Z.right, at = {
      left: rt,
      right: nt,
      top: K,
      bottom: tt,
      center: (rt + nt) / 2,
      middle: (K + tt) / 2
    }, lt = U.length > 0, ut = lt ? getRect(U) : {};
    if (!B.request) {
      if (B.direction && q.push(getSnapInfosByDirection(n, z, B.direction)), B.snap) {
        var dt = getRect(z);
        B.center && (dt.middle = (dt.top + dt.bottom) / 2, dt.center = (dt.left + dt.right) / 2), q.push(checkSnaps(n, dt, 1));
      }
      lt && (B.center && (ut.middle = (ut.top + ut.bottom) / 2, ut.center = (ut.left + ut.right) / 2), q.push(checkSnaps(n, ut, 1))), q.forEach(function(xt) {
        var Lt = xt.vertical.posInfos, mt = xt.horizontal.posInfos;
        X.push.apply(X, Lt.filter(function(ct) {
          var vt = ct.guidelineInfos;
          return vt.some(function(Tt) {
            var Pt = Tt.guideline;
            return !Pt.hide;
          });
        }).map(function(ct) {
          return {
            type: "snap",
            pos: ct.pos
          };
        })), V.push.apply(V, mt.filter(function(ct) {
          var vt = ct.guidelineInfos;
          return vt.some(function(Tt) {
            var Pt = Tt.guideline;
            return !Pt.hide;
          });
        }).map(function(ct) {
          return {
            type: "snap",
            pos: ct.pos
          };
        })), W.push.apply(W, getSnapGuidelines(Lt)), Y.push.apply(Y, getSnapGuidelines(mt));
      });
    }
    addBoundGuidelines(n, [rt, nt], [K, tt], X, V), lt && addBoundGuidelines(n, [ut.left, ut.right], [ut.top, ut.bottom], X, V, B.externalBounds);
    var yt = __spreadArray(__spreadArray([], W, !0), Y, !0), pt = yt.filter(function(xt) {
      return xt.element && !xt.gapRects;
    }), gt = yt.filter(function(xt) {
      return xt.gapRects;
    }).sort(function(xt, Lt) {
      return xt.gap - Lt.gap;
    });
    return triggerEvent(n, "onSnap", {
      guidelines: yt.filter(function(xt) {
        var Lt = xt.element;
        return !Lt;
      }),
      elements: pt,
      gaps: gt
    }, !0), __spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray([], renderDashedGuidelines(n, pt, [$, k], at, t), !0), renderGapGuidelines(n, gt, [$, k], at, t), !0), renderGuidelines(n, "horizontal", Y, [R, o], at, t), !0), renderGuidelines(n, "vertical", W, [R, o], at, t), !0), renderSnapPoses(n, "horizontal", V, $, o, J, 0, t), !0), renderSnapPoses(n, "vertical", X, k, R, Q, 1, t), !0);
  },
  dragStart: function(n, t) {
    n.state.snapRenderInfo = {
      request: t.isRequest,
      snap: !0,
      center: !0
    }, snapStart(n);
  },
  drag: function(n) {
    var t = n.state;
    t.guidelines = getTotalGuidelines(n);
  },
  pinchStart: function(n) {
    this.unset(n);
  },
  dragEnd: function(n) {
    this.unset(n);
  },
  dragControlCondition: function(n, t) {
    if (directionCondition$2(n, t) || dragControlCondition(n, t))
      return !0;
    if (!t.isRequest && t.inputEvent)
      return hasClass(t.inputEvent.target, prefix("snap-control"));
  },
  dragControlStart: function(n) {
    n.state.snapRenderInfo = null, snapStart(n);
  },
  dragControl: function(n) {
    this.drag(n);
  },
  dragControlEnd: function(n) {
    this.unset(n);
  },
  dragGroupStart: function(n, t) {
    this.dragStart(n, t);
  },
  dragGroup: function(n) {
    this.drag(n);
  },
  dragGroupEnd: function(n) {
    this.unset(n);
  },
  dragGroupControlStart: function(n) {
    n.state.snapRenderInfo = null, snapStart(n);
  },
  dragGroupControl: function(n) {
    this.drag(n);
  },
  dragGroupControlEnd: function(n) {
    this.unset(n);
  },
  unset: function(n) {
    var t = n.state;
    t.enableSnap = !1, t.guidelines = [], t.snapRenderInfo = null, t.elementRects = [];
  }
};
function renderDirectionControlsByInfos(n, t, e, o) {
  var R = n.state, N = R.renderPoses, M = R.rotation, D = R.direction, L = getProps(n.props, t).zoom, B = D > 0 ? 1 : -1, $ = M / Math.PI * 180, k = {}, U = n.renderState;
  U.renderDirectionMap || (U.renderDirectionMap = {});
  var z = U.renderDirectionMap;
  return e.forEach(function(X) {
    var V = X.dir;
    k[V] = !0;
  }), e.map(function(X) {
    var V = X.data, W = X.classNames, Y = X.dir, q = DIRECTION_INDEXES[Y];
    if (!q || !k[Y])
      return null;
    z[Y] = !0;
    var Z = (throttle($, 15) + B * DIRECTION_ROTATIONS[Y] + 720) % 180, J = {};
    return getKeys(V).forEach(function(Q) {
      J["data-".concat(Q)] = V[Q];
    }), o.createElement("div", __assign$2({
      className: prefix.apply(void 0, __spreadArray(["control", "direction", Y, t], W, !1)),
      "data-rotation": Z,
      "data-direction": Y
    }, J, {
      key: "direction-".concat(Y),
      style: getControlTransform.apply(void 0, __spreadArray([M, L], q.map(function(Q) {
        return N[Q];
      }), !1))
    }));
  });
}
function renderDirectionControls(n, t, e, o) {
  var R = getProps(n.props, e).renderDirections, N = R === void 0 ? t : R;
  if (!N)
    return [];
  var M = N === !0 ? DIRECTIONS : N;
  return renderDirectionControlsByInfos(n, e, M.map(function(D) {
    return {
      data: {},
      classNames: [],
      dir: D
    };
  }), o);
}
function renderAroundControls(n, t) {
  var e = n.renderState;
  e.renderDirectionMap || (e.renderDirectionMap = {});
  var o = n.state, R = o.renderPoses, N = o.rotation, M = o.direction, D = e.renderDirectionMap, L = n.props.zoom, B = M > 0 ? 1 : -1, $ = N / Math.PI * 180;
  return getKeys(D).map(function(k) {
    var U = DIRECTION_INDEXES[k];
    if (!U)
      return null;
    var z = (throttle($, 15) + B * DIRECTION_ROTATIONS[k] + 720) % 180;
    return t.createElement("div", {
      className: prefix("around-control"),
      "data-rotation": z,
      "data-direction": k,
      key: "direction-around-".concat(k),
      style: getControlTransform.apply(void 0, __spreadArray([N, L], U.map(function(X) {
        return R[X];
      }), !1))
    });
  });
}
function renderLine(n, t, e, o, R, N) {
  for (var M = [], D = 6; D < arguments.length; D++)
    M[D - 6] = arguments[D];
  var L = getRad$1(e, o), B = t ? throttle(L / Math.PI * 180, 15) % 180 : -1;
  return n.createElement("div", {
    key: "line".concat(N),
    className: prefix.apply(void 0, __spreadArray(["line", "direction", t ? "edge" : "", t], M, !1)),
    "data-rotation": B,
    "data-line-index": N,
    "data-direction": t,
    style: getLineStyle(e, o, R, L)
  });
}
function renderEdgeLines(n, t, e, o, R) {
  var N = e === !0 ? DIRECTIONS4 : e;
  return N.map(function(M, D) {
    var L = DIRECTION_INDEXES[M], B = L[0], $ = L[1];
    if ($ != null)
      return renderLine(n, M, o[B], o[$], R, "".concat(t, "Edge").concat(D), t);
  }).filter(Boolean);
}
function getRenderDirections(n) {
  return function(t, e) {
    var o = getProps(t.props, n).edge;
    return o && (o === !0 || o.length) ? __spreadArray(__spreadArray([], renderEdgeLines(e, n, o, t.state.renderPoses, t.props.zoom), !0), renderDiagonalDirections(t, n, e), !0) : renderAllDirections(t, n, e);
  };
}
function renderAllDirections(n, t, e) {
  return renderDirectionControls(n, DIRECTIONS, t, e);
}
function renderDiagonalDirections(n, t, e) {
  return renderDirectionControls(n, ["nw", "ne", "sw", "se"], t, e);
}
var Draggable = {
  name: "draggable",
  props: {
    draggable: Boolean,
    throttleDrag: Number,
    throttleDragRotate: Number,
    startDragRotate: Number,
    edgeDraggable: Boolean
  },
  events: {
    onDragStart: "dragStart",
    onDrag: "drag",
    onDragEnd: "dragEnd",
    onDragGroupStart: "dragGroupStart",
    onDragGroup: "dragGroup",
    onDragGroupEnd: "dragGroupEnd"
  },
  render: function(n, t) {
    var e = n.props, o = e.throttleDragRotate, R = e.zoom, N = n.state, M = N.dragInfo, D = N.beforeOrigin;
    if (!o || !M)
      return [];
    var L = M.dist;
    if (!L[0] && !L[1])
      return [];
    var B = getDistSize(L), $ = getRad$1(L, [0, 0]);
    return [t.createElement("div", {
      className: prefix("line", "horizontal", "dragline", "dashed"),
      key: "dragRotateGuideline",
      style: {
        width: "".concat(B, "px"),
        transform: "translate(".concat(D[0], "px, ").concat(D[1], "px) rotate(").concat($, "rad) scaleY(").concat(R, ")")
      }
    })];
  },
  dragStart: function(n, t) {
    var e = t.datas, o = t.parentEvent, R = t.parentGesto, N = n.state, M = N.target, D = N.gestos;
    if (D.draggable)
      return !1;
    D.draggable = R || n.targetGesto;
    var L = getComputedStyle$1$1(M);
    e.datas = {}, e.left = parseFloat(L.left || "") || 0, e.top = parseFloat(L.top || "") || 0, e.bottom = parseFloat(L.bottom || "") || 0, e.right = parseFloat(L.right || "") || 0, e.startValue = [0, 0], setDragStart(n, t), setDefaultTransformIndex(t, "translate"), startCheckSnapDrag(n, e), e.prevDist = [0, 0], e.prevBeforeDist = [0, 0], e.isDrag = !1, e.deltaOffset = [0, 0];
    var B = fillParams(n, t, __assign$2({
      set: function(k) {
        e.startValue = k;
      }
    }, fillTransformStartEvent(t))), $ = o || triggerEvent(n, "onDragStart", B);
    return $ !== !1 ? (e.isDrag = !0, n.state.dragInfo = {
      startRect: n.getRect(),
      dist: [0, 0]
    }) : (D.draggable = null, e.isPinch = !1), e.isDrag ? B : !1;
  },
  drag: function(n, t) {
    if (!!t) {
      resolveTransformEvent(t, "translate");
      var e = t.datas, o = t.parentEvent, R = t.parentFlag, N = t.isPinch, M = t.isRequest, D = t.deltaOffset, L = t.distX, B = t.distY, $ = e.isDrag, k = e.prevDist, U = e.prevBeforeDist, z = e.startValue;
      if (!!$) {
        D && (L += D[0], B += D[1]);
        var X = n.props, V = X.parentMoveable, W = o ? 0 : X.throttleDrag || 0, Y = o ? 0 : X.throttleDragRotate || 0, q = !1, Z = 0;
        if (!o && Y > 0 && (L || B)) {
          var J = X.startDragRotate || 0, Q = throttle(J + getRad$1([0, 0], [L, B]) * 180 / Math.PI, Y) - J, K = B * Math.abs(Math.cos((Q - 90) / 180 * Math.PI)), rt = L * Math.abs(Math.cos(Q / 180 * Math.PI)), tt = getDistSize([rt, K]);
          Z = Q * Math.PI / 180, L = tt * Math.cos(Z), B = tt * Math.sin(Z);
        }
        if (!N && !o && !R && (!Y || L || B)) {
          var nt = checkSnapBoundsDrag(n, L, B, Y, M || D, e), at = nt[0], lt = nt[1], ut = at.isSnap, dt = at.isBound, yt = at.offset, pt = lt.isSnap, gt = lt.isBound, xt = lt.offset;
          q = ut || pt || dt || gt, L += yt, B += xt;
        }
        var Lt = plus(getBeforeDragDist({
          datas: e,
          distX: L,
          distY: B
        }), z), mt = plus(getTransformDist({
          datas: e,
          distX: L,
          distY: B
        }), z);
        !Y && !q && (throttleArray(mt, W), throttleArray(Lt, W)), throttleArray(mt, TINY_NUM), throttleArray(Lt, TINY_NUM);
        var ct = minus(Lt, z), vt = minus(mt, z), Tt = minus(vt, k), Pt = minus(ct, U);
        e.prevDist = vt, e.prevBeforeDist = ct, e.passDelta = Tt, e.passDist = vt;
        var wt = e.left + ct[0], Mt = e.top + ct[1], ht = e.right - ct[0], $t = e.bottom - ct[1], At = convertTransformFormat(e, "translate(".concat(mt[0], "px, ").concat(mt[1], "px)"), "translate(".concat(vt[0], "px, ").concat(vt[1], "px)"));
        if (fillOriginalTransform(t, At), n.state.dragInfo.dist = o ? [0, 0] : vt, !(!o && !V && Tt.every(function(St) {
          return !St;
        }) && Pt.some(function(St) {
          return !St;
        }))) {
          var kt = n.state, Ot = kt.width, _t = kt.height, Gt = fillParams(n, t, __assign$2({
            transform: At,
            dist: vt,
            delta: Tt,
            translate: mt,
            beforeDist: ct,
            beforeDelta: Pt,
            beforeTranslate: Lt,
            left: wt,
            top: Mt,
            right: ht,
            bottom: $t,
            width: Ot,
            height: _t,
            isPinch: N
          }, fillCSSObject({
            transform: At
          }, t)));
          return !o && triggerEvent(n, "onDrag", Gt), Gt;
        }
      }
    }
  },
  dragAfter: function(n, t) {
    var e = t.datas, o = e.deltaOffset;
    return o[0] || o[1] ? (e.deltaOffset = [0, 0], this.drag(n, __assign$2(__assign$2({}, t), {
      deltaOffset: o
    }))) : !1;
  },
  dragEnd: function(n, t) {
    var e = t.parentEvent, o = t.datas;
    if (n.state.dragInfo = null, !!o.isDrag) {
      o.isDrag = !1;
      var R = fillEndParams(n, t, {});
      return !e && triggerEvent(n, "onDragEnd", R), R;
    }
  },
  dragGroupStart: function(n, t) {
    var e = t.datas, o = t.clientX, R = t.clientY, N = this.dragStart(n, t);
    if (!N)
      return !1;
    var M = triggerChildGesto(n, this, "dragStart", [o || 0, R || 0], t, !1, "draggable"), D = __assign$2(__assign$2({}, N), {
      targets: n.props.targets,
      events: M
    }), L = triggerEvent(n, "onDragGroupStart", D);
    return e.isDrag = L !== !1, e.isDrag ? N : !1;
  },
  dragGroup: function(n, t) {
    var e = t.datas;
    if (!!e.isDrag) {
      var o = this.drag(n, t), R = t.datas.passDelta, N = triggerChildGesto(n, this, "drag", R, t, !1, "draggable");
      if (!!o) {
        var M = __assign$2({
          targets: n.props.targets,
          events: N
        }, o);
        return triggerEvent(n, "onDragGroup", M), M;
      }
    }
  },
  dragGroupEnd: function(n, t) {
    var e = t.isDrag, o = t.datas;
    if (!!o.isDrag) {
      this.dragEnd(n, t);
      var R = triggerChildGesto(n, this, "dragEnd", [0, 0], t, !1, "draggable");
      return triggerEvent(n, "onDragGroupEnd", fillEndParams(n, t, {
        targets: n.props.targets,
        events: R
      })), e;
    }
  },
  request: function(n) {
    var t = {}, e = n.getRect(), o = 0, R = 0;
    return {
      isControl: !1,
      requestStart: function() {
        return {
          datas: t
        };
      },
      request: function(N) {
        return "x" in N ? o = N.x - e.left : "deltaX" in N && (o += N.deltaX), "y" in N ? R = N.y - e.top : "deltaY" in N && (R += N.deltaY), {
          datas: t,
          distX: o,
          distY: R
        };
      },
      requestEnd: function() {
        return {
          datas: t,
          isDrag: !0
        };
      }
    };
  },
  unset: function(n) {
    n.state.gestos.draggable = null, n.state.dragInfo = null;
  }
}, directionCondition$1 = getDirectionCondition("resizable"), Resizable = {
  name: "resizable",
  ableGroup: "size",
  canPinch: !0,
  props: {
    resizable: Boolean,
    throttleResize: Number,
    renderDirections: Array,
    keepRatio: Boolean,
    resizeFormat: Function,
    keepRatioFinally: Boolean,
    edge: Boolean
  },
  events: {
    onResizeStart: "resizeStart",
    onBeforeResize: "beforeResize",
    onResize: "resize",
    onResizeEnd: "resizeEnd",
    onResizeGroupStart: "resizeGroupStart",
    onBeforeResizeGroup: "beforeResizeGroup",
    onResizeGroup: "resizeGroup",
    onResizeGroupEnd: "resizeGroupEnd"
  },
  render: getRenderDirections("resizable"),
  dragControlCondition: directionCondition$1,
  dragControlStart: function(n, t) {
    var e, o = t.inputEvent, R = t.isPinch, N = t.isGroup, M = t.parentDirection, D = t.parentGesto, L = t.datas, B = t.parentFixedDirection, $ = t.parentEvent, k = M || (R ? [0, 0] : getDirection(o.target)), U = n.state, z = U.target, X = U.width, V = U.height, W = U.gestos;
    if (!k || !z || W.resizable)
      return !1;
    W.resizable = D || n.controlGesto, !R && setDragStart(n, t), L.datas = {}, L.direction = k, L.startOffsetWidth = X, L.startOffsetHeight = V, L.prevWidth = 0, L.prevHeight = 0, L.minSize = [0, 0], L.startWidth = U.cssWidth, L.startHeight = U.cssHeight, L.maxSize = [1 / 0, 1 / 0], N || (L.minSize = [U.minOffsetWidth, U.minOffsetHeight], L.maxSize = [U.maxOffsetWidth, U.maxOffsetHeight]);
    var Y = n.props.transformOrigin || "% %";
    L.transformOrigin = Y && isString$1(Y) ? Y.split(" ") : Y, L.startOffsetMatrix = U.offsetMatrix, L.startTransformOrigin = U.transformOrigin, L.isWidth = (e = t == null ? void 0 : t.parentIsWidth) !== null && e !== void 0 ? e : !k[0] && !k[1] || k[0] || !k[1];
    function q(tt) {
      L.ratio = tt && isFinite(tt) ? tt : 0;
    }
    L.startPositions = getAbsolutePosesByState(n.state);
    function Z(tt) {
      L.fixedDirection = tt, L.fixedPosition = getPosByDirection(L.startPositions, tt);
    }
    function J(tt) {
      L.minSize = [convertUnitSize("".concat(tt[0]), 0) || 0, convertUnitSize("".concat(tt[1]), 0) || 0];
    }
    function Q(tt) {
      var nt = [tt[0] || 1 / 0, tt[1] || 1 / 0];
      (!isNumber(nt[0]) || isFinite(nt[0])) && (nt[0] = convertUnitSize("".concat(nt[0]), 0) || 1 / 0), (!isNumber(nt[1]) || isFinite(nt[1])) && (nt[1] = convertUnitSize("".concat(nt[1]), 0) || 1 / 0), L.maxSize = nt;
    }
    q(X / V), Z(B || [-k[0], -k[1]]), L.setFixedDirection = Z, L.setMin = J, L.setMax = Q;
    var K = fillParams(n, t, {
      direction: k,
      startRatio: L.ratio,
      set: function(tt) {
        var nt = tt[0], at = tt[1];
        L.startWidth = nt, L.startHeight = at;
      },
      setMin: J,
      setMax: Q,
      setRatio: q,
      setFixedDirection: Z,
      setOrigin: function(tt) {
        L.transformOrigin = tt;
      },
      dragStart: Draggable.dragStart(n, new CustomGesto().dragStart([0, 0], t))
    }), rt = $ || triggerEvent(n, "onResizeStart", K);
    return L.startFixedDirection = L.fixedDirection, rt !== !1 && (L.isResize = !0, n.state.snapRenderInfo = {
      request: t.isRequest,
      direction: k
    }), L.isResize ? K : !1;
  },
  dragControl: function(n, t) {
    var e, o = t.datas, R = t.parentFlag, N = t.isPinch, M = t.parentKeepRatio, D = t.dragClient, L = t.parentDist, B = t.isRequest, $ = t.isGroup, k = t.parentEvent, U = t.resolveMatrix, z = o.isResize, X = o.transformOrigin, V = o.startWidth, W = o.startHeight, Y = o.prevWidth, q = o.prevHeight, Z = o.minSize, J = o.maxSize, Q = o.ratio, K = o.startOffsetWidth, rt = o.startOffsetHeight, tt = o.isWidth;
    if (!z)
      return;
    if (U) {
      var nt = n.state.is3d, at = o.startOffsetMatrix, lt = o.startTransformOrigin, ut = nt ? 4 : 3, dt = parseMat(getNextTransforms(t)), yt = Math.sqrt(dt.length);
      ut !== yt && (dt = convertDimension(dt, yt, ut));
      var pt = getNextMatrix(at, dt, lt, ut), gt = calculatePoses(pt, K, rt, ut);
      o.startPositions = gt, o.nextTargetMatrix = dt, o.nextAllMatrix = pt;
    }
    var xt = getProps(n.props, "resizable"), Lt = xt.resizeFormat, mt = xt.throttleResize, ct = mt === void 0 ? R ? 0 : 1 : mt, vt = xt.parentMoveable, Tt = xt.keepRatioFinally, Pt = o.direction, wt = Pt, Mt = 0, ht = 0;
    !Pt[0] && !Pt[1] && (wt = [1, 1]);
    var $t = Q && (M != null ? M : xt.keepRatio) || !1;
    function At() {
      var Qt = o.fixedDirection, Ie = getOffsetSizeDist(wt, $t, o, t);
      Mt = Ie.distWidth, ht = Ie.distHeight;
      var de = wt[0] - Qt[0] || $t ? Math.max(K + Mt, TINY_NUM) : K, ue = wt[1] - Qt[1] || $t ? Math.max(rt + ht, TINY_NUM) : rt;
      return $t && K && rt && (tt ? ue = de / Q : de = ue * Q), [de, ue];
    }
    var kt = At(), Ot = kt[0], _t = kt[1];
    k || (o.setFixedDirection(o.fixedDirection), triggerEvent(n, "onBeforeResize", fillParams(n, t, {
      startFixedDirection: o.startFixedDirection,
      setFixedDirection: function(Qt) {
        var Ie;
        return o.setFixedDirection(Qt), Ie = At(), Ot = Ie[0], _t = Ie[1], [Ot, _t];
      },
      boundingWidth: Ot,
      boundingHeight: _t,
      setSize: function(Qt) {
        Ot = Qt[0], _t = Qt[1];
      }
    }, !0)));
    var Gt = D;
    D || (!R && N ? Gt = getAbsolutePosition(n, [0, 0]) : Gt = o.fixedPosition);
    var St = [0, 0];
    N || (St = checkSnapResize(n, Ot, _t, Pt, Gt, B, o)), L && (!L[0] && (St[0] = 0), !L[1] && (St[1] = 0));
    function Et() {
      var Qt;
      Lt && (Qt = Lt([Ot, _t]), Ot = Qt[0], _t = Qt[1]), Ot = throttle(Ot, ct), _t = throttle(_t, ct);
    }
    if ($t) {
      wt[0] && wt[1] && St[0] && St[1] && (Math.abs(St[0]) > Math.abs(St[1]) ? St[1] = 0 : St[0] = 0);
      var Rt = !St[0] && !St[1];
      Rt && Et(), wt[0] && !wt[1] || St[0] && !St[1] || Rt && tt ? (Ot += St[0], _t = Ot / Q) : (!wt[0] && wt[1] || !St[0] && St[1] || Rt && !tt) && (_t += St[1], Ot = _t * Q);
    } else
      Ot += St[0], _t += St[1], Ot = Math.max(0, Ot), _t = Math.max(0, _t);
    e = calculateBoundSize([Ot, _t], Z, J, $t ? Q : !1), Ot = e[0], _t = e[1], Et(), $t && ($ || Tt) && (tt ? _t = Ot / Q : Ot = _t * Q), Mt = Ot - K, ht = _t - rt;
    var Dt = [Mt - Y, ht - q];
    o.prevWidth = Mt, o.prevHeight = ht;
    var Ct = getResizeDist(n, Ot, _t, Gt, X, o);
    if (!(!vt && Dt.every(function(Qt) {
      return !Qt;
    }) && Ct.every(function(Qt) {
      return !Qt;
    }))) {
      var Zt = Draggable.drag(n, setCustomDrag(t, n.state, Ct, !!N, !1, "draggable")), Yt = Zt.transform, se = V + Mt, xe = W + ht, Oe = fillParams(n, t, __assign$2({
        width: se,
        height: xe,
        offsetWidth: Math.round(Ot),
        offsetHeight: Math.round(_t),
        startRatio: Q,
        boundingWidth: Ot,
        boundingHeight: _t,
        direction: Pt,
        dist: [Mt, ht],
        delta: Dt,
        isPinch: !!N,
        drag: Zt
      }, fillAfterTransform({
        style: {
          width: "".concat(se, "px"),
          height: "".concat(xe, "px")
        },
        transform: Yt
      }, Zt, t)));
      return !k && triggerEvent(n, "onResize", Oe), Oe;
    }
  },
  dragControlAfter: function(n, t) {
    var e = t.datas, o = e.isResize, R = e.startOffsetWidth, N = e.startOffsetHeight, M = e.prevWidth, D = e.prevHeight;
    if (!!o) {
      var L = n.state, B = L.width, $ = L.height, k = B - (R + M), U = $ - (N + D), z = Math.abs(k) > 3, X = Math.abs(U) > 3;
      if (z && (e.startWidth += k, e.startOffsetWidth += k, e.prevWidth += k), X && (e.startHeight += U, e.startOffsetHeight += U, e.prevHeight += U), z || X)
        return this.dragControl(n, t);
    }
  },
  dragControlEnd: function(n, t) {
    var e = t.datas, o = t.parentEvent;
    if (!!e.isResize) {
      e.isResize = !1;
      var R = fillEndParams(n, t, {});
      return !o && triggerEvent(n, "onResizeEnd", R), R;
    }
  },
  dragGroupControlCondition: directionCondition$1,
  dragGroupControlStart: function(n, t) {
    var e = t.datas, o = this.dragControlStart(n, __assign$2(__assign$2({}, t), {
      isGroup: !0
    }));
    if (!o)
      return !1;
    var R = fillChildEvents(n, "resizable", t);
    function N(X, V) {
      var W = e.fixedDirection, Y = e.fixedPosition, q = V.datas.startPositions || getAbsolutePosesByState(X.state), Z = getPosByDirection(q, W), J = calculate(createRotateMatrix(-n.rotation / 180 * Math.PI, 3), [Z[0] - Y[0], Z[1] - Y[1], 1], 3), Q = J[0], K = J[1];
      return V.datas.originalX = Q, V.datas.originalY = K, V;
    }
    var M = e.startOffsetWidth, D = e.startOffsetHeight;
    function L() {
      var X = e.minSize;
      R.forEach(function(V) {
        var W = V.datas, Y = W.minSize, q = W.startOffsetWidth, Z = W.startOffsetHeight, J = M * (q ? Y[0] / q : 0), Q = D * (Z ? Y[1] / Z : 0);
        X[0] = Math.max(X[0], J), X[1] = Math.max(X[1], Q);
      });
    }
    function B() {
      var X = e.maxSize;
      R.forEach(function(V) {
        var W = V.datas, Y = W.maxSize, q = W.startOffsetWidth, Z = W.startOffsetHeight, J = M * (q ? Y[0] / q : 0), Q = D * (Z ? Y[1] / Z : 0);
        X[0] = Math.min(X[0], J), X[1] = Math.min(X[1], Q);
      });
    }
    var $ = triggerChildAbles(n, this, "dragControlStart", t, function(X, V) {
      return N(X, V);
    });
    L(), B();
    var k = function(X) {
      o.setFixedDirection(X), $.forEach(function(V, W) {
        V.setFixedDirection(X), N(V.moveable, R[W]);
      });
    };
    e.setFixedDirection = k;
    var U = __assign$2(__assign$2({}, o), {
      targets: n.props.targets,
      events: $.map(function(X) {
        return __assign$2(__assign$2({}, X), {
          setMin: function(V) {
            X.setMin(V), L();
          },
          setMax: function(V) {
            X.setMax(V), B();
          }
        });
      }),
      setFixedDirection: k,
      setMin: function(X) {
        o.setMin(X), L();
      },
      setMax: function(X) {
        o.setMax(X), B();
      }
    }), z = triggerEvent(n, "onResizeGroupStart", U);
    return e.isResize = z !== !1, e.isResize ? o : !1;
  },
  dragGroupControl: function(n, t) {
    var e = t.datas;
    if (!!e.isResize) {
      var o = getProps(n.props, "resizable");
      catchEvent(n, "onBeforeResize", function(z) {
        triggerEvent(n, "onBeforeResizeGroup", fillParams(n, t, __assign$2(__assign$2({}, z), {
          targets: o.targets
        }), !0));
      });
      var R = this.dragControl(n, __assign$2(__assign$2({}, t), {
        isGroup: !0
      }));
      if (!!R) {
        var N = R.boundingWidth, M = R.boundingHeight, D = R.dist, L = o.keepRatio, B = [N / (N - D[0]), M / (M - D[1])], $ = e.fixedPosition, k = triggerChildAbles(n, this, "dragControl", t, function(z, X) {
          var V = calculate(createRotateMatrix(n.rotation / 180 * Math.PI, 3), [X.datas.originalX * B[0], X.datas.originalY * B[1], 1], 3), W = V[0], Y = V[1];
          return __assign$2(__assign$2({}, X), {
            parentDist: null,
            parentScale: B,
            dragClient: plus($, [W, Y]),
            parentKeepRatio: L
          });
        }), U = __assign$2({
          targets: o.targets,
          events: k
        }, R);
        return triggerEvent(n, "onResizeGroup", U), U;
      }
    }
  },
  dragGroupControlEnd: function(n, t) {
    var e = t.isDrag, o = t.datas;
    if (!!o.isResize) {
      this.dragControlEnd(n, t);
      var R = triggerChildAbles(n, this, "dragControlEnd", t), N = fillEndParams(n, t, {
        targets: n.props.targets,
        events: R
      });
      return triggerEvent(n, "onResizeGroupEnd", N), e;
    }
  },
  request: function(n) {
    var t = {}, e = 0, o = 0, R = n.getRect();
    return {
      isControl: !0,
      requestStart: function(N) {
        var M;
        return {
          datas: t,
          parentDirection: N.direction || [1, 1],
          parentIsWidth: (M = N == null ? void 0 : N.horizontal) !== null && M !== void 0 ? M : !0
        };
      },
      request: function(N) {
        return "offsetWidth" in N ? e = N.offsetWidth - R.offsetWidth : "deltaWidth" in N && (e += N.deltaWidth), "offsetHeight" in N ? o = N.offsetHeight - R.offsetHeight : "deltaHeight" in N && (o += N.deltaHeight), {
          datas: t,
          parentDist: [e, o],
          parentKeepRatio: N.keepRatio
        };
      },
      requestEnd: function() {
        return {
          datas: t,
          isDrag: !0
        };
      }
    };
  },
  unset: function(n) {
    n.state.gestos.resizable = null;
  }
};
function setRotateStartInfo(n, t, e, o, R) {
  var N = n.props.groupable, M = n.state, D = M.is3d ? 4 : 3, L = t.origin, B = calculatePosition(
    n.state.rootMatrix,
    minus([L[0], L[1]], N ? [0, 0] : [M.left, M.top]),
    D
  ), $ = plus([R.left, R.top], B);
  t.startAbsoluteOrigin = $, t.prevDeg = getRad$1($, [e, o]) / Math.PI * 180, t.defaultDeg = t.prevDeg, t.prevSnapDeg = 0, t.loop = 0, t.startDist = getDist$2($, [e, o]);
}
function getAbsoluteDist(n, t, e) {
  var o = e.defaultDeg, R = e.prevDeg, N = R % 360, M = Math.floor(R / 360);
  N < 0 && (N += 360), N > n && N > 270 && n < 90 ? ++M : N < n && N < 90 && n > 270 && --M;
  var D = t * (M * 360 + n - o);
  return e.prevDeg = o + D, D;
}
function getAbsoluteDistByClient(n, t, e, o) {
  return getAbsoluteDist(getRad$1(o.startAbsoluteOrigin, [n, t]) / Math.PI * 180, e, o);
}
function getRotateInfo(n, t, e, o, R, N) {
  var M = n.props.throttleRotate, D = M === void 0 ? 0 : M, L = o, B = e.prevSnapDeg;
  N && (L = checkSnapRotate(n, t, e.origin, L));
  var $ = throttle(R + L, D), k = $ - R;
  return e.prevSnapDeg = k, [k - B, L, $];
}
function getRotationPositions(n, t, e) {
  var o = t[0], R = t[1], N = t[2], M = t[3];
  if (n !== "none") {
    var D = (n || "top").split("-"), L = D[0], B = D[1], $ = [o, R];
    L === "left" ? $ = [N, o] : L === "right" ? $ = [R, M] : L === "bottom" && ($ = [M, N]);
    var k = [($[0][0] + $[1][0]) / 2, ($[0][1] + $[1][1]) / 2], U = getRotationRad($, e);
    if (B) {
      var z = B === "top" || B === "left", X = L === "bottom" || L === "left";
      k = $[z && !X || !z && X ? 0 : 1];
    }
    return [k, U];
  }
}
function dragControlCondition(n, t) {
  if (t.isRequest)
    return t.requestAble === "rotatable";
  var e = t.inputEvent.target;
  if (hasClass(e, prefix("rotation-control")) || hasClass(e, prefix("around-control")) || hasClass(e, prefix("control")) && hasClass(e, prefix("rotatable")))
    return !0;
  var o = n.props.rotationTarget;
  return o ? getRefTargets(o, !0).some(function(R) {
    return R ? e === R || e.contains(R) : !1;
  }) : !1;
}
var directionCSS = DIRECTIONS.map(function(n) {
  var t = "", e = "", o = "center", R = "center";
  return n.indexOf("n") > -1 && (t = "top: -20px;", R = "bottom"), n.indexOf("s") > -1 && (t = "top: 0px;", R = "top"), n.indexOf("w") > -1 && (e = "left: -20px;", o = "right"), n.indexOf("e") > -1 && (e = "left: 0px;", o = "left"), '.around-control[data-direction*="'.concat(n, `"] {
        `).concat(e).concat(t, `
        transform-origin: `).concat(o, " ").concat(R, `;
    }`);
}).join(`
`), css = `.rotation {
    position: absolute;
    height: 40px;
    width: 1px;
    transform-origin: 50% 100%;
    height: calc(40px * var(--zoom));
    top: auto;
    left: 0;
    bottom: 100%;
    will-change: transform;
}
.rotation .rotation-line {
    display: block;
    width: 100%;
    height: 100%;
    transform-origin: 50% 50%;
}
.rotation .rotation-control {
    border-color: #4af;
    border-color: var(--moveable-color);
    background:#fff;
    cursor: alias;
}
.rotatable.direction.control {
    cursor: alias;
}
.around-control {
    position: absolute;
    will-change: transform;
    width: 20px;
    height: 20px;
    left: -10px;
    top: -10px;
    box-sizing: border-box;
    background: transparent;
    z-index: 8;
    cursor: alias;
    transform-origin: center center;
}
.rotatable.direction.control.move {
    cursor: move;
}
`.concat(directionCSS, `
`), Rotatable = {
  name: "rotatable",
  canPinch: !0,
  props: {
    rotatable: Boolean,
    rotationPosition: String,
    throttleRotate: Number,
    renderDirections: Object,
    rotationTarget: Object,
    rotateAroundControls: Boolean,
    edge: Boolean,
    resolveAblesWithRotatable: Object
  },
  events: {
    onRotateStart: "rotateStart",
    onBeforeRotate: "beforeRotate",
    onRotate: "rotate",
    onRotateEnd: "rotateEnd",
    onRotateGroupStart: "rotateGroupStart",
    onBeforeRotateGroup: "beforeRotateGroup",
    onRotateGroup: "rotateGroup",
    onRotateGroupEnd: "rotateGroupEnd"
  },
  css: [css],
  render: function(n, t) {
    var e = getProps(n.props, "rotatable"), o = e.rotatable, R = e.rotationPosition, N = e.zoom, M = e.renderDirections, D = e.rotateAroundControls, L = e.resolveAblesWithRotatable, B = n.state, $ = B.renderPoses, k = B.direction;
    if (!o)
      return null;
    var U = getRotationPositions(R, $, k), z = [];
    if (U) {
      var X = U[0], V = U[1];
      z.push(t.createElement("div", {
        key: "rotation",
        className: prefix("rotation"),
        style: {
          transform: "translate(-50%) translate(".concat(X[0], "px, ").concat(X[1], "px) rotate(").concat(V, "rad)")
        }
      }, t.createElement("div", {
        className: prefix("line rotation-line"),
        style: {
          transform: "scaleX(".concat(N, ")")
        }
      }), t.createElement("div", {
        className: prefix("control rotation-control"),
        style: {
          transform: "translate(0.5px) scale(".concat(N, ")")
        }
      })));
    }
    if (M) {
      var W = getKeys(L || {}), Y = {};
      W.forEach(function(Z) {
        L[Z].forEach(function(J) {
          Y[J] = Z;
        });
      });
      var q = [];
      isArray(M) && (q = M.map(function(Z) {
        var J = Y[Z];
        return {
          data: J ? {
            resolve: J
          } : {},
          classNames: J ? ["move"] : [],
          dir: Z
        };
      })), z.push.apply(z, renderDirectionControlsByInfos(n, "rotatable", q, t));
    }
    return D && z.push.apply(z, renderAroundControls(n, t)), z;
  },
  dragControlCondition,
  dragControlStart: function(n, t) {
    var e, o, R = t.datas, N = t.clientX, M = t.clientY, D = t.parentRotate, L = t.parentFlag, B = t.isPinch, $ = t.isRequest, k = n.state, U = k.target, z = k.left, X = k.top, V = k.direction, W = k.beforeDirection, Y = k.targetTransform, q = k.moveableClientRect, Z = k.offsetMatrix, J = k.targetMatrix, Q = k.allMatrix, K = k.width, rt = k.height;
    if (!$ && !U)
      return !1;
    var tt = n.getRect();
    R.rect = tt, R.transform = Y, R.left = z, R.top = X;
    var nt = function(wt) {
      R.fixedDirection = wt, R.fixedPosition = getDirectionOffset(n, wt), ct && ct.setFixedDirection(wt);
    }, at = N, lt = M;
    if ($ || B || L) {
      var ut = D || 0;
      R.beforeInfo = {
        origin: tt.beforeOrigin,
        prevDeg: ut,
        defaultDeg: ut,
        prevSnapDeg: 0,
        startDist: 0
      }, R.afterInfo = __assign$2(__assign$2({}, R.beforeInfo), {
        origin: tt.origin
      }), R.absoluteInfo = __assign$2(__assign$2({}, R.beforeInfo), {
        origin: tt.origin,
        startValue: ut
      });
    } else {
      var dt = (o = t.inputEvent) === null || o === void 0 ? void 0 : o.target;
      if (dt) {
        var yt = dt.getAttribute("data-direction") || "", pt = DIRECTION_REGION_TO_DIRECTION[yt];
        if (pt) {
          R.isControl = !0, R.isAroundControl = hasClass(dt, prefix("around-control")), R.controlDirection = pt;
          var gt = dt.getAttribute("data-resolve");
          gt && (R.resolveAble = gt);
          var xt = calculateMoveableClientPositions(k.rootMatrix, k.renderPoses, q);
          e = getPosByDirection(xt, pt), at = e[0], lt = e[1];
        }
      }
      R.beforeInfo = {
        origin: tt.beforeOrigin
      }, R.afterInfo = {
        origin: tt.origin
      }, R.absoluteInfo = {
        origin: tt.origin,
        startValue: tt.rotation
      };
      var Lt = nt;
      nt = function(wt) {
        var Mt = k.is3d ? 4 : 3, ht = getPosByDirection([[0, 0], [K, 0], [0, rt], [K, rt]], wt), $t = plus(getOrigin(J, Mt), ht), At = $t[0], kt = $t[1], Ot = calculate(Z, convertPositionMatrix([At, kt], Mt)), _t = calculate(Q, convertPositionMatrix([ht[0], ht[1]], Mt));
        Lt(wt), R.beforeInfo.origin = Ot, R.afterInfo.origin = _t, R.absoluteInfo.origin = _t, setRotateStartInfo(n, R.beforeInfo, at, lt, q), setRotateStartInfo(n, R.afterInfo, at, lt, q), setRotateStartInfo(n, R.absoluteInfo, at, lt, q);
      };
    }
    R.startClientX = at, R.startClientY = lt, R.direction = V, R.beforeDirection = W, R.startValue = 0, R.datas = {}, setDefaultTransformIndex(t, "rotate");
    var mt = !1, ct = !1;
    if (R.isControl && R.resolveAble) {
      var vt = R.resolveAble;
      vt === "resizable" && (ct = Resizable.dragControlStart(n, __assign$2(__assign$2({}, new CustomGesto("resizable").dragStart([0, 0], t)), {
        parentDirection: R.controlDirection,
        parentFixedDirection: R.fixedDirection
      })));
    }
    ct || (mt = Draggable.dragStart(n, new CustomGesto().dragStart([0, 0], t))), nt(getOriginDirection(n));
    var Tt = fillParams(n, t, __assign$2(__assign$2({
      set: function(wt) {
        R.startValue = wt * Math.PI / 180;
      },
      setFixedDirection: nt
    }, fillTransformStartEvent(t)), {
      dragStart: mt,
      resizeStart: ct
    })), Pt = triggerEvent(n, "onRotateStart", Tt);
    return R.isRotate = Pt !== !1, k.snapRenderInfo = {
      request: t.isRequest
    }, R.isRotate ? Tt : !1;
  },
  dragControl: function(n, t) {
    var e, o, R, N = t.datas, M = t.distX, D = t.distY, L = t.parentRotate, B = t.parentFlag, $ = t.isPinch, k = t.groupDelta, U = N.beforeDirection, z = N.beforeInfo, X = N.afterInfo, V = N.absoluteInfo, W = N.isRotate, Y = N.startValue, q = N.rect, Z = N.startClientX, J = N.startClientY;
    if (!!W) {
      resolveTransformEvent(t, "rotate");
      var Q = getTransformDirection(t), K = U * Q, rt = n.props.parentMoveable, tt = 0, nt, at, lt = 0, ut, dt, yt = 0, pt, gt, xt = 180 / Math.PI * Y, Lt = V.startValue, mt = !1, ct = Z + M, vt = J + D;
      if (!B && "parentDist" in t) {
        var Tt = t.parentDist;
        nt = Tt, ut = Tt, pt = Tt;
      } else
        $ || B ? (nt = getAbsoluteDist(L, U, z), ut = getAbsoluteDist(L, K, X), pt = getAbsoluteDist(L, K, V)) : (nt = getAbsoluteDistByClient(ct, vt, U, z), ut = getAbsoluteDistByClient(ct, vt, K, X), pt = getAbsoluteDistByClient(ct, vt, K, V), mt = !0);
      if (at = xt + nt, dt = xt + ut, gt = Lt + pt, triggerEvent(n, "onBeforeRotate", fillParams(n, t, {
        beforeRotation: at,
        rotation: dt,
        absoluteRotation: gt,
        setRotation: function(Gt) {
          ut = Gt - xt, nt = ut, pt = ut;
        }
      }, !0)), e = getRotateInfo(n, q, z, nt, xt, mt), tt = e[0], nt = e[1], at = e[2], o = getRotateInfo(n, q, X, ut, xt, mt), lt = o[0], ut = o[1], dt = o[2], R = getRotateInfo(n, q, V, pt, Lt, mt), yt = R[0], pt = R[1], gt = R[2], !(!yt && !lt && !tt && !rt)) {
        var Pt = convertTransformFormat(N, "rotate(".concat(dt, "deg)"), "rotate(".concat(ut, "deg)")), wt = getRotateDist(n, ut, N), Mt = minus(plus(k || [0, 0], wt), N.prevInverseDist || [0, 0]);
        N.prevInverseDist = wt, N.requestValue = null;
        var ht = fillTransformEvent(n, Pt, Mt, $, t), $t = ht, At = getDist$2([ct, vt], V.startAbsoluteOrigin) - V.startDist, kt = void 0;
        if (N.resolveAble === "resizable") {
          var Ot = Resizable.dragControl(n, __assign$2(__assign$2({}, setCustomDrag(t, n.state, [t.deltaX, t.deltaY], !!$, !1, "resizable")), {
            resolveMatrix: !0,
            parentDistance: At
          }));
          Ot && (kt = Ot, $t = fillAfterTransform($t, Ot, t));
        }
        var _t = fillParams(n, t, __assign$2(__assign$2({
          delta: lt,
          dist: ut,
          rotate: dt,
          rotation: dt,
          beforeDist: nt,
          beforeDelta: tt,
          beforeRotate: at,
          beforeRotation: at,
          absoluteDist: pt,
          absoluteDelta: yt,
          absoluteRotate: gt,
          absoluteRotation: gt,
          isPinch: !!$,
          resize: kt
        }, ht), $t));
        return triggerEvent(n, "onRotate", _t), _t;
      }
    }
  },
  dragControlAfter: function(n, t) {
    t.datas.requestValue;
  },
  dragControlEnd: function(n, t) {
    var e = t.datas;
    if (!!e.isRotate) {
      e.isRotate = !1;
      var o = fillEndParams(n, t, {});
      return triggerEvent(n, "onRotateEnd", o), o;
    }
  },
  dragGroupControlCondition: dragControlCondition,
  dragGroupControlStart: function(n, t) {
    var e = t.datas, o = n.state, R = o.left, N = o.top, M = o.beforeOrigin, D = this.dragControlStart(n, t);
    if (!D)
      return !1;
    D.set(e.beforeDirection * n.rotation);
    var L = triggerChildAbles(n, this, "dragControlStart", t, function(k, U) {
      var z = k.state, X = z.left, V = z.top, W = z.beforeOrigin, Y = plus(minus([X, V], [R, N]), minus(W, M));
      return U.datas.groupClient = Y, __assign$2(__assign$2({}, U), {
        parentRotate: 0
      });
    }), B = __assign$2(__assign$2({}, D), {
      targets: n.props.targets,
      events: L
    }), $ = triggerEvent(n, "onRotateGroupStart", B);
    return e.isRotate = $ !== !1, e.isRotate ? D : !1;
  },
  dragGroupControl: function(n, t) {
    var e = t.datas;
    if (!!e.isRotate) {
      catchEvent(n, "onBeforeRotate", function($) {
        triggerEvent(n, "onBeforeRotateGroup", fillParams(n, t, __assign$2(__assign$2({}, $), {
          targets: n.props.targets
        }), !0));
      });
      var o = this.dragControl(n, t);
      if (!!o) {
        var R = e.beforeDirection, N = o.beforeDist, M = o.beforeDelta, D = M / 180 * Math.PI, L = triggerChildAbles(n, this, "dragControl", t, function($, k) {
          var U = k.datas.groupClient, z = U[0], X = U[1], V = rotate([z, X], D * R), W = V[0], Y = V[1], q = [W - z, Y - X];
          return k.datas.groupClient = [W, Y], __assign$2(__assign$2({}, k), {
            parentRotate: N,
            groupDelta: q
          });
        });
        n.rotation = R * o.beforeRotation;
        var B = __assign$2({
          targets: n.props.targets,
          events: L,
          set: function($) {
            n.rotation = $;
          },
          setGroupRotation: function($) {
            n.rotation = $;
          }
        }, o);
        return triggerEvent(n, "onRotateGroup", B), B;
      }
    }
  },
  dragGroupControlEnd: function(n, t) {
    var e = t.isDrag, o = t.datas;
    if (!!o.isRotate) {
      this.dragControlEnd(n, t);
      var R = triggerChildAbles(n, this, "dragControlEnd", t), N = fillEndParams(n, t, {
        targets: n.props.targets,
        events: R
      });
      return triggerEvent(n, "onRotateGroupEnd", N), e;
    }
  },
  request: function(n) {
    var t = {}, e = 0, o = n.getRotation();
    return {
      isControl: !0,
      requestStart: function() {
        return {
          datas: t
        };
      },
      request: function(R) {
        return "deltaRotate" in R ? e += R.deltaRotate : "rotate" in R && (e = R.rotate - o), {
          datas: t,
          parentDist: e
        };
      },
      requestEnd: function() {
        return {
          datas: t,
          isDrag: !0
        };
      }
    };
  }
}, directionCondition = getDirectionCondition("scalable"), Scalable = {
  name: "scalable",
  ableGroup: "size",
  canPinch: !0,
  props: {
    scalable: Boolean,
    throttleScale: Number,
    renderDirections: String,
    keepRatio: Boolean,
    edge: Boolean
  },
  events: {
    onScaleStart: "scaleStart",
    onBeforeScale: "beforeScale",
    onScale: "scale",
    onScaleEnd: "scaleEnd",
    onScaleGroupStart: "scaleGroupStart",
    onBeforeScaleGroup: "beforeScaleGroup",
    onScaleGroup: "scaleGroup",
    onScaleGroupEnd: "scaleGroupEnd"
  },
  render: getRenderDirections("scalable"),
  dragControlCondition: directionCondition,
  dragControlStart: function(n, t) {
    var e = t.datas, o = t.isPinch, R = t.inputEvent, N = t.parentDirection, M = N || (o ? [0, 0] : getDirection(R.target)), D = n.state, L = D.width, B = D.height, $ = D.targetTransform, k = D.target, U = D.pos1, z = D.pos2, X = D.pos4;
    if (!M || !k)
      return !1;
    o || setDragStart(n, t), e.datas = {}, e.transform = $, e.prevDist = [1, 1], e.direction = M, e.startOffsetWidth = L, e.startOffsetHeight = B, e.startValue = [1, 1];
    var V = getDist$2(U, z), W = getDist$2(z, X), Y = !M[0] && !M[1] || M[0] || !M[1];
    e.scaleWidth = V, e.scaleHeight = W, e.scaleXRatio = V / L, e.scaleYRatio = W / B, setDefaultTransformIndex(t, "scale"), e.isWidth = Y;
    function q(K) {
      e.ratio = K && isFinite(K) ? K : 0;
    }
    e.startPositions = getAbsolutePosesByState(n.state);
    function Z(K) {
      e.fixedDirection = K, e.fixedPosition = getPosByDirection(e.startPositions, K);
    }
    e.setFixedDirection = Z, q(getDist$2(U, z) / getDist$2(z, X)), Z([-M[0], -M[1]]);
    var J = fillParams(n, t, __assign$2(__assign$2({
      direction: M,
      set: function(K) {
        e.startValue = K;
      },
      setRatio: q,
      setFixedDirection: Z
    }, fillTransformStartEvent(t)), {
      dragStart: Draggable.dragStart(n, new CustomGesto().dragStart([0, 0], t))
    })), Q = triggerEvent(n, "onScaleStart", J);
    return e.startFixedDirection = e.fixedDirection, Q !== !1 && (e.isScale = !0, n.state.snapRenderInfo = {
      request: t.isRequest,
      direction: M
    }), e.isScale ? J : !1;
  },
  dragControl: function(n, t) {
    resolveTransformEvent(t, "scale");
    var e = t.datas, o = t.parentKeepRatio, R = t.parentFlag, N = t.isPinch, M = t.dragClient, D = t.isRequest, L = e.prevDist, B = e.direction, $ = e.startOffsetWidth, k = e.startOffsetHeight, U = e.isScale, z = e.startValue, X = e.isWidth, V = e.ratio;
    if (!U)
      return !1;
    var W = n.props, Y = W.throttleScale, q = W.parentMoveable, Z = B;
    !B[0] && !B[1] && (Z = [1, 1]);
    var J = V && (o != null ? o : W.keepRatio) || !1, Q = n.state;
    function K() {
      var vt = getOffsetSizeDist(Z, J, e, t), Tt = vt.distWidth, Pt = vt.distHeight, wt = ($ + Tt) / $, Mt = (k + Pt) / k;
      return wt = Z[0] || J ? wt * z[0] : z[0], Mt = Z[1] || J ? Mt * z[1] : z[1], wt === 0 && (wt = (L[0] > 0 ? 1 : -1) * MIN_SCALE), Mt === 0 && (Mt = (L[1] > 0 ? 1 : -1) * MIN_SCALE), [wt, Mt];
    }
    var rt = K();
    if (!N && n.props.groupable) {
      var tt = Q.snapRenderInfo || {}, nt = tt.direction;
      isArray(nt) && (nt[0] || nt[1]) && (Q.snapRenderInfo = {
        direction: B,
        request: t.isRequest
      });
    }
    triggerEvent(n, "onBeforeScale", fillParams(n, t, {
      scale: rt,
      setFixedDirection: function(vt) {
        return e.setFixedDirection(vt), rt = K(), rt;
      },
      startFixedDirection: e.startFixedDirection,
      setScale: function(vt) {
        rt = vt;
      }
    }, !0));
    var at = [rt[0] / z[0], rt[1] / z[1]], lt = M, ut = [0, 0];
    if (M || (!R && N ? lt = getAbsolutePosition(n, [0, 0]) : lt = e.fixedPosition), N || (ut = checkSnapScale(n, at, B, D, e)), J) {
      Z[0] && Z[1] && ut[0] && ut[1] && (Math.abs(ut[0] * $) > Math.abs(ut[1] * k) ? ut[1] = 0 : ut[0] = 0);
      var dt = !ut[0] && !ut[1];
      if (dt && (X ? at[0] = throttle(at[0] * z[0], Y) / z[0] : at[1] = throttle(at[1] * z[1], Y) / z[1]), Z[0] && !Z[1] || ut[0] && !ut[1] || dt && X) {
        at[0] += ut[0];
        var yt = $ * at[0] * z[0] / V;
        at[1] = yt / k / z[1];
      } else if (!Z[0] && Z[1] || !ut[0] && ut[1] || dt && !X) {
        at[1] += ut[1];
        var pt = k * at[1] * z[1] * V;
        at[0] = pt / $ / z[0];
      }
    } else
      at[0] += ut[0], at[1] += ut[1], ut[0] || (at[0] = throttle(at[0] * z[0], Y) / z[0]), ut[1] || (at[1] = throttle(at[1] * z[1], Y) / z[1]);
    at[0] === 0 && (at[0] = (L[0] > 0 ? 1 : -1) * MIN_SCALE), at[1] === 0 && (at[1] = (L[1] > 0 ? 1 : -1) * MIN_SCALE);
    var gt = [at[0] / L[0], at[1] / L[1]];
    rt = multiply2(at, z);
    var xt = getScaleDist(n, at, e.fixedDirection, lt, e), Lt = minus(xt, e.prevInverseDist || [0, 0]);
    if (e.prevDist = at, e.prevInverseDist = xt, rt[0] === L[0] && rt[1] === L[1] && Lt.every(function(vt) {
      return !vt;
    }) && !q)
      return !1;
    var mt = convertTransformFormat(e, "scale(".concat(rt.join(", "), ")"), "scale(".concat(at.join(", "), ")")), ct = fillParams(n, t, __assign$2({
      offsetWidth: $,
      offsetHeight: k,
      direction: B,
      scale: rt,
      dist: at,
      delta: gt,
      isPinch: !!N
    }, fillTransformEvent(n, mt, Lt, N, t)));
    return triggerEvent(n, "onScale", ct), ct;
  },
  dragControlEnd: function(n, t) {
    var e = t.datas, o = t.isDrag;
    return e.isScale ? (e.isScale = !1, triggerEvent(n, "onScaleEnd", fillEndParams(n, t, {})), o) : !1;
  },
  dragGroupControlCondition: directionCondition,
  dragGroupControlStart: function(n, t) {
    var e = t.datas, o = this.dragControlStart(n, t);
    if (!o)
      return !1;
    var R = fillChildEvents(n, "resizable", t);
    function N($, k) {
      var U = e.fixedDirection, z = e.fixedPosition, X = k.datas.startPositions || getAbsolutePosesByState($.state), V = getPosByDirection(X, U), W = calculate(createRotateMatrix(-n.rotation / 180 * Math.PI, 3), [V[0] - z[0], V[1] - z[1], 1], 3), Y = W[0], q = W[1];
      return k.datas.originalX = Y, k.datas.originalY = q, k;
    }
    e.moveableScale = n.scale;
    var M = triggerChildAbles(n, this, "dragControlStart", t, function($, k) {
      return N($, k);
    }), D = function($) {
      o.setFixedDirection($), M.forEach(function(k, U) {
        k.setFixedDirection($), N(k.moveable, R[U]);
      });
    };
    e.setFixedDirection = D;
    var L = __assign$2(__assign$2({}, o), {
      targets: n.props.targets,
      events: M,
      setFixedDirection: D
    }), B = triggerEvent(n, "onScaleGroupStart", L);
    return e.isScale = B !== !1, e.isScale ? L : !1;
  },
  dragGroupControl: function(n, t) {
    var e = t.datas;
    if (!!e.isScale) {
      catchEvent(n, "onBeforeScale", function(k) {
        triggerEvent(n, "onBeforeScaleGroup", fillParams(n, t, __assign$2(__assign$2({}, k), {
          targets: n.props.targets
        }), !0));
      });
      var o = this.dragControl(n, t);
      if (!!o) {
        var R = e.moveableScale;
        n.scale = [o.scale[0] * R[0], o.scale[1] * R[1]];
        var N = n.props.keepRatio, M = o.dist, D = o.scale, L = e.fixedPosition, B = triggerChildAbles(n, this, "dragControl", t, function(k, U) {
          var z = calculate(createRotateMatrix(n.rotation / 180 * Math.PI, 3), [U.datas.originalX * M[0], U.datas.originalY * M[1], 1], 3), X = z[0], V = z[1];
          return __assign$2(__assign$2({}, U), {
            parentDist: null,
            parentScale: D,
            parentKeepRatio: N,
            dragClient: plus(L, [X, V])
          });
        }), $ = __assign$2({
          targets: n.props.targets,
          events: B
        }, o);
        return triggerEvent(n, "onScaleGroup", $), $;
      }
    }
  },
  dragGroupControlEnd: function(n, t) {
    var e = t.isDrag, o = t.datas;
    if (!!o.isScale) {
      this.dragControlEnd(n, t);
      var R = triggerChildAbles(n, this, "dragControlEnd", t), N = fillEndParams(n, t, {
        targets: n.props.targets,
        events: R
      });
      return triggerEvent(n, "onScaleGroupEnd", N), e;
    }
  },
  request: function() {
    var n = {}, t = 0, e = 0;
    return {
      isControl: !0,
      requestStart: function(o) {
        return {
          datas: n,
          parentDirection: o.direction || [1, 1]
        };
      },
      request: function(o) {
        return t += o.deltaWidth, e += o.deltaHeight, {
          datas: n,
          parentDist: [t, e],
          parentKeepRatio: o.keepRatio
        };
      },
      requestEnd: function() {
        return {
          datas: n,
          isDrag: !0
        };
      }
    };
  }
};
function getMiddleLinePos(n, t) {
  return n.map(function(e, o) {
    return dot(e, t[o], 1, 2);
  });
}
function getTriangleRad(n, t, e) {
  var o = getRad$1(n, t), R = getRad$1(n, e), N = R - o;
  return N >= 0 ? N : N + 2 * Math.PI;
}
function isValidPos(n, t) {
  var e = getTriangleRad(n[0], n[1], n[2]), o = getTriangleRad(t[0], t[1], t[2]), R = Math.PI;
  return !(e >= R && o <= R || e <= R && o >= R);
}
var Warpable = {
  name: "warpable",
  ableGroup: "size",
  props: {
    warpable: Boolean,
    renderDirections: Array,
    edge: Boolean
  },
  events: {
    onWarpStart: "warpStart",
    onWarp: "warp",
    onWarpEnd: "warpEnd"
  },
  render: function(n, t) {
    var e = n.props, o = e.resizable, R = e.scalable, N = e.warpable, M = e.zoom;
    if (o || R || !N)
      return [];
    var D = n.state, L = D.pos1, B = D.pos2, $ = D.pos3, k = D.pos4, U = getMiddleLinePos(L, B), z = getMiddleLinePos(B, L), X = getMiddleLinePos(L, $), V = getMiddleLinePos($, L), W = getMiddleLinePos($, k), Y = getMiddleLinePos(k, $), q = getMiddleLinePos(B, k), Z = getMiddleLinePos(k, B);
    return __spreadArray([t.createElement("div", {
      className: prefix("line"),
      key: "middeLine1",
      style: getLineStyle(U, W, M)
    }), t.createElement("div", {
      className: prefix("line"),
      key: "middeLine2",
      style: getLineStyle(z, Y, M)
    }), t.createElement("div", {
      className: prefix("line"),
      key: "middeLine3",
      style: getLineStyle(X, q, M)
    }), t.createElement("div", {
      className: prefix("line"),
      key: "middeLine4",
      style: getLineStyle(V, Z, M)
    })], renderAllDirections(n, "warpable", t), !0);
  },
  dragControlCondition: function(n, t) {
    if (t.isRequest)
      return !1;
    var e = t.inputEvent.target;
    return hasClass(e, prefix("direction")) && hasClass(e, prefix("warpable"));
  },
  dragControlStart: function(n, t) {
    var e = t.datas, o = t.inputEvent, R = n.props.target, N = o.target, M = getDirection(N);
    if (!M || !R)
      return !1;
    var D = n.state, L = D.transformOrigin, B = D.is3d, $ = D.targetTransform, k = D.targetMatrix, U = D.width, z = D.height, X = D.left, V = D.top;
    e.datas = {}, e.targetTransform = $, e.warpTargetMatrix = B ? k : convertDimension(k, 3, 4), e.targetInverseMatrix = ignoreDimension(invert(e.warpTargetMatrix, 4), 3, 4), e.direction = M, e.left = X, e.top = V, e.poses = [[0, 0], [U, 0], [0, z], [U, z]].map(function(q) {
      return minus(q, L);
    }), e.nextPoses = e.poses.map(function(q) {
      var Z = q[0], J = q[1];
      return calculate(e.warpTargetMatrix, [Z, J, 0, 1], 4);
    }), e.startValue = createIdentityMatrix(4), e.prevMatrix = createIdentityMatrix(4), e.absolutePoses = getAbsolutePosesByState(D), e.posIndexes = getPosIndexesByDirection(M), setDragStart(n, t), setDefaultTransformIndex(t, "matrix3d"), D.snapRenderInfo = {
      request: t.isRequest,
      direction: M
    };
    var W = fillParams(n, t, __assign$2({
      set: function(q) {
        e.startValue = q;
      }
    }, fillTransformStartEvent(t))), Y = triggerEvent(n, "onWarpStart", W);
    return Y !== !1 && (e.isWarp = !0), e.isWarp;
  },
  dragControl: function(n, t) {
    var e = t.datas, o = t.isRequest, R = t.distX, N = t.distY, M = e.targetInverseMatrix, D = e.prevMatrix, L = e.isWarp, B = e.startValue, $ = e.poses, k = e.posIndexes, U = e.absolutePoses;
    if (!L)
      return !1;
    if (resolveTransformEvent(t, "matrix3d"), hasGuidelines(n, "warpable")) {
      var z = k.map(function(nt) {
        return U[nt];
      });
      z.length > 1 && z.push([(z[0][0] + z[1][0]) / 2, (z[0][1] + z[1][1]) / 2]);
      var X = checkMoveableSnapBounds(n, o, {
        horizontal: z.map(function(nt) {
          return nt[1] + N;
        }),
        vertical: z.map(function(nt) {
          return nt[0] + R;
        })
      }), V = X.horizontal, W = X.vertical;
      N -= V.offset, R -= W.offset;
    }
    var Y = getDragDist({
      datas: e,
      distX: R,
      distY: N
    }, !0), q = e.nextPoses.slice();
    if (k.forEach(function(nt) {
      q[nt] = plus(q[nt], Y);
    }), !NEARBY_POS.every(function(nt) {
      return isValidPos(nt.map(function(at) {
        return $[at];
      }), nt.map(function(at) {
        return q[at];
      }));
    }))
      return !1;
    var Z = createWarpMatrix($[0], $[2], $[1], $[3], q[0], q[2], q[1], q[3]);
    if (!Z.length)
      return !1;
    var J = multiply(M, Z, 4), Q = getTransfromMatrix(e, J, !0), K = multiply(invert(D, 4), Q, 4);
    e.prevMatrix = Q;
    var rt = multiply(B, Q, 4), tt = convertTransformFormat(e, "matrix3d(".concat(rt.join(", "), ")"), "matrix3d(".concat(Q.join(", "), ")"));
    return fillOriginalTransform(t, tt), triggerEvent(n, "onWarp", fillParams(n, t, {
      delta: K,
      matrix: rt,
      dist: Q,
      multiply,
      transform: tt
    })), !0;
  },
  dragControlEnd: function(n, t) {
    var e = t.datas, o = t.isDrag;
    return e.isWarp ? (e.isWarp = !1, triggerEvent(n, "onWarpEnd", fillEndParams(n, t, {})), o) : !1;
  }
}, AREA_PIECES = /* @__PURE__ */ prefix("area-pieces"), AREA_PIECE = /* @__PURE__ */ prefix("area-piece"), AVOID = /* @__PURE__ */ prefix("avoid");
function restoreStyle(n) {
  var t = n.areaElement;
  if (!!t) {
    var e = n.state, o = e.width, R = e.height;
    removeClass(t, AVOID), t.style.cssText += "left: 0px; top: 0px; width: ".concat(o, "px; height: ").concat(R, "px");
  }
}
function renderPieces(n) {
  return n.createElement("div", {
    key: "area_pieces",
    className: AREA_PIECES
  }, n.createElement("div", {
    className: AREA_PIECE
  }), n.createElement("div", {
    className: AREA_PIECE
  }), n.createElement("div", {
    className: AREA_PIECE
  }), n.createElement("div", {
    className: AREA_PIECE
  }));
}
var DragArea = {
  name: "dragArea",
  props: {
    dragArea: Boolean,
    passDragArea: Boolean
  },
  events: {
    onClick: "click",
    onClickGroup: "clickGroup"
  },
  render: function(n, t) {
    var e = n.props, o = e.target, R = e.dragArea, N = e.groupable, M = e.passDragArea, D = n.state, L = D.width, B = D.height, $ = D.renderPoses, k = M ? prefix("area", "pass") : prefix("area");
    if (N)
      return [t.createElement("div", {
        key: "area",
        ref: ref(n, "areaElement"),
        className: k
      }), renderPieces(t)];
    if (!o || !R)
      return [];
    var U = createWarpMatrix([0, 0], [L, 0], [0, B], [L, B], $[0], $[1], $[2], $[3]), z = U.length ? makeMatrixCSS(U, !0) : "none";
    return [t.createElement("div", {
      key: "area",
      ref: ref(n, "areaElement"),
      className: k,
      style: {
        top: "0px",
        left: "0px",
        width: "".concat(L, "px"),
        height: "".concat(B, "px"),
        transformOrigin: "0 0",
        transform: z
      }
    }), renderPieces(t)];
  },
  dragStart: function(n, t) {
    var e = t.datas, o = t.clientX, R = t.clientY, N = t.inputEvent;
    if (!N)
      return !1;
    e.isDragArea = !1;
    var M = n.areaElement, D = n.state, L = D.moveableClientRect, B = D.renderPoses, $ = D.rootMatrix, k = D.is3d, U = L.left, z = L.top, X = getRect(B), V = X.left, W = X.top, Y = X.width, q = X.height, Z = k ? 4 : 3, J = calculateInversePosition($, [o - U, R - z], Z), Q = J[0], K = J[1];
    Q -= V, K -= W;
    var rt = [{
      left: V,
      top: W,
      width: Y,
      height: K - 10
    }, {
      left: V,
      top: W,
      width: Q - 10,
      height: q
    }, {
      left: V,
      top: W + K + 10,
      width: Y,
      height: q - K - 10
    }, {
      left: V + Q + 10,
      top: W,
      width: Y - Q - 10,
      height: q
    }], tt = [].slice.call(M.nextElementSibling.children);
    rt.forEach(function(nt, at) {
      tt[at].style.cssText = "left: ".concat(nt.left, "px;top: ").concat(nt.top, "px; width: ").concat(nt.width, "px; height: ").concat(nt.height, "px;");
    }), addClass(M, AVOID), D.disableNativeEvent = !0;
  },
  drag: function(n, t) {
    var e = t.datas, o = t.inputEvent;
    if (this.enableNativeEvent(n), !o)
      return !1;
    e.isDragArea || (e.isDragArea = !0, restoreStyle(n));
  },
  dragEnd: function(n, t) {
    this.enableNativeEvent(n);
    var e = t.inputEvent, o = t.datas;
    if (!e)
      return !1;
    o.isDragArea || restoreStyle(n);
  },
  dragGroupStart: function(n, t) {
    return this.dragStart(n, t);
  },
  dragGroup: function(n, t) {
    return this.drag(n, t);
  },
  dragGroupEnd: function(n, t) {
    return this.dragEnd(n, t);
  },
  unset: function(n) {
    restoreStyle(n), n.state.disableNativeEvent = !1;
  },
  enableNativeEvent: function(n) {
    var t = n.state;
    t.disableNativeEvent && requestAnimationFrame$1(function() {
      t.disableNativeEvent = !1;
    });
  }
}, Origin = makeAble("origin", {
  render: function(n, t) {
    var e = n.props.zoom, o = n.state, R = o.beforeOrigin, N = o.rotation;
    return [t.createElement("div", {
      className: prefix("control", "origin"),
      style: getControlTransform(N, e, R),
      key: "beforeOrigin"
    })];
  }
});
function getDefaultScrollPosition(n) {
  var t = n.scrollContainer;
  return [t.scrollLeft, t.scrollTop];
}
var Scrollable = {
  name: "scrollable",
  canPinch: !0,
  props: {
    scrollable: Boolean,
    scrollContainer: Object,
    scrollThreshold: Number,
    getScrollPosition: Function
  },
  events: {
    onScroll: "scroll",
    onScrollGroup: "scrollGroup"
  },
  dragRelation: "strong",
  dragStart: function(n, t) {
    var e = n.props, o = e.scrollContainer, R = o === void 0 ? n.getContainer() : o, N = new DragScroll$1(), M = getRefTarget(R, !0);
    t.datas.dragScroll = N;
    var D = t.isControl ? "controlGesto" : "targetGesto", L = t.targets;
    N.on("scroll", function(B) {
      var $ = B.container, k = B.direction, U = fillParams(n, t, {
        scrollContainer: $,
        direction: k
      }), z = L ? "onScrollGroup" : "onScroll";
      L && (U.targets = L), triggerEvent(n, z, U);
    }).on("move", function(B) {
      var $ = B.offsetX, k = B.offsetY;
      n[D].scrollBy($, k, t.inputEvent, !1);
    }), N.dragStart(t, {
      container: M
    });
  },
  checkScroll: function(n, t) {
    var e = t.datas.dragScroll;
    if (!!e) {
      var o = n.props, R = o.scrollContainer, N = R === void 0 ? n.getContainer() : R, M = o.scrollThreshold, D = M === void 0 ? 0 : M, L = o.getScrollPosition, B = L === void 0 ? getDefaultScrollPosition : L;
      return e.drag(t, {
        container: N,
        threshold: D,
        getScrollPosition: function($) {
          return B({
            scrollContainer: $.container,
            direction: $.direction
          });
        }
      }), !0;
    }
  },
  drag: function(n, t) {
    return this.checkScroll(n, t);
  },
  dragEnd: function(n, t) {
    t.datas.dragScroll.dragEnd(), t.datas.dragScroll = null;
  },
  dragControlStart: function(n, t) {
    return this.dragStart(n, __assign$2(__assign$2({}, t), {
      isControl: !0
    }));
  },
  dragControl: function(n, t) {
    return this.drag(n, t);
  },
  dragControlEnd: function(n, t) {
    return this.dragEnd(n, t);
  },
  dragGroupStart: function(n, t) {
    return this.dragStart(n, __assign$2(__assign$2({}, t), {
      targets: n.props.targets
    }));
  },
  dragGroup: function(n, t) {
    return this.drag(n, __assign$2(__assign$2({}, t), {
      targets: n.props.targets
    }));
  },
  dragGroupEnd: function(n, t) {
    return this.dragEnd(n, __assign$2(__assign$2({}, t), {
      targets: n.props.targets
    }));
  },
  dragGroupControlStart: function(n, t) {
    return this.dragStart(n, __assign$2(__assign$2({}, t), {
      targets: n.props.targets,
      isControl: !0
    }));
  },
  dragGroupContro: function(n, t) {
    return this.drag(n, __assign$2(__assign$2({}, t), {
      targets: n.props.targets
    }));
  },
  dragGroupControEnd: function(n, t) {
    return this.dragEnd(n, __assign$2(__assign$2({}, t), {
      targets: n.props.targets
    }));
  }
}, Default = {
  name: "",
  props: {
    target: Object,
    dragTarget: Object,
    container: Object,
    portalContainer: Object,
    rootContainer: Object,
    useResizeObserver: Boolean,
    zoom: Number,
    transformOrigin: Array,
    edge: Object,
    ables: Array,
    className: String,
    pinchThreshold: Number,
    pinchOutside: Boolean,
    triggerAblesSimultaneously: Boolean,
    checkInput: Boolean,
    cspNonce: String,
    translateZ: Number,
    hideDefaultLines: Boolean,
    props: Object,
    flushSync: Function,
    stopPropagation: Boolean,
    preventClickEventOnDrag: Boolean,
    preventClickDefault: Boolean
  },
  events: {}
}, Padding = makeAble("padding", {
  render: function(n, t) {
    var e = n.props;
    if (e.dragArea)
      return [];
    var o = e.padding || {}, R = o.left, N = R === void 0 ? 0 : R, M = o.top, D = M === void 0 ? 0 : M, L = o.right, B = L === void 0 ? 0 : L, $ = o.bottom, k = $ === void 0 ? 0 : $, U = n.state, z = U.renderPoses, X = U.pos1, V = U.pos2, W = U.pos3, Y = U.pos4, q = [X, V, W, Y], Z = [];
    return N > 0 && Z.push([0, 2]), D > 0 && Z.push([0, 1]), B > 0 && Z.push([1, 3]), k > 0 && Z.push([2, 3]), Z.map(function(J, Q) {
      var K = J[0], rt = J[1], tt = q[K], nt = q[rt], at = z[K], lt = z[rt], ut = createWarpMatrix([0, 0], [100, 0], [0, 100], [100, 100], tt, nt, at, lt);
      if (!!ut.length)
        return t.createElement("div", {
          key: "padding".concat(Q),
          className: prefix("padding"),
          style: {
            transform: makeMatrixCSS(ut, !0)
          }
        });
    });
  }
}), RADIUS_DIRECTIONS = ["nw", "ne", "se", "sw"];
function calculateRatio(n, t) {
  var e = n[0] + n[1], o = e > t ? t / e : 1;
  return n[0] *= o, n[1] = t - n[1] * o, n;
}
var HORIZONTAL_RADIUS_ORDER = [1, 2, 5, 6], VERTICAL_RADIUS_ORDER = [0, 3, 4, 7], HORIZONTAL_RADIUS_DIRECTIONS = [1, -1, -1, 1], VERTICAL_RADIUS_DIRECTIONS = [1, 1, -1, -1];
function getRadiusStyles(n, t, e, o, R, N, M, D, L) {
  N === void 0 && (N = 0), M === void 0 && (M = 0), D === void 0 && (D = o), L === void 0 && (L = R);
  var B = [], $ = !1, k = n.map(function(U, z) {
    var X = t[z], V = X.horizontal, W = X.vertical;
    if (W && !$ && ($ = !0, B.push("/")), $) {
      var Y = Math.max(0, W === 1 ? U[1] - M : L - U[1]);
      return B.push(convertCSSSize(Y, R, e)), Y;
    } else {
      var Y = Math.max(0, V === 1 ? U[0] - N : D - U[0]);
      return B.push(convertCSSSize(Y, o, e)), Y;
    }
  });
  return {
    styles: B,
    raws: k
  };
}
function getRadiusRange(n) {
  for (var t = [0, 0], e = [0, 0], o = n.length, R = 0; R < o; ++R) {
    var N = n[R];
    !N.sub || (N.horizontal && (t[1] === 0 && (t[0] = R), t[1] = R - t[0] + 1, e[0] = R + 1), N.vertical && (e[1] === 0 && (e[0] = R), e[1] = R - e[0] + 1));
  }
  return {
    horizontalRange: t,
    verticalRange: e
  };
}
function getRadiusValues(n, t, e, o, R, N) {
  var M, D, L, B;
  N === void 0 && (N = [0, 0]);
  var $ = n.indexOf("/"), k = ($ > -1 ? n.slice(0, $) : n).length, U = n.slice(0, k), z = n.slice(k + 1), X = U[0], V = X === void 0 ? "0px" : X, W = U[1], Y = W === void 0 ? V : W, q = U[2], Z = q === void 0 ? V : q, J = U[3], Q = J === void 0 ? Y : J, K = z[0], rt = K === void 0 ? V : K, tt = z[1], nt = tt === void 0 ? rt : tt, at = z[2], lt = at === void 0 ? rt : at, ut = z[3], dt = ut === void 0 ? nt : ut, yt = [V, Y, Z, Q].map(function(ct) {
    return convertUnitSize(ct, t);
  }), pt = [rt, nt, lt, dt].map(function(ct) {
    return convertUnitSize(ct, e);
  }), gt = yt.slice(), xt = pt.slice();
  M = calculateRatio([gt[0], gt[1]], t), gt[0] = M[0], gt[1] = M[1], D = calculateRatio([gt[3], gt[2]], t), gt[3] = D[0], gt[2] = D[1], L = calculateRatio([xt[0], xt[3]], e), xt[0] = L[0], xt[3] = L[1], B = calculateRatio([xt[1], xt[2]], e), xt[1] = B[0], xt[2] = B[1];
  var Lt = gt.slice(0, Math.max(N[0], U.length)), mt = xt.slice(0, Math.max(N[1], z.length));
  return __spreadArray(__spreadArray([], Lt.map(function(ct, vt) {
    var Tt = RADIUS_DIRECTIONS[vt];
    return {
      horizontal: HORIZONTAL_RADIUS_DIRECTIONS[vt],
      vertical: 0,
      pos: [o + ct, R + (VERTICAL_RADIUS_DIRECTIONS[vt] === -1 ? e : 0)],
      sub: !0,
      raw: yt[vt],
      direction: Tt
    };
  }), !0), mt.map(function(ct, vt) {
    var Tt = RADIUS_DIRECTIONS[vt];
    return {
      horizontal: 0,
      vertical: VERTICAL_RADIUS_DIRECTIONS[vt],
      pos: [o + (HORIZONTAL_RADIUS_DIRECTIONS[vt] === -1 ? t : 0), R + ct],
      sub: !0,
      raw: pt[vt],
      direction: Tt
    };
  }), !0);
}
function removeRadiusPos(n, t, e, o, R) {
  R === void 0 && (R = t.length);
  var N = getRadiusRange(n.slice(o)), M = N.horizontalRange, D = N.verticalRange, L = e - o, B = 0;
  if (L === 0)
    B = R;
  else if (L > 0 && L < M[1])
    B = M[1] - L;
  else if (L >= D[0])
    B = D[0] + D[1] - L;
  else
    return;
  n.splice(e, B), t.splice(e, B);
}
function addRadiusPos(n, t, e, o, R, N, M, D, L, B, $) {
  B === void 0 && (B = 0), $ === void 0 && ($ = 0);
  var k = getRadiusRange(n.slice(e)), U = k.horizontalRange, z = k.verticalRange;
  if (o > -1)
    for (var X = HORIZONTAL_RADIUS_DIRECTIONS[o] === 1 ? N - B : D - N, V = U[1]; V <= o; ++V) {
      var W = VERTICAL_RADIUS_DIRECTIONS[V] === 1 ? $ : L, Y = 0;
      if (o === V ? Y = N : V === 0 ? Y = B + X : HORIZONTAL_RADIUS_DIRECTIONS[V] === -1 && (Y = D - (t[e][0] - B)), n.splice(e + V, 0, {
        horizontal: HORIZONTAL_RADIUS_DIRECTIONS[V],
        vertical: 0,
        pos: [Y, W]
      }), t.splice(e + V, 0, [Y, W]), V === 0)
        break;
    }
  else if (R > -1) {
    var q = VERTICAL_RADIUS_DIRECTIONS[R] === 1 ? M - $ : L - M;
    if (U[1] === 0 && z[1] === 0) {
      var Z = [B + q, $];
      n.push({
        horizontal: HORIZONTAL_RADIUS_DIRECTIONS[0],
        vertical: 0,
        pos: Z
      }), t.push(Z);
    }
    for (var J = z[0], V = z[1]; V <= R; ++V) {
      var Y = HORIZONTAL_RADIUS_DIRECTIONS[V] === 1 ? B : D, W = 0;
      if (R === V ? W = M : V === 0 ? W = $ + q : VERTICAL_RADIUS_DIRECTIONS[V] === 1 ? W = t[e + J][1] : VERTICAL_RADIUS_DIRECTIONS[V] === -1 && (W = L - (t[e + J][1] - $)), n.push({
        horizontal: 0,
        vertical: VERTICAL_RADIUS_DIRECTIONS[V],
        pos: [Y, W]
      }), t.push([Y, W]), V === 0)
        break;
    }
  }
}
function splitRadiusPoses(n, t) {
  t === void 0 && (t = n.map(function(R) {
    return R.raw;
  }));
  var e = n.map(function(R, N) {
    return R.horizontal ? t[N] : null;
  }).filter(function(R) {
    return R != null;
  }), o = n.map(function(R, N) {
    return R.vertical ? t[N] : null;
  }).filter(function(R) {
    return R != null;
  });
  return {
    horizontals: e,
    verticals: o
  };
}
var CLIP_DIRECTIONS = [[0, -1, "n"], [1, 0, "e"]], CLIP_RECT_DIRECTIONS = [[-1, -1, "nw"], [0, -1, "n"], [1, -1, "ne"], [1, 0, "e"], [1, 1, "se"], [0, 1, "s"], [-1, 1, "sw"], [-1, 0, "w"]];
function getClipStyles(n, t, e) {
  var o = n.props.clipRelative, R = n.state, N = R.width, M = R.height, D = t, L = D.type, B = D.poses, $ = L === "rect", k = L === "circle";
  if (L === "polygon")
    return e.map(function(K) {
      return "".concat(convertCSSSize(K[0], N, o), " ").concat(convertCSSSize(K[1], M, o));
    });
  if ($ || L === "inset") {
    var U = e[1][1], z = e[3][0], X = e[7][0], V = e[5][1];
    if ($)
      return [U, z, V, X].map(function(K) {
        return "".concat(K, "px");
      });
    var W = [U, N - z, M - V, X].map(function(K, rt) {
      return convertCSSSize(K, rt % 2 ? N : M, o);
    });
    if (e.length > 8) {
      var Y = minus(e[4], e[0]), q = Y[0], Z = Y[1];
      W.push.apply(W, __spreadArray(["round"], getRadiusStyles(e.slice(8), B.slice(8), o, q, Z, X, U, z, V).styles, !1));
    }
    return W;
  } else if (k || L === "ellipse") {
    var J = e[0], Q = convertCSSSize(Math.abs(e[1][1] - J[1]), k ? Math.sqrt((N * N + M * M) / 2) : M, o), W = k ? [Q] : [convertCSSSize(Math.abs(e[2][0] - J[0]), N, o), Q];
    return W.push("at", convertCSSSize(J[0], N, o), convertCSSSize(J[1], M, o)), W;
  }
}
function getRectPoses(n, t, e, o) {
  var R = [o, (o + t) / 2, t], N = [n, (n + e) / 2, e];
  return CLIP_RECT_DIRECTIONS.map(function(M) {
    var D = M[0], L = M[1], B = M[2], $ = R[D + 1], k = N[L + 1];
    return {
      vertical: Math.abs(L),
      horizontal: Math.abs(D),
      direction: B,
      pos: [$, k]
    };
  });
}
function getControlSize(n) {
  var t = [1 / 0, -1 / 0], e = [1 / 0, -1 / 0];
  return n.forEach(function(o) {
    var R = o.pos;
    t[0] = Math.min(t[0], R[0]), t[1] = Math.max(t[1], R[0]), e[0] = Math.min(e[0], R[1]), e[1] = Math.max(e[1], R[1]);
  }), [Math.abs(t[1] - t[0]), Math.abs(e[1] - e[0])];
}
function moveControlPos(n, t, e, o, R) {
  var N = n[t], M = N.direction, D = N.sub, L = n.map(function() {
    return [0, 0];
  }), B = M ? M.split("") : [];
  if (o && t < 8) {
    var $ = B.filter(function(dt) {
      return dt === "w" || dt === "e";
    }), k = B.filter(function(dt) {
      return dt === "n" || dt === "s";
    }), U = $[0], z = k[0];
    L[t] = e;
    var X = getControlSize(n), V = X[0], W = X[1], Y = V && W ? V / W : 0;
    if (Y && R) {
      var q = (t + 4) % 8, Z = n[q].pos, J = [0, 0];
      M.indexOf("w") > -1 ? J[0] = -1 : M.indexOf("e") > -1 && (J[0] = 1), M.indexOf("n") > -1 ? J[1] = -1 : M.indexOf("s") > -1 && (J[1] = 1);
      var Q = getSizeDistByDist([V, W], e, Y, J, !0), K = V + Q[0], rt = W + Q[1], tt = Z[1], nt = Z[1], at = Z[0], lt = Z[0];
      J[0] === -1 ? at = lt - K : J[0] === 1 ? lt = at + K : (at = at - K / 2, lt = lt + K / 2), J[1] === -1 ? tt = nt - rt : (J[1] === 1 || (tt = nt - rt / 2), nt = tt + rt);
      var ut = getRectPoses(tt, lt, nt, at);
      n.forEach(function(dt, yt) {
        L[yt][0] = ut[yt].pos[0] - dt.pos[0], L[yt][1] = ut[yt].pos[1] - dt.pos[1];
      });
    } else
      n.forEach(function(dt, yt) {
        var pt = dt.direction;
        !pt || (pt.indexOf(U) > -1 && (L[yt][0] = e[0]), pt.indexOf(z) > -1 && (L[yt][1] = e[1]));
      }), U && (L[1][0] = e[0] / 2, L[5][0] = e[0] / 2), z && (L[3][1] = e[1] / 2, L[7][1] = e[1] / 2);
  } else
    M && !D ? B.forEach(function(dt) {
      var yt = dt === "n" || dt === "s";
      n.forEach(function(pt, gt) {
        var xt = pt.direction, Lt = pt.horizontal, mt = pt.vertical;
        !xt || xt.indexOf(dt) === -1 || (L[gt] = [yt || !Lt ? 0 : e[0], !yt || !mt ? 0 : e[1]]);
      });
    }) : L[t] = e;
  return L;
}
function getClipPath(n, t, e, o, R) {
  var N, M, D, L, B, $, k, U = R;
  if (!U) {
    var z = getComputedStyle$1$1(n), X = z.clipPath;
    U = X !== "none" ? X : z.clip;
  }
  if (!((!U || U === "none" || U === "auto") && (U = o, !U))) {
    var V = splitBracket(U), W = V.prefix, Y = W === void 0 ? U : W, q = V.value, Z = q === void 0 ? "" : q, J = Y === "circle", Q = " ";
    if (Y === "polygon") {
      var K = splitComma(Z || "0% 0%, 100% 0%, 100% 100%, 0% 100%");
      Q = ",";
      var rt = K.map(function(Ct) {
        var Zt = Ct.split(" "), Yt = Zt[0], se = Zt[1];
        return {
          vertical: 1,
          horizontal: 1,
          pos: [convertUnitSize(Yt, t), convertUnitSize(se, e)]
        };
      });
      return {
        type: Y,
        clipText: U,
        poses: rt,
        splitter: Q
      };
    } else if (J || Y === "ellipse") {
      var tt = "", nt = "", at = 0, lt = 0, K = splitSpace(Z);
      if (J) {
        var ut = "";
        N = K[0], ut = N === void 0 ? "50%" : N, M = K[2], tt = M === void 0 ? "50%" : M, D = K[3], nt = D === void 0 ? "50%" : D, at = convertUnitSize(ut, Math.sqrt((t * t + e * e) / 2)), lt = at;
      } else {
        var dt = "", yt = "";
        L = K[0], dt = L === void 0 ? "50%" : L, B = K[1], yt = B === void 0 ? "50%" : B, $ = K[3], tt = $ === void 0 ? "50%" : $, k = K[4], nt = k === void 0 ? "50%" : k, at = convertUnitSize(dt, t), lt = convertUnitSize(yt, e);
      }
      var pt = [convertUnitSize(tt, t), convertUnitSize(nt, e)], rt = __spreadArray([{
        vertical: 1,
        horizontal: 1,
        pos: pt,
        direction: "nesw"
      }], CLIP_DIRECTIONS.slice(0, J ? 1 : 2).map(function(Yt) {
        return {
          vertical: Math.abs(Yt[1]),
          horizontal: Yt[0],
          direction: Yt[2],
          sub: !0,
          pos: [pt[0] + Yt[0] * at, pt[1] + Yt[1] * lt]
        };
      }), !0);
      return {
        type: Y,
        clipText: U,
        radiusX: at,
        radiusY: lt,
        left: pt[0] - at,
        top: pt[1] - lt,
        poses: rt,
        splitter: Q
      };
    } else if (Y === "inset") {
      var K = splitSpace(Z || "0 0 0 0"), gt = K.indexOf("round"), xt = (gt > -1 ? K.slice(0, gt) : K).length, Lt = K.slice(xt + 1), mt = K.slice(0, xt), ct = mt[0], vt = mt[1], Tt = vt === void 0 ? ct : vt, Pt = mt[2], wt = Pt === void 0 ? ct : Pt, Mt = mt[3], ht = Mt === void 0 ? Tt : Mt, $t = [ct, wt].map(function(Yt) {
        return convertUnitSize(Yt, e);
      }), At = $t[0], kt = $t[1], Ot = [ht, Tt].map(function(Yt) {
        return convertUnitSize(Yt, t);
      }), _t = Ot[0], Gt = Ot[1], St = t - Gt, Et = e - kt, Rt = getRadiusValues(Lt, St - _t, Et - At, _t, At), rt = __spreadArray(__spreadArray([], getRectPoses(At, St, Et, _t), !0), Rt, !0);
      return {
        type: "inset",
        clipText: U,
        poses: rt,
        top: At,
        left: _t,
        right: St,
        bottom: Et,
        radius: Lt,
        splitter: Q
      };
    } else if (Y === "rect") {
      var K = splitComma(Z || "0px, ".concat(t, "px, ").concat(e, "px, 0px"));
      Q = ",";
      var Dt = K.map(function(Qt) {
        var Ie = splitUnit(Qt).value;
        return Ie;
      }), At = Dt[0], Gt = Dt[1], kt = Dt[2], _t = Dt[3], rt = getRectPoses(At, Gt, kt, _t);
      return {
        type: "rect",
        clipText: U,
        poses: rt,
        top: At,
        right: Gt,
        bottom: kt,
        left: _t,
        values: K,
        splitter: Q
      };
    }
  }
}
function addClipPath(n, t) {
  var e = calculatePointerDist(n, t), o = e[0], R = e[1], N = t.datas, M = N.clipPath, D = N.clipIndex, L = M, B = L.type, $ = L.poses, k = L.splitter, U = $.map(function(Y) {
    return Y.pos;
  });
  if (B === "polygon")
    U.splice(D, 0, [o, R]);
  else if (B === "inset") {
    var z = HORIZONTAL_RADIUS_ORDER.indexOf(D), X = VERTICAL_RADIUS_ORDER.indexOf(D), V = $.length;
    if (addRadiusPos($, U, 8, z, X, o, R, U[4][0], U[4][1], U[0][0], U[0][1]), V === $.length)
      return;
  } else
    return;
  var W = getClipStyles(n, M, U);
  triggerEvent(n, "onClip", fillParams(n, t, {
    clipEventType: "added",
    clipType: B,
    poses: U,
    clipStyles: W,
    clipStyle: "".concat(B, "(").concat(W.join(k), ")"),
    distX: 0,
    distY: 0
  }));
}
function removeClipPath(n, t) {
  var e = t.datas, o = e.clipPath, R = e.clipIndex, N = o, M = N.type, D = N.poses, L = N.splitter, B = D.map(function(U) {
    return U.pos;
  }), $ = B.length;
  if (M === "polygon")
    D.splice(R, 1), B.splice(R, 1);
  else if (M === "inset") {
    if (R < 8 || (removeRadiusPos(D, B, R, 8, $), $ === D.length))
      return;
  } else
    return;
  var k = getClipStyles(n, o, B);
  triggerEvent(n, "onClip", fillParams(n, t, {
    clipEventType: "removed",
    clipType: M,
    poses: B,
    clipStyles: k,
    clipStyle: "".concat(M, "(").concat(k.join(L), ")"),
    distX: 0,
    distY: 0
  }));
}
var Clippable = {
  name: "clippable",
  props: {
    clippable: Boolean,
    defaultClipPath: String,
    customClipPath: String,
    keepRatio: Boolean,
    clipRelative: Boolean,
    clipArea: Boolean,
    dragWithClip: Boolean,
    clipTargetBounds: Boolean,
    clipVerticalGuidelines: Array,
    clipHorizontalGuidelines: Array,
    clipSnapThreshold: Boolean
  },
  events: {
    onClipStart: "clipStart",
    onClip: "clip",
    onClipEnd: "clipEnd"
  },
  css: [`.control.clip-control {
    background: #6d6;
    cursor: pointer;
}
.control.clip-control.clip-radius {
    background: #d66;
}
.line.clip-line {
    background: #6e6;
    cursor: move;
    z-index: 1;
}
.clip-area {
    position: absolute;
    top: 0;
    left: 0;
}
.clip-ellipse {
    position: absolute;
    cursor: move;
    border: 1px solid #6d6;
    border: var(--zoompx) solid #6d6;
    border-radius: 50%;
    transform-origin: 0px 0px;
}`, `:host {
    --bounds-color: #d66;
}`, `.guideline {
    pointer-events: none;
    z-index: 2;
}`, `.line.guideline.bounds {
    background: #d66;
    background: var(--bounds-color);
}`],
  render: function(n, t) {
    var e = n.props, o = e.customClipPath, R = e.defaultClipPath, N = e.clipArea, M = e.zoom, D = n.state, L = D.target, B = D.width, $ = D.height, k = D.allMatrix, U = D.is3d, z = D.left, X = D.top, V = D.pos1, W = D.pos2, Y = D.pos3, q = D.pos4, Z = D.clipPathState, J = D.snapBoundInfos, Q = D.rotation;
    if (!L)
      return [];
    var K = getClipPath(L, B, $, R || "inset", Z || o);
    if (!K)
      return [];
    var rt = U ? 4 : 3, tt = K.type, nt = K.poses, at = nt.map(function(Et) {
      var Rt = calculatePosition(k, Et.pos, rt);
      return [Rt[0] - z, Rt[1] - X];
    }), lt = [], ut = [], dt = tt === "rect", yt = tt === "inset", pt = tt === "polygon";
    if (dt || yt || pt) {
      var gt = yt ? at.slice(0, 8) : at;
      ut = gt.map(function(Et, Rt) {
        var Dt = Rt === 0 ? gt[gt.length - 1] : gt[Rt - 1], Ct = getRad$1(Dt, Et), Zt = getDiagonalSize(Dt, Et);
        return t.createElement("div", {
          key: "clipLine".concat(Rt),
          className: prefix("line", "clip-line", "snap-control"),
          "data-clip-index": Rt,
          style: {
            width: "".concat(Zt, "px"),
            transform: "translate(".concat(Dt[0], "px, ").concat(Dt[1], "px) rotate(").concat(Ct, "rad) scaleY(").concat(M, ")")
          }
        });
      });
    }
    if (lt = at.map(function(Et, Rt) {
      return t.createElement("div", {
        key: "clipControl".concat(Rt),
        className: prefix("control", "clip-control", "snap-control"),
        "data-clip-index": Rt,
        style: {
          transform: "translate(".concat(Et[0], "px, ").concat(Et[1], "px) rotate(").concat(Q, "rad) scale(").concat(M, ")")
        }
      });
    }), yt && lt.push.apply(lt, at.slice(8).map(function(Et, Rt) {
      return t.createElement("div", {
        key: "clipRadiusControl".concat(Rt),
        className: prefix("control", "clip-control", "clip-radius", "snap-control"),
        "data-clip-index": 8 + Rt,
        style: {
          transform: "translate(".concat(Et[0], "px, ").concat(Et[1], "px) rotate(").concat(Q, "rad) scale(").concat(M, ")")
        }
      });
    })), tt === "circle" || tt === "ellipse") {
      var xt = K.left, Lt = K.top, mt = K.radiusX, ct = K.radiusY, vt = minus(calculatePosition(k, [xt, Lt], rt), calculatePosition(k, [0, 0], rt)), Tt = vt[0], Pt = vt[1], wt = "none";
      if (!N) {
        for (var Mt = Math.max(10, mt / 5, ct / 5), ht = [], $t = 0; $t <= Mt; ++$t) {
          var At = Math.PI * 2 / Mt * $t;
          ht.push([mt + (mt - M) * Math.cos(At), ct + (ct - M) * Math.sin(At)]);
        }
        ht.push([mt, -2]), ht.push([-2, -2]), ht.push([-2, ct * 2 + 2]), ht.push([mt * 2 + 2, ct * 2 + 2]), ht.push([mt * 2 + 2, -2]), ht.push([mt, -2]), wt = "polygon(".concat(ht.map(function(Et) {
          return "".concat(Et[0], "px ").concat(Et[1], "px");
        }).join(", "), ")");
      }
      lt.push(t.createElement("div", {
        key: "clipEllipse",
        className: prefix("clip-ellipse", "snap-control"),
        style: {
          width: "".concat(mt * 2, "px"),
          height: "".concat(ct * 2, "px"),
          clipPath: wt,
          transform: "translate(".concat(-z + Tt, "px, ").concat(-X + Pt, "px) ").concat(makeMatrixCSS(k))
        }
      }));
    }
    if (N) {
      var kt = getRect(__spreadArray([V, W, Y, q], at, !0)), Ot = kt.width, _t = kt.height, Gt = kt.left, St = kt.top;
      if (pt || dt || yt) {
        var ht = yt ? at.slice(0, 8) : at;
        lt.push(t.createElement("div", {
          key: "clipArea",
          className: prefix("clip-area", "snap-control"),
          style: {
            width: "".concat(Ot, "px"),
            height: "".concat(_t, "px"),
            transform: "translate(".concat(Gt, "px, ").concat(St, "px)"),
            clipPath: "polygon(".concat(ht.map(function(Rt) {
              return "".concat(Rt[0] - Gt, "px ").concat(Rt[1] - St, "px");
            }).join(", "), ")")
          }
        }));
      }
    }
    return J && ["vertical", "horizontal"].forEach(function(Et) {
      var Rt = J[Et], Dt = Et === "horizontal";
      Rt.isSnap && ut.push.apply(ut, Rt.snap.posInfos.map(function(Ct, Zt) {
        var Yt = Ct.pos, se = minus(calculatePosition(k, Dt ? [0, Yt] : [Yt, 0], rt), [z, X]), xe = minus(calculatePosition(k, Dt ? [B, Yt] : [Yt, $], rt), [z, X]);
        return renderLine(t, "", se, xe, M, "clip".concat(Et, "snap").concat(Zt), "guideline");
      })), Rt.isBound && ut.push.apply(ut, Rt.bounds.map(function(Ct, Zt) {
        var Yt = Ct.pos, se = minus(calculatePosition(k, Dt ? [0, Yt] : [Yt, 0], rt), [z, X]), xe = minus(calculatePosition(k, Dt ? [B, Yt] : [Yt, $], rt), [z, X]);
        return renderLine(t, "", se, xe, M, "clip".concat(Et, "bounds").concat(Zt), "guideline", "bounds", "bold");
      }));
    }), __spreadArray(__spreadArray([], lt, !0), ut, !0);
  },
  dragControlCondition: function(n, t) {
    return t.inputEvent && (t.inputEvent.target.getAttribute("class") || "").indexOf("clip") > -1;
  },
  dragStart: function(n, t) {
    var e = n.props, o = e.dragWithClip, R = o === void 0 ? !0 : o;
    return R ? !1 : this.dragControlStart(n, t);
  },
  drag: function(n, t) {
    return this.dragControl(n, __assign$2(__assign$2({}, t), {
      isDragTarget: !0
    }));
  },
  dragEnd: function(n, t) {
    return this.dragControlEnd(n, t);
  },
  dragControlStart: function(n, t) {
    var e = n.state, o = n.props, R = o.defaultClipPath, N = o.customClipPath, M = e.target, D = e.width, L = e.height, B = t.inputEvent ? t.inputEvent.target : null, $ = B && B.getAttribute("class") || "", k = t.datas, U = getClipPath(M, D, L, R || "inset", N);
    if (!U)
      return !1;
    var z = U.clipText, X = U.type, V = U.poses, W = triggerEvent(n, "onClipStart", fillParams(n, t, {
      clipType: X,
      clipStyle: z,
      poses: V.map(function(Y) {
        return Y.pos;
      })
    }));
    return W === !1 ? (k.isClipStart = !1, !1) : (k.isControl = $ && $.indexOf("clip-control") > -1, k.isLine = $.indexOf("clip-line") > -1, k.isArea = $.indexOf("clip-area") > -1 || $.indexOf("clip-ellipse") > -1, k.clipIndex = B ? parseInt(B.getAttribute("data-clip-index"), 10) : -1, k.clipPath = U, k.isClipStart = !0, e.clipPathState = z, setDragStart(n, t), !0);
  },
  dragControl: function(n, t) {
    var e, o = t.datas, R = t.originalDatas, N = t.isDragTarget;
    if (!o.isClipStart)
      return !1;
    var M = o, D = M.isControl, L = M.isLine, B = M.isArea, $ = M.clipIndex, k = M.clipPath;
    if (!k)
      return !1;
    var U = getProps(n.props, "clippable"), z = U.keepRatio, X = 0, V = 0, W = R.draggable, Y = getDragDist(t);
    N && W ? (e = W.prevBeforeDist, X = e[0], V = e[1]) : (X = Y[0], V = Y[1]);
    var q = [X, V], Z = n.state, J = Z.width, Q = Z.height, K = !B && !D && !L, rt = k.type, tt = k.poses, nt = k.splitter, at = tt.map(function(ot) {
      return ot.pos;
    });
    K && (X = -X, V = -V);
    var lt = !D || tt[$].direction === "nesw", ut = rt === "inset" || rt === "rect", dt = tt.map(function() {
      return [0, 0];
    });
    if (D && !lt) {
      var yt = tt[$], pt = yt.horizontal, gt = yt.vertical, xt = [X * Math.abs(pt), V * Math.abs(gt)];
      dt = moveControlPos(tt, $, xt, ut, z);
    } else
      lt && (dt = at.map(function() {
        return [X, V];
      }));
    var Lt = at.map(function(ot, ft) {
      return plus(ot, dt[ft]);
    }), mt = __spreadArray([], Lt, !0);
    Z.snapBoundInfos = null;
    var ct = k.type === "circle", vt = k.type === "ellipse";
    if (ct || vt) {
      var Tt = getRect(Lt), Pt = Math.abs(Tt.bottom - Tt.top), wt = Math.abs(vt ? Tt.right - Tt.left : Pt), Mt = Lt[0][1] + Pt, ht = Lt[0][0] - wt, $t = Lt[0][0] + wt;
      ct && (mt.push([$t, Tt.bottom]), dt.push([1, 0])), mt.push([Tt.left, Mt]), dt.push([0, 1]), mt.push([ht, Tt.bottom]), dt.push([1, 0]);
    }
    var At = getDefaultGuidelines((U.clipHorizontalGuidelines || []).map(function(ot) {
      return convertUnitSize("".concat(ot), Q);
    }), (U.clipVerticalGuidelines || []).map(function(ot) {
      return convertUnitSize("".concat(ot), J);
    }), J, Q), kt = [], Ot = [];
    if (ct || vt)
      kt = [mt[4][0], mt[2][0]], Ot = [mt[1][1], mt[3][1]];
    else if (ut) {
      var _t = [mt[0], mt[2], mt[4], mt[6]], Gt = [dt[0], dt[2], dt[4], dt[6]];
      kt = _t.filter(function(ot, ft) {
        return Gt[ft][0];
      }).map(function(ot) {
        return ot[0];
      }), Ot = _t.filter(function(ot, ft) {
        return Gt[ft][1];
      }).map(function(ot) {
        return ot[1];
      });
    } else
      kt = mt.filter(function(ot, ft) {
        return dt[ft][0];
      }).map(function(ot) {
        return ot[0];
      }), Ot = mt.filter(function(ot, ft) {
        return dt[ft][1];
      }).map(function(ot) {
        return ot[1];
      });
    var St = [0, 0], Et = checkSnapBounds(At, U.clipTargetBounds && {
      left: 0,
      top: 0,
      right: J,
      bottom: Q
    }, kt, Ot, 5), Rt = Et.horizontal, Dt = Et.vertical, Ct = Rt.offset, Zt = Dt.offset;
    if (Rt.isBound && (St[1] += Ct), Dt.isBound && (St[0] += Zt), (vt || ct) && dt[0][0] === 0 && dt[0][1] === 0) {
      var Tt = getRect(Lt), Yt = Tt.bottom - Tt.top, se = vt ? Tt.right - Tt.left : Yt, xe = Dt.isBound ? Math.abs(Zt) : Dt.snapIndex === 0 ? -Zt : Zt, Oe = Rt.isBound ? Math.abs(Ct) : Rt.snapIndex === 0 ? -Ct : Ct;
      se -= xe, Yt -= Oe, ct && (Yt = checkSnapBoundPriority(Dt, Rt) > 0 ? Yt : se, se = Yt);
      var Qt = mt[0];
      mt[1][1] = Qt[1] - Yt, mt[2][0] = Qt[0] + se, mt[3][1] = Qt[1] + Yt, mt[4][0] = Qt[0] - se;
    } else if (ut && z && D) {
      var Ie = getControlSize(tt), de = Ie[0], ue = Ie[1], ae = de && ue ? de / ue : 0, Jt = tt[$], Pe = Jt.direction || "", ha = mt[1][1], Mt = mt[5][1], ht = mt[7][0], $t = mt[3][0];
      Ct <= Zt ? Ct = Zt / ae : Zt = Ct * ae, Pe.indexOf("w") > -1 ? ht -= Zt : Pe.indexOf("e") > -1 ? $t -= Zt : (ht += Zt / 2, $t -= Zt / 2), Pe.indexOf("n") > -1 ? ha -= Ct : Pe.indexOf("s") > -1 ? Mt -= Ct : (ha += Ct / 2, Mt -= Ct / 2);
      var Ql = getRectPoses(ha, $t, Mt, ht);
      mt.forEach(function(It, Nt) {
        var Ft;
        Ft = Ql[Nt].pos, It[0] = Ft[0], It[1] = Ft[1];
      });
    } else
      mt.forEach(function(ot, ft) {
        var bt = dt[ft];
        bt[0] && (ot[0] -= Zt), bt[1] && (ot[1] -= Ct);
      });
    var Bo = getClipStyles(n, k, Lt), ca = "".concat(rt, "(").concat(Bo.join(nt), ")");
    if (Z.clipPathState = ca, ct || vt)
      kt = [mt[4][0], mt[2][0]], Ot = [mt[1][1], mt[3][1]];
    else if (ut) {
      var _t = [mt[0], mt[2], mt[4], mt[6]];
      kt = _t.map(function(ft) {
        return ft[0];
      }), Ot = _t.map(function(ft) {
        return ft[1];
      });
    } else
      kt = mt.map(function(ot) {
        return ot[0];
      }), Ot = mt.map(function(ot) {
        return ot[1];
      });
    if (Z.snapBoundInfos = checkSnapBounds(At, U.clipTargetBounds && {
      left: 0,
      top: 0,
      right: J,
      bottom: Q
    }, kt, Ot, 1), W) {
      var $o = Z.is3d, ko = Z.allMatrix, Go = $o ? 4 : 3, fa = St;
      N && (fa = [q[0] + St[0] - Y[0], q[1] + St[1] - Y[1]]), W.deltaOffset = multiply(ko, [fa[0], fa[1], 0, 0], Go);
    }
    return triggerEvent(n, "onClip", fillParams(n, t, {
      clipEventType: "changed",
      clipType: rt,
      poses: Lt,
      clipStyle: ca,
      clipStyles: Bo,
      distX: X,
      distY: V
    })), !0;
  },
  dragControlEnd: function(n, t) {
    this.unset(n);
    var e = t.isDrag, o = t.datas, R = t.isDouble, N = o.isLine, M = o.isClipStart, D = o.isControl;
    return M ? (triggerEvent(n, "onClipEnd", fillEndParams(n, t, {})), R && (D ? removeClipPath(n, t) : N && addClipPath(n, t)), R || e) : !1;
  },
  unset: function(n) {
    n.state.clipPathState = "", n.state.snapBoundInfos = null;
  }
}, OriginDraggable = {
  name: "originDraggable",
  props: {
    originDraggable: Boolean,
    originRelative: Boolean
  },
  events: {
    onDragOriginStart: "dragOriginStart",
    onDragOrigin: "dragOrigin",
    onDragOriginEnd: "dragOriginEnd"
  },
  css: [`:host[data-able-origindraggable] .control.origin {
    pointer-events: auto;
}`],
  dragControlCondition: function(n, t) {
    return t.isRequest ? t.requestAble === "originDraggable" : hasClass(t.inputEvent.target, prefix("origin"));
  },
  dragControlStart: function(n, t) {
    var e = t.datas;
    setDragStart(n, t);
    var o = fillParams(n, t, {
      dragStart: Draggable.dragStart(n, new CustomGesto().dragStart([0, 0], t))
    }), R = triggerEvent(n, "onDragOriginStart", o);
    return e.startOrigin = n.state.transformOrigin, e.startTargetOrigin = n.state.targetOrigin, e.prevOrigin = [0, 0], e.isDragOrigin = !0, R === !1 ? (e.isDragOrigin = !1, !1) : o;
  },
  dragControl: function(n, t) {
    var e = t.datas, o = t.isPinch, R = t.isRequest;
    if (!e.isDragOrigin)
      return !1;
    var N = getDragDist(t), M = N[0], D = N[1], L = n.state, B = L.width, $ = L.height, k = L.offsetMatrix, U = L.targetMatrix, z = L.is3d, X = n.props.originRelative, V = X === void 0 ? !0 : X, W = z ? 4 : 3, Y = [M, D];
    if (R) {
      var q = t.distOrigin;
      (q[0] || q[1]) && (Y = q);
    }
    var Z = plus(e.startOrigin, Y), J = plus(e.startTargetOrigin, Y), Q = minus(Y, e.prevOrigin), K = getNextMatrix(k, U, Z, W), rt = n.getRect(), tt = getRect(calculatePoses(K, B, $, W)), nt = [rt.left - tt.left, rt.top - tt.top];
    e.prevOrigin = Y;
    var at = [convertCSSSize(J[0], B, V), convertCSSSize(J[1], $, V)].join(" "), lt = fillParams(n, t, {
      width: B,
      height: $,
      origin: Z,
      dist: Y,
      delta: Q,
      transformOrigin: at,
      drag: Draggable.drag(n, setCustomDrag(t, n.state, nt, !!o, !1))
    });
    return triggerEvent(n, "onDragOrigin", lt), lt;
  },
  dragControlEnd: function(n, t) {
    var e = t.datas;
    return e.isDragOrigin ? (triggerEvent(n, "onDragOriginEnd", fillEndParams(n, t, {})), !0) : !1;
  },
  dragGroupControlCondition: function(n, t) {
    return this.dragControlCondition(n, t);
  },
  dragGroupControlStart: function(n, t) {
    var e = this.dragControlStart(n, t);
    return !!e;
  },
  dragGroupControl: function(n, t) {
    var e = this.dragControl(n, t);
    return e ? (n.transformOrigin = e.transformOrigin, !0) : !1;
  },
  request: function(n) {
    var t = {}, e = n.getRect(), o = 0, R = 0, N = e.transformOrigin, M = [0, 0];
    return {
      isControl: !0,
      requestStart: function() {
        return {
          datas: t
        };
      },
      request: function(D) {
        return "deltaOrigin" in D ? (M[0] += D.deltaOrigin[0], M[1] += D.deltaOrigin[1]) : "origin" in D ? (M[0] = D.origin[0] - N[0], M[1] = D.origin[1] - N[1]) : ("x" in D ? o = D.x - e.left : "deltaX" in D && (o += D.deltaX), "y" in D ? R = D.y - e.top : "deltaY" in D && (R += D.deltaY)), {
          datas: t,
          distX: o,
          distY: R,
          distOrigin: M
        };
      },
      requestEnd: function() {
        return {
          datas: t,
          isDrag: !0
        };
      }
    };
  }
};
function addBorderRadius(n, t, e, o, R, N, M) {
  var D = splitRadiusPoses(n), L = D.horizontals, B = D.verticals, $ = L.length, k = B.length, U = -1, z = -1;
  e === 0 ? $ === 0 ? U = 0 : $ === 1 && (U = 1) : e === 3 && ($ <= 2 ? U = 2 : $ <= 3 && (U = 3)), e === 2 ? k === 0 ? z = 0 : k < 4 && (z = 3) : e === 1 && (k <= 1 ? z = 1 : k <= 2 && (z = 2)), addRadiusPos(n, t, 0, U, z, o, R, N, M);
}
function getBorderRadius(n, t, e, o, R) {
  o === void 0 && (o = [0, 0]);
  var N, M = [];
  if (R)
    N = R;
  else {
    var D = getComputedStyle$1$1(n);
    N = D && D.borderRadius || "";
  }
  return !N || !R && N === "0px" ? M = [] : M = splitSpace(N), getRadiusValues(M, t, e, 0, 0, o);
}
function triggerRoundEvent(n, t, e, o, R, N) {
  var M = n.state, D = M.width, L = M.height, B = getRadiusStyles(N, R, n.props.roundRelative, D, L), $ = B.raws, k = B.styles, U = splitRadiusPoses(R, $), z = U.horizontals, X = U.verticals, V = k.join(" ");
  M.borderRadiusState = V, triggerEvent(n, "onRound", fillParams(n, t, {
    horizontals: z,
    verticals: X,
    borderRadius: V,
    width: D,
    height: L,
    delta: o,
    dist: e
  }));
}
var Roundable = {
  name: "roundable",
  props: {
    roundable: Boolean,
    roundRelative: Boolean,
    minRoundControls: Array,
    maxRoundControls: Array,
    roundClickable: Boolean
  },
  events: {
    onRoundStart: "roundStart",
    onRound: "round",
    onRoundEnd: "roundEnd"
  },
  css: [`.control.border-radius {
    background: #d66;
    cursor: pointer;
}`, `:host[data-able-roundable] .line.direction {
    cursor: pointer;
}`],
  render: function(n, t) {
    var e = n.state, o = e.target, R = e.width, N = e.height, M = e.allMatrix, D = e.is3d, L = e.left, B = e.top, $ = e.borderRadiusState, k = n.props, U = k.minRoundControls, z = U === void 0 ? [0, 0] : U, X = k.maxRoundControls, V = X === void 0 ? [4, 4] : X, W = k.zoom;
    if (!o)
      return null;
    var Y = D ? 4 : 3, q = getBorderRadius(o, R, N, z, $);
    if (!q)
      return null;
    var Z = 0, J = 0;
    return q.map(function(Q, K) {
      J += Math.abs(Q.horizontal), Z += Math.abs(Q.vertical);
      var rt = minus(calculatePosition(M, Q.pos, Y), [L, B]), tt = Q.vertical ? Z <= V[1] : J <= V[0];
      return t.createElement("div", {
        key: "borderRadiusControl".concat(K),
        className: prefix("control", "border-radius"),
        "data-radius-index": K,
        style: {
          display: tt ? "block" : "none",
          transform: "translate(".concat(rt[0], "px, ").concat(rt[1], "px) scale(").concat(W, ")")
        }
      });
    });
  },
  dragControlCondition: function(n, t) {
    if (!t.inputEvent || t.isRequest)
      return !1;
    var e = t.inputEvent.target.getAttribute("class") || "";
    return e.indexOf("border-radius") > -1 || e.indexOf("moveable-line") > -1 && e.indexOf("moveable-direction") > -1;
  },
  dragControlStart: function(n, t) {
    var e = t.inputEvent, o = t.datas, R = e.target, N = R.getAttribute("class") || "", M = N.indexOf("border-radius") > -1, D = N.indexOf("moveable-line") > -1 && N.indexOf("moveable-direction") > -1, L = M ? parseInt(R.getAttribute("data-radius-index"), 10) : -1, B = D ? parseInt(R.getAttribute("data-line-index"), 10) : -1;
    if (!M && !D)
      return !1;
    var $ = triggerEvent(n, "onRoundStart", fillParams(n, t, {}));
    if ($ === !1)
      return !1;
    o.lineIndex = B, o.controlIndex = L, o.isControl = M, o.isLine = D, setDragStart(n, t);
    var k = n.props, U = k.roundRelative, z = k.minRoundControls, X = z === void 0 ? [0, 0] : z, V = n.state, W = V.target, Y = V.width, q = V.height;
    o.isRound = !0, o.prevDist = [0, 0];
    var Z = getBorderRadius(W, Y, q, X) || [];
    return o.controlPoses = Z, V.borderRadiusState = getRadiusStyles(Z.map(function(J) {
      return J.pos;
    }), Z, U, Y, q).styles.join(" "), !0;
  },
  dragControl: function(n, t) {
    var e = t.datas;
    if (!e.isRound || !e.isControl || !e.controlPoses.length)
      return !1;
    var o = e.controlIndex, R = e.controlPoses, N = getDragDist(t), M = N[0], D = N[1], L = [M, D], B = minus(L, e.prevDist), $ = n.props.maxRoundControls, k = $ === void 0 ? [4, 4] : $, U = n.state, z = U.width, X = U.height, V = R[o], W = V.vertical, Y = V.horizontal, q = R.map(function(J) {
      var Q = J.horizontal, K = J.vertical, rt = [Q * Y * L[0], K * W * L[1]];
      if (Q) {
        if (k[0] === 1)
          return rt;
        if (k[0] < 4 && Q !== Y)
          return rt;
      } else {
        if (k[1] === 0)
          return rt[1] = K * Y * L[0] / z * X, rt;
        if (W) {
          if (k[1] === 1)
            return rt;
          if (k[1] < 4 && K !== W)
            return rt;
        }
      }
      return [0, 0];
    });
    q[o] = L;
    var Z = R.map(function(J, Q) {
      return plus(J.pos, q[Q]);
    });
    return e.prevDist = [M, D], triggerRoundEvent(n, t, L, B, R, Z), !0;
  },
  dragControlEnd: function(n, t) {
    var e = n.state;
    e.borderRadiusState = "";
    var o = t.datas, R = t.isDouble;
    if (!o.isRound)
      return !1;
    var N = e.width, M = e.height, D = o.isControl, L = o.controlIndex, B = o.isLine, $ = o.lineIndex, k = o.controlPoses, U = k.map(function(Z) {
      return Z.pos;
    }), z = U.length, X = n.props.roundClickable, V = X === void 0 ? !0 : X;
    if (R && V) {
      if (D)
        removeRadiusPos(k, U, L, 0);
      else if (B) {
        var W = calculatePointerDist(n, t), Y = W[0], q = W[1];
        addBorderRadius(k, U, $, Y, q, N, M);
      }
      z !== k.length && triggerRoundEvent(n, t, [0, 0], [0, 0], k, U);
    }
    return triggerEvent(n, "onRoundEnd", fillEndParams(n, t, {})), e.borderRadiusState = "", !0;
  },
  unset: function(n) {
    n.state.borderRadiusState = "";
  }
};
function isIdentityMatrix(n, t) {
  var e = t ? 4 : 3, o = createIdentityMatrix(e), R = "matrix".concat(t ? "3d" : "", "(").concat(o.join(","), ")");
  return n === R || n === "matrix(1,0,0,1,0,0)";
}
var BeforeRenderable = {
  isPinch: !0,
  name: "beforeRenderable",
  props: {},
  events: {
    onBeforeRenderStart: "beforeRenderStart",
    onBeforeRender: "beforeRender",
    onBeforeRenderEnd: "beforeRenderEnd",
    onBeforeRenderGroupStart: "beforeRenderGroupStart",
    onBeforeRenderGroup: "beforeRenderGroup",
    onBeforeRenderGroupEnd: "beforeRenderGroupEnd"
  },
  dragRelation: "weak",
  setTransform: function(n, t) {
    var e = n.state, o = e.is3d, R = e.target, N = e.targetMatrix, M = R == null ? void 0 : R.style.transform, D = o ? "matrix3d(".concat(N.join(","), ")") : "matrix(".concat(convertMatrixtoCSS(N, !0), ")"), L = !M || M === "none" ? D : M;
    t.datas.startTransforms = isIdentityMatrix(L, o) ? [] : splitSpace(L);
  },
  resetStyle: function(n) {
    var t = n.datas;
    t.nextStyle = {}, t.nextTransforms = n.datas.startTransforms, t.nextTransformAppendedIndexes = [];
  },
  fillDragStartParams: function(n, t) {
    return fillParams(n, t, {
      setTransform: function(e) {
        t.datas.startTransforms = isArray(e) ? e : splitSpace(e);
      },
      isPinch: !!t.isPinch
    });
  },
  fillDragParams: function(n, t) {
    return fillParams(n, t, {
      isPinch: !!t.isPinch
    });
  },
  dragStart: function(n, t) {
    this.setTransform(n, t), triggerEvent(n, "onBeforeRenderStart", this.fillDragStartParams(n, t));
  },
  drag: function(n, t) {
    this.resetStyle(t);
    var e = t.datas;
    e.nextStyle = {}, triggerEvent(n, "onBeforeRender", fillParams(n, t, {
      isPinch: !!t.isPinch
    }));
  },
  dragEnd: function(n, t) {
    triggerEvent(n, "onBeforeRenderEnd", fillParams(n, t, {
      isPinch: !!t.isPinch,
      isDrag: t.isDrag
    }));
  },
  dragGroupStart: function(n, t) {
    var e = this;
    this.dragStart(n, t);
    var o = fillChildEvents(n, "beforeRenderable", t), R = n.moveables, N = o.map(function(M, D) {
      var L = R[D];
      return e.setTransform(L, M), e.fillDragStartParams(L, M);
    });
    triggerEvent(n, "onBeforeRenderGroupStart", fillParams(n, t, {
      isPinch: !!t.isPinch,
      targets: n.props.targets,
      setTransform: function() {
      },
      events: N
    }));
  },
  dragGroup: function(n, t) {
    var e = this;
    this.drag(n, t);
    var o = fillChildEvents(n, "beforeRenderable", t), R = n.moveables, N = o.map(function(M, D) {
      var L = R[D];
      e.resetStyle(M);
      var B = t.datas;
      return B.nextStyle = {}, e.fillDragParams(L, M);
    });
    triggerEvent(n, "onBeforeRenderGroup", fillParams(n, t, {
      isPinch: !!t.isPinch,
      targets: n.props.targets,
      events: N
    }));
  },
  dragGroupEnd: function(n, t) {
    this.dragEnd(n, t), triggerEvent(n, "onBeforeRenderGroupEnd", fillParams(n, t, {
      isPinch: !!t.isPinch,
      isDrag: t.isDrag,
      targets: n.props.targets
    }));
  },
  dragControlStart: function(n, t) {
    return this.dragStart(n, t);
  },
  dragControl: function(n, t) {
    return this.drag(n, t);
  },
  dragControlEnd: function(n, t) {
    return this.dragEnd(n, t);
  },
  dragGroupControlStart: function(n, t) {
    return this.dragGroupStart(n, t);
  },
  dragGroupControl: function(n, t) {
    return this.dragGroup(n, t);
  },
  dragGroupControlEnd: function(n, t) {
    return this.dragGroupEnd(n, t);
  }
}, Renderable = {
  name: "renderable",
  props: {},
  events: {
    onRenderStart: "renderStart",
    onRender: "render",
    onRenderEnd: "renderEnd",
    onRenderGroupStart: "renderGroupStart",
    onRenderGroup: "renderGroup",
    onRenderGroupEnd: "renderGroupEnd"
  },
  dragRelation: "weak",
  dragStart: function(n, t) {
    triggerEvent(n, "onRenderStart", fillParams(n, t, {
      isPinch: !!t.isPinch
    }));
  },
  drag: function(n, t) {
    triggerEvent(n, "onRender", this.fillDragParams(n, t));
  },
  dragAfter: function(n, t) {
    if (t.resultCount)
      return this.drag(n, t);
  },
  dragEnd: function(n, t) {
    triggerEvent(n, "onRenderEnd", this.fillDragEndParams(n, t));
  },
  dragGroupStart: function(n, t) {
    triggerEvent(n, "onRenderGroupStart", fillParams(n, t, {
      isPinch: !!t.isPinch,
      targets: n.props.targets
    }));
  },
  dragGroup: function(n, t) {
    var e = this, o = fillChildEvents(n, "beforeRenderable", t), R = n.moveables, N = o.map(function(M, D) {
      var L = R[D];
      return e.fillDragParams(L, M);
    });
    triggerEvent(n, "onRenderGroup", fillParams(n, t, __assign$2(__assign$2({
      isPinch: !!t.isPinch,
      targets: n.props.targets,
      transform: getNextTransformText(t)
    }, fillCSSObject(getNextStyle(t))), {
      events: N
    })));
  },
  dragGroupEnd: function(n, t) {
    var e = this, o = fillChildEvents(n, "beforeRenderable", t), R = n.moveables, N = o.map(function(M, D) {
      var L = R[D];
      return e.fillDragEndParams(L, M);
    });
    triggerEvent(n, "onRenderGroupEnd", fillParams(n, t, {
      isPinch: !!t.isPinch,
      isDrag: t.isDrag,
      targets: n.props.targets,
      events: N
    }));
  },
  dragControlStart: function(n, t) {
    return this.dragStart(n, t);
  },
  dragControl: function(n, t) {
    return this.drag(n, t);
  },
  dragControlAfter: function(n, t) {
    return this.dragAfter(n, t);
  },
  dragControlEnd: function(n, t) {
    return this.dragEnd(n, t);
  },
  dragGroupControlStart: function(n, t) {
    return this.dragGroupStart(n, t);
  },
  dragGroupControl: function(n, t) {
    return this.dragGroup(n, t);
  },
  dragGroupControlEnd: function(n, t) {
    return this.dragGroupEnd(n, t);
  },
  fillDragParams: function(n, t) {
    return fillParams(n, t, __assign$2({
      isPinch: !!t.isPinch,
      transform: getNextTransformText(t)
    }, fillCSSObject(getNextStyle(t))));
  },
  fillDragEndParams: function(n, t) {
    return fillParams(n, t, {
      isPinch: !!t.isPinch,
      isDrag: t.isDrag
    });
  }
};
function triggerAble(n, t, e, o, R, N, M) {
  var D = R === "Start", L = n.state.target, B = N.isRequest;
  if (!L || D && o.indexOf("Control") > -1 && !B && n.areaElement === N.inputEvent.target)
    return !1;
  var $ = "".concat(e).concat(o).concat(R), k = "".concat(e).concat(o, "Condition"), U = R === "End", z = R === "After", X = D && (!n.targetGesto || !n.controlGesto || !n.targetGesto.isFlag() || !n.controlGesto.isFlag());
  X && n.updateRect(R, !0, !1), R === "" && !B && convertDragDist(n.state, N);
  var V = __spreadArray([], n[t], !0);
  if (B) {
    var W = N.requestAble;
    V.some(function(ut) {
      return ut.name === W;
    }) || V.push.apply(V, n.props.ables.filter(function(ut) {
      return ut.name === W;
    }));
  }
  if (!V.length || V.every(function(ut) {
    return ut.dragRelation;
  }))
    return !1;
  var Y = __spreadArray(__spreadArray([BeforeRenderable], V, !0), [Renderable], !1).filter(function(ut) {
    return ut[$];
  }), q = N.datas;
  X && Y.forEach(function(ut) {
    ut.unset && ut.unset(n);
  });
  var Z = N.inputEvent, J;
  U && Z && (J = document.elementFromPoint(N.clientX, N.clientY) || Z.target);
  var Q = 0, K = !1, rt = function() {
    var ut;
    K = !0, (ut = N.stop) === null || ut === void 0 || ut.call(N);
  }, tt = Y.filter(function(ut) {
    var dt = ut.name, yt = q[dt] || (q[dt] = {});
    if (D && (yt.isEventStart = !ut[k] || ut[k](n, N)), yt.isEventStart) {
      var pt = ut[$](n, __assign$2(__assign$2({}, N), {
        stop: rt,
        resultCount: Q,
        datas: yt,
        originalDatas: q,
        inputTarget: J
      }));
      return n._emitter.off(), D && pt === !1 && (yt.isEventStart = !1), Q += pt ? 1 : 0, pt;
    }
    return !1;
  }), nt = tt.length, at = !1;
  if (D && (K || Y.length && !nt) && (at = K || Y.filter(function(ut) {
    var dt = ut.name, yt = q[dt];
    return yt.isEventStart ? ut.dragRelation !== "strong" : !1;
  }).length), (U || at) && (n.state.gestos = {}, n.moveables && n.moveables.forEach(function(ut) {
    ut.state.gestos = {};
  })), X && at && Y.forEach(function(ut) {
    ut.unset && ut.unset(n);
  }), D && !at && !B && nt && (N == null || N.preventDefault()), n.isUnmounted || at)
    return !1;
  if (!D && nt && !M || U) {
    var lt = n.props.flushSync || defaultSync;
    lt(function() {
      n.updateRect(U ? R : "", !0, !1), n.forceUpdate();
    });
  }
  return !D && !U && !z && nt && !M && triggerAble(n, t, e, o, R + "After", N), !0;
}
function getTargetAbleGesto(n, t, e) {
  var o = n.controlBox.getElement(), R = [];
  R.push(o), (!n.props.dragArea || n.props.dragTarget) && R.push(t);
  var N = function(M) {
    var D = M.inputEvent.target, L = n.areaElement;
    return D === L || !n.isMoveableElement(D) && !n.controlBox.getElement().contains(D) || hasClass(D, "moveable-area") || hasClass(D, "moveable-padding");
  };
  return getAbleGesto(n, R, "targetAbles", e, {
    dragStart: N,
    pinchStart: N
  });
}
function getAbleGesto(n, t, e, o, R) {
  R === void 0 && (R = {});
  var N = e === "targetAbles", M = n.props, D = M.pinchOutside, L = M.pinchThreshold, B = M.preventClickEventOnDrag, $ = M.preventClickDefault, k = M.checkInput, U = {
    preventDefault: !0,
    preventRightClick: !0,
    preventWheelClick: !0,
    container: window,
    pinchThreshold: L,
    pinchOutside: D,
    preventClickEventOnDrag: N ? B : !1,
    preventClickEventOnDragStart: N ? $ : !1,
    preventClickEventByCondition: N ? null : function(V) {
      return n.controlBox.getElement().contains(V.target);
    },
    checkInput: N ? k : !1
  }, z = new Gesto$1(t, U), X = o === "Control";
  return ["drag", "pinch"].forEach(function(V) {
    ["Start", "", "End"].forEach(function(W) {
      z.on("".concat(V).concat(W), function(Y) {
        var q, Z = Y.eventType;
        if (R[Z] && !R[Z](Y)) {
          Y.stop();
          return;
        }
        var J = triggerAble(n, e, V, o, W, Y);
        J ? (n.props.stopPropagation || W === "Start" && X) && ((q = Y == null ? void 0 : Y.inputEvent) === null || q === void 0 || q.stopPropagation()) : Y.stop();
      });
    });
  }), z;
}
var EventManager = /* @__PURE__ */ function() {
  function n(e, o, R) {
    var N = this;
    this.target = e, this.moveable = o, this.eventName = R, this.ables = [], this._onEvent = function(M) {
      var D = N.eventName, L = N.moveable;
      L.state.disableNativeEvent || N.ables.forEach(function(B) {
        B[D](L, {
          inputEvent: M
        });
      });
    }, e.addEventListener(R.toLowerCase(), this._onEvent);
  }
  var t = n.prototype;
  return t.setAbles = function(e) {
    this.ables = e;
  }, t.destroy = function() {
    this.target.removeEventListener(this.eventName.toLowerCase(), this._onEvent), this.target = null, this.moveable = null;
  }, n;
}();
function getShadowRoot(n) {
  if (n && n.getRootNode) {
    var t = n.getRootNode();
    if (t.nodeType === 11)
      return t;
  }
}
function getMatrixStackInfo(n, t, e) {
  for (var o = n, R = [], N = !e && n === t || n === document.body, M = N, D = !1, L = 3, B, $, k, U = !1, z = getOffsetInfo(t, t, !0).offsetParent; o && !M; ) {
    M = N;
    var X = getComputedStyle(o), V = X.position, W = getElementTransform(o, X), Y = convertCSStoMatrix(getTransformMatrix(W)), q = V === "fixed", Z = {
      hasTransform: !1,
      fixedContainer: null
    };
    q && (U = !0, Z = getPositionFixedInfo(o), z = Z.fixedContainer);
    var J = Y.length;
    !D && J === 16 && (D = !0, L = 4, convert3DMatrixes(R), k && (k = convertDimension(k, 3, 4))), D && J === 9 && (Y = convertDimension(Y, 3, 4));
    var Q = getOffsetPosInfo(o, n, X), K = Q.tagName, rt = Q.hasOffset, tt = Q.isSVG, nt = Q.origin, at = Q.targetOrigin, lt = Q.offset, ut = lt[0], dt = lt[1];
    K === "svg" && k && (R.push({
      type: "target",
      target: o,
      matrix: getSVGMatrix(o, L)
    }), R.push({
      type: "offset",
      target: o,
      matrix: createIdentityMatrix(L)
    }));
    var yt = void 0, pt = !1, gt = !1;
    if (q)
      yt = Z.fixedContainer, pt = !0;
    else {
      var xt = getOffsetInfo(o, t);
      if (yt = xt.offsetParent, pt = xt.isEnd, gt = xt.isStatic, IS_FIREFOX) {
        var Lt = xt.parentSlotElement;
        if (Lt) {
          for (var mt = yt, ct = 0, vt = 0; mt && getShadowRoot(mt); )
            ct += mt.offsetLeft, vt += mt.offsetTop, mt = mt.offsetParent;
          ut -= ct, dt -= vt;
        }
      }
    }
    IS_WEBKIT && !IS_SAFARI_ABOVE15 && rt && !tt && gt && (V === "relative" || V === "static") && (ut -= yt.offsetLeft, dt -= yt.offsetTop, N = N || pt);
    var Tt = 0, Pt = 0, wt = 0, Mt = 0;
    if (q)
      rt && Z.hasTransform && (wt = yt.clientLeft, Mt = yt.clientTop);
    else if (rt && z !== yt && (Tt = yt.clientLeft, Pt = yt.clientTop), rt && yt === document.body) {
      var ht = getBodyOffset(o, !1, X);
      ut += ht[0], dt += ht[1];
    }
    if (R.push({
      type: "target",
      target: o,
      matrix: getAbsoluteMatrix(Y, L, nt)
    }), rt ? R.push({
      type: "offset",
      target: o,
      matrix: createOriginMatrix([ut - o.scrollLeft + Tt - wt, dt - o.scrollTop + Pt - Mt], L)
    }) : R.push({
      type: "offset",
      target: o,
      origin: nt
    }), k || (k = Y), B || (B = nt), $ || ($ = at), M || q)
      break;
    o = yt, N = pt, (!e || o === document.body) && (M = N);
  }
  return k || (k = createIdentityMatrix(L)), B || (B = [0, 0]), $ || ($ = [0, 0]), {
    offsetContainer: z,
    matrixes: R,
    targetMatrix: k,
    transformOrigin: B,
    targetOrigin: $,
    is3d: D,
    hasFixed: U
  };
}
function calculateMatrixStack(n, t, e, o) {
  var R;
  e === void 0 && (e = t);
  var N = getMatrixStackInfo(n, t), M = N.matrixes, D = N.is3d, L = N.targetMatrix, B = N.transformOrigin, $ = N.targetOrigin, k = N.offsetContainer, U = N.hasFixed, z = getMatrixStackInfo(k, e, !0), X = z.matrixes, V = z.is3d, W = z.offsetContainer, Y = o || V || D, q = Y ? 4 : 3, Z = n.tagName.toLowerCase() !== "svg" && "ownerSVGElement" in n, J = L, Q = createIdentityMatrix(q), K = createIdentityMatrix(q), rt = createIdentityMatrix(q), tt = createIdentityMatrix(q), nt = M.length;
  X.reverse(), M.reverse(), !D && Y && (J = convertDimension(J, 3, 4), convert3DMatrixes(M)), !V && Y && convert3DMatrixes(X), X.forEach(function(pt) {
    K = multiply(K, pt.matrix, q);
  });
  var at = e || document.body, lt = ((R = X[0]) === null || R === void 0 ? void 0 : R.target) || getOffsetInfo(at, at, !0).offsetParent, ut = X.slice(1).reduce(function(pt, gt) {
    return multiply(pt, gt.matrix, q);
  }, createIdentityMatrix(q));
  M.forEach(function(pt, gt) {
    if (nt - 2 === gt && (rt = Q.slice()), nt - 1 === gt && (tt = Q.slice()), !pt.matrix) {
      var xt = M[gt + 1], Lt = getSVGOffset(pt, xt, lt, q, multiply(ut, Q, q));
      pt.matrix = createOriginMatrix(Lt, q);
    }
    Q = multiply(Q, pt.matrix, q);
  });
  var dt = !Z && D;
  J || (J = createIdentityMatrix(dt ? 4 : 3));
  var yt = makeMatrixCSS(Z && J.length === 16 ? convertDimension(J, 4, 3) : J, dt);
  return K = ignoreDimension(K, q, q), {
    hasFixed: U,
    rootMatrix: K,
    beforeMatrix: rt,
    offsetMatrix: tt,
    allMatrix: Q,
    targetMatrix: J,
    targetTransform: yt,
    transformOrigin: B,
    targetOrigin: $,
    is3d: Y,
    offsetContainer: k,
    offsetRootContainer: W
  };
}
function calculateElementInfo(n, t, e, o) {
  e === void 0 && (e = t);
  var R = 0, N = 0, M = 0, D = {}, L = getSize(n);
  if (n && (R = L.offsetWidth, N = L.offsetHeight), n) {
    var B = calculateMatrixStack(n, t, e, o), $ = calculateMoveablePosition(B.allMatrix, B.transformOrigin, R, N);
    D = __assign$2(__assign$2({}, B), $);
    var k = calculateMoveablePosition(B.allMatrix, [50, 50], 100, 100);
    M = getRotationRad([k.pos1, k.pos2], k.direction);
  }
  var U = o ? 4 : 3;
  return __assign$2(__assign$2(__assign$2({
    width: R,
    height: N,
    rotation: M
  }, L), {
    rootMatrix: createIdentityMatrix(U),
    beforeMatrix: createIdentityMatrix(U),
    offsetMatrix: createIdentityMatrix(U),
    allMatrix: createIdentityMatrix(U),
    targetMatrix: createIdentityMatrix(U),
    targetTransform: "",
    transformOrigin: [0, 0],
    targetOrigin: [0, 0],
    is3d: !!o,
    left: 0,
    top: 0,
    right: 0,
    bottom: 0,
    origin: [0, 0],
    pos1: [0, 0],
    pos2: [0, 0],
    pos3: [0, 0],
    pos4: [0, 0],
    direction: 1,
    hasFixed: !1,
    offsetContainer: null,
    offsetRootContainer: null
  }), D);
}
function getMoveableTargetInfo(n, t, e, o, R) {
  var N = 1, M = [0, 0], D = resetClientRect(), L = resetClientRect(), B = resetClientRect(), $ = resetClientRect(), k = calculateElementInfo(t, e, R, !0);
  if (t) {
    var U = k.is3d ? 4 : 3, z = calculateMoveablePosition(k.offsetMatrix, plus(k.transformOrigin, getOrigin(k.targetMatrix, U)), k.width, k.height);
    N = z.direction, M = plus(z.origin, [z.left - k.left, z.top - k.top]), D = getClientRect(t);
    var X = getOffsetInfo(o, o, !0).offsetParent || k.offsetRootContainer;
    B = getClientRect(X, !0), $ = getClientRect(k.offsetRootContainer), n && (L = getClientRect(n));
  }
  return __assign$2({
    targetClientRect: D,
    containerClientRect: B,
    moveableClientRect: L,
    rootContainerClientRect: $,
    beforeDirection: N,
    beforeOrigin: M,
    originalBeforeOrigin: M,
    target: t
  }, k);
}
var MoveableManager$1 = /* @__PURE__ */ function(n) {
  __extends$1(t, n);
  function t() {
    var o = n !== null && n.apply(this, arguments) || this;
    return o.state = __assign$2({
      container: null,
      gestos: {},
      renderPoses: [[0, 0], [0, 0], [0, 0], [0, 0]],
      disableNativeEvent: !1
    }, getMoveableTargetInfo(null)), o.renderState = {}, o.enabledAbles = [], o.targetAbles = [], o.controlAbles = [], o.rotation = 0, o.scale = [1, 1], o.isUnmounted = !1, o.events = {
      mouseEnter: null,
      mouseLeave: null
    }, o._emitter = new EventEmitter$3(), o._prevTarget = null, o._prevDragArea = !1, o._isPropTargetChanged = !1, o._observer = null, o._observerId = 0, o.checkUpdateRect = function() {
      if (!o.isDragging()) {
        var R = o.props.parentMoveable;
        if (R) {
          R.checkUpdateRect();
          return;
        }
        cancelAnimationFrame$1(o._observerId), o._observerId = requestAnimationFrame$1(function() {
          o.isDragging() || o.updateRect();
        });
      }
    }, o._onPreventClick = function(R) {
      R.stopPropagation(), R.preventDefault();
    }, o;
  }
  var e = t.prototype;
  return e.render = function() {
    var o = this.props, R = this.state, N = o.parentPosition, M = o.className, D = o.target, L = o.zoom, B = o.cspNonce, $ = o.translateZ, k = o.cssStyled, U = o.portalContainer;
    this.checkUpdate(), this.updateRenderPoses();
    var z = N || {
      left: 0,
      top: 0
    }, X = z.left, V = z.top, W = R.left, Y = R.top, q = R.target, Z = R.direction, J = R.hasFixed, Q = o.targets, K = (Q && Q.length || D) && q, rt = this.isDragging(), tt = {};
    return this.getEnabledAbles().forEach(function(nt) {
      tt["data-able-".concat(nt.name.toLowerCase())] = !0;
    }), createElement(k, __assign$2({
      cspNonce: B,
      ref: ref(this, "controlBox"),
      className: "".concat(prefix("control-box", Z === -1 ? "reverse" : "", rt ? "dragging" : ""), " ").concat(M)
    }, tt, {
      onClick: this._onPreventClick,
      portalContainer: U,
      style: {
        position: J ? "fixed" : "absolute",
        display: K ? "block" : "none",
        transform: "translate3d(".concat(W - X, "px, ").concat(Y - V, "px, ").concat($, ")"),
        "--zoom": L,
        "--zoompx": "".concat(L, "px")
      }
    }), this.renderAbles(), this._renderLines());
  }, e.componentDidMount = function() {
    this.isUnmounted = !1, this.controlBox.getElement();
    var o = this.props, R = o.parentMoveable, N = o.container, M = o.wrapperMoveable;
    this._updateTargets(), this._updateNativeEvents(), this._updateEvents(), !N && !R && !M && this.updateRect("", !1, !0), this.updateCheckInput(), this._updateObserver(this.props);
  }, e.componentDidUpdate = function(o) {
    this._updateNativeEvents(), this._updateEvents(), this._updateTargets(), this.updateCheckInput(), this._updateObserver(o);
  }, e.componentWillUnmount = function() {
    this.isUnmounted = !0, this._emitter.off(), unset(this, "targetGesto"), unset(this, "controlGesto");
    var o = this.events;
    for (var R in o) {
      var N = o[R];
      N && N.destroy();
    }
  }, e.getAble = function(o) {
    var R = this.props.ables || [];
    return find$1(R, function(N) {
      return N.name === o;
    });
  }, e.getContainer = function() {
    var o = this.props, R = o.parentMoveable, N = o.wrapperMoveable, M = o.container;
    return M || N && N.getContainer() || R && R.getContainer() || this.controlBox.getElement().parentElement;
  }, e.isMoveableElement = function(o) {
    var R;
    return o && (((R = o.getAttribute) === null || R === void 0 ? void 0 : R.call(o, "class")) || "").indexOf(PREFIX) > -1;
  }, e.dragStart = function(o) {
    var R = this.targetGesto;
    return R && !R.isFlag() && R.triggerDragStart(o), this;
  }, e.hitTest = function(o) {
    var R = this.state, N = R.target, M = R.pos1, D = R.pos2, L = R.pos3, B = R.pos4, $ = R.targetClientRect;
    if (!N)
      return 0;
    var k;
    if (o instanceof Element) {
      var U = o.getBoundingClientRect();
      k = {
        left: U.left,
        top: U.top,
        width: U.width,
        height: U.height
      };
    } else
      k = __assign$2({
        width: 0,
        height: 0
      }, o);
    var z = k.left, X = k.top, V = k.width, W = k.height, Y = fitPoints([M, D, B, L], $), q = getOverlapSize(Y, [[z, X], [z + V, X], [z + V, X + W], [z, X + W]]), Z = getAreaSize(Y);
    return !q || !Z ? 0 : Math.min(100, q / Z * 100);
  }, e.isInside = function(o, R) {
    var N = this.state, M = N.target, D = N.pos1, L = N.pos2, B = N.pos3, $ = N.pos4, k = N.targetClientRect;
    return M ? isInside([o, R], fitPoints([D, L, $, B], k)) : !1;
  }, e.updateRect = function(o, R, N) {
    N === void 0 && (N = !0);
    var M = this.props, D = M.parentMoveable, L = this.state, B = L.target || this.props.target, $ = this.getContainer(), k = D ? D.props.rootContainer : M.rootContainer;
    this.updateState(getMoveableTargetInfo(this.controlBox && this.controlBox.getElement(), B, $, $, k || $), D ? !1 : N);
  }, e.isDragging = function() {
    return (this.targetGesto ? this.targetGesto.isFlag() : !1) || (this.controlGesto ? this.controlGesto.isFlag() : !1);
  }, e.updateTarget = function(o) {
    this.updateRect(o, !0);
  }, e.getRect = function() {
    var o = this.state, R = getAbsolutePosesByState(this.state), N = R[0], M = R[1], D = R[2], L = R[3], B = getRect(R), $ = o.width, k = o.height, U = B.width, z = B.height, X = B.left, V = B.top, W = [o.left, o.top], Y = plus(W, o.origin), q = plus(W, o.beforeOrigin), Z = o.transformOrigin;
    return {
      width: U,
      height: z,
      left: X,
      top: V,
      pos1: N,
      pos2: M,
      pos3: D,
      pos4: L,
      offsetWidth: $,
      offsetHeight: k,
      beforeOrigin: q,
      origin: Y,
      transformOrigin: Z,
      rotation: this.getRotation()
    };
  }, e.getManager = function() {
    return this;
  }, e.getRotation = function() {
    var o = this.state, R = o.pos1, N = o.pos2, M = o.direction;
    return getAbsoluteRotation(R, N, M);
  }, e.request = function(o, R, N) {
    R === void 0 && (R = {});
    var M = this.props, D = M.ables, L = M.groupable, B = D.filter(function(W) {
      return W.name === o;
    })[0];
    if (this.isDragging() || !B || !B.request)
      return {
        request: function() {
          return this;
        },
        requestEnd: function() {
          return this;
        }
      };
    var $ = this, k = B.request(this), U = N || R.isInstant, z = k.isControl ? "controlAbles" : "targetAbles", X = "".concat(L ? "Group" : "").concat(k.isControl ? "Control" : ""), V = {
      request: function(W) {
        return triggerAble($, z, "drag", X, "", __assign$2(__assign$2({}, k.request(W)), {
          requestAble: o,
          isRequest: !0
        }), U), this;
      },
      requestEnd: function() {
        return triggerAble($, z, "drag", X, "End", __assign$2(__assign$2({}, k.requestEnd()), {
          requestAble: o,
          isRequest: !0
        }), U), this;
      }
    };
    return triggerAble($, z, "drag", X, "Start", __assign$2(__assign$2({}, k.requestStart(R)), {
      requestAble: o,
      isRequest: !0
    }), U), U ? V.request(R).requestEnd() : V;
  }, e.destroy = function() {
    this.componentWillUnmount();
  }, e.updateRenderPoses = function() {
    var o = this.state, R = this.props, N = o.originalBeforeOrigin, M = o.transformOrigin, D = o.allMatrix, L = o.is3d, B = o.pos1, $ = o.pos2, k = o.pos3, U = o.pos4, z = o.left, X = o.top, V = R.padding || {}, W = V.left, Y = W === void 0 ? 0 : W, q = V.top, Z = q === void 0 ? 0 : q, J = V.bottom, Q = J === void 0 ? 0 : J, K = V.right, rt = K === void 0 ? 0 : K, tt = L ? 4 : 3, nt = R.groupable ? N : plus(N, [z, X]);
    o.renderPoses = [plus(B, calculatePadding(D, [-Y, -Z], M, nt, tt)), plus($, calculatePadding(D, [rt, -Z], M, nt, tt)), plus(k, calculatePadding(D, [-Y, Q], M, nt, tt)), plus(U, calculatePadding(D, [rt, Q], M, nt, tt))];
  }, e.checkUpdate = function() {
    this._isPropTargetChanged = !1;
    var o = this.props, R = o.target, N = o.container, M = o.parentMoveable, D = this.state, L = D.target, B = D.container;
    if (!(!L && !R)) {
      this.updateAbles();
      var $ = !equals(L, R), k = $ || !equals(B, N);
      if (!!k) {
        var U = N || this.controlBox;
        U && this.unsetAbles(), this.updateState({
          target: R,
          container: N
        }), !M && U && this.updateRect("End", !1, !1), this._isPropTargetChanged = $;
      }
    }
  }, e.waitToChangeTarget = function() {
    return new Promise(function() {
    });
  }, e.triggerEvent = function(o, R) {
    this._emitter.trigger(o, R);
    var N = this.props[o];
    return N && N(R);
  }, e.useCSS = function(o, R) {
    var N = this.props.customStyledMap, M = o + R;
    return N[M] || (N[M] = styled(o, R)), N[M];
  }, e.unsetAbles = function() {
    var o = this;
    this.targetAbles.forEach(function(R) {
      R.unset && R.unset(o);
    });
  }, e.updateAbles = function(o, R) {
    o === void 0 && (o = this.props.ables), R === void 0 && (R = "");
    var N = this.props, M = N.triggerAblesSimultaneously, D = o.filter(function(z) {
      return z && (z.always && N[z.name] !== !1 || N[z.name]);
    }), L = "drag".concat(R, "Start"), B = "pinch".concat(R, "Start"), $ = "drag".concat(R, "ControlStart"), k = filterAbles(D, [L, B], M), U = filterAbles(D, [$], M);
    this.enabledAbles = D, this.targetAbles = k, this.controlAbles = U;
  }, e.updateState = function(o, R) {
    if (R) {
      if (this.isUnmounted)
        return;
      this.setState(o);
    } else {
      var N = this.state;
      for (var M in o)
        N[M] = o[M];
    }
  }, e.getEnabledAbles = function() {
    var o = this.props, R = o.ables;
    return R.filter(function(N) {
      return N && o[N.name];
    });
  }, e.renderAbles = function() {
    var o = this, R = this.props, N = R.triggerAblesSimultaneously, M = {
      createElement
    };
    return this.renderState = {}, groupByMap(flat(filterAbles(this.getEnabledAbles(), ["render"], N).map(function(D) {
      var L = D.render;
      return L(o, M) || [];
    })).filter(function(D) {
      return D;
    }), function(D) {
      var L = D.key;
      return L;
    }).map(function(D) {
      return D[0];
    });
  }, e.updateCheckInput = function() {
    this.targetGesto && (this.targetGesto.options.checkInput = this.props.checkInput);
  }, e._updateObserver = function(o) {
    var R, N = this.props, M = N.target;
    if (!window.ResizeObserver || !M || !N.useResizeObserver) {
      (R = this._observer) === null || R === void 0 || R.disconnect();
      return;
    }
    if (!(o.target === M && this._observer)) {
      var D = new ResizeObserver(this.checkUpdateRect);
      D.observe(M, {
        box: "border-box"
      }), this._observer = D;
    }
  }, e._updateEvents = function() {
    var o = this.controlBox.getElement(), R = this.targetAbles.length, N = this.controlAbles.length, M = this.props, D = M.dragTarget || M.target, L = !R && this.targetGesto || this._isTargetChanged(!0);
    L && (unset(this, "targetGesto"), this.updateState({
      gesto: null
    })), N || unset(this, "controlGesto"), D && R && !this.targetGesto && (this.targetGesto = getTargetAbleGesto(this, D, "")), !this.controlGesto && N && (this.controlGesto = getAbleGesto(this, o, "controlAbles", "Control"));
  }, e._updateTargets = function() {
    var o = this.props;
    this._prevTarget = o.dragTarget || o.target, this._prevDragArea = o.dragArea;
  }, e._renderLines = function() {
    var o = this.props, R = o, N = R.zoom, M = R.hideDefaultLines, D = R.hideChildMoveableDefaultLines, L = R.parentMoveable;
    if (M || L && D)
      return [];
    var B = this.state.renderPoses, $ = {
      createElement
    };
    return [[0, 1], [1, 3], [3, 2], [2, 0]].map(function(k, U) {
      var z = k[0], X = k[1];
      return renderLine($, "", B[z], B[X], N, U);
    });
  }, e._isTargetChanged = function(o) {
    var R = this.props, N = R.dragTarget || R.target, M = this._prevTarget, D = this._prevDragArea, L = R.dragArea, B = !L && M !== N, $ = (o || L) && D !== L;
    return B || $;
  }, e._updateNativeEvents = function() {
    var o = this, R = this.props, N = R.dragArea ? this.areaElement : this.state.target, M = this.events, D = getKeys(M);
    if (this._isTargetChanged())
      for (var L in M) {
        var B = M[L];
        B && B.destroy(), M[L] = null;
      }
    if (!!N) {
      var $ = this.enabledAbles;
      D.forEach(function(k) {
        var U = filterAbles($, [k]), z = U.length > 0, X = M[k];
        if (!z) {
          X && (X.destroy(), M[k] = null);
          return;
        }
        X || (X = new EventManager(N, o, k), M[k] = X), X.setAbles(U);
      });
    }
  }, t.defaultProps = {
    target: null,
    dragTarget: null,
    container: null,
    rootContainer: null,
    origin: !0,
    parentMoveable: null,
    wrapperMoveable: null,
    parentPosition: null,
    portalContainer: null,
    useResizeObserver: !1,
    ables: [],
    pinchThreshold: 20,
    dragArea: !1,
    passDragArea: !1,
    transformOrigin: "",
    className: "",
    zoom: 1,
    triggerAblesSimultaneously: !1,
    padding: {},
    pinchOutside: !0,
    checkInput: !1,
    groupable: !1,
    hideDefaultLines: !1,
    cspNonce: "",
    translateZ: 0,
    cssStyled: null,
    customStyledMap: {},
    props: {},
    stopPropagation: !1,
    preventClickDefault: !1,
    preventClickEventOnDrag: !0,
    flushSync: defaultSync
  }, t;
}(PureComponent), Groupable = {
  name: "groupable",
  props: {
    defaultGroupRotate: Number,
    defaultGroupOrigin: String,
    groupable: Boolean,
    hideChildMoveableDefaultLines: Boolean
  },
  events: {},
  render: function(n, t) {
    var e = n.props.targets || [];
    n.moveables = [];
    var o = n.state, R = o.left, N = o.top, M = {
      left: R,
      top: N
    }, D = n.props;
    return e.map(function(L, B) {
      return t.createElement(MoveableManager$1, {
        key: "moveable" + B,
        ref: refs(n, "moveables", B),
        target: L,
        origin: !1,
        cssStyled: D.cssStyled,
        customStyledMap: D.customStyledMap,
        useResizeObserver: D.useResizeObserver,
        hideChildMoveableDefaultLines: D.hideChildMoveableDefaultLines,
        parentMoveable: n,
        parentPosition: M
      });
    });
  }
}, Clickable = makeAble("clickable", {
  props: {
    clickable: Boolean
  },
  events: {
    onClick: "click",
    onClickGroup: "clickGroup"
  },
  always: !0,
  dragRelation: "weak",
  dragStart: function() {
  },
  dragControlStart: function() {
    this.dragStart();
  },
  dragGroupStart: function(n, t) {
    t.datas.inputTarget = t.inputEvent && t.inputEvent.target;
  },
  dragEnd: function(n, t) {
    var e = n.state.target, o = t.inputEvent, R = t.inputTarget, N = n.isMoveableElement(R), M = !N && n.controlBox.getElement().contains(R);
    if (!(!o || !R || t.isDrag || n.isMoveableElement(R) || M)) {
      var D = e.contains(R);
      triggerEvent(n, "onClick", fillParams(n, t, {
        isDouble: t.isDouble,
        inputTarget: R,
        isTarget: e === R,
        containsTarget: D
      }));
    }
  },
  dragGroupEnd: function(n, t) {
    var e = t.inputEvent, o = t.inputTarget;
    if (!(!e || !o || t.isDrag || n.isMoveableElement(o) || t.datas.inputTarget === o)) {
      var R = n.props.targets, N = R.indexOf(o), M = N > -1, D = !1;
      N === -1 && (N = findIndex(R, function(L) {
        return L.contains(o);
      }), D = N > -1), triggerEvent(n, "onClickGroup", fillParams(n, t, {
        isDouble: t.isDouble,
        targets: R,
        inputTarget: o,
        targetIndex: N,
        isTarget: M,
        containsTarget: D
      }));
    }
  },
  dragControlEnd: function(n, t) {
    this.dragEnd(n, t);
  },
  dragGroupControlEnd: function(n, t) {
    this.dragEnd(n, t);
  }
});
function getDraggableEvent(n) {
  var t = n.originalDatas.draggable;
  return t || (n.originalDatas.draggable = {}, t = n.originalDatas.draggable), __assign$2(__assign$2({}, n), {
    datas: t
  });
}
var edgeDraggable = makeAble("edgeDraggable", {
  css: [`.edge.edgeDraggable.line {
    cursor: move;
}`],
  render: function(n, t) {
    var e = n.props, o = e.edgeDraggable;
    return o ? renderEdgeLines(t, "edgeDraggable", o, n.state.renderPoses, e.zoom) : [];
  },
  dragControlCondition: function(n, t) {
    if (!n.props.edgeDraggable || !t.inputEvent)
      return !1;
    var e = t.inputEvent.target;
    return hasClass(e, prefix("direction")) && hasClass(e, prefix("edge")) && hasClass(e, prefix("edgeDraggable"));
  },
  dragControlStart: function(n, t) {
    return n.state.snapRenderInfo = {
      request: t.isRequest,
      snap: !0,
      center: !0
    }, Draggable.dragStart(n, getDraggableEvent(t));
  },
  dragControl: function(n, t) {
    return Draggable.drag(n, getDraggableEvent(t));
  },
  dragControlEnd: function(n, t) {
    return Draggable.dragEnd(n, getDraggableEvent(t));
  },
  dragGroupControlCondition: function(n, t) {
    if (!n.props.edgeDraggable || !t.inputEvent)
      return !1;
    var e = t.inputEvent.target;
    return hasClass(e, prefix("direction")) && hasClass(e, prefix("line"));
  },
  dragGroupControlStart: function(n, t) {
    return Draggable.dragGroupStart(n, getDraggableEvent(t));
  },
  dragGroupControl: function(n, t) {
    return Draggable.dragGroup(n, getDraggableEvent(t));
  },
  dragGroupControlEnd: function(n, t) {
    return Draggable.dragGroupEnd(n, getDraggableEvent(t));
  },
  unset: function(n) {
    return Draggable.unset(n);
  }
}), IndividualGroupable = {
  name: "individualGroupable",
  props: {
    individualGroupable: Boolean
  },
  events: {}
}, MOVEABLE_ABLES = [BeforeRenderable, Default, Snappable, Pinchable, Draggable, edgeDraggable, Resizable, Scalable, Warpable, Rotatable, Scrollable, Padding, Origin, OriginDraggable, Clippable, Roundable, Groupable, IndividualGroupable, Clickable, DragArea, Renderable], MOVEABLE_EVENTS_PROPS_MAP = /* @__PURE__ */ MOVEABLE_ABLES.reduce(function(n, t) {
  return __assign$2(__assign$2({}, n), "events" in t ? t.events : {});
}, {}), MOVEABLE_PROPS_MAP = /* @__PURE__ */ MOVEABLE_ABLES.reduce(function(n, t) {
  return __assign$2(__assign$2({}, n), t.props);
}, {}), MOVEABLE_EVENTS_MAP = /* @__PURE__ */ invertObject(MOVEABLE_EVENTS_PROPS_MAP), MOVEABLE_EVENTS = Object.keys(MOVEABLE_EVENTS_MAP), MOVEABLE_PROPS = Object.keys(MOVEABLE_PROPS_MAP);
function getMaxPos(n, t) {
  return Math.max.apply(Math, n.map(function(e) {
    var o = e[0], R = e[1], N = e[2], M = e[3];
    return Math.max(o[t], R[t], N[t], M[t]);
  }));
}
function getMinPos(n, t) {
  return Math.min.apply(Math, n.map(function(e) {
    var o = e[0], R = e[1], N = e[2], M = e[3];
    return Math.min(o[t], R[t], N[t], M[t]);
  }));
}
function getGroupRect(n, t) {
  if (!n.length)
    return [0, 0, 0, 0];
  var e = n.map(function(V) {
    var W = V.state;
    return getAbsolutePosesByState(W);
  }), o = MAX_NUM, R = MAX_NUM, N = 0, M = 0, D = throttle(t, TINY_NUM);
  if (D % 90) {
    var L = D / 180 * Math.PI, B = Math.tan(L), $ = -1 / B, k = [MIN_NUM, MAX_NUM], U = [MIN_NUM, MAX_NUM];
    e.forEach(function(V) {
      V.forEach(function(W) {
        var Y = W[1] - B * W[0], q = W[1] - $ * W[0];
        k[0] = Math.max(k[0], Y), k[1] = Math.min(k[1], Y), U[0] = Math.max(U[0], q), U[1] = Math.min(U[1], q);
      });
    }), k.forEach(function(V) {
      U.forEach(function(W) {
        var Y = (W - V) / (B - $), q = B * Y + V;
        o = Math.min(o, Y), R = Math.min(R, q);
      });
    });
    var z = e.map(function(V) {
      var W = V[0], Y = V[1], q = V[2], Z = V[3];
      return [rotate(W, -L), rotate(Y, -L), rotate(q, -L), rotate(Z, -L)];
    });
    N = getMaxPos(z, 0) - getMinPos(z, 0), M = getMaxPos(z, 1) - getMinPos(z, 1);
  } else if (o = getMinPos(e, 0), R = getMinPos(e, 1), N = getMaxPos(e, 0) - o, M = getMaxPos(e, 1) - R, D % 180) {
    var X = N;
    N = M, M = X;
  }
  return [o, R, N, M];
}
var MoveableGroup = /* @__PURE__ */ function(n) {
  __extends$1(t, n);
  function t() {
    var o = n !== null && n.apply(this, arguments) || this;
    return o.differ = new ChildrenDiffer$1(), o.moveables = [], o.transformOrigin = "50% 50%", o;
  }
  var e = t.prototype;
  return e.checkUpdate = function() {
    this._isPropTargetChanged = !1, this.updateAbles();
  }, e.updateRect = function(o, R, N) {
    if (N === void 0 && (N = !0), !!this.controlBox) {
      this.moveables.forEach(function(dt) {
        dt.updateRect(o, !1, !1);
      });
      var M = this.state, D = this.props, L = M.target || D.target;
      (!R || o !== "" && D.updateGroup) && (this.rotation = D.defaultGroupRotate, this.transformOrigin = D.defaultGroupOrigin || "50% 50%", this.scale = [1, 1]);
      var B = this.rotation, $ = this.scale, k = getGroupRect(this.moveables, B), U = k[0], z = k[1], X = k[2], V = k[3], W = "rotate(".concat(B, "deg) scale(").concat($[0] >= 0 ? 1 : -1, ", ").concat($[1] >= 0 ? 1 : -1, ")");
      L.style.cssText += "left:0px;top:0px; transform-origin: ".concat(this.transformOrigin, "; width:").concat(X, "px; height:").concat(V, "px;") + "transform:".concat(W), M.width = X, M.height = V;
      var Y = this.getContainer(), q = getMoveableTargetInfo(this.controlBox.getElement(), L, this.controlBox.getElement(), this.getContainer(), this.props.rootContainer || Y), Z = [q.left, q.top], J = getAbsolutePosesByState(q), Q = J[0], K = J[1], rt = J[2], tt = J[3], nt = getMinMaxs([Q, K, rt, tt]), at = [nt.minX, nt.minY];
      q.pos1 = minus(Q, at), q.pos2 = minus(K, at), q.pos3 = minus(rt, at), q.pos4 = minus(tt, at), q.left = U - q.left + at[0], q.top = z - q.top + at[1], q.origin = minus(plus(Z, q.origin), at), q.beforeOrigin = minus(plus(Z, q.beforeOrigin), at), q.originalBeforeOrigin = plus(Z, q.originalBeforeOrigin);
      var lt = q.targetClientRect, ut = $[0] * $[1] > 0 ? 1 : -1;
      lt.top += q.top - M.top, lt.left += q.left - M.left, L.style.transform = "translate(".concat(-at[0], "px, ").concat(-at[1], "px) ").concat(W), this.updateState(__assign$2(__assign$2({}, q), {
        direction: ut,
        beforeDirection: ut
      }), N);
    }
  }, e.getRect = function() {
    return __assign$2(__assign$2({}, n.prototype.getRect.call(this)), {
      children: this.moveables.map(function(o) {
        return o.getRect();
      })
    });
  }, e.triggerEvent = function(o, R, N) {
    if (N || o.indexOf("Group") > -1)
      return n.prototype.triggerEvent.call(this, o, R);
    this._emitter.trigger(o, R);
  }, e.updateAbles = function() {
    n.prototype.updateAbles.call(this, __spreadArray(__spreadArray([], this.props.ables, !0), [Groupable], !1), "Group");
  }, e._updateTargets = function() {
    n.prototype._updateTargets.call(this), this._prevTarget = this.props.dragTarget || this.areaElement;
  }, e._updateEvents = function() {
    var o = this.state, R = this.props, N = this._prevTarget, M = R.dragTarget || this.areaElement;
    N !== M && (unset(this, "targetGesto"), unset(this, "controlGesto"), o.target = null), o.target || (o.target = this.areaElement, this.controlBox.getElement().style.display = "block"), o.target && (this.targetGesto || (this.targetGesto = getTargetAbleGesto(this, M, "Group")), this.controlGesto || (this.controlGesto = getAbleGesto(this, this.controlBox.getElement(), "controlAbles", "GroupControl")));
    var D = !equals(o.container, R.container);
    D && (o.container = R.container);
    var L = this.differ.update(R.targets), B = L.added, $ = L.changed, k = L.removed, U = B.length || k.length;
    (D || U || $.length) && this.updateRect(), this._isPropTargetChanged = !!U;
  }, e._updateObserver = function() {
  }, t.defaultProps = __assign$2(__assign$2({}, MoveableManager$1.defaultProps), {
    transformOrigin: ["50%", "50%"],
    groupable: !0,
    dragArea: !0,
    keepRatio: !0,
    targets: [],
    defaultGroupRotate: 0,
    defaultGroupOrigin: "50% 50%"
  }), t;
}(MoveableManager$1), MoveableIndividualGroup = /* @__PURE__ */ function(n) {
  __extends$1(t, n);
  function t() {
    var o = n !== null && n.apply(this, arguments) || this;
    return o.moveables = [], o;
  }
  var e = t.prototype;
  return e.render = function() {
    var o = this, R = this.props, N = R.cspNonce, M = R.cssStyled, D = R.targets;
    return createElement(M, {
      cspNonce: N,
      ref: ref(this, "controlBox"),
      className: prefix("control-box")
    }, D.map(function(L, B) {
      return createElement(MoveableManager$1, __assign$2({
        key: "moveable" + B,
        ref: refs(o, "moveables", B)
      }, o.props, {
        target: L,
        wrapperMoveable: o
      }));
    }));
  }, e.componentDidUpdate = function() {
  }, e.updateRect = function(o, R, N) {
    N === void 0 && (N = !0), this.moveables.forEach(function(M) {
      M.updateRect(o, R, N);
    });
  }, e.getRect = function() {
    return __assign$2(__assign$2({}, n.prototype.getRect.call(this)), {
      children: this.moveables.map(function(o) {
        return o.getRect();
      })
    });
  }, e.request = function() {
    return {
      request: function() {
        return this;
      },
      requestEnd: function() {
        return this;
      }
    };
  }, e.dragStart = function() {
    return this;
  }, e.hitTest = function() {
    return 0;
  }, e.isInside = function() {
    return !1;
  }, e.isDragging = function() {
    return !1;
  }, e.updateRenderPoses = function() {
  }, e.checkUpdate = function() {
  }, e.triggerEvent = function() {
  }, e.updateAbles = function() {
  }, e._updateEvents = function() {
  }, e._updateObserver = function() {
  }, t;
}(MoveableManager$1), InitialMoveable = /* @__PURE__ */ function(n) {
  __extends$1(t, n);
  function t() {
    var o = n !== null && n.apply(this, arguments) || this;
    return o.refTargets = [], o.selectorMap = {}, o._differ = new ChildrenDiffer$1(), o._elementTargets = [], o._onChangetarget = null, o;
  }
  var e = t.prototype;
  return t.makeStyled = function() {
    var o = {}, R = this.getTotalAbles();
    R.forEach(function(M) {
      var D = M.css;
      !D || D.forEach(function(L) {
        o[L] = !0;
      });
    });
    var N = getKeys(o).join(`
`);
    this.defaultStyled = styled("div", prefixCSS(PREFIX, MOVEABLE_CSS + N));
  }, t.getTotalAbles = function() {
    return __spreadArray([Default, Groupable, IndividualGroupable, DragArea], this.defaultAbles, !0);
  }, e.render = function() {
    var o = this.constructor;
    o.defaultStyled || o.makeStyled();
    var R = this.props, N = R.ables, M = R.props, D = __rest(R, ["ables", "props"]), L = this._updateRefs(!0), B = getElementTargets(L, this.selectorMap), $ = B.length > 1, k = o.getTotalAbles(), U = __spreadArray(__spreadArray([], k, !0), N || [], !0), z = __assign$2(__assign$2(__assign$2({}, D), M || {}), {
      ables: U,
      cssStyled: o.defaultStyled,
      customStyledMap: o.customStyledMap
    });
    return this._elementTargets = B, $ ? D.individualGroupable ? createElement(MoveableIndividualGroup, __assign$2({
      key: "individual-group",
      ref: ref(this, "moveable")
    }, z, {
      target: null,
      targets: B
    })) : createElement(MoveableGroup, __assign$2({
      key: "group",
      ref: ref(this, "moveable")
    }, z, {
      target: null,
      targets: B
    })) : createElement(MoveableManager$1, __assign$2({
      key: "single",
      ref: ref(this, "moveable")
    }, z, {
      target: B[0]
    }));
  }, e.componentDidMount = function() {
    this._updateRefs();
  }, e.componentDidUpdate = function() {
    var o = this._differ.update(this._elementTargets), R = o.added, N = o.removed, M = R.length || N.length;
    M && this._onChangetarget && this._onChangetarget(), this._updateRefs();
  }, e.componentWillUnmount = function() {
    this.selectorMap = {}, this.refTargets = [];
  }, e.waitToChangeTarget = function() {
    var o = this, R;
    return this._onChangetarget = function() {
      o._onChangetarget = null, R();
    }, new Promise(function(N) {
      R = N;
    });
  }, e.getManager = function() {
    return this.moveable;
  }, e._updateRefs = function(o) {
    var R = this.refTargets, N = getRefTargets(this.props.target || this.props.targets), M = typeof document < "u", D = R.length !== N.length || R.some(function($, k) {
      var U = N[k];
      return !$ && !U ? !1 : $ !== U;
    }), L = this.selectorMap, B = {};
    return this.refTargets.forEach(function($) {
      if (isString$1($)) {
        var k = L[$];
        k ? B[$] = L[$] : M && (D = !0, B[$] = [].slice.call(document.querySelectorAll($)));
      }
    }), this.refTargets = N, this.selectorMap = B, !o && D && this.forceUpdate(), N;
  }, t.defaultAbles = [], t.customStyledMap = {}, t.defaultStyled = null, __decorate$1([withMethods(MOVEABLE_METHODS)], t.prototype, "moveable", void 0), t;
}(PureComponent), Moveable$1 = /* @__PURE__ */ function(n) {
  __extends$1(t, n);
  function t() {
    return n !== null && n.apply(this, arguments) || this;
  }
  return t.defaultAbles = MOVEABLE_ABLES, t;
}(InitialMoveable), Moveable$2 = Moveable$1;
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var extendStatics = function(n, t) {
  return extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(e, o) {
    e.__proto__ = o;
  } || function(e, o) {
    for (var R in o)
      o.hasOwnProperty(R) && (e[R] = o[R]);
  }, extendStatics(n, t);
};
function __extends(n, t) {
  extendStatics(n, t);
  function e() {
    this.constructor = n;
  }
  n.prototype = t === null ? Object.create(t) : (e.prototype = t.prototype, new e());
}
var __assign$1 = function() {
  return __assign$1 = Object.assign || function(t) {
    for (var e, o = 1, R = arguments.length; o < R; o++) {
      e = arguments[o];
      for (var N in e)
        Object.prototype.hasOwnProperty.call(e, N) && (t[N] = e[N]);
    }
    return t;
  }, __assign$1.apply(this, arguments);
};
function __decorate(n, t, e, o) {
  var R = arguments.length, N = R < 3 ? t : o === null ? o = Object.getOwnPropertyDescriptor(t, e) : o, M;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    N = Reflect.decorate(n, t, e, o);
  else
    for (var D = n.length - 1; D >= 0; D--)
      (M = n[D]) && (N = (R < 3 ? M(N) : R > 3 ? M(t, e, N) : M(t, e)) || N);
  return R > 3 && N && Object.defineProperty(t, e, N), N;
}
var InnerMoveable = /* @__PURE__ */ function(n) {
  __extends(t, n);
  function t(o) {
    var R = n.call(this, o) || this;
    return R.state = {}, R.state = R.props, R;
  }
  var e = t.prototype;
  return e.render = function() {
    return createPortal(createElement(Moveable$2, __assign$1({
      ref: ref(this, "moveable")
    }, this.state)), this.state.parentElement);
  }, t;
}(Component), PROPERTIES = MOVEABLE_PROPS, METHODS = MOVEABLE_METHODS, EVENTS = MOVEABLE_EVENTS;
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var __assign = function() {
  return __assign = Object.assign || function(t) {
    for (var e, o = 1, R = arguments.length; o < R; o++) {
      e = arguments[o];
      for (var N in e)
        Object.prototype.hasOwnProperty.call(e, N) && (t[N] = e[N]);
    }
    return t;
  }, __assign.apply(this, arguments);
};
function __spreadArrays() {
  for (var n = 0, t = 0, e = arguments.length; t < e; t++)
    n += arguments[t].length;
  for (var o = Array(n), R = 0, t = 0; t < e; t++)
    for (var N = arguments[t], M = 0, D = N.length; M < D; M++, R++)
      o[R] = N[M];
  return o;
}
var EventEmitter = /* @__PURE__ */ function() {
  function n() {
    this._events = {};
  }
  var t = n.prototype;
  return t.on = function(e, o) {
    if (isObject$2(e))
      for (var R in e)
        this.on(R, e[R]);
    else
      this._addEvent(e, o, {});
    return this;
  }, t.off = function(e, o) {
    if (!e)
      this._events = {};
    else if (isObject$2(e))
      for (var R in e)
        this.off(R);
    else if (!o)
      this._events[e] = [];
    else {
      var N = this._events[e];
      if (N) {
        var M = findIndex(N, function(D) {
          return D.listener === o;
        });
        M > -1 && N.splice(M, 1);
      }
    }
    return this;
  }, t.once = function(e, o) {
    var R = this;
    return o && this._addEvent(e, o, {
      once: !0
    }), new Promise(function(N) {
      R._addEvent(e, N, {
        once: !0
      });
    });
  }, t.emit = function(e, o) {
    var R = this;
    o === void 0 && (o = {});
    var N = this._events[e];
    if (!e || !N)
      return !0;
    var M = !1;
    return o.eventType = e, o.stop = function() {
      M = !0;
    }, o.currentTarget = this, __spreadArrays(N).forEach(function(D) {
      D.listener(o), D.once && R.off(e, D.listener);
    }), !M;
  }, t.trigger = function(e, o) {
    return o === void 0 && (o = {}), this.emit(e, o);
  }, t._addEvent = function(e, o, R) {
    var N = this._events;
    N[e] = N[e] || [];
    var M = N[e];
    M.push(__assign({
      listener: o
    }, R));
  }, n;
}(), EventEmitter$1 = EventEmitter, MoveableManager = /* @__PURE__ */ function(n) {
  __extends(t, n);
  function t(o, R) {
    R === void 0 && (R = {});
    var N = n.call(this) || this;
    N.tempElement = document.createElement("div");
    var M = __assign$1({}, R), D = {};
    EVENTS.forEach(function(B) {
      D[camelize("on ".concat(B))] = function($) {
        return N.trigger(B, $);
      };
    }), render(createElement(InnerMoveable, __assign$1({
      ref: ref(N, "innerMoveable"),
      parentElement: o
    }, M, D)), N.tempElement);
    var L = M.target;
    return isArray(L) && L.length > 1 && N.updateRect(), N;
  }
  var e = t.prototype;
  return e.setState = function(o, R) {
    this.innerMoveable.setState(o, R);
  }, e.forceUpdate = function(o) {
    this.innerMoveable.forceUpdate(o);
  }, e.dragStart = function(o) {
    var R = this.innerMoveable;
    R.$_timer && this.forceUpdate(), this.getMoveable().dragStart(o);
  }, e.destroy = function() {
    render(null, this.tempElement), this.off(), this.tempElement = null, this.innerMoveable = null;
  }, e.getMoveable = function() {
    return this.innerMoveable.moveable;
  }, t = __decorate([Properties(METHODS, function(o, R) {
    o[R] || (o[R] = function() {
      for (var N = [], M = 0; M < arguments.length; M++)
        N[M] = arguments[M];
      var D = this.getMoveable();
      if (!(!D || !D[R]))
        return D[R].apply(D, N);
    });
  }), Properties(PROPERTIES, function(o, R) {
    Object.defineProperty(o, R, {
      get: function() {
        return this.getMoveable().props[R];
      },
      set: function(N) {
        var M;
        this.setState((M = {}, M[R] = N, M));
      },
      enumerable: !0,
      configurable: !0
    });
  })], t), t;
}(EventEmitter$1), Moveable = /* @__PURE__ */ function(n) {
  __extends(t, n);
  function t() {
    return n !== null && n.apply(this, arguments) || this;
  }
  return t;
}(MoveableManager), __accessCheck$2 = (n, t, e) => {
  if (!t.has(n))
    throw TypeError("Cannot " + e);
}, __privateGet$2 = (n, t, e) => (__accessCheck$2(n, t, "read from private field"), e ? e.call(n) : t.get(n)), __privateAdd$2 = (n, t, e) => {
  if (t.has(n))
    throw TypeError("Cannot add the same private member more than once");
  t instanceof WeakSet ? t.add(n) : t.set(n, e);
}, __privateSet$2 = (n, t, e, o) => (__accessCheck$2(n, t, "write to private field"), o ? o.call(n, e) : t.set(n, e), e), __privateWrapper = (n, t, e, o) => ({
  set _(R) {
    __privateSet$2(n, t, R, e);
  },
  get _() {
    return __privateGet$2(n, t, o);
  }
}), __privateMethod$2 = (n, t, e) => (__accessCheck$2(n, t, "access private method"), e), _divDesignRoot, _scrItr, _alzTagArg, _cfg$1, _ID_DESIGNMODE, _cntDesignCast, _hId2dc, _aDC, _resizeDiv, resizeDiv_fn;
const _DesignCast = class {
  constructor(n, t = !1) {
    this.bg_col = n, this.isLay = t, __privateAdd$2(this, _resizeDiv), this.hArg = {}, this.id_tag = "", this.hDesignArg = {
      rotation: 0,
      pivot_x: 0,
      pivot_y: 0,
      left: 0,
      center: 0,
      right: 0,
      s_right: 0,
      top: 0,
      middle: 0,
      bottom: 0,
      s_bottom: 0,
      width: 0,
      height: 0
    }, this.fncLay = () => {
    }, this.mov = void 0, this.div = void 0, this.lx = 0, this.ly = 0, this.rect = Rectangle.EMPTY, this.pivot = new Point(0, 0), this.scale = new Point(1, 1), this.rotation = 0, this.oldFn = () => "", this.rotatable = !0;
  }
  static init(n, t, e, o, R, N, M) {
    n.view.insertAdjacentHTML("beforebegin", `<div id="${__privateGet$2(_DesignCast, _ID_DESIGNMODE)}" style="width: ${CmnLib.stageW * _DesignCast.sys.cvsScale}px; height: ${CmnLib.stageH * t.cvsScale}px; background: rgba(0,0,0,0); position: absolute; touch-action: none; user-select: none; display: none;"></div>`), __privateSet$2(_DesignCast, _divDesignRoot, document.getElementById(__privateGet$2(_DesignCast, _ID_DESIGNMODE))), _DesignCast.divHint.classList.add("sn_design_hint"), n.view.parentElement.appendChild(_DesignCast.divHint), _DesignCast.sys = t, __privateSet$2(_DesignCast, _scrItr, e), _DesignCast.prpPrs = o, __privateSet$2(_DesignCast, _alzTagArg, R), __privateSet$2(_DesignCast, _cfg$1, N), _DesignCast.hPages = M, addStyle(`
.sn_design_cast {
	position: absolute; touch-action: none; user-select: none;
	opacity: 0.6; border-radius: 8px;
}

.sn_design_cast.drag_border {
	line-height: 1.8;
	border: dashed 5px #333;
}

.sn_design_hint {
	position: absolute;
	left: 0;
	top: 0;
	padding: 5px;
	border-radius: 5px;
	background: #333;
	z-index: 10;
	color: #fff;
	font-weight: bold;
	font-size: 12px;
	display: none;
}
`);
  }
  static setHint(n, t, e, o) {
    _DesignCast.divHint.innerHTML = n;
    const R = window.getComputedStyle(_DesignCast.divHint), N = parseFloat(R.width), M = parseFloat(R.height);
    _DesignCast.divHint.style.cssText = `display: block; left: ${Math.max(10, o.lx + t - N)}px;
		top: ${Math.max(10, o.ly + e - M - 10)}px;`;
  }
  static cvsResizeDesign() {
    const n = __privateGet$2(_DesignCast, _divDesignRoot).style;
    n.width = `${CmnLib.stageW * _DesignCast.sys.cvsScale}px`, n.height = `${CmnLib.stageH * _DesignCast.sys.cvsScale}px`;
  }
  destroy() {
    var n;
    this.div = void 0, (n = this.mov) == null || n.destroy(), this.mov = void 0;
  }
  gethArg() {
    return this.hArg;
  }
  sethArg(n) {
    var e, o;
    if (!this.includeDesignArg(n))
      return;
    this.id_tag || (this.id_tag = (e = n[":id_tag"]) != null ? e : ""), this.hArg = n;
    const t = (o = n[":id_dc"]) != null ? o : this.id_tag;
    __privateGet$2(_DesignCast, _hId2dc)[t] = this;
  }
  includeDesignArg(n) {
    for (const t in n)
      if (t in this.hDesignArg)
        return !0;
    return !1;
  }
  getRect() {
    return Rectangle.EMPTY;
  }
  cnvPosArg(n, t) {
    return {};
  }
  cnvSizeArg(n, t) {
    return {};
  }
  setPos(n, t) {
  }
  setSize(n, t) {
  }
  setOther(n) {
  }
  adopt(n) {
    this.child = n, n.parent = this;
  }
  static enterMode() {
    _DesignCast.leaveMode(), __privateGet$2(_DesignCast, _divDesignRoot).style.display = "inline", __privateSet$2(_DesignCast, _cntDesignCast, 0), __privateSet$2(_DesignCast, _hId2dc, {});
  }
  static allHide() {
    __privateGet$2(_DesignCast, _aDC).forEach((n) => n.visible = !1);
  }
  set visible(n) {
    !this.div || !this.mov || (this.div.style.display = n ? "inline" : "none", this.mov.updateTarget());
  }
  static leaveMode() {
    __privateGet$2(_DesignCast, _divDesignRoot).textContent = "", __privateGet$2(_DesignCast, _divDesignRoot).style.display = "none", __privateGet$2(_DesignCast, _aDC).forEach((n) => n.destroy()), __privateSet$2(_DesignCast, _aDC, []);
  }
  cvsResize() {
    var n;
    __privateMethod$2(this, _resizeDiv, resizeDiv_fn).call(this), (n = this.mov) == null || n.updateTarget();
  }
  onDragStart() {
  }
  make() {
    var D, L;
    const n = (D = this.hArg[":id_dc"]) != null ? D : this.id_tag;
    __privateGet$2(_DesignCast, _hId2dc)[n] = this;
    const t = this.div = document.createElement("div");
    t.id = __privateGet$2(_DesignCast, _ID_DESIGNMODE) + "_" + ++__privateWrapper(_DesignCast, _cntDesignCast)._, t.classList.add("sn_design_cast"), t.dataset.id_dc = n, t.style.backgroundColor = `${this.bg_col}`, t.style.display = "none", this.rect = this.getRect(), __privateMethod$2(this, _resizeDiv, resizeDiv_fn).call(this), (this.parent && (L = document.querySelector(
      `[data-id_dc="${this.parent.id_tag}"]`
    )) != null ? L : __privateGet$2(_DesignCast, _divDesignRoot)).appendChild(t);
    const e = {
      aPos: [0, 0],
      roDeg: 0,
      trOrg: "",
      origin: [0, 0]
    }, o = () => {
      e.aPos = [NaN, NaN], e.roDeg = this.rotation;
      const B = this.pivot.x * _DesignCast.sys.cvsScale, $ = this.pivot.y * _DesignCast.sys.cvsScale;
      e.trOrg = `${B}px ${$}px`, e.origin = [B, $], Object.assign(this.mov, {
        verticalGuidelines: [],
        horizontalGuidelines: []
      });
    }, R = (B) => {
      _DesignCast.sys.send2Dbg("_changeCast", {
        ...B,
        ":id_tag": this.id_tag
      }), _DesignCast.divHint.style.display = "none";
    }, N = () => {
      const [B, $] = e.aPos;
      if (isNaN(B)) {
        _DesignCast.divHint.style.display = "none";
        return;
      }
      const k = int(this.rect.x += B / _DesignCast.sys.cvsScale + this.pivot.x), U = int(this.rect.y += $ / _DesignCast.sys.cvsScale + this.pivot.y);
      this.setPos(k, U);
      const z = uint(this.rect.width), X = uint(this.rect.height);
      this.setSize(z, X), R({
        ...this.cnvPosArg(k, U),
        ...this.cnvSizeArg(z, X)
      });
    };
    let M;
    this.mov = new Moveable(document.body, {
      target: t,
      draggable: !0,
      resizable: !0,
      rotatable: this.rotatable,
      originDraggable: this.rotatable,
      snappable: !0
    }).on("dragStart", (B) => {
      var k;
      o(), this.onDragStart();
      const $ = (k = this.child) == null ? void 0 : k.mov;
      $ && (M = $.target, $.isInside(B.clientX, B.clientY) && ($.target = void 0));
    }).on("drag", (B) => {
      e.aPos = B.beforeTranslate, this.procDragHint(B, B.left, B.top);
    }).on("dragEnd", () => {
      var B, $;
      N(), (B = this.child) != null && B.mov && (this.child.mov.target = M), ($ = this.parent) != null && $.mov && (this.parent.mov.target = this.parent.div);
    }).on("resizeStart", o).on("resize", (B) => {
      t.style.width = `${B.width}px`, t.style.height = `${B.height}px`, e.aPos = B.drag.beforeTranslate, this.rect.width = B.width / _DesignCast.sys.cvsScale, this.rect.height = B.height / _DesignCast.sys.cvsScale, this.procResizeHint(B, B.drag.left, B.drag.top);
    }).on("resizeEnd", N).on("rotateStart", (B) => {
      o(), B.set(e.roDeg);
    }).on("rotate", (B) => {
      e.roDeg = B.beforeRotate, _DesignCast.setHint(int(e.roDeg) + "\u5EA6", B.drag.left, B.drag.top, this);
    }).on("rotateEnd", () => {
      this.rotation = e.roDeg, this.setOther({}), R({ rotation: int(e.roDeg) });
    }).on("dragOriginStart", () => o).on("dragOrigin", (B) => {
      e.trOrg = B.transformOrigin, e.origin = B.origin;
    }).on("dragOriginEnd", () => {
      const [B, $] = e.origin;
      e.trOrg = `${B}px ${$}px`;
      const k = this.pivot.x = B / _DesignCast.sys.cvsScale, U = this.pivot.y = $ / _DesignCast.sys.cvsScale;
      this.setOther({});
      const z = int(this.rect.x + k), X = int(this.rect.y + U);
      this.setPos(z, X), R({
        ...this.cnvPosArg(z, X),
        pivot_x: int(k),
        pivot_y: int(U)
      });
    }).on("render", () => {
      const { aPos: B, roDeg: $, trOrg: k } = e;
      t.style.transformOrigin = k, t.style.transform = `translate(${B[0]}px, ${B[1]}px) rotate(${$}deg)`;
    }), __privateGet$2(_DesignCast, _aDC).push(this), t.addEventListener("dragenter", () => t.classList.add("drag_border")), t.addEventListener("dragover", (B) => {
      B.stopPropagation(), B.preventDefault(), B.dataTransfer && (B.dataTransfer.dropEffect = "copy");
    }), t.addEventListener("dragleave", () => t.classList.remove("drag_border")), t.addEventListener("drop", (B) => {
      B.stopPropagation(), B.preventDefault(), t.classList.remove("drag_border");
      const $ = B.dataTransfer;
      if (!$ || $.files.length === 0)
        return;
      const k = $.files[0], U = {
        ":id_tag": this.id_tag,
        fn: getFn(k.name),
        ext: getExt(k.name),
        url: "",
        buf: new ArrayBuffer(0),
        old_fn: this.oldFn(),
        old_url: __privateGet$2(_DesignCast, _cfg$1).searchPath(this.oldFn(), Config.EXT_SPRITE)
      };
      k.arrayBuffer().then((z) => {
        U.buf = z;
        try {
          U.url = __privateGet$2(_DesignCast, _scrItr).cnvPath4Dbg(
            __privateGet$2(_DesignCast, _cfg$1).searchPath(k.name, Config.EXT_SPRITE)
          );
        } catch {
        }
        _DesignCast.sys.send2Dbg("_dropFile", U);
      }).catch((z) => console.error("drop2dc %o", z));
    }), t.addEventListener("dblclick", (B) => {
      B.preventDefault(), _DesignCast.sys.send2Dbg("_focusScript", this.hArg);
    });
  }
  procDragHint(n, t, e) {
    const [o, R] = n.beforeTranslate;
    _DesignCast.setHint(
      `(${int(this.rect.x + o / _DesignCast.sys.cvsScale)}, ${int(this.rect.y + R / _DesignCast.sys.cvsScale)})`,
      t,
      e,
      this
    );
  }
  procResizeHint(n, t, e) {
    _DesignCast.setHint(
      `(${int(n.drag.left)}, ${int(n.drag.top)})<br/>${int(this.rect.width)} x ${int(this.rect.height)}`,
      t,
      e,
      this
    );
  }
  static replaceToken(n) {
    var B, $, k, U, z, X, V, W, Y, q, Z;
    const e = n[":id_tag"], o = __privateGet$2(_DesignCast, _hId2dc)[e];
    if (!document.querySelector(`div[data-id_dc='${e}']`) || !o)
      return;
    const N = n[":token"];
    __privateGet$2(_DesignCast, _scrItr).replace(n[":idx_tkn"], N);
    const [M, D] = tagToken2Name_Args(N);
    o.child && (o.child.hArg[":token"] = o.hArg[":token"]), __privateGet$2(_DesignCast, _alzTagArg).go(D);
    const L = __privateGet$2(_DesignCast, _alzTagArg).hPrm;
    if ("pivot_x" in L || "pivot_y" in L) {
      const J = Number(_DesignCast.prpPrs.getValAmpersand((B = L.pivot_x.val) != null ? B : "0")), Q = Number(_DesignCast.prpPrs.getValAmpersand(($ = L.pivot_y.val) != null ? $ : "0"));
      (isNaN(J) || isNaN(Q)) && DebugMng.myTrace(`pivot_x\u304Bpivot_y\u304C\u6570\u5024\u3067\u306F\u3042\u308A\u307E\u305B\u3093
(fn:${n[":path"].slice(13)} ln:${n[":ln"]})
${N}`, "F"), o.pivot.set(J, Q);
    }
    if ("left" in L || "top" in L || "x" in L || "y" in L) {
      const J = int(_DesignCast.prpPrs.getValAmpersand((U = (k = L.left.val) != null ? k : L.x.val) != null ? U : "0")), Q = int(_DesignCast.prpPrs.getValAmpersand((X = (z = L.top.val) != null ? z : L.y.val) != null ? X : "0"));
      (isNaN(J) || isNaN(Q)) && DebugMng.myTrace(`width\u304Bheight\u304C\u6570\u5024\u3067\u306F\u3042\u308A\u307E\u305B\u3093
(fn:${n[":path"].slice(13)} ln:${n[":ln"]})
${N}`, "F"), o.rect.x = J - o.pivot.x, o.rect.y = Q - o.pivot.y, o.setPos(J, Q);
    }
    if ("width" in L || "height" in L) {
      const J = int(_DesignCast.prpPrs.getValAmpersand((V = L.width.val) != null ? V : "0")), Q = int(_DesignCast.prpPrs.getValAmpersand((W = L.height.val) != null ? W : "0"));
      (isNaN(J) || isNaN(Q)) && DebugMng.myTrace(`width\u304Bheight\u304C\u6570\u5024\u3067\u306F\u3042\u308A\u307E\u305B\u3093
(fn:${n[":path"].slice(13)} ln:${n[":ln"]})
${N}`, "F"), o.rect.width = J, o.rect.height = Q, o.setSize(J, Q);
    }
    if ("scale_x" in L || "scale_y" in L) {
      const J = Number(_DesignCast.prpPrs.getValAmpersand((Y = L.scale_x.val) != null ? Y : "0")), Q = Number(_DesignCast.prpPrs.getValAmpersand((q = L.scale_y.val) != null ? q : "0"));
      (isNaN(J) || isNaN(Q)) && DebugMng.myTrace(`scale_x\u304Bscale_y\u304C\u6570\u5024\u3067\u306F\u3042\u308A\u307E\u305B\u3093
(fn:${n[":path"].slice(13)} ln:${n[":ln"]})
${N}`, "F"), o.scale.set(J, Q);
    }
    if ("rotation" in L) {
      const J = Number(_DesignCast.prpPrs.getValAmpersand((Z = L.rotation.val) != null ? Z : "0"));
      isNaN(J) && DebugMng.myTrace(`rotation\u304C\u6570\u5024\u3067\u306F\u3042\u308A\u307E\u305B\u3093
(fn:${n[":path"].slice(13)} ln:${n[":ln"]})
${N}`, "F"), o.rotation = J;
    }
    o.setOther(L), o.cvsResize();
  }
};
let DesignCast = _DesignCast;
_divDesignRoot = /* @__PURE__ */ new WeakMap();
_scrItr = /* @__PURE__ */ new WeakMap();
_alzTagArg = /* @__PURE__ */ new WeakMap();
_cfg$1 = /* @__PURE__ */ new WeakMap();
_ID_DESIGNMODE = /* @__PURE__ */ new WeakMap();
_cntDesignCast = /* @__PURE__ */ new WeakMap();
_hId2dc = /* @__PURE__ */ new WeakMap();
_aDC = /* @__PURE__ */ new WeakMap();
_resizeDiv = /* @__PURE__ */ new WeakSet();
resizeDiv_fn = function() {
  this.fncLay(), this.div && Object.assign(this.div.style, {
    left: `${this.lx + this.rect.x * _DesignCast.sys.cvsScale}px`,
    top: `${this.ly + this.rect.y * _DesignCast.sys.cvsScale}px`,
    width: `${this.rect.width * _DesignCast.sys.cvsScale}px`,
    height: `${this.rect.height * _DesignCast.sys.cvsScale}px`,
    transformOrigin: `${this.pivot.x * _DesignCast.sys.cvsScale}px ${this.pivot.y * _DesignCast.sys.cvsScale}px`,
    transform: `scale(${this.scale.x}, ${this.scale.y}) rotate(${this.rotation}deg)`
  });
};
__privateAdd$2(DesignCast, _divDesignRoot, void 0);
__privateAdd$2(DesignCast, _scrItr, void 0);
__privateAdd$2(DesignCast, _alzTagArg, void 0);
__privateAdd$2(DesignCast, _cfg$1, void 0);
DesignCast.divHint = document.createElement("div");
__privateAdd$2(DesignCast, _ID_DESIGNMODE, "DesignMode");
__privateAdd$2(DesignCast, _cntDesignCast, 0);
__privateAdd$2(DesignCast, _hId2dc, {});
__privateAdd$2(DesignCast, _aDC, []);
var yi;
class GrpLayDesignCast extends DesignCast {
  constructor(e, o) {
    super("#29e", !0);
    it(this, yi, void 0);
    this.spLay = e, this.gl = o, this.oldFn = () => {
      var R;
      return (R = this.hArg.fn) != null ? R : "";
    };
  }
  setSp(e) {
    et(this, yi, e);
  }
  getRect() {
    var e, o, R, N;
    return new Rectangle(this.spLay.x, this.spLay.y, (o = (e = H(this, yi)) == null ? void 0 : e.width) != null ? o : 0, (N = (R = H(this, yi)) == null ? void 0 : R.height) != null ? N : 0);
  }
  cnvPosArg(e, o) {
    return { left: e, top: o };
  }
  cnvSizeArg(e, o) {
    return { width: e, height: o };
  }
  setPos(e, o) {
    this.spLay.x = e, this.spLay.y = o;
  }
  setSize(e, o) {
    H(this, yi).width = e, H(this, yi).height = o;
  }
  setOther(e) {
    var o;
    if ("fn" in e) {
      const R = DesignCast.prpPrs.getValAmpersand((o = e.fn.val) != null ? o : "");
      this.gl.lay({ fn: R });
    }
    this.spLay.pivot.copyFrom(this.pivot), this.spLay.scale.copyFrom(this.scale), this.spLay.angle = this.rotation;
  }
}
yi = new WeakMap();
class TxtLayDesignCast extends DesignCast {
  constructor(t, e) {
    super("#29e", !0), this.spLay = t, this.ts = e, this.hDesignArg = {
      rotation: 0,
      pivot_x: 0,
      pivot_y: 0,
      left: 0,
      center: 0,
      right: 0,
      s_right: 0,
      top: 0,
      middle: 0,
      bottom: 0,
      s_bottom: 0,
      width: 0,
      height: 0,
      pl: 0,
      pr: 0,
      pt: 0,
      pb: 0
    };
  }
  getRect() {
    const t = this.ts.infTL;
    return new Rectangle(this.spLay.x, this.spLay.y, t.$width, t.$height);
  }
  cnvPosArg(t, e) {
    return { left: t, top: e };
  }
  cnvSizeArg(t, e) {
    return { width: t, height: e };
  }
  setPos(t, e) {
    this.spLay.position.set(t, e), this.ts.lay(this.cnvPosArg(t, e));
  }
  setSize(t, e) {
    this.ts.lay(this.cnvSizeArg(t, e));
  }
  setOther(t) {
    var e;
    (e = this.child) == null || e.setOther(t), this.spLay.pivot.copyFrom(this.pivot), this.spLay.scale.copyFrom(this.scale), this.spLay.angle = this.rotation;
  }
}
var Ha, ch;
class TxtLayPadDesignCast extends DesignCast {
  constructor(e) {
    super("#9e2");
    it(this, Ha);
    this.ts = e, this.rotatable = !1;
  }
  getRect() {
    const e = this.ts.infTL;
    return new Rectangle(
      e.pad_left,
      e.pad_top,
      e.$width - e.pad_left - e.pad_right,
      e.$height - e.pad_top - e.pad_bottom
    );
  }
  cnvPosArg(e, o) {
    return { pl: e, pt: o };
  }
  cnvSizeArg(e, o) {
    const R = this.ts.infTL;
    return {
      pr: R.$width - R.pad_left - e,
      pb: R.$height - R.pad_top - o
    };
  }
  setPos(e, o) {
    this.ts.lay(this.cnvPosArg(e, o));
  }
  setSize(e, o) {
    this.ts.lay({ ...this.cnvSizeArg(e, o), ":redraw": !0 });
  }
  setOther(e) {
    var R, N, M, D, L, B, $, k;
    const o = this.ts.infTL;
    if (("pl" in e || "pt" in e) && (this.setPos(
      this.rect.x = parseFloat(DesignCast.prpPrs.getValAmpersand(
        (N = (R = e.pl) == null ? void 0 : R.val) != null ? N : `${o.pad_left}`
      )),
      this.rect.y = parseFloat(DesignCast.prpPrs.getValAmpersand(
        (D = (M = e.pt) == null ? void 0 : M.val) != null ? D : `${o.pad_top}`
      ))
    ), this.cvsResize()), "pr" in e || "pb" in e) {
      this.ts.lay({
        pr: parseFloat(DesignCast.prpPrs.getValAmpersand(
          (B = (L = e.pr) == null ? void 0 : L.val) != null ? B : `${o.pad_right}`
        )),
        pb: parseFloat(DesignCast.prpPrs.getValAmpersand(
          (k = ($ = e.pb) == null ? void 0 : $.val) != null ? k : `${o.pad_bottom}`
        ))
      });
      const U = this.getRect();
      this.setSize(
        this.rect.width = U.width,
        this.rect.height = U.height
      ), this.cvsResize();
    }
  }
  procDragHint(e, o, R) {
    const [N, M] = e.beforeTranslate;
    st(this, Ha, ch).call(this, o, R, N, M);
  }
  procResizeHint(e, o, R) {
    const [N, M] = e.drag.beforeTranslate;
    st(this, Ha, ch).call(this, o, R, N, M);
  }
}
Ha = new WeakSet(), ch = function(e, o, R, N) {
  const M = this.rect.x, D = this.rect.y, L = this.rect.width, B = this.rect.height, $ = this.ts.infTL, k = int(M + R / DesignCast.sys.cvsScale), U = int(D + N / DesignCast.sys.cvsScale), z = int($.$width - k - L), X = int($.$height - U - B), V = (W) => "&nbsp;".repeat(W);
  DesignCast.setHint(
    V(5 + 5 + 1) + `\u4E0A\u5E45=${U}<br/>
			\u5DE6\u5E45=${k + V(1 + 3 + 5 + 1)}\u53F3\u5E45=${z}<br/>` + V(5) + `\u5185\u5074 ${int(L)} x ${int(B)}<br/>` + V(5 + 5) + `\u4E0B\u5E45=${X}`,
    e,
    o,
    this
  );
};
class BtnDesignCast extends DesignCast {
  constructor(t, e) {
    super("#e92"), this.btn = t, this.hArg = e, this.pivot.x = argChk_Num(e, "pivot_x", this.pivot.x), this.pivot.y = argChk_Num(e, "pivot_y", this.pivot.y), this.scale.x = argChk_Num(e, "scale_x", this.scale.x), this.scale.y = argChk_Num(e, "scale_y", this.scale.y), this.rotation = argChk_Num(e, "rotation", this.rotation), this.sethArg(e);
  }
  sethArg(t) {
    var o;
    super.sethArg(t);
    const e = (o = this.hArg.layer) != null ? o : "";
    this.fncLay = !this.parent && !this.child && e ? () => {
      const R = DesignCast.hPages[e].fore;
      this.lx = R.x * DesignCast.sys.cvsScale, this.ly = R.y * DesignCast.sys.cvsScale;
    } : () => {
    };
  }
  cnvPosArg(t, e) {
    return { left: t, top: e };
  }
  cnvSizeArg(t, e) {
    return { width: t, height: e };
  }
  setPos(t, e) {
    this.btn.x = t, this.btn.y = e;
  }
  setOther(t) {
    this.btn.pivot.copyFrom(this.pivot), this.btn.scale.copyFrom(this.scale), this.btn.angle = this.rotation;
  }
  onDragStart() {
    const t = this.btn.parent.children.filter((e) => e !== this.btn);
    Object.assign(this.mov, {
      verticalGuidelines: t.map((e) => this.lx + e.x * DesignCast.sys.cvsScale),
      horizontalGuidelines: t.map((e) => this.ly + e.y * DesignCast.sys.cvsScale)
    });
  }
}
class TxtBtnDesignCast extends BtnDesignCast {
  constructor(t, e, o) {
    super(t, e), this.txt = o, this.oldFn = () => {
      var R;
      return (R = this.hArg.b_pic) != null ? R : "";
    }, argChk_Boolean(e, "design", !0) || (this.setPos = () => {
    }, this.setSize = () => {
    });
  }
  getRect() {
    return new Rectangle(this.btn.x, this.btn.y, this.txt.width, this.txt.height);
  }
  setSize(t, e) {
    this.txt.width = t, this.txt.height = e;
  }
  setOther(t) {
    var e;
    if (super.setOther(t), "b_pic" in t) {
      const o = DesignCast.prpPrs.getValAmpersand((e = t.b_pic.val) != null ? e : "");
      this.btn.update_b_pic(o, this.txt);
    }
  }
}
var Yr;
class PicBtnDesignCast extends BtnDesignCast {
  constructor(e, o) {
    super(e, o);
    it(this, Yr, void 0);
    this.oldFn = () => {
      var R;
      return (R = this.hArg.pic) != null ? R : "";
    };
  }
  setSp(e) {
    et(this, Yr, e);
  }
  getRect() {
    return new Rectangle(this.btn.x, this.btn.y, H(this, Yr).width, H(this, Yr).height);
  }
  setSize(e, o) {
    H(this, Yr).width = e, H(this, Yr).height = o;
  }
  setOther(e) {
    var o;
    if (super.setOther(e), "pic" in e) {
      const R = DesignCast.prpPrs.getValAmpersand((o = e.pic.val) != null ? o : "");
      this.btn.update_pic(R, H(this, Yr));
    }
  }
}
Yr = new WeakMap();
var __accessCheck$1 = (n, t, e) => {
  if (!t.has(n))
    throw TypeError("Cannot " + e);
}, __privateGet$1 = (n, t, e) => (__accessCheck$1(n, t, "read from private field"), e ? e.call(n) : t.get(n)), __privateAdd$1 = (n, t, e) => {
  if (t.has(n))
    throw TypeError("Cannot add the same private member more than once");
  t instanceof WeakSet ? t.add(n) : t.set(n, e);
}, __privateSet$1 = (n, t, e, o) => (__accessCheck$1(n, t, "write to private field"), o ? o.call(n, e) : t.set(n, e), e), __privateMethod$1 = (n, t, e) => (__accessCheck$1(n, t, "access private method"), e), _elc, _hFace, _main, _cfg, _appPixi, _sys, _glbVol, _movVol, _evtMng, _idc$1, _csvFn, _sBkFn, _sBkFace, _width, _height, _dec2cache, _sortAFrameName, sortAFrameName_fn, _dec2cache4Cripto, dec2cache4Cripto_fn, _mkSprite, mkSprite_fn, _rtTsy, _spTsy, _fncRender, _hAEncImg, _hEncImgOUrl;
const _GrpLayer = class extends Layer {
  constructor() {
    super(), __privateAdd$1(this, _idc$1, new GrpLayDesignCast(this.spLay, this)), __privateAdd$1(this, _csvFn, ""), __privateAdd$1(this, _sBkFn, ""), __privateAdd$1(this, _sBkFace, ""), this.lay = (n) => this.laySub(n, (t) => {
      t && __privateGet$1(_GrpLayer, _main).resume();
    }), __privateAdd$1(this, _width, 0), __privateAdd$1(this, _height, 0), __privateAdd$1(this, _rtTsy, void 0), __privateAdd$1(this, _spTsy, void 0), __privateAdd$1(this, _fncRender, () => {
    }), this.record = () => ({
      ...super.record(),
      sBkFn: __privateGet$1(this, _sBkFn),
      sBkFace: __privateGet$1(this, _sBkFace),
      idc_hArg: __privateGet$1(this, _idc$1).gethArg()
    }), this.dump = () => super.dump() + `, "pic":"${__privateGet$1(this, _csvFn)}"`, CmnLib.isDbg && (this.setSp = (n) => __privateGet$1(this, _idc$1).setSp(n), this.cvsResize = () => {
      super.cvsResize(), __privateGet$1(this, _idc$1).cvsResize();
    });
  }
  static init(n, t, e, o, R) {
    __privateSet$1(_GrpLayer, _main, n), __privateSet$1(_GrpLayer, _cfg, t), __privateSet$1(_GrpLayer, _appPixi, e), __privateSet$1(_GrpLayer, _sys, o);
    const N = () => {
      const M = __privateGet$1(_GrpLayer, _glbVol) * __privateGet$1(_GrpLayer, _movVol);
      for (const D in _GrpLayer.hFn2VElm)
        _GrpLayer.hFn2VElm[D].volume = M;
    };
    R.setNoticeChgVolume(
      (M) => {
        __privateSet$1(_GrpLayer, _glbVol, M), N();
      },
      (M) => {
        __privateSet$1(_GrpLayer, _movVol, M), N();
      }
    ), __privateGet$1(_GrpLayer, _sys).crypto && __privateSet$1(_GrpLayer, _dec2cache, __privateMethod$1(_GrpLayer, _dec2cache4Cripto, dec2cache4Cripto_fn));
  }
  static setEvtMng(n) {
    __privateSet$1(_GrpLayer, _evtMng, n);
  }
  static destroy() {
    __privateGet$1(_GrpLayer, _elc).clear(), __privateSet$1(_GrpLayer, _hFace, {}), _GrpLayer.hFn2ResAniSpr = {}, _GrpLayer.hFn2VElm = {};
  }
  setSp(n) {
  }
  laySub(n, t) {
    const { fn: e, face: o = "" } = n;
    if (__privateGet$1(this, _idc$1).sethArg(n), !e)
      return super.lay(n), this.spLay.children.length > 0 && this.setPos(n), __privateSet$1(this, _sBkFn, ""), __privateSet$1(this, _csvFn, __privateSet$1(this, _sBkFace, o)), t(!1), !1;
    const R = "fn" in n, N = "face" in n;
    return this.clearLay({ filter: "true" }), R && __privateSet$1(this, _sBkFn, e), N && __privateSet$1(this, _sBkFace, o), super.lay(n), n.dx = 0, n.dy = 0, _GrpLayer.csv2Sprites(
      __privateSet$1(this, _csvFn, e + (o ? "," + o : "")),
      this.spLay,
      (M) => {
        ("width" in n || "height" in n) && (M.width = argChk_Num(n, "width", 0), M.height = argChk_Num(n, "height", 0)), __privateSet$1(this, _width, M.width), __privateSet$1(this, _height, M.height), Layer.setXY(M, n, this.spLay, !0), this.setSp(M);
      },
      (M) => {
        Layer.setBlendmode(this.spLay, n), t(M);
      }
    );
  }
  get width() {
    return __privateGet$1(this, _width);
  }
  get height() {
    return __privateGet$1(this, _height);
  }
  static csv2Sprites(n, t, e, o = () => {
  }) {
    let R = !1;
    if (n.slice(0, 5) === "data:") {
      const L = () => {
        const B = Sprite.from(n);
        t == null || t.addChild(B), e(B), o(R);
      };
      return n in TextureCache ? L() : (R = !0, new Loader().add(n, n).load(L)), R;
    }
    const N = [], M = new Loader();
    n.split(",").forEach((L, B) => {
      if (!L)
        throw "face\u5C5E\u6027\u306B\u7A7A\u8981\u7D20\u304C\u542B\u307E\u308C\u307E\u3059";
      const $ = __privateGet$1(_GrpLayer, _hFace)[L] || {
        fn: L,
        dx: 0,
        dy: 0,
        blendmode: BLEND_MODES$5.NORMAL
      }, k = B === 0 ? e : (X) => {
        X.x = $.dx, X.y = $.dy, X.blendMode = $.blendmode;
      };
      if (N.push({ fn: $.fn, fnc: k }), $.fn in _GrpLayer.hFn2ResAniSpr || $.fn in TextureCache || $.fn in Loader.shared.resources)
        return;
      R = !0;
      const U = __privateGet$1(_GrpLayer, _cfg).searchPath($.fn, Config.EXT_SPRITE), z = __privateGet$1(this, _sys).crypto ? { xhrType: U.slice(-5) === ".json" ? LoaderResource.XHR_RESPONSE_TYPE.TEXT : LoaderResource.XHR_RESPONSE_TYPE.BUFFER } : {};
      M.add({ ...z, name: $.fn, url: U });
    });
    const D = (L) => {
      var B;
      for (const $ of N) {
        const k = __privateMethod$1(B = _GrpLayer, _mkSprite, mkSprite_fn).call(B, $.fn, L);
        k.name = $.fn, t == null || t.addChild(k), $.fnc(k);
      }
      o(R);
    };
    return R ? M.use((L, B) => {
      __privateGet$1(this, _sys).dec(L.extension, L.data).then(($) => {
        var k;
        return __privateGet$1(k = _GrpLayer, _dec2cache).call(k, $, L, () => B == null ? void 0 : B());
      }).catch(($) => __privateGet$1(this, _main).errScript(`Graphic \u30ED\u30FC\u30C9\u5931\u6557\u3067\u3059 fn:${L.name} ${$}`, !1));
    }).load((L, B) => D(B)) : D({}), R;
  }
  static wv(n) {
    const { fn: t } = n;
    if (!t)
      throw "fn\u306F\u5FC5\u9808\u3067\u3059";
    const e = _GrpLayer.hFn2VElm[t];
    if (!e || e.loop)
      return !1;
    if (e.ended)
      return delete _GrpLayer.hFn2VElm[t], !1;
    const o = () => {
      e.removeEventListener("ended", o), delete _GrpLayer.hFn2VElm[t], __privateGet$1(this, _main).resume();
    };
    return e.addEventListener("ended", o, { once: !0, passive: !0 }), __privateGet$1(_GrpLayer, _evtMng).waitEvent(
      () => {
        e.pause(), o();
      },
      argChk_Boolean(n, "canskip", !0),
      argChk_Boolean(n, "global", !1)
    );
  }
  renderStart() {
    __privateSet$1(this, _rtTsy, RenderTexture.create({
      width: CmnLib.stageW,
      height: CmnLib.stageH
    })), __privateSet$1(this, _spTsy, new Sprite(__privateGet$1(this, _rtTsy))), __privateGet$1(this, _spTsy).visible = !1, this.spLay.addChildAt(__privateGet$1(this, _spTsy), 0), __privateGet$1(this, _spTsy).position.set(-this.spLay.x, -this.spLay.y);
    let n = () => {
      const t = this.spLay.alpha;
      this.spLay.alpha = 1, this.spLay.children.forEach((e) => e.visible = !0), __privateGet$1(this, _spTsy).visible = !1, __privateGet$1(_GrpLayer, _appPixi).renderer.render(this.spLay, { renderTexture: __privateGet$1(this, _rtTsy) }), this.spLay.alpha = t, this.spLay.children.forEach((e) => e.visible = !1);
    };
    if (!this.containMovement) {
      let t = n;
      n = () => {
        n = () => {
        }, t();
      };
    }
    __privateSet$1(this, _fncRender, () => {
      n(), __privateGet$1(this, _spTsy).visible = !0;
    }), __privateGet$1(_GrpLayer, _appPixi).ticker.add(__privateGet$1(this, _fncRender));
  }
  renderEnd() {
    __privateGet$1(_GrpLayer, _appPixi).ticker.remove(__privateGet$1(this, _fncRender)), this.spLay.removeChild(__privateGet$1(this, _spTsy)), this.spLay.children.forEach((n) => n.visible = !0), __privateGet$1(this, _spTsy).destroy(!0);
  }
  static loadPic2Img(n, t, e) {
    const o = __privateGet$1(this, _hEncImgOUrl)[n];
    if (o) {
      t.src = o;
      return;
    }
    const R = __privateGet$1(this, _hAEncImg)[n];
    if (R) {
      R.push(t);
      return;
    }
    __privateGet$1(this, _hAEncImg)[n] = [t];
    const N = __privateGet$1(_GrpLayer, _cfg).searchPath(n, Config.EXT_SPRITE), M = new Loader().add({ name: n, url: N, xhrType: LoaderResource.XHR_RESPONSE_TYPE.BUFFER });
    __privateGet$1(_GrpLayer, _sys).crypto && M.use((D, L) => {
      __privateGet$1(_GrpLayer, _sys).dec(D.extension, D.data).then((B) => {
        if (D.extension !== "bin") {
          L == null || L();
          return;
        }
        D.data = B, B instanceof HTMLImageElement && (D.type = LoaderResource.TYPE.IMAGE), L == null || L();
      }).catch((B) => __privateGet$1(_GrpLayer, _main).errScript(`GrpLayer loadPic \u30ED\u30FC\u30C9\u5931\u6557\u3067\u3059 fn:${D.name} ${B}`, !1));
    }), M.load((D, L) => {
      for (const B in L) {
        const $ = __privateGet$1(this, _hEncImgOUrl)[B] = L[B].data.src;
        __privateGet$1(this, _hAEncImg)[B].forEach((k) => {
          k.src = $, e && (k.onload = () => e(k));
        }), delete __privateGet$1(this, _hAEncImg)[B];
      }
    });
  }
  setPos(n) {
    Layer.setXY(
      this.spLay.children.length === 0 ? this.spLay : this.spLay.children[0],
      n,
      this.spLay,
      !0
    );
  }
  static add_face(n) {
    const { name: t } = n;
    if (!t)
      throw "name\u306F\u5FC5\u9808\u3067\u3059";
    if (t in __privateGet$1(_GrpLayer, _hFace))
      throw "\u4E00\u3064\u306Ename\uFF08" + t + "\uFF09\u306B\u5BFE\u3057\u3066\u540C\u3058\u753B\u50CF\u3092\u8907\u6570\u5272\u308A\u5F53\u3066\u3089\u308C\u307E\u305B\u3093";
    const { fn: e = t } = n;
    return __privateGet$1(_GrpLayer, _hFace)[t] = {
      fn: e,
      dx: argChk_Num(n, "dx", 0),
      dy: argChk_Num(n, "dy", 0),
      blendmode: Layer.getBlendmodeNum(n.blendmode || "")
    }, !1;
  }
  static clearFace2Name() {
    __privateSet$1(_GrpLayer, _hFace, {});
  }
  get containMovement() {
    if (__privateGet$1(this, _csvFn) === "")
      return !1;
    const n = this.spLay.children;
    return __privateGet$1(this, _csvFn).split(",").some(
      (t, e) => n[e] instanceof AnimatedSprite || _GrpLayer.hFn2VElm[t]
    );
  }
  clearLay(n) {
    super.clearLay(n);
    for (const t of this.spLay.removeChildren())
      t.destroy();
    __privateSet$1(this, _sBkFn, ""), __privateSet$1(this, _sBkFace, ""), __privateSet$1(this, _csvFn, "");
  }
  playback(n, t) {
    if (super.playback(n, t), n.sBkFn === "" && n.sBkFace === "") {
      __privateSet$1(this, _sBkFn, n.sBkFn), __privateSet$1(this, _sBkFace, n.sBkFace), __privateGet$1(this, _idc$1).sethArg(n.idc_hArg);
      return;
    }
    t.push(new Promise((e) => this.laySub(
      { fn: n.sBkFn, face: n.sBkFace, left: n.x, top: n.y, alpha: n.alpha, blendmode: Layer.getNum2Blendmode(n.blendMode), rotation: n.rotation, scale_x: n.scale_x, scale_y: n.scale_y },
      (o) => {
        this.spLay.position.set(n.x, n.y), e();
      }
    )));
  }
  makeDesignCast(n) {
    !this.spLay.visible || n(__privateGet$1(this, _idc$1));
  }
  cvsResize() {
    super.cvsResize();
  }
  showDesignCast() {
    __privateGet$1(this, _idc$1).visible = !0;
  }
};
let GrpLayer = _GrpLayer;
_elc = /* @__PURE__ */ new WeakMap();
_hFace = /* @__PURE__ */ new WeakMap();
_main = /* @__PURE__ */ new WeakMap();
_cfg = /* @__PURE__ */ new WeakMap();
_appPixi = /* @__PURE__ */ new WeakMap();
_sys = /* @__PURE__ */ new WeakMap();
_glbVol = /* @__PURE__ */ new WeakMap();
_movVol = /* @__PURE__ */ new WeakMap();
_evtMng = /* @__PURE__ */ new WeakMap();
_idc$1 = /* @__PURE__ */ new WeakMap();
_csvFn = /* @__PURE__ */ new WeakMap();
_sBkFn = /* @__PURE__ */ new WeakMap();
_sBkFace = /* @__PURE__ */ new WeakMap();
_width = /* @__PURE__ */ new WeakMap();
_height = /* @__PURE__ */ new WeakMap();
_dec2cache = /* @__PURE__ */ new WeakMap();
_sortAFrameName = /* @__PURE__ */ new WeakSet();
sortAFrameName_fn = function(n) {
  const t = /([^\d]+)\d+\.(\w+)/.exec(n[0]);
  if (!t)
    return;
  const e = t[1].length, o = -t[2].length - 1;
  n.sort(
    (R, N) => int(R.slice(e, o)) > int(N.slice(e, o)) ? 1 : -1
  );
};
_dec2cache4Cripto = /* @__PURE__ */ new WeakSet();
dec2cache4Cripto_fn = function(n, t, e) {
  var M;
  if (t.data = n, t.extension === "bin" && (n instanceof HTMLImageElement ? (t.texture = Texture.fromLoader(n, t.url, t.name), t.type = LoaderResource.TYPE.IMAGE, URL.revokeObjectURL(n.src)) : n instanceof HTMLVideoElement && (n.volume = __privateGet$1(_GrpLayer, _glbVol), _GrpLayer.hFn2VElm[t.name] = n, t.type = LoaderResource.TYPE.VIDEO, URL.revokeObjectURL(n.src))), t.extension !== "json") {
    e();
    return;
  }
  if (typeof n != "string") {
    e();
    return;
  }
  const o = t.data = JSON.parse(n);
  if (t.type = LoaderResource.TYPE.JSON, !((M = o.meta) != null && M.image)) {
    e();
    return;
  }
  const R = getFn(o.meta.image), N = __privateGet$1(_GrpLayer, _cfg).searchPath(R, Config.EXT_SPRITE);
  new Loader().use((D, L) => {
    __privateGet$1(this, _sys).dec(D.extension, D.data).then((B) => {
      D.data = B, B instanceof HTMLImageElement && (D.type = LoaderResource.TYPE.IMAGE, URL.revokeObjectURL(B.src)), L == null || L();
    }).catch((B) => __privateGet$1(this, _main).errScript(`Graphic \u30ED\u30FC\u30C9\u5931\u6557\u3067\u3059 dec2res4Cripto fn:${D.name} ${B}`, !1));
  }).add({ name: R, url: N, xhrType: LoaderResource.XHR_RESPONSE_TYPE.BUFFER }).load((D, L) => {
    var B;
    for (const $ in D.resources) {
      const k = Texture.from(D.resources[$].data).baseTexture, U = Object.values(o.frames);
      __privateMethod$1(B = _GrpLayer, _sortAFrameName, sortAFrameName_fn).call(B, U), _GrpLayer.hFn2ResAniSpr[t.name] = {
        aTex: U.map((z) => new Texture(
          k,
          new Rectangle(
            z.frame.x,
            z.frame.y,
            z.frame.w,
            z.frame.h
          )
        )),
        meta: o.meta
      };
    }
    e();
  });
};
_mkSprite = /* @__PURE__ */ new WeakSet();
mkSprite_fn = function(n, t) {
  var o;
  const e = _GrpLayer.hFn2ResAniSpr[n];
  if (e) {
    const R = new AnimatedSprite(e.aTex);
    return R.animationSpeed = (o = e.meta.animationSpeed) != null ? o : 1, R.play(), R;
  }
  return n in TextureCache ? Sprite.from(n) : n in _GrpLayer.hFn2VElm ? Sprite.from(_GrpLayer.hFn2VElm[n]) : n in t ? new Sprite(t[n].texture) : new Sprite();
};
_rtTsy = /* @__PURE__ */ new WeakMap();
_spTsy = /* @__PURE__ */ new WeakMap();
_fncRender = /* @__PURE__ */ new WeakMap();
_hAEncImg = /* @__PURE__ */ new WeakMap();
_hEncImgOUrl = /* @__PURE__ */ new WeakMap();
__privateAdd$1(GrpLayer, _sortAFrameName);
__privateAdd$1(GrpLayer, _dec2cache4Cripto);
__privateAdd$1(GrpLayer, _mkSprite);
__privateAdd$1(GrpLayer, _elc, new EventListenerCtn());
__privateAdd$1(GrpLayer, _hFace, {});
__privateAdd$1(GrpLayer, _main, void 0);
__privateAdd$1(GrpLayer, _cfg, void 0);
__privateAdd$1(GrpLayer, _appPixi, void 0);
__privateAdd$1(GrpLayer, _sys, void 0);
__privateAdd$1(GrpLayer, _glbVol, 1);
__privateAdd$1(GrpLayer, _movVol, 1);
__privateAdd$1(GrpLayer, _evtMng, void 0);
GrpLayer.hFn2ResAniSpr = {};
__privateAdd$1(GrpLayer, _dec2cache, (n, t, e) => {
  var o;
  switch (t.type) {
    case LoaderResource.TYPE.JSON:
      const R = t.spritesheet._frameKeys;
      __privateMethod$1(o = _GrpLayer, _sortAFrameName, sortAFrameName_fn).call(o, R), _GrpLayer.hFn2ResAniSpr[t.name] = {
        aTex: R.map((M) => Texture.from(M)),
        meta: t.data.meta
      };
      break;
    case LoaderResource.TYPE.VIDEO:
      const N = t.data;
      N.volume = __privateGet$1(_GrpLayer, _glbVol), _GrpLayer.hFn2VElm[t.name] = N;
  }
  e();
});
GrpLayer.hFn2VElm = {};
__privateAdd$1(GrpLayer, _hAEncImg, {});
__privateAdd$1(GrpLayer, _hEncImgOUrl, {});
var ls, za, hs, ne, Ar, qr, tr, bi, Ht, Zr, _r, mr, cs, Yo, yr, Or, ja, fs, Va, Mu, hc, rn, ds, nn, sn, an, un, ps, Du, Kr, Xa, fh, vs, Jr, Wa, Qr, Nr, Ya, qa, dh, Ei, ln, Za, ph, lr;
const Xt = class extends Container {
  constructor(e, o, R) {
    super();
    it(this, cs);
    it(this, Mu);
    it(this, Xa);
    it(this, qa);
    it(this, Za);
    it(this, ne, document.createElement("span"));
    it(this, Ar, new Container());
    it(this, qr, new Graphics());
    it(this, tr, new TxtLayDesignCast(this.spLay, this));
    it(this, bi, new TxtLayPadDesignCast(this));
    it(this, Ht, {
      fontsize: 24,
      $width: 0,
      $height: 0,
      pad_left: 0,
      pad_right: 0,
      pad_top: 0,
      pad_bottom: 0
    });
    it(this, Zr, !1);
    it(this, _r, 0);
    it(this, mr, 0);
    it(this, yr, 0);
    it(this, Or, !1);
    it(this, ja, 0);
    it(this, fs, 0);
    it(this, rn, void 0);
    it(this, ds, []);
    it(this, nn, []);
    it(this, sn, 0);
    it(this, Du, /animation\-duration: (?<ms>\d+)ms;/);
    it(this, Kr, () => {
    });
    it(this, vs, !1);
    it(this, Ya, 0);
    it(this, Ei, "Quadratic.Out");
    it(this, ln, "Quadratic.Out");
    it(this, lr, void 0);
    this.spLay = e, this.canFocus = o, this.sys = R, H(this, ne).classList.add("sn_tx"), H(this, ne).style.position = "absolute", H(Xt, za).view.parentElement.appendChild(H(this, ne)), this.addChild(H(this, Ar)), this.addChild(H(this, qr)), H(this, qr).name = "grpDbgMasume", H(this, tr).adopt(H(this, bi));
  }
  static init(e, o) {
    et(Xt, ls, e), et(Xt, za, o), et(Xt, an, /[!?]/), et(Xt, un, /[]/), et(Xt, ps, /[]/);
  }
  static setEvtMng(e) {
    et(Xt, hs, e);
  }
  static destroy() {
    et(Xt, Va, {
      backgroundColor: 0,
      borderBottomWidth: 0,
      borderLeftWidth: 0,
      borderRightWidth: 0,
      borderTopWidth: 0,
      marginBottom: 0,
      marginLeft: 0,
      marginRight: 0,
      marginTop: 0
    }), et(Xt, Jr, /* @__PURE__ */ Object.create(null)), et(Xt, Qr, /* @__PURE__ */ Object.create(null)), et(Xt, Nr, new Container());
  }
  lay(e) {
    var R, N, M, D, L, B, $, k;
    const o = H(this, ne).style;
    if (e.style) {
      const U = document.createElement("span");
      U.style.cssText = e.style;
      const z = U.style.length;
      for (let X = 0; X < z; ++X) {
        const V = U.style[X];
        if (V in H(Xt, Va)) {
          DebugMng.myTrace(`${V}\u306F\u6307\u5B9A\u3067\u304D\u307E\u305B\u3093`, "W");
          continue;
        }
        o[V] = U.style[V];
      }
      !U.style.opacity && "alpha" in e && (o.opacity = String(this.spLay.alpha));
    } else
      "alpha" in e && (o.opacity = String(this.spLay.alpha));
    if ("width" in e && (o.width = ((R = e.width) != null ? R : "0") + "px"), "height" in e && (o.height = ((N = e.height) != null ? N : "0") + "px"), "pl" in e && (o.paddingLeft = ((M = e.pl) != null ? M : "0") + "px"), "pr" in e && (o.paddingRight = ((D = e.pr) != null ? D : "0") + "px"), "pt" in e && (o.paddingTop = ((L = e.pt) != null ? L : "0") + "px"), "pb" in e && (o.paddingBottom = ((B = e.pb) != null ? B : "0") + "px"), "kinsoku_sol" in e && et(Xt, an, new RegExp(`[${e.kinsoku_sol}]`)), "kinsoku_eol" in e && et(Xt, un, new RegExp(`[${e.kinsoku_eol}]`)), "kinsoku_dns" in e && et(Xt, ps, new RegExp(`[${e.kinsoku_dns}]`)), st(this, cs, Yo).call(this), H(this, tr).sethArg(e), et(this, yr, this.spLay.position.x), o.transformOrigin = `${this.spLay.pivot.x}px ${this.spLay.pivot.y}px`, this.cvsResize(), o.display = this.spLay.visible ? "inline" : "none", o.textShadow = (k = ($ = e.filter) != null ? $ : o.textShadow) != null ? k : "", et(this, Zr, argChk_Boolean(e, "break_fixed", H(this, Zr))), et(this, _r, argChk_Num(e, "break_fixed_left", H(this, _r))), et(this, mr, argChk_Num(e, "break_fixed_top", H(this, mr))), ":redraw" in e && H(this, sn) > 0) {
      const U = [
        H(this, ne).innerHTML.replace(/(animation-delay: )\d+ms/g, "$10ms"),
        `<span class='sn_ch' data-add='{"ch_in_style":"default"}'>\u3000</span>`
      ];
      st(this, Za, ph).call(this), this.goTxt(U);
    }
  }
  cvsResize() {
    const e = H(this, ne).style;
    e.left = `${this.sys.ofsLeft4elm + H(this, yr) * this.sys.cvsScale}px`, e.top = `${this.sys.ofsTop4elm + this.spLay.position.y * this.sys.cvsScale}px`, e.transform = `rotate(${this.spLay.angle}deg) scale(${this.spLay.scale.x * this.sys.cvsScale}, ${this.spLay.scale.y * this.sys.cvsScale})`, H(this, tr).cvsResize(), H(this, bi).cvsResize();
  }
  get tategaki() {
    return H(this, Or);
  }
  get infTL() {
    return H(this, Ht);
  }
  get getWidth() {
    return H(this, Ht).$width;
  }
  get getHeight() {
    return H(this, Ht).$height;
  }
  setSize(e, o) {
    H(this, Ht).$width = e, H(this, Ht).$height = o, H(this, ne).style.width = H(this, Ht).$width + "px", H(this, ne).style.height = H(this, Ht).$height + "px";
  }
  goTxt(e) {
    var W, Y, q, Z, J, Q;
    H(Xt, Nr).visible = !1;
    const o = H(this, nn).length;
    o === 0 ? (H(Xt, ls).oCfg.debug.masume && (CmnLib.debugLog && console.log(`\u{1F34C} masume ${this.name} v:${this.visible} l:${this.x} t:${this.y} a:${this.alpha} pl:${H(this, Ht).pad_left} pr:${H(this, Ht).pad_right} pt:${H(this, Ht).pad_top} pb:${H(this, Ht).pad_bottom} w:${H(this, Ht).$width} h:${H(this, Ht).$height}`), H(this, qr).clear().beginFill(3407616, 0.2).lineStyle(1, 3407616, 1).drawRect(-H(this, Ht).pad_left, -H(this, Ht).pad_top, H(this, Ht).$width, H(this, Ht).$height).endFill().beginFill(13311, 0.2).lineStyle(2, 13311, 1).drawRect(
      0,
      0,
      H(this, Ht).$width - H(this, Ht).pad_left - H(this, Ht).pad_right,
      H(this, Ht).$height - H(this, Ht).pad_top - H(this, Ht).pad_bottom
    ).endFill()), H(this, ne).innerHTML = [...e].join("").replaceAll(/[\n\t]/g, "")) : H(this, ne).insertAdjacentHTML("beforeend", e.slice(H(this, sn)).join("").replaceAll(/[\n\t]/g, "")), et(this, sn, e.length);
    let R = 0, N = 2;
    do {
      const K = et(this, nn, st(this, qa, dh).call(this, H(this, ne)));
      if (R = K.length, this.sys.cvsScale !== 1) {
        const tt = this.sys.ofsPadLeft_Dom2PIXI + parseFloat(H(this, ne).style.left) * (1 - this.sys.cvsScale), nt = this.sys.ofsPadTop_Dom2PIXI + parseFloat(H(this, ne).style.top) * (1 - this.sys.cvsScale);
        for (let at = 0; at < R; ++at) {
          const lt = K[at].rect;
          lt.x -= tt, lt.y -= nt, lt.x /= this.sys.cvsScale, lt.y /= this.sys.cvsScale, lt.width /= this.sys.cvsScale, lt.height /= this.sys.cvsScale;
        }
      }
      if (R < 2)
        break;
      let rt = -1 / 0;
      for (; N < R; ++N) {
        const tt = K[N];
        if (tt.elm.outerHTML.slice(0, 3) === "<rt")
          continue;
        const nt = this.tategaki ? tt.rect.y : tt.rect.x;
        if (rt <= nt) {
          rt = nt;
          continue;
        }
        rt = -1 / 0;
        const at = N;
        if (H(Xt, ps).test(K[N - 1].ch) && K[N - 1].ch === tt.ch)
          --N;
        else {
          if (H(Xt, un).test(K[N - 1].ch))
            --N;
          else if (H(Xt, an).test(tt.ch))
            for (; N > 0 && H(Xt, an).test(K[--N].ch); )
              ;
          else
            continue;
          for (; N > 0 && H(Xt, un).test(K[N - 1].ch); )
            --N;
        }
        const lt = K[N].elm.parentElement, ut = document.createElement("br");
        if (lt.classList.contains("sn_tx"))
          lt.insertBefore(ut, K[N].elm);
        else {
          const dt = lt.parentElement;
          dt.classList.contains("sn_ch") ? dt.parentElement.insertBefore(ut, dt) : dt.insertBefore(ut, lt);
        }
        N += 2, N < at && (N = at), R = -1;
        break;
      }
    } while (R < 0);
    const M = CmnLib.debugLog ? (K, rt) => console.log(`\u{1F34C} masume ch:${K.ch} x:${rt.x} y:${rt.y} w:${rt.width} h:${rt.height}`) : () => {
    }, D = H(Xt, ls).oCfg.debug.masume ? (K, rt) => {
      M(K, rt), H(this, qr).beginFill(6737151, 0.5).lineStyle(2, 16724736, 1).drawRect(rt.x, rt.y, rt.width, rt.height).endFill();
    } : () => {
    }, L = CmnTween.ease(H(this, Ei)), B = H(this, ne).getBoundingClientRect(), $ = B.left + globalThis.scrollX + H(this, Ht).pad_left, k = B.top + globalThis.scrollY + H(this, Ht).pad_top;
    let U = new Rectangle();
    for (let K = o; K < R; ++K) {
      const rt = H(this, nn)[K], tt = rt.rect, nt = JSON.parse((W = rt.arg) != null ? W : '{"delay": 0}'), at = JSON.parse((Y = rt.add) != null ? Y : "{}"), lt = H(Xt, Jr)[at.ch_in_style];
      if (tt.x -= $, tt.y -= k, D(rt, tt), lt && (H(this, Or) ? (tt.x += (tt.width - tt.height) / 2, tt.width = tt.height) : (tt.y += (tt.height - tt.width) / 2, tt.height = tt.width), U = tt), rt.cmd === "grp") {
        const ut = new Container();
        H(this, Ar).addChild(ut), GrpLayer.csv2Sprites(nt.pic, ut, (dt) => {
          st(this, Xa, fh).call(this, ut, nt, at, tt, L, lt != null ? lt : {}), ut.parent || ut.removeChild(dt);
        });
      }
      if (rt.lnk) {
        const ut = rt.elm.parentElement.closest("[data-arg]"), dt = JSON.parse((q = ut.dataset.arg) != null ? q : "{}");
        dt.key = `lnk=[${K}] ` + this.name;
        const yt = new Sprite();
        st(this, Xa, fh).call(this, yt, dt, at, tt, L, lt != null ? lt : {});
        const pt = (Z = dt.style) != null ? Z : "", gt = pt + ((J = dt.style_hover) != null ? J : ""), xt = pt + ((Q = dt.style_clicked) != null ? Q : ""), Lt = ut.style.cssText, mt = (vt) => {
          !vt || (ut.style.cssText = Lt + vt);
        };
        ut.querySelectorAll(".sn_ch").forEach((vt) => vt.dataset.st_bk = vt.style.cssText), H(Xt, hs).button(
          dt,
          yt,
          () => mt(pt),
          () => this.canFocus() ? (mt(gt), !0) : !1,
          () => mt(xt)
        ), H(this, Ar).addChild(yt);
      }
    }
    const z = H(this, ne).querySelectorAll("span.sn_ch");
    z.forEach((K) => K.className = K.className.replace(/sn_ch_in_([^\s"]+)/g, "go_ch_in_$1")), et(this, vs, !0), et(this, Kr, () => {
      et(this, vs, !1), z.forEach((K) => K.className = K.className.replace(/ go_ch_in_[^\s"]+/g, "")), o !== R && (et(this, _r, U.x + (H(this, Or) ? 0 : U.width)), et(this, mr, U.y + (H(this, Or) ? U.height : 0))), H(Xt, Nr).position.set(
        H(this, _r),
        H(this, mr)
      ), H(Xt, Nr).visible = !0, et(this, Kr, () => {
      });
    });
    const X = z.length;
    if (X === 0) {
      H(this, Kr).call(this);
      return;
    }
    let V;
    for (let K = X - 1; K >= 0; --K) {
      const rt = z[K];
      if (rt.className === "sn_ch")
        break;
      const tt = rt.getAttribute("style");
      if (!tt) {
        V = rt;
        break;
      }
      const nt = tt.match(H(this, Du)), at = nt == null ? void 0 : nt.groups;
      if (!at || Number(at.ms) > 0) {
        V = rt;
        break;
      }
    }
    if (!V) {
      H(this, Kr).call(this);
      return;
    }
    V.addEventListener("animationend", H(this, Kr), { once: !0, passive: !0 });
  }
  skipChIn() {
    let e = H(this, vs);
    return H(this, Kr).call(this), H(this, ds).forEach((o) => {
      o.tw && (o.tw.stop().end(), e = !0);
    }), et(this, ds, []), e;
  }
  static initChStyle() {
    et(Xt, Jr, /* @__PURE__ */ Object.create(null)), et(Xt, Qr, /* @__PURE__ */ Object.create(null));
  }
  static getChInStyle(e) {
    return H(Xt, Jr)[e];
  }
  static ch_in_style(e) {
    var M, D, L;
    const { name: o } = e;
    if (!o)
      throw "name\u306F\u5FC5\u9808\u3067\u3059";
    if (H(Xt, Wa).test(o))
      throw `name\u3010${o}\u3011\u306B\u4F7F\u3048\u306A\u3044\u6587\u5B57\u304C\u542B\u307E\u308C\u307E\u3059`;
    if (o in H(Xt, Jr))
      throw `name\u3010${o}\u3011\u306F\u3059\u3067\u306B\u3042\u308A\u307E\u3059`;
    const R = String((M = e.x) != null ? M : "=0"), N = String((D = e.y) != null ? D : "=0");
    return H(Xt, Jr)[o] = {
      wait: argChk_Num(e, "wait", 500),
      alpha: argChk_Num(e, "alpha", 0),
      x: R,
      y: N,
      nx: parseFloat(R.charAt(0) === "=" ? R.slice(1) : R),
      ny: parseFloat(N.charAt(0) === "=" ? N.slice(1) : N),
      scale_x: argChk_Num(e, "scale_x", 1),
      scale_y: argChk_Num(e, "scale_y", 1),
      rotate: argChk_Num(e, "rotate", 0),
      join: argChk_Boolean(e, "join", !0),
      ease: (L = e.ease) != null ? L : "ease-out"
    };
  }
  static getChOutStyle(e) {
    return H(Xt, Qr)[e];
  }
  static ch_out_style(e) {
    var M, D, L;
    const { name: o } = e;
    if (!o)
      throw "name\u306F\u5FC5\u9808\u3067\u3059";
    if (H(Xt, Wa).test(o))
      throw `name\u3010${o}\u3011\u306B\u4F7F\u3048\u306A\u3044\u6587\u5B57\u304C\u542B\u307E\u308C\u307E\u3059`;
    if (o in H(Xt, Qr))
      throw `name\u3010${o}\u3011\u306F\u3059\u3067\u306B\u3042\u308A\u307E\u3059`;
    const R = String((M = e.x) != null ? M : "=0"), N = String((D = e.y) != null ? D : "=0");
    return H(Xt, Qr)[o] = {
      wait: argChk_Num(e, "wait", 500),
      alpha: argChk_Num(e, "alpha", 0),
      x: R,
      y: N,
      nx: parseFloat(R.charAt(0) === "=" ? R.slice(1) : R),
      ny: parseFloat(N.charAt(0) === "=" ? N.slice(1) : N),
      scale_x: argChk_Num(e, "scale_x", 1),
      scale_y: argChk_Num(e, "scale_y", 1),
      rotate: argChk_Num(e, "rotate", 0),
      join: argChk_Boolean(e, "join", !1),
      ease: (L = e.ease) != null ? L : "ease-out"
    };
  }
  dispBreak(e) {
    const o = H(Xt, Nr);
    o.visible = !1, this.addChild(o), GrpLayer.csv2Sprites(e, o, (R) => {
      o.parent || o.removeChild(R);
    });
  }
  static delBreak() {
    const e = H(Xt, Nr);
    e.parent && (e.parent.removeChild(e), e.removeChildren()), et(Xt, Nr, new Container());
  }
  reNew() {
    var o;
    st(this, Za, ph).call(this);
    const e = new Xt(this.spLay, () => this.canFocus(), this.sys);
    return et(e, Ht, H(this, Ht)), H(e, ne).style.cssText = H(this, ne).style.cssText, et(e, yr, H(this, yr)), e.name = this.name, st(o = e, cs, Yo).call(o), H(e, tr).sethArg(H(this, tr).gethArg()), et(e, rn, H(this, rn)), et(e, Ei, H(this, Ei)), et(e, ln, H(this, ln)), et(e, Zr, H(this, Zr)), et(e, _r, H(this, _r)), et(e, mr, H(this, mr)), this.destroy(), e;
  }
  record() {
    return {
      infTL: H(this, Ht),
      cssText: H(this, ne).style.cssText,
      left: H(this, yr),
      idc_hArg: H(this, tr).gethArg(),
      ch_filter: H(this, rn),
      fi_easing: H(this, Ei),
      fo_easing: H(this, ln),
      break_fixed: H(this, Zr),
      break_fixed_left: H(this, _r),
      break_fixed_top: H(this, mr)
    };
  }
  playback(e) {
    var o, R, N;
    et(this, Ht, e.infTL), this.position.set(H(this, Ht).pad_left, H(this, Ht).pad_top), H(this, ne).style.cssText = e.cssText, et(this, yr, e.left), st(this, cs, Yo).call(this), H(this, tr).sethArg(e.idc_hArg), et(this, rn, e.ch_filter), et(this, Ei, e.fi_easing), et(this, ln, e.fo_easing), et(this, Zr, (o = e.break_fixed) != null ? o : !1), et(this, _r, (R = e.break_fixed_left) != null ? R : 0), et(this, mr, (N = e.break_fixed_top) != null ? N : 0);
  }
  snapshot(e, o) {
    st(this, Mu, hc).call(this, (R) => {
      et(this, lr, new Sprite(R)), H(this, Or) && (H(this, lr).x += CmnLib.stageW - (H(this, yr) + H(this, Ht).$width)), H(this, lr).y -= H(this, fs), H(this, lr).texture.frame = new Rectangle(0, 0, H(this, Ht).$width - H(this, yr), H(this, Ht).$height), H(this, Ar).addChild(H(this, lr)), e.render(H(this, lr), void 0, !1), o();
    }, !1);
  }
  snapshot_end() {
    H(this, lr) && (H(this, Ar).removeChild(H(this, lr)), et(this, lr, void 0));
  }
  makeDesignCast(e) {
    e(H(this, tr));
    const o = H(this, tr).gethArg();
    H(this, bi).sethArg({ ...o, ":id_dc": o[":id_tag"] + "_pad" }), e(H(this, bi));
  }
  showDesignCast() {
    H(this, tr).visible = !0, H(this, bi).visible = !0;
  }
  dump() {
    const e = [], o = H(this, ne).style, R = o.length;
    for (let N = 0; N < R; ++N) {
      const M = o[N];
      e.push(`"${M}":"${o[M].replace(/(["\\])/g, "\\$1")}"`);
    }
    return `"txt":"${H(this, ne).textContent.replace(/(["\\])/g, "\\$1")}", "style":{${e.join(",")}}`;
  }
  destroy() {
    Xt.delBreak(), H(this, ne).parentElement.removeChild(H(this, ne)), this.removeChild(H(this, Ar)), this.removeChild(H(this, qr)), super.destroy();
  }
};
let TxtStage = Xt;
ls = new WeakMap(), za = new WeakMap(), hs = new WeakMap(), ne = new WeakMap(), Ar = new WeakMap(), qr = new WeakMap(), tr = new WeakMap(), bi = new WeakMap(), Ht = new WeakMap(), Zr = new WeakMap(), _r = new WeakMap(), mr = new WeakMap(), cs = new WeakSet(), Yo = function() {
  var N;
  const e = H(this, ne).style, o = parseFloat(e.fontSize || "0");
  H(this, Ht).fontsize = o, H(this, Ht).pad_left = parseFloat(e.paddingLeft || "0"), H(this, Ht).pad_right = parseFloat(e.paddingRight || "0"), H(this, Ht).pad_top = parseFloat(e.paddingTop || "0"), H(this, Ht).pad_bottom = parseFloat(e.paddingBottom || "0"), H(this, Ht).$width = parseFloat(e.width || "0"), H(this, Ht).$height = parseFloat(e.height || "0"), this.position.set(H(this, Ht).pad_left, H(this, Ht).pad_top), et(this, Or, e.writingMode === "vertical-rl"), et(this, ja, 0), et(this, fs, 0);
  const R = (N = e.lineHeight) != null ? N : "0";
  et(this, Ya, H(this, Or) ? 0 : (R.slice(-2) === "px" ? parseFloat(R) : o * parseFloat(R) - o) / 2);
}, yr = new WeakMap(), Or = new WeakMap(), ja = new WeakMap(), fs = new WeakMap(), Va = new WeakMap(), Mu = new WeakSet(), hc = function(e, o = !0) {
  const R = {
    escape: (W) => W.replace(/([.*+?^${}()|\[\]\/\\])/g, "\\$1"),
    mimeType: (W) => {
      const Y = B(W).toLowerCase();
      return N()[Y] || "";
    },
    dataAsUrl: z,
    isDataUrl: $,
    resolveUrl: k,
    getAndEncode: U,
    asArray: (W) => {
      const Y = [], q = W.length;
      for (let Z = 0; Z < q; ++Z)
        Y.push(W[Z]);
      return Y;
    }
  };
  function N() {
    const W = "application/font-woff", Y = "image/jpeg";
    return {
      woff: W,
      woff2: W,
      ttf: "application/font-truetype",
      eot: "application/vnd.ms-fontobject",
      png: "image/png",
      jpg: Y,
      jpeg: Y,
      gif: "image/gif",
      tiff: "image/tiff",
      svg: "image/svg+xml"
    };
  }
  const M = X(), D = V();
  function L(W) {
    return D.resolveAll().then((Y) => {
      const q = document.createElement("style");
      return W.appendChild(q), q.appendChild(document.createTextNode(Y)), W;
    });
  }
  function B(W) {
    var q;
    const Y = /\.([^\.\/]*?)$/g.exec(W);
    return (q = Y == null ? void 0 : Y[1]) != null ? q : "";
  }
  function $(W) {
    return W.search(/^(data:)/) !== -1;
  }
  function k(W, Y) {
    const q = document.implementation.createHTMLDocument(), Z = q.createElement("base");
    q.head.appendChild(Z);
    const J = q.createElement("a");
    return q.body.appendChild(J), Z.href = Y, J.href = W, J.href;
  }
  function U(W) {
    let Y = 3e4;
    return new Promise(function(q) {
      const Z = new XMLHttpRequest();
      Z.onreadystatechange = J, Z.ontimeout = Q, Z.responseType = "blob", Z.timeout = Y, Z.open("GET", W, !0), Z.send();
      function J() {
        if (Z.readyState !== 4)
          return;
        if (Z.status !== 200) {
          K("cannot fetch resource: " + W + ", status: " + Z.status);
          return;
        }
        const rt = new FileReader();
        rt.onloadend = function() {
          const tt = rt.result.toString().split(/,/)[1];
          q(tt);
        }, rt.readAsDataURL(Z.response);
      }
      function Q() {
        K("timeout of " + Y + "ms occured while fetching resource: " + W);
      }
      function K(rt) {
        console.error(rt), q("");
      }
    });
  }
  function z(W, Y) {
    return "data:" + Y + ";base64," + W;
  }
  function X() {
    const W = /url\(['"]?([^'"]+?)['"]?\)/g;
    return {
      inlineAll: J,
      shouldProcess: Y
    };
    function Y(Q) {
      return Q.search(W) !== -1;
    }
    function q(Q) {
      const K = [];
      let rt;
      for (; rt = W.exec(Q); )
        K.push(rt[1]);
      return K.filter(function(tt) {
        return !R.isDataUrl(tt);
      });
    }
    function Z(Q, K, rt, tt) {
      return Promise.resolve(K).then((at) => rt ? R.resolveUrl(at, rt) : at).then(tt || R.getAndEncode).then((at) => R.dataAsUrl(at, R.mimeType(K))).then((at) => Q.replace(nt(K), "$1" + at + "$3"));
      function nt(at) {
        return new RegExp(`(url\\(['"]?)(` + R.escape(at) + `)(['"]?\\))`, "g");
      }
    }
    function J(Q, K, rt) {
      if (tt())
        return Promise.resolve(Q);
      return Promise.resolve(Q).then(q).then((nt) => {
        let at = Promise.resolve(Q);
        for (const lt of nt)
          at = at.then((ut) => Z(ut, lt, K, rt));
        return at;
      });
      function tt() {
        return !Y(Q);
      }
    }
  }
  function V() {
    return {
      resolveAll: W,
      impl: { readAll: Y }
    };
    function W() {
      return Y().then((q) => Promise.allSettled(
        q.map((Z) => Z.resolve())
      )).then((q) => q.join(`
`));
    }
    function Y() {
      return Promise.resolve(R.asArray(document.styleSheets)).then(Z).then(q).then((Q) => Q.map(J));
      function q(Q) {
        return Q.filter((K) => K.type === CSSRule.FONT_FACE_RULE).filter((K) => M.shouldProcess(K.style.getPropertyValue("src")));
      }
      function Z(Q) {
        const K = [];
        for (const rt of Q)
          try {
            if (rt.href)
              continue;
            R.asArray(rt.cssRules || []).forEach(K.push.bind(K));
          } catch (tt) {
            console.error("Error while reading CSS rules from " + rt.href, tt.toString());
          }
        return K;
      }
      function J(Q) {
        return {
          resolve: function() {
            const rt = (Q.parentStyleSheet || {}).href;
            return M.inlineAll(Q.cssText, rt);
          },
          src: function() {
            return Q.style.getPropertyValue("src");
          }
        };
      }
    }
  }
  Promise.resolve(H(this, ne)).then((W) => {
    const Y = W.cloneNode(!0);
    return Y.style.padding = "0px", Y.style.paddingRight = H(this, ja) + "px", Y.style.paddingTop = H(this, fs) + "px", Y.style.left = "0px", Y.style.top = "0px", Y.style.width = H(this, Ht).$width - H(this, Ht).pad_left - H(this, Ht).pad_right + "px", Y.style.height = H(this, Ht).$height - H(this, Ht).pad_top - H(this, Ht).pad_bottom + "px", H(this, ne).hidden = o, Y;
  }).then(L).then((W) => {
    W.setAttribute("xmlns", "http://www.w3.org/1999/xhtml");
    const Y = new Image();
    return Y.src = `data:image/svg+xml;charset=utf-8,<svg xmlns="http://www.w3.org/2000/svg" width="${H(this, Ht).$width}px" height="${H(this, Ht).$height}px"><foreignObject x="0" y="0" width="100%" height="100%">${new XMLSerializer().serializeToString(W).replaceAll("#", "%23").replaceAll(`
`, "%0A")}</foreignObject></svg>`, new Promise((q) => Y.onload = () => q(Y));
  }).then((W) => new Promise((Y) => setTimeout(() => Y(W), 100))).then((W) => {
    const Y = document.createElement("canvas");
    Y.width = H(this, Ht).$width, Y.height = H(this, Ht).$height, Y.getContext("2d").drawImage(W, 0, 0), Y.toBlob((q) => {
      if (!q)
        return;
      const Z = URL.createObjectURL(q);
      Texture.from(Z).once("update", (J) => {
        e(J), URL.revokeObjectURL(Z);
      });
    });
  }).catch((W) => DebugMng.myTrace(`goTxt() = ${W}`));
}, rn = new WeakMap(), ds = new WeakMap(), nn = new WeakMap(), sn = new WeakMap(), an = new WeakMap(), un = new WeakMap(), ps = new WeakMap(), Du = new WeakMap(), Kr = new WeakMap(), Xa = new WeakSet(), fh = function(e, o, R, N, M, D) {
  var B, $, k;
  e.alpha = 0, o.x && (N.x = o.x.charAt(0) === "=" ? N.x + parseInt(o.x.slice(1)) : parseInt(o.x)), o.y && (N.y = o.y.charAt(0) === "=" ? N.y + parseInt(o.y.slice(1)) : parseInt(o.y)), o.width && (N.width = parseInt(o.width)), o.height && (N.height = parseInt(o.height)), o.wait && (D.wait = parseInt(o.wait)), e.width = N.width, e.height = N.height, D.x ? e.position.set(
    D.x.charAt(0) === "=" ? N.x + e.width * D.nx : D.nx,
    D.y.charAt(0) === "=" ? N.y + e.height * D.ny : D.ny
  ) : e.position.set(N.x, N.y);
  const L = {
    sp: e,
    tw: new Tween(e).to({ alpha: 1, x: N.x, y: N.y, width: N.width, height: N.height, angle: 0 }, (B = D.wait) != null ? B : 0).easing(M).delay((($ = R.wait) != null ? $ : 0) + ((k = o.delay) != null ? k : 0)).onComplete(() => {
      L.tw = void 0;
    }).start()
  };
  H(this, ds).push(L);
}, vs = new WeakMap(), Jr = new WeakMap(), Wa = new WeakMap(), Qr = new WeakMap(), Nr = new WeakMap(), Ya = new WeakMap(), qa = new WeakSet(), dh = function(e) {
  var D, L, B, $;
  const o = [];
  if (e.nodeType !== e.TEXT_NODE)
    return e.childNodes.forEach((k) => o.push(st(this, qa, dh).call(this, k))), o.flat();
  const R = e.ownerDocument.createRange();
  R.selectNodeContents(e);
  let N = 0;
  const M = R.endOffset;
  for (; N < M; ) {
    R.setStart(e, N), R.setEnd(e, ++N);
    const k = R.getBoundingClientRect(), U = R.startContainer.parentElement;
    if (!U)
      throw "fn:TxtStage.ts pe null";
    const z = R.toString(), X = {
      ch: z,
      rect: new Rectangle(
        k.left + globalThis.scrollX,
        k.top + globalThis.scrollY,
        k.width,
        k.height + ("gjqy".includes(z) ? H(this, Ya) : 0)
      ),
      elm: U,
      cmd: (D = U.getAttribute("data-cmd")) != null ? D : void 0,
      arg: (L = U.getAttribute("data-arg")) != null ? L : void 0,
      add: (B = U.getAttribute("data-add")) != null ? B : void 0,
      lnk: ($ = U.getAttribute("data-lnk")) != null ? $ : void 0
    };
    o.push(X);
  }
  return R.detach(), o;
}, Ei = new WeakMap(), ln = new WeakMap(), Za = new WeakSet(), ph = function() {
  var M;
  H(this, qr).clear(), et(this, nn, []), et(this, sn, 0), this.skipChIn();
  const e = H(this, ne).cloneNode(!0);
  e.textContent = "";
  const o = H(this, ne);
  o.parentElement.insertBefore(e, o);
  let R = 0;
  o.querySelectorAll("span.sn_ch").forEach((D) => {
    var $, k, U, z, X, V;
    const L = JSON.parse(
      (V = (X = (k = D == null ? void 0 : D.getAttribute("data-add")) != null ? k : ($ = D == null ? void 0 : D.children[0]) == null ? void 0 : $.getAttribute("data-add")) != null ? X : (z = (U = D == null ? void 0 : D.children[0]) == null ? void 0 : U.children[0]) == null ? void 0 : z.getAttribute("data-add")) != null ? V : "{}"
    );
    if (!L.ch_out_style)
      return;
    const B = H(Xt, Qr)[L.ch_out_style];
    if (!!B) {
      if (B.wait === 0) {
        D.style.display = "none";
        return;
      }
      R += B.wait, B.join || (D.style.animationDelay = "0ms"), D.classList.add(`go_ch_out_${L.ch_out_style}`);
    }
  });
  const N = () => {
    o.parentElement.removeChild(o), H(this, Ar).removeChildren().forEach((D) => {
      D instanceof Container && H(Xt, hs).unButton(D), D.destroy();
    });
  };
  R === 0 ? (H(this, ne).textContent = "", N()) : (M = o.lastElementChild) == null || M.addEventListener("animationend", N, { once: !0, passive: !0 }), et(this, ne, e);
}, lr = new WeakMap(), it(TxtStage, ls, void 0), it(TxtStage, za, void 0), it(TxtStage, hs, void 0), it(TxtStage, Va, {
  backgroundColor: 0,
  borderBottomWidth: 0,
  borderLeftWidth: 0,
  borderRightWidth: 0,
  borderTopWidth: 0,
  marginBottom: 0,
  marginLeft: 0,
  marginRight: 0,
  marginTop: 0
}), it(TxtStage, an, void 0), it(TxtStage, un, void 0), it(TxtStage, ps, void 0), it(TxtStage, Jr, /* @__PURE__ */ Object.create(null)), it(TxtStage, Wa, /[\s\.,]/), it(TxtStage, Qr, /* @__PURE__ */ Object.create(null)), it(TxtStage, Nr, new Container());
var __accessCheck = (n, t, e) => {
  if (!t.has(n))
    throw TypeError("Cannot " + e);
}, __privateGet = (n, t, e) => (__accessCheck(n, t, "read from private field"), e ? e.call(n) : t.get(n)), __privateAdd = (n, t, e) => {
  if (t.has(n))
    throw TypeError("Cannot add the same private member more than once");
  t instanceof WeakSet ? t.add(n) : t.set(n, e);
}, __privateSet = (n, t, e, o) => (__accessCheck(n, t, "write to private field"), o ? o.call(n, e) : t.set(n, e), e), __privateMethod = (n, t, e) => (__accessCheck(n, t, "access private method"), e), _procMasume4txt, _procMasume4pic, _rctBtnTxt, _idc, _sp_b_pic, _sp_pic, _loaded_b_pic, loaded_b_pic_fn, _normal, _hover, _clicked, _loaded_pic, loaded_pic_fn;
const _Button = class extends Container {
  constructor(n, t, e, o) {
    var z, X, V;
    var R;
    super(), this.hArg = n, this.evtMng = t, this.resolve = e, this.canFocus = o, __privateAdd(this, _loaded_b_pic), __privateAdd(this, _loaded_pic), this.getBtnBounds = () => __privateGet(this, _rctBtnTxt), __privateAdd(this, _rctBtnTxt, new Rectangle()), __privateAdd(this, _idc, void 0), __privateAdd(this, _sp_b_pic, void 0), __privateAdd(this, _sp_pic, void 0), __privateAdd(this, _normal, () => {
    }), __privateAdd(this, _hover, () => !1), __privateAdd(this, _clicked, () => {
    }), CmnLib.isDbg && (this.makeDesignCast = (W) => W(__privateGet(this, _idc)), this.cvsResize = () => __privateGet(this, _idc).cvsResize());
    let N = {
      x: this.x = uint((z = n.left) != null ? z : 0),
      y: this.y = uint((X = n.top) != null ? X : 0),
      rotation: this.angle = argChk_Num(n, "rotation", this.angle),
      pivot_x: this.pivot.x = argChk_Num(n, "pivot_x", this.pivot.x),
      pivot_y: this.pivot.y = argChk_Num(n, "pivot_y", this.pivot.y),
      scale_x: this.scale.x = argChk_Num(n, "scale_x", this.scale.x),
      scale_y: this.scale.y = argChk_Num(n, "scale_y", this.scale.y),
      width: 0,
      height: 0
    };
    const M = N.enabled = argChk_Boolean(n, "enabled", !0);
    if (this.getBtnBounds = () => (__privateGet(this, _rctBtnTxt).x = N.x, __privateGet(this, _rctBtnTxt).y = N.y, __privateGet(this, _rctBtnTxt)), n.pic) {
      N.type = "pic", __privateSet(this, _idc, new PicBtnDesignCast(this, n)), M && this.evtMng.button(this.hArg, this, () => __privateGet(this, _normal).call(this), () => __privateGet(this, _hover).call(this), () => __privateGet(this, _clicked).call(this)), GrpLayer.csv2Sprites(
        n.pic,
        this,
        (W) => {
          __privateMethod(this, _loaded_pic, loaded_pic_fn).call(this, W, N), __privateGet(this, _rctBtnTxt).width = W.width * N.scale_x, __privateGet(this, _rctBtnTxt).height = W.height * N.scale_y;
        },
        (W) => e
      );
      return;
    }
    if (!n.text)
      throw "text\u307E\u305F\u306Fpic\u5C5E\u6027\u306F\u5FC5\u9808\u3067\u3059";
    const D = argChk_Num(n, "height", 30), L = new TextStyle({
      align: "center",
      dropShadow: !0,
      dropShadowAlpha: 0.7,
      dropShadowColor: "white",
      dropShadowBlur: 7,
      dropShadowDistance: 0,
      fill: "black",
      fontFamily: _Button.fontFamily,
      fontSize: D,
      padding: 5
    });
    if (n.style)
      try {
        const W = JSON.parse(n.style);
        for (const Y in W)
          L[Y] = W[Y];
      } catch (W) {
        throw new Error(mesErrJSON(n, "style", W.message));
      }
    const B = new Text((V = n.text) != null ? V : "", L);
    B.alpha = argChk_Num(n, "alpha", B.alpha), B.width = argChk_Num(n, "width", 100), B.height = n.height = D, this.setText = (W) => B.text = W, N.type = "text", N = { ...N, ...L }, N.alpha = B.alpha, N.text = B.text, N.width = B.width, N.height = B.height, __privateSet(this, _idc, new TxtBtnDesignCast(this, n, B));
    let $ = !1;
    if (n.b_pic && (N.b_pic = n.b_pic, $ = GrpLayer.csv2Sprites(
      n.b_pic,
      this,
      (W) => {
        __privateMethod(this, _loaded_b_pic, loaded_b_pic_fn).call(this, W, B), N.width = this.width, N.height = this.height;
      },
      (W) => {
        Layer.setBlendmode(this, n), W && e();
      }
    )), B.name = JSON.stringify(N), this.addChild(B), __privateGet(this, _rctBtnTxt).width = B.width, __privateGet(this, _rctBtnTxt).height = B.height, N.width = this.width, N.height = this.height, n.b_pic || Layer.setBlendmode(this, n), __privateGet(R = _Button, _procMasume4txt).call(R, this, B), !M) {
      $ || e();
      return;
    }
    const k = L.clone();
    if (n.style_hover)
      try {
        const W = JSON.parse(n.style_hover);
        for (const Y in W)
          k[Y] = W[Y];
      } catch (W) {
        throw new Error(mesErrJSON(n, "style_hover", W.message));
      }
    else
      k.fill = "white";
    const U = k.clone();
    if (n.style_clicked)
      try {
        const W = JSON.parse(n.style_clicked);
        for (const Y in W)
          U[Y] = W[Y];
      } catch (W) {
        throw new Error(mesErrJSON(n, "style_clicked", W.message));
      }
    else
      U.dropShadow = !1;
    t.button(n, this, () => B.style = L, () => o() ? (B.style = k, !0) : !1, () => B.style = U), $ || e();
  }
  static init(n) {
    !n.oCfg.debug.masume || (__privateSet(_Button, _procMasume4txt, (t, e) => t.addChild(
      new Graphics().beginFill(8926088, 0.2).lineStyle(1, 8926088, 1).drawRect(e.x, e.y, e.width, e.height).endFill()
    )), __privateSet(_Button, _procMasume4pic, (t, e, o, R) => t.addChild(
      new Graphics().beginFill(8926088, 0.2).lineStyle(1, 8926088, 1).drawRect(e.x, e.y, o, R).endFill()
    )));
  }
  setText(n) {
  }
  destroy(n) {
    this.evtMng.unButton(this), super.destroy();
  }
  makeDesignCast(n) {
  }
  showDesignCast() {
    __privateGet(this, _idc).visible = !0;
  }
  cvsResize() {
  }
  update_b_pic(n, t) {
    var o;
    const e = JSON.parse((o = t.name) != null ? o : "{}");
    __privateGet(this, _sp_b_pic) && this.removeChild(__privateGet(this, _sp_b_pic)), this.hArg.b_pic = e.b_pic = n, t.name = JSON.stringify(e), n && GrpLayer.csv2Sprites(
      n,
      this,
      (R) => __privateMethod(this, _loaded_b_pic, loaded_b_pic_fn).call(this, R, t),
      () => Layer.setBlendmode(this, this.hArg)
    );
  }
  update_pic(n, t) {
    var o;
    const e = JSON.parse((o = t.name) != null ? o : "{}");
    __privateGet(this, _sp_pic) && this.removeChild(__privateGet(this, _sp_pic)), this.hArg.pic = e.pic = n, t.name = JSON.stringify(e), n && GrpLayer.csv2Sprites(
      n,
      this,
      (R) => __privateMethod(this, _loaded_pic, loaded_pic_fn).call(this, R, e),
      () => Layer.setBlendmode(this, this.hArg)
    );
  }
};
let Button = _Button;
_procMasume4txt = /* @__PURE__ */ new WeakMap();
_procMasume4pic = /* @__PURE__ */ new WeakMap();
_rctBtnTxt = /* @__PURE__ */ new WeakMap();
_idc = /* @__PURE__ */ new WeakMap();
_sp_b_pic = /* @__PURE__ */ new WeakMap();
_sp_pic = /* @__PURE__ */ new WeakMap();
_loaded_b_pic = /* @__PURE__ */ new WeakSet();
loaded_b_pic_fn = function(n, t) {
  __privateSet(this, _sp_b_pic, n), this.setChildIndex(n, 0), n.alpha = t.alpha, n.setTransform(
    t.x,
    t.y,
    1,
    1,
    t.rotation,
    0,
    0,
    (n.width - t.width) / 2,
    (n.height - t.height) / 2
  ), n.name = t.name;
};
_normal = /* @__PURE__ */ new WeakMap();
_hover = /* @__PURE__ */ new WeakMap();
_clicked = /* @__PURE__ */ new WeakMap();
_loaded_pic = /* @__PURE__ */ new WeakSet();
loaded_pic_fn = function(n, t) {
  var e;
  __privateSet(this, _sp_pic, n), t.alpha = n.alpha = argChk_Num(this.hArg, "alpha", n.alpha), __privateGet(this, _idc).setSp(n);
  const o = n.width / 3, R = n.height, N = n.texture.baseTexture, M = new Texture(N, new Rectangle(0, 0, o, R)), D = new Texture(N, new Rectangle(o, 0, o, R)), L = new Texture(N, new Rectangle(o * 2, 0, o, R)), B = () => n.texture = M;
  B(), __privateSet(this, _normal, B), __privateSet(this, _hover, () => this.canFocus() ? (n.texture = L, !0) : !1), __privateSet(this, _clicked, () => n.texture = D), "width" in this.hArg ? (t.width = uint(this.hArg.width), this.scale.x *= t.width / o) : t.width = o, "height" in this.hArg ? (t.height = uint(this.hArg.height), this.scale.y *= t.height / o) : t.height = o, n.name = JSON.stringify(t), __privateGet(e = _Button, _procMasume4pic).call(e, this, n, o, R);
};
Button.fontFamily = "'Hiragino Sans', 'Hiragino Kaku Gothic ProN', '\u6E38\u30B4\u30B7\u30C3\u30AF Medium', meiryo, sans-serif";
__privateAdd(Button, _procMasume4txt, (n, t) => {
});
__privateAdd(Button, _procMasume4pic, (n, t, e, o) => {
});
var gs, br, _s, Ka, Ja, vh, Qa, gh, to, ms, eo, ti, hn, Lu, cc, Mr, er, hr, le, Er, ee, ys, ke, bs, qo, xr, cn, Es, Zo, Dr, ro, _h, io, mh, xi, fn, dn, xs, Ts, ei, rr, Fu, fc, Xe, Ss, Cs, Ko, Ti, kn, Lr, ir, nr, Fr, Is, Jo, Si, Gn, Ci;
const qt = class extends Layer {
  constructor() {
    super();
    it(this, bs);
    it(this, Es);
    it(this, ro);
    it(this, io);
    it(this, Fu);
    it(this, Cs);
    it(this, Ti);
    it(this, Is);
    it(this, Si);
    it(this, Mr, void 0);
    it(this, er, void 0);
    it(this, hr, void 0);
    it(this, le, void 0);
    it(this, Er, void 0);
    it(this, ee, void 0);
    it(this, ys, void 0);
    it(this, ke, void 0);
    it(this, xr, void 0);
    it(this, cn, void 0);
    it(this, Dr, void 0);
    it(this, xi, void 0);
    it(this, fn, void 0);
    it(this, dn, void 0);
    it(this, xs, void 0);
    it(this, ei, void 0);
    it(this, rr, void 0);
    it(this, Xe, void 0);
    it(this, Ss, void 0);
    it(this, Lr, void 0);
    it(this, ir, void 0);
    it(this, nr, void 0);
    it(this, Fr, void 0);
    it(this, Ci, void 0);
    et(this, Mr, 0), et(this, er, 0), et(this, hr, !1), et(this, le, void 0), et(this, Er, ""), et(this, ee, new TxtStage(this.spLay, () => this.canFocus(), H(qt, eo))), et(this, ys, new RubySpliter()), et(this, ke, new Container()), et(this, xr, ""), et(this, cn, !0), et(this, Dr, ""), et(this, xi, ""), et(this, fn, (o) => ""), et(this, dn, ""), et(this, xs, new RegExp("[\u3000]")), this.isCur = !1, et(this, ei, () => ""), et(this, rr, ""), et(this, Xe, !1), et(this, Ss, (o, R) => {
      var B, $, k, U, z, X, V, W, Y, q;
      H(qt, gs).oCfg.debug.putCh && console.log(`\u{1F58A} \u6587\u5B57\u8868\u793A text:\`${o}\` ruby:\`${R}\` name:\`${this.name_}\``);
      const N = R.split("\uFF5C");
      let M = "";
      const [D, L] = N;
      switch (N.length) {
        case 1:
          if (et(this, Xe, !0), o === `
`) {
            H(this, ir) ? (et(this, ir, !1), M = "<ruby>\u3000<rt>\u3000</rt></ruby><br/>") : M = "<br/>";
            break;
          }
          H(this, ir) && (et(this, ir, !1), R === "" && (R = "\u3000")), M = st(this, Cs, Ko).call(this, o, R, H(this, rr));
          break;
        case 2:
          switch (D) {
            case "start":
            case "left":
            case "center":
            case "right":
            case "justify":
            case "121":
            case "even":
            case "1ruby":
              et(this, ir, !1), et(this, Xe, !0), M = st(this, Cs, Ko).call(this, o, L, D);
              break;
            case "gotxt":
              st(this, Si, Gn).call(this), this.isCur && H(B = qt, _s).call(B, H(this, nr).join("").replace(/^<ruby><rt><\/rt><\/ruby>(<br\/>)+/, "").replace(/style='(anim\S+ \S+?;\s*)+/g, "style='").replace(/( style=''| data-(add|arg|cmd)='.+?'|\n+|\t+)/g, "").replace(/class='sn_ch .+?'/g, "class='sn_ch'").replaceAll("class='offrec'", "style='display: none;'").replaceAll("`", "\\`")), H(this, Xe) && (H(this, ee).goTxt(H(this, nr)), et(this, Xe, !1), et(this, Lr, 0));
              return;
            case "add":
              {
                const Z = JSON.parse(L), { cl: J, sty: Q } = st(this, Ti, kn).call(this, !0, Z.wait);
                H(this, nr).push(`<span${J} style='display: inline;${(k = ($ = H(this, Fr).at(-1)) == null ? void 0 : $.o.style) != null ? k : ""}${(U = Z.style) != null ? U : ""}${Q}'>`), delete Z.style, st(this, Is, Jo).call(this, Z);
              }
              return;
            case "add_close":
              H(this, nr).push("</span>"), st(this, Si, Gn).call(this);
              return;
            case "grp":
              et(this, Xe, !0);
              {
                const Z = JSON.parse(L);
                if (Z.delay = H(this, Lr), (z = Z.id) != null || (Z.id = H(this, nr).length), Z.id === "break") {
                  H(this, ee).dispBreak(Z.pic);
                  return;
                }
                (X = Z.style) != null || (Z.style = "");
                const { cl: J, sty: Q, lnk: K } = st(this, Ti, kn).call(this, !0, Z.wait);
                M = `<span data-cmd='grp' data-id='${Z.id}'${J} style='${Q} ${(V = Z.style) != null ? V : ""}'${K} data-arg='${JSON.stringify(Z)}' data-add='{"ch_in_style":"${H(this, xr)}", "ch_out_style":"${H(this, Dr)}"}'>\u3000</span>`, H(this, ir) && (et(this, ir, !1), M = `<ruby>${M}<rt>\u3000</rt></ruby>`);
              }
              break;
            case "tcy":
              et(this, ir, !1), et(this, Xe, !0);
              {
                H(qt, br).doRecLog() && et(this, Ci, H(this, Ci) + (o + (R ? `\u300A${R}\u300B` : "")));
                const Z = JSON.parse(L), { t: J, r: Q = "" } = Z, K = CmnLib.isSafari ? Q.replace(/[A-Za-z0-9]/g, (lt) => String.fromCharCode(lt.charCodeAt(0) + 65248)) : Q, rt = this.mkStyle_r_align(J, K, H(this, rr)), { cl: tt, sty: nt, lnk: at } = st(this, Ti, kn).call(this, !0, Z.wait);
                M = `<span${tt} style='${nt}${H(this, fn).call(this, J)} ${(W = Z.style) != null ? W : ""}'${at}><ruby><span style='
text-combine-upright: all;
-webkit-text-combine: horizontal;
				' data-add='{"ch_in_style":"${H(this, xr)}", "ch_out_style":"${H(this, Dr)}"}'>${J}</span>
				<rt${rt}>${K}</rt></ruby></span>`;
              }
              break;
            case "del":
              TxtStage.delBreak();
              return;
            case "span":
              st(this, Si, Gn).call(this), et(this, Xe, !0);
              {
                const Z = JSON.parse(L);
                Z.style && st(this, Is, Jo).call(this, Z);
              }
              return;
            case "link":
              st(this, Si, Gn).call(this), et(this, Xe, !0);
              {
                const Z = JSON.parse(L);
                Z[":link"] = " data-lnk='@'";
                const { cl: J, sty: Q } = st(this, Ti, kn).call(this, !1, Z.wait);
                H(this, nr).push(`<span data-arg='${L}'${J} style='display: inline; ${Q} ${(Y = Z.style) != null ? Y : ""}' data-add='{"ch_in_style":"${H(this, xr)}", "ch_out_style":"${H(this, Dr)}"}'}>`), delete Z.style, st(this, Is, Jo).call(this, Z);
              }
              return;
            case "endlink":
              et(this, Xe, !0), H(this, nr).push("</span>"), st(this, Si, Gn).call(this);
              return;
            default:
              et(this, Xe, !0), M = st(this, Cs, Ko).call(this, o, R, H(this, rr));
          }
          break;
      }
      H(this, nr).push(H(q = qt, Ts).call(q, M));
    }), et(this, Lr, 0), et(this, ir, !0), et(this, nr, []), et(this, Fr, []), this.click = () => !this.spLay.interactiveChildren || !this.spLay.visible ? !0 : H(this, ee).skipChIn(), et(this, Ci, ""), this.addButton = (o) => new Promise((R) => {
      o.key = `btn=[${H(this, ke).children.length}] ` + this.name_, o[":id_tag"] = o.key.slice(0, -7), argChk_Boolean(o, "hint_tate", H(this, ee).tategaki);
      const N = new Button(o, H(qt, ms), () => R(), () => this.canFocus());
      N.name = JSON.stringify(o).replaceAll('"', "'"), H(this, ke).addChild(N);
    }), this.record = () => ({
      ...super.record(),
      enabled: this.enabled,
      r_align: H(this, rr),
      b_do: H(this, le) === void 0 ? void 0 : H(this, le) instanceof Sprite ? "Sprite" : "Graphics",
      b_pic: H(this, Er),
      b_color: H(this, Mr),
      b_alpha: H(this, er),
      b_alpha_isfixed: H(this, hr),
      ffs: H(this, xi),
      txs: H(this, ee).record(),
      strNoFFS: H(this, dn),
      btns: H(this, ke).children.map((o) => o.name)
    }), this.spLay.addChild(H(this, ee)), H(this, ys).init(H(this, Ss)), this.spLay.addChild(H(this, ke)), H(this, ke).name = "cntBtn";
    const e = 16;
    this.lay({ style: `width: ${CmnLib.stageW}px; height: ${CmnLib.stageH}px; font-family: 'Hiragino Sans', 'Hiragino Kaku Gothic ProN', '\u6E38\u30B4\u30B7\u30C3\u30AF Medium', meiryo, sans-serif; color: white; font-size: 24px; line-height: 1.5; padding: ${e}px;`, in_style: "default", out_style: "default", back_clear: "true" });
  }
  static init(e, o, R, N, M, D) {
    var B, $;
    et(qt, gs, e), TxtStage.init(e, D), et(qt, br, R), et(qt, _s, N), et(qt, Ka, M), R.setDoRecProc(qt.chgDoRec), o.autowc = (k) => {
      var U;
      return st(U = qt, Lu, cc).call(U, k);
    }, o.autowc({ enabled: !1, text: "", time: 0 }), o.ch_in_style = (k) => {
      var U;
      return st(U = qt, Ja, vh).call(U, k);
    }, o.ch_out_style = (k) => {
      var U;
      return st(U = qt, Qa, gh).call(U, k);
    }, TxtStage.initChStyle(), initStyle();
    let L = "";
    e.matchPath(".+", Config.EXT_FONT).forEach((k) => {
      for (const U in k)
        L += `
@font-face {
	font-family: '${k[U]}';
	src: url('${H(this, gs).searchPath(k[U], Config.EXT_FONT)}');
}
`;
    }), L += `
.sn_tx {
	pointer-events: none;
	user-select: none;
	-webkit-touch-callout: none;
	box-sizing: border-box;
}
.sn_ch {
	position: relative;
	display: inline-block;
}
`, addStyle(L), st(B = qt, Ja, vh).call(B, {
      name: "default",
      wait: 500,
      alpha: 0,
      x: "=0.3",
      y: "=0",
      scale_x: 1,
      scale_y: 1,
      rotate: 0,
      join: !0,
      ease: "ease-out"
    }), st($ = qt, Qa, gh).call($, {
      name: "default",
      wait: 0,
      alpha: 0,
      x: "=0",
      y: "=0",
      scale_x: 1,
      scale_y: 1,
      rotate: 0,
      join: !1,
      ease: "ease-out"
    });
  }
  static setEvtMng(e, o, R) {
    et(qt, to, e), et(qt, ms, o), et(qt, eo, R), TxtStage.setEvtMng(o);
  }
  destroy() {
    H(this, le) && (this.spLay.removeChild(H(this, le)).destroy(), et(this, le, void 0)), this.clearText(), H(this, ee).destroy();
  }
  static destroy() {
    et(qt, ti, !1), et(qt, hn, {}), et(qt, Ts, (e) => e);
  }
  set name(e) {
    this.name_ = e, H(this, ee).name = e;
  }
  get name() {
    return this.name_;
  }
  cvsResize() {
    H(this, ee).cvsResize();
  }
  cvsResizeChildren() {
    H(this, ke).children.forEach((e) => e.cvsResize());
  }
  lay(e) {
    var o;
    return super.lay(e), Layer.setXY(this.spLay, e, this.spLay), e[":id_tag"] = this.name_.slice(0, -7), RubySpliter.setting(e), st(this, io, mh).call(this, e), H(this, ee).lay(e), "r_align" in e && et(this, rr, (o = e.r_align) != null ? o : ""), et(this, ei, CmnLib.isSafari ? H(this, ee).tategaki ? (R, N) => `text-align: start; height: ${N}em; padding-top: ${R}; padding-bottom: ${R};` : (R, N) => `text-align: start; width: ${N}em; padding-left: ${R}; padding-right: ${R};` : H(this, ee).tategaki ? (R) => `text-align: justify; text-align-last: justify; padding-top: ${R}; padding-bottom: ${R};` : (R) => `text-align: justify; text-align-last: justify; padding-left: ${R}; padding-right: ${R};`), CmnLib.isFirefox && (this.mkStyle_r_align = st(this, Fu, fc)), "alpha" in e && H(this, ke).children.forEach((R) => R.alpha = this.spLay.alpha), st(this, bs, qo).call(this, e), st(this, Es, Zo).call(this, e), st(this, ro, _h).call(this, e, (R) => {
      R && H(qt, to).resume();
    });
  }
  get width() {
    return H(this, ee).getWidth;
  }
  get height() {
    return H(this, ee).getHeight;
  }
  chgBackAlpha(e) {
    const o = H(this, hr) ? H(this, er) : e * H(this, er);
    H(this, le) instanceof Graphics && (H(this, le) && (this.spLay.removeChild(H(this, le)), H(this, le).destroy()), this.spLay.addChildAt(
      et(this, le, new Graphics()).beginFill(H(this, Mr)).lineStyle(void 0).drawRect(0, 0, H(this, ee).getWidth, H(this, ee).getHeight).endFill(),
      0
    ), H(this, le).name = "back(color)"), H(this, le) && (H(this, le).visible = o > 0, H(this, le).alpha = o);
  }
  static chgDoRec(e) {
    et(qt, Ts, e ? (o) => o : (o) => `<span class='offrec'>${o}</span>`);
  }
  mkStyle_r_align(e, o, R) {
    if (!R)
      return "";
    const N = e.length * 2;
    if (N - o.length < 0)
      return ` style='text-align: ${R};'`;
    let M = "";
    switch (R) {
      case "justify":
        M = H(this, ei).call(this, "0", N);
        break;
      case "121":
        M = H(this, ei).call(this, `calc(${(N - o.length) / (o.length * 2)}em)`, N);
        break;
      case "even":
        M = H(this, ei).call(this, `calc(${(N - o.length) / (o.length + 1)}em)`, N);
        break;
      case "1ruby":
        M = H(this, ei).call(this, "1em", N);
        break;
      default:
        M = `text-align: ${R};`;
    }
    return ` style='${M}'`;
  }
  tagCh(e) {
    H(this, ys).putTxt(e);
  }
  clearText() {
    var e;
    this.spLay.addChild(et(this, ee, H(this, ee).reNew())), et(this, Lr, 0), et(this, ir, !0), et(this, nr, []), et(this, Ci, ""), H(e = qt, _s).call(e, "", !0);
  }
  get pageText() {
    return H(this, Ci).replace("\u300A\u3000\u300B", "");
  }
  get enabled() {
    return this.spLay.interactiveChildren;
  }
  set enabled(e) {
    this.spLay.interactiveChildren = e;
  }
  canFocus() {
    var e, o;
    return ((e = this.spLay.interactiveChildren) != null ? e : !1) && this.spLay.visible && H(o = qt, Ka).call(o, this);
  }
  clearLay(e) {
    super.clearLay(e), this.clearText(), H(this, ke).removeChildren().forEach((o) => o.destroy());
  }
  playback(e, o) {
    super.playback(e, o), this.enabled = e.enabled, et(this, rr, e.r_align), this.cvsResize(), st(this, io, mh).call(this, e), H(this, ee).playback(e.txs), et(this, er, e.b_alpha), et(this, hr, e.b_alpha_isfixed), o.push(new Promise((N) => {
      const M = e.b_do ? e.b_do === "Sprite" ? { b_pic: e.b_pic } : { b_color: e.b_color } : { b_pic: "" };
      M.b_alpha = e.b_alpha, M.b_alpha_isfixed = e.b_alpha_isfixed, st(this, ro, _h).call(this, M, (D) => {
        D && N();
      }) || N();
    }));
    const R = e.btns;
    o = o.concat(R.map((N) => this.addButton(JSON.parse(N.replaceAll("'", '"')))));
  }
  snapshot(e, o) {
    e.render(this.spLay, { clear: !1 }), H(this, ee).snapshot(e, o);
  }
  snapshot_end() {
    H(this, ee).snapshot_end();
  }
  makeDesignCast(e) {
    !this.spLay.visible || H(this, ee).makeDesignCast(e);
  }
  makeDesignCastChildren(e) {
    !this.spLay.visible || H(this, ke).children.forEach((o) => o.makeDesignCast(e));
  }
  showDesignCast() {
    H(this, ee).showDesignCast();
  }
  showDesignCastChildren() {
    H(this, ke).children.forEach((e) => e.showDesignCast());
  }
  dump() {
    return H(this, Ss).call(this, "", "gotxt\uFF5C"), super.dump() + `, "enabled":"${this.enabled}", ${H(this, ee).dump()}, "b_pic":"${H(this, Er)}", "b_color":"${H(this, Mr)}", "b_alpha":${H(this, er)}, "b_alpha_isfixed":"${H(this, hr)}", "width":${H(this, ee).getWidth}, "height":${H(this, ee).getHeight}, "pixi_obj":[${this.spLay.children.map((e) => `{"class":"${e instanceof Sprite ? "Sprite" : e instanceof Graphics ? "Graphics" : e instanceof Container ? "Container" : "?"}", "name":"${e.name}", "alpha":${e.alpha}, "x":${e.x}, "y":${e.y}, "visible":"${e.visible}"}`).join(",")}], "button":[${H(this, ke).children.map((e) => {
      var o;
      return (o = e.children[0].name) != null ? o : "{}";
    }).join(",")}]`;
  }
};
let TxtLayer = qt;
gs = new WeakMap(), br = new WeakMap(), _s = new WeakMap(), Ka = new WeakMap(), Ja = new WeakSet(), vh = function(e) {
  const o = TxtStage.ch_in_style(e), R = o.x.charAt(0) === "=" ? `${o.nx * 100}%` : `${o.nx}px`, N = o.y.charAt(0) === "=" ? `${o.ny * 100}%` : `${o.ny}px`, { name: M } = e;
  return addStyle(`
.sn_ch_in_${M} {
	position: relative;
	display: inline-block;
}
.go_ch_in_${M} {
	opacity: ${o.alpha};
	position: relative;
	display: inline-block;
	animation: sn_ch_in_${M} ${o.wait}ms ${o.ease} 0s both;
}
@keyframes sn_ch_in_${M} {
	from {transform: rotate(${o.rotate}deg) scale(${o.scale_x}, ${o.scale_y}) translate(${R}, ${N});}
	to {opacity: 1; transform: none;}
}
`), !1;
}, Qa = new WeakSet(), gh = function(e) {
  const o = TxtStage.ch_out_style(e), R = o.x.charAt(0) === "=" ? `${o.nx * 100}%` : `${o.nx}px`, N = o.y.charAt(0) === "=" ? `${o.ny * 100}%` : `${o.ny}px`, { name: M } = e;
  return addStyle(`
.go_ch_out_${M} {
	position: relative;
	display: inline-block;
	animation: go_ch_out_${M} ${o.wait}ms ${o.ease} 0s both;
}
@keyframes go_ch_out_${M} {
	to {
		opacity: ${o.alpha};
		transform: rotate(${o.rotate}deg) scale(${o.scale_x}, ${o.scale_y}) translate(${R}, ${N});
	}
`), !1;
}, to = new WeakMap(), ms = new WeakMap(), eo = new WeakMap(), ti = new WeakMap(), hn = new WeakMap(), Lu = new WeakSet(), cc = function(e) {
  et(qt, ti, argChk_Boolean(e, "enabled", H(qt, ti))), H(qt, br).setVal_Nochk("save", "const.sn.autowc.enabled", H(qt, ti));
  const { text: o } = e;
  if ("text" in e != "time" in e)
    throw "[autowc] text\u3068time\u306F\u540C\u6642\u6307\u5B9A\u5FC5\u9808\u3067\u3059";
  if (H(qt, br).setVal_Nochk("save", "const.sn.autowc.text", o), !o)
    return H(qt, br).setVal_Nochk("save", "const.sn.autowc.time", ""), !1;
  const R = o.length;
  if (H(qt, ti) && R === 0)
    throw '[autowc] enabled === false \u304B\u3064 text === "" \u306F\u8A31\u3055\u308C\u307E\u305B\u3093';
  const N = String(e.time).split(",");
  if (N.length !== R)
    throw "[autowc] text\u6587\u5B57\u6570\u3068time\u306B\u8A18\u8FF0\u3055\u308C\u305F\u5F85\u3061\u6642\u9593\uFF08\u30B3\u30F3\u30DE\u533A\u5207\u308A\uFF09\u306F\u540C\u6570\u306B\u3057\u3066\u4E0B\u3055\u3044";
  return et(qt, hn, {}), N.forEach((M, D) => H(qt, hn)[o[D]] = uint(M)), H(qt, br).setVal_Nochk("save", "const.sn.autowc.time", e.time), !1;
}, Mr = new WeakMap(), er = new WeakMap(), hr = new WeakMap(), le = new WeakMap(), Er = new WeakMap(), ee = new WeakMap(), ys = new WeakMap(), ke = new WeakMap(), bs = new WeakSet(), qo = function(e) {
  const { in_style: o } = e;
  if (!o)
    return;
  const R = TxtStage.getChInStyle(o);
  if (!R)
    throw `\u5B58\u5728\u3057\u306A\u3044in_style\u3010${o}\u3011\u3067\u3059`;
  et(this, xr, o), et(this, cn, R.join);
}, xr = new WeakMap(), cn = new WeakMap(), Es = new WeakSet(), Zo = function(e) {
  const { out_style: o } = e;
  if (!o)
    return;
  if (!TxtStage.getChOutStyle(o))
    throw `\u5B58\u5728\u3057\u306A\u3044out_style\u3010${o}\u3011\u3067\u3059`;
  et(this, Dr, o);
}, Dr = new WeakMap(), ro = new WeakSet(), _h = function(e, o) {
  if ("back_clear" in e)
    return argChk_Boolean(e, "back_clear", !1) && (et(this, Mr, 0), et(this, er, 0), et(this, hr, !1), et(this, Er, "")), o(!1), !1;
  et(this, er, argChk_Num(e, "b_alpha", H(this, er))), et(this, hr, argChk_Boolean(e, "b_alpha_isfixed", H(this, hr)));
  const R = (H(this, hr) ? 1 : Number(H(qt, br).getVal("sys:TextLayer.Back.Alpha"))) * H(this, er);
  if (e.b_pic) {
    if (H(this, Er) !== e.b_pic)
      return et(this, Er, e.b_pic), H(this, le) && (this.spLay.removeChild(H(this, le)), H(this, le).destroy()), GrpLayer.csv2Sprites(H(this, Er), this.spLay, (N) => {
        et(this, le, N), N.name = "back(pic)", N.visible = R > 0, N.alpha = R, H(this, ee).setSize(N.width, N.height), this.spLay.setChildIndex(N, 0), o(!0);
      });
  } else
    "b_color" in e && (et(this, Mr, argChk_Color(e, "b_color", 0)), H(this, le) && (this.spLay.removeChild(H(this, le)), H(this, le).destroy()), et(this, Er, ""), this.spLay.addChildAt(
      et(this, le, new Graphics()).beginFill(H(this, Mr)).lineStyle(void 0).drawRect(0, 0, H(this, ee).getWidth, H(this, ee).getHeight).endFill(),
      0
    ), H(this, le).name = "back(color)");
  return H(this, le) && (H(this, le).visible = R > 0, H(this, le).alpha = R), o(!1), !1;
}, io = new WeakSet(), mh = function(e) {
  var o, R;
  "noffs" in e && (et(this, dn, (o = e.noffs) != null ? o : ""), et(this, xs, new RegExp(`[\u3000${H(this, dn)}]`))), "ffs" in e && ((R = H(this, xi)) != null || et(this, xi, ""), et(this, fn, H(this, xi) === "" ? () => "" : (N) => H(this, xs).test(N) ? "" : ` font-feature-settings: ${H(this, xi)};`));
}, xi = new WeakMap(), fn = new WeakMap(), dn = new WeakMap(), xs = new WeakMap(), Ts = new WeakMap(), ei = new WeakMap(), rr = new WeakMap(), Fu = new WeakSet(), fc = function(e, o, R) {
  if (!R)
    return "";
  const N = e.length * 2;
  if (N - o.length < 0)
    return ` style='text-align: ${R};'`;
  let M = "";
  switch (R) {
    case "left":
      M = "ruby-align: start;";
      break;
    case "center":
      M = "ruby-align: center;";
      break;
    case "right":
      M = "ruby-align: start;";
      break;
    case "justify":
      M = "ruby-align: space-between;";
      break;
    case "121":
      M = "ruby-align: space-around;";
      break;
    case "even":
      const D = (N - o.length) / (o.length + 1);
      M = "ruby-align: space-between; " + (H(this, ee).tategaki ? `padding-top: ${D}em; padding-bottom: ${D}em;` : `padding-left: ${D}em; padding-right: ${D}em;`);
      break;
    case "1ruby":
      M = "ruby-align: space-between; " + (H(this, ee).tategaki ? "padding-top: 1em; padding-bottom: 1em;" : "padding-left: 1em; padding-right: 1em;");
      break;
    default:
      M = `text-align: ${R};`;
  }
  return ` style='${M}'`;
}, Xe = new WeakMap(), Ss = new WeakMap(), Cs = new WeakSet(), Ko = function(e, o, R) {
  e === " " && (e = "&nbsp;"), H(qt, br).doRecLog() && et(this, Ci, H(this, Ci) + (e + (o ? `\u300A${o}\u300B` : "")));
  const { cl: N, sty: M, lnk: D } = st(this, Ti, kn).call(this, !0, null, e), L = `${D} data-add='{"ch_in_style":"${H(this, xr)}", "ch_out_style":"${H(this, Dr)}"}'`;
  return `<span${N} style='${M}${H(this, fn).call(this, e)}'${o ? "" : L}>${o ? `<ruby${L}>${e}<rt${this.mkStyle_r_align(e, o, R)}>${o}</rt></ruby>` : e}</span>`;
}, Ti = new WeakSet(), kn = function(e, o, R = `
`) {
  var D, L, B, $, k, U, z, X;
  const N = (D = H(this, Fr).at(0)) == null ? void 0 : D.o.wait, M = H(this, cn) ? ((L = o != null ? o : N) != null ? L : H(qt, ti)) ? (B = H(qt, hn)[R.charAt(0)]) != null ? B : 0 : LayerMng.msecChWait : 0;
  return H(qt, ms).isSkippingByKeyDown() ? et(this, Lr, 0) : e && H(this, cn) && et(this, Lr, H(this, Lr) + M), {
    cl: ` class='sn_ch${M > 0 ? ` sn_ch_in_${H(this, xr)}` : ""}'`,
    sty: `animation-delay: ${H(this, Lr)}ms;${(U = (k = ($ = H(this, Fr).at(-1)) == null ? void 0 : $.o) == null ? void 0 : k.style) != null ? U : ""}`,
    lnk: (X = (z = H(this, Fr).at(0)) == null ? void 0 : z.o[":link"]) != null ? X : ""
  };
}, Lr = new WeakMap(), ir = new WeakMap(), nr = new WeakMap(), Fr = new WeakMap(), Is = new WeakSet(), Jo = function(e) {
  H(this, Fr).push({
    o: e,
    r_align: H(this, rr),
    ch_in_style: H(this, xr),
    ch_out_style: H(this, Dr)
  }), "r_align" in e && et(this, rr, e.r_align), st(this, bs, qo).call(this, e), st(this, Es, Zo).call(this, e);
}, Si = new WeakSet(), Gn = function() {
  const e = H(this, Fr).pop();
  !e || (et(this, rr, e.r_align), st(this, bs, qo).call(this, { in_style: e.ch_in_style }), st(this, Es, Zo).call(this, { out_style: e.ch_out_style }));
}, Ci = new WeakMap(), it(TxtLayer, Ja), it(TxtLayer, Qa), it(TxtLayer, Lu), it(TxtLayer, gs, void 0), it(TxtLayer, br, void 0), it(TxtLayer, _s, void 0), it(TxtLayer, Ka, void 0), it(TxtLayer, to, void 0), it(TxtLayer, ms, void 0), it(TxtLayer, eo, void 0), it(TxtLayer, ti, !1), it(TxtLayer, hn, {}), it(TxtLayer, Ts, (e) => e);
var ws, ri, Bu, dc, Rs, Ps, Qo, $u, pc, ku, vc, no, Gu, gc, Uu, mc;
class FrameMng {
  constructor(t, e, o, R, N, M, D) {
    it(this, Bu);
    it(this, Ps);
    it(this, $u);
    it(this, ku);
    it(this, Gu);
    it(this, Uu);
    it(this, ws, void 0);
    it(this, ri, /* @__PURE__ */ Object.create(null));
    it(this, Rs, {});
    it(this, no, 1);
    this.cfg = t, this.appPixi = o, this.val = R, this.main = N, this.sys = M, this.hTwInf = D, e.add_frame = (L) => st(this, Bu, dc).call(this, L), e.let_frame = (L) => st(this, $u, pc).call(this, L), e.set_frame = (L) => st(this, ku, vc).call(this, L), e.frame = (L) => st(this, Gu, gc).call(this, L), e.tsy_frame = (L) => st(this, Uu, mc).call(this, L);
  }
  setEvtMng(t) {
    et(this, ws, t);
  }
  destroy() {
    for (const t in H(this, ri)) {
      const e = H(this, ri)[t];
      e.parentElement.removeChild(e);
    }
    et(this, ri, /* @__PURE__ */ Object.create(null));
  }
  getFrmDisabled(t) {
    return H(this, Rs)[t];
  }
  cvsResize() {
    for (const t in H(this, ri)) {
      const e = H(this, ri)[t], o = "const.sn.frm." + t, R = Number(this.val.getVal(o + ".x")), N = Number(this.val.getVal(o + ".y")), M = Number(this.val.getVal(o + ".width")), D = Number(this.val.getVal(o + ".height"));
      e.style.left = `${this.sys.ofsLeft4elm + R * this.sys.cvsScale}px`, e.style.top = `${this.sys.ofsTop4elm + N * this.sys.cvsScale}px`, e.width = String(M * this.sys.cvsScale), e.height = String(D * this.sys.cvsScale);
    }
  }
}
ws = new WeakMap(), ri = new WeakMap(), Bu = new WeakSet(), dc = function(t) {
  const { id: e, src: o, alpha: R = 1, scale_x: N = 1, scale_y: M = 1, rotate: D = 0 } = t;
  if (!e)
    throw "id\u306F\u5FC5\u9808\u3067\u3059";
  if (!o)
    throw "src\u306F\u5FC5\u9808\u3067\u3059";
  const L = "const.sn.frm." + e;
  if (this.val.getVal(`tmp:${L}`))
    throw `frame\u3010${e}\u3011\u306F\u3059\u3067\u306B\u3042\u308A\u307E\u3059`;
  const B = argChk_Boolean(t, "visible", !0), $ = t.b_color ? ` background-color: ${t.b_color};` : "", k = st(this, Ps, Qo).call(this, t);
  this.appPixi.view.insertAdjacentHTML("beforebegin", `<iframe id="${e}" sandbox="allow-scripts allow-same-origin" style="opacity: ${R}; position: absolute; left:${this.sys.ofsLeft4elm + k.x * this.sys.cvsScale}px; top: ${this.sys.ofsTop4elm + k.y * this.sys.cvsScale}px; z-index: 1; ${$} border: 0px; overflow: hidden; display: ${B ? "inline" : "none"}; transform: scale(${N}, ${M}) rotate(${D}deg);" width="${k.width * this.sys.cvsScale}" height="${k.height * this.sys.cvsScale}"></iframe>`);
  const U = this.cfg.searchPath(o, Config.EXT_HTML), z = new Loader().add({ name: o, url: U, xhrType: LoaderResource.XHR_RESPONSE_TYPE.TEXT });
  return this.sys.crypto && z.use((X, V) => {
    try {
      X.data = this.sys.decStr(X.extension, X.data);
    } catch (W) {
      this.main.errScript(`[add_frame]Html \u30ED\u30FC\u30C9\u5931\u6557\u3067\u3059 src:${X.name} ${W}`, !1);
    }
    V == null || V();
  }), z.load((X, V) => {
    var Y;
    const W = document.getElementById(e);
    H(this, ri)[e] = W, H(this, Rs)[e] = !1, W.srcdoc = String((Y = V[o]) == null ? void 0 : Y.data).replace("sn_repRes();", "").replace(
      /\s(?:src|href)=(["'])(\S+)\1/g,
      (q, Z, J) => J.slice(0, 3) === "../" ? this.sys.cur + J.slice(4) : q.replace(Z, Z + U.slice(0, U.lastIndexOf("/") + 1))
    ), W.onload = () => {
      var Z;
      this.val.setVal_Nochk("tmp", L, !0), this.val.setVal_Nochk("tmp", L + ".alpha", R), this.val.setVal_Nochk("tmp", L + ".x", k.x), this.val.setVal_Nochk("tmp", L + ".y", k.y), this.val.setVal_Nochk("tmp", L + ".scale_x", N), this.val.setVal_Nochk("tmp", L + ".scale_y", M), this.val.setVal_Nochk("tmp", L + ".rotate", D), this.val.setVal_Nochk("tmp", L + ".width", k.width), this.val.setVal_Nochk("tmp", L + ".height", k.height), this.val.setVal_Nochk("tmp", L + ".visible", B);
      const q = W.contentWindow;
      H(this, ws).resvFlameEvent(q), (Z = q.sn_repRes) == null || Z.call(q, (J) => {
        var Q;
        return GrpLayer.loadPic2Img((Q = J.dataset.src) != null ? Q : "", J);
      }), this.main.resume();
    };
  }), !0;
}, Rs = new WeakMap(), Ps = new WeakSet(), Qo = function(t) {
  const e = { ...t }, o = this.sys.resolution;
  return new DOMRect(
    argChk_Num(e, "x", 0) * o,
    argChk_Num(e, "y", 0) * o,
    argChk_Num(e, "width", CmnLib.stageW) * o,
    argChk_Num(e, "height", CmnLib.stageH) * o
  );
}, $u = new WeakSet(), pc = function(t) {
  const { id: e, var_name: o } = t;
  if (!e)
    throw "id\u306F\u5FC5\u9808\u3067\u3059";
  const R = document.getElementById(e);
  if (!R)
    throw `id\u3010${e}\u3011\u306F\u30D5\u30EC\u30FC\u30E0\u3067\u306F\u3042\u308A\u307E\u305B\u3093`;
  const N = "const.sn.frm." + e;
  if (!this.val.getVal(`tmp:${N}`))
    throw `frame\u3010${e}\u3011\u304C\u8AAD\u307F\u8FBC\u307E\u308C\u3066\u3044\u307E\u305B\u3093`;
  if (!o)
    throw "var_name\u306F\u5FC5\u9808\u3067\u3059";
  const M = R.contentWindow;
  if (!M.hasOwnProperty(o))
    throw `frame\u3010${e}\u3011\u306B\u5909\u6570/\u95A2\u6570\u3010${o}\u3011\u304C\u3042\u308A\u307E\u305B\u3093\u3002\u5909\u6570\u306F var\u4ED8\u304D\u306B\u3057\u3066\u4E0B\u3055\u3044`;
  const D = M[o];
  return this.val.setVal_Nochk(
    "tmp",
    N + "." + o,
    argChk_Boolean(t, "function", !1) ? D() : D
  ), !1;
}, ku = new WeakSet(), vc = function(t) {
  const { id: e, var_name: o, text: R } = t;
  if (!e)
    throw "id\u306F\u5FC5\u9808\u3067\u3059";
  const N = document.getElementById(e);
  if (!N)
    throw `id\u3010${e}\u3011\u306F\u30D5\u30EC\u30FC\u30E0\u3067\u306F\u3042\u308A\u307E\u305B\u3093`;
  const M = "const.sn.frm." + e;
  if (!this.val.getVal(`tmp:${M}`))
    throw `frame\u3010${e}\u3011\u304C\u8AAD\u307F\u8FBC\u307E\u308C\u3066\u3044\u307E\u305B\u3093`;
  if (!o)
    throw "var_name\u306F\u5FC5\u9808\u3067\u3059";
  if (!R)
    throw "text\u306F\u5FC5\u9808\u3067\u3059";
  this.val.setVal_Nochk("tmp", M + "." + o, R);
  const D = N.contentWindow;
  return D[o] = R, !1;
}, no = new WeakMap(), Gu = new WeakSet(), gc = function(t) {
  const { id: e } = t;
  if (!e)
    throw "id\u306F\u5FC5\u9808\u3067\u3059";
  const o = document.getElementById(e);
  if (!o)
    throw `id\u3010${e}\u3011\u306F\u30D5\u30EC\u30FC\u30E0\u3067\u306F\u3042\u308A\u307E\u305B\u3093`;
  const R = "const.sn.frm." + e;
  if (!this.val.getVal("tmp:" + R))
    throw `frame\u3010${e}\u3011\u304C\u8AAD\u307F\u8FBC\u307E\u308C\u3066\u3044\u307E\u305B\u3093`;
  const N = o.style;
  if (argChk_Boolean(t, "float", !1) ? N.zIndex = `${++Re(this, no)._}` : "index" in t ? N.zIndex = `${argChk_Num(t, "index", 0)}` : t.dive && (N.zIndex = `-${++Re(this, no)._}`), "alpha" in t) {
    const D = N.opacity = String(t.alpha);
    this.val.setVal_Nochk("tmp", R + ".alpha", D);
  }
  const M = st(this, Ps, Qo).call(this, t);
  if (("x" in t || "y" in t) && (N.left = `${this.sys.ofsLeft4elm + M.x * this.sys.cvsScale}px`, N.top = `${this.sys.ofsTop4elm + M.y * this.sys.cvsScale}px`, this.val.setVal_Nochk("tmp", R + ".x", M.x), this.val.setVal_Nochk("tmp", R + ".y", M.y)), "scale_x" in t || "scale_y" in t || "rotate" in t) {
    const D = argChk_Num(t, "scale_x", 1), L = argChk_Num(t, "scale_y", 1), B = argChk_Num(t, "rotate", 0);
    N.transform = `scale(${D}, ${L}) rotate(${B}deg)`, this.val.setVal_Nochk("tmp", R + ".scale_x", D), this.val.setVal_Nochk("tmp", R + ".scale_y", L), this.val.setVal_Nochk("tmp", R + ".rotate", B);
  }
  if ("width" in t && (o.width = String(M.width * this.sys.cvsScale), this.val.setVal_Nochk("tmp", R + ".width", M.width)), "height" in t && (o.height = String(M.height * this.sys.cvsScale), this.val.setVal_Nochk("tmp", R + ".height", M.height)), "visible" in t) {
    const D = argChk_Boolean(t, "visible", !0);
    N.display = D ? "inline" : "none", this.val.setVal_Nochk("tmp", R + ".visible", D);
  }
  if ("b_color" in t && (N.backgroundColor = t.b_color), "disabled" in t) {
    const D = H(this, Rs)[e] = argChk_Boolean(t, "disabled", !0);
    o.contentDocument.body.querySelectorAll("input,select").forEach((B) => B.disabled = D);
  }
  return !1;
}, Uu = new WeakSet(), mc = function(t) {
  var W;
  const { id: e } = t;
  if (!e)
    throw "id\u306F\u5FC5\u9808\u3067\u3059";
  const o = document.getElementById(e);
  if (!o)
    throw `id\u3010${e}\u3011\u306F\u30D5\u30EC\u30FC\u30E0\u3067\u306F\u3042\u308A\u307E\u305B\u3093`;
  const R = "const.sn.frm." + e;
  if (!this.val.getVal(`tmp:${R}`, 0))
    throw `frame\u3010${e}\u3011\u304C\u8AAD\u307F\u8FBC\u307E\u308C\u3066\u3044\u307E\u305B\u3093`;
  const N = {};
  "alpha" in t && (N.a = o.style.opacity), ("x" in t || "y" in t || "scale_x" in t || "scale_y" in t || "rotate" in t) && (N.x = Number(this.val.getVal(`tmp:${R}.x`)), N.y = Number(this.val.getVal(`tmp:${R}.y`)), N.sx = Number(this.val.getVal(`tmp:${R}.scale_x`)), N.sy = Number(this.val.getVal(`tmp:${R}.scale_y`)), N.r = Number(this.val.getVal(`tmp:${R}.rotate`))), "width" in t && (N.w = this.val.getVal(`tmp:${R}.width`)), "height" in t && (N.h = this.val.getVal(`tmp:${R}.height`));
  const M = cnvTweenArg(t, N), D = {}, L = argChk_Num(t, "repeat", 1);
  let B = () => {
  };
  "alpha" in t && (D.a = argChk_Num(M, "alpha", 0), B = () => {
    o.style.opacity = N.a, this.val.setVal_Nochk("tmp", "alpha", N.a);
  });
  let $ = () => {
  };
  const k = st(this, Ps, Qo).call(this, M);
  ("x" in t || "y" in t || "scale_x" in t || "scale_y" in t || "rotate" in t) && (D.x = k.x, D.y = k.y, D.sx = argChk_Num(M, "scale_x", 1), D.sy = argChk_Num(M, "scale_y", 1), D.r = argChk_Num(M, "rotate", 0), $ = () => {
    o.style.left = this.sys.ofsLeft4elm + N.x * this.sys.cvsScale + "px", o.style.top = this.sys.ofsTop4elm + N.y * this.sys.cvsScale + "px", o.style.transform = `scale(${N.sx}, ${N.sy}) rotate(${N.r}deg)`, this.val.setVal_Nochk("tmp", R + ".x", N.x), this.val.setVal_Nochk("tmp", R + ".y", N.y), this.val.setVal_Nochk("tmp", R + ".scale_x", N.sx), this.val.setVal_Nochk("tmp", R + ".scale_y", N.sy), this.val.setVal_Nochk("tmp", R + ".rotate", N.r);
  });
  let U = () => {
  };
  "width" in t && (D.w = k.width, U = () => {
    o.width = N.w * this.sys.cvsScale + "px", this.val.setVal_Nochk("tmp", R + ".width", N.w);
  });
  let z = () => {
  };
  "height" in t && (D.h = k.height, z = () => {
    o.height = N.h * this.sys.cvsScale + "px", this.val.setVal_Nochk("tmp", R + ".height", N.h);
  }), this.appPixi.stage.interactive = !1;
  const X = `frm
${t.id}`, V = new Tween(N).to(D, argChk_Num(t, "time", NaN) * (Boolean(this.val.getVal("tmp:sn.skip.enabled") || H(this, ws).isSkippingByKeyDown()) ? 0 : 1)).delay(argChk_Num(t, "delay", 0)).easing(CmnTween.ease(t.ease)).repeat(L === 0 ? 1 / 0 : L - 1).yoyo(argChk_Boolean(t, "yoyo", !1)).onUpdate(() => {
    B(), $(), U(), z();
  }).onComplete(() => {
    var q, Z;
    this.appPixi.stage.interactive = !0;
    const Y = this.hTwInf[X];
    !Y || (delete this.hTwInf[X], (q = Y.tw) == null || q.stop(), Y.resume && this.main.resume(), (Z = Y.onEnd) == null || Z.call(Y));
  });
  if ("chain" in t) {
    const Y = this.hTwInf[(W = t.chain) != null ? W : ""];
    if (!Y || !Y.tw)
      throw `${t.chain}\u306F\u5B58\u5728\u3057\u306A\u3044\u30FB\u307E\u305F\u306F\u7D42\u4E86\u3057\u305F\u30C8\u30A5\u30A4\u30FC\u30F3\u3067\u3059`;
    delete Y.onEnd, Y.tw.chain(V);
  } else
    V.start();
  return this.hTwInf[X] = { tw: V, resume: !1 }, !1;
};
var Tr, ie, ge, Ii, pn, As, Os, Ns, vn, so, yh, ii, Br, Hu, yc, sr, zu, bc, ju, Ec, Vu, xc, Kt, Sr, Cr, Ms, Xu, Tc, Ds, tu, Wu, Sc, ao, Ls, oo, wi, Ri, $r, Se, Pi, Yu, Cc, Ce, Ge, Je, qu, Ic, Zu, wc, Ku, Rc, gn, ga, Ju, Pc, We, Qu, Ac, tl, Oc, el, Nc, rl, Mc, il, Dc, Ai, Oi, Un, cr, nl, Lc, Fs, sl, Fc, kr, Ni, Mi, Hn, Ir, wr, al, Bc, ol, $c, ul, kc, ll, Gc, hl, Uc, cl, Hc, fl, zc, dl, jc, pl, Vc, vl, Xc, gl, Wc, _l, Yc, ml, qc, yl, Zc, bl, Kc;
const Wi = class {
  constructor(t, e, o, R, N, M, D, L, B, $) {
    it(this, so);
    it(this, Hu);
    it(this, zu);
    it(this, ju);
    it(this, Vu);
    it(this, Xu);
    it(this, Ds);
    it(this, Wu);
    it(this, Yu);
    it(this, Ge);
    it(this, qu);
    it(this, Zu);
    it(this, Ku);
    it(this, gn);
    it(this, Ju);
    it(this, Qu);
    it(this, tl);
    it(this, el);
    it(this, rl);
    it(this, il);
    it(this, Oi);
    it(this, nl);
    it(this, sl);
    it(this, Mi);
    it(this, al);
    it(this, ol);
    it(this, ul);
    it(this, ll);
    it(this, hl);
    it(this, cl);
    it(this, fl);
    it(this, dl);
    it(this, pl);
    it(this, vl);
    it(this, gl);
    it(this, _l);
    it(this, ml);
    it(this, yl);
    it(this, bl);
    it(this, Tr, void 0);
    it(this, ie, void 0);
    it(this, ge, void 0);
    it(this, Ii, void 0);
    it(this, pn, void 0);
    it(this, As, void 0);
    it(this, Os, void 0);
    it(this, Ns, void 0);
    it(this, vn, void 0);
    it(this, ii, void 0);
    it(this, Br, void 0);
    it(this, sr, void 0);
    it(this, Kt, void 0);
    it(this, Sr, void 0);
    it(this, Cr, void 0);
    it(this, Ms, void 0);
    it(this, ao, void 0);
    it(this, Ls, void 0);
    it(this, oo, void 0);
    it(this, wi, void 0);
    it(this, Ri, void 0);
    it(this, $r, void 0);
    it(this, Se, void 0);
    it(this, Pi, void 0);
    it(this, Ce, void 0);
    it(this, We, void 0);
    it(this, cr, void 0);
    it(this, Fs, void 0);
    it(this, kr, void 0);
    it(this, Ni, void 0);
    it(this, Ir, void 0);
    it(this, wr, void 0);
    this.cfg = t, this.hTag = e, this.appPixi = o, this.val = R, this.main = N, this.scrItr = M, this.sys = D, this.sndMng = L, this.alzTagArg = B, this.prpPrs = $, et(this, ie, new Container()), et(this, ge, new Container()), et(this, As, () => update()), et(this, Os, {
      attach: (V) => (DesignCast.leaveMode(), !1),
      continue: (V) => (DesignCast.leaveMode(), !1),
      disconnect: (V) => (DesignCast.leaveMode(), !1),
      _enterDesign: (V) => (DesignCast.enterMode(), H(this, Sr).forEach((W) => {
        const Y = H(this, Kt)[W].fore;
        Y.makeDesignCastChildren((q) => q.make()), Y.makeDesignCast((q) => q.make());
      }), st(this, so, yh).call(this, H(this, Cr)), !1),
      _replaceToken: (V, W) => (DesignCast.replaceToken(W), !1),
      _selectNode: (V, W) => (st(this, so, yh).call(this, W.node), !1)
    }), et(this, Ns, ""), et(this, vn, ""), this.getFrmDisabled = (V) => H(this, Ii).getFrmDisabled(V), et(this, ii, void 0), et(this, sr, (V, W = this.currentTxtlayForeNeedErr, Y = !0) => W.tagCh("\uFF5C\u3000\u300A" + V + "\u300B")), this.goTxt = () => {
    }, this.breakLine = () => {
    }, this.breakPage = () => {
    }, et(this, Kt, {}), et(this, Sr, []), et(this, Cr, ""), et(this, Ms, ""), et(this, ao, `
precision mediump float;

varying vec2 vTextureCoord;
uniform sampler2D uSampler;

uniform sampler2D rule;
uniform float vague;
uniform float tick;

uniform vec4 inputPixel;
uniform highp vec4 outputFrame;
vec2 getUV(vec2 coord) {
	return coord * inputPixel.xy / outputFrame.zw;
}

void main(void) {
	vec4 fg = texture2D(uSampler, vTextureCoord);
	vec4 ru = texture2D(rule, getUV(vTextureCoord));

	float v = ru.r - tick;
	if (abs(v) < vague) {
		float f_a = fg.a *(0.5 +v /vague *0.5);

		gl_FragColor.rgb = fg.rgb *f_a;
		gl_FragColor.a = f_a;
	}
	else {
		gl_FragColor = (v >= 0.0)? fg : vec4(0);
	}
}`), et(this, Ls, {
      rule: Texture.EMPTY,
      vague: 0,
      tick: 0
    }), et(this, oo, new Filter(void 0, H(this, ao), H(this, Ls))), et(this, wi, RenderTexture.create({
      width: CmnLib.stageW,
      height: CmnLib.stageH
    })), et(this, Ri, new Sprite(H(this, wi))), et(this, $r, RenderTexture.create({
      width: CmnLib.stageW,
      height: CmnLib.stageH
    })), et(this, Se, new Sprite(H(this, $r))), et(this, Pi, []), et(this, Ce, { tw: void 0, resume: !1 }), et(this, We, {}), et(this, cr, (V) => {
      throw H(this, Ni).call(this), 0;
    }), et(this, Fs, (V) => {
      throw H(this, Ni).call(this), 0;
    }), et(this, Ni, () => {
      throw "\u6587\u5B57\u30EC\u30A4\u30E4\u30FC\u304C\u3042\u308A\u307E\u305B\u3093\u3002\u6587\u5B57\u8868\u793A\u3084\u64CD\u4F5C\u3059\u308B\u524D\u306B\u3001[add_lay layer=\uFF08\u30EC\u30A4\u30E4\u540D\uFF09 class=txt]\u3067\u6587\u5B57\u30EC\u30A4\u30E4\u3092\u8FFD\u52A0\u3057\u3066\u4E0B\u3055\u3044";
    }), et(this, Ir, { text: "" }), et(this, wr, []);
    const k = () => {
      D.cvsResize(), this.cvsResizeDesign(), H(this, vn) ? H(this, Sr).forEach(
        (V) => H(this, Kt)[V].fore.cvsResizeChildren()
      ) : H(this, Sr).forEach(
        (V) => H(this, Kt)[V].fore.cvsResize()
      ), H(this, Ii).cvsResize(), H(this, Br).cvsResize();
    };
    if (CmnLib.isMobile)
      globalThis.addEventListener("orientationchange", k, { passive: !0 });
    else {
      let V;
      globalThis.addEventListener("resize", () => {
        V || (V = setTimeout(() => {
          V = void 0, k();
        }, 1e3 / 60 * 10));
      }, { passive: !0 });
    }
    D.cvsResize(), TxtLayer.init(t, e, R, (V) => this.recText(V), (V) => H(this, Kt)[V.layname].fore === V, o), GrpLayer.init(N, t, o, D, L), Button.init(t), et(this, Ii, new FrameMng(this.cfg, this.hTag, this.appPixi, this.val, N, this.sys, H(this, We))), D.hFactoryCls.grp = () => new GrpLayer(), D.hFactoryCls.txt = () => new TxtLayer(), e.loadplugin = (V) => st(this, ju, Ec).call(this, V), e.snapshot = (V) => st(this, zu, bc).call(this, V), e.add_lay = (V) => st(this, Vu, xc).call(this, V), e.clear_lay = (V) => st(this, Wu, Sc).call(this, V), e.finish_trans = () => st(this, gn, ga).call(this), e.lay = (V) => st(this, Xu, Tc).call(this, V), e.trans = (V) => st(this, Yu, Cc).call(this, V), e.wt = (V) => st(this, Ku, Rc).call(this, V), e.quake = (V) => st(this, Ju, Pc).call(this, V), e.stop_quake = (V) => e.finish_trans(V), e.wq = (V) => e.wt(V), e.pause_tsy = (V) => st(this, rl, Mc).call(this, V), e.resume_tsy = (V) => st(this, il, Dc).call(this, V), e.stop_tsy = (V) => st(this, el, Nc).call(this, V), e.tsy = (V) => st(this, Qu, Ac).call(this, V), e.wait_tsy = (V) => st(this, tl, Oc).call(this, V), e.ch = (V) => st(this, Oi, Un).call(this, V), e.clear_text = (V) => st(this, al, Bc).call(this, V), e.current = (V) => H(this, Fs).call(this, V), e.endlink = (V) => st(this, ol, $c).call(this, V), e.er = (V) => st(this, ul, kc).call(this, V), e.graph = (V) => st(this, ll, Gc).call(this, V), e.link = (V) => st(this, hl, Uc).call(this, V), e.r = (V) => st(this, cl, Hc).call(this, V), e.rec_ch = (V) => st(this, dl, jc).call(this, V), e.rec_r = () => st(this, fl, zc).call(this), e.reset_rec = (V) => st(this, pl, Vc).call(this, V), e.ruby2 = (V) => st(this, vl, Xc).call(this, V), e.span = (V) => st(this, gl, Wc).call(this, V), e.tcy = (V) => st(this, _l, Yc).call(this, V), e.add_face = (V) => GrpLayer.add_face(V), e.wv = (V) => GrpLayer.wv(V), e.dump_lay = (V) => st(this, ml, qc).call(this, V), e.enable_event = (V) => st(this, yl, Zc).call(this, V), e.button = (V) => st(this, bl, Kc).call(this, V), t.existsBreakline && (this.breakLine = () => H(this, sr).call(this, 'grp\uFF5C{"id":"break","pic":"breakline"}')), t.existsBreakpage && (this.breakPage = () => H(this, sr).call(this, 'grp\uFF5C{"id":"break","pic":"breakpage"}')), et(this, pn, parseColor(String(t.oCfg.init.bg_color)));
    const U = new Graphics();
    U.beginFill(H(this, pn), 1).lineStyle(0, H(this, pn)).drawRect(0, 0, CmnLib.stageW, CmnLib.stageH).endFill(), H(this, ie).addChild(U.clone()), H(this, ge).addChild(U), H(this, ge).visible = !1, et(this, Tr, this.appPixi.stage), H(this, Tr).addChild(H(this, ge)), H(this, Tr).addChild(H(this, ie)), H(this, Tr).addChild(H(this, Ri)), H(this, Tr).addChild(H(this, Se)), this.appPixi.ticker.add(H(this, As));
    const z = (V, W) => {
      st(this, Hu, yc).call(this, Number(W));
    };
    z("", R.getVal("sys:TextLayer.Back.Alpha", 1)), R.defValTrg("sys:TextLayer.Back.Alpha", z);
    const X = (V, W) => Button.fontFamily = W;
    X("", R.getVal("tmp:sn.button.fontFamily", Button.fontFamily)), R.defValTrg("tmp:sn.button.fontFamily", X), R.defTmp("const.sn.log.json", () => JSON.stringify(
      H(this, Ir).text ? [...H(this, wr), H(this, Ir)] : H(this, wr)
    )), R.defTmp("const.sn.last_page_text", () => {
      var V, W;
      return (W = (V = this.currentTxtlayFore) == null ? void 0 : V.pageText) != null ? W : "";
    }), CmnLib.isDbg && (DesignCast.init(this.appPixi, D, M, $, B, this.cfg, H(this, Kt)), this.cvsResizeDesign = () => DesignCast.cvsResizeDesign(), D.addHook((V, W) => {
      var Y, q;
      !((q = (Y = H(this, Os))[V]) != null && q.call(Y, V, W)) || delete H(this, Os)[V];
    }));
  }
  cvsResizeDesign() {
  }
  cover(t, e = 0) {
    H(this, ii) && (H(this, Tr).removeChild(H(this, ii)), H(this, ii).destroy(), et(this, ii, void 0)), t && H(this, Tr).addChild(
      et(this, ii, new Graphics()).beginFill(e).lineStyle(0, e).drawRect(0, 0, CmnLib.stageW, CmnLib.stageH).endFill()
    );
  }
  setEvtMng(t) {
    et(this, Br, t), H(this, Ii).setEvtMng(t), GrpLayer.setEvtMng(t);
  }
  before_destroy() {
    for (const t in H(this, Kt))
      H(this, Kt)[t].destroy();
  }
  destroy() {
    GrpLayer.destroy(), RubySpliter.destroy(), TxtStage.destroy(), TxtLayer.destroy(), H(this, Ii).destroy(), this.stopAllTw(), this.appPixi.ticker.remove(H(this, As)), et(Wi, Ai, 10);
  }
  stopAllTw() {
    et(this, We, {}), removeAll();
  }
  clearBreak() {
    !this.currentTxtlayFore || (this.clearBreak = () => H(this, sr).call(this, "del\uFF5Cbreak"), this.clearBreak());
  }
  clickTxtLay() {
    if (!this.currentTxtlayFore)
      return;
    const t = st(this, Ge, Je).call(this), e = t.length;
    for (let o = 0; o < e; ++o) {
      const R = t[o], N = H(this, Kt)[R];
      if (!(N.fore instanceof TxtLayer))
        continue;
      if (!N.fore.click())
        break;
    }
  }
  static get msecChWait() {
    return H(Wi, Ai);
  }
  static set msecChWait(t) {
    et(Wi, Ai, t);
  }
  setNormalChWait() {
    et(Wi, Ai, this.scrItr.normalWait);
  }
  get currentTxtlayForeNeedErr() {
    return H(this, Ni).call(this), this.currentTxtlayFore;
  }
  get currentTxtlayFore() {
    if (!!H(this, kr))
      return H(this, kr).fore;
  }
  recText(t, e = !1) {
    const o = H(this, Ir);
    if (e) {
      o.text && (o.text = String(o.text).replaceAll("</span><span class='sn_ch'>", ""), H(this, wr).push(o) > this.cfg.oCfg.log.max_len && et(this, wr, H(this, wr).slice(-this.cfg.oCfg.log.max_len))), et(this, Ir, { text: "" });
      return;
    }
    o.text = t.replace(/\\`/, "`"), this.val.setVal_Nochk(
      "save",
      "const.sn.sLog",
      String(this.val.getVal("const.sn.log.json"))
    );
  }
  record() {
    const t = {};
    return H(this, Sr).forEach((e) => {
      const o = H(this, Kt)[e];
      t[e] = {
        cls: o.cls,
        fore: o.fore.record(),
        back: o.back.record()
      };
    }), t;
  }
  playback(t, e) {
    var M, D;
    et(this, wr, JSON.parse(String(this.val.getVal("save:const.sn.sLog")))), et(this, Ir, { text: "" });
    const o = [], R = [];
    for (const L in t) {
      const B = t[L];
      R.push({ layer: L, idx: B.fore.idx });
      const $ = (D = (M = H(this, Kt))[L]) != null ? D : M[L] = new Pages(L, B.cls, H(this, ie), H(this, ge), {}, this.sys, this.val, { isWait: !1 });
      $.fore.playback(B.fore, o), $.back.playback(B.back, o);
    }
    const N = H(this, ie).children.length;
    Promise.allSettled(o).then(() => {
      R.sort(function(L, B) {
        return L.idx < B.idx ? -1 : L.idx > B.idx ? 1 : 0;
      }), R.forEach((L) => {
        const B = H(this, Kt)[L.layer];
        if (!B)
          return;
        const $ = N > L.idx ? L.idx : N - 1;
        H(this, ie).setChildIndex(B.fore.spLay, $), H(this, ge).setChildIndex(B.back.spLay, $);
      }), e();
    }).catch((L) => console.error("fn:LayerMng.ts playback e:%o", L));
  }
};
let LayerMng = Wi;
Tr = new WeakMap(), ie = new WeakMap(), ge = new WeakMap(), Ii = new WeakMap(), pn = new WeakMap(), As = new WeakMap(), Os = new WeakMap(), Ns = new WeakMap(), vn = new WeakMap(), so = new WeakSet(), yh = function(t) {
  [Re(this, Ns)._, this.vn = ""] = t.split("/");
  const e = H(this, Kt)[H(this, Ns)];
  !e || (DesignCast.allHide(), H(this, vn) ? e.fore.showDesignCastChildren() : e.fore.showDesignCast());
}, ii = new WeakMap(), Br = new WeakMap(), Hu = new WeakSet(), yc = function(t) {
  st(this, Ge, Je).call(this).forEach((e) => {
    const o = H(this, Kt)[e];
    if (!(o.fore instanceof TxtLayer))
      return;
    o.fore.chgBackAlpha(t), o.back.chgBackAlpha(t);
  });
}, sr = new WeakMap(), zu = new WeakSet(), bc = function(t) {
  const e = t.fn ? t.fn.slice(0, 10) === "userdata:/" ? t.fn : `downloads:/${t.fn + getDateStr("-", "_", "", "_")}.png` : `downloads:/snapshot${getDateStr("-", "_", "", "_")}.png`, o = this.cfg.searchPath(e);
  if (this.sys.canCapturePage(o))
    return !1;
  const R = getExt(o), N = argChk_Color(t, "b_color", H(this, pn)), M = autoDetectRenderer({
    width: argChk_Num(t, "width", CmnLib.stageW),
    height: argChk_Num(t, "height", CmnLib.stageH),
    backgroundAlpha: N > 16777216 && R === "png" ? 0 : 1,
    antialias: argChk_Boolean(t, "smoothing", !1),
    preserveDrawingBuffer: !0,
    backgroundColor: N & 16777215,
    autoDensity: !0
  }), D = [], L = t.page !== "back" ? "fore" : "back";
  return H(this, Ce).tw ? D.push(new Promise((B) => {
    H(this, ge).visible = !0, H(this, Pi).forEach(($) => M.render($, { clear: !1 })), H(this, ge).visible = !1, H(this, Ri).visible = !0, H(this, ie).filters = H(this, Se).filters, H(this, ie).visible = !0, M.render(H(this, ie), { clear: !1 }), H(this, ie).visible = !1, H(this, ie).filters = [], B();
  })) : st(this, Ge, Je).call(this, t.layer).forEach((B) => D.push(new Promise(
    ($) => H(this, Kt)[B][L].snapshot(M, () => $())
  ))), Promise.allSettled(D).then(async () => {
    const B = RenderTexture.create({ width: M.width, height: M.height, transform: !0 });
    M.render(H(this, Tr), { renderTexture: B }), await this.sys.savePic(
      o,
      M.plugins.extract.base64(Sprite.from(B))
    ), H(this, Ce).tw || st(this, Ge, Je).call(this, t.layer).forEach(($) => H(this, Kt)[$][L].snapshot_end()), M.destroy(!0);
  }), !1;
}, ju = new WeakSet(), Ec = function(t) {
  const { fn: e } = t;
  if (!e)
    throw "fn\u306F\u5FC5\u9808\u3067\u3059";
  const o = argChk_Boolean(t, "join", !0);
  switch (getExt(e)) {
    case "css":
      (async () => {
        const R = await fetch(e);
        if (!R.ok)
          throw new Error("Network response was not ok.");
        addStyle(await R.text()), o && this.main.resume();
      })();
      break;
    default:
      throw "\u30B5\u30DD\u30FC\u30C8\u3055\u308C\u306A\u3044\u62E1\u5F35\u5B50\u3067\u3059";
  }
  return o;
}, Vu = new WeakSet(), xc = function(t) {
  const { layer: e, class: o } = t;
  if (!e)
    throw "layer\u306F\u5FC5\u9808\u3067\u3059";
  if (e.includes(","))
    throw "layer\u540D\u306B\u300C,\u300D\u306F\u4F7F\u3048\u307E\u305B\u3093";
  if (e in H(this, Kt))
    throw `layer\u3010${e}\u3011\u306F\u3059\u3067\u306B\u3042\u308A\u307E\u3059`;
  if (!o)
    throw "cls\u306F\u5FC5\u9808\u3067\u3059";
  const R = { isWait: !1 };
  switch (H(this, Kt)[e] = new Pages(e, o, H(this, ie), H(this, ge), t, this.sys, this.val, R), H(this, Sr).push(e), o) {
    case "txt":
      H(this, Cr) || (et(this, Ni, () => {
      }), et(this, cr, st(this, nl, Lc)), et(this, Fs, st(this, sl, Fc)), this.hTag.current({ layer: e }), this.goTxt = () => {
        this.val.getVal("sn.skip.enabled") ? et(Wi, Ai, 0) : this.setNormalChWait(), st(this, Ge, Je).call(this).forEach((N) => {
          const M = H(this, Kt)[N];
          M.fore instanceof TxtLayer && H(this, sr).call(this, "gotxt\uFF5C", M.fore, !1);
        });
      }), this.val.setVal_Nochk(
        "save",
        "const.sn.layer." + (e != null ? e : H(this, Cr)) + ".enabled",
        !0
      );
      break;
    case "grp":
      if (H(this, Ms))
        break;
      et(this, Ms, e);
      break;
  }
  return this.scrItr.recodeDesign(t), R.isWait;
}, Kt = new WeakMap(), Sr = new WeakMap(), Cr = new WeakMap(), Ms = new WeakMap(), Xu = new WeakSet(), Tc = function(t) {
  const e = st(this, Mi, Hn).call(this, t), o = H(this, Kt)[e], R = o.back.spLay, N = o.fore.spLay;
  if (argChk_Boolean(t, "float", !1))
    H(this, ge).setChildIndex(R, H(this, ge).children.length - 1), H(this, ie).setChildIndex(N, H(this, ie).children.length - 1), st(this, Ds, tu).call(this);
  else if (t.index)
    argChk_Num(t, "index", 0) && (H(this, ge).setChildIndex(R, t.index), H(this, ie).setChildIndex(N, t.index), st(this, Ds, tu).call(this));
  else if (t.dive) {
    const { dive: M } = t;
    let D = 0;
    if (e === M)
      throw "[lay] \u5C5E\u6027 layer\u3068dive\u304C\u540C\u3058\u3010" + M + "\u3011\u3067\u3059";
    const L = H(this, Kt)[M];
    if (!L)
      throw "[lay] \u5C5E\u6027 dive\u3010" + M + "\u3011\u304C\u4E0D\u6B63\u3067\u3059\u3002\u30EC\u30A4\u30E4\u30FC\u304C\u3042\u308A\u307E\u305B\u3093";
    const B = L.back, $ = L.fore, k = H(this, ge).getChildIndex(B.spLay), U = H(this, ie).getChildIndex($.spLay);
    D = k < U ? k : U, D > H(this, ge).getChildIndex(R) && --D, H(this, ie).setChildIndex(N, D), H(this, ge).setChildIndex(R, D), st(this, Ds, tu).call(this);
  }
  return t[":id_tag"] = o.fore.name.slice(0, -7), this.scrItr.recodeDesign(t), o.lay(t);
}, Ds = new WeakSet(), tu = function() {
  et(this, Sr, st(this, Zu, wc).call(this));
}, Wu = new WeakSet(), Sc = function(t) {
  return st(this, qu, Ic).call(this, t, (e) => {
    const o = H(this, Kt)[st(this, Mi, Hn).call(this, { layer: e })];
    t.page === "both" ? (o.fore.clearLay(t), o.back.clearLay(t)) : o.getPage(t).clearLay(t);
  }), !1;
}, ao = new WeakMap(), Ls = new WeakMap(), oo = new WeakMap(), wi = new WeakMap(), Ri = new WeakMap(), $r = new WeakMap(), Se = new WeakMap(), Pi = new WeakMap(), Yu = new WeakSet(), Cc = function(t) {
  st(this, gn, ga).call(this);
  const e = CmnTween.ease(t.ease);
  et(this, Pi, []);
  const o = {}, R = [];
  st(this, Ge, Je).call(this, t.layer).forEach((z) => {
    o[z] = !0, R.push(H(this, Kt)[z].fore);
  });
  const N = [];
  st(this, Ge, Je).call(this).forEach((z) => {
    const X = H(this, Kt)[z][o[z] ? "back" : "fore"];
    H(this, Pi).push(X.spLay), N.push(X);
  }), H(this, wi).resize(CmnLib.stageW, CmnLib.stageH), this.appPixi.renderer.render(H(this, ge), { renderTexture: H(this, wi) });
  let M = () => {
    H(this, ge).visible = !0, H(this, Pi).forEach((z) => {
      this.appPixi.renderer.render(z, { renderTexture: H(this, wi), clear: !1 });
    }), H(this, ge).visible = !1;
  };
  if (!N.some((z) => z.containMovement)) {
    let z = M;
    M = () => {
      M = () => {
      }, z();
    };
  }
  H(this, $r).resize(CmnLib.stageW, CmnLib.stageH), this.appPixi.renderer.render(H(this, ie), { renderTexture: H(this, $r) });
  let D = () => {
    H(this, ie).visible = !0, this.appPixi.renderer.render(H(this, ie), { renderTexture: H(this, $r) }), H(this, ie).visible = !1;
  };
  if (!R.some((z) => z.containMovement)) {
    let z = D;
    D = () => {
      D = () => {
      }, z();
    };
  }
  const L = () => {
    M(), H(this, Ri).visible = !0, D(), H(this, Se).visible = !0;
  };
  H(this, Se).alpha = 1;
  const B = () => {
    var X;
    this.appPixi.ticker && this.appPixi.ticker.remove(L), [Re(this, ie)._, Re(this, ge)._] = [H(this, ge), H(this, ie)];
    const z = [];
    for (const V in H(this, Kt)) {
      const W = H(this, Kt)[V];
      if (o[V]) {
        W.transPage(z);
        continue;
      }
      const Y = H(this, ie).getChildIndex(W.back.spLay);
      H(this, ie).removeChild(W.back.spLay), H(this, ge).removeChild(W.fore.spLay), H(this, ie).addChildAt(W.fore.spLay, Y), H(this, ge).addChildAt(W.back.spLay, Y);
    }
    Promise.allSettled(z), H(this, ie).visible = !0, H(this, ge).visible = !1, H(this, Ri).visible = !1, H(this, Se).visible = !1, (X = H(this, Ce).tw) == null || X.stop(), H(this, Ce).resume && this.main.resume(), et(this, Ce, { tw: void 0, resume: !1 });
  };
  et(this, Ce, { tw: void 0, resume: !1 });
  const $ = argChk_Num(t, "time", 0);
  if ($ === 0 || H(this, Br).isSkippingByKeyDown())
    return B(), !1;
  const k = "glsl" in t;
  if (!k && !("rule" in t))
    return H(this, Se).filters = [], H(this, Ce).tw = new Tween(H(this, Se)).to({ alpha: 0 }, $).delay(argChk_Num(t, "delay", 0)).easing(e).onComplete(B).start(), this.appPixi.ticker.add(L), !1;
  const U = k ? new Filter(void 0, t.glsl, H(this, Ls)) : H(this, oo);
  if (U.uniforms.vague = argChk_Num(t, "vague", 0.04), U.uniforms.tick = 0, H(this, Ce).tw = new Tween(U.uniforms).to({ tick: 1 }, $).delay(argChk_Num(t, "delay", 0)).easing(e).onComplete(B), H(this, Se).filters = [U], k)
    return H(this, Ce).tw.start(), this.appPixi.ticker.add(L), !1;
  if (!t.rule)
    throw "rule\u304C\u6307\u5B9A\u3055\u308C\u3066\u3044\u307E\u305B\u3093";
  return GrpLayer.csv2Sprites(t.rule, void 0, (z) => {
    var X;
    U.uniforms.rule = z.texture, z.destroy(), (X = H(this, Ce).tw) == null || X.start(), this.appPixi.ticker.add(L);
  }), !1;
}, Ce = new WeakMap(), Ge = new WeakSet(), Je = function(t = "") {
  return t ? t.split(",") : H(this, Sr);
}, qu = new WeakSet(), Ic = function(t, e) {
  const o = st(this, Ge, Je).call(this, t.layer);
  return o.forEach((R) => {
    if (!R)
      return;
    const N = H(this, Kt)[R];
    if (!N)
      throw "\u5B58\u5728\u3057\u306A\u3044layer\u3010" + R + "\u3011\u3067\u3059";
    e(R, N);
  }), o;
}, Zu = new WeakSet(), wc = function(t = "") {
  return st(this, Ge, Je).call(this, t).sort((e, o) => {
    const R = H(this, ie).getChildIndex(H(this, Kt)[e].fore.spLay), N = H(this, ie).getChildIndex(H(this, Kt)[o].fore.spLay);
    return R < N ? -1 : R > N ? 1 : 0;
  });
}, Ku = new WeakSet(), Rc = function(t) {
  return H(this, Ce).tw ? (H(this, Ce).resume = !0, H(this, Br).waitLimitedEvent(t, () => st(this, gn, ga).call(this))) : !1;
}, gn = new WeakSet(), ga = function() {
  var t;
  return (t = H(this, Ce).tw) == null || t.end(), !1;
}, Ju = new WeakSet(), Pc = function(t) {
  st(this, gn, ga).call(this);
  const e = argChk_Num(t, "time", NaN);
  if (e === 0 || this.val.getVal("tmp:sn.skip.enabled") || H(this, Br).isSkippingByKeyDown())
    return !1;
  const o = [];
  st(this, Ge, Je).call(this, t.layer).forEach((k) => {
    o.push(H(this, Kt)[k].fore.spLay);
  }), H(this, $r).resize(CmnLib.stageW, CmnLib.stageH);
  const R = () => {
    H(this, ie).visible = !0, o.forEach(
      (k) => this.appPixi.renderer.render(k, { renderTexture: H(this, $r), clear: !1 })
    ), H(this, ie).visible = !1;
  };
  H(this, Se).visible = !0, H(this, Se).alpha = 1;
  const N = uint(argChk_Num(t, "hmax", 10)), M = uint(argChk_Num(t, "vmax", 10)), D = N === 0 ? () => {
  } : () => H(this, Se).x = Math.round(Math.random() * N * 2) - N, L = M === 0 ? () => {
  } : () => H(this, Se).y = Math.round(Math.random() * M * 2) - M;
  H(this, Se).filters = [];
  const B = argChk_Num(t, "repeat", 1), $ = new Tween(H(this, Se)).to({ x: 0, y: 0 }, e).delay(argChk_Num(t, "delay", 0)).easing(CmnTween.ease(t.ease)).onUpdate(() => {
    D(), L();
  }).repeat(B === 0 ? 1 / 0 : B - 1).yoyo(argChk_Boolean(t, "yoyo", !1)).onComplete(() => {
    var k, U;
    (k = this.appPixi.ticker) == null || k.remove(R), H(this, ie).visible = !0, H(this, Se).visible = !1, H(this, Se).x = 0, H(this, Se).y = 0, (U = H(this, Ce).tw) == null || U.stop(), H(this, Ce).resume && this.main.resume(), et(this, Ce, { tw: void 0, resume: !1 });
  }).start();
  return et(this, Ce, { tw: $, resume: !1 }), this.appPixi.ticker.add(R), !1;
}, We = new WeakMap(), Qu = new WeakSet(), Ac = function(t) {
  var U, z;
  if (!t.layer)
    throw "layer\u306F\u5FC5\u9808\u3067\u3059";
  const e = st(this, Mi, Hn).call(this, t);
  let o = H(this, Kt)[e].fore, R = () => {
  };
  const N = H(this, Br).isSkippingByKeyDown();
  !N && "render" in t && (o.renderStart(), R = () => o.renderEnd());
  const M = cnvTweenArg(t, o), D = argChk_Num(t, "repeat", 1), L = (U = t.name) != null ? U : t.layer, B = new Tween(o).to(M, argChk_Num(t, "time", NaN) * (Boolean(this.val.getVal("tmp:sn.skip.enabled") || N) ? 0 : 1)).delay(argChk_Num(t, "delay", 0)).easing(CmnTween.ease(t.ease)).repeat(D === 0 ? 1 / 0 : D - 1).yoyo(argChk_Boolean(t, "yoyo", !1)).onComplete(() => {
    var V, W;
    const X = H(this, We)[L];
    !X || (R(), delete H(this, We)[L], (V = X.tw) == null || V.stop(), X.resume && this.main.resume(), (W = X.onEnd) == null || W.call(X));
  });
  if ("chain" in t) {
    const X = H(this, We)[(z = t.chain) != null ? z : ""];
    if (!(X != null && X.tw))
      throw `${t.chain}\u306F\u5B58\u5728\u3057\u306A\u3044\u30FB\u307E\u305F\u306F\u7D42\u4E86\u3057\u305F\u30C8\u30A5\u30A4\u30FC\u30F3\u3067\u3059`;
    delete X.onEnd, X.tw.chain(B);
  } else
    B.start();
  const $ = argChk_Boolean(t, "arrive", !1), k = argChk_Boolean(t, "backlay", !1);
  return H(this, We)[L] = { tw: B, resume: !1, onEnd: () => {
    if ($ && Object.assign(o, M), k) {
      const X = H(this, Kt)[e].back.spLay;
      for (const V in hMemberCnt)
        X[V] = o[V];
    }
  } }, !1;
}, tl = new WeakSet(), Oc = function(t) {
  var R;
  const e = "id" in t ? `frm
${t.id}` : (R = t.name) != null ? R : t.layer;
  if (!e)
    throw "\u30C8\u30A5\u30A4\u30FC\u30F3\u304C\u6307\u5B9A\u3055\u308C\u3066\u3044\u307E\u305B\u3093";
  const o = H(this, We)[e];
  return o != null && o.tw ? o.resume = H(this, Br).waitEvent(
    () => {
      var N;
      return (N = o.tw) == null ? void 0 : N.end();
    },
    argChk_Boolean(t, "canskip", !0),
    argChk_Boolean(t, "global", !1)
  ) : !1;
}, el = new WeakSet(), Nc = function(t) {
  var o, R, N;
  const e = "id" in t ? `frm
${t.id}` : (o = t.name) != null ? o : t.layer;
  if (!e)
    throw "\u30C8\u30A5\u30A4\u30FC\u30F3\u304C\u6307\u5B9A\u3055\u308C\u3066\u3044\u307E\u305B\u3093";
  return (N = (R = H(this, We)[e]) == null ? void 0 : R.tw) == null || N.end(), !1;
}, rl = new WeakSet(), Mc = function(t) {
  var o, R, N;
  const e = "id" in t ? `frm
${t.id}` : (o = t.name) != null ? o : t.layer;
  if (!e)
    throw "\u30C8\u30A5\u30A4\u30FC\u30F3\u304C\u6307\u5B9A\u3055\u308C\u3066\u3044\u307E\u305B\u3093";
  return (N = (R = H(this, We)[e]) == null ? void 0 : R.tw) == null || N.pause(), !1;
}, il = new WeakSet(), Dc = function(t) {
  var o, R, N;
  const e = "id" in t ? `frm
${t.id}` : (o = t.name) != null ? o : t.layer;
  if (!e)
    throw "\u30C8\u30A5\u30A4\u30FC\u30F3\u304C\u6307\u5B9A\u3055\u308C\u3066\u3044\u307E\u305B\u3093";
  return (N = (R = H(this, We)[e]) == null ? void 0 : R.tw) == null || N.resume(), !1;
}, Ai = new WeakMap(), Oi = new WeakSet(), Un = function(t) {
  const { text: e } = t;
  if (!e)
    throw "text\u306F\u5FC5\u9808\u3067\u3059";
  const o = H(this, cr).call(this, t);
  delete t.text, this.val.getVal("tmp:sn.skip.enabled") ? t.wait = 0 : "wait" in t && argChk_Num(t, "wait", NaN), H(this, sr).call(this, "add\uFF5C" + JSON.stringify(t), o);
  const R = argChk_Boolean(t, "record", !0), N = this.val.doRecLog();
  return R || this.val.setVal_Nochk("save", "sn.doRecLog", R), o.tagCh(e.replaceAll("[r]", `
`)), R || this.val.setVal_Nochk("save", "sn.doRecLog", N), H(this, sr).call(this, "add_close\uFF5C", o), !1;
}, cr = new WeakMap(), nl = new WeakSet(), Lc = function(t) {
  const e = st(this, Mi, Hn).call(this, t, H(this, Cr)), R = H(this, Kt)[e].getPage(t);
  if (!(R instanceof TxtLayer))
    throw e + "\u306FTxtLayer\u3067\u306F\u3042\u308A\u307E\u305B\u3093";
  return R;
}, Fs = new WeakMap(), sl = new WeakSet(), Fc = function(t) {
  const { layer: e } = t;
  if (!e)
    throw "[current] layer\u306F\u5FC5\u9808\u3067\u3059";
  if (et(this, kr, H(this, Kt)[e]), !(H(this, kr).getPage(t) instanceof TxtLayer))
    throw `${e}\u306FTxtLayer\u3067\u306F\u3042\u308A\u307E\u305B\u3093`;
  return this.recText("", !0), et(this, Cr, e), this.val.setVal_Nochk("save", "const.sn.mesLayer", e), st(this, Ge, Je).call(this).forEach((o) => {
    const R = H(this, Kt)[o];
    R.fore instanceof TxtLayer && (R.fore.isCur = R.back.isCur = o === e);
  }), !1;
}, kr = new WeakMap(), Ni = new WeakMap(), Mi = new WeakSet(), Hn = function(t, e = "") {
  var R;
  const o = (R = t.layer) != null ? R : e;
  if (o.includes(","))
    throw "layer\u540D\u306B\u300C,\u300D\u306F\u4F7F\u3048\u307E\u305B\u3093";
  if (!(o in H(this, Kt)))
    throw "\u5C5E\u6027 layer\u3010" + o + "\u3011\u304C\u4E0D\u6B63\u3067\u3059\u3002\u30EC\u30A4\u30E4\u30FC\u304C\u3042\u308A\u307E\u305B\u3093";
  return t.layer = o;
}, Ir = new WeakMap(), wr = new WeakMap(), al = new WeakSet(), Bc = function(t) {
  const e = H(this, cr).call(this, t);
  return t.layer === H(this, Cr) && t.page === "fore" && this.recText("", !0), e.clearText(), !1;
}, ol = new WeakSet(), $c = function(t) {
  return H(this, sr).call(this, "endlink\uFF5C", H(this, cr).call(this, t)), !1;
}, ul = new WeakSet(), kc = function(t) {
  return argChk_Boolean(t, "rec_page_break", !0) && this.recText("", !0), H(this, kr) && (H(this, kr).fore.clearLay(t), H(this, kr).back.clearLay(t)), !1;
}, ll = new WeakSet(), Gc = function(t) {
  if (!t.pic)
    throw "[graph] pic\u306F\u5FC5\u9808\u3067\u3059";
  return t.text = "\uFF5C\u3000\u300Agrp\uFF5C" + JSON.stringify(t) + "\u300B", st(this, Oi, Un).call(this, t);
}, hl = new WeakSet(), Uc = function(t) {
  var e, o, R;
  return (e = t.style) != null || (t.style = "background-color: rgba(255,0,0,0.5);"), (o = t.style_hover) != null || (t.style_hover = "background-color: rgba(255,0,0,0.9);"), (R = t.style_clicked) != null || (t.style_clicked = t.style), H(this, sr).call(this, "link\uFF5C" + JSON.stringify(t), H(this, cr).call(this, t)), !1;
}, cl = new WeakSet(), Hc = function(t) {
  return t.text = `
`, st(this, Oi, Un).call(this, t);
}, fl = new WeakSet(), zc = function() {
  return this.recText(`
`), !1;
}, dl = new WeakSet(), jc = function(t) {
  var e;
  return et(this, Ir, t), this.recText((e = t.text) != null ? e : ""), !1;
}, pl = new WeakSet(), Vc = function(t) {
  var e;
  return et(this, wr, []), et(this, Ir, { text: (e = t.text) != null ? e : "" }), this.val.setVal_Nochk(
    "save",
    "const.sn.sLog",
    t.text ? `[{text:"${t.text}"}]` : "[]"
  ), !1;
}, vl = new WeakSet(), Xc = function(t) {
  const { t: e, r: o } = t;
  if (!e)
    throw "[ruby2] t\u306F\u5FC5\u9808\u3067\u3059";
  if (!o)
    throw "[ruby2] r\u306F\u5FC5\u9808\u3067\u3059";
  return t.text = "\uFF5C" + e + "\u300A" + o + "\u300B", st(this, Oi, Un).call(this, t);
}, gl = new WeakSet(), Wc = function(t) {
  return H(this, sr).call(this, "span\uFF5C" + JSON.stringify(t), H(this, cr).call(this, t)), !1;
}, _l = new WeakSet(), Yc = function(t) {
  if (!t.t)
    throw "[tcy] t\u306F\u5FC5\u9808\u3067\u3059";
  return t.text = "\uFF5C\u3000\u300Atcy\uFF5C" + JSON.stringify(t) + "\u300B", st(this, Oi, Un).call(this, t);
}, ml = new WeakSet(), qc = function(t) {
  return console.group("\u{1F95F} [dump_lay]"), st(this, Ge, Je).call(this, t.layer).forEach((e) => {
    const o = H(this, Kt)[e];
    try {
      console.info(
        `%c${o.fore.name.slice(0, -7)} %o`,
        `color:#${CmnLib.isDarkMode ? "49F" : "05A"};`,
        JSON.parse(`{"back":{${o.back.dump()}}, "fore":{${o.fore.dump()}}}`)
      );
    } catch (R) {
      console.error("dump_lay err:%o", R), console.error(`   back:${o.back.dump()}`), console.error(`   fore:${o.fore.dump()}`);
    }
  }), console.groupEnd(), !1;
}, yl = new WeakSet(), Zc = function(t) {
  const e = st(this, Mi, Hn).call(this, t, H(this, Cr)), o = argChk_Boolean(t, "enabled", !0);
  return H(this, cr).call(this, t).enabled = o, this.val.setVal_Nochk("save", "const.sn.layer." + e + ".enabled", o), !1;
}, bl = new WeakSet(), Kc = function(t) {
  var e, o, R;
  return Pages.argChk_page(t, "back"), (e = t.clicksebuf) != null || (t.clicksebuf = "SYS"), (o = t.entersebuf) != null || (t.entersebuf = "SYS"), (R = t.leavesebuf) != null || (t.leavesebuf = "SYS"), t.fn || (t.fn = this.scrItr.scriptFn), H(this, cr).call(this, t).addButton(t), this.scrItr.recodeDesign(t), !1;
}, it(LayerMng, Ai, 10);
var me, fe, El, Jc, uo, _n, ma;
class FocusMng {
  constructor() {
    it(this, El);
    it(this, _n);
    it(this, me, []);
    it(this, fe, -1);
    it(this, uo, CmnLib.debugLog ? (t) => console.log(`\u{1F47E} <FocusMng idx:${t} btn:%o`, H(this, me)[t].btn) : () => {
    });
  }
  destroy() {
    et(this, me, []), et(this, fe, -1);
  }
  add(t, e, o) {
    var D;
    if (H(this, me).findIndex((L) => L.btn === t) >= 0)
      return;
    if (t instanceof Container) {
      t.on("pointerdown", () => {
        for (let L = H(this, me).length - 1; L >= 0; --L)
          if (H(this, me)[L].btn === t) {
            et(this, fe, L);
            return;
          }
        et(this, fe, -1);
      }), H(this, me).push({ btn: t, on: e, off: o });
      return;
    }
    t.addEventListener("focus", () => {
      for (let L = H(this, me).length - 1; L >= 0; --L)
        if (H(this, me)[L].btn === t) {
          et(this, fe, L);
          return;
        }
      et(this, fe, -1);
    });
    let R = (L) => {
    }, N = t.localName === "button" || t.localName === "a" ? (L) => !L.isTrusted && L.key === "Enter" : (L) => L.key === "Enter";
    const M = t;
    switch ((D = M.type) != null ? D : "") {
      case "checkbox":
        R = () => M.checked = !M.checked;
        break;
      case "":
        t.querySelectorAll("input[type]").length > 0 && (R = (L) => st(this, El, Jc).call(this, t, L.key), N = () => !1);
        break;
      case "range":
        R = (L) => {
          L.isTrusted || (L.key === "ArrowUp" ? M.stepUp() : M.stepDown());
        };
        break;
      case "text":
      case "textarea":
        R = (L) => {
          var $;
          if (L.isTrusted)
            return;
          let B = (($ = M.selectionStart) != null ? $ : 0) + (L.key === "ArrowUp" ? -1 : 1);
          B < 0 && (B = 0), M.setSelectionRange(B, B);
        };
        break;
    }
    t.addEventListener("keydown", (L) => {
      if (!(L.key !== "ArrowUp" && L.key !== "ArrowDown" && L.key !== "Enter")) {
        if (L.stopPropagation(), L.stopImmediatePropagation(), N(L)) {
          t.dispatchEvent(new MouseEvent("click"));
          return;
        }
        R(L);
      }
    }, { passive: !0 }), t.hasAttribute("tabindex") || (t.tabIndex = 0), H(this, me).push({ btn: t, on: e, off: o });
  }
  remove(t) {
    const e = H(this, me).findIndex((o) => o.btn === t);
    e < 0 || (H(this, me).splice(e, 1), H(this, me).length === 0 ? et(this, fe, -1) : e <= H(this, fe) && --Re(this, fe)._);
  }
  isFocus(t) {
    return H(this, fe) < 0 ? !1 : H(this, me)[H(this, fe)].btn === t;
  }
  prev() {
    st(this, _n, ma).call(this);
    const t = H(this, me).length;
    if (t !== 0) {
      --Re(this, fe)._ < 0 && et(this, fe, t - 1);
      for (let e = t; e >= 1; --e) {
        const o = (H(this, fe) + e) % t;
        if (H(this, me)[o].on()) {
          et(this, fe, o), H(this, uo).call(this, o);
          return;
        }
      }
      et(this, fe, -1);
    }
  }
  next() {
    st(this, _n, ma).call(this);
    const t = H(this, me).length;
    if (t !== 0) {
      ++Re(this, fe)._ >= t && et(this, fe, 0);
      for (let e = 0; e < t; ++e) {
        const o = (H(this, fe) + e) % t;
        if (H(this, me)[o].on()) {
          et(this, fe, o), H(this, uo).call(this, o);
          return;
        }
      }
      et(this, fe, -1);
    }
  }
  getFocus() {
    if (H(this, fe) < 0)
      return;
    st(this, _n, ma).call(this), H(this, fe) >= H(this, me).length && et(this, fe, 0);
    const t = H(this, me)[H(this, fe)];
    return t.on() ? t.btn : void 0;
  }
  blur() {
    st(this, _n, ma).call(this), et(this, fe, -1), globalThis.focus();
  }
}
me = new WeakMap(), fe = new WeakMap(), El = new WeakSet(), Jc = function(t, e) {
  const o = t.querySelectorAll("input[type]"), R = o.length;
  for (let N = 0; N < R; ++N)
    if (!!o[N].checked) {
      o[(N + R + (e === "ArrowUp" ? -1 : 1)) % R].checked = !0;
      break;
    }
}, uo = new WeakMap(), _n = new WeakSet(), ma = function() {
  for (let t = H(this, me).length - 1; t >= 0; --t) {
    const e = H(this, me)[t];
    !(e.btn instanceof Container) || e.btn.parent ? e.off() : H(this, me).splice(t, 1);
  }
};
var top = "top", bottom = "bottom", right = "right", left = "left", auto = "auto", basePlacements = [top, bottom, right, left], start = "start", end = "end", clippingParents = "clippingParents", viewport = "viewport", popper = "popper", reference = "reference", variationPlacements = /* @__PURE__ */ basePlacements.reduce(function(n, t) {
  return n.concat([t + "-" + start, t + "-" + end]);
}, []), placements = /* @__PURE__ */ [].concat(basePlacements, [auto]).reduce(function(n, t) {
  return n.concat([t, t + "-" + start, t + "-" + end]);
}, []), beforeRead = "beforeRead", read$6 = "read", afterRead = "afterRead", beforeMain = "beforeMain", main$1 = "main", afterMain = "afterMain", beforeWrite = "beforeWrite", write$6 = "write", afterWrite = "afterWrite", modifierPhases = [beforeRead, read$6, afterRead, beforeMain, main$1, afterMain, beforeWrite, write$6, afterWrite];
function getNodeName(n) {
  return n ? (n.nodeName || "").toLowerCase() : null;
}
function getWindow(n) {
  if (n == null)
    return window;
  if (n.toString() !== "[object Window]") {
    var t = n.ownerDocument;
    return t && t.defaultView || window;
  }
  return n;
}
function isElement(n) {
  var t = getWindow(n).Element;
  return n instanceof t || n instanceof Element;
}
function isHTMLElement(n) {
  var t = getWindow(n).HTMLElement;
  return n instanceof t || n instanceof HTMLElement;
}
function isShadowRoot(n) {
  if (typeof ShadowRoot > "u")
    return !1;
  var t = getWindow(n).ShadowRoot;
  return n instanceof t || n instanceof ShadowRoot;
}
function applyStyles(n) {
  var t = n.state;
  Object.keys(t.elements).forEach(function(e) {
    var o = t.styles[e] || {}, R = t.attributes[e] || {}, N = t.elements[e];
    !isHTMLElement(N) || !getNodeName(N) || (Object.assign(N.style, o), Object.keys(R).forEach(function(M) {
      var D = R[M];
      D === !1 ? N.removeAttribute(M) : N.setAttribute(M, D === !0 ? "" : D);
    }));
  });
}
function effect$2(n) {
  var t = n.state, e = {
    popper: {
      position: t.options.strategy,
      left: "0",
      top: "0",
      margin: "0"
    },
    arrow: {
      position: "absolute"
    },
    reference: {}
  };
  return Object.assign(t.elements.popper.style, e.popper), t.styles = e, t.elements.arrow && Object.assign(t.elements.arrow.style, e.arrow), function() {
    Object.keys(t.elements).forEach(function(o) {
      var R = t.elements[o], N = t.attributes[o] || {}, M = Object.keys(t.styles.hasOwnProperty(o) ? t.styles[o] : e[o]), D = M.reduce(function(L, B) {
        return L[B] = "", L;
      }, {});
      !isHTMLElement(R) || !getNodeName(R) || (Object.assign(R.style, D), Object.keys(N).forEach(function(L) {
        R.removeAttribute(L);
      }));
    });
  };
}
const applyStyles$1 = {
  name: "applyStyles",
  enabled: !0,
  phase: "write",
  fn: applyStyles,
  effect: effect$2,
  requires: ["computeStyles"]
};
function getBasePlacement(n) {
  return n.split("-")[0];
}
var max = Math.max, min = Math.min, round = Math.round;
function getUAString() {
  var n = navigator.userAgentData;
  return n != null && n.brands ? n.brands.map(function(t) {
    return t.brand + "/" + t.version;
  }).join(" ") : navigator.userAgent;
}
function isLayoutViewport() {
  return !/^((?!chrome|android).)*safari/i.test(getUAString());
}
function getBoundingClientRect(n, t, e) {
  t === void 0 && (t = !1), e === void 0 && (e = !1);
  var o = n.getBoundingClientRect(), R = 1, N = 1;
  t && isHTMLElement(n) && (R = n.offsetWidth > 0 && round(o.width) / n.offsetWidth || 1, N = n.offsetHeight > 0 && round(o.height) / n.offsetHeight || 1);
  var M = isElement(n) ? getWindow(n) : window, D = M.visualViewport, L = !isLayoutViewport() && e, B = (o.left + (L && D ? D.offsetLeft : 0)) / R, $ = (o.top + (L && D ? D.offsetTop : 0)) / N, k = o.width / R, U = o.height / N;
  return {
    width: k,
    height: U,
    top: $,
    right: B + k,
    bottom: $ + U,
    left: B,
    x: B,
    y: $
  };
}
function getLayoutRect(n) {
  var t = getBoundingClientRect(n), e = n.offsetWidth, o = n.offsetHeight;
  return Math.abs(t.width - e) <= 1 && (e = t.width), Math.abs(t.height - o) <= 1 && (o = t.height), {
    x: n.offsetLeft,
    y: n.offsetTop,
    width: e,
    height: o
  };
}
function contains(n, t) {
  var e = t.getRootNode && t.getRootNode();
  if (n.contains(t))
    return !0;
  if (e && isShadowRoot(e)) {
    var o = t;
    do {
      if (o && n.isSameNode(o))
        return !0;
      o = o.parentNode || o.host;
    } while (o);
  }
  return !1;
}
function getComputedStyle$1(n) {
  return getWindow(n).getComputedStyle(n);
}
function isTableElement(n) {
  return ["table", "td", "th"].indexOf(getNodeName(n)) >= 0;
}
function getDocumentElement(n) {
  return ((isElement(n) ? n.ownerDocument : n.document) || window.document).documentElement;
}
function getParentNode(n) {
  return getNodeName(n) === "html" ? n : n.assignedSlot || n.parentNode || (isShadowRoot(n) ? n.host : null) || getDocumentElement(n);
}
function getTrueOffsetParent(n) {
  return !isHTMLElement(n) || getComputedStyle$1(n).position === "fixed" ? null : n.offsetParent;
}
function getContainingBlock(n) {
  var t = /firefox/i.test(getUAString()), e = /Trident/i.test(getUAString());
  if (e && isHTMLElement(n)) {
    var o = getComputedStyle$1(n);
    if (o.position === "fixed")
      return null;
  }
  var R = getParentNode(n);
  for (isShadowRoot(R) && (R = R.host); isHTMLElement(R) && ["html", "body"].indexOf(getNodeName(R)) < 0; ) {
    var N = getComputedStyle$1(R);
    if (N.transform !== "none" || N.perspective !== "none" || N.contain === "paint" || ["transform", "perspective"].indexOf(N.willChange) !== -1 || t && N.willChange === "filter" || t && N.filter && N.filter !== "none")
      return R;
    R = R.parentNode;
  }
  return null;
}
function getOffsetParent(n) {
  for (var t = getWindow(n), e = getTrueOffsetParent(n); e && isTableElement(e) && getComputedStyle$1(e).position === "static"; )
    e = getTrueOffsetParent(e);
  return e && (getNodeName(e) === "html" || getNodeName(e) === "body" && getComputedStyle$1(e).position === "static") ? t : e || getContainingBlock(n) || t;
}
function getMainAxisFromPlacement(n) {
  return ["top", "bottom"].indexOf(n) >= 0 ? "x" : "y";
}
function within(n, t, e) {
  return max(n, min(t, e));
}
function withinMaxClamp(n, t, e) {
  var o = within(n, t, e);
  return o > e ? e : o;
}
function getFreshSideObject() {
  return {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0
  };
}
function mergePaddingObject(n) {
  return Object.assign({}, getFreshSideObject(), n);
}
function expandToHashMap(n, t) {
  return t.reduce(function(e, o) {
    return e[o] = n, e;
  }, {});
}
var toPaddingObject = function(t, e) {
  return t = typeof t == "function" ? t(Object.assign({}, e.rects, {
    placement: e.placement
  })) : t, mergePaddingObject(typeof t != "number" ? t : expandToHashMap(t, basePlacements));
};
function arrow(n) {
  var t, e = n.state, o = n.name, R = n.options, N = e.elements.arrow, M = e.modifiersData.popperOffsets, D = getBasePlacement(e.placement), L = getMainAxisFromPlacement(D), B = [left, right].indexOf(D) >= 0, $ = B ? "height" : "width";
  if (!(!N || !M)) {
    var k = toPaddingObject(R.padding, e), U = getLayoutRect(N), z = L === "y" ? top : left, X = L === "y" ? bottom : right, V = e.rects.reference[$] + e.rects.reference[L] - M[L] - e.rects.popper[$], W = M[L] - e.rects.reference[L], Y = getOffsetParent(N), q = Y ? L === "y" ? Y.clientHeight || 0 : Y.clientWidth || 0 : 0, Z = V / 2 - W / 2, J = k[z], Q = q - U[$] - k[X], K = q / 2 - U[$] / 2 + Z, rt = within(J, K, Q), tt = L;
    e.modifiersData[o] = (t = {}, t[tt] = rt, t.centerOffset = rt - K, t);
  }
}
function effect$1(n) {
  var t = n.state, e = n.options, o = e.element, R = o === void 0 ? "[data-popper-arrow]" : o;
  if (R != null && !(typeof R == "string" && (R = t.elements.popper.querySelector(R), !R))) {
    if (process.env.NODE_ENV !== "production" && (isHTMLElement(R) || console.error(['Popper: "arrow" element must be an HTMLElement (not an SVGElement).', "To use an SVG arrow, wrap it in an HTMLElement that will be used as", "the arrow."].join(" "))), !contains(t.elements.popper, R)) {
      process.env.NODE_ENV !== "production" && console.error(['Popper: "arrow" modifier\'s `element` must be a child of the popper', "element."].join(" "));
      return;
    }
    t.elements.arrow = R;
  }
}
const arrow$1 = {
  name: "arrow",
  enabled: !0,
  phase: "main",
  fn: arrow,
  effect: effect$1,
  requires: ["popperOffsets"],
  requiresIfExists: ["preventOverflow"]
};
function getVariation(n) {
  return n.split("-")[1];
}
var unsetSides = {
  top: "auto",
  right: "auto",
  bottom: "auto",
  left: "auto"
};
function roundOffsetsByDPR(n) {
  var t = n.x, e = n.y, o = window, R = o.devicePixelRatio || 1;
  return {
    x: round(t * R) / R || 0,
    y: round(e * R) / R || 0
  };
}
function mapToStyles(n) {
  var t, e = n.popper, o = n.popperRect, R = n.placement, N = n.variation, M = n.offsets, D = n.position, L = n.gpuAcceleration, B = n.adaptive, $ = n.roundOffsets, k = n.isFixed, U = M.x, z = U === void 0 ? 0 : U, X = M.y, V = X === void 0 ? 0 : X, W = typeof $ == "function" ? $({
    x: z,
    y: V
  }) : {
    x: z,
    y: V
  };
  z = W.x, V = W.y;
  var Y = M.hasOwnProperty("x"), q = M.hasOwnProperty("y"), Z = left, J = top, Q = window;
  if (B) {
    var K = getOffsetParent(e), rt = "clientHeight", tt = "clientWidth";
    if (K === getWindow(e) && (K = getDocumentElement(e), getComputedStyle$1(K).position !== "static" && D === "absolute" && (rt = "scrollHeight", tt = "scrollWidth")), K = K, R === top || (R === left || R === right) && N === end) {
      J = bottom;
      var nt = k && K === Q && Q.visualViewport ? Q.visualViewport.height : K[rt];
      V -= nt - o.height, V *= L ? 1 : -1;
    }
    if (R === left || (R === top || R === bottom) && N === end) {
      Z = right;
      var at = k && K === Q && Q.visualViewport ? Q.visualViewport.width : K[tt];
      z -= at - o.width, z *= L ? 1 : -1;
    }
  }
  var lt = Object.assign({
    position: D
  }, B && unsetSides), ut = $ === !0 ? roundOffsetsByDPR({
    x: z,
    y: V
  }) : {
    x: z,
    y: V
  };
  if (z = ut.x, V = ut.y, L) {
    var dt;
    return Object.assign({}, lt, (dt = {}, dt[J] = q ? "0" : "", dt[Z] = Y ? "0" : "", dt.transform = (Q.devicePixelRatio || 1) <= 1 ? "translate(" + z + "px, " + V + "px)" : "translate3d(" + z + "px, " + V + "px, 0)", dt));
  }
  return Object.assign({}, lt, (t = {}, t[J] = q ? V + "px" : "", t[Z] = Y ? z + "px" : "", t.transform = "", t));
}
function computeStyles(n) {
  var t = n.state, e = n.options, o = e.gpuAcceleration, R = o === void 0 ? !0 : o, N = e.adaptive, M = N === void 0 ? !0 : N, D = e.roundOffsets, L = D === void 0 ? !0 : D;
  if (process.env.NODE_ENV !== "production") {
    var B = getComputedStyle$1(t.elements.popper).transitionProperty || "";
    M && ["transform", "top", "right", "bottom", "left"].some(function(k) {
      return B.indexOf(k) >= 0;
    }) && console.warn(["Popper: Detected CSS transitions on at least one of the following", 'CSS properties: "transform", "top", "right", "bottom", "left".', `

`, 'Disable the "computeStyles" modifier\'s `adaptive` option to allow', "for smooth transitions, or remove these properties from the CSS", "transition declaration on the popper element if only transitioning", "opacity or background-color for example.", `

`, "We recommend using the popper element as a wrapper around an inner", "element that can have any CSS property transitioned for animations."].join(" "));
  }
  var $ = {
    placement: getBasePlacement(t.placement),
    variation: getVariation(t.placement),
    popper: t.elements.popper,
    popperRect: t.rects.popper,
    gpuAcceleration: R,
    isFixed: t.options.strategy === "fixed"
  };
  t.modifiersData.popperOffsets != null && (t.styles.popper = Object.assign({}, t.styles.popper, mapToStyles(Object.assign({}, $, {
    offsets: t.modifiersData.popperOffsets,
    position: t.options.strategy,
    adaptive: M,
    roundOffsets: L
  })))), t.modifiersData.arrow != null && (t.styles.arrow = Object.assign({}, t.styles.arrow, mapToStyles(Object.assign({}, $, {
    offsets: t.modifiersData.arrow,
    position: "absolute",
    adaptive: !1,
    roundOffsets: L
  })))), t.attributes.popper = Object.assign({}, t.attributes.popper, {
    "data-popper-placement": t.placement
  });
}
const computeStyles$1 = {
  name: "computeStyles",
  enabled: !0,
  phase: "beforeWrite",
  fn: computeStyles,
  data: {}
};
var passive = {
  passive: !0
};
function effect(n) {
  var t = n.state, e = n.instance, o = n.options, R = o.scroll, N = R === void 0 ? !0 : R, M = o.resize, D = M === void 0 ? !0 : M, L = getWindow(t.elements.popper), B = [].concat(t.scrollParents.reference, t.scrollParents.popper);
  return N && B.forEach(function($) {
    $.addEventListener("scroll", e.update, passive);
  }), D && L.addEventListener("resize", e.update, passive), function() {
    N && B.forEach(function($) {
      $.removeEventListener("scroll", e.update, passive);
    }), D && L.removeEventListener("resize", e.update, passive);
  };
}
const eventListeners = {
  name: "eventListeners",
  enabled: !0,
  phase: "write",
  fn: function() {
  },
  effect,
  data: {}
};
var hash$1 = {
  left: "right",
  right: "left",
  bottom: "top",
  top: "bottom"
};
function getOppositePlacement(n) {
  return n.replace(/left|right|bottom|top/g, function(t) {
    return hash$1[t];
  });
}
var hash = {
  start: "end",
  end: "start"
};
function getOppositeVariationPlacement(n) {
  return n.replace(/start|end/g, function(t) {
    return hash[t];
  });
}
function getWindowScroll(n) {
  var t = getWindow(n), e = t.pageXOffset, o = t.pageYOffset;
  return {
    scrollLeft: e,
    scrollTop: o
  };
}
function getWindowScrollBarX(n) {
  return getBoundingClientRect(getDocumentElement(n)).left + getWindowScroll(n).scrollLeft;
}
function getViewportRect(n, t) {
  var e = getWindow(n), o = getDocumentElement(n), R = e.visualViewport, N = o.clientWidth, M = o.clientHeight, D = 0, L = 0;
  if (R) {
    N = R.width, M = R.height;
    var B = isLayoutViewport();
    (B || !B && t === "fixed") && (D = R.offsetLeft, L = R.offsetTop);
  }
  return {
    width: N,
    height: M,
    x: D + getWindowScrollBarX(n),
    y: L
  };
}
function getDocumentRect(n) {
  var t, e = getDocumentElement(n), o = getWindowScroll(n), R = (t = n.ownerDocument) == null ? void 0 : t.body, N = max(e.scrollWidth, e.clientWidth, R ? R.scrollWidth : 0, R ? R.clientWidth : 0), M = max(e.scrollHeight, e.clientHeight, R ? R.scrollHeight : 0, R ? R.clientHeight : 0), D = -o.scrollLeft + getWindowScrollBarX(n), L = -o.scrollTop;
  return getComputedStyle$1(R || e).direction === "rtl" && (D += max(e.clientWidth, R ? R.clientWidth : 0) - N), {
    width: N,
    height: M,
    x: D,
    y: L
  };
}
function isScrollParent(n) {
  var t = getComputedStyle$1(n), e = t.overflow, o = t.overflowX, R = t.overflowY;
  return /auto|scroll|overlay|hidden/.test(e + R + o);
}
function getScrollParent(n) {
  return ["html", "body", "#document"].indexOf(getNodeName(n)) >= 0 ? n.ownerDocument.body : isHTMLElement(n) && isScrollParent(n) ? n : getScrollParent(getParentNode(n));
}
function listScrollParents(n, t) {
  var e;
  t === void 0 && (t = []);
  var o = getScrollParent(n), R = o === ((e = n.ownerDocument) == null ? void 0 : e.body), N = getWindow(o), M = R ? [N].concat(N.visualViewport || [], isScrollParent(o) ? o : []) : o, D = t.concat(M);
  return R ? D : D.concat(listScrollParents(getParentNode(M)));
}
function rectToClientRect(n) {
  return Object.assign({}, n, {
    left: n.x,
    top: n.y,
    right: n.x + n.width,
    bottom: n.y + n.height
  });
}
function getInnerBoundingClientRect(n, t) {
  var e = getBoundingClientRect(n, !1, t === "fixed");
  return e.top = e.top + n.clientTop, e.left = e.left + n.clientLeft, e.bottom = e.top + n.clientHeight, e.right = e.left + n.clientWidth, e.width = n.clientWidth, e.height = n.clientHeight, e.x = e.left, e.y = e.top, e;
}
function getClientRectFromMixedType(n, t, e) {
  return t === viewport ? rectToClientRect(getViewportRect(n, e)) : isElement(t) ? getInnerBoundingClientRect(t, e) : rectToClientRect(getDocumentRect(getDocumentElement(n)));
}
function getClippingParents(n) {
  var t = listScrollParents(getParentNode(n)), e = ["absolute", "fixed"].indexOf(getComputedStyle$1(n).position) >= 0, o = e && isHTMLElement(n) ? getOffsetParent(n) : n;
  return isElement(o) ? t.filter(function(R) {
    return isElement(R) && contains(R, o) && getNodeName(R) !== "body";
  }) : [];
}
function getClippingRect(n, t, e, o) {
  var R = t === "clippingParents" ? getClippingParents(n) : [].concat(t), N = [].concat(R, [e]), M = N[0], D = N.reduce(function(L, B) {
    var $ = getClientRectFromMixedType(n, B, o);
    return L.top = max($.top, L.top), L.right = min($.right, L.right), L.bottom = min($.bottom, L.bottom), L.left = max($.left, L.left), L;
  }, getClientRectFromMixedType(n, M, o));
  return D.width = D.right - D.left, D.height = D.bottom - D.top, D.x = D.left, D.y = D.top, D;
}
function computeOffsets(n) {
  var t = n.reference, e = n.element, o = n.placement, R = o ? getBasePlacement(o) : null, N = o ? getVariation(o) : null, M = t.x + t.width / 2 - e.width / 2, D = t.y + t.height / 2 - e.height / 2, L;
  switch (R) {
    case top:
      L = {
        x: M,
        y: t.y - e.height
      };
      break;
    case bottom:
      L = {
        x: M,
        y: t.y + t.height
      };
      break;
    case right:
      L = {
        x: t.x + t.width,
        y: D
      };
      break;
    case left:
      L = {
        x: t.x - e.width,
        y: D
      };
      break;
    default:
      L = {
        x: t.x,
        y: t.y
      };
  }
  var B = R ? getMainAxisFromPlacement(R) : null;
  if (B != null) {
    var $ = B === "y" ? "height" : "width";
    switch (N) {
      case start:
        L[B] = L[B] - (t[$] / 2 - e[$] / 2);
        break;
      case end:
        L[B] = L[B] + (t[$] / 2 - e[$] / 2);
        break;
    }
  }
  return L;
}
function detectOverflow(n, t) {
  t === void 0 && (t = {});
  var e = t, o = e.placement, R = o === void 0 ? n.placement : o, N = e.strategy, M = N === void 0 ? n.strategy : N, D = e.boundary, L = D === void 0 ? clippingParents : D, B = e.rootBoundary, $ = B === void 0 ? viewport : B, k = e.elementContext, U = k === void 0 ? popper : k, z = e.altBoundary, X = z === void 0 ? !1 : z, V = e.padding, W = V === void 0 ? 0 : V, Y = mergePaddingObject(typeof W != "number" ? W : expandToHashMap(W, basePlacements)), q = U === popper ? reference : popper, Z = n.rects.popper, J = n.elements[X ? q : U], Q = getClippingRect(isElement(J) ? J : J.contextElement || getDocumentElement(n.elements.popper), L, $, M), K = getBoundingClientRect(n.elements.reference), rt = computeOffsets({
    reference: K,
    element: Z,
    strategy: "absolute",
    placement: R
  }), tt = rectToClientRect(Object.assign({}, Z, rt)), nt = U === popper ? tt : K, at = {
    top: Q.top - nt.top + Y.top,
    bottom: nt.bottom - Q.bottom + Y.bottom,
    left: Q.left - nt.left + Y.left,
    right: nt.right - Q.right + Y.right
  }, lt = n.modifiersData.offset;
  if (U === popper && lt) {
    var ut = lt[R];
    Object.keys(at).forEach(function(dt) {
      var yt = [right, bottom].indexOf(dt) >= 0 ? 1 : -1, pt = [top, bottom].indexOf(dt) >= 0 ? "y" : "x";
      at[dt] += ut[pt] * yt;
    });
  }
  return at;
}
function computeAutoPlacement(n, t) {
  t === void 0 && (t = {});
  var e = t, o = e.placement, R = e.boundary, N = e.rootBoundary, M = e.padding, D = e.flipVariations, L = e.allowedAutoPlacements, B = L === void 0 ? placements : L, $ = getVariation(o), k = $ ? D ? variationPlacements : variationPlacements.filter(function(X) {
    return getVariation(X) === $;
  }) : basePlacements, U = k.filter(function(X) {
    return B.indexOf(X) >= 0;
  });
  U.length === 0 && (U = k, process.env.NODE_ENV !== "production" && console.error(["Popper: The `allowedAutoPlacements` option did not allow any", "placements. Ensure the `placement` option matches the variation", "of the allowed placements.", 'For example, "auto" cannot be used to allow "bottom-start".', 'Use "auto-start" instead.'].join(" ")));
  var z = U.reduce(function(X, V) {
    return X[V] = detectOverflow(n, {
      placement: V,
      boundary: R,
      rootBoundary: N,
      padding: M
    })[getBasePlacement(V)], X;
  }, {});
  return Object.keys(z).sort(function(X, V) {
    return z[X] - z[V];
  });
}
function getExpandedFallbackPlacements(n) {
  if (getBasePlacement(n) === auto)
    return [];
  var t = getOppositePlacement(n);
  return [getOppositeVariationPlacement(n), t, getOppositeVariationPlacement(t)];
}
function flip(n) {
  var t = n.state, e = n.options, o = n.name;
  if (!t.modifiersData[o]._skip) {
    for (var R = e.mainAxis, N = R === void 0 ? !0 : R, M = e.altAxis, D = M === void 0 ? !0 : M, L = e.fallbackPlacements, B = e.padding, $ = e.boundary, k = e.rootBoundary, U = e.altBoundary, z = e.flipVariations, X = z === void 0 ? !0 : z, V = e.allowedAutoPlacements, W = t.options.placement, Y = getBasePlacement(W), q = Y === W, Z = L || (q || !X ? [getOppositePlacement(W)] : getExpandedFallbackPlacements(W)), J = [W].concat(Z).reduce(function(wt, Mt) {
      return wt.concat(getBasePlacement(Mt) === auto ? computeAutoPlacement(t, {
        placement: Mt,
        boundary: $,
        rootBoundary: k,
        padding: B,
        flipVariations: X,
        allowedAutoPlacements: V
      }) : Mt);
    }, []), Q = t.rects.reference, K = t.rects.popper, rt = /* @__PURE__ */ new Map(), tt = !0, nt = J[0], at = 0; at < J.length; at++) {
      var lt = J[at], ut = getBasePlacement(lt), dt = getVariation(lt) === start, yt = [top, bottom].indexOf(ut) >= 0, pt = yt ? "width" : "height", gt = detectOverflow(t, {
        placement: lt,
        boundary: $,
        rootBoundary: k,
        altBoundary: U,
        padding: B
      }), xt = yt ? dt ? right : left : dt ? bottom : top;
      Q[pt] > K[pt] && (xt = getOppositePlacement(xt));
      var Lt = getOppositePlacement(xt), mt = [];
      if (N && mt.push(gt[ut] <= 0), D && mt.push(gt[xt] <= 0, gt[Lt] <= 0), mt.every(function(wt) {
        return wt;
      })) {
        nt = lt, tt = !1;
        break;
      }
      rt.set(lt, mt);
    }
    if (tt)
      for (var ct = X ? 3 : 1, vt = function(Mt) {
        var ht = J.find(function($t) {
          var At = rt.get($t);
          if (At)
            return At.slice(0, Mt).every(function(kt) {
              return kt;
            });
        });
        if (ht)
          return nt = ht, "break";
      }, Tt = ct; Tt > 0; Tt--) {
        var Pt = vt(Tt);
        if (Pt === "break")
          break;
      }
    t.placement !== nt && (t.modifiersData[o]._skip = !0, t.placement = nt, t.reset = !0);
  }
}
const flip$1 = {
  name: "flip",
  enabled: !0,
  phase: "main",
  fn: flip,
  requiresIfExists: ["offset"],
  data: {
    _skip: !1
  }
};
function getSideOffsets(n, t, e) {
  return e === void 0 && (e = {
    x: 0,
    y: 0
  }), {
    top: n.top - t.height - e.y,
    right: n.right - t.width + e.x,
    bottom: n.bottom - t.height + e.y,
    left: n.left - t.width - e.x
  };
}
function isAnySideFullyClipped(n) {
  return [top, right, bottom, left].some(function(t) {
    return n[t] >= 0;
  });
}
function hide(n) {
  var t = n.state, e = n.name, o = t.rects.reference, R = t.rects.popper, N = t.modifiersData.preventOverflow, M = detectOverflow(t, {
    elementContext: "reference"
  }), D = detectOverflow(t, {
    altBoundary: !0
  }), L = getSideOffsets(M, o), B = getSideOffsets(D, R, N), $ = isAnySideFullyClipped(L), k = isAnySideFullyClipped(B);
  t.modifiersData[e] = {
    referenceClippingOffsets: L,
    popperEscapeOffsets: B,
    isReferenceHidden: $,
    hasPopperEscaped: k
  }, t.attributes.popper = Object.assign({}, t.attributes.popper, {
    "data-popper-reference-hidden": $,
    "data-popper-escaped": k
  });
}
const hide$1 = {
  name: "hide",
  enabled: !0,
  phase: "main",
  requiresIfExists: ["preventOverflow"],
  fn: hide
};
function distanceAndSkiddingToXY(n, t, e) {
  var o = getBasePlacement(n), R = [left, top].indexOf(o) >= 0 ? -1 : 1, N = typeof e == "function" ? e(Object.assign({}, t, {
    placement: n
  })) : e, M = N[0], D = N[1];
  return M = M || 0, D = (D || 0) * R, [left, right].indexOf(o) >= 0 ? {
    x: D,
    y: M
  } : {
    x: M,
    y: D
  };
}
function offset(n) {
  var t = n.state, e = n.options, o = n.name, R = e.offset, N = R === void 0 ? [0, 0] : R, M = placements.reduce(function($, k) {
    return $[k] = distanceAndSkiddingToXY(k, t.rects, N), $;
  }, {}), D = M[t.placement], L = D.x, B = D.y;
  t.modifiersData.popperOffsets != null && (t.modifiersData.popperOffsets.x += L, t.modifiersData.popperOffsets.y += B), t.modifiersData[o] = M;
}
const offset$1 = {
  name: "offset",
  enabled: !0,
  phase: "main",
  requires: ["popperOffsets"],
  fn: offset
};
function popperOffsets(n) {
  var t = n.state, e = n.name;
  t.modifiersData[e] = computeOffsets({
    reference: t.rects.reference,
    element: t.rects.popper,
    strategy: "absolute",
    placement: t.placement
  });
}
const popperOffsets$1 = {
  name: "popperOffsets",
  enabled: !0,
  phase: "read",
  fn: popperOffsets,
  data: {}
};
function getAltAxis(n) {
  return n === "x" ? "y" : "x";
}
function preventOverflow(n) {
  var t = n.state, e = n.options, o = n.name, R = e.mainAxis, N = R === void 0 ? !0 : R, M = e.altAxis, D = M === void 0 ? !1 : M, L = e.boundary, B = e.rootBoundary, $ = e.altBoundary, k = e.padding, U = e.tether, z = U === void 0 ? !0 : U, X = e.tetherOffset, V = X === void 0 ? 0 : X, W = detectOverflow(t, {
    boundary: L,
    rootBoundary: B,
    padding: k,
    altBoundary: $
  }), Y = getBasePlacement(t.placement), q = getVariation(t.placement), Z = !q, J = getMainAxisFromPlacement(Y), Q = getAltAxis(J), K = t.modifiersData.popperOffsets, rt = t.rects.reference, tt = t.rects.popper, nt = typeof V == "function" ? V(Object.assign({}, t.rects, {
    placement: t.placement
  })) : V, at = typeof nt == "number" ? {
    mainAxis: nt,
    altAxis: nt
  } : Object.assign({
    mainAxis: 0,
    altAxis: 0
  }, nt), lt = t.modifiersData.offset ? t.modifiersData.offset[t.placement] : null, ut = {
    x: 0,
    y: 0
  };
  if (!!K) {
    if (N) {
      var dt, yt = J === "y" ? top : left, pt = J === "y" ? bottom : right, gt = J === "y" ? "height" : "width", xt = K[J], Lt = xt + W[yt], mt = xt - W[pt], ct = z ? -tt[gt] / 2 : 0, vt = q === start ? rt[gt] : tt[gt], Tt = q === start ? -tt[gt] : -rt[gt], Pt = t.elements.arrow, wt = z && Pt ? getLayoutRect(Pt) : {
        width: 0,
        height: 0
      }, Mt = t.modifiersData["arrow#persistent"] ? t.modifiersData["arrow#persistent"].padding : getFreshSideObject(), ht = Mt[yt], $t = Mt[pt], At = within(0, rt[gt], wt[gt]), kt = Z ? rt[gt] / 2 - ct - At - ht - at.mainAxis : vt - At - ht - at.mainAxis, Ot = Z ? -rt[gt] / 2 + ct + At + $t + at.mainAxis : Tt + At + $t + at.mainAxis, _t = t.elements.arrow && getOffsetParent(t.elements.arrow), Gt = _t ? J === "y" ? _t.clientTop || 0 : _t.clientLeft || 0 : 0, St = (dt = lt == null ? void 0 : lt[J]) != null ? dt : 0, Et = xt + kt - St - Gt, Rt = xt + Ot - St, Dt = within(z ? min(Lt, Et) : Lt, xt, z ? max(mt, Rt) : mt);
      K[J] = Dt, ut[J] = Dt - xt;
    }
    if (D) {
      var Ct, Zt = J === "x" ? top : left, Yt = J === "x" ? bottom : right, se = K[Q], xe = Q === "y" ? "height" : "width", Oe = se + W[Zt], Qt = se - W[Yt], Ie = [top, left].indexOf(Y) !== -1, de = (Ct = lt == null ? void 0 : lt[Q]) != null ? Ct : 0, ue = Ie ? Oe : se - rt[xe] - tt[xe] - de + at.altAxis, ae = Ie ? se + rt[xe] + tt[xe] - de - at.altAxis : Qt, Jt = z && Ie ? withinMaxClamp(ue, se, ae) : within(z ? ue : Oe, se, z ? ae : Qt);
      K[Q] = Jt, ut[Q] = Jt - se;
    }
    t.modifiersData[o] = ut;
  }
}
const preventOverflow$1 = {
  name: "preventOverflow",
  enabled: !0,
  phase: "main",
  fn: preventOverflow,
  requiresIfExists: ["offset"]
};
function getHTMLElementScroll(n) {
  return {
    scrollLeft: n.scrollLeft,
    scrollTop: n.scrollTop
  };
}
function getNodeScroll(n) {
  return n === getWindow(n) || !isHTMLElement(n) ? getWindowScroll(n) : getHTMLElementScroll(n);
}
function isElementScaled(n) {
  var t = n.getBoundingClientRect(), e = round(t.width) / n.offsetWidth || 1, o = round(t.height) / n.offsetHeight || 1;
  return e !== 1 || o !== 1;
}
function getCompositeRect(n, t, e) {
  e === void 0 && (e = !1);
  var o = isHTMLElement(t), R = isHTMLElement(t) && isElementScaled(t), N = getDocumentElement(t), M = getBoundingClientRect(n, R, e), D = {
    scrollLeft: 0,
    scrollTop: 0
  }, L = {
    x: 0,
    y: 0
  };
  return (o || !o && !e) && ((getNodeName(t) !== "body" || isScrollParent(N)) && (D = getNodeScroll(t)), isHTMLElement(t) ? (L = getBoundingClientRect(t, !0), L.x += t.clientLeft, L.y += t.clientTop) : N && (L.x = getWindowScrollBarX(N))), {
    x: M.left + D.scrollLeft - L.x,
    y: M.top + D.scrollTop - L.y,
    width: M.width,
    height: M.height
  };
}
function order(n) {
  var t = /* @__PURE__ */ new Map(), e = /* @__PURE__ */ new Set(), o = [];
  n.forEach(function(N) {
    t.set(N.name, N);
  });
  function R(N) {
    e.add(N.name);
    var M = [].concat(N.requires || [], N.requiresIfExists || []);
    M.forEach(function(D) {
      if (!e.has(D)) {
        var L = t.get(D);
        L && R(L);
      }
    }), o.push(N);
  }
  return n.forEach(function(N) {
    e.has(N.name) || R(N);
  }), o;
}
function orderModifiers(n) {
  var t = order(n);
  return modifierPhases.reduce(function(e, o) {
    return e.concat(t.filter(function(R) {
      return R.phase === o;
    }));
  }, []);
}
function debounce(n) {
  var t;
  return function() {
    return t || (t = new Promise(function(e) {
      Promise.resolve().then(function() {
        t = void 0, e(n());
      });
    })), t;
  };
}
function format(n) {
  for (var t = arguments.length, e = new Array(t > 1 ? t - 1 : 0), o = 1; o < t; o++)
    e[o - 1] = arguments[o];
  return [].concat(e).reduce(function(R, N) {
    return R.replace(/%s/, N);
  }, n);
}
var INVALID_MODIFIER_ERROR = 'Popper: modifier "%s" provided an invalid %s property, expected %s but got %s', MISSING_DEPENDENCY_ERROR = 'Popper: modifier "%s" requires "%s", but "%s" modifier is not available', VALID_PROPERTIES = ["name", "enabled", "phase", "fn", "effect", "requires", "options"];
function validateModifiers(n) {
  n.forEach(function(t) {
    [].concat(Object.keys(t), VALID_PROPERTIES).filter(function(e, o, R) {
      return R.indexOf(e) === o;
    }).forEach(function(e) {
      switch (e) {
        case "name":
          typeof t.name != "string" && console.error(format(INVALID_MODIFIER_ERROR, String(t.name), '"name"', '"string"', '"' + String(t.name) + '"'));
          break;
        case "enabled":
          typeof t.enabled != "boolean" && console.error(format(INVALID_MODIFIER_ERROR, t.name, '"enabled"', '"boolean"', '"' + String(t.enabled) + '"'));
          break;
        case "phase":
          modifierPhases.indexOf(t.phase) < 0 && console.error(format(INVALID_MODIFIER_ERROR, t.name, '"phase"', "either " + modifierPhases.join(", "), '"' + String(t.phase) + '"'));
          break;
        case "fn":
          typeof t.fn != "function" && console.error(format(INVALID_MODIFIER_ERROR, t.name, '"fn"', '"function"', '"' + String(t.fn) + '"'));
          break;
        case "effect":
          t.effect != null && typeof t.effect != "function" && console.error(format(INVALID_MODIFIER_ERROR, t.name, '"effect"', '"function"', '"' + String(t.fn) + '"'));
          break;
        case "requires":
          t.requires != null && !Array.isArray(t.requires) && console.error(format(INVALID_MODIFIER_ERROR, t.name, '"requires"', '"array"', '"' + String(t.requires) + '"'));
          break;
        case "requiresIfExists":
          Array.isArray(t.requiresIfExists) || console.error(format(INVALID_MODIFIER_ERROR, t.name, '"requiresIfExists"', '"array"', '"' + String(t.requiresIfExists) + '"'));
          break;
        case "options":
        case "data":
          break;
        default:
          console.error('PopperJS: an invalid property has been provided to the "' + t.name + '" modifier, valid properties are ' + VALID_PROPERTIES.map(function(o) {
            return '"' + o + '"';
          }).join(", ") + '; but "' + e + '" was provided.');
      }
      t.requires && t.requires.forEach(function(o) {
        n.find(function(R) {
          return R.name === o;
        }) == null && console.error(format(MISSING_DEPENDENCY_ERROR, String(t.name), o, o));
      });
    });
  });
}
function uniqueBy(n, t) {
  var e = /* @__PURE__ */ new Set();
  return n.filter(function(o) {
    var R = t(o);
    if (!e.has(R))
      return e.add(R), !0;
  });
}
function mergeByName(n) {
  var t = n.reduce(function(e, o) {
    var R = e[o.name];
    return e[o.name] = R ? Object.assign({}, R, o, {
      options: Object.assign({}, R.options, o.options),
      data: Object.assign({}, R.data, o.data)
    }) : o, e;
  }, {});
  return Object.keys(t).map(function(e) {
    return t[e];
  });
}
var INVALID_ELEMENT_ERROR = "Popper: Invalid reference or popper argument provided. They must be either a DOM element or virtual element.", INFINITE_LOOP_ERROR = "Popper: An infinite loop in the modifiers cycle has been detected! The cycle has been interrupted to prevent a browser crash.", DEFAULT_OPTIONS = {
  placement: "bottom",
  modifiers: [],
  strategy: "absolute"
};
function areValidElements() {
  for (var n = arguments.length, t = new Array(n), e = 0; e < n; e++)
    t[e] = arguments[e];
  return !t.some(function(o) {
    return !(o && typeof o.getBoundingClientRect == "function");
  });
}
function popperGenerator(n) {
  n === void 0 && (n = {});
  var t = n, e = t.defaultModifiers, o = e === void 0 ? [] : e, R = t.defaultOptions, N = R === void 0 ? DEFAULT_OPTIONS : R;
  return function(D, L, B) {
    B === void 0 && (B = N);
    var $ = {
      placement: "bottom",
      orderedModifiers: [],
      options: Object.assign({}, DEFAULT_OPTIONS, N),
      modifiersData: {},
      elements: {
        reference: D,
        popper: L
      },
      attributes: {},
      styles: {}
    }, k = [], U = !1, z = {
      state: $,
      setOptions: function(Y) {
        var q = typeof Y == "function" ? Y($.options) : Y;
        V(), $.options = Object.assign({}, N, $.options, q), $.scrollParents = {
          reference: isElement(D) ? listScrollParents(D) : D.contextElement ? listScrollParents(D.contextElement) : [],
          popper: listScrollParents(L)
        };
        var Z = orderModifiers(mergeByName([].concat(o, $.options.modifiers)));
        if ($.orderedModifiers = Z.filter(function(lt) {
          return lt.enabled;
        }), process.env.NODE_ENV !== "production") {
          var J = uniqueBy([].concat(Z, $.options.modifiers), function(lt) {
            var ut = lt.name;
            return ut;
          });
          if (validateModifiers(J), getBasePlacement($.options.placement) === auto) {
            var Q = $.orderedModifiers.find(function(lt) {
              var ut = lt.name;
              return ut === "flip";
            });
            Q || console.error(['Popper: "auto" placements require the "flip" modifier be', "present and enabled to work."].join(" "));
          }
          var K = getComputedStyle$1(L), rt = K.marginTop, tt = K.marginRight, nt = K.marginBottom, at = K.marginLeft;
          [rt, tt, nt, at].some(function(lt) {
            return parseFloat(lt);
          }) && console.warn(['Popper: CSS "margin" styles cannot be used to apply padding', "between the popper and its reference element or boundary.", "To replicate margin, use the `offset` modifier, as well as", "the `padding` option in the `preventOverflow` and `flip`", "modifiers."].join(" "));
        }
        return X(), z.update();
      },
      forceUpdate: function() {
        if (!U) {
          var Y = $.elements, q = Y.reference, Z = Y.popper;
          if (!areValidElements(q, Z)) {
            process.env.NODE_ENV !== "production" && console.error(INVALID_ELEMENT_ERROR);
            return;
          }
          $.rects = {
            reference: getCompositeRect(q, getOffsetParent(Z), $.options.strategy === "fixed"),
            popper: getLayoutRect(Z)
          }, $.reset = !1, $.placement = $.options.placement, $.orderedModifiers.forEach(function(lt) {
            return $.modifiersData[lt.name] = Object.assign({}, lt.data);
          });
          for (var J = 0, Q = 0; Q < $.orderedModifiers.length; Q++) {
            if (process.env.NODE_ENV !== "production" && (J += 1, J > 100)) {
              console.error(INFINITE_LOOP_ERROR);
              break;
            }
            if ($.reset === !0) {
              $.reset = !1, Q = -1;
              continue;
            }
            var K = $.orderedModifiers[Q], rt = K.fn, tt = K.options, nt = tt === void 0 ? {} : tt, at = K.name;
            typeof rt == "function" && ($ = rt({
              state: $,
              options: nt,
              name: at,
              instance: z
            }) || $);
          }
        }
      },
      update: debounce(function() {
        return new Promise(function(W) {
          z.forceUpdate(), W($);
        });
      }),
      destroy: function() {
        V(), U = !0;
      }
    };
    if (!areValidElements(D, L))
      return process.env.NODE_ENV !== "production" && console.error(INVALID_ELEMENT_ERROR), z;
    z.setOptions(B).then(function(W) {
      !U && B.onFirstUpdate && B.onFirstUpdate(W);
    });
    function X() {
      $.orderedModifiers.forEach(function(W) {
        var Y = W.name, q = W.options, Z = q === void 0 ? {} : q, J = W.effect;
        if (typeof J == "function") {
          var Q = J({
            state: $,
            name: Y,
            instance: z,
            options: Z
          }), K = function() {
          };
          k.push(Q || K);
        }
      });
    }
    function V() {
      k.forEach(function(W) {
        return W();
      }), k = [];
    }
    return z;
  };
}
var defaultModifiers = [eventListeners, popperOffsets$1, computeStyles$1, applyStyles$1, offset$1, flip$1, preventOverflow$1, arrow$1, hide$1], createPopper = /* @__PURE__ */ popperGenerator({
  defaultModifiers
});
const { GamepadListener } = require("gamepad.js");
var Gr, Di, De, lo, ho, bh, co, Eh, fo, xh, Bs, $s, po, Th, be, fr, ni, si, vo, Li, zn, go, _o, Ue, ks, Gs, mo, xl, Qc, yo, mn, Tl, tf, bo, Sh, Sl, ef, Eo, Ch, yn, ya, bn, Cl, rf, Il, nf, dr, wl, sf, Rl, af, Us, eu, Hs, Pl, of, He;
class EventMng {
  constructor(t, e, o, R, N, M, D, L, B) {
    it(this, ho);
    it(this, co);
    it(this, fo);
    it(this, po);
    it(this, Li);
    it(this, xl);
    it(this, Tl);
    it(this, bo);
    it(this, Sl);
    it(this, Eo);
    it(this, yn);
    it(this, Cl);
    it(this, Il);
    it(this, wl);
    it(this, Rl);
    it(this, Us);
    it(this, Pl);
    it(this, Gr, new EventListenerCtn());
    it(this, Di, new GamepadListener({
      analog: !1,
      deadZone: 0.3
    }));
    it(this, De, new FocusMng());
    it(this, lo, (t) => {
    });
    it(this, Bs, !1);
    it(this, $s, !1);
    it(this, be, {});
    it(this, fr, {});
    it(this, ni, !1);
    it(this, si, !1);
    it(this, vo, (t) => {
      var e;
      return (e = H(this, be)[t]) != null ? e : H(this, fr)[t];
    });
    it(this, go, () => {
      et(this, go, () => {
      }), this.scrItr.firstWait();
    });
    it(this, _o, {
      getBoundingClientRect: (t = 0, e = 0) => DOMRect.fromRect({ x: t, y: e, width: 0, height: 0 })
    });
    it(this, Ue, void 0);
    it(this, ks, void 0);
    it(this, Gs, void 0);
    it(this, mo, {
      placement: "bottom",
      fallbackPlacements: ["top", "bottom"]
    });
    it(this, yo, (t, e) => {
    });
    it(this, mn, new EventListenerCtn());
    it(this, bn, () => this.layMng.goTxt());
    it(this, dr, () => !1);
    it(this, Hs, () => {
    });
    it(this, He, {
      Alt: 0,
      Meta: 0,
      Control: 0,
      ArrowDown: 0,
      End: 0,
      Enter: 0,
      Escape: 0,
      " ": 0,
      GoBack: 0
    });
    var X;
    if (this.cfg = t, this.hTag = e, this.appPixi = o, this.main = R, this.layMng = N, this.val = M, this.sndMng = D, this.scrItr = L, this.sys = B, e.clear_event = (V) => st(this, Tl, tf).call(this, V), e.event = (V) => st(this, Sl, ef).call(this, V), e.l = (V) => st(this, Cl, rf).call(this, V), e.p = (V) => st(this, Il, nf).call(this, V), e.s = () => (this.scrItr.recodePage(), st(this, Li, zn).call(this, () => {
    }, !1, !0), !0), e.set_cancel_skip = () => st(this, wl, sf).call(this), e.set_focus = (V) => st(this, Rl, af).call(this, V), e.wait = (V) => st(this, Us, eu).call(this, V), e.waitclick = () => st(this, Pl, of).call(this), D.setEvtMng(this), L.setOtherObj(this, N), TxtLayer.setEvtMng(R, this, B), N.setEvtMng(this), B.setFire((V, W) => this.fire(V, W)), CmnLib.isDbg) {
      const V = {
        pause: () => {
          if (et(this, ni, !0), !H(this, si))
            return;
          const W = {};
          this.scrItr.recodeDesign(W), this.sys.callHook("_enterDesign", W), this.sys.send2Dbg("_enterDesign", W);
        },
        stopOnBreakpoint: () => et(this, ni, !0),
        stopOnDataBreakpoint: () => et(this, ni, !0),
        continue: () => et(this, ni, !1),
        disconnect: () => et(this, ni, !1)
      };
      V.attach = V.stopOnEntry = V.stopOnStep = V.stopOnStepIn = V.stopOnStepOut = V.stopOnBackstep = V.pause, B.addHook((W) => {
        var Y;
        return (Y = V[W]) == null ? void 0 : Y.call(V);
      });
    }
    addStyle(`
.sn_hint {
	background-color: #3c3225;
	color: white;
	padding: 4px 8px;
	border-radius: 4px;
	font-size: 1.2em;
	z-index: 10000;
	pointer-events: none;
	user-select: none;
}

.sn_hint_ar,
.sn_hint_ar::before {
	position: absolute;
	width: 8px;
	height: 8px;
	background: inherit;
}
.sn_hint_ar {
	visibility: hidden;
}
.sn_hint_ar::before {
	visibility: visible;
	content: '';
	transform: rotate(45deg);
}

.sn_hint[data-popper-placement^='top']		> .sn_hint_ar {bottom: -4px;}
.sn_hint[data-popper-placement^='bottom']	> .sn_hint_ar {top: -4px;}
.sn_hint[data-popper-placement^='left']		> .sn_hint_ar {right: -4px;}
.sn_hint[data-popper-placement^='right']	> .sn_hint_ar {left: -4px;}
`), Array.from(document.getElementsByClassName("sn_hint")).forEach((V) => {
      var W;
      return (W = V.parentElement) == null ? void 0 : W.removeChild(V);
    }), (X = o.view.parentElement) == null || X.insertAdjacentHTML("beforeend", `
<div class="sn_hint" role="tooltip">
	<span>Dummy</span>
	<div class="sn_hint_ar" data-popper-arrow></div>
</div>`), et(this, Ue, document.querySelector(".sn_hint")), et(this, ks, H(this, Ue).querySelector("span")), et(this, Gs, createPopper(H(this, _o), H(this, Ue))), H(this, Ue).hidden = !0, o.stage.interactive = !0, CmnLib.isMobile ? o.stage.on("pointerdown", (V) => this.fire("click", V)) : H(this, Gr).add(o.stage, "pointerdown", (V) => {
      switch (V.data.button) {
        case 0:
          this.fire("click", V);
          break;
        case 1:
          this.fire("middleclick", V);
          break;
      }
    }), H(this, Gr).add(window, "keydown", (V) => st(this, ho, bh).call(this, V)), H(this, Gr).add(o.view, "contextmenu", (V) => st(this, co, Eh).call(this, V));
    const $ = (V) => {
      CmnLib.isDarkMode = V.matches, M.setVal_Nochk("tmp", "const.sn.isDarkMode", CmnLib.isDarkMode);
    }, k = globalThis.matchMedia("(prefers-color-scheme: dark)");
    $(k), k.addEventListener("change", (V) => {
      $(V), this.fire("sn:chgDarkMode", V);
    }), "WheelEvent" in window && (H(this, Gr).add(o.view, "wheel", (V) => st(this, fo, xh).call(this, V), { passive: !0 }), et(this, lo, (V) => V.addEventListener("wheel", (W) => st(this, fo, xh).call(this, W), { passive: !0 })), et(this, yo, (V, W) => V.add(o.view, "wheel", (Y) => {
      Y.isComposing || Y.deltaY <= 0 || (Y.stopPropagation(), W());
    }))), CmnLib.debugLog && (H(this, Di).on("gamepad:connected", (V) => console.log(`\u{1F47A}<'gamepad:connected' index:${V.detail.index} id:${V.detail.gamepad.id}`)), H(this, Di).on("gamepad:disconnected", (V) => console.log(`\u{1F47A}<'gamepad:disconnected' index:${V.detail.index} id:${V.detail.gamepad.id}`)));
    const U = [
      "",
      "ArrowUp",
      "",
      "ArrowLeft",
      "",
      "ArrowRight",
      "",
      "ArrowDown",
      ""
    ], z = [0, 0];
    H(this, Di).on("gamepad:axis", (V) => {
      if (!document.hasFocus() || V.detail.stick !== 0)
        return;
      z[V.detail.axis] = V.detail.value;
      const W = (z[1] + 1) * 3 + (z[0] + 1), Y = U[W];
      if (!Y)
        return;
      const q = H(this, De).getFocus();
      (!q || q instanceof Container ? globalThis : q).dispatchEvent(new KeyboardEvent("keydown", { key: Y, bubbles: !0 })), !(!q || q instanceof Container) && q.getAttribute("type") === "range" && q.dispatchEvent(new InputEvent("input", { bubbles: !0 }));
    }), H(this, Di).on("gamepad:button", (V) => {
      if (!(!document.hasFocus() || V.detail.value === 0))
        if (V.detail.button % 2 === 0) {
          const W = H(this, De).getFocus();
          (!W || W instanceof Container ? globalThis : W).dispatchEvent(new KeyboardEvent("keydown", { key: "Enter", bubbles: !0 }));
        } else
          o.view.dispatchEvent(new Event("contextmenu"));
    }), H(this, Di).start(), H(this, Gr).add(window, "keyup", (V) => {
      V.isComposing || V.key in H(this, He) && (H(this, He)[V.key] = 0);
    }), M.defTmp("const.sn.key.alternate", () => H(this, He).Alt > 0), M.defTmp("const.sn.key.command", () => H(this, He).Meta > 0), M.defTmp("const.sn.key.control", () => H(this, He).Control > 0), M.defTmp("const.sn.key.end", () => H(this, He).End > 0), M.defTmp("const.sn.key.escape", () => H(this, He).Escape > 0), M.defTmp("const.sn.key.back", () => H(this, He).GoBack > 0);
  }
  resvFlameEvent(t) {
    t.addEventListener("keydown", (e) => st(this, ho, bh).call(this, e)), t.addEventListener("contextmenu", (e) => st(this, co, Eh).call(this, e)), H(this, lo).call(this, t);
  }
  destroy() {
    H(this, De).destroy(), H(this, Gr).clear();
  }
  fire(t, e) {
    var N;
    if (H(this, dr).call(this) || !H(this, si) || H(this, ni))
      return;
    const o = t.toLowerCase();
    if (CmnLib.debugLog && console.log(`\u{1F47A} fire<(key:\`${o}\` type:${e.type} e:%o)`, { ...e }), o === "enter") {
      const M = H(this, De).getFocus();
      if (M instanceof Container) {
        M.emit("pointerdown", new Event("pointerdown"));
        return;
      }
    }
    const R = H(this, vo).call(this, o);
    if (!R) {
      o.slice(0, 5) === "swipe" && globalThis.scrollBy(
        -e.deltaX,
        -e.deltaY
      );
      return;
    }
    o.slice(-5) !== "wheel" && ((N = e.preventDefault) == null || N.call(e)), e.stopPropagation(), o.slice(0, 4) !== "dom=" && this.layMng.clickTxtLay(), et(this, si, !1), R(e), H(this, Ue).hidden = !0;
  }
  popLocalEvts() {
    const t = H(this, be);
    return et(this, be, {}), t;
  }
  pushLocalEvts(t) {
    et(this, be, t);
  }
  waitEvent(t, e = !0, o = !1) {
    if (e && o)
      throw "canskip\u3068global\u3092\u540C\u6642\u306Btrue\u6307\u5B9A\u3067\u304D\u307E\u305B\u3093";
    if (this.val.getVal("tmp:sn.skip.enabled")) {
      if (this.val.getVal("tmp:sn.skip.all") || this.scrItr.isNextKidoku)
        return t(), !1;
      H(this, dr).call(this);
    }
    return st(this, Li, zn).call(this, t, e, o), !0;
  }
  unButton(t) {
    H(this, De).remove(t);
  }
  button(t, e, o, R, N) {
    var U, z;
    !t.fn && !t.label && this.main.errScript("fn\u307E\u305F\u306Flabel\u306F\u5FC5\u9808\u3067\u3059"), e.interactive = e.buttonMode = !0;
    const M = (z = (U = t.key) == null ? void 0 : U.toLowerCase()) != null ? z : " ";
    t.fn || (t.fn = this.scrItr.scriptFn);
    const D = argChk_Boolean(t, "global", !1);
    D ? H(this, fr)[M] = () => this.main.resumeByJumpOrCall(t) : H(this, be)[M] = () => this.main.resumeByJumpOrCall(t);
    const L = e;
    L.on("pointerdown", (X) => this.fire(M, X));
    const B = t.hint ? () => st(this, xl, Qc).call(this, t, e) : () => {
    }, $ = () => {
      o(), H(this, Ue).hidden = !0;
    }, k = () => (B(), R());
    if (L.on("pointerover", k), L.on("pointerout", () => {
      H(this, De).isFocus(e) ? k() : $();
    }), L.on("pointerdown", N), L.on(
      "pointerup",
      CmnLib.isMobile ? $ : () => {
        H(this, De).isFocus(e) ? k() : $();
      }
    ), H(this, De).add(e, k, $), t.clickse && (this.cfg.searchPath(t.clickse, Config.EXT_SOUND), L.on("pointerdown", () => {
      const X = { fn: t.clickse, join: !1 };
      t.clicksebuf && (X.buf = t.clicksebuf), this.hTag.playse(X);
    })), t.enterse && (this.cfg.searchPath(t.enterse, Config.EXT_SOUND), L.on("pointerover", () => {
      const X = { fn: t.enterse, join: !1 };
      t.entersebuf && (X.buf = t.entersebuf), this.hTag.playse(X);
    })), t.leavese && (this.cfg.searchPath(t.leavese, Config.EXT_SOUND), L.on("pointerout", () => {
      const X = { fn: t.leavese, join: !1 };
      t.leavesebuf && (X.buf = t.leavesebuf), this.hTag.playse(X);
    })), t.onenter) {
      const X = M + t.onenter.toLowerCase(), V = { fn: t.fn, label: t.onenter, call: !0, key: X };
      D ? H(this, fr)[X] = () => this.main.resumeByJumpOrCall(V) : H(this, be)[X] = () => this.main.resumeByJumpOrCall(V), L.on("pointerover", (W) => this.fire(X, W));
    }
    if (t.onleave) {
      const X = M + t.onleave.toLowerCase(), V = { fn: t.fn, label: t.onleave, call: !0, key: X };
      D ? H(this, fr)[X] = () => this.main.resumeByJumpOrCall(V) : H(this, be)[X] = () => this.main.resumeByJumpOrCall(V), L.on("pointerout", (W) => this.fire(X, W));
    }
    this.sndMng.loadAheadSnd(t);
  }
  cvsResize() {
    H(this, Ue).hidden = !0;
  }
  waitLimitedEvent(t, e) {
    H(this, bn).call(this), this.val.saveKidoku();
    const o = () => {
      H(this, mn).clear(), e();
    };
    if (this.val.getVal("tmp:sn.skip.enabled"))
      if (!this.val.getVal("tmp:sn.skip.all") && !this.scrItr.isNextKidoku)
        H(this, dr).call(this);
      else
        return o(), !1;
    return argChk_Boolean(t, "canskip", !0) && (H(this, mn).add(window, "pointerdown", (R) => {
      R.stopPropagation(), o();
    }), H(this, mn).add(window, "keydown", (R) => {
      R.isComposing || (R.stopPropagation(), o());
    }), H(this, yo).call(this, H(this, mn), o)), !0;
  }
  isSkippingByKeyDown() {
    if (this.scrItr.skip4page)
      return !0;
    for (const t in H(this, He))
      if (H(this, He)[t] === 2)
        return !0;
    return !1;
  }
}
Gr = new WeakMap(), Di = new WeakMap(), De = new WeakMap(), lo = new WeakMap(), ho = new WeakSet(), bh = function(t) {
  if (t.isComposing)
    return;
  t.key in H(this, He) && (H(this, He)[t.key] = t.repeat ? 2 : 1);
  const e = (t.altKey ? t.key === "Alt" ? "" : "alt+" : "") + (t.ctrlKey ? t.key === "Control" ? "" : "ctrl+" : "") + (t.shiftKey ? t.key === "Shift" ? "" : "shift+" : "") + t.key;
  this.fire(e, t);
}, co = new WeakSet(), Eh = function(t) {
  const e = (t.altKey ? t.key === "Alt" ? "" : "alt+" : "") + (t.ctrlKey ? t.key === "Control" ? "" : "ctrl+" : "") + (t.shiftKey ? t.key === "Shift" ? "" : "shift+" : "") + "rightclick";
  this.fire(e, t), t.preventDefault();
}, fo = new WeakSet(), xh = function(t) {
  if (t.isComposing)
    return;
  if (H(this, Bs)) {
    et(this, $s, !0);
    return;
  }
  et(this, Bs, !0), st(this, po, Th).call(this);
  const e = (t.altKey ? "alt+" : "") + (t.ctrlKey ? "ctrl+" : "") + (t.shiftKey ? "shift+" : "") + (t.deltaY > 0 ? "downwheel" : "upwheel");
  this.fire(e, t);
}, Bs = new WeakMap(), $s = new WeakMap(), po = new WeakSet(), Th = function() {
  setTimeout(() => {
    if (H(this, $s)) {
      et(this, $s, !1), st(this, po, Th).call(this);
      return;
    }
    et(this, Bs, !1);
  }, 250);
}, be = new WeakMap(), fr = new WeakMap(), ni = new WeakMap(), si = new WeakMap(), vo = new WeakMap(), Li = new WeakSet(), zn = function(t, e = !0, o = !0) {
  if (H(this, bn).call(this), this.val.saveKidoku(), e ? H(this, be).click = H(this, be).enter = H(this, be).arrowdown = H(this, be)["wheel.y>0"] = t : (delete H(this, be).click, delete H(this, be).enter, delete H(this, be).arrowdown, delete H(this, be)["wheel.y>0"]), et(this, vo, o ? (R) => {
    var N;
    return (N = H(this, be)[R]) != null ? N : H(this, fr)[R];
  } : (R) => H(this, be)[R]), et(this, si, !0), H(this, go).call(this), CmnLib.debugLog) {
    const R = /* @__PURE__ */ Object.create(null);
    R.local = Object.keys(H(this, be)), R.global = Object.keys(H(this, fr)), console.log("\u{1F38D} wait event... %o", R);
  }
}, go = new WeakMap(), _o = new WeakMap(), Ue = new WeakMap(), ks = new WeakMap(), Gs = new WeakMap(), mo = new WeakMap(), xl = new WeakSet(), Qc = function(t, e) {
  var N, M;
  const o = e instanceof Button ? e.getBtnBounds() : e.getBounds();
  if (!(t[":\u30BF\u30B0\u540D"] === "link")) {
    const D = e.parent.parent;
    o.x += D.x, o.y += D.y;
  }
  if (!t.hint) {
    H(this, Ue).hidden = !0;
    return;
  }
  H(this, Ue).style.cssText = `position:${H(this, Ue).style.position}; transform:${H(this, Ue).style.transform};` + ((N = t.hint_style) != null ? N : ""), H(this, ks).style.cssText = "", H(this, ks).textContent = (M = t.hint) != null ? M : "";
  try {
    const D = t.hint_opt ? { ...H(this, mo), ...JSON.parse(t.hint_opt) } : H(this, mo);
    H(this, Gs).setOptions(D);
  } catch (D) {
    console.error(mesErrJSON(t, "hint_opt", D.message));
  }
  H(this, _o).getBoundingClientRect = () => DOMRect.fromRect({
    x: this.sys.ofsLeft4elm + o.x * this.sys.cvsScale,
    y: this.sys.ofsTop4elm + o.y * this.sys.cvsScale,
    width: o.width,
    height: o.height
  }), H(this, Gs).update(), H(this, Ue).hidden = !1;
}, yo = new WeakMap(), mn = new WeakMap(), Tl = new WeakSet(), tf = function(t) {
  const e = argChk_Boolean(t, "global", !1), o = e ? H(this, fr) : H(this, be);
  for (const R in o)
    st(this, bo, Sh).call(this, R, o[R]);
  return e ? et(this, fr, {}) : et(this, be, {}), et(this, si, !1), !1;
}, bo = new WeakSet(), Sh = function(t, e) {
  t.slice(0, 4) === "dom=" && st(this, yn, ya).call(this, t).el.forEach((o) => o.removeEventListener("click", e));
}, Sl = new WeakSet(), ef = function(t) {
  var M, D;
  const e = t.key;
  if (!e)
    throw "key\u306F\u5FC5\u9808\u3067\u3059";
  const o = e.toLowerCase(), R = argChk_Boolean(t, "call", !1), N = argChk_Boolean(t, "global", !1) ? H(this, fr) : H(this, be);
  if (argChk_Boolean(t, "del", !1)) {
    if (t.fn || t.label || R)
      throw "fn/label/call\u3068del\u306F\u540C\u6642\u6307\u5B9A\u3067\u304D\u307E\u305B\u3093";
    return st(this, bo, Sh).call(this, e, N[o]), delete N[o], !1;
  }
  if ((M = t.fn) != null || (t.fn = this.scrItr.scriptFn), e.slice(0, 4) === "dom=") {
    const L = st(this, yn, ya).call(this, e);
    if (L.el.length === 0) {
      if (argChk_Boolean(t, "need_err", !0))
        throw `HTML\u5185\u306B\u30BB\u30EC\u30AF\u30BF\uFF08${L.sel}\uFF09\u306B\u5BFE\u5FDC\u3059\u308B\u8981\u7D20\u304C\u898B\u3064\u304B\u308A\u307E\u305B\u3093\u3002\u5B58\u5728\u3057\u306A\u3044\u5834\u5408\u3092\u8A31\u5BB9\u3059\u308B\u306A\u3089\u3001need_err=false \u3068\u6307\u5B9A\u3057\u3066\u304F\u3060\u3055\u3044`;
      return !1;
    }
    let B = ["click", "keydown"];
    switch ((D = L.el[0].type) != null ? D : "") {
      case "checkbox":
        B = ["input"];
        break;
      case "range":
        B = ["input"];
        break;
      case "text":
      case "textarea":
        B = ["input", "change"];
        break;
    }
    B.forEach((k, U) => L.el.forEach((z) => {
      H(this, Gr).add(z, k, (X) => {
        if (!H(this, si) || this.layMng.getFrmDisabled(L.id) || k === "keydown" && X.key !== "Enter")
          return;
        const V = z.dataset;
        for (const W in V)
          V.hasOwnProperty(W) && this.val.setVal_Nochk("tmp", `sn.event.domdata.${W}`, V[W]);
        this.fire(e, X);
      }), U === 0 && H(this, De).add(
        z,
        () => st(this, Eo, Ch).call(this, z) ? (z.focus(), !0) : !1,
        () => {
        }
      );
    }));
  }
  return N[o] = () => this.main.resumeByJumpOrCall(t), !1;
}, Eo = new WeakSet(), Ch = function(t) {
  if (t.offsetParent === null)
    return !1;
  let e = t;
  do {
    if (getComputedStyle(e).display === "none" || e.dataset.focus === "false" || (e == null ? void 0 : e.disabled))
      return !1;
    e = e.parentElement;
  } while (e !== null);
  return !0;
}, yn = new WeakSet(), ya = function(t) {
  const e = t.indexOf(":");
  let o = "";
  if (e >= 0) {
    const R = t.slice(4, e), N = `const.sn.frm.${R}`;
    if (!this.val.getVal(`tmp:${N}`, 0))
      throw `HTML\u3010${R}\u3011\u304C\u8AAD\u307F\u8FBC\u307E\u308C\u3066\u3044\u307E\u305B\u3093`;
    const D = document.getElementById(R).contentWindow;
    return o = t.slice(e + 1), { el: D.document.querySelectorAll(o), id: R, sel: o };
  }
  return o = t.slice(4), { el: document.querySelectorAll(o), id: "", sel: o };
}, bn = new WeakMap(), Cl = new WeakSet(), rf = function(t) {
  if (this.scrItr.skip4page)
    return !1;
  if (!this.val.getVal("tmp:sn.tagL.enabled"))
    return H(this, bn).call(this), !1;
  if (this.val.getVal("tmp:sn.skip.enabled")) {
    if (!this.val.getVal("tmp:sn.skip.all") && !this.scrItr.isNextKidoku)
      H(this, dr).call(this);
    else if ("ps".includes(this.val.getVal("sys:sn.skip.mode")))
      return !1;
  }
  return this.val.getVal("tmp:sn.auto.enabled") ? st(this, Us, eu).call(this, {
    time: Number(this.scrItr.isKidoku ? this.val.getVal("sys:sn.auto.msecLineWait_Kidoku") : this.val.getVal("sys:sn.auto.msecLineWait"))
  }) : (argChk_Boolean(t, "visible", !0) && this.layMng.breakLine(), st(this, Li, zn).call(this, () => this.main.resume()), !0);
}, Il = new WeakSet(), nf = function(t) {
  if (this.scrItr.recodePage(), this.val.getVal("tmp:sn.skip.enabled")) {
    if (!this.val.getVal("tmp:sn.skip.all") && !this.scrItr.isNextKidoku)
      H(this, dr).call(this);
    else if (this.val.getVal("sys:sn.skip.mode") == "s")
      return H(this, bn).call(this), !1;
  }
  if (this.val.getVal("tmp:sn.auto.enabled"))
    return st(this, Us, eu).call(this, {
      time: Number(this.scrItr.isKidoku ? this.val.getVal("sys:sn.auto.msecPageWait_Kidoku") : this.val.getVal("sys:sn.auto.msecPageWait"))
    });
  argChk_Boolean(t, "visible", !0) && this.layMng.breakPage();
  const e = () => {
    this.sndMng.clearCache(), this.main.resume();
  };
  return st(this, Li, zn).call(this, argChk_Boolean(t, "er", !1) && this.layMng.currentTxtlayFore ? () => {
    this.hTag.er(t), e();
  } : e), !0;
}, dr = new WeakMap(), wl = new WeakSet(), sf = function() {
  return et(this, dr, () => (et(this, dr, () => !1), this.val.setVal_Nochk("tmp", "sn.tagL.enabled", !0), this.val.setVal_Nochk("tmp", "sn.skip.enabled", !1), this.val.setVal_Nochk("tmp", "sn.auto.enabled", !1), this.layMng.setNormalChWait(), H(this, Hs).call(this), !0)), !1;
}, Rl = new WeakSet(), af = function(t) {
  const { add: e, del: o, to: R } = t;
  if ((e == null ? void 0 : e.slice(0, 4)) === "dom=") {
    const N = st(this, yn, ya).call(this, e);
    if (N.el.length === 0 && argChk_Boolean(t, "need_err", !0))
      throw `HTML\u5185\u306B\u30BB\u30EC\u30AF\u30BF\uFF08${N.sel}\uFF09\u306B\u5BFE\u5FDC\u3059\u308B\u8981\u7D20\u304C\u898B\u3064\u304B\u308A\u307E\u305B\u3093\u3002\u5B58\u5728\u3057\u306A\u3044\u5834\u5408\u3092\u8A31\u5BB9\u3059\u308B\u306A\u3089\u3001need_err=false \u3068\u6307\u5B9A\u3057\u3066\u304F\u3060\u3055\u3044`;
    return N.el.forEach((M) => H(this, De).add(
      M,
      () => st(this, Eo, Ch).call(this, M) ? (M.focus(), !0) : !1,
      () => {
      }
    )), !1;
  }
  if ((o == null ? void 0 : o.slice(0, 4)) === "dom=") {
    const N = st(this, yn, ya).call(this, o);
    if (N.el.length === 0 && argChk_Boolean(t, "need_err", !0))
      throw `HTML\u5185\u306B\u30BB\u30EC\u30AF\u30BF\uFF08${N.sel}\uFF09\u306B\u5BFE\u5FDC\u3059\u308B\u8981\u7D20\u304C\u898B\u3064\u304B\u308A\u307E\u305B\u3093\u3002\u5B58\u5728\u3057\u306A\u3044\u5834\u5408\u3092\u8A31\u5BB9\u3059\u308B\u306A\u3089\u3001need_err=false \u3068\u6307\u5B9A\u3057\u3066\u304F\u3060\u3055\u3044`;
    return N.el.forEach((M) => H(this, De).remove(M)), !1;
  }
  if (!R)
    throw "[set_focus] add \u304B to \u306F\u5FC5\u9808\u3067\u3059";
  switch (R) {
    case "null":
      H(this, De).blur();
      break;
    case "next":
      H(this, De).next();
      break;
    case "prev":
      H(this, De).prev();
      break;
  }
  return !1;
}, Us = new WeakSet(), eu = function(t) {
  const e = argChk_Num(t, "time", NaN);
  if (this.scrItr.skip4page)
    return !1;
  if (this.val.getVal("tmp:sn.skip.enabled"))
    return !this.val.getVal("tmp:sn.skip.all") && !this.scrItr.isNextKidoku && H(this, dr).call(this), !1;
  this.val.getVal("tmp:sn.auto.enabled") && et(this, Hs, () => {
    this.scrItr.subIdxToken(), o.end();
  });
  const o = new Tween({}).to({}, e).onComplete(() => {
    et(this, Hs, () => {
    }), o.stop(), this.main.resume();
  }).start();
  return this.waitEvent(
    () => o.end(),
    argChk_Boolean(t, "canskip", !0),
    argChk_Boolean(t, "global", !1)
  );
}, Hs = new WeakMap(), Pl = new WeakSet(), of = function() {
  return this.scrItr.skip4page ? !1 : ((this.val.getVal("tmp:sn.skip.enabled") || this.val.getVal("tmp:sn.auto.enabled")) && H(this, dr).call(this), st(this, Li, zn).call(this, () => this.main.resume()), !0);
}, He = new WeakMap();
class CallStack {
  constructor(t = "", e = 0, o = { ":hEvt1Time": {}, ":hMp": {} }) {
    this.fn = t, this.idx = e, this.csArg = o, this.toString = () => `[fn:${this.fn}, idx:${this.idx}, csArg:${this.csArg}]`;
  }
}
var Vt, te, Ut, ce, he, ai, xo, Ih, Fi, En, Al, oi, To, wh, So, Rh, zs, Bi, jn, xn, ba, Tn, ui, Ee, Ol, uf, Sn, Ea, Nl, lf, js, Vs, ar, Ml, hf, Dl, cf, li, Xi, Ll, ff, $i, ki, Xs, Ws, Ys, Ye, Fl, df, Bl, pf, $l, vf, Co, Ph, kl, gf, Gl, _f, Ul, mf, Io, Ah, qs, Cn, xa, Gi, Ui, Vn, wo, Oh, Zs, Ro, Nh, Po, Ao, Ks, Hi, Js, Hl, yf, ze, zl, bf, Oo, Mh, No, Mo, Do, jl, Ef, Ur, Lo, Dh, Vl, xf, Xl, Tf, Wl, Sf, Qs, In, Yl, Cf, ta, ru, wn, ql, If, pr, Zl, wf, ea, iu, Kl, Rf, vr, Ae;
const Qe = class {
  constructor(t, e, o, R, N, M, D, L, B) {
    it(this, xo);
    it(this, To);
    it(this, So);
    it(this, Bi);
    it(this, xn);
    it(this, Ol);
    it(this, Sn);
    it(this, Nl);
    it(this, Ml);
    it(this, Dl);
    it(this, li);
    it(this, Ll);
    it(this, Fl);
    it(this, Bl);
    it(this, $l);
    it(this, Co);
    it(this, kl);
    it(this, Gl);
    it(this, Ul);
    it(this, Io);
    it(this, Cn);
    it(this, Ui);
    it(this, wo);
    it(this, Ro);
    it(this, Hl);
    it(this, zl);
    it(this, Oo);
    it(this, jl);
    it(this, Lo);
    it(this, Vl);
    it(this, Xl);
    it(this, Wl);
    it(this, Yl);
    it(this, ta);
    it(this, ql);
    it(this, Zl);
    it(this, ea);
    it(this, Kl);
    it(this, Vt, void 0);
    it(this, te, void 0);
    it(this, Ut, void 0);
    it(this, ce, void 0);
    it(this, he, void 0);
    it(this, ai, void 0);
    it(this, Fi, void 0);
    it(this, En, void 0);
    it(this, oi, void 0);
    it(this, zs, void 0);
    it(this, Ee, void 0);
    it(this, js, void 0);
    it(this, Vs, void 0);
    it(this, ar, void 0);
    it(this, $i, void 0);
    it(this, ki, void 0);
    it(this, Xs, void 0);
    it(this, Ws, void 0);
    it(this, Ys, void 0);
    it(this, Ye, void 0);
    it(this, qs, void 0);
    it(this, Gi, void 0);
    it(this, Zs, void 0);
    it(this, Po, void 0);
    it(this, Ao, void 0);
    it(this, Ks, void 0);
    it(this, Hi, void 0);
    it(this, Js, void 0);
    it(this, ze, void 0);
    it(this, No, void 0);
    it(this, Mo, void 0);
    it(this, Do, void 0);
    it(this, Ur, void 0);
    it(this, Qs, void 0);
    it(this, In, void 0);
    it(this, wn, void 0);
    it(this, pr, void 0);
    it(this, vr, void 0);
    it(this, Ae, void 0);
    if (this.cfg = t, this.hTag = e, this.main = o, this.val = R, this.alzTagArg = N, this.runAnalyze = M, this.prpPrs = D, this.sndMng = L, this.sys = B, et(this, Vt, { aToken: [""], len: 1, aLNum: [1] }), et(this, te, ""), et(this, Ut, 0), et(this, ce, 0), this.addLineNum = ($) => et(this, ce, H(this, ce) + $), et(this, he, []), et(this, ai, new Grammar()), this.firstWait = () => {
    }, et(this, Fi, {
      disconnect: () => {
        et(Qe, Tn, {}), et(Qe, ui, {}), this.isBreak = () => !1, H(this, Fi).continue({}), et(this, Ee, 0);
      },
      restart: () => this.isBreak = () => !1,
      add_break: ($) => st(this, xo, Ih).call(this, $.fn, $.o),
      data_break: ($) => {
        H(this, Ee) === 0 && (et(this, Ee, 1), this.main.setLoop(!1, `\u5909\u6570 ${$.dataId}\u3010${$.old_v}\u3011\u2192\u3010${$.new_v}\u3011\u30C7\u30FC\u30BF\u30D6\u30EC\u30FC\u30AF`), this.sys.callHook("stopOnDataBreakpoint", {}), this.sys.send2Dbg("stopOnDataBreakpoint", {}));
      },
      set_func_break: ($) => {
        et(Qe, ui, {}), $.a.forEach((k) => H(Qe, ui)[k.name] = 1), this.sys.send2Dbg($.ri, {});
      },
      stack: ($) => this.sys.send2Dbg($.ri, { a: st(this, Nl, lf).call(this) }),
      eval: ($) => {
        this.sys.send2Dbg($.ri, { v: this.prpPrs.parse($.txt) });
      },
      continue: () => {
        st(this, xn, ba).call(this) || (et(this, Ut, H(this, Ut) - H(this, Bi, jn)), et(this, Ee, 3), this.main.setLoop(!0), this.main.resume());
      },
      stepover: ($) => st(this, To, wh).call(this, $),
      stepin: () => {
        if (st(this, xn, ba).call(this))
          return;
        const $ = H(this, Vt).aToken[H(this, Ut) - H(this, Bi, jn)];
        this.sys.callHook(`stopOnStep${H(this, In).test($) ? "In" : ""}`, {}), et(this, Ut, H(this, Ut) - H(this, Bi, jn)), et(this, Ee, H(this, Ee) === 1 ? 4 : 5), this.main.setLoop(!0), this.main.resume();
      },
      stepout: ($) => {
        st(this, xn, ba).call(this) || (H(this, he).length > 0 ? st(this, So, Rh).call(this, !0) : st(this, To, wh).call(this, $));
      },
      pause: () => {
        et(this, Ee, 4), this.main.setLoop(!1, "\u4E00\u6642\u505C\u6B62"), this.sys.send2Dbg("stopOnStep", {});
      },
      stopOnEntry: () => {
        et(this, Ee, 4), this.main.setLoop(!1, "\u4E00\u6642\u505C\u6B62"), this.sys.send2Dbg("stopOnEntry", {});
      }
    }), et(this, En, ($) => this.cfg.searchPath($, Config.EXT_SCRIPT)), et(this, oi, ($) => (this.sys.pathBaseCnvSnPath4Dbg + H(this, En).call(this, $)).replace(H(Qe, Al), `$1/prj/$2/${H(this, te)}$3`)), this.cnvPath4Dbg = ($) => this.sys.pathBaseCnvSnPath4Dbg + $.replace("/crypto_prj/", "/prj/"), et(this, zs, 0), et(this, Ee, 0), this.isBreak = ($) => !1, et(this, js, ($) => {
    }), et(this, $i, () => {
    }), et(this, ki, () => {
    }), et(this, Xs, ""), et(this, Ws, {}), this.noticeBreak = ($) => {
    }, et(this, Ys, 5), et(this, Ye, [-1]), et(this, qs, ""), et(this, Gi, ""), this.nextToken = () => "", et(this, Zs, ($) => {
    }), et(this, Po, /(\*{2,})(.*)/), et(this, Ao, /\[macro\s/), et(this, Ks, /\[endmacro[\s\]]/), et(this, Hi, /^\[let_ml\s/g), et(this, Js, /^\[endlet_ml\s*]/g), et(this, ze, /* @__PURE__ */ Object.create(null)), et(this, No, /^\[(call|loadplugin)\s/), et(this, Mo, /\bfn\s*=\s*[^\s\]]+/), et(this, Do, () => {
      for (let $ = H(this, Vt).len - 1; $ >= 0; --$) {
        const k = H(this, Vt).aToken[$];
        if (!H(this, No).test(k))
          continue;
        const [U, z] = tagToken2Name_Args(k);
        this.alzTagArg.go(z);
        const X = this.alzTagArg.hPrm.fn;
        if (!X)
          continue;
        const V = X.val;
        if (!V || V.slice(-1) !== "*")
          continue;
        const W = U === "loadplugin" ? "css" : "sn", Y = this.cfg.matchPath("^" + V.slice(0, -1) + ".*", W);
        H(this, Vt).aToken.splice($, 1, "	", "; " + k), H(this, Vt).aLNum.splice($, 1, NaN, NaN);
        for (const q of Y) {
          const Z = k.replace(
            H(this, Mo),
            "fn=" + decodeURIComponent(getFn(q[W]))
          );
          H(this, Vt).aToken.splice($, 0, Z), H(this, Vt).aLNum.splice($, 0, NaN);
        }
      }
      H(this, Vt).len = H(this, Vt).aToken.length;
    }), et(this, Ur, !1), et(this, Qs, "call"), et(this, In, /\[(call)\b/), et(this, wn, !1), et(this, pr, {
      hSave: {},
      hPages: {},
      aIfStk: [-1]
    }), et(this, vr, []), et(this, Ae, -1), e.let_ml = ($) => st(this, Ml, hf).call(this, $), e.dump_stack = () => st(this, Dl, cf).call(this), e.dump_script = ($) => st(this, Ll, ff).call(this, $), e.else = e.elsif = e.endif = () => st(this, Fl, df).call(this), e.if = ($) => st(this, Bl, pf).call(this, $), e.call = ($) => st(this, $l, vf).call(this, $), e.jump = ($) => st(this, kl, gf).call(this, $), e.page = ($) => st(this, Gl, _f).call(this, $), e.pop_stack = ($) => st(this, Ul, mf).call(this, $), e.return = () => st(this, Io, Ah).call(this), e.bracket2macro = ($) => st(this, Vl, xf).call(this, $), e.char2macro = ($) => st(this, Xl, Tf).call(this, $), e.endmacro = () => st(this, Io, Ah).call(this), e.macro = ($) => st(this, Wl, Sf).call(this, $), e.load = ($) => st(this, Yl, Cf).call(this, $), e.reload_script = ($) => st(this, ql, If).call(this, $), e.record_place = () => st(this, Zl, wf).call(this), e.save = ($) => st(this, Kl, Rf).call(this, $), t.oCfg.debug.token && et(this, Zs, ($) => console.log(`\u{1F331} \u30C8\u30FC\u30AF\u30F3 fn:${H(this, te)} idx:${H(this, Ut)} ln:${H(this, ce)} token\u3010${$}\u3011`)), R.defTmp("const.sn.vctCallStk.length", () => H(this, he).length), H(this, ai).setEscape(t.oCfg.init.escape), CmnLib.isDbg) {
      B.addHook((k, U) => {
        var z, X;
        return (X = (z = H(this, Fi))[k]) == null ? void 0 : X.call(z, U);
      }), this.isBreak = st(this, Ol, uf);
      const $ = this.analyzeInit;
      this.analyzeInit = () => {
        this.analyzeInit = () => {
        }, this.sys.send2Dbg("hi", {});
      }, H(this, Fi).auth = (k) => {
        const U = k.hBreakpoint.hFn2hLineBP;
        for (const z in U)
          st(this, xo, Ih).call(this, z, U[z]);
        if (et(Qe, ui, {}), k.hBreakpoint.aFunc.forEach((z) => H(Qe, ui)[z.name] = 1), k.stopOnEntry) {
          for (; ; ) {
            let z = this.nextToken();
            if (!z)
              break;
            const X = z.charCodeAt(0);
            if (X === 91 || X === 38 || X === 42 && z.length === 1)
              break;
            X === 10 && et(this, ce, H(this, ce) + z.length);
          }
          this.sys.callHook("stopOnEntry", {}), this.analyzeInit = $, this.analyzeInit();
        } else
          this.firstWait = () => {
            this.sys.callHook("stopOnEntry", {});
          }, this.analyzeInit = $, this.analyzeInit();
      };
    } else
      this.recodeDesign = () => {
      };
    t.oCfg.debug.tag && et(this, js, ($) => console.log(`\u{1F332} \u30BF\u30B0\u89E3\u6790 fn:${H(this, te)} idx:${H(this, Ut)} ln:${H(this, ce)} [${$} %o]`, this.alzTagArg.hPrm));
  }
  get scriptFn() {
    return H(this, te);
  }
  subIdxToken() {
    --Re(this, Ut)._;
  }
  get lineNum() {
    return H(this, ce);
  }
  destroy() {
    this.isBreak = () => !1;
  }
  \u30BF\u30B0\u89E3\u6790(t) {
    const [e, o] = tagToken2Name_Args(t), R = this.hTag[e];
    if (!R)
      throw `\u672A\u5B9A\u7FA9\u306E\u30BF\u30B0\u3010${e}\u3011\u3067\u3059`;
    this.alzTagArg.go(o), H(this, js).call(this, e);
    const N = this.alzTagArg.hPrm;
    if (N.cond) {
      const L = N.cond.val;
      if (!L || L.charAt(0) === "&")
        throw "\u5C5E\u6027cond\u306F\u300C&\u300D\u304C\u4E0D\u8981\u3067\u3059";
      const B = this.prpPrs.parse(L), $ = String(B);
      if ($ === "null" || $ === "undefined" || !B)
        return !1;
    }
    let M = {};
    const D = H(this, he).length;
    if (this.alzTagArg.isKomeParam) {
      if (D === 0)
        throw "\u5C5E\u6027\u300C*\u300D\u306F\u30DE\u30AF\u30ED\u306E\u307F\u6709\u52B9\u3067\u3059";
      M = { ...H(this, he)[H(this, he).length - 1].csArg };
    }
    M[":\u30BF\u30B0\u540D"] = e;
    for (const L in N) {
      let B = N[L].val;
      if ((B == null ? void 0 : B.charAt(0)) === "%") {
        if (D === 0)
          throw "\u5C5E\u6027\u300C%\u300D\u306F\u30DE\u30AF\u30ED\u5B9A\u7FA9\u5185\u3067\u306E\u307F\u4F7F\u7528\u3067\u304D\u307E\u3059\uFF08\u305D\u306E\u30DE\u30AF\u30ED\u306E\u5F15\u6570\u3092\u793A\u3059\u7C21\u7565\u6587\u6CD5\u3067\u3042\u308B\u305F\u3081\uFF09";
        const k = H(this, he)[H(this, he).length - 1].csArg[B.slice(1)];
        if (k) {
          M[L] = k;
          continue;
        }
        if (B = N[L].def, B === void 0 || B === "null")
          continue;
      }
      if (B = this.prpPrs.getValAmpersand(B != null ? B : ""), B !== "undefined") {
        M[L] = B;
        continue;
      }
      const $ = N[L].def;
      $ !== void 0 && (B = this.prpPrs.getValAmpersand($), B !== "undefined" && (M[L] = B));
    }
    return R(M);
  }
  setOtherObj(t, e) {
    et(this, Vs, t), et(this, ar, e);
  }
  dumpErrForeLine() {
    var M;
    if (H(this, Ut) === 0) {
      console.group(`\u{1F95F} Error line (from 0 rows before) fn:${H(this, te)}`), console.groupEnd();
      return;
    }
    let t = "";
    for (let D = H(this, Ut) - 1; D >= 0 && (t = H(this, Vt).aToken[D] + t, !(((M = t.match(/\n/g)) != null ? M : []).length >= H(this, Ys))); --D)
      ;
    const e = t.split(`
`).slice(-H(this, Ys)), o = e.length;
    console.group(`\u{1F95F} Error line (from ${o} rows before) fn:${H(this, te)}`);
    const R = String(H(this, ce)).length, N = st(this, li, Xi).call(this, H(this, Vt), H(this, Ut));
    for (let D = 0; D < o; ++D) {
      const L = H(this, ce) - o + D + 1, B = `${String(L).padStart(R, " ")}: %c`, $ = e[D], k = $.length > 75 ? $.slice(0, 75) + "\u2026" : $;
      D === o - 1 ? console.info(
        B + k.slice(0, N.col_s) + "%c" + k.slice(N.col_s),
        "color: black; background-color: skyblue;",
        "color: black; background-color: pink;"
      ) : console.info(B + k, "color: black; background-color: skyblue;");
    }
    console.groupEnd();
  }
  analyzeInit() {
    const t = st(this, Hl, yf).call(this, H(this, Vt), Boolean(this.val.getVal("mp:const.sn.macro.name")), H(this, ce), H(this, Gi), H(this, Ut));
    et(this, Ut, t.idx), et(this, ce, t.ln), this.runAnalyze();
  }
  get isKidoku() {
    return H(this, Ur);
  }
  get isNextKidoku() {
    let t = H(this, te), e = H(this, Ut), o = H(this, Vt).len;
    if (H(this, he).length > 0) {
      const N = H(this, he)[0];
      t = N.fn, e = N.idx;
      const M = H(this, ze)[t];
      M && (o = M.len);
    }
    const R = this.val.getAreaKidoku(t);
    return !R || e === o ? !1 : R.search(e);
  }
  get normalWait() {
    return H(this, Ur) ? this.val.getVal("sys:sn.tagCh.doWait_Kidoku") ? uint(this.val.getVal("sys:sn.tagCh.msecWait_Kidoku")) : 0 : this.val.getVal("sys:sn.tagCh.doWait") ? uint(this.val.getVal("sys:sn.tagCh.msecWait")) : 0;
  }
  get skip4page() {
    return H(this, wn);
  }
  recodePage() {
    if (et(this, wn, !1), !this.val.getVal("save:sn.doRecLog"))
      return;
    const { fn: t, idx: e } = st(this, ea, iu).call(this), o = e - 1, R = o + ":" + t, N = H(this, vr).findIndex((D) => D.key === R);
    if (N > -1) {
      et(this, Ae, N);
      return;
    }
    const M = {
      key: R,
      fn: t,
      idx: o,
      retFn: t,
      retIdx: 0,
      retMark: { ...H(this, pr) }
    };
    if (H(this, Ae) >= 0) {
      const D = H(this, vr)[H(this, Ae)];
      M.retFn = D.fn, M.retIdx = D.idx + 1;
    }
    ++Re(this, Ae)._ === H(this, vr).length ? H(this, vr).push(M) : H(this, vr)[H(this, Ae)] = M;
  }
  recodeDesign(t) {
    let e = "", o = 0;
    const R = H(this, he).length;
    if (t.design_unit && R > 0) {
      const D = H(this, he)[0];
      e = D.fn, o = D.idx;
    } else
      e = H(this, te), o = H(this, Ut);
    t[":path"] = H(this, oi).call(this, e);
    const N = st(this, li, Xi).call(this, H(this, ze)[e], o);
    t[":ln"] = N.ln, t[":col_s"] = N.col_s, t[":col_e"] = N.col_e;
    const M = o - 1;
    t[":idx_tkn"] = M, t[":token"] = H(this, ze)[e].aToken[M], this.sys.send2Dbg("_recodeDesign", t);
  }
  replace(t, e) {
    H(this, Vt).aToken[t] = e;
  }
};
let ScriptIterator = Qe;
Vt = new WeakMap(), te = new WeakMap(), Ut = new WeakMap(), ce = new WeakMap(), he = new WeakMap(), ai = new WeakMap(), xo = new WeakSet(), Ih = function(t, e) {
  H(Qe, Tn)[H(this, oi).call(this, t)] = e;
}, Fi = new WeakMap(), En = new WeakMap(), Al = new WeakMap(), oi = new WeakMap(), To = new WeakSet(), wh = function(t) {
  if (st(this, xn, ba).call(this))
    return;
  const e = H(this, Vt).aToken[H(this, Ut) - H(this, Bi, jn)];
  H(this, In).test(e) ? st(this, So, Rh).call(this, !1) : (this.sys.callHook("stopOnStep", {}), H(this, Fi).stepin(t));
}, So = new WeakSet(), Rh = function(t) {
  this.sys.callHook(`stopOnStep${t ? "Out" : ""}`, {}), et(this, zs, H(this, he).length - (t ? 1 : 0)), et(this, Ut, H(this, Ut) - H(this, Bi, jn)), et(this, Ee, t ? 7 : 6), this.main.setLoop(!0), this.main.resume();
}, zs = new WeakMap(), Bi = new WeakSet(), jn = function() {
  return H(this, Ee) === 2 || H(this, Ee) === 4 ? 1 : 0;
}, xn = new WeakSet(), ba = function() {
  return H(this, Ut) < H(this, Vt).len ? !1 : (this.sys.callHook("stopOnEntry", {}), this.main.setLoop(!1, "\u30B9\u30AF\u30EA\u30D7\u30C8\u7D42\u7AEF\u3067\u3059"), !0);
}, Tn = new WeakMap(), ui = new WeakMap(), Ee = new WeakMap(), Ol = new WeakSet(), uf = function(t) {
  switch (H(this, Ee)) {
    case 6:
      st(this, Sn, Ea).call(this), et(this, Ee, 7);
      break;
    case 7:
      if (H(this, he).length !== H(this, zs))
        break;
      return et(this, Ee, 4), this.main.setLoop(!1, "\u30B9\u30C6\u30C3\u30D7\u5B9F\u884C"), this.sys.send2Dbg("stopOnStep", {}), !0;
    case 5:
      st(this, Sn, Ea).call(this), et(this, Ee, 4);
      break;
    case 4:
      return st(this, Sn, Ea).call(this), this.main.setLoop(!1, "\u30B9\u30C6\u30C3\u30D7\u5B9F\u884C"), this.sys.send2Dbg("stopOnStep", {}), !0;
    case 3:
      st(this, Sn, Ea).call(this), et(this, Ee, 0);
      break;
    default:
      if (tagToken2Name(t) in H(Qe, ui))
        return et(this, Ee, 2), this.main.setLoop(!1, `\u95A2\u6570 ${t} \u30D6\u30EC\u30FC\u30AF`), this.sys.callHook("stopOnBreakpoint", {}), this.sys.send2Dbg("stopOnBreakpoint", {}), !0;
      {
        const e = H(Qe, Tn)[H(this, oi).call(this, H(this, te))];
        if (!e)
          break;
        const o = e[H(this, ce)];
        if (!o)
          break;
        if (o.condition) {
          if (!this.prpPrs.parse(o.condition))
            break;
        } else if ("hitCondition" in o && --o.hitCondition > 0)
          break;
        const R = H(this, Ee) === 0;
        et(this, Ee, 2), this.main.setLoop(!1, R ? (o.condition ? "\u6761\u4EF6" : "\u30D2\u30C3\u30C8\u30AB\u30A6\u30F3\u30C8") + "\u30D6\u30EC\u30FC\u30AF" : "\u30B9\u30C6\u30C3\u30D7\u5B9F\u884C");
        const N = R ? "stopOnBreakpoint" : "stopOnStep";
        this.sys.callHook(N, {}), this.sys.send2Dbg(N, {});
      }
      return !0;
  }
  return !1;
}, Sn = new WeakSet(), Ea = function() {
  var e;
  const t = (e = H(Qe, Tn)[getFn(H(this, te))]) == null ? void 0 : e[H(this, ce)];
  t != null && t.hitCondition && --t.hitCondition;
}, Nl = new WeakSet(), lf = function() {
  var $, k;
  const t = H(this, Ee) === 3 ? 1 : 0, e = H(this, Vt).aToken[H(this, Ut) - 1 + t], o = H(this, oi).call(this, H(this, te)), R = tagToken2Name(e), N = R ? `[${R}]` : e, M = ($ = this.val.getVal("mp:const.sn.macro")) != null ? $ : "{}";
  if (H(this, Ut) === 0)
    return [{ fn: o, ln: 1, col: 1, nm: N, ma: M }];
  const D = st(this, li, Xi).call(this, H(this, Vt), H(this, Ut)), L = [{ fn: o, ln: D.ln, col: D.col_s + 1, nm: N, ma: M }], B = H(this, he).length;
  if (B === 0)
    return L;
  for (let U = B - 1; U >= 0; --U) {
    const z = H(this, he)[U], X = H(this, ze)[z.fn], V = X.aToken[z.idx - 1], W = st(this, li, Xi).call(this, X, z.idx), Y = tagToken2Name(V);
    L.push({
      fn: H(this, oi).call(this, z.fn),
      ln: W.ln,
      col: W.col_s + 1,
      nm: Y ? `[${Y}]` : V,
      ma: (k = z.csArg[":hMp"]["const.sn.macro"]) != null ? k : "{}"
    });
  }
  return L;
}, js = new WeakMap(), Vs = new WeakMap(), ar = new WeakMap(), Ml = new WeakSet(), hf = function(t) {
  var N;
  const { name: e } = t;
  if (!e)
    throw "name\u306F\u5FC5\u9808\u3067\u3059";
  let o = "";
  const R = H(this, Vt).len;
  for (; H(this, Ut) < R && (o = H(this, Vt).aToken[H(this, Ut)], o === ""); ++Re(this, Ut)._)
    ;
  return t.text = o, t.cast = "str", this.hTag.let(t), et(this, Ut, H(this, Ut) + 2), et(this, ce, H(this, ce) + ((N = o.match(/\n/g)) != null ? N : []).length), !1;
}, Dl = new WeakSet(), cf = function() {
  var R;
  if (H(this, Ut) === 0)
    return console.group(`\u{1F95F} [dump_stack] \u30B9\u30AF\u30EA\u30D7\u30C8\u73FE\u5728\u5730 fn:${H(this, te)} line:${1} col:${0}`), console.groupEnd(), !1;
  const t = st(this, li, Xi).call(this, H(this, Vt), H(this, Ut)), e = `\u30B9\u30AF\u30EA\u30D7\u30C8\u73FE\u5728\u5730 fn:${H(this, te)} line:${t.ln} col:${t.col_s + 1}`;
  console.group(`\u{1F95F} [dump_stack] ${e}`);
  const o = H(this, he).length;
  if (o > 0) {
    console.info(e);
    for (let N = o - 1; N >= 0; --N) {
      const M = H(this, he)[N], D = M.csArg[":hMp"], L = D ? D[":\u30BF\u30B0\u540D"] : void 0, B = (R = M.csArg[":\u30BF\u30B0\u540D"]) != null ? R : "", $ = st(this, li, Xi).call(this, H(this, ze)[M.fn], M.idx);
      console.info(
        `${o - N}\u3064\u524D\u306E\u30B3\u30FC\u30EB\u5143 fn:${M.fn} line:${$.ln} col:${$.col_s + 1}` + (L ? "\uFF08[" + L + "]\u30DE\u30AF\u30ED\u5185\uFF09" : " ") + `\u3067 [${B} ...]\u3092\u30B3\u30FC\u30EB`
      );
    }
  }
  return console.groupEnd(), !1;
}, li = new WeakSet(), Xi = function(t, e) {
  const o = { ln: 1, col_s: 0, col_e: 0 };
  if (!t)
    return o;
  let R = e - 1;
  const N = o.ln = t.aLNum[R];
  for (; t.aLNum[R] === N; ) {
    if (t.aToken[R].charAt(0) !== `
`) {
      const M = t.aToken[R].length;
      o.col_e > 0 && (o.col_s += M), o.col_e += M;
    }
    if (--R < 0)
      break;
  }
  return o;
}, Ll = new WeakSet(), ff = function(t) {
  const { set_fnc: e, break_fnc: o } = t;
  if (!e)
    throw "set_fnc\u306F\u5FC5\u9808\u3067\u3059";
  if (et(this, $i, globalThis[e]), !H(this, $i)) {
    if (argChk_Boolean(t, "need_err", !0))
      throw `HTML\u5185\u306B\u95A2\u6570${e}\u304C\u898B\u3064\u304B\u308A\u307E\u305B\u3093`;
    return et(this, $i, () => {
    }), !1;
  }
  if (this.noticeBreak = (R) => {
    var N;
    H(this, Xs) !== H(this, te) && (et(this, Xs, H(this, te)), H(this, $i).call(this, H(this, Ws)[H(this, te)] = (N = H(this, Ws)[H(this, te)]) != null ? N : H(this, Vt).aToken.join(""))), H(this, ki).call(this, H(this, ce), R);
  }, this.noticeBreak(!0), !o)
    return !1;
  if (et(this, ki, globalThis[o]), !H(this, ki)) {
    if (argChk_Boolean(t, "need_err", !0))
      throw `HTML\u5185\u306B\u95A2\u6570${o}\u304C\u898B\u3064\u304B\u308A\u307E\u305B\u3093`;
    et(this, ki, () => {
    });
  }
  return !1;
}, $i = new WeakMap(), ki = new WeakMap(), Xs = new WeakMap(), Ws = new WeakMap(), Ys = new WeakMap(), Ye = new WeakMap(), Fl = new WeakSet(), df = function() {
  if (H(this, Ye)[0] === -1)
    throw "if\u30D6\u30ED\u30C3\u30AF\u5185\u3067\u306F\u3042\u308A\u307E\u305B\u3093";
  return et(this, Ut, H(this, Ye)[0]), H(this, Ye).shift(), !1;
}, Bl = new WeakSet(), pf = function(t) {
  var L;
  const { exp: e } = t;
  if (!e)
    throw "exp\u306F\u5FC5\u9808\u3067\u3059";
  if (e.charAt(0) === "&")
    throw "\u5C5E\u6027exp\u306F\u300C&\u300D\u304C\u4E0D\u8981\u3067\u3059";
  let o = 0, R = this.prpPrs.parse(e) ? H(this, Ut) : -1;
  const N = H(this, Vt).aLNum[H(this, Ut)];
  let M = H(this, ce) - (N || 0);
  const D = H(this, Vt).len;
  for (; H(this, Ut) < D; ++Re(this, Ut)._) {
    const B = H(this, Vt).aLNum[H(this, Ut)];
    H(this, Vt).aLNum[H(this, Ut)] = (B || 0) + M;
    const $ = H(this, Vt).aToken[H(this, Ut)];
    if (!$)
      continue;
    const k = $.charCodeAt(0);
    if (k === 10) {
      et(this, ce, H(this, ce) + $.length);
      continue;
    }
    if (k !== 91)
      continue;
    const [U, z] = tagToken2Name_Args($);
    if (!(U in this.hTag))
      throw `\u672A\u5B9A\u7FA9\u306E\u30BF\u30B0[${U}]\u3067\u3059`;
    switch (this.alzTagArg.go(z), U) {
      case "if":
        ++o;
        break;
      case "elsif":
        if (o > 0 || R > -1)
          break;
        const X = (L = this.alzTagArg.hPrm.exp.val) != null ? L : "";
        if (X.charAt(0) === "&")
          throw "\u5C5E\u6027exp\u306F\u300C&\u300D\u304C\u4E0D\u8981\u3067\u3059";
        this.prpPrs.parse(X) && (R = H(this, Ut) + 1);
        break;
      case "else":
        if (o > 0)
          break;
        R === -1 && (R = H(this, Ut) + 1);
        break;
      case "endif":
        if (o > 0) {
          --o;
          break;
        }
        return R === -1 ? (++Re(this, Ut)._, H(this, Vt).aLNum[H(this, Ut)] += M) : (H(this, Ye).unshift(H(this, Ut) + 1), et(this, Ut, R), et(this, ce, H(this, Vt).aLNum[H(this, Ut)])), !1;
    }
  }
  throw "[endif]\u304C\u306A\u3044\u307E\u307E\u30B9\u30AF\u30EA\u30D7\u30C8\u7D42\u7AEF\u3067\u3059";
}, $l = new WeakSet(), vf = function(t) {
  argChk_Boolean(t, "count", !1) || st(this, Lo, Dh).call(this);
  const { fn: e } = t;
  return e && H(this, En).call(this, e), st(this, Co, Ph).call(this, { ":hEvt1Time": H(this, Vs).popLocalEvts(), ":hMp": this.val.cloneMp() }), argChk_Boolean(t, "clear_local_event", !1) && this.hTag.clear_event({}), st(this, Ui, Vn).call(this, e, t.label), !0;
}, Co = new WeakSet(), Ph = function(t) {
  H(this, Vt).aLNum[H(this, Ut)] = H(this, ce), H(this, qs) || (t[":resvToken"] = "", st(this, Cn, xa).call(this)), H(this, he).push(new CallStack(H(this, te), H(this, Ut), t)), H(this, Ye).unshift(-1);
}, kl = new WeakSet(), gf = function(t) {
  return argChk_Boolean(t, "count", !0) || st(this, Lo, Dh).call(this), H(this, Ye)[0] = -1, st(this, Ui, Vn).call(this, t.fn, t.label), !0;
}, Gl = new WeakSet(), _f = function(t) {
  if (H(this, Ae) === -1)
    return !1;
  if (argChk_Boolean(t, "clear", !1))
    return et(this, vr, []), et(this, Ae, -1), !1;
  const { to: e } = t;
  if (!e)
    throw "clear\u304Bto\u306F\u5FC5\u9808\u3067\u3059";
  const o = H(this, Ae);
  switch (e) {
    case "prev":
      H(this, Ae) > 0 && --Re(this, Ae)._;
      break;
    case "next":
      const D = H(this, vr).length;
      H(this, Ae) < D - 1 && ++Re(this, Ae)._;
      break;
    default:
      throw `\u5C5E\u6027to\u300C${e}\u300D\u306F\u7570\u5E38\u3067\u3059`;
  }
  if (o === H(this, Ae))
    return !1;
  const R = H(this, vr)[H(this, Ae)], { fn: N, idx: M } = st(this, ea, iu).call(this);
  return R.key === M + ":" + N ? !1 : st(this, ta, ru).call(this, { fn: R.retFn, index: R.retIdx }, R.retMark);
}, Ul = new WeakSet(), mf = function(t) {
  if (argChk_Boolean(t, "clear", !1))
    et(this, he, []);
  else if (!H(this, he).pop())
    throw "[pop_stack] \u30B9\u30BF\u30C3\u30AF\u304C\u7A7A\u3067\u3059";
  return st(this, Cn, xa).call(this), et(this, Ye, [-1]), this.val.setMp({}), !1;
}, Io = new WeakSet(), Ah = function() {
  const t = H(this, he).pop();
  if (!t)
    throw "[return] \u30B9\u30BF\u30C3\u30AF\u304C\u7A7A\u3067\u3059";
  const e = t.csArg;
  H(this, Ye).shift();
  const o = e[":hMp"];
  o && this.val.setMp(o);
  const R = e[":resvToken"];
  return R ? this.nextToken = () => (st(this, Cn, xa).call(this), R) : st(this, Cn, xa).call(this), e[":hEvt1Time"] && H(this, Vs).pushLocalEvts(e[":hEvt1Time"]), t.fn in H(this, ze) ? (st(this, Oo, Mh).call(this, t), !1) : (st(this, Ui, Vn).call(this, t.fn, "", t.idx), !0);
}, qs = new WeakMap(), Cn = new WeakSet(), xa = function() {
  et(this, qs, ""), this.nextToken = st(this, wo, Oh);
}, Gi = new WeakMap(), Ui = new WeakSet(), Vn = function(t = "", e = "", o = 0) {
  if (!t && !e && this.main.errScript("[jump\u7CFB] fn\u307E\u305F\u306Flabel\u306F\u5FC5\u9808\u3067\u3059"), e ? (e.charAt(0) !== "*" && this.main.errScript("[jump\u7CFB] label\u306F*\u3067\u59CB\u307E\u308A\u307E\u3059"), et(this, Gi, e), H(this, Gi).slice(0, 2) !== "**" && et(this, Ut, o)) : (et(this, Gi, ""), et(this, Ut, o)), !t) {
    this.analyzeInit();
    return;
  }
  const R = H(this, En).call(this, t);
  if (t === H(this, te)) {
    this.analyzeInit();
    return;
  }
  et(this, te, t);
  const N = H(this, ze)[H(this, te)];
  if (N) {
    et(this, Vt, N), this.analyzeInit();
    return;
  }
  new Loader().add({ name: H(this, te), url: R }).use((M, D) => {
    try {
      M.data = this.sys.decStr(M.extension, M.data);
    } catch (L) {
      this.main.errScript(`[jump\u7CFB]sn\u30ED\u30FC\u30C9\u5931\u6557\u3067\u3059 fn:${M.name} ${L}`, !1);
    }
    D == null || D();
  }).load((M, D) => {
    this.nextToken = st(this, wo, Oh), et(this, ce, 1), st(this, zl, bf).call(this, D[t].data), this.hTag.record_place({}), this.main.resume(() => this.analyzeInit());
  }), this.main.stop();
}, wo = new WeakSet(), Oh = function() {
  var e, o;
  if (st(this, Ro, Nh).call(this))
    return "";
  st(this, jl, Ef).call(this), (e = H(this, Vt).aLNum)[o = H(this, Ut)] || (e[o] = H(this, ce));
  const t = H(this, Vt).aToken[H(this, Ut)];
  return H(this, Zs).call(this, t), ++Re(this, Ut)._, t;
}, Zs = new WeakMap(), Ro = new WeakSet(), Nh = function() {
  return H(this, Ut) < H(this, Vt).len ? !1 : (this.main.errScript("\u30B9\u30AF\u30EA\u30D7\u30C8\u7D42\u7AEF\u3067\u3059"), !0);
}, Po = new WeakMap(), Ao = new WeakMap(), Ks = new WeakMap(), Hi = new WeakMap(), Js = new WeakMap(), Hl = new WeakSet(), yf = function(t, e, o, R, N) {
  var $, k, U, z, X;
  const M = t.aToken.length;
  if (!R) {
    if (st(this, Ro, Nh).call(this))
      return { idx: N, ln: o };
    if (t.aLNum[N])
      o = t.aLNum[N];
    else {
      o = 1;
      for (let V = 0; V < N; ++V) {
        ($ = t.aLNum)[V] || ($[V] = o);
        const W = t.aToken[V];
        W.charCodeAt(0) === 10 ? o += W.length : o += ((k = W.match(/\n/g)) != null ? k : []).length;
      }
      t.aLNum[N] = o;
    }
    return { idx: N, ln: o };
  }
  t.aLNum[0] = 1;
  const D = R.match(H(this, Po));
  if (D) {
    R = D[1];
    let V = N;
    switch (D[2]) {
      case "before":
        for (; t.aToken[--V] !== R; )
          V === 0 && DebugMng.myTrace("[jump\u7CFB \u7121\u540D\u30E9\u30D9\u30EBbefore] " + o + "\u884C\u76EE\u4EE5\u524D\u3067" + (e ? "\u30DE\u30AF\u30ED\u5185\u306B" : "") + "\u30E9\u30D9\u30EB\u3010" + R + "\u3011\u304C\u3042\u308A\u307E\u305B\u3093", "ET"), e && t.aToken[V].search(H(this, Ao)) > -1 && DebugMng.myTrace("[jump\u7CFB \u7121\u540D\u30E9\u30D9\u30EBbefore] \u30DE\u30AF\u30ED\u5185\u306B\u30E9\u30D9\u30EB\u3010" + R + "\u3011\u304C\u3042\u308A\u307E\u305B\u3093", "ET");
        return { idx: V + 1, ln: t.aLNum[V] };
      case "after":
        for (; t.aToken[++V] !== R; )
          V === M && DebugMng.myTrace("[jump\u7CFB \u7121\u540D\u30E9\u30D9\u30EBafter] " + o + "\u884C\u76EE\u4EE5\u5F8C\u3067\u30DE\u30AF\u30ED\u5185\u306B\u30E9\u30D9\u30EB\u3010" + R + "\u3011\u304C\u3042\u308A\u307E\u305B\u3093", "ET"), t.aToken[V].search(H(this, Ks)) > -1 && DebugMng.myTrace("[jump\u7CFB \u7121\u540D\u30E9\u30D9\u30EBafter] " + o + "\u884C\u76EE\u4EE5\u5F8C\u3067\u30DE\u30AF\u30ED\u5185\u306B\u30E9\u30D9\u30EB\u3010" + R + "\u3011\u304C\u3042\u308A\u307E\u305B\u3093", "ET");
        return { idx: V + 1, ln: t.aLNum[V] };
      default:
        DebugMng.myTrace("[jump\u7CFB] \u7121\u540D\u30E9\u30D9\u30EB\u6307\u5B9A\u3010label=" + R + "\u3011\u304C\u9593\u9055\u3063\u3066\u3044\u307E\u3059", "ET");
    }
  }
  o = 1;
  const L = new RegExp(
    "^" + R.replaceAll("*", "\\*") + "(?:\\s|;|\\[|$)"
  );
  let B = !1;
  for (let V = 0; V < M; ++V) {
    (U = t.aLNum)[V] || (U[V] = o);
    const W = t.aToken[V];
    if (B) {
      H(this, Js).lastIndex = 0, H(this, Js).test(W) ? B = !1 : o += ((z = W.match(/\n/g)) != null ? z : []).length;
      continue;
    }
    const Y = W.charCodeAt(0);
    if (Y === 10) {
      o += W.length;
      continue;
    }
    if (Y === 42) {
      if (W.search(L) > -1)
        return { idx: V + 1, ln: o };
      continue;
    }
    Y === 91 && (o += ((X = W.match(/\n/g)) != null ? X : []).length, H(this, Hi).lastIndex = 0, H(this, Hi).test(W) && (B = !0));
  }
  throw B ? "[let_ml]\u306E\u7D42\u7AEF\u30FB[endlet_ml]\u304C\u3042\u308A\u307E\u305B\u3093" : (DebugMng.myTrace(`[jump\u7CFB] \u30E9\u30D9\u30EB\u3010${R}\u3011\u304C\u3042\u308A\u307E\u305B\u3093`, "ET"), "Dummy");
}, ze = new WeakMap(), zl = new WeakSet(), bf = function(t) {
  const e = H(this, ai).matchToken(t.replace(/(\r\n|\r)/g, `
`));
  for (let R = e.length - 1; R >= 0; --R) {
    const N = e[R];
    if (H(this, Hi).lastIndex = 0, H(this, Hi).test(N)) {
      const M = N.indexOf("]") + 1;
      if (M === 0)
        throw "[let_ml]\u3067\u9589\u3058\u308B\u3010]\u3011\u304C\u3042\u308A\u307E\u305B\u3093";
      const D = N.slice(0, M), L = N.slice(M);
      e.splice(R, 1, D, L);
    }
  }
  et(this, Vt, { aToken: e, len: e.length, aLNum: [] });
  let o = "";
  try {
    o = "ScriptIterator.replaceScriptChar2macro", H(this, ai).replaceScr_C2M_And_let_ml(H(this, Vt)), o = "ScriptIterator.replaceScript_Wildcard", H(this, Do).call(this);
  } catch (R) {
    if (R instanceof Error) {
      const N = R;
      o += `\u4F8B\u5916 mes=${N.message}(${N.name})`;
    } else
      o = R;
    this.main.errScript(o, !1);
  }
  H(this, ze)[H(this, te)] = H(this, Vt), this.val.loadScrWork(H(this, te));
}, Oo = new WeakSet(), Mh = function(t) {
  et(this, te, t.fn), et(this, Ut, t.idx);
  const e = H(this, ze)[H(this, te)];
  e && et(this, Vt, e), et(this, ce, H(this, Vt).aLNum[t.idx]);
}, No = new WeakMap(), Mo = new WeakMap(), Do = new WeakMap(), jl = new WeakSet(), Ef = function() {
  const t = this.val.getAreaKidoku(H(this, te));
  if (!t)
    throw `recordKidoku fn:'${H(this, te)}' (areas === null)`;
  if (H(this, he).length > 0) {
    t.record(H(this, Ut));
    return;
  }
  et(this, Ur, t.search(H(this, Ut))), this.val.setVal_Nochk("tmp", "const.sn.isKidoku", H(this, Ur)), !H(this, Ur) && t.record(H(this, Ut));
}, Ur = new WeakMap(), Lo = new WeakSet(), Dh = function() {
  var t;
  (t = this.val.getAreaKidoku(H(this, te))) == null || t.erase(H(this, Ut)), et(this, Ur, !1);
}, Vl = new WeakSet(), xf = function(t) {
  return H(this, ai).bracket2macro(t, H(this, Vt), H(this, Ut)), !1;
}, Xl = new WeakSet(), Tf = function(t) {
  return H(this, ai).char2macro(t, this.hTag, H(this, Vt), H(this, Ut)), !1;
}, Wl = new WeakSet(), Sf = function(t) {
  var N, M, D;
  const { name: e } = t;
  if (!e)
    throw "name\u306F\u5FC5\u9808\u3067\u3059";
  if (e in this.hTag)
    throw `[${e}]\u306F\u30BF\u30B0\u304B\u3059\u3067\u306B\u5B9A\u7FA9\u6E08\u307F\u306E\u30DE\u30AF\u30ED\u3067\u3059`;
  const o = H(this, ce), R = new CallStack(H(this, te), H(this, Ut));
  for (et(this, Qs, H(this, Qs) + ("|" + e)), et(this, In, new RegExp(`\\[(${H(this, Qs)})\\b`)), this.hTag[e] = (L) => (L.design_unit = t.design_unit, st(this, Co, Ph).call(this, { ...L, ":hMp": this.val.cloneMp() }), this.val.setMp(L), this.val.setVal_Nochk("mp", "const.sn.macro", JSON.stringify(t)), this.val.setVal_Nochk("mp", "const.sn.me_call_scriptFn", H(this, te)), et(this, ce, o), st(this, Oo, Mh).call(this, R), !1); H(this, Ut) < H(this, Vt).len; ++Re(this, Ut)._) {
    (N = H(this, Vt).aLNum)[M = H(this, Ut)] || (N[M] = H(this, ce));
    const L = H(this, Vt).aToken[H(this, Ut)];
    if (L.search(H(this, Ks)) > -1)
      return ++Re(this, Ut)._, !1;
    const B = L.charCodeAt(0);
    B === 10 ? et(this, ce, H(this, ce) + L.length) : B === 91 && et(this, ce, H(this, ce) + ((D = L.match(/\n/g)) != null ? D : []).length);
  }
  throw `\u30DE\u30AF\u30ED[${e}]\u5B9A\u7FA9\u306E\u7D42\u7AEF\u30FB[endmacro]\u304C\u3042\u308A\u307E\u305B\u3093`;
}, Qs = new WeakMap(), In = new WeakMap(), Yl = new WeakSet(), Cf = function(t) {
  if (!("place" in t))
    throw "place\u306F\u5FC5\u9808\u3067\u3059";
  const e = Number(t.place);
  if ("fn" in t != "label" in t)
    throw "fn\u3068label\u306F\u30BB\u30C3\u30C8\u3067\u6307\u5B9A\u3057\u3066\u4E0B\u3055\u3044";
  const o = this.val.getMark(e);
  if (!o)
    throw `place\u3010${e}\u3011\u306F\u5B58\u5728\u3057\u307E\u305B\u3093`;
  return st(this, ta, ru).call(this, t, o);
}, ta = new WeakSet(), ru = function(t, e, o = !0) {
  this.hTag.clear_event({}), this.val.mark2save(e), this.val.setMp({}), H(this, ar).recText("", !0), o && this.sndMng.playLoopFromSaveObj(), argChk_Boolean(t, "do_rec", !0) && et(this, pr, {
    hSave: this.val.cloneSave(),
    hPages: { ...e.hPages },
    aIfStk: [...e.aIfStk]
  });
  const R = {
    enabled: this.val.getVal("save:const.sn.autowc.enabled"),
    text: this.val.getVal("save:const.sn.autowc.text"),
    time: Number(this.val.getVal("save:const.sn.autowc.time"))
  };
  this.hTag.autowc(R);
  const N = String(this.val.getVal("save:const.sn.scriptFn")), M = Number(this.val.getVal("save:const.sn.scriptIdx"));
  return et(this, Ye, [...H(this, pr).aIfStk]), et(this, he, []), H(this, ar).cover(!0), H(this, ar).stopAllTw(), "index" in t ? (H(this, ar).playback(H(this, pr).hPages, () => {
    var D, L;
    H(this, ar).cover(!1), et(this, wn, !0), st(this, Ui, Vn).call(this, (D = t.fn) != null ? D : N, "", (L = t.index) != null ? L : M);
  }), !0) : (delete H(this, ze)[N], H(this, ar).playback(
    H(this, pr).hPages,
    "label" in t ? () => {
      H(this, ar).cover(!1), et(this, te, N), et(this, Ut, M), this.hTag.call({ fn: t.fn, label: t.label });
    } : () => {
      H(this, ar).cover(!1), st(this, Ui, Vn).call(this, N, "", M);
    }
  ), !0);
}, wn = new WeakMap(), ql = new WeakSet(), If = function(t) {
  const e = this.val.getMark(0);
  return delete H(this, ze)[getFn(e.hSave["const.sn.scriptFn"])], t.do_rec = !1, st(this, ta, ru).call(this, t, e, !1);
}, pr = new WeakMap(), Zl = new WeakSet(), wf = function() {
  if (this.main.isDestroyed())
    return !1;
  const { fn: t, idx: e } = st(this, ea, iu).call(this);
  return this.val.setVal_Nochk("save", "const.sn.scriptFn", t), this.val.setVal_Nochk("save", "const.sn.scriptIdx", e), et(this, pr, {
    hSave: this.val.cloneSave(),
    hPages: H(this, ar).record(),
    aIfStk: H(this, Ye).slice(H(this, he).length)
  }), !1;
}, ea = new WeakSet(), iu = function() {
  if (H(this, he).length === 0)
    return {
      fn: H(this, te),
      idx: H(this, Ut)
    };
  const e = H(this, he)[0];
  return {
    fn: e.fn,
    idx: e.idx
  };
}, Kl = new WeakSet(), Rf = function(t) {
  var R;
  if (!("place" in t))
    throw "place\u306F\u5FC5\u9808\u3067\u3059";
  const e = Number(t.place);
  delete t[":\u30BF\u30B0\u540D"], delete t.place, t.text = ((R = t.text) != null ? R : "").replace(/^(<br\/>)+/, ""), H(this, pr).json = t, this.val.setMark(e, H(this, pr));
  const o = Number(this.val.getVal("sys:const.sn.save.place"));
  return e === o && this.val.setVal_Nochk("sys", "const.sn.save.place", o + 1), !1;
}, vr = new WeakMap(), Ae = new WeakMap(), it(ScriptIterator, Al, /(.+)\/crypto_prj\/([^\/]+)\/[^\.]+(\.\w+)/), it(ScriptIterator, Tn, {}), it(ScriptIterator, ui, {});
var qe, Ze, Le, gr, hi, Rn, Fe, Fo, ci, ra, zi, ia, na, Pn, Jl, Pf, sa, aa, An, oa, nu, ji, On;
class Main {
  constructor(t) {
    it(this, Jl);
    it(this, oa);
    it(this, qe, void 0);
    it(this, Ze, void 0);
    it(this, Le, void 0);
    it(this, gr, void 0);
    it(this, hi, void 0);
    it(this, Rn, void 0);
    it(this, Fe, void 0);
    it(this, Fo, void 0);
    it(this, ci, void 0);
    it(this, ra, void 0);
    it(this, zi, void 0);
    it(this, ia, void 0);
    it(this, na, void 0);
    it(this, Pn, void 0);
    it(this, sa, void 0);
    it(this, aa, void 0);
    it(this, An, void 0);
    it(this, ji, void 0);
    it(this, On, void 0);
    this.sys = t, et(this, Le, /* @__PURE__ */ Object.create(null)), et(this, zi, () => {
    }), et(this, ia, new AnalyzeTagArg()), et(this, na, !1), et(this, Pn, "skynovel"), et(this, sa, () => H(this, zi).call(this)), et(this, aa, (e = st(this, oa, nu)) => {
      H(this, ji) || (H(this, ci).clearBreak(), et(this, zi, e), this.resume = (o = st(this, oa, nu)) => {
        et(this, zi, o);
      }, H(this, Fe).noticeBreak(!1));
    }), this.resume = H(this, aa), this.stop = () => {
      et(this, zi, () => {
      }), this.resume = H(this, aa), H(this, Fe).noticeBreak(!0);
    }, et(this, An, !0), et(this, ji, !1), this.isDestroyed = () => H(this, ji), skipHello(), Config.generate(t).then((e) => et(this, qe, e)).then(() => st(this, Jl, Pf).call(this)).catch((e) => console.error("load err fn:prj.json e:%o", e));
  }
  errScript(t, e = !0) {
    if (this.stop(), DebugMng.myTrace(t), CmnLib.debugLog && console.log("\u{1F35C} SKYNovel err!"), e)
      throw t;
  }
  resumeByJumpOrCall(t) {
    var e, o;
    if (t.url) {
      globalThis.open(t.url);
      return;
    }
    H(this, gr).setVal_Nochk("tmp", "sn.eventArg", (e = t.arg) != null ? e : ""), H(this, gr).setVal_Nochk("tmp", "sn.eventLabel", (o = t.label) != null ? o : ""), argChk_Boolean(t, "call", !1) ? (H(this, Fe).subIdxToken(), this.resume(() => H(this, Le).call(t))) : (H(this, Le).clear_event({}), this.resume(() => H(this, Le).jump(t)));
  }
  setLoop(t, e = "") {
    et(this, An, t) ? this.resume() : this.stop(), this.sys.setTitleInfo(e ? ` -- ${e}\u4E2D` : "");
  }
  fire(t, e) {
    H(this, ra).fire(t, e);
  }
  async destroy(t = 0) {
    H(this, ji) || (et(this, ji, !0), H(this, na) && (this.stop(), et(this, An, !1), H(this, ci).before_destroy(), t > 0 && await new Promise((e) => setTimeout(e, t)), et(this, Le, {}), H(this, ra).destroy(), H(this, Fe).destroy(), H(this, ci).destroy(), H(this, Fo).destroy(), H(this, Ze).ticker.remove(H(this, sa)), H(this, On) && H(this, Ze) && H(this, Ze).view.parentNode.appendChild(H(this, On)), clearTextureCache(), H(this, Ze).destroy(!0)));
  }
}
qe = new WeakMap(), Ze = new WeakMap(), Le = new WeakMap(), gr = new WeakMap(), hi = new WeakMap(), Rn = new WeakMap(), Fe = new WeakMap(), Fo = new WeakMap(), ci = new WeakMap(), ra = new WeakMap(), zi = new WeakMap(), ia = new WeakMap(), na = new WeakMap(), Pn = new WeakMap(), Jl = new WeakSet(), Pf = async function() {
  var R, N, M;
  const t = (R = document.createElement("canvas")) == null ? void 0 : R.getContext("2d");
  if (!t)
    throw "argChk_Color err";
  CmnLib.cc4ColorName = t;
  const e = {
    width: H(this, qe).oCfg.window.width,
    height: H(this, qe).oCfg.window.height,
    backgroundColor: parseColor(String(H(this, qe).oCfg.init.bg_color)),
    resolution: (N = globalThis.devicePixelRatio) != null ? N : 1,
    autoResize: !0
  }, o = document.getElementById(H(this, Pn));
  o && (et(this, On, o.cloneNode(!0)), H(this, On).id = H(this, Pn), e.view = o), et(this, Ze, new Application(e)), o || (document.body.appendChild(H(this, Ze).view), H(this, Ze).view.id = H(this, Pn)), et(this, gr, new Variable(H(this, qe), H(this, Le))), et(this, hi, new PropParser(H(this, gr), (M = H(this, qe).oCfg.init.escape) != null ? M : "\\")), await Promise.allSettled(this.sys.init(H(this, Le), H(this, Ze), H(this, gr), this)), H(this, Le).title({ text: H(this, qe).oCfg.book.title || "SKYNovel" }), et(this, Rn, new SoundMng(H(this, qe), H(this, Le), H(this, gr), this, this.sys)), et(this, Fe, new ScriptIterator(H(this, qe), H(this, Le), this, H(this, gr), H(this, ia), () => st(this, oa, nu).call(this), H(this, hi), H(this, Rn), this.sys)), et(this, Fo, new DebugMng(this.sys, H(this, Le), H(this, Fe))), et(this, ci, new LayerMng(H(this, qe), H(this, Le), H(this, Ze), H(this, gr), this, H(this, Fe), this.sys, H(this, Rn), H(this, ia), H(this, hi))), et(this, ra, new EventMng(H(this, qe), H(this, Le), H(this, Ze), this, H(this, ci), H(this, gr), H(this, Rn), H(this, Fe), this.sys)), H(this, Ze).ticker.add(H(this, sa)), this.resumeByJumpOrCall({ fn: "main" }), et(this, na, !0);
}, sa = new WeakMap(), aa = new WeakMap(), An = new WeakMap(), oa = new WeakSet(), nu = function() {
  var t;
  for (; H(this, An); ) {
    let e = H(this, Fe).nextToken();
    if (!e)
      break;
    const o = e.charCodeAt(0);
    if (o !== 9) {
      if (o === 10) {
        H(this, Fe).addLineNum(e.length);
        continue;
      }
      if (o === 91) {
        if (H(this, Fe).isBreak(e))
          return;
        try {
          const R = ((t = e.match(/\n/g)) != null ? t : []).length;
          if (R > 0 && H(this, Fe).addLineNum(R), H(this, Fe).\u30BF\u30B0\u89E3\u6790(e)) {
            this.stop();
            break;
          }
          continue;
        } catch (R) {
          if (R instanceof Error) {
            const N = R;
            let M = `\u30BF\u30B0\u89E3\u6790\u4E2D\u4F8B\u5916 mes=${N.message}(${N.name})`;
            M = `[${tagToken2Name(e)}]` + M, this.errScript(M, !1);
          } else
            this.errScript(String(R), !1);
          return;
        }
      }
      if (o === 38)
        try {
          if (e.slice(-1) !== "&") {
            if (H(this, Fe).isBreak(e))
              return;
            const R = splitAmpersand(e.slice(1));
            R.name = H(this, hi).getValAmpersand(R.name), R.text = String(H(this, hi).parse(R.text)), H(this, Le).let(R);
            continue;
          }
          if (e.charAt(1) === "&")
            throw new Error("\u300C&\u8868\u793A&\u300D\u66F8\u5F0F\u3067\u306F\u300C&\u300D\u6307\u5B9A\u304C\u4E0D\u8981\u3067\u3059");
          e = String(H(this, hi).parse(e.slice(1, -1)));
        } catch (R) {
          this.errScript(
            R instanceof Error ? `& \u5909\u6570\u64CD\u4F5C\u30FB\u8868\u793A mes=${R.message}(${R.name})` : R,
            !1
          );
          return;
        }
      else {
        if (o === 59)
          continue;
        if (o === 42 && e.length > 1)
          continue;
      }
      try {
        H(this, ci).currentTxtlayForeNeedErr.tagCh(e);
      } catch (R) {
        this.errScript(
          R instanceof Error ? `\u6587\u5B57\u8868\u793A mes=${R.message}(${R.name})` : R,
          !1
        );
        return;
      }
    }
  }
}, ji = new WeakMap(), On = new WeakMap();
var assign = make_assign(), create$1 = make_create(), trim$1 = make_trim(), Global$5 = typeof window < "u" ? window : commonjsGlobal$1, util$6 = {
  assign,
  create: create$1,
  trim: trim$1,
  bind: bind$1,
  slice: slice$1,
  each: each$7,
  map,
  pluck: pluck$1,
  isList: isList$1,
  isFunction: isFunction$1,
  isObject: isObject$1,
  Global: Global$5
};
function make_assign() {
  return Object.assign ? Object.assign : function(t, e, o, R) {
    for (var N = 1; N < arguments.length; N++)
      each$7(Object(arguments[N]), function(M, D) {
        t[D] = M;
      });
    return t;
  };
}
function make_create() {
  if (Object.create)
    return function(t, e, o, R) {
      var N = slice$1(arguments, 1);
      return assign.apply(this, [Object.create(t)].concat(N));
    };
  {
    let n = function() {
    };
    return function(e, o, R, N) {
      var M = slice$1(arguments, 1);
      return n.prototype = e, assign.apply(this, [new n()].concat(M));
    };
  }
}
function make_trim() {
  return String.prototype.trim ? function(t) {
    return String.prototype.trim.call(t);
  } : function(t) {
    return t.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, "");
  };
}
function bind$1(n, t) {
  return function() {
    return t.apply(n, Array.prototype.slice.call(arguments, 0));
  };
}
function slice$1(n, t) {
  return Array.prototype.slice.call(n, t || 0);
}
function each$7(n, t) {
  pluck$1(n, function(e, o) {
    return t(e, o), !1;
  });
}
function map(n, t) {
  var e = isList$1(n) ? [] : {};
  return pluck$1(n, function(o, R) {
    return e[R] = t(o, R), !1;
  }), e;
}
function pluck$1(n, t) {
  if (isList$1(n)) {
    for (var e = 0; e < n.length; e++)
      if (t(n[e], e))
        return n[e];
  } else
    for (var o in n)
      if (n.hasOwnProperty(o) && t(n[o], o))
        return n[o];
}
function isList$1(n) {
  return n != null && typeof n != "function" && typeof n.length == "number";
}
function isFunction$1(n) {
  return n && {}.toString.call(n) === "[object Function]";
}
function isObject$1(n) {
  return n && {}.toString.call(n) === "[object Object]";
}
var util$5 = util$6, slice = util$5.slice, pluck = util$5.pluck, each$6 = util$5.each, bind = util$5.bind, create = util$5.create, isList = util$5.isList, isFunction = util$5.isFunction, isObject = util$5.isObject, storeEngine = {
  createStore
}, storeAPI = {
  version: "2.0.12",
  enabled: !1,
  get: function(n, t) {
    var e = this.storage.read(this._namespacePrefix + n);
    return this._deserialize(e, t);
  },
  set: function(n, t) {
    return t === void 0 ? this.remove(n) : (this.storage.write(this._namespacePrefix + n, this._serialize(t)), t);
  },
  remove: function(n) {
    this.storage.remove(this._namespacePrefix + n);
  },
  each: function(n) {
    var t = this;
    this.storage.each(function(e, o) {
      n.call(t, t._deserialize(e), (o || "").replace(t._namespaceRegexp, ""));
    });
  },
  clearAll: function() {
    this.storage.clearAll();
  },
  hasNamespace: function(n) {
    return this._namespacePrefix == "__storejs_" + n + "_";
  },
  createStore: function() {
    return createStore.apply(this, arguments);
  },
  addPlugin: function(n) {
    this._addPlugin(n);
  },
  namespace: function(n) {
    return createStore(this.storage, this.plugins, n);
  }
};
function _warn() {
  var n = typeof console > "u" ? null : console;
  if (!!n) {
    var t = n.warn ? n.warn : n.log;
    t.apply(n, arguments);
  }
}
function createStore(n, t, e) {
  e || (e = ""), n && !isList(n) && (n = [n]), t && !isList(t) && (t = [t]);
  var o = e ? "__storejs_" + e + "_" : "", R = e ? new RegExp("^" + o) : null, N = /^[a-zA-Z0-9_\-]*$/;
  if (!N.test(e))
    throw new Error("store.js namespaces can only have alphanumerics + underscores and dashes");
  var M = {
    _namespacePrefix: o,
    _namespaceRegexp: R,
    _testStorage: function(L) {
      try {
        var B = "__storejs__test__";
        L.write(B, B);
        var $ = L.read(B) === B;
        return L.remove(B), $;
      } catch {
        return !1;
      }
    },
    _assignPluginFnProp: function(L, B) {
      var $ = this[B];
      this[B] = function() {
        var U = slice(arguments, 0), z = this;
        function X() {
          if (!!$)
            return each$6(arguments, function(W, Y) {
              U[Y] = W;
            }), $.apply(z, U);
        }
        var V = [X].concat(U);
        return L.apply(z, V);
      };
    },
    _serialize: function(L) {
      return JSON.stringify(L);
    },
    _deserialize: function(L, B) {
      if (!L)
        return B;
      var $ = "";
      try {
        $ = JSON.parse(L);
      } catch {
        $ = L;
      }
      return $ !== void 0 ? $ : B;
    },
    _addStorage: function(L) {
      this.enabled || this._testStorage(L) && (this.storage = L, this.enabled = !0);
    },
    _addPlugin: function(L) {
      var B = this;
      if (isList(L)) {
        each$6(L, function(U) {
          B._addPlugin(U);
        });
        return;
      }
      var $ = pluck(this.plugins, function(U) {
        return L === U;
      });
      if (!$) {
        if (this.plugins.push(L), !isFunction(L))
          throw new Error("Plugins must be function values that return objects");
        var k = L.call(this);
        if (!isObject(k))
          throw new Error("Plugins must return an object of function properties");
        each$6(k, function(U, z) {
          if (!isFunction(U))
            throw new Error("Bad plugin property: " + z + " from plugin " + L.name + ". Plugins should only return functions.");
          B._assignPluginFnProp(U, z);
        });
      }
    },
    addStorage: function(L) {
      _warn("store.addStorage(storage) is deprecated. Use createStore([storages])"), this._addStorage(L);
    }
  }, D = create(M, storeAPI, {
    plugins: []
  });
  return D.raw = {}, each$6(D, function(L, B) {
    isFunction(L) && (D.raw[B] = bind(D, L));
  }), each$6(n, function(L) {
    D._addStorage(L);
  }), each$6(t, function(L) {
    D._addPlugin(L);
  }), D;
}
var util$4 = util$6, Global$4 = util$4.Global, localStorage_1 = {
  name: "localStorage",
  read: read$5,
  write: write$5,
  each: each$5,
  remove: remove$5,
  clearAll: clearAll$5
};
function localStorage() {
  return Global$4.localStorage;
}
function read$5(n) {
  return localStorage().getItem(n);
}
function write$5(n, t) {
  return localStorage().setItem(n, t);
}
function each$5(n) {
  for (var t = localStorage().length - 1; t >= 0; t--) {
    var e = localStorage().key(t);
    n(read$5(e), e);
  }
}
function remove$5(n) {
  return localStorage().removeItem(n);
}
function clearAll$5() {
  return localStorage().clear();
}
var util$3 = util$6, Global$3 = util$3.Global, oldFFGlobalStorage = {
  name: "oldFF-globalStorage",
  read: read$4,
  write: write$4,
  each: each$4,
  remove: remove$4,
  clearAll: clearAll$4
}, globalStorage = Global$3.globalStorage;
function read$4(n) {
  return globalStorage[n];
}
function write$4(n, t) {
  globalStorage[n] = t;
}
function each$4(n) {
  for (var t = globalStorage.length - 1; t >= 0; t--) {
    var e = globalStorage.key(t);
    n(globalStorage[e], e);
  }
}
function remove$4(n) {
  return globalStorage.removeItem(n);
}
function clearAll$4() {
  each$4(function(n, t) {
    delete globalStorage[n];
  });
}
var util$2 = util$6, Global$2 = util$2.Global, oldIEUserDataStorage = {
  name: "oldIE-userDataStorage",
  write: write$3,
  read: read$3,
  each: each$3,
  remove: remove$3,
  clearAll: clearAll$3
}, storageName = "storejs", doc$1 = Global$2.document, _withStorageEl = _makeIEStorageElFunction(), disable = (Global$2.navigator ? Global$2.navigator.userAgent : "").match(/ (MSIE 8|MSIE 9|MSIE 10)\./);
function write$3(n, t) {
  if (!disable) {
    var e = fixKey(n);
    _withStorageEl(function(o) {
      o.setAttribute(e, t), o.save(storageName);
    });
  }
}
function read$3(n) {
  if (!disable) {
    var t = fixKey(n), e = null;
    return _withStorageEl(function(o) {
      e = o.getAttribute(t);
    }), e;
  }
}
function each$3(n) {
  _withStorageEl(function(t) {
    for (var e = t.XMLDocument.documentElement.attributes, o = e.length - 1; o >= 0; o--) {
      var R = e[o];
      n(t.getAttribute(R.name), R.name);
    }
  });
}
function remove$3(n) {
  var t = fixKey(n);
  _withStorageEl(function(e) {
    e.removeAttribute(t), e.save(storageName);
  });
}
function clearAll$3() {
  _withStorageEl(function(n) {
    var t = n.XMLDocument.documentElement.attributes;
    n.load(storageName);
    for (var e = t.length - 1; e >= 0; e--)
      n.removeAttribute(t[e].name);
    n.save(storageName);
  });
}
var forbiddenCharsRegex = new RegExp("[!\"#$%&'()*+,/\\\\:;<=>?@[\\]^`{|}~]", "g");
function fixKey(n) {
  return n.replace(/^\d/, "___$&").replace(forbiddenCharsRegex, "___");
}
function _makeIEStorageElFunction() {
  if (!doc$1 || !doc$1.documentElement || !doc$1.documentElement.addBehavior)
    return null;
  var n = "script", t, e, o;
  try {
    e = new ActiveXObject("htmlfile"), e.open(), e.write("<" + n + ">document.w=window</" + n + '><iframe src="/favicon.ico"></iframe>'), e.close(), t = e.w.frames[0].document, o = t.createElement("div");
  } catch {
    o = doc$1.createElement("div"), t = doc$1.body;
  }
  return function(R) {
    var N = [].slice.call(arguments, 0);
    N.unshift(o), t.appendChild(o), o.addBehavior("#default#userData"), o.load(storageName), R.apply(this, N), t.removeChild(o);
  };
}
var util$1 = util$6, Global$1 = util$1.Global, trim = util$1.trim, cookieStorage = {
  name: "cookieStorage",
  read: read$2,
  write: write$2,
  each: each$2,
  remove: remove$2,
  clearAll: clearAll$2
}, doc = Global$1.document;
function read$2(n) {
  if (!n || !_has(n))
    return null;
  var t = "(?:^|.*;\\s*)" + escape(n).replace(/[\-\.\+\*]/g, "\\$&") + "\\s*\\=\\s*((?:[^;](?!;))*[^;]?).*";
  return unescape(doc.cookie.replace(new RegExp(t), "$1"));
}
function each$2(n) {
  for (var t = doc.cookie.split(/; ?/g), e = t.length - 1; e >= 0; e--)
    if (!!trim(t[e])) {
      var o = t[e].split("="), R = unescape(o[0]), N = unescape(o[1]);
      n(N, R);
    }
}
function write$2(n, t) {
  !n || (doc.cookie = escape(n) + "=" + escape(t) + "; expires=Tue, 19 Jan 2038 03:14:07 GMT; path=/");
}
function remove$2(n) {
  !n || !_has(n) || (doc.cookie = escape(n) + "=; expires=Thu, 01 Jan 1970 00:00:00 GMT; path=/");
}
function clearAll$2() {
  each$2(function(n, t) {
    remove$2(t);
  });
}
function _has(n) {
  return new RegExp("(?:^|;\\s*)" + escape(n).replace(/[\-\.\+\*]/g, "\\$&") + "\\s*\\=").test(doc.cookie);
}
var util = util$6, Global = util.Global, sessionStorage_1 = {
  name: "sessionStorage",
  read: read$1,
  write: write$1,
  each: each$1,
  remove: remove$1,
  clearAll: clearAll$1
};
function sessionStorage$1() {
  return Global.sessionStorage;
}
function read$1(n) {
  return sessionStorage$1().getItem(n);
}
function write$1(n, t) {
  return sessionStorage$1().setItem(n, t);
}
function each$1(n) {
  for (var t = sessionStorage$1().length - 1; t >= 0; t--) {
    var e = sessionStorage$1().key(t);
    n(read$1(e), e);
  }
}
function remove$1(n) {
  return sessionStorage$1().removeItem(n);
}
function clearAll$1() {
  return sessionStorage$1().clear();
}
var memoryStorage_1 = {
  name: "memoryStorage",
  read,
  write,
  each,
  remove,
  clearAll
}, memoryStorage = {};
function read(n) {
  return memoryStorage[n];
}
function write(n, t) {
  memoryStorage[n] = t;
}
function each(n) {
  for (var t in memoryStorage)
    memoryStorage.hasOwnProperty(t) && n(memoryStorage[t], t);
}
function remove(n) {
  delete memoryStorage[n];
}
function clearAll(n) {
  memoryStorage = {};
}
var all = [
  localStorage_1,
  oldFFGlobalStorage,
  oldIEUserDataStorage,
  cookieStorage,
  sessionStorage_1,
  memoryStorage_1
], json2$1 = {}, hasRequiredJson2;
function requireJson2() {
  return hasRequiredJson2 || (hasRequiredJson2 = 1, typeof JSON != "object" && (JSON = {}), function() {
    var rx_one = /^[\],:{}\s]*$/, rx_two = /\\(?:["\\\/bfnrt]|u[0-9a-fA-F]{4})/g, rx_three = /"[^"\\\n\r]*"|true|false|null|-?\d+(?:\.\d*)?(?:[eE][+\-]?\d+)?/g, rx_four = /(?:^|:|,)(?:\s*\[)+/g, rx_escapable = /[\\"\u0000-\u001f\u007f-\u009f\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g, rx_dangerous = /[\u0000\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g;
    function f(n) {
      return n < 10 ? "0" + n : n;
    }
    function this_value() {
      return this.valueOf();
    }
    typeof Date.prototype.toJSON != "function" && (Date.prototype.toJSON = function() {
      return isFinite(this.valueOf()) ? this.getUTCFullYear() + "-" + f(this.getUTCMonth() + 1) + "-" + f(this.getUTCDate()) + "T" + f(this.getUTCHours()) + ":" + f(this.getUTCMinutes()) + ":" + f(this.getUTCSeconds()) + "Z" : null;
    }, Boolean.prototype.toJSON = this_value, Number.prototype.toJSON = this_value, String.prototype.toJSON = this_value);
    var gap, indent, meta, rep;
    function quote(n) {
      return rx_escapable.lastIndex = 0, rx_escapable.test(n) ? '"' + n.replace(rx_escapable, function(t) {
        var e = meta[t];
        return typeof e == "string" ? e : "\\u" + ("0000" + t.charCodeAt(0).toString(16)).slice(-4);
      }) + '"' : '"' + n + '"';
    }
    function str(n, t) {
      var e, o, R, N, M = gap, D, L = t[n];
      switch (L && typeof L == "object" && typeof L.toJSON == "function" && (L = L.toJSON(n)), typeof rep == "function" && (L = rep.call(t, n, L)), typeof L) {
        case "string":
          return quote(L);
        case "number":
          return isFinite(L) ? String(L) : "null";
        case "boolean":
        case "null":
          return String(L);
        case "object":
          if (!L)
            return "null";
          if (gap += indent, D = [], Object.prototype.toString.apply(L) === "[object Array]") {
            for (N = L.length, e = 0; e < N; e += 1)
              D[e] = str(e, L) || "null";
            return R = D.length === 0 ? "[]" : gap ? `[
` + gap + D.join(`,
` + gap) + `
` + M + "]" : "[" + D.join(",") + "]", gap = M, R;
          }
          if (rep && typeof rep == "object")
            for (N = rep.length, e = 0; e < N; e += 1)
              typeof rep[e] == "string" && (o = rep[e], R = str(o, L), R && D.push(quote(o) + (gap ? ": " : ":") + R));
          else
            for (o in L)
              Object.prototype.hasOwnProperty.call(L, o) && (R = str(o, L), R && D.push(quote(o) + (gap ? ": " : ":") + R));
          return R = D.length === 0 ? "{}" : gap ? `{
` + gap + D.join(`,
` + gap) + `
` + M + "}" : "{" + D.join(",") + "}", gap = M, R;
      }
    }
    typeof JSON.stringify != "function" && (meta = {
      "\b": "\\b",
      "	": "\\t",
      "\n": "\\n",
      "\f": "\\f",
      "\r": "\\r",
      '"': '\\"',
      "\\": "\\\\"
    }, JSON.stringify = function(n, t, e) {
      var o;
      if (gap = "", indent = "", typeof e == "number")
        for (o = 0; o < e; o += 1)
          indent += " ";
      else
        typeof e == "string" && (indent = e);
      if (rep = t, t && typeof t != "function" && (typeof t != "object" || typeof t.length != "number"))
        throw new Error("JSON.stringify");
      return str("", { "": n });
    }), typeof JSON.parse != "function" && (JSON.parse = function(text, reviver) {
      var j;
      function walk(n, t) {
        var e, o, R = n[t];
        if (R && typeof R == "object")
          for (e in R)
            Object.prototype.hasOwnProperty.call(R, e) && (o = walk(R, e), o !== void 0 ? R[e] = o : delete R[e]);
        return reviver.call(n, t, R);
      }
      if (text = String(text), rx_dangerous.lastIndex = 0, rx_dangerous.test(text) && (text = text.replace(rx_dangerous, function(n) {
        return "\\u" + ("0000" + n.charCodeAt(0).toString(16)).slice(-4);
      })), rx_one.test(
        text.replace(rx_two, "@").replace(rx_three, "]").replace(rx_four, "")
      ))
        return j = eval("(" + text + ")"), typeof reviver == "function" ? walk({ "": j }, "") : j;
      throw new SyntaxError("JSON.parse");
    });
  }()), json2$1;
}
var json2 = json2Plugin;
function json2Plugin() {
  return requireJson2(), {};
}
var engine = storeEngine, storages = all, plugins = [json2], store_legacy = engine.createStore(storages, plugins);
/*!
devtools-detect
https://github.com/sindresorhus/devtools-detect
By Sindre Sorhus
MIT License
*/
const devtools = {
  isOpen: !1,
  orientation: void 0
}, threshold = 160, emitEvent = (n, t) => {
  globalThis.dispatchEvent(new globalThis.CustomEvent("devtoolschange", {
    detail: {
      isOpen: n,
      orientation: t
    }
  }));
}, main = ({ emitEvents: n = !0 } = {}) => {
  const t = globalThis.outerWidth - globalThis.innerWidth > threshold, e = globalThis.outerHeight - globalThis.innerHeight > threshold, o = t ? "vertical" : "horizontal";
  !(e && t) && (globalThis.Firebug && globalThis.Firebug.chrome && globalThis.Firebug.chrome.isInitialized || t || e) ? ((!devtools.isOpen || devtools.orientation !== o) && n && emitEvent(!0, o), devtools.isOpen = !0, devtools.orientation = o) : (devtools.isOpen && n && emitEvent(!1, void 0), devtools.isOpen = !1, devtools.orientation = void 0);
};
main({ emitEvents: !1 });
setInterval(main, 500);
var Nn, ua, Hr, la;
class SysWeb extends SysBase {
  constructor(e = {}, o = { cur: "prj/", crypto: !1, dip: "" }) {
    super(e, o);
    it(this, Nn, void 0);
    it(this, ua, void 0);
    it(this, Hr, void 0);
    it(this, la, void 0);
    et(this, Nn, ""), et(this, ua, ":"), this.run = async () => {
      H(this, Hr) && (H(this, Hr).destroy(10), await new Promise((M) => setTimeout(M, 10))), et(this, Hr, new Main(this));
    }, et(this, Hr, void 0), this.pathBaseCnvSnPath4Dbg = "${pathbase}/", this._export = () => ((async () => {
      const N = JSON.stringify({
        sys: this.data.sys,
        mark: this.data.mark,
        kidoku: this.data.kidoku
      }), M = this.crypto ? await this.enc(N) : N, D = new Blob([M], { type: "text/json" }), L = document.createElement("a");
      L.href = URL.createObjectURL(D), L.download = (this.crypto ? "" : "no_crypto_") + this.cfg.getNs() + getDateStr("-", "_", "") + ".swpd", L.click(), CmnLib.debugLog && console.log("\u30D7\u30EC\u30A4\u30C7\u30FC\u30BF\u3092\u30A8\u30AF\u30B9\u30DD\u30FC\u30C8\u3057\u307E\u3057\u305F"), setTimeout(() => this.fire("sn:exported", new Event("click")), 10);
    })(), !1), this._import = () => (new Promise((N, M) => {
      const D = document.createElement("input");
      D.type = "file", D.accept = ".swpd, text/plain", D.onchange = () => {
        D.files ? N(D.files[0].path) : M();
      }, D.click();
    }).then((N) => new Promise((M) => {
      const D = new FileReader();
      D.readAsText(N), D.onload = () => M(D.result);
    })).then(async (N) => {
      const M = JSON.parse(this.crypto ? this.decStr("json", N) : N);
      if (!M.sys || !M.mark || !M.kidoku)
        throw new Error("\u7570\u5E38\u306A\u30D7\u30EC\u30A4\u30C7\u30FC\u30BF\u3067\u3059");
      if (M.sys[SysBase.VALNM_CFG_NS] !== this.cfg.oCfg.save_ns) {
        console.error(`\u5225\u306E\u30B2\u30FC\u30E0\u3010\u30D7\u30ED\u30B8\u30A7\u30AF\u30C8\u540D=${M.sys[SysBase.VALNM_CFG_NS]}\u3011\u306E\u30D7\u30EC\u30A4\u30C7\u30FC\u30BF\u3067\u3059`);
        return;
      }
      this.data.sys = M.sys, this.data.mark = M.mark, this.data.kidoku = M.kidoku, this.flush(), this.val.updateData(M), CmnLib.debugLog && console.log("\u30D7\u30EC\u30A4\u30C7\u30FC\u30BF\u3092\u30A4\u30F3\u30DD\u30FC\u30C8\u3057\u307E\u3057\u305F"), this.fire("sn:imported", new Event("click"));
    }).catch((N) => console.error(`\u7570\u5E38\u306A\u30D7\u30EC\u30A4\u30C7\u30FC\u30BF\u3067\u3059 ${N.message}`)), !1), this.navigate_to = (N) => {
      const { url: M } = N;
      if (!M)
        throw "[navigate_to] url\u306F\u5FC5\u9808\u3067\u3059";
      return globalThis.open(M, "_blank"), !1;
    }, et(this, la, {});
    const R = o.cur.split("/");
    et(this, Nn, R.length > 2 ? R.slice(0, -2).join("/") + "/" : ""), globalThis.onload = async () => this.loaded(e, o);
  }
  async loaded(e, o) {
    await super.loaded(e, o), document.querySelectorAll("[data-prj]").forEach((D) => {
      const L = D.attributes.getNamedItem("data-prj");
      L && D.addEventListener("click", () => this.runSN(L.value), { passive: !0 });
    }), document.querySelectorAll("[data-reload]").forEach(
      (D) => D.addEventListener("click", () => this.run(), { passive: !0 })
    ), o.dip && (CmnLib.hDip = JSON.parse(o.dip));
    const R = new URLSearchParams(location.search), N = R.get("dip");
    if (N && (CmnLib.hDip = { ...CmnLib.hDip, ...JSON.parse(N.replaceAll("%2C", ",")) }), !argChk_Boolean(CmnLib.hDip, "oninit_run", !0))
      return;
    argChk_Boolean(CmnLib.hDip, "dbg", !1) && (CmnLib.isDbg = !0, this.fetch = (D) => fetch(D, { mode: "cors" })), this.extPort = argChk_Num(CmnLib.hDip, "port", this.extPort);
    const M = R.get("cur");
    M && (o.cur = H(this, Nn) + M + "/"), this.run();
  }
  runSN(e) {
    this.arg.cur = H(this, Nn) + e + "/", H(this, ua) !== this.arg.cur && (et(this, ua, this.arg.cur), this.run());
  }
  stop() {
    !H(this, Hr) || (H(this, Hr).destroy(), et(this, Hr, void 0));
  }
  async loadPath(e, o) {
    await super.loadPath(e, o);
    const R = this.arg.cur + "path.json", N = await fetch(R);
    if (!N.ok)
      throw Error(N.statusText);
    const M = await N.text(), D = JSON.parse(this.decStr(R, M));
    for (const L in D) {
      const B = e[L] = D[L];
      for (const $ in B)
        $ !== ":cnt" && (B[$] = this.arg.cur + B[$]);
    }
  }
  initVal(e, o, R) {
    const N = encodeURIComponent(document.location.hostname);
    o["const.sn.isDebugger"] = N === "localhost" || N === "127.0.0.1";
    const M = this.cfg.getNs();
    this.flush = this.crypto ? async () => {
      store_legacy.set(M + "sys_", this.enc(JSON.stringify(this.data.sys))), store_legacy.set(M + "mark_", this.enc(JSON.stringify(this.data.mark))), store_legacy.set(M + "kidoku_", this.enc(JSON.stringify(this.data.kidoku)));
    } : () => {
      store_legacy.set(M + "sys", this.data.sys), store_legacy.set(M + "mark", this.data.mark), store_legacy.set(M + "kidoku", this.data.kidoku);
    };
    const D = M + (this.arg.crypto ? "sys_" : "sys");
    if (o["const.sn.isFirstBoot"] = store_legacy.get(D) === void 0) {
      this.data.sys = e.sys, this.data.mark = e.mark, this.data.kidoku = e.kidoku, this.flush(), R(this.data);
      return;
    }
    if (!this.crypto) {
      this.data.sys = store_legacy.get(M + "sys"), this.data.mark = store_legacy.get(M + "mark"), this.data.kidoku = store_legacy.get(M + "kidoku"), R(this.data);
      return;
    }
    let L = "";
    try {
      L = "sys", this.data.sys = JSON.parse(this.decStr("json", store_legacy.get(M + "sys_"))), L += Number(this.val.getVal("sys:TextLayer.Back.Alpha", 1)), L = "mark", this.data.mark = JSON.parse(this.decStr("json", store_legacy.get(M + "mark_"))), L = "kidoku", this.data.kidoku = JSON.parse(this.decStr("json", store_legacy.get(M + "kidoku_")));
    } catch (B) {
      console.error(`\u30BB\u30FC\u30D6\u30C7\u30FC\u30BF\uFF08${L}\uFF09\u304C\u58CA\u308C\u3066\u3044\u307E\u3059\u3002\u4E00\u5EA6\u30AF\u30EA\u30A2\u3059\u308B\u5FC5\u8981\u304C\u3042\u308A\u307E\u3059 %o`, B);
    }
    R(this.data);
  }
  init(e, o, R, N) {
    super.init(e, o, R, N);
    const M = o.view.parentElement;
    if ("requestFullscreen" in document.body)
      this.tglFlscr_sub = () => this.isFullScr ? document.exitFullscreen() : M.requestFullscreen(), document.addEventListener("fullscreenchange", () => this.isFullScr = Boolean(document.fullscreenElement));
    else {
      const D = document;
      this.tglFlscr_sub = () => this.isFullScr ? D.webkitCancelFullScreen() : M.webkitRequestFullscreen(), document.addEventListener("fullscreenchange", () => this.isFullScr = Boolean(D.webkitFullscreenElement));
    }
    return this.cfg.oCfg.debug.devtool || window.addEventListener("devtoolschange", (D) => {
      !D.detail.isOpen || (console.error("DevTool\u306F\u7981\u6B62\u3055\u308C\u3066\u3044\u307E\u3059\u3002\u8A31\u53EF\u3059\u308B\u5834\u5408\u306F\u3010\u30D7\u30ED\u30B8\u30A7\u30AF\u30C8\u8A2D\u5B9A\u3011\u306E\u3010devtool\u3011\u3092ON\u306B\u3002"), N.destroy());
    }, { once: !0, passive: !0 }), [];
  }
  cvsResize() {
    if (super.cvsResize(), this.isFullScr) {
      const e = this.appPixi.view.style;
      e.width = e.height = "";
    }
  }
  titleSub(e) {
    document.title = e, document.querySelectorAll("[data-title]").forEach((o) => o.textContent = e);
  }
  async savePic(e, o) {
    const R = document.createElement("a");
    R.href = o, R.download = e, R.click(), CmnLib.debugLog && console.log("\u753B\u50CF\u30D5\u30A1\u30A4\u30EB\u3092\u30C0\u30A6\u30F3\u30ED\u30FC\u30C9\u3057\u307E\u3059");
  }
  async appendFile(e, o, R) {
    var L;
    const N = ((L = H(this, la)[e]) != null ? L : "") + o;
    H(this, la)[e] = N;
    const M = new Blob([N], { type: "text/json" }), D = document.createElement("a");
    D.href = URL.createObjectURL(M), D.download = e, D.click();
  }
}
Nn = new WeakMap(), ua = new WeakMap(), Hr = new WeakMap(), la = new WeakMap();
export {
  CmnLib,
  Layer,
  SysWeb,
  argChk_Boolean,
  argChk_Num
};
//# sourceMappingURL=web.js.map
