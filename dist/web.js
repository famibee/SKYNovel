var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a2, b2) => {
  for (var prop in b2 || (b2 = {}))
    if (__hasOwnProp.call(b2, prop))
      __defNormalProp(a2, prop, b2[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b2)) {
      if (__propIsEnum.call(b2, prop))
        __defNormalProp(a2, prop, b2[prop]);
    }
  return a2;
};
var __spreadProps = (a2, b2) => __defProps(a2, __getOwnPropDescs(b2));
var __accessCheck2 = (obj, member, msg) => {
  if (!member.has(obj))
    throw TypeError("Cannot " + msg);
};
var __privateGet2 = (obj, member, getter) => {
  __accessCheck2(obj, member, "read from private field");
  return getter ? getter.call(obj) : member.get(obj);
};
var __privateAdd2 = (obj, member, value) => {
  if (member.has(obj))
    throw TypeError("Cannot add the same private member more than once");
  member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
};
var __privateSet2 = (obj, member, value, setter) => {
  __accessCheck2(obj, member, "write to private field");
  setter ? setter.call(obj, value) : member.set(obj, value);
  return value;
};
var __privateWrapper2 = (obj, member, setter, getter) => {
  return {
    set _(value) {
      __privateSet2(obj, member, value, setter);
    },
    get _() {
      return __privateGet2(obj, member, getter);
    }
  };
};
var __privateMethod2 = (obj, member, method) => {
  __accessCheck2(obj, member, "access private method");
  return method;
};
var _a2, _b2, _c2, _d, _sesame, _putCh2, _REG_RUBY, _REG_CANTC2M, _REGC2M, _regStrC2M, _regStrC2M4not, _hC2M, _REG_TAGARG, _hPrm, _isKomeParam, _parser, _calc, calc_fn, _hFnc, _fncSub_ChkNum, fncSub_ChkNum_fn, _REG_EMBEDVAR, _procEmbedVar, procEmbedVar_fn, _REG_VAL, _getValName_B2D, getValName_B2D_fn, _hScopes, _hSave, _hTmp, _sys2, _data, _hSys, _hAreaKidoku, _callHook, _hProcDbgRes, _set_data_break, set_data_break_fn, _flush, _doRecProc, _copybookmark, copybookmark_fn, _erasebookmark, erasebookmark_fn, _let, let_fn, _let_abs, let_abs_fn, _let_char_at, let_char_at_fn, _let_index_of, let_index_of_fn, _let_length, let_length_fn, _let_replace, let_replace_fn, _let_round, let_round_fn, _let_search, let_search_fn, _let_substr, let_substr_fn, _clearsysvar, clearsysvar_fn, _clearvar, clearvar_fn, _setVal, _hSetEvent, _castAuto, castAuto_fn, _REG_NUMERICLITERAL, _dump_val, _doRecLog, _hValTrg, _runFirst_Bool_hSysVal_true, runFirst_Bool_hSysVal_true_fn, _runFirst_sys_an_tagCh_msecWait, runFirst_sys_an_tagCh_msecWait_fn, _runFirst_sys_an_tagCh_msecWait_Kidoku, runFirst_sys_an_tagCh_msecWait_Kidoku_fn, _runFirst_sys_an_auto_msecPageWait, runFirst_sys_an_auto_msecPageWait_fn, _runFirst_sys_an_auto_msecLineWait, runFirst_sys_an_auto_msecLineWait_fn, _runFirst_Bool_hSaveVal_true, runFirst_Bool_hSaveVal_true_fn, _runFirst_Bool_hTmp_true, runFirst_Bool_hTmp_true_fn, _runFirst_Bool_hTmp_false, runFirst_Bool_hTmp_false_fn, _hEase, _hSndBuf, _hLP, _evtMng2, _volume, volume_fn, _getVol, getVol_fn, _fadeoutbgm, fadeoutbgm_fn, _fadeoutse, fadeoutse_fn, _fadebgm, fadebgm_fn, _fadese, fadese_fn, _playbgm, playbgm_fn, _MAX_END_MS, _playse, playse_fn, _playseSub, playseSub_fn, _initVol, _stop_allse, stop_allse_fn, _stopbgm, stopbgm_fn, _stopse, stopse_fn, _wb, wb_fn, _wf, wf_fn, _stopfadese, stopfadese_fn, _wl, wl_fn, _ws, ws_fn, _xchgbuf, xchgbuf_fn, _addLoopPlay, addLoopPlay_fn, _delLoopPlay, delLoopPlay_fn, _pg, _hBlendmode, _vctEvt, _sp, _procHint, procHint_fn, _sp2, _cfg2, _appPixi2, _evtMng3, _htmTxt, _cntTxt, _grpDbgMasume, _idc2, _idcCh, _infTL, _break_fixed, _break_fixed_left, _break_fixed_top, _lay_sub, lay_sub_fn, _left, _isTategaki, _padTx4x, _padTx4y, _hWarning, _htm2tx, htm2tx_fn, _ch_filter, _aSpTw, _aRect, _lenHtmTxt, _reg\u884C\u982D\u7981\u5247, _reg\u884C\u672B\u7981\u5247, _reg\u5206\u5272\u7981\u6B62, _beforeHTMLElm, _REGDS, _fncEndChIn, _spWork, spWork_fn, _isChInIng, _hChInStyle, _REG_NG_CHSTYLE_NAME_CHR, _hChOutStyle, _cntBreak, _lh_half, _getChRects, getChRects_fn, _fi_easing, _fo_easing, _clearText, clearText_fn, _sss, _evtMng4, _hIfrm, _add_frame, add_frame_fn, _hDisabled, _rect, rect_fn, _let_frame, let_frame_fn, _set_frame, set_frame_fn, _zIdx, _frame, frame_fn, _tsy_frame, tsy_frame_fn, _stage, _fore, _back, _frmMng, _fncTicker, _hProcDbgRes2, _modeLn, _modeLnSub, _selectNode, selectNode_fn, _grpCover, _evtMng5, _foreachRedrawTxtLayBack, foreachRedrawTxtLayBack_fn, _cmdTxt, _snapshot, snapshot_fn, _loadplugin, loadplugin_fn, _add_lay, add_lay_fn, _hPages, _aLayName, _curTxtlay, _firstGrplay, _lay, lay_fn, _rebuildLayerRankInfo, rebuildLayerRankInfo_fn, _clear_lay, clear_lay_fn, _srcRuleTransFragment, _ufRuleTrans, _fltRule, _rtTransBack, _spTransBack, _rtTransFore, _spTransFore, _aBackTransAfter, _trans, trans_fn, _tiTrans, _getLayers, getLayers_fn, _foreachLayers, foreachLayers_fn, _sortLayers, sortLayers_fn, _wt, wt_fn, _finish_trans, finish_trans_fn, _quake, quake_fn, _hTwInf, _tsy, tsy_fn, _wait_tsy, wait_tsy_fn, _stop_tsy, stop_tsy_fn, _pause_tsy, pause_tsy_fn, _resume_tsy, resume_tsy_fn, _msecChWait, _ch, ch_fn, _getTxtLayer, _$getTxtLayer, $getTxtLayer_fn, _current, _$current, $current_fn, _pgTxtlay, _chkTxtLay, _argChk_layer, argChk_layer_fn, _oLastPage, _aTxtLog, _clear_text, clear_text_fn, _endlink, endlink_fn, _er, er_fn, _graph, graph_fn, _link, link_fn, _r, r_fn, _rec_r, rec_r_fn, _rec_ch, rec_ch_fn, _reset_rec, reset_rec_fn, _ruby2, ruby2_fn, _span, span_fn, _tcy, tcy_fn, _dump_lay, dump_lay_fn, _enable_event, enable_event_fn, _button, button_fn, _aBtn, _idx, _radio_next, radio_next_fn, _logFocus, _allOff, allOff_fn, _elc2, _cvsHint, _picHint_w, _picHint_h, _padHint, _grpHint, _gamepad, _fcs, _resvFlameEvent4Wheel, _ev_keydown, ev_keydown_fn, _ev_contextmenu, ev_contextmenu_fn, _ev_wheel, ev_wheel_fn, _wheeling, _extend_wheel, _ev_wheel_waitstop, ev_wheel_waitstop_fn, _hLocalEvt2Fnc, _hGlobalEvt2Fnc, _isDbgBreak, _isWait, _getEvt2Fnc, _waitEventBase, waitEventBase_fn, _firstWait, _dispHint, dispHint_fn, _dispHint_hArg, _dispHint_ctnBtn, _dispHint_masume, _procWheel4wle, _elcWLE, _clear_event, clear_event_fn, _clear_eventer, clear_eventer_fn, _event, event_fn, _canFocus, canFocus_fn, _getHtmlElmList, getHtmlElmList_fn, _goTxt, _l, l_fn, _p, p_fn, _stopSkip, _set_cancel_skip, set_cancel_skip_fn, _set_focus, set_focus_fn, _wait, wait_fn, _cancelWait, _waitclick, waitclick_fn, _hDownKeys, _script, _scriptFn, _idxToken, _lineNum, _aCallStk, _grm, _regBreakPoint, regBreakPoint_fn, _hHook2, _cnvSnPath, _REG4CODE_FN, _cnvSnPath4Dbg, _go_stepover, go_stepover_fn, _go_stepout, go_stepout_fn, _csDepth_macro_esc, _idxDx4Dbg, idxDx4Dbg_get, _isIdxOverLast, isIdxOverLast_fn, _hFn2hLineBP, _hFuncBP, _breakState, _isBreak_base, isBreak_base_fn, _subHitCondition, subHitCondition_fn, _aStack, aStack_fn, _procDebugtag, _evtMng6, _layMng, _let_ml, let_ml_fn, _dump_stack, dump_stack_fn, _cnvIdx2lineCol, cnvIdx2lineCol_fn, _dump_script, dump_script_fn, _fncSet, _fncBreak, _fnLastBreak, _hScrCache4Dump, _dumpErrLine, _aIfStk, _endif, endif_fn, _if, if_fn, _call, call_fn, _callSub, callSub_fn, _jump, jump_fn, _page, page_fn, _pop_stack, pop_stack_fn, _return, return_fn, _resvToken, _clearResvToken, clearResvToken_fn, _skipLabel, _jumpWork, jumpWork_fn, _nextToken_Proc, nextToken_Proc_fn, _dbgToken, _errOverScr, errOverScr_fn, _REG_NONAME_LABEL, _REG_TOKEN_MACRO_BEGIN, _REG_TOKEN_MACRO_END, _REG_TAG_LET_ML, _REG_TAG_ENDLET_ML, _seekScript, seekScript_fn, _hScript, _resolveScript, resolveScript_fn, _jump_light, jump_light_fn, _REG_WILDCARD, _REG_WILDCARD2, _replaceScript_Wildcard, _recordKidoku, recordKidoku_fn, _isKidoku, _eraseKidoku, eraseKidoku_fn, _bracket2macro, bracket2macro_fn, _char2macro, char2macro_fn, _macro, macro_fn, _strStepin, _REGSTEPIN, _load, load_fn, _loadFromMark, loadFromMark_fn, _skip4page, _reload_script, reload_script_fn, _mark, _record_place, record_place_fn, _nowScrIdx, nowScrIdx_fn, _save, save_fn, _aPageLog, _posAPageLog, _cfg3, _appPixi3, _hTag2, _val2, _prpPrs, _sndMng, _scrItr2, _dbgMng, _layMng2, _evtMng7, _fncNext, _alzTagArg2, _inited, _SN_ID, _init, init_fn, _fncTicker2, _fncresume, _isLoop, _runAnalyze, runAnalyze_fn, _destroyed, _clone_cvs, _path_base, _now_prj, _main2, _hAppendFile;
var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
var platform$1 = { exports: {} };
/*!
 * Platform.js v1.3.6
 * Copyright 2014-2020 Benjamin Tan
 * Copyright 2011-2013 John-David Dalton
 * Available under MIT license
 */
(function(module, exports) {
  (function() {
    var objectTypes = {
      "function": true,
      "object": true
    };
    var root = objectTypes[typeof window] && window || this;
    var freeExports = exports;
    var freeModule = module && !module.nodeType && module;
    var freeGlobal = freeExports && freeModule && typeof commonjsGlobal == "object" && commonjsGlobal;
    if (freeGlobal && (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal || freeGlobal.self === freeGlobal)) {
      root = freeGlobal;
    }
    var maxSafeInteger = Math.pow(2, 53) - 1;
    var reOpera = /\bOpera/;
    var objectProto = Object.prototype;
    var hasOwnProperty2 = objectProto.hasOwnProperty;
    var toString2 = objectProto.toString;
    function capitalize(string) {
      string = String(string);
      return string.charAt(0).toUpperCase() + string.slice(1);
    }
    function cleanupOS(os, pattern, label) {
      var data = {
        "10.0": "10",
        "6.4": "10 Technical Preview",
        "6.3": "8.1",
        "6.2": "8",
        "6.1": "Server 2008 R2 / 7",
        "6.0": "Server 2008 / Vista",
        "5.2": "Server 2003 / XP 64-bit",
        "5.1": "XP",
        "5.01": "2000 SP1",
        "5.0": "2000",
        "4.0": "NT",
        "4.90": "ME"
      };
      if (pattern && label && /^Win/i.test(os) && !/^Windows Phone /i.test(os) && (data = data[/[\d.]+$/.exec(os)])) {
        os = "Windows " + data;
      }
      os = String(os);
      if (pattern && label) {
        os = os.replace(RegExp(pattern, "i"), label);
      }
      os = format2(os.replace(/ ce$/i, " CE").replace(/\bhpw/i, "web").replace(/\bMacintosh\b/, "Mac OS").replace(/_PowerPC\b/i, " OS").replace(/\b(OS X) [^ \d]+/i, "$1").replace(/\bMac (OS X)\b/, "$1").replace(/\/(\d)/, " $1").replace(/_/g, ".").replace(/(?: BePC|[ .]*fc[ \d.]+)$/i, "").replace(/\bx86\.64\b/gi, "x86_64").replace(/\b(Windows Phone) OS\b/, "$1").replace(/\b(Chrome OS \w+) [\d.]+\b/, "$1").split(" on ")[0]);
      return os;
    }
    function each2(object, callback) {
      var index = -1, length2 = object ? object.length : 0;
      if (typeof length2 == "number" && length2 > -1 && length2 <= maxSafeInteger) {
        while (++index < length2) {
          callback(object[index], index, object);
        }
      } else {
        forOwn(object, callback);
      }
    }
    function format2(string) {
      string = trim2(string);
      return /^(?:webOS|i(?:OS|P))/.test(string) ? string : capitalize(string);
    }
    function forOwn(object, callback) {
      for (var key in object) {
        if (hasOwnProperty2.call(object, key)) {
          callback(object[key], key, object);
        }
      }
    }
    function getClassOf(value) {
      return value == null ? capitalize(value) : toString2.call(value).slice(8, -1);
    }
    function isHostType(object, property) {
      var type = object != null ? typeof object[property] : "number";
      return !/^(?:boolean|number|string|undefined)$/.test(type) && (type == "object" ? !!object[property] : true);
    }
    function qualify(string) {
      return String(string).replace(/([ -])(?!$)/g, "$1?");
    }
    function reduce(array, callback) {
      var accumulator = null;
      each2(array, function(value, index) {
        accumulator = callback(accumulator, value, index, array);
      });
      return accumulator;
    }
    function trim2(string) {
      return String(string).replace(/^ +| +$/g, "");
    }
    function parse2(ua) {
      var context2 = root;
      var isCustomContext = ua && typeof ua == "object" && getClassOf(ua) != "String";
      if (isCustomContext) {
        context2 = ua;
        ua = null;
      }
      var nav = context2.navigator || {};
      var userAgent = nav.userAgent || "";
      ua || (ua = userAgent);
      var likeChrome = isCustomContext ? !!nav.likeChrome : /\bChrome\b/.test(ua) && !/internal|\n/i.test(toString2.toString());
      var objectClass = "Object", airRuntimeClass = isCustomContext ? objectClass : "ScriptBridgingProxyObject", enviroClass = isCustomContext ? objectClass : "Environment", javaClass = isCustomContext && context2.java ? "JavaPackage" : getClassOf(context2.java), phantomClass = isCustomContext ? objectClass : "RuntimeObject";
      var java = /\bJava/.test(javaClass) && context2.java;
      var rhino = java && getClassOf(context2.environment) == enviroClass;
      var alpha = java ? "a" : "\u03B1";
      var beta = java ? "b" : "\u03B2";
      var doc2 = context2.document || {};
      var opera = context2.operamini || context2.opera;
      var operaClass = reOpera.test(operaClass = isCustomContext && opera ? opera["[[Class]]"] : getClassOf(opera)) ? operaClass : opera = null;
      var data;
      var arch = ua;
      var description = [];
      var prerelease = null;
      var useFeatures = ua == userAgent;
      var version2 = useFeatures && opera && typeof opera.version == "function" && opera.version();
      var isSpecialCasedOS;
      var layout = getLayout([
        { "label": "EdgeHTML", "pattern": "Edge" },
        "Trident",
        { "label": "WebKit", "pattern": "AppleWebKit" },
        "iCab",
        "Presto",
        "NetFront",
        "Tasman",
        "KHTML",
        "Gecko"
      ]);
      var name2 = getName([
        "Adobe AIR",
        "Arora",
        "Avant Browser",
        "Breach",
        "Camino",
        "Electron",
        "Epiphany",
        "Fennec",
        "Flock",
        "Galeon",
        "GreenBrowser",
        "iCab",
        "Iceweasel",
        "K-Meleon",
        "Konqueror",
        "Lunascape",
        "Maxthon",
        { "label": "Microsoft Edge", "pattern": "(?:Edge|Edg|EdgA|EdgiOS)" },
        "Midori",
        "Nook Browser",
        "PaleMoon",
        "PhantomJS",
        "Raven",
        "Rekonq",
        "RockMelt",
        { "label": "Samsung Internet", "pattern": "SamsungBrowser" },
        "SeaMonkey",
        { "label": "Silk", "pattern": "(?:Cloud9|Silk-Accelerated)" },
        "Sleipnir",
        "SlimBrowser",
        { "label": "SRWare Iron", "pattern": "Iron" },
        "Sunrise",
        "Swiftfox",
        "Vivaldi",
        "Waterfox",
        "WebPositive",
        { "label": "Yandex Browser", "pattern": "YaBrowser" },
        { "label": "UC Browser", "pattern": "UCBrowser" },
        "Opera Mini",
        { "label": "Opera Mini", "pattern": "OPiOS" },
        "Opera",
        { "label": "Opera", "pattern": "OPR" },
        "Chromium",
        "Chrome",
        { "label": "Chrome", "pattern": "(?:HeadlessChrome)" },
        { "label": "Chrome Mobile", "pattern": "(?:CriOS|CrMo)" },
        { "label": "Firefox", "pattern": "(?:Firefox|Minefield)" },
        { "label": "Firefox for iOS", "pattern": "FxiOS" },
        { "label": "IE", "pattern": "IEMobile" },
        { "label": "IE", "pattern": "MSIE" },
        "Safari"
      ]);
      var product = getProduct([
        { "label": "BlackBerry", "pattern": "BB10" },
        "BlackBerry",
        { "label": "Galaxy S", "pattern": "GT-I9000" },
        { "label": "Galaxy S2", "pattern": "GT-I9100" },
        { "label": "Galaxy S3", "pattern": "GT-I9300" },
        { "label": "Galaxy S4", "pattern": "GT-I9500" },
        { "label": "Galaxy S5", "pattern": "SM-G900" },
        { "label": "Galaxy S6", "pattern": "SM-G920" },
        { "label": "Galaxy S6 Edge", "pattern": "SM-G925" },
        { "label": "Galaxy S7", "pattern": "SM-G930" },
        { "label": "Galaxy S7 Edge", "pattern": "SM-G935" },
        "Google TV",
        "Lumia",
        "iPad",
        "iPod",
        "iPhone",
        "Kindle",
        { "label": "Kindle Fire", "pattern": "(?:Cloud9|Silk-Accelerated)" },
        "Nexus",
        "Nook",
        "PlayBook",
        "PlayStation Vita",
        "PlayStation",
        "TouchPad",
        "Transformer",
        { "label": "Wii U", "pattern": "WiiU" },
        "Wii",
        "Xbox One",
        { "label": "Xbox 360", "pattern": "Xbox" },
        "Xoom"
      ]);
      var manufacturer = getManufacturer({
        "Apple": { "iPad": 1, "iPhone": 1, "iPod": 1 },
        "Alcatel": {},
        "Archos": {},
        "Amazon": { "Kindle": 1, "Kindle Fire": 1 },
        "Asus": { "Transformer": 1 },
        "Barnes & Noble": { "Nook": 1 },
        "BlackBerry": { "PlayBook": 1 },
        "Google": { "Google TV": 1, "Nexus": 1 },
        "HP": { "TouchPad": 1 },
        "HTC": {},
        "Huawei": {},
        "Lenovo": {},
        "LG": {},
        "Microsoft": { "Xbox": 1, "Xbox One": 1 },
        "Motorola": { "Xoom": 1 },
        "Nintendo": { "Wii U": 1, "Wii": 1 },
        "Nokia": { "Lumia": 1 },
        "Oppo": {},
        "Samsung": { "Galaxy S": 1, "Galaxy S2": 1, "Galaxy S3": 1, "Galaxy S4": 1 },
        "Sony": { "PlayStation": 1, "PlayStation Vita": 1 },
        "Xiaomi": { "Mi": 1, "Redmi": 1 }
      });
      var os = getOS([
        "Windows Phone",
        "KaiOS",
        "Android",
        "CentOS",
        { "label": "Chrome OS", "pattern": "CrOS" },
        "Debian",
        { "label": "DragonFly BSD", "pattern": "DragonFly" },
        "Fedora",
        "FreeBSD",
        "Gentoo",
        "Haiku",
        "Kubuntu",
        "Linux Mint",
        "OpenBSD",
        "Red Hat",
        "SuSE",
        "Ubuntu",
        "Xubuntu",
        "Cygwin",
        "Symbian OS",
        "hpwOS",
        "webOS ",
        "webOS",
        "Tablet OS",
        "Tizen",
        "Linux",
        "Mac OS X",
        "Macintosh",
        "Mac",
        "Windows 98;",
        "Windows "
      ]);
      function getLayout(guesses) {
        return reduce(guesses, function(result, guess) {
          return result || RegExp("\\b" + (guess.pattern || qualify(guess)) + "\\b", "i").exec(ua) && (guess.label || guess);
        });
      }
      function getManufacturer(guesses) {
        return reduce(guesses, function(result, value, key) {
          return result || (value[product] || value[/^[a-z]+(?: +[a-z]+\b)*/i.exec(product)] || RegExp("\\b" + qualify(key) + "(?:\\b|\\w*\\d)", "i").exec(ua)) && key;
        });
      }
      function getName(guesses) {
        return reduce(guesses, function(result, guess) {
          return result || RegExp("\\b" + (guess.pattern || qualify(guess)) + "\\b", "i").exec(ua) && (guess.label || guess);
        });
      }
      function getOS(guesses) {
        return reduce(guesses, function(result, guess) {
          var pattern = guess.pattern || qualify(guess);
          if (!result && (result = RegExp("\\b" + pattern + "(?:/[\\d.]+|[ \\w.]*)", "i").exec(ua))) {
            result = cleanupOS(result, pattern, guess.label || guess);
          }
          return result;
        });
      }
      function getProduct(guesses) {
        return reduce(guesses, function(result, guess) {
          var pattern = guess.pattern || qualify(guess);
          if (!result && (result = RegExp("\\b" + pattern + " *\\d+[.\\w_]*", "i").exec(ua) || RegExp("\\b" + pattern + " *\\w+-[\\w]*", "i").exec(ua) || RegExp("\\b" + pattern + "(?:; *(?:[a-z]+[_-])?[a-z]+\\d+|[^ ();-]*)", "i").exec(ua))) {
            if ((result = String(guess.label && !RegExp(pattern, "i").test(guess.label) ? guess.label : result).split("/"))[1] && !/[\d.]+/.test(result[0])) {
              result[0] += " " + result[1];
            }
            guess = guess.label || guess;
            result = format2(result[0].replace(RegExp(pattern, "i"), guess).replace(RegExp("; *(?:" + guess + "[_-])?", "i"), " ").replace(RegExp("(" + guess + ")[-_.]?(\\w)", "i"), "$1 $2"));
          }
          return result;
        });
      }
      function getVersion(patterns) {
        return reduce(patterns, function(result, pattern) {
          return result || (RegExp(pattern + "(?:-[\\d.]+/|(?: for [\\w-]+)?[ /-])([\\d.]+[^ ();/_-]*)", "i").exec(ua) || 0)[1] || null;
        });
      }
      function toStringPlatform() {
        return this.description || "";
      }
      layout && (layout = [layout]);
      if (/\bAndroid\b/.test(os) && !product && (data = /\bAndroid[^;]*;(.*?)(?:Build|\) AppleWebKit)\b/i.exec(ua))) {
        product = trim2(data[1]).replace(/^[a-z]{2}-[a-z]{2};\s*/i, "") || null;
      }
      if (manufacturer && !product) {
        product = getProduct([manufacturer]);
      } else if (manufacturer && product) {
        product = product.replace(RegExp("^(" + qualify(manufacturer) + ")[-_.\\s]", "i"), manufacturer + " ").replace(RegExp("^(" + qualify(manufacturer) + ")[-_.]?(\\w)", "i"), manufacturer + " $2");
      }
      if (data = /\bGoogle TV\b/.exec(product)) {
        product = data[0];
      }
      if (/\bSimulator\b/i.test(ua)) {
        product = (product ? product + " " : "") + "Simulator";
      }
      if (name2 == "Opera Mini" && /\bOPiOS\b/.test(ua)) {
        description.push("running in Turbo/Uncompressed mode");
      }
      if (name2 == "IE" && /\blike iPhone OS\b/.test(ua)) {
        data = parse2(ua.replace(/like iPhone OS/, ""));
        manufacturer = data.manufacturer;
        product = data.product;
      } else if (/^iP/.test(product)) {
        name2 || (name2 = "Safari");
        os = "iOS" + ((data = / OS ([\d_]+)/i.exec(ua)) ? " " + data[1].replace(/_/g, ".") : "");
      } else if (name2 == "Konqueror" && /^Linux\b/i.test(os)) {
        os = "Kubuntu";
      } else if (manufacturer && manufacturer != "Google" && (/Chrome/.test(name2) && !/\bMobile Safari\b/i.test(ua) || /\bVita\b/.test(product)) || /\bAndroid\b/.test(os) && /^Chrome/.test(name2) && /\bVersion\//i.test(ua)) {
        name2 = "Android Browser";
        os = /\bAndroid\b/.test(os) ? os : "Android";
      } else if (name2 == "Silk") {
        if (!/\bMobi/i.test(ua)) {
          os = "Android";
          description.unshift("desktop mode");
        }
        if (/Accelerated *= *true/i.test(ua)) {
          description.unshift("accelerated");
        }
      } else if (name2 == "UC Browser" && /\bUCWEB\b/.test(ua)) {
        description.push("speed mode");
      } else if (name2 == "PaleMoon" && (data = /\bFirefox\/([\d.]+)\b/.exec(ua))) {
        description.push("identifying as Firefox " + data[1]);
      } else if (name2 == "Firefox" && (data = /\b(Mobile|Tablet|TV)\b/i.exec(ua))) {
        os || (os = "Firefox OS");
        product || (product = data[1]);
      } else if (!name2 || (data = !/\bMinefield\b/i.test(ua) && /\b(?:Firefox|Safari)\b/.exec(name2))) {
        if (name2 && !product && /[\/,]|^[^(]+?\)/.test(ua.slice(ua.indexOf(data + "/") + 8))) {
          name2 = null;
        }
        if ((data = product || manufacturer || os) && (product || manufacturer || /\b(?:Android|Symbian OS|Tablet OS|webOS)\b/.test(os))) {
          name2 = /[a-z]+(?: Hat)?/i.exec(/\bAndroid\b/.test(os) ? os : data) + " Browser";
        }
      } else if (name2 == "Electron" && (data = (/\bChrome\/([\d.]+)\b/.exec(ua) || 0)[1])) {
        description.push("Chromium " + data);
      }
      if (!version2) {
        version2 = getVersion([
          "(?:Cloud9|CriOS|CrMo|Edge|Edg|EdgA|EdgiOS|FxiOS|HeadlessChrome|IEMobile|Iron|Opera ?Mini|OPiOS|OPR|Raven|SamsungBrowser|Silk(?!/[\\d.]+$)|UCBrowser|YaBrowser)",
          "Version",
          qualify(name2),
          "(?:Firefox|Minefield|NetFront)"
        ]);
      }
      if (data = layout == "iCab" && parseFloat(version2) > 3 && "WebKit" || /\bOpera\b/.test(name2) && (/\bOPR\b/.test(ua) ? "Blink" : "Presto") || /\b(?:Midori|Nook|Safari)\b/i.test(ua) && !/^(?:Trident|EdgeHTML)$/.test(layout) && "WebKit" || !layout && /\bMSIE\b/i.test(ua) && (os == "Mac OS" ? "Tasman" : "Trident") || layout == "WebKit" && /\bPlayStation\b(?! Vita\b)/i.test(name2) && "NetFront") {
        layout = [data];
      }
      if (name2 == "IE" && (data = (/; *(?:XBLWP|ZuneWP)(\d+)/i.exec(ua) || 0)[1])) {
        name2 += " Mobile";
        os = "Windows Phone " + (/\+$/.test(data) ? data : data + ".x");
        description.unshift("desktop mode");
      } else if (/\bWPDesktop\b/i.test(ua)) {
        name2 = "IE Mobile";
        os = "Windows Phone 8.x";
        description.unshift("desktop mode");
        version2 || (version2 = (/\brv:([\d.]+)/.exec(ua) || 0)[1]);
      } else if (name2 != "IE" && layout == "Trident" && (data = /\brv:([\d.]+)/.exec(ua))) {
        if (name2) {
          description.push("identifying as " + name2 + (version2 ? " " + version2 : ""));
        }
        name2 = "IE";
        version2 = data[1];
      }
      if (useFeatures) {
        if (isHostType(context2, "global")) {
          if (java) {
            data = java.lang.System;
            arch = data.getProperty("os.arch");
            os = os || data.getProperty("os.name") + " " + data.getProperty("os.version");
          }
          if (rhino) {
            try {
              version2 = context2.require("ringo/engine").version.join(".");
              name2 = "RingoJS";
            } catch (e) {
              if ((data = context2.system) && data.global.system == context2.system) {
                name2 = "Narwhal";
                os || (os = data[0].os || null);
              }
            }
            if (!name2) {
              name2 = "Rhino";
            }
          } else if (typeof context2.process == "object" && !context2.process.browser && (data = context2.process)) {
            if (typeof data.versions == "object") {
              if (typeof data.versions.electron == "string") {
                description.push("Node " + data.versions.node);
                name2 = "Electron";
                version2 = data.versions.electron;
              } else if (typeof data.versions.nw == "string") {
                description.push("Chromium " + version2, "Node " + data.versions.node);
                name2 = "NW.js";
                version2 = data.versions.nw;
              }
            }
            if (!name2) {
              name2 = "Node.js";
              arch = data.arch;
              os = data.platform;
              version2 = /[\d.]+/.exec(data.version);
              version2 = version2 ? version2[0] : null;
            }
          }
        } else if (getClassOf(data = context2.runtime) == airRuntimeClass) {
          name2 = "Adobe AIR";
          os = data.flash.system.Capabilities.os;
        } else if (getClassOf(data = context2.phantom) == phantomClass) {
          name2 = "PhantomJS";
          version2 = (data = data.version || null) && data.major + "." + data.minor + "." + data.patch;
        } else if (typeof doc2.documentMode == "number" && (data = /\bTrident\/(\d+)/i.exec(ua))) {
          version2 = [version2, doc2.documentMode];
          if ((data = +data[1] + 4) != version2[1]) {
            description.push("IE " + version2[1] + " mode");
            layout && (layout[1] = "");
            version2[1] = data;
          }
          version2 = name2 == "IE" ? String(version2[1].toFixed(1)) : version2[0];
        } else if (typeof doc2.documentMode == "number" && /^(?:Chrome|Firefox)\b/.test(name2)) {
          description.push("masking as " + name2 + " " + version2);
          name2 = "IE";
          version2 = "11.0";
          layout = ["Trident"];
          os = "Windows";
        }
        os = os && format2(os);
      }
      if (version2 && (data = /(?:[ab]|dp|pre|[ab]\d+pre)(?:\d+\+?)?$/i.exec(version2) || /(?:alpha|beta)(?: ?\d)?/i.exec(ua + ";" + (useFeatures && nav.appMinorVersion)) || /\bMinefield\b/i.test(ua) && "a")) {
        prerelease = /b/i.test(data) ? "beta" : "alpha";
        version2 = version2.replace(RegExp(data + "\\+?$"), "") + (prerelease == "beta" ? beta : alpha) + (/\d+\+?/.exec(data) || "");
      }
      if (name2 == "Fennec" || name2 == "Firefox" && /\b(?:Android|Firefox OS|KaiOS)\b/.test(os)) {
        name2 = "Firefox Mobile";
      } else if (name2 == "Maxthon" && version2) {
        version2 = version2.replace(/\.[\d.]+/, ".x");
      } else if (/\bXbox\b/i.test(product)) {
        if (product == "Xbox 360") {
          os = null;
        }
        if (product == "Xbox 360" && /\bIEMobile\b/.test(ua)) {
          description.unshift("mobile mode");
        }
      } else if ((/^(?:Chrome|IE|Opera)$/.test(name2) || name2 && !product && !/Browser|Mobi/.test(name2)) && (os == "Windows CE" || /Mobi/i.test(ua))) {
        name2 += " Mobile";
      } else if (name2 == "IE" && useFeatures) {
        try {
          if (context2.external === null) {
            description.unshift("platform preview");
          }
        } catch (e) {
          description.unshift("embedded");
        }
      } else if ((/\bBlackBerry\b/.test(product) || /\bBB10\b/.test(ua)) && (data = (RegExp(product.replace(/ +/g, " *") + "/([.\\d]+)", "i").exec(ua) || 0)[1] || version2)) {
        data = [data, /BB10/.test(ua)];
        os = (data[1] ? (product = null, manufacturer = "BlackBerry") : "Device Software") + " " + data[0];
        version2 = null;
      } else if (this != forOwn && product != "Wii" && (useFeatures && opera || /Opera/.test(name2) && /\b(?:MSIE|Firefox)\b/i.test(ua) || name2 == "Firefox" && /\bOS X (?:\d+\.){2,}/.test(os) || name2 == "IE" && (os && !/^Win/.test(os) && version2 > 5.5 || /\bWindows XP\b/.test(os) && version2 > 8 || version2 == 8 && !/\bTrident\b/.test(ua))) && !reOpera.test(data = parse2.call(forOwn, ua.replace(reOpera, "") + ";")) && data.name) {
        data = "ing as " + data.name + ((data = data.version) ? " " + data : "");
        if (reOpera.test(name2)) {
          if (/\bIE\b/.test(data) && os == "Mac OS") {
            os = null;
          }
          data = "identify" + data;
        } else {
          data = "mask" + data;
          if (operaClass) {
            name2 = format2(operaClass.replace(/([a-z])([A-Z])/g, "$1 $2"));
          } else {
            name2 = "Opera";
          }
          if (/\bIE\b/.test(data)) {
            os = null;
          }
          if (!useFeatures) {
            version2 = null;
          }
        }
        layout = ["Presto"];
        description.push(data);
      }
      if (data = (/\bAppleWebKit\/([\d.]+\+?)/i.exec(ua) || 0)[1]) {
        data = [parseFloat(data.replace(/\.(\d)$/, ".0$1")), data];
        if (name2 == "Safari" && data[1].slice(-1) == "+") {
          name2 = "WebKit Nightly";
          prerelease = "alpha";
          version2 = data[1].slice(0, -1);
        } else if (version2 == data[1] || version2 == (data[2] = (/\bSafari\/([\d.]+\+?)/i.exec(ua) || 0)[1])) {
          version2 = null;
        }
        data[1] = (/\b(?:Headless)?Chrome\/([\d.]+)/i.exec(ua) || 0)[1];
        if (data[0] == 537.36 && data[2] == 537.36 && parseFloat(data[1]) >= 28 && layout == "WebKit") {
          layout = ["Blink"];
        }
        if (!useFeatures || !likeChrome && !data[1]) {
          layout && (layout[1] = "like Safari");
          data = (data = data[0], data < 400 ? 1 : data < 500 ? 2 : data < 526 ? 3 : data < 533 ? 4 : data < 534 ? "4+" : data < 535 ? 5 : data < 537 ? 6 : data < 538 ? 7 : data < 601 ? 8 : data < 602 ? 9 : data < 604 ? 10 : data < 606 ? 11 : data < 608 ? 12 : "12");
        } else {
          layout && (layout[1] = "like Chrome");
          data = data[1] || (data = data[0], data < 530 ? 1 : data < 532 ? 2 : data < 532.05 ? 3 : data < 533 ? 4 : data < 534.03 ? 5 : data < 534.07 ? 6 : data < 534.1 ? 7 : data < 534.13 ? 8 : data < 534.16 ? 9 : data < 534.24 ? 10 : data < 534.3 ? 11 : data < 535.01 ? 12 : data < 535.02 ? "13+" : data < 535.07 ? 15 : data < 535.11 ? 16 : data < 535.19 ? 17 : data < 536.05 ? 18 : data < 536.1 ? 19 : data < 537.01 ? 20 : data < 537.11 ? "21+" : data < 537.13 ? 23 : data < 537.18 ? 24 : data < 537.24 ? 25 : data < 537.36 ? 26 : layout != "Blink" ? "27" : "28");
        }
        layout && (layout[1] += " " + (data += typeof data == "number" ? ".x" : /[.+]/.test(data) ? "" : "+"));
        if (name2 == "Safari" && (!version2 || parseInt(version2) > 45)) {
          version2 = data;
        } else if (name2 == "Chrome" && /\bHeadlessChrome/i.test(ua)) {
          description.unshift("headless");
        }
      }
      if (name2 == "Opera" && (data = /\bzbov|zvav$/.exec(os))) {
        name2 += " ";
        description.unshift("desktop mode");
        if (data == "zvav") {
          name2 += "Mini";
          version2 = null;
        } else {
          name2 += "Mobile";
        }
        os = os.replace(RegExp(" *" + data + "$"), "");
      } else if (name2 == "Safari" && /\bChrome\b/.exec(layout && layout[1])) {
        description.unshift("desktop mode");
        name2 = "Chrome Mobile";
        version2 = null;
        if (/\bOS X\b/.test(os)) {
          manufacturer = "Apple";
          os = "iOS 4.3+";
        } else {
          os = null;
        }
      } else if (/\bSRWare Iron\b/.test(name2) && !version2) {
        version2 = getVersion("Chrome");
      }
      if (version2 && version2.indexOf(data = /[\d.]+$/.exec(os)) == 0 && ua.indexOf("/" + data + "-") > -1) {
        os = trim2(os.replace(data, ""));
      }
      if (os && os.indexOf(name2) != -1 && !RegExp(name2 + " OS").test(os)) {
        os = os.replace(RegExp(" *" + qualify(name2) + " *"), "");
      }
      if (layout && !/\b(?:Avant|Nook)\b/.test(name2) && (/Browser|Lunascape|Maxthon/.test(name2) || name2 != "Safari" && /^iOS/.test(os) && /\bSafari\b/.test(layout[1]) || /^(?:Adobe|Arora|Breach|Midori|Opera|Phantom|Rekonq|Rock|Samsung Internet|Sleipnir|SRWare Iron|Vivaldi|Web)/.test(name2) && layout[1])) {
        (data = layout[layout.length - 1]) && description.push(data);
      }
      if (description.length) {
        description = ["(" + description.join("; ") + ")"];
      }
      if (manufacturer && product && product.indexOf(manufacturer) < 0) {
        description.push("on " + manufacturer);
      }
      if (product) {
        description.push((/^on /.test(description[description.length - 1]) ? "" : "on ") + product);
      }
      if (os) {
        data = / ([\d.+]+)$/.exec(os);
        isSpecialCasedOS = data && os.charAt(os.length - data[0].length - 1) == "/";
        os = {
          "architecture": 32,
          "family": data && !isSpecialCasedOS ? os.replace(data[0], "") : os,
          "version": data ? data[1] : null,
          "toString": function() {
            var version3 = this.version;
            return this.family + (version3 && !isSpecialCasedOS ? " " + version3 : "") + (this.architecture == 64 ? " 64-bit" : "");
          }
        };
      }
      if ((data = /\b(?:AMD|IA|Win|WOW|x86_|x)64\b/i.exec(arch)) && !/\bi686\b/i.test(arch)) {
        if (os) {
          os.architecture = 64;
          os.family = os.family.replace(RegExp(" *" + data), "");
        }
        if (name2 && (/\bWOW64\b/i.test(ua) || useFeatures && /\w(?:86|32)$/.test(nav.cpuClass || nav.platform) && !/\bWin64; x64\b/i.test(ua))) {
          description.unshift("32-bit");
        }
      } else if (os && /^OS X/.test(os.family) && name2 == "Chrome" && parseFloat(version2) >= 39) {
        os.architecture = 64;
      }
      ua || (ua = null);
      var platform3 = {};
      platform3.description = ua;
      platform3.layout = layout && layout[0];
      platform3.manufacturer = manufacturer;
      platform3.name = name2;
      platform3.prerelease = prerelease;
      platform3.product = product;
      platform3.ua = ua;
      platform3.version = name2 && version2;
      platform3.os = os || {
        "architecture": null,
        "family": null,
        "version": null,
        "toString": function() {
          return "null";
        }
      };
      platform3.parse = parse2;
      platform3.toString = toStringPlatform;
      if (platform3.version) {
        description.unshift(version2);
      }
      if (platform3.name) {
        description.unshift(name2);
      }
      if (os && name2 && !(os == String(os).split(" ")[0] && (os == name2.split(" ")[0] || product))) {
        description.push(product ? "(" + os + ")" : "on " + os);
      }
      if (description.length) {
        platform3.description = description.join(" ");
      }
      return platform3;
    }
    var platform2 = parse2();
    if (freeExports && freeModule) {
      forOwn(platform2, function(value, key) {
        freeExports[key] = value;
      });
    } else {
      root.platform = platform2;
    }
  }).call(commonjsGlobal);
})(platform$1, platform$1.exports);
var platform = platform$1.exports;
function int(o) {
  return parseInt(String(o), 10);
}
function uint(o) {
  const v2 = parseInt(String(o), 10);
  return v2 < 0 ? -v2 : v2;
}
if (!("toInt" in String.prototype)) {
  String.prototype.toInt = function() {
    return int(this);
  };
}
if (!("toUint" in String.prototype)) {
  String.prototype.toUint = function() {
    const v2 = int(this);
    return v2 < 0 ? -v2 : v2;
  };
}
function getDateStr(spl_dd = "/", spl_dt = " ", spl_tt = ":", spl_ms = "") {
  const now2 = new Date();
  return now2.getFullYear() + spl_dd + String(100 + now2.getMonth() + 1).slice(1, 3) + spl_dd + String(100 + now2.getDate()).slice(1, 3) + spl_dt + String(100 + now2.getHours()).slice(1, 3) + spl_tt + String(100 + now2.getMinutes()).slice(1, 3) + (spl_ms === "" ? "" : spl_ms + String(now2.getMilliseconds()));
}
const hMemberCnt = {
  alpha: 0,
  height: 0,
  rotation: 0,
  scale_x: 0,
  scale_y: 0,
  pivot_x: 0,
  pivot_y: 0,
  width: 0,
  x: 0,
  y: 0
};
function cnvTweenArg(hArg, lay) {
  const hTo = {};
  for (const nm in hMemberCnt) {
    if (!(nm in hArg))
      continue;
    const v2 = String(hArg[nm]);
    const a2 = (v2.charAt(0) === "=" ? v2.slice(1) : v2).split(",");
    const a0 = hTo[nm] = parseFloat(a2[0]);
    if (a2.length > 1)
      hTo[nm] += Math.round(Math.random() * (parseFloat(a2[1]) - a0 + 1));
    if (v2.charAt(0) === "=")
      hTo[nm] += parseFloat(lay[nm]);
  }
  return hTo;
}
const css_key4del = "/* SKYNovel */";
function initStyle() {
  const he = document.getElementsByTagName("head")[0];
  const len = he.children.length;
  for (let i2 = len - 1; i2 >= 0; --i2) {
    const v2 = he.children[i2];
    if (!(v2 instanceof HTMLStyleElement))
      continue;
    if (v2.innerText.slice(0, 14) !== css_key4del)
      continue;
    he.removeChild(v2);
  }
}
function addStyle(style) {
  const gs = document.createElement("style");
  gs.innerHTML = css_key4del + style;
  document.getElementsByTagName("head")[0].appendChild(gs);
}
function argChk_Num(hash2, name2, def) {
  const v2 = hash2[name2];
  if (!(name2 in hash2)) {
    if (isNaN(def))
      throw `[${hash2[":\u30BF\u30B0\u540D"]}]\u5C5E\u6027 ${name2} \u306F\u5FC5\u9808\u3067\u3059`;
    hash2[name2] = def;
    return def;
  }
  const n = String(v2).slice(0, 2) === "0x" ? parseInt(v2) : parseFloat(v2);
  if (isNaN(n))
    throw `[${hash2[":\u30BF\u30B0\u540D"]}]\u5C5E\u6027 ${name2} \u306E\u5024\u3010${v2}\u3011\u304C\u6570\u5024\u3067\u306F\u3042\u308A\u307E\u305B\u3093`;
  return hash2[name2] = n;
}
function argChk_Boolean(hash2, name2, def) {
  if (!(name2 in hash2))
    return hash2[name2] = def;
  const v2 = hash2[name2];
  if (v2 === null)
    return false;
  const v22 = String(v2);
  return hash2[name2] = v22 === "false" ? false : Boolean(v22);
}
function parseColor(v2) {
  console.log(`fn:CmnLib.ts line:152 v:%o`, v2);
  if (v2.charAt(0) === "#")
    return parseInt(v2.slice(1), 16);
  const n = Number(v2);
  if (!isNaN(n))
    return n;
  if (v2 === "black")
    return 0;
  CmnLib.cc4ColorName.fillStyle = v2;
  const cc = CmnLib.cc4ColorName.fillStyle;
  if (cc === "#000000")
    throw `\u8272\u540D\u524D ${v2} \u304C\u7570\u5E38\u3067\u3059`;
  return parseInt(cc.slice(1), 16);
}
function argChk_Color(hash2, name2, def) {
  const v2 = hash2[name2];
  if (!v2)
    return hash2[name2] = def;
  return hash2[name2] = parseColor(String(v2));
}
const REG_FN = /^[^\/\.]+$|[^\/]+(?=\.)/;
function getFn(p2) {
  var _a3;
  return ((_a3 = p2.match(REG_FN)) != null ? _a3 : [""])[0];
}
const REG_EXT = /\.([^\.]+)$/;
function getExt(p2) {
  var _a3;
  return ((_a3 = p2.match(REG_EXT)) != null ? _a3 : [""])[1];
}
class CmnLib {
}
CmnLib.stageW = 0;
CmnLib.stageH = 0;
CmnLib.debugLog = false;
CmnLib.isSafari = platform$1.exports.name === "Safari";
CmnLib.isFirefox = platform$1.exports.name === "Firefox";
CmnLib.isMac = new RegExp("OS X").test((_b2 = (_a2 = platform$1.exports.os) == null ? void 0 : _a2.family) != null ? _b2 : "");
CmnLib.isMobile = !new RegExp("(Windows|OS X)").test((_d = (_c2 = platform$1.exports.os) == null ? void 0 : _c2.family) != null ? _d : "");
CmnLib.hDip = {};
CmnLib.isDbg = false;
CmnLib.isPackaged = false;
CmnLib.isDarkMode = false;
var re = /^(?:(?![^:@]+:[^:@\/]*@)(http|https|ws|wss):\/\/)?((?:(([^:@]*)(?::([^:@]*))?)?@)?((?:[a-f0-9]{0,4}:){2,7}[a-f0-9]{0,4}|[^:\/?#]*)(?::(\d*))?)(((\/(?:[^?#](?![^?#\/]*\.[^?#\/.]+(?:[?#]|$)))*\/?)?([^?#\/]*))(?:\?([^#]*))?(?:#(.*))?)/;
var parts = [
  "source",
  "protocol",
  "authority",
  "userInfo",
  "user",
  "password",
  "host",
  "port",
  "relative",
  "path",
  "directory",
  "file",
  "query",
  "anchor"
];
var parseuri = function parseuri2(str2) {
  var src = str2, b2 = str2.indexOf("["), e = str2.indexOf("]");
  if (b2 != -1 && e != -1) {
    str2 = str2.substring(0, b2) + str2.substring(b2, e).replace(/:/g, ";") + str2.substring(e, str2.length);
  }
  var m2 = re.exec(str2 || ""), uri = {}, i2 = 14;
  while (i2--) {
    uri[parts[i2]] = m2[i2] || "";
  }
  if (b2 != -1 && e != -1) {
    uri.source = src;
    uri.host = uri.host.substring(1, uri.host.length - 1).replace(/;/g, ":");
    uri.authority = uri.authority.replace("[", "").replace("]", "").replace(/;/g, ":");
    uri.ipv6uri = true;
  }
  uri.pathNames = pathNames(uri, uri["path"]);
  uri.queryKey = queryKey(uri, uri["query"]);
  return uri;
};
function pathNames(obj, path) {
  var regx = /\/{2,9}/g, names = path.replace(regx, "/").split("/");
  if (path.substr(0, 1) == "/" || path.length === 0) {
    names.splice(0, 1);
  }
  if (path.substr(path.length - 1, 1) == "/") {
    names.splice(names.length - 1, 1);
  }
  return names;
}
function queryKey(uri, query) {
  var data = {};
  query.replace(/(?:^|&)([^&=]*)=?([^&]*)/g, function($0, $1, $2) {
    if ($1) {
      data[$1] = $2;
    }
  });
  return data;
}
function url$1(uri, path = "", loc) {
  let obj = uri;
  loc = loc || typeof location !== "undefined" && location;
  if (uri == null)
    uri = loc.protocol + "//" + loc.host;
  if (typeof uri === "string") {
    if (uri.charAt(0) === "/") {
      if (uri.charAt(1) === "/") {
        uri = loc.protocol + uri;
      } else {
        uri = loc.host + uri;
      }
    }
    if (!/^(https?|wss?):\/\//.test(uri)) {
      if (typeof loc !== "undefined") {
        uri = loc.protocol + "//" + uri;
      } else {
        uri = "https://" + uri;
      }
    }
    obj = parseuri(uri);
  }
  if (!obj.port) {
    if (/^(http|ws)$/.test(obj.protocol)) {
      obj.port = "80";
    } else if (/^(http|ws)s$/.test(obj.protocol)) {
      obj.port = "443";
    }
  }
  obj.path = obj.path || "/";
  const ipv6 = obj.host.indexOf(":") !== -1;
  const host = ipv6 ? "[" + obj.host + "]" : obj.host;
  obj.id = obj.protocol + "://" + host + ":" + obj.port + path;
  obj.href = obj.protocol + "://" + host + (loc && loc.port === obj.port ? "" : ":" + obj.port);
  return obj;
}
var hasCors = { exports: {} };
try {
  hasCors.exports = typeof XMLHttpRequest !== "undefined" && "withCredentials" in new XMLHttpRequest();
} catch (err) {
  hasCors.exports = false;
}
var hasCORS = hasCors.exports;
var globalThis$1 = (() => {
  if (typeof self !== "undefined") {
    return self;
  } else if (typeof window !== "undefined") {
    return window;
  } else {
    return Function("return this")();
  }
})();
function XMLHttpRequest$1(opts) {
  const xdomain = opts.xdomain;
  try {
    if (typeof XMLHttpRequest !== "undefined" && (!xdomain || hasCORS)) {
      return new XMLHttpRequest();
    }
  } catch (e) {
  }
  if (!xdomain) {
    try {
      return new globalThis$1[["Active"].concat("Object").join("X")]("Microsoft.XMLHTTP");
    } catch (e) {
    }
  }
}
function pick(obj, ...attr) {
  return attr.reduce((acc, k) => {
    if (obj.hasOwnProperty(k)) {
      acc[k] = obj[k];
    }
    return acc;
  }, {});
}
const NATIVE_SET_TIMEOUT = setTimeout;
const NATIVE_CLEAR_TIMEOUT = clearTimeout;
function installTimerFunctions(obj, opts) {
  if (opts.useNativeTimers) {
    obj.setTimeoutFn = NATIVE_SET_TIMEOUT.bind(globalThis$1);
    obj.clearTimeoutFn = NATIVE_CLEAR_TIMEOUT.bind(globalThis$1);
  } else {
    obj.setTimeoutFn = setTimeout.bind(globalThis$1);
    obj.clearTimeoutFn = clearTimeout.bind(globalThis$1);
  }
}
var Emitter_1 = Emitter;
function Emitter(obj) {
  if (obj)
    return mixin(obj);
}
function mixin(obj) {
  for (var key in Emitter.prototype) {
    obj[key] = Emitter.prototype[key];
  }
  return obj;
}
Emitter.prototype.on = Emitter.prototype.addEventListener = function(event, fn) {
  this._callbacks = this._callbacks || {};
  (this._callbacks["$" + event] = this._callbacks["$" + event] || []).push(fn);
  return this;
};
Emitter.prototype.once = function(event, fn) {
  function on2() {
    this.off(event, on2);
    fn.apply(this, arguments);
  }
  on2.fn = fn;
  this.on(event, on2);
  return this;
};
Emitter.prototype.off = Emitter.prototype.removeListener = Emitter.prototype.removeAllListeners = Emitter.prototype.removeEventListener = function(event, fn) {
  this._callbacks = this._callbacks || {};
  if (arguments.length == 0) {
    this._callbacks = {};
    return this;
  }
  var callbacks = this._callbacks["$" + event];
  if (!callbacks)
    return this;
  if (arguments.length == 1) {
    delete this._callbacks["$" + event];
    return this;
  }
  var cb;
  for (var i2 = 0; i2 < callbacks.length; i2++) {
    cb = callbacks[i2];
    if (cb === fn || cb.fn === fn) {
      callbacks.splice(i2, 1);
      break;
    }
  }
  if (callbacks.length === 0) {
    delete this._callbacks["$" + event];
  }
  return this;
};
Emitter.prototype.emit = function(event) {
  this._callbacks = this._callbacks || {};
  var args = new Array(arguments.length - 1), callbacks = this._callbacks["$" + event];
  for (var i2 = 1; i2 < arguments.length; i2++) {
    args[i2 - 1] = arguments[i2];
  }
  if (callbacks) {
    callbacks = callbacks.slice(0);
    for (var i2 = 0, len = callbacks.length; i2 < len; ++i2) {
      callbacks[i2].apply(this, args);
    }
  }
  return this;
};
Emitter.prototype.emitReserved = Emitter.prototype.emit;
Emitter.prototype.listeners = function(event) {
  this._callbacks = this._callbacks || {};
  return this._callbacks["$" + event] || [];
};
Emitter.prototype.hasListeners = function(event) {
  return !!this.listeners(event).length;
};
const PACKET_TYPES = /* @__PURE__ */ Object.create(null);
PACKET_TYPES["open"] = "0";
PACKET_TYPES["close"] = "1";
PACKET_TYPES["ping"] = "2";
PACKET_TYPES["pong"] = "3";
PACKET_TYPES["message"] = "4";
PACKET_TYPES["upgrade"] = "5";
PACKET_TYPES["noop"] = "6";
const PACKET_TYPES_REVERSE = /* @__PURE__ */ Object.create(null);
Object.keys(PACKET_TYPES).forEach((key) => {
  PACKET_TYPES_REVERSE[PACKET_TYPES[key]] = key;
});
const ERROR_PACKET = { type: "error", data: "parser error" };
const withNativeBlob$1 = typeof Blob === "function" || typeof Blob !== "undefined" && Object.prototype.toString.call(Blob) === "[object BlobConstructor]";
const withNativeArrayBuffer$2 = typeof ArrayBuffer === "function";
const isView$1 = (obj) => {
  return typeof ArrayBuffer.isView === "function" ? ArrayBuffer.isView(obj) : obj && obj.buffer instanceof ArrayBuffer;
};
const encodePacket = ({ type, data }, supportsBinary, callback) => {
  if (withNativeBlob$1 && data instanceof Blob) {
    if (supportsBinary) {
      return callback(data);
    } else {
      return encodeBlobAsBase64(data, callback);
    }
  } else if (withNativeArrayBuffer$2 && (data instanceof ArrayBuffer || isView$1(data))) {
    if (supportsBinary) {
      return callback(data);
    } else {
      return encodeBlobAsBase64(new Blob([data]), callback);
    }
  }
  return callback(PACKET_TYPES[type] + (data || ""));
};
const encodeBlobAsBase64 = (data, callback) => {
  const fileReader = new FileReader();
  fileReader.onload = function() {
    const content = fileReader.result.split(",")[1];
    callback("b" + content);
  };
  return fileReader.readAsDataURL(data);
};
var chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
var lookup$1 = typeof Uint8Array === "undefined" ? [] : new Uint8Array(256);
for (var i$1 = 0; i$1 < chars.length; i$1++) {
  lookup$1[chars.charCodeAt(i$1)] = i$1;
}
var decode$2 = function(base64) {
  var bufferLength = base64.length * 0.75, len = base64.length, i2, p2 = 0, encoded1, encoded2, encoded3, encoded4;
  if (base64[base64.length - 1] === "=") {
    bufferLength--;
    if (base64[base64.length - 2] === "=") {
      bufferLength--;
    }
  }
  var arraybuffer = new ArrayBuffer(bufferLength), bytes = new Uint8Array(arraybuffer);
  for (i2 = 0; i2 < len; i2 += 4) {
    encoded1 = lookup$1[base64.charCodeAt(i2)];
    encoded2 = lookup$1[base64.charCodeAt(i2 + 1)];
    encoded3 = lookup$1[base64.charCodeAt(i2 + 2)];
    encoded4 = lookup$1[base64.charCodeAt(i2 + 3)];
    bytes[p2++] = encoded1 << 2 | encoded2 >> 4;
    bytes[p2++] = (encoded2 & 15) << 4 | encoded3 >> 2;
    bytes[p2++] = (encoded3 & 3) << 6 | encoded4 & 63;
  }
  return arraybuffer;
};
const withNativeArrayBuffer$1 = typeof ArrayBuffer === "function";
const decodePacket = (encodedPacket, binaryType) => {
  if (typeof encodedPacket !== "string") {
    return {
      type: "message",
      data: mapBinary(encodedPacket, binaryType)
    };
  }
  const type = encodedPacket.charAt(0);
  if (type === "b") {
    return {
      type: "message",
      data: decodeBase64Packet(encodedPacket.substring(1), binaryType)
    };
  }
  const packetType = PACKET_TYPES_REVERSE[type];
  if (!packetType) {
    return ERROR_PACKET;
  }
  return encodedPacket.length > 1 ? {
    type: PACKET_TYPES_REVERSE[type],
    data: encodedPacket.substring(1)
  } : {
    type: PACKET_TYPES_REVERSE[type]
  };
};
const decodeBase64Packet = (data, binaryType) => {
  if (withNativeArrayBuffer$1) {
    const decoded = decode$2(data);
    return mapBinary(decoded, binaryType);
  } else {
    return { base64: true, data };
  }
};
const mapBinary = (data, binaryType) => {
  switch (binaryType) {
    case "blob":
      return data instanceof ArrayBuffer ? new Blob([data]) : data;
    case "arraybuffer":
    default:
      return data;
  }
};
const SEPARATOR = String.fromCharCode(30);
const encodePayload = (packets, callback) => {
  const length2 = packets.length;
  const encodedPackets = new Array(length2);
  let count = 0;
  packets.forEach((packet, i2) => {
    encodePacket(packet, false, (encodedPacket) => {
      encodedPackets[i2] = encodedPacket;
      if (++count === length2) {
        callback(encodedPackets.join(SEPARATOR));
      }
    });
  });
};
const decodePayload = (encodedPayload, binaryType) => {
  const encodedPackets = encodedPayload.split(SEPARATOR);
  const packets = [];
  for (let i2 = 0; i2 < encodedPackets.length; i2++) {
    const decodedPacket = decodePacket(encodedPackets[i2], binaryType);
    packets.push(decodedPacket);
    if (decodedPacket.type === "error") {
      break;
    }
  }
  return packets;
};
const protocol$1 = 4;
class Transport extends Emitter_1 {
  constructor(opts) {
    super();
    this.writable = false;
    installTimerFunctions(this, opts);
    this.opts = opts;
    this.query = opts.query;
    this.readyState = "";
    this.socket = opts.socket;
  }
  onError(msg, desc) {
    const err = new Error(msg);
    err.type = "TransportError";
    err.description = desc;
    super.emit("error", err);
    return this;
  }
  open() {
    if (this.readyState === "closed" || this.readyState === "") {
      this.readyState = "opening";
      this.doOpen();
    }
    return this;
  }
  close() {
    if (this.readyState === "opening" || this.readyState === "open") {
      this.doClose();
      this.onClose();
    }
    return this;
  }
  send(packets) {
    if (this.readyState === "open") {
      this.write(packets);
    }
  }
  onOpen() {
    this.readyState = "open";
    this.writable = true;
    super.emit("open");
  }
  onData(data) {
    const packet = decodePacket(data, this.socket.binaryType);
    this.onPacket(packet);
  }
  onPacket(packet) {
    super.emit("packet", packet);
  }
  onClose() {
    this.readyState = "closed";
    super.emit("close");
  }
}
var alphabet = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-_".split(""), length = 64, map$2 = {}, seed = 0, i = 0, prev;
function encode$1(num) {
  var encoded = "";
  do {
    encoded = alphabet[num % length] + encoded;
    num = Math.floor(num / length);
  } while (num > 0);
  return encoded;
}
function decode$1(str2) {
  var decoded = 0;
  for (i = 0; i < str2.length; i++) {
    decoded = decoded * length + map$2[str2.charAt(i)];
  }
  return decoded;
}
function yeast() {
  var now2 = encode$1(+new Date());
  if (now2 !== prev)
    return seed = 0, prev = now2;
  return now2 + "." + encode$1(seed++);
}
for (; i < length; i++)
  map$2[alphabet[i]] = i;
yeast.encode = encode$1;
yeast.decode = decode$1;
var yeast_1 = yeast;
var parseqs = {};
parseqs.encode = function(obj) {
  var str2 = "";
  for (var i2 in obj) {
    if (obj.hasOwnProperty(i2)) {
      if (str2.length)
        str2 += "&";
      str2 += encodeURIComponent(i2) + "=" + encodeURIComponent(obj[i2]);
    }
  }
  return str2;
};
parseqs.decode = function(qs) {
  var qry = {};
  var pairs = qs.split("&");
  for (var i2 = 0, l2 = pairs.length; i2 < l2; i2++) {
    var pair = pairs[i2].split("=");
    qry[decodeURIComponent(pair[0])] = decodeURIComponent(pair[1]);
  }
  return qry;
};
class Polling extends Transport {
  constructor() {
    super(...arguments);
    this.polling = false;
  }
  get name() {
    return "polling";
  }
  doOpen() {
    this.poll();
  }
  pause(onPause) {
    this.readyState = "pausing";
    const pause = () => {
      this.readyState = "paused";
      onPause();
    };
    if (this.polling || !this.writable) {
      let total = 0;
      if (this.polling) {
        total++;
        this.once("pollComplete", function() {
          --total || pause();
        });
      }
      if (!this.writable) {
        total++;
        this.once("drain", function() {
          --total || pause();
        });
      }
    } else {
      pause();
    }
  }
  poll() {
    this.polling = true;
    this.doPoll();
    this.emit("poll");
  }
  onData(data) {
    const callback = (packet) => {
      if (this.readyState === "opening" && packet.type === "open") {
        this.onOpen();
      }
      if (packet.type === "close") {
        this.onClose();
        return false;
      }
      this.onPacket(packet);
    };
    decodePayload(data, this.socket.binaryType).forEach(callback);
    if (this.readyState !== "closed") {
      this.polling = false;
      this.emit("pollComplete");
      if (this.readyState === "open") {
        this.poll();
      }
    }
  }
  doClose() {
    const close = () => {
      this.write([{ type: "close" }]);
    };
    if (this.readyState === "open") {
      close();
    } else {
      this.once("open", close);
    }
  }
  write(packets) {
    this.writable = false;
    encodePayload(packets, (data) => {
      this.doWrite(data, () => {
        this.writable = true;
        this.emit("drain");
      });
    });
  }
  uri() {
    let query = this.query || {};
    const schema = this.opts.secure ? "https" : "http";
    let port = "";
    if (this.opts.timestampRequests !== false) {
      query[this.opts.timestampParam] = yeast_1();
    }
    if (!this.supportsBinary && !query.sid) {
      query.b64 = 1;
    }
    if (this.opts.port && (schema === "https" && Number(this.opts.port) !== 443 || schema === "http" && Number(this.opts.port) !== 80)) {
      port = ":" + this.opts.port;
    }
    const encodedQuery = parseqs.encode(query);
    const ipv6 = this.opts.hostname.indexOf(":") !== -1;
    return schema + "://" + (ipv6 ? "[" + this.opts.hostname + "]" : this.opts.hostname) + port + this.opts.path + (encodedQuery.length ? "?" + encodedQuery : "");
  }
}
function empty() {
}
const hasXHR2 = function() {
  const xhr = new XMLHttpRequest$1({
    xdomain: false
  });
  return xhr.responseType != null;
}();
class XHR extends Polling {
  constructor(opts) {
    super(opts);
    if (typeof location !== "undefined") {
      const isSSL = location.protocol === "https:";
      let port = location.port;
      if (!port) {
        port = isSSL ? "443" : "80";
      }
      this.xd = typeof location !== "undefined" && opts.hostname !== location.hostname || port !== opts.port;
      this.xs = opts.secure !== isSSL;
    }
    const forceBase64 = opts && opts.forceBase64;
    this.supportsBinary = hasXHR2 && !forceBase64;
  }
  request(opts = {}) {
    Object.assign(opts, { xd: this.xd, xs: this.xs }, this.opts);
    return new Request(this.uri(), opts);
  }
  doWrite(data, fn) {
    const req = this.request({
      method: "POST",
      data
    });
    req.on("success", fn);
    req.on("error", (err) => {
      this.onError("xhr post error", err);
    });
  }
  doPoll() {
    const req = this.request();
    req.on("data", this.onData.bind(this));
    req.on("error", (err) => {
      this.onError("xhr poll error", err);
    });
    this.pollXhr = req;
  }
}
class Request extends Emitter_1 {
  constructor(uri, opts) {
    super();
    installTimerFunctions(this, opts);
    this.opts = opts;
    this.method = opts.method || "GET";
    this.uri = uri;
    this.async = opts.async !== false;
    this.data = opts.data !== void 0 ? opts.data : null;
    this.create();
  }
  create() {
    const opts = pick(this.opts, "agent", "pfx", "key", "passphrase", "cert", "ca", "ciphers", "rejectUnauthorized", "autoUnref");
    opts.xdomain = !!this.opts.xd;
    opts.xscheme = !!this.opts.xs;
    const xhr = this.xhr = new XMLHttpRequest$1(opts);
    try {
      xhr.open(this.method, this.uri, this.async);
      try {
        if (this.opts.extraHeaders) {
          xhr.setDisableHeaderCheck && xhr.setDisableHeaderCheck(true);
          for (let i2 in this.opts.extraHeaders) {
            if (this.opts.extraHeaders.hasOwnProperty(i2)) {
              xhr.setRequestHeader(i2, this.opts.extraHeaders[i2]);
            }
          }
        }
      } catch (e) {
      }
      if (this.method === "POST") {
        try {
          xhr.setRequestHeader("Content-type", "text/plain;charset=UTF-8");
        } catch (e) {
        }
      }
      try {
        xhr.setRequestHeader("Accept", "*/*");
      } catch (e) {
      }
      if ("withCredentials" in xhr) {
        xhr.withCredentials = this.opts.withCredentials;
      }
      if (this.opts.requestTimeout) {
        xhr.timeout = this.opts.requestTimeout;
      }
      xhr.onreadystatechange = () => {
        if (xhr.readyState !== 4)
          return;
        if (xhr.status === 200 || xhr.status === 1223) {
          this.onLoad();
        } else {
          this.setTimeoutFn(() => {
            this.onError(typeof xhr.status === "number" ? xhr.status : 0);
          }, 0);
        }
      };
      xhr.send(this.data);
    } catch (e) {
      this.setTimeoutFn(() => {
        this.onError(e);
      }, 0);
      return;
    }
    if (typeof document !== "undefined") {
      this.index = Request.requestsCount++;
      Request.requests[this.index] = this;
    }
  }
  onSuccess() {
    this.emit("success");
    this.cleanup();
  }
  onData(data) {
    this.emit("data", data);
    this.onSuccess();
  }
  onError(err) {
    this.emit("error", err);
    this.cleanup(true);
  }
  cleanup(fromError) {
    if (typeof this.xhr === "undefined" || this.xhr === null) {
      return;
    }
    this.xhr.onreadystatechange = empty;
    if (fromError) {
      try {
        this.xhr.abort();
      } catch (e) {
      }
    }
    if (typeof document !== "undefined") {
      delete Request.requests[this.index];
    }
    this.xhr = null;
  }
  onLoad() {
    const data = this.xhr.responseText;
    if (data !== null) {
      this.onData(data);
    }
  }
  abort() {
    this.cleanup();
  }
}
Request.requestsCount = 0;
Request.requests = {};
if (typeof document !== "undefined") {
  if (typeof attachEvent === "function") {
    attachEvent("onunload", unloadHandler);
  } else if (typeof addEventListener === "function") {
    const terminationEvent = "onpagehide" in globalThis$1 ? "pagehide" : "unload";
    addEventListener(terminationEvent, unloadHandler, false);
  }
}
function unloadHandler() {
  for (let i2 in Request.requests) {
    if (Request.requests.hasOwnProperty(i2)) {
      Request.requests[i2].abort();
    }
  }
}
const nextTick = (() => {
  const isPromiseAvailable = typeof Promise === "function" && typeof Promise.resolve === "function";
  if (isPromiseAvailable) {
    return (cb) => Promise.resolve().then(cb);
  } else {
    return (cb, setTimeoutFn) => setTimeoutFn(cb, 0);
  }
})();
const WebSocket = globalThis$1.WebSocket || globalThis$1.MozWebSocket;
const usingBrowserWebSocket = true;
const defaultBinaryType = "arraybuffer";
const isReactNative = typeof navigator !== "undefined" && typeof navigator.product === "string" && navigator.product.toLowerCase() === "reactnative";
class WS extends Transport {
  constructor(opts) {
    super(opts);
    this.supportsBinary = !opts.forceBase64;
  }
  get name() {
    return "websocket";
  }
  doOpen() {
    if (!this.check()) {
      return;
    }
    const uri = this.uri();
    const protocols = this.opts.protocols;
    const opts = isReactNative ? {} : pick(this.opts, "agent", "perMessageDeflate", "pfx", "key", "passphrase", "cert", "ca", "ciphers", "rejectUnauthorized", "localAddress", "protocolVersion", "origin", "maxPayload", "family", "checkServerIdentity");
    if (this.opts.extraHeaders) {
      opts.headers = this.opts.extraHeaders;
    }
    try {
      this.ws = usingBrowserWebSocket && !isReactNative ? protocols ? new WebSocket(uri, protocols) : new WebSocket(uri) : new WebSocket(uri, protocols, opts);
    } catch (err) {
      return this.emit("error", err);
    }
    this.ws.binaryType = this.socket.binaryType || defaultBinaryType;
    this.addEventListeners();
  }
  addEventListeners() {
    this.ws.onopen = () => {
      if (this.opts.autoUnref) {
        this.ws._socket.unref();
      }
      this.onOpen();
    };
    this.ws.onclose = this.onClose.bind(this);
    this.ws.onmessage = (ev) => this.onData(ev.data);
    this.ws.onerror = (e) => this.onError("websocket error", e);
  }
  write(packets) {
    this.writable = false;
    for (let i2 = 0; i2 < packets.length; i2++) {
      const packet = packets[i2];
      const lastPacket = i2 === packets.length - 1;
      encodePacket(packet, this.supportsBinary, (data) => {
        const opts = {};
        try {
          if (usingBrowserWebSocket) {
            this.ws.send(data);
          }
        } catch (e) {
        }
        if (lastPacket) {
          nextTick(() => {
            this.writable = true;
            this.emit("drain");
          }, this.setTimeoutFn);
        }
      });
    }
  }
  doClose() {
    if (typeof this.ws !== "undefined") {
      this.ws.close();
      this.ws = null;
    }
  }
  uri() {
    let query = this.query || {};
    const schema = this.opts.secure ? "wss" : "ws";
    let port = "";
    if (this.opts.port && (schema === "wss" && Number(this.opts.port) !== 443 || schema === "ws" && Number(this.opts.port) !== 80)) {
      port = ":" + this.opts.port;
    }
    if (this.opts.timestampRequests) {
      query[this.opts.timestampParam] = yeast_1();
    }
    if (!this.supportsBinary) {
      query.b64 = 1;
    }
    const encodedQuery = parseqs.encode(query);
    const ipv6 = this.opts.hostname.indexOf(":") !== -1;
    return schema + "://" + (ipv6 ? "[" + this.opts.hostname + "]" : this.opts.hostname) + port + this.opts.path + (encodedQuery.length ? "?" + encodedQuery : "");
  }
  check() {
    return !!WebSocket && !("__initialize" in WebSocket && this.name === WS.prototype.name);
  }
}
const transports = {
  websocket: WS,
  polling: XHR
};
class Socket$1 extends Emitter_1 {
  constructor(uri, opts = {}) {
    super();
    if (uri && typeof uri === "object") {
      opts = uri;
      uri = null;
    }
    if (uri) {
      uri = parseuri(uri);
      opts.hostname = uri.host;
      opts.secure = uri.protocol === "https" || uri.protocol === "wss";
      opts.port = uri.port;
      if (uri.query)
        opts.query = uri.query;
    } else if (opts.host) {
      opts.hostname = parseuri(opts.host).host;
    }
    installTimerFunctions(this, opts);
    this.secure = opts.secure != null ? opts.secure : typeof location !== "undefined" && location.protocol === "https:";
    if (opts.hostname && !opts.port) {
      opts.port = this.secure ? "443" : "80";
    }
    this.hostname = opts.hostname || (typeof location !== "undefined" ? location.hostname : "localhost");
    this.port = opts.port || (typeof location !== "undefined" && location.port ? location.port : this.secure ? "443" : "80");
    this.transports = opts.transports || ["polling", "websocket"];
    this.readyState = "";
    this.writeBuffer = [];
    this.prevBufferLen = 0;
    this.opts = Object.assign({
      path: "/engine.io",
      agent: false,
      withCredentials: false,
      upgrade: true,
      timestampParam: "t",
      rememberUpgrade: false,
      rejectUnauthorized: true,
      perMessageDeflate: {
        threshold: 1024
      },
      transportOptions: {},
      closeOnBeforeunload: true
    }, opts);
    this.opts.path = this.opts.path.replace(/\/$/, "") + "/";
    if (typeof this.opts.query === "string") {
      this.opts.query = parseqs.decode(this.opts.query);
    }
    this.id = null;
    this.upgrades = null;
    this.pingInterval = null;
    this.pingTimeout = null;
    this.pingTimeoutTimer = null;
    if (typeof addEventListener === "function") {
      if (this.opts.closeOnBeforeunload) {
        addEventListener("beforeunload", () => {
          if (this.transport) {
            this.transport.removeAllListeners();
            this.transport.close();
          }
        }, false);
      }
      if (this.hostname !== "localhost") {
        this.offlineEventListener = () => {
          this.onClose("transport close");
        };
        addEventListener("offline", this.offlineEventListener, false);
      }
    }
    this.open();
  }
  createTransport(name2) {
    const query = clone(this.opts.query);
    query.EIO = protocol$1;
    query.transport = name2;
    if (this.id)
      query.sid = this.id;
    const opts = Object.assign({}, this.opts.transportOptions[name2], this.opts, {
      query,
      socket: this,
      hostname: this.hostname,
      secure: this.secure,
      port: this.port
    });
    return new transports[name2](opts);
  }
  open() {
    let transport;
    if (this.opts.rememberUpgrade && Socket$1.priorWebsocketSuccess && this.transports.indexOf("websocket") !== -1) {
      transport = "websocket";
    } else if (this.transports.length === 0) {
      this.setTimeoutFn(() => {
        this.emitReserved("error", "No transports available");
      }, 0);
      return;
    } else {
      transport = this.transports[0];
    }
    this.readyState = "opening";
    try {
      transport = this.createTransport(transport);
    } catch (e) {
      this.transports.shift();
      this.open();
      return;
    }
    transport.open();
    this.setTransport(transport);
  }
  setTransport(transport) {
    if (this.transport) {
      this.transport.removeAllListeners();
    }
    this.transport = transport;
    transport.on("drain", this.onDrain.bind(this)).on("packet", this.onPacket.bind(this)).on("error", this.onError.bind(this)).on("close", () => {
      this.onClose("transport close");
    });
  }
  probe(name2) {
    let transport = this.createTransport(name2);
    let failed = false;
    Socket$1.priorWebsocketSuccess = false;
    const onTransportOpen = () => {
      if (failed)
        return;
      transport.send([{ type: "ping", data: "probe" }]);
      transport.once("packet", (msg) => {
        if (failed)
          return;
        if (msg.type === "pong" && msg.data === "probe") {
          this.upgrading = true;
          this.emitReserved("upgrading", transport);
          if (!transport)
            return;
          Socket$1.priorWebsocketSuccess = transport.name === "websocket";
          this.transport.pause(() => {
            if (failed)
              return;
            if (this.readyState === "closed")
              return;
            cleanup();
            this.setTransport(transport);
            transport.send([{ type: "upgrade" }]);
            this.emitReserved("upgrade", transport);
            transport = null;
            this.upgrading = false;
            this.flush();
          });
        } else {
          const err = new Error("probe error");
          err.transport = transport.name;
          this.emitReserved("upgradeError", err);
        }
      });
    };
    function freezeTransport() {
      if (failed)
        return;
      failed = true;
      cleanup();
      transport.close();
      transport = null;
    }
    const onerror = (err) => {
      const error = new Error("probe error: " + err);
      error.transport = transport.name;
      freezeTransport();
      this.emitReserved("upgradeError", error);
    };
    function onTransportClose() {
      onerror("transport closed");
    }
    function onclose() {
      onerror("socket closed");
    }
    function onupgrade(to) {
      if (transport && to.name !== transport.name) {
        freezeTransport();
      }
    }
    const cleanup = () => {
      transport.removeListener("open", onTransportOpen);
      transport.removeListener("error", onerror);
      transport.removeListener("close", onTransportClose);
      this.off("close", onclose);
      this.off("upgrading", onupgrade);
    };
    transport.once("open", onTransportOpen);
    transport.once("error", onerror);
    transport.once("close", onTransportClose);
    this.once("close", onclose);
    this.once("upgrading", onupgrade);
    transport.open();
  }
  onOpen() {
    this.readyState = "open";
    Socket$1.priorWebsocketSuccess = this.transport.name === "websocket";
    this.emitReserved("open");
    this.flush();
    if (this.readyState === "open" && this.opts.upgrade && this.transport.pause) {
      let i2 = 0;
      const l2 = this.upgrades.length;
      for (; i2 < l2; i2++) {
        this.probe(this.upgrades[i2]);
      }
    }
  }
  onPacket(packet) {
    if (this.readyState === "opening" || this.readyState === "open" || this.readyState === "closing") {
      this.emitReserved("packet", packet);
      this.emitReserved("heartbeat");
      switch (packet.type) {
        case "open":
          this.onHandshake(JSON.parse(packet.data));
          break;
        case "ping":
          this.resetPingTimeout();
          this.sendPacket("pong");
          this.emitReserved("ping");
          this.emitReserved("pong");
          break;
        case "error":
          const err = new Error("server error");
          err.code = packet.data;
          this.onError(err);
          break;
        case "message":
          this.emitReserved("data", packet.data);
          this.emitReserved("message", packet.data);
          break;
      }
    }
  }
  onHandshake(data) {
    this.emitReserved("handshake", data);
    this.id = data.sid;
    this.transport.query.sid = data.sid;
    this.upgrades = this.filterUpgrades(data.upgrades);
    this.pingInterval = data.pingInterval;
    this.pingTimeout = data.pingTimeout;
    this.onOpen();
    if (this.readyState === "closed")
      return;
    this.resetPingTimeout();
  }
  resetPingTimeout() {
    this.clearTimeoutFn(this.pingTimeoutTimer);
    this.pingTimeoutTimer = this.setTimeoutFn(() => {
      this.onClose("ping timeout");
    }, this.pingInterval + this.pingTimeout);
    if (this.opts.autoUnref) {
      this.pingTimeoutTimer.unref();
    }
  }
  onDrain() {
    this.writeBuffer.splice(0, this.prevBufferLen);
    this.prevBufferLen = 0;
    if (this.writeBuffer.length === 0) {
      this.emitReserved("drain");
    } else {
      this.flush();
    }
  }
  flush() {
    if (this.readyState !== "closed" && this.transport.writable && !this.upgrading && this.writeBuffer.length) {
      this.transport.send(this.writeBuffer);
      this.prevBufferLen = this.writeBuffer.length;
      this.emitReserved("flush");
    }
  }
  write(msg, options, fn) {
    this.sendPacket("message", msg, options, fn);
    return this;
  }
  send(msg, options, fn) {
    this.sendPacket("message", msg, options, fn);
    return this;
  }
  sendPacket(type, data, options, fn) {
    if (typeof data === "function") {
      fn = data;
      data = void 0;
    }
    if (typeof options === "function") {
      fn = options;
      options = null;
    }
    if (this.readyState === "closing" || this.readyState === "closed") {
      return;
    }
    options = options || {};
    options.compress = options.compress !== false;
    const packet = {
      type,
      data,
      options
    };
    this.emitReserved("packetCreate", packet);
    this.writeBuffer.push(packet);
    if (fn)
      this.once("flush", fn);
    this.flush();
  }
  close() {
    const close = () => {
      this.onClose("forced close");
      this.transport.close();
    };
    const cleanupAndClose = () => {
      this.off("upgrade", cleanupAndClose);
      this.off("upgradeError", cleanupAndClose);
      close();
    };
    const waitForUpgrade = () => {
      this.once("upgrade", cleanupAndClose);
      this.once("upgradeError", cleanupAndClose);
    };
    if (this.readyState === "opening" || this.readyState === "open") {
      this.readyState = "closing";
      if (this.writeBuffer.length) {
        this.once("drain", () => {
          if (this.upgrading) {
            waitForUpgrade();
          } else {
            close();
          }
        });
      } else if (this.upgrading) {
        waitForUpgrade();
      } else {
        close();
      }
    }
    return this;
  }
  onError(err) {
    Socket$1.priorWebsocketSuccess = false;
    this.emitReserved("error", err);
    this.onClose("transport error", err);
  }
  onClose(reason, desc) {
    if (this.readyState === "opening" || this.readyState === "open" || this.readyState === "closing") {
      this.clearTimeoutFn(this.pingTimeoutTimer);
      this.transport.removeAllListeners("close");
      this.transport.close();
      this.transport.removeAllListeners();
      if (typeof removeEventListener === "function") {
        removeEventListener("offline", this.offlineEventListener, false);
      }
      this.readyState = "closed";
      this.id = null;
      this.emitReserved("close", reason, desc);
      this.writeBuffer = [];
      this.prevBufferLen = 0;
    }
  }
  filterUpgrades(upgrades) {
    const filteredUpgrades = [];
    let i2 = 0;
    const j2 = upgrades.length;
    for (; i2 < j2; i2++) {
      if (~this.transports.indexOf(upgrades[i2]))
        filteredUpgrades.push(upgrades[i2]);
    }
    return filteredUpgrades;
  }
}
Socket$1.protocol = protocol$1;
function clone(obj) {
  const o = {};
  for (let i2 in obj) {
    if (obj.hasOwnProperty(i2)) {
      o[i2] = obj[i2];
    }
  }
  return o;
}
Socket$1.protocol;
const withNativeArrayBuffer = typeof ArrayBuffer === "function";
const isView = (obj) => {
  return typeof ArrayBuffer.isView === "function" ? ArrayBuffer.isView(obj) : obj.buffer instanceof ArrayBuffer;
};
const toString = Object.prototype.toString;
const withNativeBlob = typeof Blob === "function" || typeof Blob !== "undefined" && toString.call(Blob) === "[object BlobConstructor]";
const withNativeFile = typeof File === "function" || typeof File !== "undefined" && toString.call(File) === "[object FileConstructor]";
function isBinary(obj) {
  return withNativeArrayBuffer && (obj instanceof ArrayBuffer || isView(obj)) || withNativeBlob && obj instanceof Blob || withNativeFile && obj instanceof File;
}
function hasBinary(obj, toJSON) {
  if (!obj || typeof obj !== "object") {
    return false;
  }
  if (Array.isArray(obj)) {
    for (let i2 = 0, l2 = obj.length; i2 < l2; i2++) {
      if (hasBinary(obj[i2])) {
        return true;
      }
    }
    return false;
  }
  if (isBinary(obj)) {
    return true;
  }
  if (obj.toJSON && typeof obj.toJSON === "function" && arguments.length === 1) {
    return hasBinary(obj.toJSON(), true);
  }
  for (const key in obj) {
    if (Object.prototype.hasOwnProperty.call(obj, key) && hasBinary(obj[key])) {
      return true;
    }
  }
  return false;
}
function deconstructPacket(packet) {
  const buffers = [];
  const packetData = packet.data;
  const pack = packet;
  pack.data = _deconstructPacket(packetData, buffers);
  pack.attachments = buffers.length;
  return { packet: pack, buffers };
}
function _deconstructPacket(data, buffers) {
  if (!data)
    return data;
  if (isBinary(data)) {
    const placeholder = { _placeholder: true, num: buffers.length };
    buffers.push(data);
    return placeholder;
  } else if (Array.isArray(data)) {
    const newData = new Array(data.length);
    for (let i2 = 0; i2 < data.length; i2++) {
      newData[i2] = _deconstructPacket(data[i2], buffers);
    }
    return newData;
  } else if (typeof data === "object" && !(data instanceof Date)) {
    const newData = {};
    for (const key in data) {
      if (Object.prototype.hasOwnProperty.call(data, key)) {
        newData[key] = _deconstructPacket(data[key], buffers);
      }
    }
    return newData;
  }
  return data;
}
function reconstructPacket(packet, buffers) {
  packet.data = _reconstructPacket(packet.data, buffers);
  packet.attachments = void 0;
  return packet;
}
function _reconstructPacket(data, buffers) {
  if (!data)
    return data;
  if (data && data._placeholder) {
    return buffers[data.num];
  } else if (Array.isArray(data)) {
    for (let i2 = 0; i2 < data.length; i2++) {
      data[i2] = _reconstructPacket(data[i2], buffers);
    }
  } else if (typeof data === "object") {
    for (const key in data) {
      if (Object.prototype.hasOwnProperty.call(data, key)) {
        data[key] = _reconstructPacket(data[key], buffers);
      }
    }
  }
  return data;
}
const protocol = 5;
var PacketType;
(function(PacketType2) {
  PacketType2[PacketType2["CONNECT"] = 0] = "CONNECT";
  PacketType2[PacketType2["DISCONNECT"] = 1] = "DISCONNECT";
  PacketType2[PacketType2["EVENT"] = 2] = "EVENT";
  PacketType2[PacketType2["ACK"] = 3] = "ACK";
  PacketType2[PacketType2["CONNECT_ERROR"] = 4] = "CONNECT_ERROR";
  PacketType2[PacketType2["BINARY_EVENT"] = 5] = "BINARY_EVENT";
  PacketType2[PacketType2["BINARY_ACK"] = 6] = "BINARY_ACK";
})(PacketType || (PacketType = {}));
class Encoder {
  encode(obj) {
    if (obj.type === PacketType.EVENT || obj.type === PacketType.ACK) {
      if (hasBinary(obj)) {
        obj.type = obj.type === PacketType.EVENT ? PacketType.BINARY_EVENT : PacketType.BINARY_ACK;
        return this.encodeAsBinary(obj);
      }
    }
    return [this.encodeAsString(obj)];
  }
  encodeAsString(obj) {
    let str2 = "" + obj.type;
    if (obj.type === PacketType.BINARY_EVENT || obj.type === PacketType.BINARY_ACK) {
      str2 += obj.attachments + "-";
    }
    if (obj.nsp && obj.nsp !== "/") {
      str2 += obj.nsp + ",";
    }
    if (obj.id != null) {
      str2 += obj.id;
    }
    if (obj.data != null) {
      str2 += JSON.stringify(obj.data);
    }
    return str2;
  }
  encodeAsBinary(obj) {
    const deconstruction = deconstructPacket(obj);
    const pack = this.encodeAsString(deconstruction.packet);
    const buffers = deconstruction.buffers;
    buffers.unshift(pack);
    return buffers;
  }
}
class Decoder extends Emitter_1 {
  constructor() {
    super();
  }
  add(obj) {
    let packet;
    if (typeof obj === "string") {
      packet = this.decodeString(obj);
      if (packet.type === PacketType.BINARY_EVENT || packet.type === PacketType.BINARY_ACK) {
        this.reconstructor = new BinaryReconstructor(packet);
        if (packet.attachments === 0) {
          super.emitReserved("decoded", packet);
        }
      } else {
        super.emitReserved("decoded", packet);
      }
    } else if (isBinary(obj) || obj.base64) {
      if (!this.reconstructor) {
        throw new Error("got binary data when not reconstructing a packet");
      } else {
        packet = this.reconstructor.takeBinaryData(obj);
        if (packet) {
          this.reconstructor = null;
          super.emitReserved("decoded", packet);
        }
      }
    } else {
      throw new Error("Unknown type: " + obj);
    }
  }
  decodeString(str2) {
    let i2 = 0;
    const p2 = {
      type: Number(str2.charAt(0))
    };
    if (PacketType[p2.type] === void 0) {
      throw new Error("unknown packet type " + p2.type);
    }
    if (p2.type === PacketType.BINARY_EVENT || p2.type === PacketType.BINARY_ACK) {
      const start = i2 + 1;
      while (str2.charAt(++i2) !== "-" && i2 != str2.length) {
      }
      const buf = str2.substring(start, i2);
      if (buf != Number(buf) || str2.charAt(i2) !== "-") {
        throw new Error("Illegal attachments");
      }
      p2.attachments = Number(buf);
    }
    if (str2.charAt(i2 + 1) === "/") {
      const start = i2 + 1;
      while (++i2) {
        const c2 = str2.charAt(i2);
        if (c2 === ",")
          break;
        if (i2 === str2.length)
          break;
      }
      p2.nsp = str2.substring(start, i2);
    } else {
      p2.nsp = "/";
    }
    const next = str2.charAt(i2 + 1);
    if (next !== "" && Number(next) == next) {
      const start = i2 + 1;
      while (++i2) {
        const c2 = str2.charAt(i2);
        if (c2 == null || Number(c2) != c2) {
          --i2;
          break;
        }
        if (i2 === str2.length)
          break;
      }
      p2.id = Number(str2.substring(start, i2 + 1));
    }
    if (str2.charAt(++i2)) {
      const payload = tryParse(str2.substr(i2));
      if (Decoder.isPayloadValid(p2.type, payload)) {
        p2.data = payload;
      } else {
        throw new Error("invalid payload");
      }
    }
    return p2;
  }
  static isPayloadValid(type, payload) {
    switch (type) {
      case PacketType.CONNECT:
        return typeof payload === "object";
      case PacketType.DISCONNECT:
        return payload === void 0;
      case PacketType.CONNECT_ERROR:
        return typeof payload === "string" || typeof payload === "object";
      case PacketType.EVENT:
      case PacketType.BINARY_EVENT:
        return Array.isArray(payload) && payload.length > 0;
      case PacketType.ACK:
      case PacketType.BINARY_ACK:
        return Array.isArray(payload);
    }
  }
  destroy() {
    if (this.reconstructor) {
      this.reconstructor.finishedReconstruction();
    }
  }
}
function tryParse(str2) {
  try {
    return JSON.parse(str2);
  } catch (e) {
    return false;
  }
}
class BinaryReconstructor {
  constructor(packet) {
    this.packet = packet;
    this.buffers = [];
    this.reconPack = packet;
  }
  takeBinaryData(binData) {
    this.buffers.push(binData);
    if (this.buffers.length === this.reconPack.attachments) {
      const packet = reconstructPacket(this.reconPack, this.buffers);
      this.finishedReconstruction();
      return packet;
    }
    return null;
  }
  finishedReconstruction() {
    this.reconPack = null;
    this.buffers = [];
  }
}
var parser = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  protocol,
  get PacketType() {
    return PacketType;
  },
  Encoder,
  Decoder
}, Symbol.toStringTag, { value: "Module" }));
function on(obj, ev, fn) {
  obj.on(ev, fn);
  return function subDestroy() {
    obj.off(ev, fn);
  };
}
const RESERVED_EVENTS = Object.freeze({
  connect: 1,
  connect_error: 1,
  disconnect: 1,
  disconnecting: 1,
  newListener: 1,
  removeListener: 1
});
class Socket extends Emitter_1 {
  constructor(io, nsp, opts) {
    super();
    this.connected = false;
    this.disconnected = true;
    this.receiveBuffer = [];
    this.sendBuffer = [];
    this.ids = 0;
    this.acks = {};
    this.flags = {};
    this.io = io;
    this.nsp = nsp;
    if (opts && opts.auth) {
      this.auth = opts.auth;
    }
    if (this.io._autoConnect)
      this.open();
  }
  subEvents() {
    if (this.subs)
      return;
    const io = this.io;
    this.subs = [
      on(io, "open", this.onopen.bind(this)),
      on(io, "packet", this.onpacket.bind(this)),
      on(io, "error", this.onerror.bind(this)),
      on(io, "close", this.onclose.bind(this))
    ];
  }
  get active() {
    return !!this.subs;
  }
  connect() {
    if (this.connected)
      return this;
    this.subEvents();
    if (!this.io["_reconnecting"])
      this.io.open();
    if (this.io._readyState === "open")
      this.onopen();
    return this;
  }
  open() {
    return this.connect();
  }
  send(...args) {
    args.unshift("message");
    this.emit.apply(this, args);
    return this;
  }
  emit(ev, ...args) {
    if (RESERVED_EVENTS.hasOwnProperty(ev)) {
      throw new Error('"' + ev + '" is a reserved event name');
    }
    args.unshift(ev);
    const packet = {
      type: PacketType.EVENT,
      data: args
    };
    packet.options = {};
    packet.options.compress = this.flags.compress !== false;
    if (typeof args[args.length - 1] === "function") {
      const id = this.ids++;
      const ack = args.pop();
      this._registerAckCallback(id, ack);
      packet.id = id;
    }
    const isTransportWritable = this.io.engine && this.io.engine.transport && this.io.engine.transport.writable;
    const discardPacket = this.flags.volatile && (!isTransportWritable || !this.connected);
    if (discardPacket)
      ;
    else if (this.connected) {
      this.packet(packet);
    } else {
      this.sendBuffer.push(packet);
    }
    this.flags = {};
    return this;
  }
  _registerAckCallback(id, ack) {
    const timeout = this.flags.timeout;
    if (timeout === void 0) {
      this.acks[id] = ack;
      return;
    }
    const timer = this.io.setTimeoutFn(() => {
      delete this.acks[id];
      for (let i2 = 0; i2 < this.sendBuffer.length; i2++) {
        if (this.sendBuffer[i2].id === id) {
          this.sendBuffer.splice(i2, 1);
        }
      }
      ack.call(this, new Error("operation has timed out"));
    }, timeout);
    this.acks[id] = (...args) => {
      this.io.clearTimeoutFn(timer);
      ack.apply(this, [null, ...args]);
    };
  }
  packet(packet) {
    packet.nsp = this.nsp;
    this.io._packet(packet);
  }
  onopen() {
    if (typeof this.auth == "function") {
      this.auth((data) => {
        this.packet({ type: PacketType.CONNECT, data });
      });
    } else {
      this.packet({ type: PacketType.CONNECT, data: this.auth });
    }
  }
  onerror(err) {
    if (!this.connected) {
      this.emitReserved("connect_error", err);
    }
  }
  onclose(reason) {
    this.connected = false;
    this.disconnected = true;
    delete this.id;
    this.emitReserved("disconnect", reason);
  }
  onpacket(packet) {
    const sameNamespace = packet.nsp === this.nsp;
    if (!sameNamespace)
      return;
    switch (packet.type) {
      case PacketType.CONNECT:
        if (packet.data && packet.data.sid) {
          const id = packet.data.sid;
          this.onconnect(id);
        } else {
          this.emitReserved("connect_error", new Error("It seems you are trying to reach a Socket.IO server in v2.x with a v3.x client, but they are not compatible (more information here: https://socket.io/docs/v3/migrating-from-2-x-to-3-0/)"));
        }
        break;
      case PacketType.EVENT:
        this.onevent(packet);
        break;
      case PacketType.BINARY_EVENT:
        this.onevent(packet);
        break;
      case PacketType.ACK:
        this.onack(packet);
        break;
      case PacketType.BINARY_ACK:
        this.onack(packet);
        break;
      case PacketType.DISCONNECT:
        this.ondisconnect();
        break;
      case PacketType.CONNECT_ERROR:
        this.destroy();
        const err = new Error(packet.data.message);
        err.data = packet.data.data;
        this.emitReserved("connect_error", err);
        break;
    }
  }
  onevent(packet) {
    const args = packet.data || [];
    if (packet.id != null) {
      args.push(this.ack(packet.id));
    }
    if (this.connected) {
      this.emitEvent(args);
    } else {
      this.receiveBuffer.push(Object.freeze(args));
    }
  }
  emitEvent(args) {
    if (this._anyListeners && this._anyListeners.length) {
      const listeners = this._anyListeners.slice();
      for (const listener of listeners) {
        listener.apply(this, args);
      }
    }
    super.emit.apply(this, args);
  }
  ack(id) {
    const self2 = this;
    let sent = false;
    return function(...args) {
      if (sent)
        return;
      sent = true;
      self2.packet({
        type: PacketType.ACK,
        id,
        data: args
      });
    };
  }
  onack(packet) {
    const ack = this.acks[packet.id];
    if (typeof ack === "function") {
      ack.apply(this, packet.data);
      delete this.acks[packet.id];
    }
  }
  onconnect(id) {
    this.id = id;
    this.connected = true;
    this.disconnected = false;
    this.emitBuffered();
    this.emitReserved("connect");
  }
  emitBuffered() {
    this.receiveBuffer.forEach((args) => this.emitEvent(args));
    this.receiveBuffer = [];
    this.sendBuffer.forEach((packet) => this.packet(packet));
    this.sendBuffer = [];
  }
  ondisconnect() {
    this.destroy();
    this.onclose("io server disconnect");
  }
  destroy() {
    if (this.subs) {
      this.subs.forEach((subDestroy) => subDestroy());
      this.subs = void 0;
    }
    this.io["_destroy"](this);
  }
  disconnect() {
    if (this.connected) {
      this.packet({ type: PacketType.DISCONNECT });
    }
    this.destroy();
    if (this.connected) {
      this.onclose("io client disconnect");
    }
    return this;
  }
  close() {
    return this.disconnect();
  }
  compress(compress) {
    this.flags.compress = compress;
    return this;
  }
  get volatile() {
    this.flags.volatile = true;
    return this;
  }
  timeout(timeout) {
    this.flags.timeout = timeout;
    return this;
  }
  onAny(listener) {
    this._anyListeners = this._anyListeners || [];
    this._anyListeners.push(listener);
    return this;
  }
  prependAny(listener) {
    this._anyListeners = this._anyListeners || [];
    this._anyListeners.unshift(listener);
    return this;
  }
  offAny(listener) {
    if (!this._anyListeners) {
      return this;
    }
    if (listener) {
      const listeners = this._anyListeners;
      for (let i2 = 0; i2 < listeners.length; i2++) {
        if (listener === listeners[i2]) {
          listeners.splice(i2, 1);
          return this;
        }
      }
    } else {
      this._anyListeners = [];
    }
    return this;
  }
  listenersAny() {
    return this._anyListeners || [];
  }
}
var backo2 = Backoff;
function Backoff(opts) {
  opts = opts || {};
  this.ms = opts.min || 100;
  this.max = opts.max || 1e4;
  this.factor = opts.factor || 2;
  this.jitter = opts.jitter > 0 && opts.jitter <= 1 ? opts.jitter : 0;
  this.attempts = 0;
}
Backoff.prototype.duration = function() {
  var ms = this.ms * Math.pow(this.factor, this.attempts++);
  if (this.jitter) {
    var rand = Math.random();
    var deviation = Math.floor(rand * this.jitter * ms);
    ms = (Math.floor(rand * 10) & 1) == 0 ? ms - deviation : ms + deviation;
  }
  return Math.min(ms, this.max) | 0;
};
Backoff.prototype.reset = function() {
  this.attempts = 0;
};
Backoff.prototype.setMin = function(min) {
  this.ms = min;
};
Backoff.prototype.setMax = function(max) {
  this.max = max;
};
Backoff.prototype.setJitter = function(jitter) {
  this.jitter = jitter;
};
class Manager extends Emitter_1 {
  constructor(uri, opts) {
    var _a3;
    super();
    this.nsps = {};
    this.subs = [];
    if (uri && typeof uri === "object") {
      opts = uri;
      uri = void 0;
    }
    opts = opts || {};
    opts.path = opts.path || "/socket.io";
    this.opts = opts;
    installTimerFunctions(this, opts);
    this.reconnection(opts.reconnection !== false);
    this.reconnectionAttempts(opts.reconnectionAttempts || Infinity);
    this.reconnectionDelay(opts.reconnectionDelay || 1e3);
    this.reconnectionDelayMax(opts.reconnectionDelayMax || 5e3);
    this.randomizationFactor((_a3 = opts.randomizationFactor) !== null && _a3 !== void 0 ? _a3 : 0.5);
    this.backoff = new backo2({
      min: this.reconnectionDelay(),
      max: this.reconnectionDelayMax(),
      jitter: this.randomizationFactor()
    });
    this.timeout(opts.timeout == null ? 2e4 : opts.timeout);
    this._readyState = "closed";
    this.uri = uri;
    const _parser2 = opts.parser || parser;
    this.encoder = new _parser2.Encoder();
    this.decoder = new _parser2.Decoder();
    this._autoConnect = opts.autoConnect !== false;
    if (this._autoConnect)
      this.open();
  }
  reconnection(v2) {
    if (!arguments.length)
      return this._reconnection;
    this._reconnection = !!v2;
    return this;
  }
  reconnectionAttempts(v2) {
    if (v2 === void 0)
      return this._reconnectionAttempts;
    this._reconnectionAttempts = v2;
    return this;
  }
  reconnectionDelay(v2) {
    var _a3;
    if (v2 === void 0)
      return this._reconnectionDelay;
    this._reconnectionDelay = v2;
    (_a3 = this.backoff) === null || _a3 === void 0 ? void 0 : _a3.setMin(v2);
    return this;
  }
  randomizationFactor(v2) {
    var _a3;
    if (v2 === void 0)
      return this._randomizationFactor;
    this._randomizationFactor = v2;
    (_a3 = this.backoff) === null || _a3 === void 0 ? void 0 : _a3.setJitter(v2);
    return this;
  }
  reconnectionDelayMax(v2) {
    var _a3;
    if (v2 === void 0)
      return this._reconnectionDelayMax;
    this._reconnectionDelayMax = v2;
    (_a3 = this.backoff) === null || _a3 === void 0 ? void 0 : _a3.setMax(v2);
    return this;
  }
  timeout(v2) {
    if (!arguments.length)
      return this._timeout;
    this._timeout = v2;
    return this;
  }
  maybeReconnectOnOpen() {
    if (!this._reconnecting && this._reconnection && this.backoff.attempts === 0) {
      this.reconnect();
    }
  }
  open(fn) {
    if (~this._readyState.indexOf("open"))
      return this;
    this.engine = new Socket$1(this.uri, this.opts);
    const socket = this.engine;
    const self2 = this;
    this._readyState = "opening";
    this.skipReconnect = false;
    const openSubDestroy = on(socket, "open", function() {
      self2.onopen();
      fn && fn();
    });
    const errorSub = on(socket, "error", (err) => {
      self2.cleanup();
      self2._readyState = "closed";
      this.emitReserved("error", err);
      if (fn) {
        fn(err);
      } else {
        self2.maybeReconnectOnOpen();
      }
    });
    if (this._timeout !== false) {
      const timeout = this._timeout;
      if (timeout === 0) {
        openSubDestroy();
      }
      const timer = this.setTimeoutFn(() => {
        openSubDestroy();
        socket.close();
        socket.emit("error", new Error("timeout"));
      }, timeout);
      if (this.opts.autoUnref) {
        timer.unref();
      }
      this.subs.push(function subDestroy() {
        clearTimeout(timer);
      });
    }
    this.subs.push(openSubDestroy);
    this.subs.push(errorSub);
    return this;
  }
  connect(fn) {
    return this.open(fn);
  }
  onopen() {
    this.cleanup();
    this._readyState = "open";
    this.emitReserved("open");
    const socket = this.engine;
    this.subs.push(on(socket, "ping", this.onping.bind(this)), on(socket, "data", this.ondata.bind(this)), on(socket, "error", this.onerror.bind(this)), on(socket, "close", this.onclose.bind(this)), on(this.decoder, "decoded", this.ondecoded.bind(this)));
  }
  onping() {
    this.emitReserved("ping");
  }
  ondata(data) {
    this.decoder.add(data);
  }
  ondecoded(packet) {
    this.emitReserved("packet", packet);
  }
  onerror(err) {
    this.emitReserved("error", err);
  }
  socket(nsp, opts) {
    let socket = this.nsps[nsp];
    if (!socket) {
      socket = new Socket(this, nsp, opts);
      this.nsps[nsp] = socket;
    }
    return socket;
  }
  _destroy(socket) {
    const nsps = Object.keys(this.nsps);
    for (const nsp of nsps) {
      const socket2 = this.nsps[nsp];
      if (socket2.active) {
        return;
      }
    }
    this._close();
  }
  _packet(packet) {
    const encodedPackets = this.encoder.encode(packet);
    for (let i2 = 0; i2 < encodedPackets.length; i2++) {
      this.engine.write(encodedPackets[i2], packet.options);
    }
  }
  cleanup() {
    this.subs.forEach((subDestroy) => subDestroy());
    this.subs.length = 0;
    this.decoder.destroy();
  }
  _close() {
    this.skipReconnect = true;
    this._reconnecting = false;
    this.onclose("forced close");
    if (this.engine)
      this.engine.close();
  }
  disconnect() {
    return this._close();
  }
  onclose(reason) {
    this.cleanup();
    this.backoff.reset();
    this._readyState = "closed";
    this.emitReserved("close", reason);
    if (this._reconnection && !this.skipReconnect) {
      this.reconnect();
    }
  }
  reconnect() {
    if (this._reconnecting || this.skipReconnect)
      return this;
    const self2 = this;
    if (this.backoff.attempts >= this._reconnectionAttempts) {
      this.backoff.reset();
      this.emitReserved("reconnect_failed");
      this._reconnecting = false;
    } else {
      const delay = this.backoff.duration();
      this._reconnecting = true;
      const timer = this.setTimeoutFn(() => {
        if (self2.skipReconnect)
          return;
        this.emitReserved("reconnect_attempt", self2.backoff.attempts);
        if (self2.skipReconnect)
          return;
        self2.open((err) => {
          if (err) {
            self2._reconnecting = false;
            self2.reconnect();
            this.emitReserved("reconnect_error", err);
          } else {
            self2.onreconnect();
          }
        });
      }, delay);
      if (this.opts.autoUnref) {
        timer.unref();
      }
      this.subs.push(function subDestroy() {
        clearTimeout(timer);
      });
    }
  }
  onreconnect() {
    const attempt = this.backoff.attempts;
    this._reconnecting = false;
    this.backoff.reset();
    this.emitReserved("reconnect", attempt);
  }
}
const cache = {};
function lookup(uri, opts) {
  if (typeof uri === "object") {
    opts = uri;
    uri = void 0;
  }
  opts = opts || {};
  const parsed = url$1(uri, opts.path || "/socket.io");
  const source = parsed.source;
  const id = parsed.id;
  const path = parsed.path;
  const sameNamespace = cache[id] && path in cache[id]["nsps"];
  const newConnection = opts.forceNew || opts["force new connection"] || opts.multiplex === false || sameNamespace;
  let io;
  if (newConnection) {
    io = new Manager(source, opts);
  } else {
    if (!cache[id]) {
      cache[id] = new Manager(source, opts);
    }
    io = cache[id];
  }
  if (parsed.query && !opts.query) {
    opts.query = parsed.queryKey;
  }
  return io.socket(parsed.path, opts);
}
Object.assign(lookup, {
  Manager,
  Socket,
  io: lookup,
  connect: lookup
});
var __accessCheck$6 = (obj, member, msg) => {
  if (!member.has(obj))
    throw TypeError("Cannot " + msg);
};
var __privateGet$6 = (obj, member, getter) => {
  __accessCheck$6(obj, member, "read from private field");
  return getter ? getter.call(obj) : member.get(obj);
};
var __privateAdd$6 = (obj, member, value) => {
  if (member.has(obj))
    throw TypeError("Cannot add the same private member more than once");
  member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
};
var __privateSet$6 = (obj, member, value, setter) => {
  __accessCheck$6(obj, member, "write to private field");
  setter ? setter.call(obj, value) : member.set(obj, value);
  return value;
};
var _cvsWidth, _cvsHeight, _cvsScale, _ofsLeft4elm, _ofsTop4elm, _ofsPadLeft_Dom2PIXI, _ofsPadTop_Dom2PIXI, _sk, _hHook, _hToastDat, _aFncHook, _main_title, _tglFlscr, _info_title, _preFromPlg, _hN2Ext, _genImage, _genVideo;
const _SysBase = class {
  constructor(hPlg = {}, arg) {
    this.hPlg = hPlg;
    this.arg = arg;
    this.hFactoryCls = {};
    this.fetch = (url2) => fetch(url2);
    this.resolution = 1;
    this.data = { sys: {}, mark: {}, kidoku: {} };
    __privateAdd$6(this, _cvsWidth, 0);
    __privateAdd$6(this, _cvsHeight, 0);
    __privateAdd$6(this, _cvsScale, 1);
    __privateAdd$6(this, _ofsLeft4elm, 0);
    __privateAdd$6(this, _ofsTop4elm, 0);
    __privateAdd$6(this, _ofsPadLeft_Dom2PIXI, 0);
    __privateAdd$6(this, _ofsPadTop_Dom2PIXI, 0);
    this.isFullScr = false;
    this.extPort = 3776;
    __privateAdd$6(this, _sk, void 0);
    __privateAdd$6(this, _hHook, {
      auth: (o) => {
        if (o.t !== this.cfg.oCfg.debuger_token) {
          this.end();
          return;
        }
        this.toast("\u63A5\u7D9A");
      },
      continue: () => this.toast("\u518D\u751F"),
      disconnect: () => this.toast("\u5207\u65AD"),
      restart: (o) => {
        var _a3;
        this.send2Dbg((_a3 = o == null ? void 0 : o.ri) != null ? _a3 : "", {});
        this.end();
        this.run();
      },
      pause: () => this.toast("\u4E00\u6642\u505C\u6B62"),
      stopOnEntry: () => this.toast("\u4E00\u6642\u505C\u6B62"),
      stopOnDataBreakpoint: () => this.toast("\u6CE8\u610F"),
      stopOnBreakpoint: () => this.toast("\u6CE8\u610F"),
      stopOnStep: () => this.toast("\u4E00\u6B69\u9032\u3080"),
      stopOnStepIn: () => this.toast("\u30B9\u30C6\u30C3\u30D5\u309A\u30A4\u30F3"),
      stopOnStepOut: () => this.toast("\u30B9\u30C6\u30C3\u30D5\u309A\u30A2\u30A6\u30C8"),
      stopOnBackstep: () => this.toast("\u4E00\u6B69\u623B\u308B"),
      _addPath: (o) => this.cfg.addPath(o.fn, o.o)
    });
    this.pathBaseCnvSnPath4Dbg = "";
    __privateAdd$6(this, _aFncHook, []);
    this.callHook = (_type, _o) => {
    };
    this.send2Dbg = (type, o) => {
      var _a3;
      (_a3 = __privateGet$6(this, _sk)) == null ? void 0 : _a3.emit("data", type, o);
    };
    this.copyBMFolder = (_from, _to) => {
    };
    this.eraseBMFolder = (_place) => {
    };
    this.close = () => false;
    this._export = () => false;
    this._import = () => false;
    this.navigate_to = () => false;
    this.title = (hArg) => {
      const { text: text2 } = hArg;
      if (!text2)
        throw "[title] text\u306F\u5FC5\u9808\u3067\u3059";
      __privateSet$6(this, _main_title, text2);
      this.titleSub(__privateGet$6(this, _main_title) + __privateGet$6(this, _info_title));
      return false;
    };
    __privateAdd$6(this, _main_title, "");
    __privateAdd$6(this, _tglFlscr, (hArg) => {
      if (!hArg.key) {
        this.tglFlscr_sub();
        return false;
      }
      const key = hArg.key.toLowerCase();
      document.addEventListener("keydown", (e) => {
        const key2 = (e.altKey ? e.key === "Alt" ? "" : "alt+" : "") + (e.ctrlKey ? e.key === "Control" ? "" : "ctrl+" : "") + (e.shiftKey ? e.key === "Shift" ? "" : "shift+" : "") + e.key.toLowerCase();
        if (key2 !== key)
          return;
        e.stopPropagation();
        this.tglFlscr_sub();
      }, { passive: true });
      return false;
    });
    this.update_check = () => false;
    this.window = () => false;
    __privateAdd$6(this, _info_title, "");
    __privateAdd$6(this, _preFromPlg, (_ext, d2) => {
      return { ret: d2.toString(), ext_num: 0 };
    });
    __privateAdd$6(this, _hN2Ext, {
      1: { ext: "jpeg", fnc: (bl) => __privateGet$6(this, _genImage).call(this, bl), mime: "image/jpeg" },
      2: { ext: "png", fnc: (bl) => __privateGet$6(this, _genImage).call(this, bl), mime: "image/png" },
      3: { ext: "svg", fnc: (bl) => __privateGet$6(this, _genImage).call(this, bl), mime: "image/svg+xml" },
      4: { ext: "webp", fnc: (bl) => __privateGet$6(this, _genImage).call(this, bl), mime: "image/webp" },
      10: { ext: "mp3", fnc: (bl) => bl.arrayBuffer(), mime: "audio/mpeg" },
      11: { ext: "m4a", fnc: (bl) => bl.arrayBuffer(), mime: "audio/aac" },
      12: { ext: "ogg", fnc: (bl) => bl.arrayBuffer(), mime: "audio/ogg" },
      13: { ext: "aac", fnc: (bl) => bl.arrayBuffer(), mime: "audio/aac" },
      14: { ext: "flac", fnc: (bl) => bl.arrayBuffer(), mime: "audio/flac" },
      15: { ext: "wav", fnc: (bl) => bl.arrayBuffer(), mime: "audio/wav" },
      20: { ext: "mp4", fnc: (bl) => __privateGet$6(this, _genVideo).call(this, bl), mime: "video/mp4" },
      21: { ext: "webm", fnc: (bl) => __privateGet$6(this, _genVideo).call(this, bl), mime: "video/webm" },
      22: { ext: "ogv", fnc: (bl) => __privateGet$6(this, _genVideo).call(this, bl), mime: "video/ogv" }
    });
    __privateAdd$6(this, _genImage, (bl) => new Promise((rs, rj) => {
      const img = new Image();
      img.onload = () => rs(img);
      img.onerror = (e) => rj(e);
      img.src = URL.createObjectURL(bl);
    }));
    __privateAdd$6(this, _genVideo, (bl) => new Promise((rs, rj) => {
      const v2 = document.createElement("video");
      v2.addEventListener("error", () => {
        var _a3, _b3;
        return rj((_b3 = (_a3 = v2 == null ? void 0 : v2.error) == null ? void 0 : _a3.message) != null ? _b3 : "");
      });
      v2.addEventListener("canplay", () => rs(v2));
      v2.src = URL.createObjectURL(bl);
    }));
    this.enc = (d2) => d2;
    this.stk = () => "";
    this.hash = (_data2) => "";
    this.isApp = false;
    this.$path_downloads = "";
    this.$path_userdata = "";
    this.canCapturePage = (_fn) => false;
  }
  async loaded(hPlg, _arg) {
    const fncPre = hPlg.snsys_pre;
    delete hPlg.snsys_pre;
    return fncPre == null ? void 0 : fncPre.init({
      addTag: () => {
      },
      addLayCls: () => {
      },
      searchPath: () => "",
      getVal: () => ({}),
      resume: () => {
      },
      render: () => {
      },
      setDec: (fnc) => __privateSet$6(this, _preFromPlg, fnc),
      setEnc: (fnc) => this.enc = fnc,
      getStK: (fnc) => this.stk = fnc,
      getHash: (fnc) => this.hash = fnc
    });
  }
  get cur() {
    return this.arg.cur;
  }
  get crypto() {
    return this.arg.crypto;
  }
  async loadPath(_hPathFn2Exts, cfg) {
    this.cfg = cfg;
  }
  initVal(_data2, _hTmp2, _comp) {
  }
  flush() {
  }
  async run() {
  }
  init(hTag, appPixi, val, main2) {
    this.val = val;
    this.appPixi = appPixi;
    let mes = "";
    try {
      this.val.setSys(this);
      mes = "sys";
      mes += Number(this.val.getVal("sys:TextLayer.Back.Alpha", 1));
      mes = "kidoku";
      this.val.saveKidoku();
    } catch (e) {
      console.error(`\u30BB\u30FC\u30D6\u30C7\u30FC\u30BF\uFF08${mes}\uFF09\u304C\u58CA\u308C\u3066\u3044\u307E\u3059\u3002\u4E00\u5EA6\u30AF\u30EA\u30A2\u3059\u308B\u5FC5\u8981\u304C\u3042\u308A\u307E\u3059 %o`, e);
    }
    hTag.close = (o) => this.close(o);
    hTag.export = (o) => this._export(o);
    hTag.import = (o) => this._import(o);
    hTag.navigate_to = (o) => this.navigate_to(o);
    hTag.title = (o) => this.title(o);
    hTag.toggle_full_screen = (o) => __privateGet$6(this, _tglFlscr).call(this, o);
    hTag.update_check = (o) => this.update_check(o);
    hTag.window = (o) => this.window(o);
    val.setVal_Nochk("tmp", "const.sn.isApp", () => this.isApp);
    val.setVal_Nochk("tmp", "const.sn.isDbg", () => CmnLib.isDbg);
    val.setVal_Nochk("tmp", "const.sn.isPackaged", () => CmnLib.isPackaged);
    this.val.defTmp("const.sn.displayState", () => this.isFullScr);
    val.setVal_Nochk("sys", _SysBase.VALNM_CFG_NS, this.cfg.oCfg.save_ns);
    val.flush();
    if (CmnLib.isDbg)
      this.attach_debug(main2);
    this.hFactoryCls = {};
    const a2 = [];
    for (const nm in this.hPlg)
      a2.push(this.hPlg[nm].init({
        addTag: (name2, tag_fnc) => {
          if (hTag[name2])
            throw `\u3059\u3067\u306B\u5B9A\u7FA9\u6E08\u307F\u306E\u30BF\u30B0[${name2}]\u3067\u3059`;
          hTag[name2] = tag_fnc;
        },
        addLayCls: (cls, fnc) => {
          if (this.hFactoryCls[cls])
            throw `\u3059\u3067\u306B\u5B9A\u7FA9\u6E08\u307F\u306E\u30EC\u30A4\u30E4cls\u3010${cls}\u3011\u3067\u3059`;
          this.hFactoryCls[cls] = fnc;
        },
        searchPath: (fn, extptn = "") => this.cfg.searchPath(fn, extptn),
        getVal: val.getVal,
        resume: () => main2.resume(),
        render: (dsp, renderTexture, clear = false) => this.appPixi.renderer.render(dsp, { renderTexture, clear }),
        setDec: (fnc) => __privateSet$6(this, _preFromPlg, fnc),
        setEnc: (fnc) => this.enc = fnc,
        getStK: (fnc) => this.stk = fnc,
        getHash: (fnc) => this.hash = fnc
      }));
    return a2;
  }
  get cvsWidth() {
    return __privateGet$6(this, _cvsWidth);
  }
  get cvsHeight() {
    return __privateGet$6(this, _cvsHeight);
  }
  get cvsScale() {
    return __privateGet$6(this, _cvsScale);
  }
  get ofsLeft4elm() {
    return __privateGet$6(this, _ofsLeft4elm);
  }
  get ofsTop4elm() {
    return __privateGet$6(this, _ofsTop4elm);
  }
  get ofsPadLeft_Dom2PIXI() {
    return __privateGet$6(this, _ofsPadLeft_Dom2PIXI);
  }
  get ofsPadTop_Dom2PIXI() {
    return __privateGet$6(this, _ofsPadTop_Dom2PIXI);
  }
  cvsResize() {
    var _a3, _b3;
    let w2 = globalThis.innerWidth;
    let h2 = globalThis.innerHeight;
    const cvs = this.appPixi.view;
    const isGallery = cvs.parentElement !== document.body;
    if (isGallery) {
      const st = globalThis.getComputedStyle(cvs);
      w2 = parseFloat(st.width);
      h2 = parseFloat(st.height);
    }
    if (CmnLib.isMobile) {
      const angle = (_b3 = (_a3 = screen.orientation) == null ? void 0 : _a3.angle) != null ? _b3 : 0;
      const isP = angle % 180 === 0;
      if (isP && w2 > h2 || !isP && w2 < h2)
        [w2, h2] = [h2, w2];
    }
    const cr = cvs.getBoundingClientRect();
    if (argChk_Boolean(CmnLib.hDip, "expanding", true) || isGallery || CmnLib.stageW > w2 || CmnLib.stageH > h2) {
      if (CmnLib.stageW / CmnLib.stageH <= w2 / h2) {
        __privateSet$6(this, _cvsHeight, h2);
        __privateSet$6(this, _cvsWidth, CmnLib.stageW / CmnLib.stageH * h2);
      } else {
        __privateSet$6(this, _cvsWidth, w2);
        __privateSet$6(this, _cvsHeight, CmnLib.stageH / CmnLib.stageW * w2);
      }
      __privateSet$6(this, _cvsScale, __privateGet$6(this, _cvsWidth) / CmnLib.stageW);
      if (isGallery) {
        __privateSet$6(this, _ofsPadLeft_Dom2PIXI, 0);
        __privateSet$6(this, _ofsPadTop_Dom2PIXI, 0);
      } else {
        const sc = 1 - __privateGet$6(this, _cvsScale);
        if (CmnLib.isMobile) {
          __privateSet$6(this, _ofsPadLeft_Dom2PIXI, (w2 - __privateGet$6(this, _cvsWidth)) / 2 * sc);
          __privateSet$6(this, _ofsPadTop_Dom2PIXI, (h2 - __privateGet$6(this, _cvsHeight)) / 2 * sc);
        } else {
          __privateSet$6(this, _ofsPadLeft_Dom2PIXI, cr.left * sc);
          __privateSet$6(this, _ofsPadTop_Dom2PIXI, cr.top * sc);
        }
      }
    } else {
      __privateSet$6(this, _cvsWidth, CmnLib.stageW);
      __privateSet$6(this, _cvsHeight, CmnLib.stageH);
      __privateSet$6(this, _cvsScale, 1);
      __privateSet$6(this, _ofsPadLeft_Dom2PIXI, 0);
      __privateSet$6(this, _ofsPadTop_Dom2PIXI, 0);
    }
    const ps = cvs.parentElement.style;
    if (!isGallery) {
      ps.position = "relative";
      ps.width = `${__privateGet$6(this, _cvsWidth)}px`;
      ps.height = `${__privateGet$6(this, _cvsHeight)}px`;
    }
    const s2 = cvs.style;
    s2.width = ps.width;
    s2.height = ps.height;
    __privateSet$6(this, _ofsLeft4elm, cr.left);
    __privateSet$6(this, _ofsTop4elm, cr.top);
    if (this.isFullScr) {
      __privateSet$6(this, _ofsLeft4elm, __privateGet$6(this, _ofsLeft4elm) + (w2 - __privateGet$6(this, _cvsWidth)) / 2);
      __privateSet$6(this, _ofsTop4elm, __privateGet$6(this, _ofsTop4elm) + (h2 - __privateGet$6(this, _cvsHeight)) / 2);
    }
  }
  attach_debug(main2) {
    this.attach_debug = () => {
    };
    const gs = document.createElement("style");
    gs.innerHTML = `/* SKYNovel Dbg */
.sn_BounceInOut { animation: sn_kfBounceInOut linear 1.5s; }
@keyframes sn_kfBounceInOut{
0%	{opacity: 0;	transform: scaleX(0.30) scaleY(0.30);}
10%	{opacity: 1;	transform: scaleX(1.10) scaleY(1.10);}
20%	{				transform: scaleX(0.95) scaleY(0.95);}
30%	{				transform: scaleX(1.00) scaleY(1.00);}
70%	{opacity: 1;}
100%{opacity: 0;}
}
.sn_BounceIn { animation: sn_kfBounceIn linear 0.3s; }
@keyframes sn_kfBounceIn{
0%	{opacity: 0;	transform: scaleX(0.30) scaleY(0.30);}
50%	{opacity: 1;	transform: scaleX(1.10) scaleY(1.10);}
100%{				transform: scaleX(0.95) scaleY(0.95);}
}
.sn_HopIn { animation: sn_kfHopIn linear 0.8s; }
@keyframes sn_kfHopIn{
0%	{transform:	translate(0px,   0px);}
15% {transform:	translate(0px, -25px);}
30% {transform:	translate(0px,   0px);}
45% {transform:	translate(0px, -15px);}
60% {transform:	translate(0px,   0px);}
75% {transform:	translate(0px,  -5px);}
100%{transform:	translate(0px,   0px);}
}`;
    document.getElementsByTagName("head")[0].appendChild(gs);
    this.addHook((type, o) => {
      var _a3, _b3;
      return (_b3 = (_a3 = __privateGet$6(this, _hHook))[type]) == null ? void 0 : _b3.call(_a3, o);
    });
    __privateSet$6(this, _sk, lookup(`http://localhost:${this.extPort}`));
    __privateGet$6(this, _sk).on("data", (type, o) => {
      this.callHook(type, o);
    }).on("disconnect", () => main2.setLoop(true));
    this.callHook = (type, o) => __privateGet$6(this, _aFncHook).forEach((fnc) => fnc(type, o));
  }
  end() {
    var _a3;
    (_a3 = __privateGet$6(this, _sk)) == null ? void 0 : _a3.disconnect();
    __privateSet$6(this, _sk, void 0);
  }
  toast(nm) {
    var _a3, _b3, _c3;
    const p2 = document.body;
    p2.querySelectorAll(".sn_BounceIn, .sn_HopIn").forEach((v2) => p2.removeChild(v2));
    const img = document.createElement("img");
    const td = __privateGet$6(_SysBase, _hToastDat)[nm];
    img.src = `data:image/svg+xml;base64,${td.dat}`;
    const size = Math.min(CmnLib.stageW, CmnLib.stageH) / 4 * __privateGet$6(this, _cvsScale);
    img.width = img.height = size;
    img.style.cssText = `position: absolute;
left: ${(CmnLib.stageW - size) / 2 * __privateGet$6(this, _cvsScale) + size * ((_a3 = td.dx) != null ? _a3 : 0)}px;
top: ${(CmnLib.stageH - size) / 2 * __privateGet$6(this, _cvsScale) + size * ((_b3 = td.dy) != null ? _b3 : 0)}px;`;
    img.classList.add("sn_toast", (_c3 = td.ease) != null ? _c3 : "sn_BounceInOut");
    if (!td.ease)
      img.addEventListener("animationend", () => p2.removeChild(img), { once: true, passive: true });
    p2.insertBefore(img, this.appPixi.view);
  }
  setFire(fire) {
    this.fire = fire;
  }
  addHook(fnc) {
    __privateGet$6(this, _aFncHook).push(fnc);
  }
  titleSub(_txt) {
  }
  tglFlscr_sub() {
  }
  setTitleInfo(txt) {
    __privateSet$6(this, _info_title, txt);
    this.titleSub(__privateGet$6(this, _main_title) + __privateGet$6(this, _info_title));
  }
  decStr(ext, d2) {
    return __privateGet$6(this, _preFromPlg).call(this, ext, d2).ret;
  }
  async dec(ext, d2) {
    const { ret, ext_num } = __privateGet$6(this, _preFromPlg).call(this, ext, d2);
    const fm = __privateGet$6(this, _hN2Ext)[ext_num];
    return (fm == null ? void 0 : fm.fnc) ? await fm.fnc(new Blob([ret], { type: fm.mime })) : ret;
  }
  get path_downloads() {
    return this.$path_downloads;
  }
  get path_userdata() {
    return this.$path_userdata;
  }
  async savePic(_fn, _data_url) {
  }
  async appendFile(_path, _data2, _callback) {
  }
  async ensureFileSync(_path) {
  }
};
let SysBase = _SysBase;
_cvsWidth = /* @__PURE__ */ new WeakMap();
_cvsHeight = /* @__PURE__ */ new WeakMap();
_cvsScale = /* @__PURE__ */ new WeakMap();
_ofsLeft4elm = /* @__PURE__ */ new WeakMap();
_ofsTop4elm = /* @__PURE__ */ new WeakMap();
_ofsPadLeft_Dom2PIXI = /* @__PURE__ */ new WeakMap();
_ofsPadTop_Dom2PIXI = /* @__PURE__ */ new WeakMap();
_sk = /* @__PURE__ */ new WeakMap();
_hHook = /* @__PURE__ */ new WeakMap();
_hToastDat = /* @__PURE__ */ new WeakMap();
_aFncHook = /* @__PURE__ */ new WeakMap();
_main_title = /* @__PURE__ */ new WeakMap();
_tglFlscr = /* @__PURE__ */ new WeakMap();
_info_title = /* @__PURE__ */ new WeakMap();
_preFromPlg = /* @__PURE__ */ new WeakMap();
_hN2Ext = /* @__PURE__ */ new WeakMap();
_genImage = /* @__PURE__ */ new WeakMap();
_genVideo = /* @__PURE__ */ new WeakMap();
SysBase.VALNM_CFG_NS = "const.sn.cfg.ns";
__privateAdd$6(SysBase, _hToastDat, {
  "\u63A5\u7D9A": { dx: -1, dat: "PHN2ZyBoZWlnaHQ9IjY0MCIgcHJlc2VydmVBc3BlY3RSYXRpbz0ieE1pZFlNaWQgbWVldCIgdmlld0JveD0iMCAwIDY0MCA2NDAiIHdpZHRoPSI2NDAiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiPjxkZWZzPjxwYXRoIGlkPSJhIiBkPSJtNjQwIDMyMGMwIDE3Ni43My0xNDMuMjcgMzIwLTMyMCAzMjBzLTMyMC0xNDMuMjctMzIwLTMyMCAxNDMuMjctMzIwIDMyMC0zMjAgMzIwIDE0My4yNyAzMjAgMzIweiIvPjxwYXRoIGlkPSJiIiBkPSJtMCAyOTJ2NTUuODhoMTI3LjEzYzEyLjM3IDQ2IDU0LjEyIDc5Ljg3IDEwNCA3OS44N2g3Ny44N3YtMjE1LjYyYy00Ni43MyAwLTcyLjY4IDAtNzcuODggMC00OS43NCAwLTkxLjYyIDMzLjg3LTEwMy45OSA3OS44Ny0xNi45NSAwLTU5LjMzIDAtMTI3LjEzIDB6Ii8+PHBhdGggaWQ9ImMiIGQ9Im01MTIuODggMjkyYy0xMi4zOC00Ni01NC4xMy03OS44Ny0xMDQtNzkuODctNS4yMSAwLTMxLjIxIDAtNzggMHYyMTUuNzRoNzcuODdjNDkuODggMCA5MS43NS0zMy44NyAxMDQtNzkuODdoMTI3LjI1di01NmMtNzYuMjcgMC0xMTguNjUgMC0xMjcuMTIgMHoiLz48L2RlZnM+PHVzZSBmaWxsPSIjMmUyZTJlIiB4bGluazpocmVmPSIjYSIvPjx1c2UgZmlsbD0ibm9uZSIgeGxpbms6aHJlZj0iI2EiLz48dXNlIGZpbGw9IiMzYWFiZDIiIHhsaW5rOmhyZWY9IiNiIi8+PHVzZSBmaWxsPSJub25lIiB4bGluazpocmVmPSIjYiIvPjx1c2UgZmlsbD0iIzNhYWJkMiIgeGxpbms6aHJlZj0iI2MiLz48dXNlIGZpbGw9Im5vbmUiIHhsaW5rOmhyZWY9IiNjIi8+PC9zdmc+" },
  "\u5207\u65AD": { dat: "PHN2ZyBoZWlnaHQ9IjY0MCIgcHJlc2VydmVBc3BlY3RSYXRpbz0ieE1pZFlNaWQgbWVldCIgdmlld0JveD0iMCAwIDY0MCA2NDAiIHdpZHRoPSI2NDAiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiPjxkZWZzPjxwYXRoIGlkPSJhIiBkPSJtNjQwIDMyMGMwIDE3Ni43My0xNDMuMjcgMzIwLTMyMCAzMjBzLTMyMC0xNDMuMjctMzIwLTMyMCAxNDMuMjctMzIwIDMyMC0zMjAgMzIwIDE0My4yNyAzMjAgMzIweiIvPjxwYXRoIGlkPSJiIiBkPSJtMTkxLjUzIDIyMS4yNGMtNDUuNjggMC04NC4wMSAzMS4wNC05NS4zIDczLjE2LTYuNDEgMC0zOC40OSAwLTk2LjIzIDB2NTEuMjFoOTYuMjNjMTEuMyA0Mi4xMSA0OS42MyA3My4xNiA5NS4zIDczLjE2aDcxLjMzdi00OC4yNGg1My43OHYtMTAxLjA1aC01My43OHYtNDguMjRjLTQyLjggMC02Ni41NyAwLTcxLjMzIDB6Ii8+PHBhdGggaWQ9ImMiIGQ9Im00NDguNDcgMjIxLjIzYy00Ljc2IDAtMjguNTMgMC03MS4zMyAwdjE5Ny41M2g3MS4zM2M0NS42OCAwIDgzLjk5LTMxLjA0IDk1LjI5LTczLjE1aDk2LjI0di01MS4yMWgtOTYuMjRjLTMzLjA4LTQ4Ljc4LTY0Ljg0LTczLjE3LTk1LjI5LTczLjE3eiIvPjwvZGVmcz48dXNlIGZpbGw9IiMyZTJlMmUiIHhsaW5rOmhyZWY9IiNhIi8+PHVzZSBmaWxsPSJub25lIiB4bGluazpocmVmPSIjYSIvPjx1c2UgZmlsbD0iI2RmNTY1NiIgeGxpbms6aHJlZj0iI2IiLz48dXNlIGZpbGw9Im5vbmUiIHhsaW5rOmhyZWY9IiNiIi8+PHVzZSBmaWxsPSIjZGY1NjU2IiB4bGluazpocmVmPSIjYyIvPjx1c2UgZmlsbD0ibm9uZSIgeGxpbms6aHJlZj0iI2MiLz48L3N2Zz4=" },
  "\u518D\u751F": { dat: "PHN2ZyBoZWlnaHQ9IjY0MCIgcHJlc2VydmVBc3BlY3RSYXRpbz0ieE1pZFlNaWQgbWVldCIgdmlld0JveD0iMCAwIDY0MCA2NDAiIHdpZHRoPSI2NDAiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiPjxkZWZzPjxwYXRoIGlkPSJhIiBkPSJtMCAzMjBjMCAxNzYuNzIgMTQzLjI4IDMyMCAzMjAgMzIwczMyMC0xNDMuMjggMzIwLTMyMC0xNDMuMjgtMzIwLTMyMC0zMjAtMzIwIDE0My4yOC0zMjAgMzIwem0yNTguODMgMTExLjA1Yy0xLjI5Ljc5LTIuOTMuODMtNC4yNi4wNC0xLjI5LS43NC0yLjExLTIuMTItMi4xMS0zLjY3IDAtNy4xNiAwLTQyLjk3IDAtMTA3LjQzczAtMTAwLjI3IDAtMTA3LjQzYzAtMS41My44Mi0yLjkzIDIuMTEtMy42OCAxLjMzLS43NiAyLjk3LS43MiA0LjI2LjA0IDE4IDEwLjc1IDE2MiA5Ni43MSAxODAgMTA3LjQ2IDEuMjkuNzMgMi4wNSAyLjE0IDIuMDUgMy42MSAwIDEuNDktLjc2IDIuODgtMi4wNSAzLjYzLTM2IDIxLjQ5LTE2MiA5Ni42OS0xODAgMTA3LjQzeiIvPjwvZGVmcz48cGF0aCBkPSJtMTU0LjU3IDE3MC4xOWgzNDYuMTV2MzA3LjY5aC0zNDYuMTV6IiBmaWxsPSIjZmZmIi8+PHVzZSBmaWxsPSIjMmUyZTJlIiB4bGluazpocmVmPSIjYSIvPjx1c2UgZmlsbD0ibm9uZSIgeGxpbms6aHJlZj0iI2EiLz48L3N2Zz4=" },
  "\u4E00\u6642\u505C\u6B62": { dat: "PHN2ZyBoZWlnaHQ9IjY0MCIgcHJlc2VydmVBc3BlY3RSYXRpbz0ieE1pZFlNaWQgbWVldCIgdmlld0JveD0iMCAwIDY0MCA2NDAiIHdpZHRoPSI2NDAiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiPjxkZWZzPjxwYXRoIGlkPSJhIiBkPSJtMCAzMjBjMCAxNzYuNzIgMTQzLjI4IDMyMCAzMjAgMzIwczMyMC0xNDMuMjggMzIwLTMyMC0xNDMuMjgtMzIwLTMyMC0zMjAtMzIwIDE0My4yOC0zMjAgMzIwem0yMDAgMTAwdi0yMDBoODB2MjAwem0xNjAgMHYtMjAwaDgwdjIwMHoiLz48L2RlZnM+PHBhdGggZD0ibTE0Ny40OSAxODAuNDFoMzUyLjR2MjgyLjY5aC0zNTIuNHoiIGZpbGw9IiNmZmYiLz48dXNlIGZpbGw9IiMyZTJlMmUiIHhsaW5rOmhyZWY9IiNhIi8+PHVzZSBmaWxsPSJub25lIiB4bGluazpocmVmPSIjYSIvPjwvc3ZnPg==" },
  "\u6CE8\u610F": { ease: "sn_HopIn", dat: "PHN2ZyBoZWlnaHQ9IjY0MCIgcHJlc2VydmVBc3BlY3RSYXRpbz0ieE1pZFlNaWQgbWVldCIgdmlld0JveD0iMCAwIDY0MCA2NDAiIHdpZHRoPSI2NDAiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiPjxkZWZzPjxwYXRoIGlkPSJhIiBkPSJtMzQzLjM0IDI5LjJjLTEwLjM3LTE3Ljk3LTM2LjMxLTE3Ljk3LTQ2LjY5IDAtMjkuMyA1MC43NS0yNjMuNyA0NTYuNzQtMjkzIDUwNy40OS0xMC4zNyAxNy45NyAyLjU5IDQwLjQ0IDIzLjM0IDQwLjQ0aDU4Ni4wMWMyMC43NSAwIDMzLjcyLTIyLjQ2IDIzLjM1LTQwLjQ0LTU4LjYtMTAxLjUtMjYzLjctNDU2Ljc0LTI5My4wMS01MDcuNDl6bS0yMy4zNCA0ODIuODNjLTE0LjUyIDAtMjYuMjktMi43MS0yNi4yOS02LjA2IDAtNC4yMSAwLTM3Ljg2IDAtNDIuMDcgMC0zLjM1IDExLjc3LTYuMDcgMjYuMjktNi4wN3MyNi4yOSAyLjcyIDI2LjI5IDYuMDd2NDIuMDdjLTcuODQgNC4wNC0xNi42MSA2LjA2LTI2LjI5IDYuMDZ6bTIxLjk5LTEwMy44NGMwIDUuNDMtOS44NSA5LjgzLTIxLjk5IDkuODMtMTIuMTUgMC0yMS45OS00LjQtMjEuOTktOS44MyAwLS4xMy4wNy0uMjUuMDgtLjM4LTEuMzctMTcuNTYtMTIuMy0xNTguMDYtMTMuNjctMTc1LjYyIDAtNS40MyAxNS45My05Ljg0IDM1LjU4LTkuODRzMzUuNTggNC40MSAzNS41OCA5Ljg0Yy0uOTEgMTEuNy01LjQ3IDcwLjI1LTEzLjY3IDE3NS42Mi4wNi4xNi4wOC4yOS4wOC4zOHoiLz48L2RlZnM+PHBhdGggZD0ibTI0MS4yOSAxOTEuNDRoMTQ1LjQ5djM1MS42NmgtMTQ1LjQ5eiIgZmlsbD0iI2ZmZiIvPjx1c2UgZmlsbD0iI2QyYmYzYSIgeGxpbms6aHJlZj0iI2EiLz48dXNlIGZpbGw9Im5vbmUiIHhsaW5rOmhyZWY9IiNhIi8+PC9zdmc+" },
  "\u4E00\u6B69\u9032\u3080": { ease: "sn_BounceIn", dat: "PHN2ZyBoZWlnaHQ9IjY0MCIgcHJlc2VydmVBc3BlY3RSYXRpbz0ieE1pZFlNaWQgbWVldCIgdmlld0JveD0iMCAwIDY0MCA2NDAiIHdpZHRoPSI2NDAiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiPjxkZWZzPjxwYXRoIGlkPSJhIiBkPSJtMCAzMjBjMCAxNzYuNzIgMTQzLjI4IDMyMCAzMjAgMzIwczMyMC0xNDMuMjggMzIwLTMyMC0xNDMuMjgtMzIwLTMyMC0zMjAtMzIwIDE0My4yOC0zMjAgMzIwem0zNzYuOTMgOTEuOTdjMC01My41MSAwLTgzLjI0IDAtODkuMTktLjE1LjE0LS4yNS4zNC0uNDQuNDUtMTYuMTEgOS42Mi0xNDQuOTUgODYuNTQtMTYxLjA2IDk2LjE1LTEuMTUuNjktMi42Mi43My0zLjgxLjAyLTEuMTUtLjY0LTEuODktMS44OS0xLjg5LTMuMjggMC02LjQxIDAtMzguNDQgMC05Ni4xMSAwLTU3LjY5IDAtODkuNzQgMC05Ni4xNSAwLTEuMzUuNzQtMi42MiAxLjg5LTMuMjkgMS4xOS0uNjggMi42Ni0uNjQgMy44MS4wNCAxNi4xMSA5LjYyIDE0NC45NSA4Ni41NCAxNjEuMDYgOTYuMTYuMTkuMS4yOS4zMS40NC40NSAwLTYuMTMgMC0zNi43NyAwLTkxLjkyaDUzLjMydjE4Ni42N3oiLz48L2RlZnM+PHBhdGggZD0ibTE0Ny40OSAxNTQuMmgzNTIuNHYzMDguOWgtMzUyLjR6IiBmaWxsPSIjZmZmIi8+PHVzZSBmaWxsPSIjMmUyZTJlIiB4bGluazpocmVmPSIjYSIvPjx1c2UgZmlsbD0ibm9uZSIgeGxpbms6aHJlZj0iI2EiLz48L3N2Zz4=" },
  "\u4E00\u6B69\u623B\u308B": { ease: "sn_BounceIn", dat: "PHN2ZyBoZWlnaHQ9IjY0MCIgcHJlc2VydmVBc3BlY3RSYXRpbz0ieE1pZFlNaWQgbWVldCIgdmlld0JveD0iMCAwIDY0MCA2NDAiIHdpZHRoPSI2NDAiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiPjxkZWZzPjxwYXRoIGlkPSJhIiBkPSJtMCAzMjBjMCAxNzYuNzIgMTQzLjI4IDMyMCAzMjAgMzIwczMyMC0xNDMuMjggMzIwLTMyMC0xNDMuMjgtMzIwLTMyMC0zMjAtMzIwIDE0My4yOC0zMjAgMzIwem00MzAuMjcgOTYuMTRjMCAxLjM1LS43NCAyLjYyLTEuODkgMy4yOC0xLjE5LjY5LTIuNjYuNjUtMy44MS0uMDMtMTYuMTEtOS42Mi0xNDQuOTUtODYuNTQtMTYxLjA1LTk2LjE2LS4yLS4xLS4yOS0uMzEtLjQ1LS40NXY5MS45MmgtNTMuMzJ2LTE4Ni42N2g1My4zMnY4OS4xOWMuMTYtLjE0LjI1LS4zNC40NS0uNDUgMTYuMS05LjYyIDE0NC45NC04Ni41NCAxNjEuMDUtOTYuMTYgMS4xNS0uNjggMi42Mi0uNzIgMy44MS0uMDEgMS4xNS42NCAxLjg5IDEuODkgMS44OSAzLjI4djk2LjExeiIvPjwvZGVmcz48cGF0aCBkPSJtMTQ3LjQ5IDE1NC4yaDM1Mi40djMwOC45aC0zNTIuNHoiIGZpbGw9IiNmZmYiLz48dXNlIGZpbGw9IiMyZTJlMmUiIHhsaW5rOmhyZWY9IiNhIi8+PHVzZSBmaWxsPSJub25lIiB4bGluazpocmVmPSIjYSIvPjwvc3ZnPg==" },
  "\u30B9\u30C6\u30C3\u30D5\u309A\u30A4\u30F3": { ease: "sn_BounceIn", dat: "PHN2ZyBoZWlnaHQ9IjY0MCIgcHJlc2VydmVBc3BlY3RSYXRpbz0ieE1pZFlNaWQgbWVldCIgdmlld0JveD0iMCAwIDY0MCA2NDAiIHdpZHRoPSI2NDAiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiPjxkZWZzPjxwYXRoIGlkPSJhIiBkPSJtMCAzMTkuOTljMCAxNzYuNzQgMTQzLjI3IDMyMC4wMSAzMjAuMDEgMzIwLjAxIDE3Ni43MiAwIDMxOS45OS0xNDMuMjcgMzE5Ljk5LTMyMC4wMSAwLTE3Ni43Mi0xNDMuMjctMzE5Ljk5LTMxOS45OS0zMTkuOTktMTc2Ljc0IDAtMzIwLjAxIDE0My4yNy0zMjAuMDEgMzE5Ljk5em0xNTMuMDUtMjkuNzIgNTUuMTItNTUuMTMgMTExLjg0IDExMS44MiAxMTEuODItMTExLjgyIDU1LjEyIDU1LjEyLTE2Ni45NCAxNjYuOTd6Ii8+PC9kZWZzPjxwYXRoIGQ9Im0xNDcuNDkgMTU0LjJoMzUyLjR2MzA4LjloLTM1Mi40eiIgZmlsbD0iI2ZmZiIvPjx1c2UgZmlsbD0iIzJlMmUyZSIgeGxpbms6aHJlZj0iI2EiLz48dXNlIGZpbGw9Im5vbmUiIHhsaW5rOmhyZWY9IiNhIi8+PC9zdmc+" },
  "\u30B9\u30C6\u30C3\u30D5\u309A\u30A2\u30A6\u30C8": { ease: "sn_BounceIn", dat: "PHN2ZyBoZWlnaHQ9IjY0MCIgcHJlc2VydmVBc3BlY3RSYXRpbz0ieE1pZFlNaWQgbWVldCIgdmlld0JveD0iMCAwIDY0MCA2NDAiIHdpZHRoPSI2NDAiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiPjxkZWZzPjxwYXRoIGlkPSJhIiBkPSJtMCAzMjAuMDFjMCAxNzYuNzIgMTQzLjI3IDMxOS45OSAzMTkuOTkgMzE5Ljk5IDE3Ni43NCAwIDMyMC4wMS0xNDMuMjcgMzIwLjAxLTMxOS45OSAwLTE3Ni43NC0xNDMuMjctMzIwLjAxLTMyMC4wMS0zMjAuMDEtMTc2LjcyIDAtMzE5Ljk5IDE0My4yNy0zMTkuOTkgMzIwLjAxem0zMTkuOTktMjYuOTgtMTExLjgyIDExMS44My01NS4xMi01NS4xMyAxNjYuOTQtMTY2Ljk2IDE2Ni45NiAxNjYuOTYtNTUuMTIgNTUuMTN6Ii8+PC9kZWZzPjxwYXRoIGQ9Im0xNDcuNDkgMTU0LjJoMzUyLjR2MzA4LjloLTM1Mi40eiIgZmlsbD0iI2ZmZiIvPjx1c2UgZmlsbD0iIzJlMmUyZSIgeGxpbms6aHJlZj0iI2EiLz48dXNlIGZpbGw9Im5vbmUiIHhsaW5rOmhyZWY9IiNhIi8+PC9zdmc+" }
});
var __accessCheck$5 = (obj, member, msg) => {
  if (!member.has(obj))
    throw TypeError("Cannot " + msg);
};
var __privateGet$5 = (obj, member, getter) => {
  __accessCheck$5(obj, member, "read from private field");
  return getter ? getter.call(obj) : member.get(obj);
};
var __privateAdd$5 = (obj, member, value) => {
  if (member.has(obj))
    throw TypeError("Cannot add the same private member more than once");
  member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
};
var __privateSet$5 = (obj, member, value, setter) => {
  __accessCheck$5(obj, member, "write to private field");
  setter ? setter.call(obj, value) : member.set(obj, value);
  return value;
};
var _existsBreakline, _existsBreakpage, _REG_PATH;
const _Config = class {
  constructor(sys) {
    this.sys = sys;
    this.oCfg = {
      save_ns: "",
      window: {
        width: 300,
        height: 300
      },
      book: {
        title: "",
        creator: "",
        cre_url: "",
        publisher: "",
        pub_url: "",
        detail: "",
        version: "1.0"
      },
      log: { max_len: 1024 },
      init: {
        bg_color: "#000000",
        tagch_msecwait: 10,
        auto_msecpagewait: 3500,
        escape: ""
      },
      debug: {
        devtool: false,
        token: false,
        tag: false,
        putCh: false,
        debugLog: false,
        baseTx: false,
        masume: false,
        variable: false
      },
      code: {},
      debuger_token: ""
    };
    this.userFnTail = "";
    this.hPathFn2Exts = {};
    __privateAdd$5(this, _existsBreakline, false);
    __privateAdd$5(this, _existsBreakpage, false);
    __privateAdd$5(this, _REG_PATH, /([^\/\s]+)\.([^\d]\w+)/);
  }
  static async generate(sys) {
    const c2 = new _Config(sys);
    const fn = sys.cur + "prj.json";
    const src = await (await sys.fetch(fn)).text();
    const oJs = JSON.parse(sys.decStr(fn, src));
    await c2.load(oJs);
    return c2;
  }
  async load(oCfg) {
    var _a3, _b3, _c3, _d2, _e, _f, _g, _h;
    this.oCfg.save_ns = (_a3 = oCfg == null ? void 0 : oCfg.save_ns) != null ? _a3 : this.oCfg.save_ns;
    CmnLib.stageW = this.oCfg.window.width = Number((_c3 = (_b3 = oCfg == null ? void 0 : oCfg.window) == null ? void 0 : _b3.width) != null ? _c3 : this.oCfg.window.width);
    CmnLib.stageH = this.oCfg.window.height = Number((_e = (_d2 = oCfg == null ? void 0 : oCfg.window) == null ? void 0 : _d2.height) != null ? _e : this.oCfg.window.height);
    this.oCfg.book = __spreadValues(__spreadValues({}, this.oCfg.book), oCfg.book);
    this.oCfg.log.max_len = (_h = (_g = (_f = oCfg.log) == null ? void 0 : _f.max_len) == null ? void 0 : _g.max_len) != null ? _h : this.oCfg.log.max_len;
    this.oCfg.init = __spreadValues(__spreadValues({}, this.oCfg.init), oCfg.init);
    this.oCfg.debug = __spreadValues(__spreadValues({}, this.oCfg.debug), oCfg.debug);
    CmnLib.debugLog = this.oCfg.debug.debugLog;
    this.oCfg.debuger_token = oCfg.debuger_token;
    await this.sys.loadPath(this.hPathFn2Exts, this);
    __privateSet$5(this, _existsBreakline, this.matchPath("^breakline$", _Config.EXT_SPRITE).length > 0);
    __privateSet$5(this, _existsBreakpage, this.matchPath("^breakpage$", _Config.EXT_SPRITE).length > 0);
    if (this.sys.crypto)
      for (const nm in this.hPathFn2Exts) {
        const o = this.hPathFn2Exts[nm];
        for (const ext in o) {
          if (ext.slice(-10) !== ":RIPEMD160")
            continue;
          const hp = o[ext].slice(o[ext].lastIndexOf("/") + 1);
          const fn = o[ext.slice(0, -10)];
          const res = await this.sys.fetch(fn);
          const src = await res.text();
          const hf = this.sys.hash(src);
          if (hp !== hf)
            throw `\u30D5\u30A1\u30A4\u30EB\u6539\u7AC4\u30A8\u30E9\u30FC\u3067\u3059 fn:${fn}`;
        }
      }
  }
  get existsBreakline() {
    return __privateGet$5(this, _existsBreakline);
  }
  get existsBreakpage() {
    return __privateGet$5(this, _existsBreakpage);
  }
  getNs() {
    return `skynovel.${this.oCfg.save_ns} - `;
  }
  searchPath(path, extptn = "") {
    if (!path)
      throw "[searchPath] fn\u304C\u7A7A\u3067\u3059";
    if (path.slice(0, 7) === "http://")
      return path;
    if (path.slice(0, 11) === "downloads:/") {
      const fp = this.sys.path_downloads + path.slice(11);
      this.sys.ensureFileSync(fp);
      return fp;
    }
    if (path.slice(0, 10) === "userdata:/") {
      const fp = this.sys.path_userdata + "storage/" + path.slice(10);
      this.sys.ensureFileSync(fp);
      return fp;
    }
    __privateGet$5(this, _REG_PATH).lastIndex = 0;
    const a2 = path.match(__privateGet$5(this, _REG_PATH));
    let fn = a2 ? a2[1] : path;
    const ext = a2 ? a2[2] : "";
    if (this.userFnTail) {
      const utn = fn + "@@" + this.userFnTail;
      if (utn in this.hPathFn2Exts) {
        if (extptn === "")
          fn = utn;
        else
          for (let e3 in this.hPathFn2Exts[utn]) {
            if (`|${extptn}|`.indexOf(`|${e3}|`) === -1)
              continue;
            fn = utn;
            break;
          }
      }
    }
    const h_exts = this.hPathFn2Exts[fn];
    if (!h_exts)
      throw `\u30B5\u30FC\u30C1\u30D1\u30B9\u306B\u5B58\u5728\u3057\u306A\u3044\u30D5\u30A1\u30A4\u30EB\u3010${path}\u3011\u3067\u3059`;
    let ret = "";
    if (!ext) {
      const hcnt = int(h_exts[":cnt"]);
      if (extptn === "") {
        if (hcnt > 1)
          throw `\u6307\u5B9A\u30D5\u30A1\u30A4\u30EB\u3010${path}\u3011\u304C\u8907\u6570\u30DE\u30C3\u30C1\u3057\u307E\u3059\u3002\u30B5\u30FC\u30C1\u5BFE\u8C61\u62E1\u5F35\u5B50\u7FA4\u3010${extptn}\u3011\u3067\u7D5E\u308A\u8FBC\u3080\u304B\u3001\u30D5\u30A1\u30A4\u30EB\u540D\u3092\u500B\u5225\u306B\u3057\u3066\u4E0B\u3055\u3044\u3002`;
        return path;
      }
      const search_exts = `|${extptn}|`;
      if (hcnt > 1) {
        let cnt = 0;
        for (const e2 in h_exts) {
          if (search_exts.indexOf(`|${e2}|`) === -1)
            continue;
          if (++cnt > 1)
            throw `\u6307\u5B9A\u30D5\u30A1\u30A4\u30EB\u3010${path}\u3011\u304C\u8907\u6570\u30DE\u30C3\u30C1\u3057\u307E\u3059\u3002\u30B5\u30FC\u30C1\u5BFE\u8C61\u62E1\u5F35\u5B50\u7FA4\u3010${extptn}\u3011\u3067\u7D5E\u308A\u8FBC\u3080\u304B\u3001\u30D5\u30A1\u30A4\u30EB\u540D\u3092\u500B\u5225\u306B\u3057\u3066\u4E0B\u3055\u3044\u3002`;
        }
      }
      for (let e in h_exts) {
        if (search_exts.indexOf(`|${e}|`) > -1)
          return h_exts[e];
      }
      throw `\u30B5\u30FC\u30C1\u5BFE\u8C61\u62E1\u5F35\u5B50\u7FA4\u3010${extptn}\u3011\u306B\u30DE\u30C3\u30C1\u3059\u308B\u30D5\u30A1\u30A4\u30EB\u304C\u30B5\u30FC\u30C1\u30D1\u30B9\u306B\u5B58\u5728\u3057\u307E\u305B\u3093\u3002\u63A2\u7D22\u30D5\u30A1\u30A4\u30EB\u540D=\u3010${path}\u3011`;
    }
    if (extptn !== "" && `|${extptn}|`.indexOf(`|${ext}|`) === -1) {
      throw `\u6307\u5B9A\u30D5\u30A1\u30A4\u30EB\u306E\u62E1\u5F35\u5B50\u3010${ext}\u3011\u306F\u3001\u30B5\u30FC\u30C1\u5BFE\u8C61\u62E1\u5F35\u5B50\u7FA4\u3010${extptn}\u3011\u306B\u30DE\u30C3\u30C1\u3057\u307E\u305B\u3093\u3002\u63A2\u7D22\u30D5\u30A1\u30A4\u30EB\u540D=\u3010${path}\u3011`;
    }
    ret = h_exts[ext];
    if (!ret)
      throw `\u30B5\u30FC\u30C1\u30D1\u30B9\u306B\u5B58\u5728\u3057\u306A\u3044\u62E1\u5F35\u5B50\u3010${ext}\u3011\u3067\u3059\u3002\u63A2\u7D22\u30D5\u30A1\u30A4\u30EB\u540D=\u3010${path}\u3011\u3001\u30B5\u30FC\u30C1\u5BFE\u8C61\u62E1\u5F35\u5B50\u7FA4\u3010${extptn}\u3011`;
    return ret;
  }
  matchPath(fnptn, extptn = "") {
    const aRet = [];
    const regPtn = new RegExp(fnptn);
    const regExt = new RegExp(extptn);
    for (let fn in this.hPathFn2Exts) {
      if (fn.search(regPtn) === -1)
        continue;
      const h_exts = this.hPathFn2Exts[fn];
      if (extptn === "") {
        aRet.push(h_exts);
        continue;
      }
      const o = {};
      let isa = false;
      for (const ext in h_exts) {
        if (ext.search(regExt) === -1)
          continue;
        o[ext] = fn;
        isa = true;
      }
      if (isa)
        aRet.push(o);
    }
    return aRet;
  }
  addPath(fn, h_exts) {
    const o = {};
    for (const ext in h_exts) {
      o[ext] = (ext.charAt(0) === ":" ? `` : this.sys.cur) + h_exts[ext];
    }
    this.hPathFn2Exts[fn] = o;
  }
};
let Config = _Config;
_existsBreakline = /* @__PURE__ */ new WeakMap();
_existsBreakpage = /* @__PURE__ */ new WeakMap();
_REG_PATH = /* @__PURE__ */ new WeakMap();
Config.EXT_SPRITE = "png|jpg|jpeg|json|svg|webp|mp4|webm";
Config.EXT_SCRIPT = "sn|ssn";
Config.EXT_FONT = "woff2|woff|otf|ttf";
Config.EXT_SOUND = "mp3|m4a|ogg|aac|flac|wav";
Config.EXT_HTML = "htm|html";
const _RubySpliter = class {
  constructor() {
    __privateAdd2(this, _putCh2, () => {
    });
  }
  static setting(hArg) {
    if (hArg.sesame)
      __privateSet2(_RubySpliter, _sesame, hArg.sesame);
  }
  static getSesame() {
    return __privateGet2(_RubySpliter, _sesame);
  }
  static destroy() {
    __privateSet2(_RubySpliter, _sesame, "\u30FD");
  }
  init(putCh) {
    __privateSet2(this, _putCh2, putCh);
  }
  static setEscape(ce) {
    __privateSet2(_RubySpliter, _REG_RUBY, new RegExp(`${ce ? `(?<ce>\\${ce}\\S)|` : ""}\uFF5C(?<str>[^\u300A\\n]+)\u300A(?<ruby>[^\u300B\\n]+)\u300B|(?:(?<kan>[\u2E80-\u2FDF\u3005\u3007\u303B\u3400-\u9FFF\u8C48-\uFAFF]+[\u3041-\u30FF]*|[^\u3000\uFF5C\u300A\u300B\\n])\u300A(?<kan_ruby>[^\u300B\\n]+)\u300B)|(?<txt>[\uD800-\uDBFF][\uDC00-\uDFFF]|[^\u3000\uFF5C\u300A\u300B]+(?=\uFF5C)|[^\u3000\uFF5C\u300A\u300B]*[\u3041-\u30FF](?=[\u2E80-\u2FDF\u3005\u3007\u303B\u3400-\u9FFF\u8C48-\uFAFF]+\u300A)|.)`, "gs"));
  }
  putTxt(text2) {
    var _a3;
    let e = null;
    while (e = __privateGet2(_RubySpliter, _REG_RUBY).exec(text2)) {
      const g2 = e == null ? void 0 : e.groups;
      if (!g2)
        continue;
      const ruby = g2.ruby;
      if (ruby) {
        this.putTxtRb(g2.str, ruby);
        continue;
      }
      const kan_ruby = g2.kan_ruby;
      if (kan_ruby) {
        this.putTxtRb(g2.kan, kan_ruby);
        continue;
      }
      if (g2.ce) {
        __privateGet2(this, _putCh2).call(this, g2.ce.slice(1), "");
        continue;
      }
      Array.from((_a3 = g2.txt) != null ? _a3 : "").forEach((v2) => __privateGet2(this, _putCh2).call(this, v2, ""));
    }
  }
  putTxtRb(text2, ruby) {
    const a2 = Array.from(text2);
    const len = a2.length;
    if (ruby.charAt(0) === "*" && ruby.length <= 2) {
      const rb_ses = "center\uFF5C" + (ruby === "*" ? __privateGet2(_RubySpliter, _sesame) : ruby.charAt(1));
      for (let i2 = 0; i2 < len; ++i2)
        __privateGet2(this, _putCh2).call(this, a2[i2], rb_ses);
      return;
    }
    if (len === 1 || ruby.indexOf(" ") === -1) {
      __privateGet2(this, _putCh2).call(this, text2, ruby.replaceAll("	", " "));
      return;
    }
    const aR = ruby.split(" ");
    const lenR = aR.length;
    const len_max = lenR > len ? lenR : len;
    for (let i2 = 0; i2 < len_max; ++i2) {
      __privateGet2(this, _putCh2).call(this, i2 < len ? a2[i2] : "", i2 < lenR ? aR[i2].replaceAll("	", " ") : "");
    }
  }
};
let RubySpliter = _RubySpliter;
_sesame = new WeakMap();
_putCh2 = new WeakMap();
_REG_RUBY = new WeakMap();
__privateAdd2(RubySpliter, _sesame, "\u30FD");
__privateAdd2(RubySpliter, _REG_RUBY, void 0);
const REG_TAG = /(?<name>[^\s;\]]+)/;
function tagToken2Name_Args(token) {
  const e = REG_TAG.exec(token.slice(1, -1));
  const g2 = e == null ? void 0 : e.groups;
  if (!g2)
    throw `\u30BF\u30B0\u8A18\u8FF0\u3010${token}\u3011\u7570\u5E38\u3067\u3059(\u30BF\u30B0\u89E3\u6790)`;
  const nm = g2.name;
  return [nm, token.slice(1 + nm.length, -1)];
}
function tagToken2Name(token) {
  const e = REG_TAG.exec(token.slice(1));
  const g2 = e == null ? void 0 : e.groups;
  if (!g2)
    throw `\u30BF\u30B0\u8A18\u8FF0\u3010${token}\u3011\u7570\u5E38\u3067\u3059(\u30BF\u30B0\u89E3\u6790)`;
  return g2.name;
}
function splitAmpersand(token) {
  const equa = token.replaceAll("==", "\uFF1D").replaceAll("!=", "\u2260").split("=");
  const cnt_equa = equa.length;
  if (cnt_equa < 2 || cnt_equa > 3)
    throw "\u300C&\u8A08\u7B97\u300D\u66F8\u5F0F\u3067\u306F\u300C=\u300D\u6307\u5B9A\u304C\u4E00\u3064\u304B\u4E8C\u3064\u5FC5\u8981\u3067\u3059";
  if (equa[1].charAt(0) === "&")
    throw "\u300C&\u8A08\u7B97\u300D\u66F8\u5F0F\u3067\u306F\u300C&\u300D\u6307\u5B9A\u304C\u4E0D\u8981\u3067\u3059";
  return {
    name: equa[0].replaceAll("\uFF1D", "==").replaceAll("\u2260", "!="),
    text: equa[1].replaceAll("\uFF1D", "==").replaceAll("\u2260", "!="),
    cast: cnt_equa === 3 ? equa[2].trim() : void 0
  };
}
class Grammar {
  constructor() {
    __privateAdd2(this, _REG_CANTC2M, void 0);
    __privateAdd2(this, _REGC2M, void 0);
    __privateAdd2(this, _regStrC2M, void 0);
    __privateAdd2(this, _regStrC2M4not, void 0);
    __privateAdd2(this, _hC2M, void 0);
    __privateSet2(this, _REGC2M, new RegExp(""));
    __privateSet2(this, _regStrC2M, "");
    __privateSet2(this, _regStrC2M4not, "");
    this.replaceScr_C2M_And_let_ml = (scr, start_idx = 0) => {
      if (!__privateGet2(this, _hC2M))
        return;
      for (let i2 = scr.len - 1; i2 >= start_idx; --i2) {
        const token = scr.aToken[i2];
        this.REG_TOKEN_NOTXT.lastIndex = 0;
        if (this.REG_TOKEN_NOTXT.test(token.charAt(0)))
          continue;
        const lnum = scr.aLNum[i2];
        const a2 = token.match(__privateGet2(this, _REGC2M));
        if (!a2)
          continue;
        let del = 1;
        for (let j2 = a2.length - 1; j2 >= 0; --j2) {
          let ch = a2[j2];
          const macro = __privateGet2(this, _hC2M)[ch.charAt(0)];
          if (macro) {
            ch = macro + (macro.slice(-1) === "]" ? "" : `'${ch.slice(1, -1)}']`);
          }
          scr.aToken.splice(i2, del, ch);
          scr.aLNum.splice(i2, del, lnum);
          del = 0;
        }
      }
      scr.len = scr.aToken.length;
    };
    this.setEscape("");
  }
  setEscape(ce) {
    if (__privateGet2(this, _hC2M) && ce in __privateGet2(this, _hC2M))
      throw "[\u30A8\u30B9\u30B1\u30FC\u30D7\u6587\u5B57] char\u3010" + ce + "\u3011\u304C\u767B\u9332\u6E08\u307F\u306E\u62EC\u5F27\u30DE\u30AF\u30ED\u307E\u305F\u306F\u4E00\u6587\u5B57\u30DE\u30AF\u30ED\u3067\u3059";
    const ces = ce != null ? ce : "\\";
    this.REG_TOKEN = new RegExp((ce ? `\\${ce}\\S|` : "") + `\\n+|\\t+|\\[let_ml\\s+[^\\]]+\\].+?(?=\\[endlet_ml[\\]\\s])|\\[(?:[^"'#;\\]]+|` + (ces ? `(?:"(?:\\${ces}["'#\\n]|[^"])*"|'(?:\\${ces}["'#\\n]|[^'])*'|\\#(?:\\${ces}["'#\\n]|[^#])*\\#)` : `(["'#]).*?\\1`) + `|;[^\\n]*)*?]|;[^\\n]*|&[^&\\n]+&|&&?[^;\\n\\t&]+|^\\*\\w+|[^\\n\\t\\[;${ce ? `\\${ce}` : ""}]+`, "gs");
    RubySpliter.setEscape(ce);
    __privateSet2(this, _REG_CANTC2M, new RegExp(`[\\w\\s;[\\]*=&\uFF5C\u300A\u300B${ce ? `\\${ce}` : ""}]`));
    this.REG_TOKEN_NOTXT = new RegExp(`[\\n\\t;\\[*&${ce ? `\\${ce}` : ""}]`);
  }
  matchToken(txt) {
    var _a3;
    return (_a3 = txt.match(this.REG_TOKEN)) != null ? _a3 : [];
  }
  bracket2macro(hArg, script, idxToken) {
    var _a3;
    const { name: name2, text: text2 } = hArg;
    if (!name2)
      throw "[bracket2macro] name\u306F\u5FC5\u9808\u3067\u3059";
    if (!text2)
      throw "[bracket2macro] text\u306F\u5FC5\u9808\u3067\u3059";
    if (text2.length !== 2)
      throw "[bracket2macro] text\u306F\u62EC\u5F27\u306E\u524D\u5F8C\u3092\u793A\u3059\u4E8C\u6587\u5B57\u3092\u6307\u5B9A\u3057\u3066\u304F\u3060\u3055\u3044";
    (_a3 = __privateGet2(this, _hC2M)) != null ? _a3 : __privateSet2(this, _hC2M, {});
    const op = text2.charAt(0);
    const cl = text2.charAt(1);
    if (op in __privateGet2(this, _hC2M))
      throw "[bracket2macro] text\u3010" + op + "\u3011\u304C\u767B\u9332\u6E08\u307F\u306E\u62EC\u5F27\u30DE\u30AF\u30ED\u307E\u305F\u306F\u4E00\u6587\u5B57\u30DE\u30AF\u30ED\u3067\u3059";
    if (cl in __privateGet2(this, _hC2M))
      throw "[bracket2macro] text\u3010" + cl + "\u3011\u304C\u767B\u9332\u6E08\u307F\u306E\u62EC\u5F27\u30DE\u30AF\u30ED\u307E\u305F\u306F\u4E00\u6587\u5B57\u30DE\u30AF\u30ED\u3067\u3059";
    __privateGet2(this, _REG_CANTC2M).lastIndex = 0;
    if (__privateGet2(this, _REG_CANTC2M).test(op))
      throw "[bracket2macro] text\u3010" + op + "\u3011\u306F\u62EC\u5F27\u30DE\u30AF\u30ED\u306B\u4F7F\u7528\u3067\u304D\u306A\u3044\u6587\u5B57\u3067\u3059";
    __privateGet2(this, _REG_CANTC2M).lastIndex = 0;
    if (__privateGet2(this, _REG_CANTC2M).test(cl))
      throw "[bracket2macro] text\u3010" + cl + "\u3011\u306F\u62EC\u5F27\u30DE\u30AF\u30ED\u306B\u4F7F\u7528\u3067\u304D\u306A\u3044\u6587\u5B57\u3067\u3059";
    __privateGet2(this, _hC2M)[cl] = "0";
    __privateGet2(this, _hC2M)[op] = `[${name2} text=`;
    this.addC2M(`\\${op}[^\\${cl}]*\\${cl}`, `\\${op}\\${cl}`);
    this.replaceScr_C2M_And_let_ml(script, idxToken);
  }
  char2macro(hArg, hTag, script, idxToken) {
    var _a3;
    const { char, name: name2 } = hArg;
    if (!char)
      throw "[char2macro] char\u306F\u5FC5\u9808\u3067\u3059";
    (_a3 = __privateGet2(this, _hC2M)) != null ? _a3 : __privateSet2(this, _hC2M, {});
    if (char in __privateGet2(this, _hC2M))
      throw "[char2macro] char\u3010" + char + "\u3011\u304C\u767B\u9332\u6E08\u307F\u306E\u62EC\u5F27\u30DE\u30AF\u30ED\u307E\u305F\u306F\u4E00\u6587\u5B57\u30DE\u30AF\u30ED\u3067\u3059";
    __privateGet2(this, _REG_CANTC2M).lastIndex = 0;
    if (__privateGet2(this, _REG_CANTC2M).test(char))
      throw "[char2macro] char\u3010" + char + "\u3011\u306F\u4E00\u6587\u5B57\u30DE\u30AF\u30ED\u306B\u4F7F\u7528\u3067\u304D\u306A\u3044\u6587\u5B57\u3067\u3059";
    if (!name2)
      throw "[char2macro] name\u306F\u5FC5\u9808\u3067\u3059";
    if (!(name2 in hTag))
      throw `[char2macro] \u672A\u5B9A\u7FA9\u306E\u30BF\u30B0\u53C8\u306F\u30DE\u30AF\u30ED[${name2}]\u3067\u3059`;
    __privateGet2(this, _hC2M)[char] = `[${name2}]`;
    this.addC2M(`\\${char}`, `\\${char}`);
    this.replaceScr_C2M_And_let_ml(script, idxToken);
  }
  addC2M(a2, b2) {
    __privateSet2(this, _regStrC2M, __privateGet2(this, _regStrC2M) + `${a2}|`);
    __privateSet2(this, _regStrC2M4not, __privateGet2(this, _regStrC2M4not) + `${b2}`);
    __privateSet2(this, _REGC2M, new RegExp(`(${__privateGet2(this, _regStrC2M)}[^${__privateGet2(this, _regStrC2M4not)}]+)`, "g"));
  }
}
_REG_CANTC2M = new WeakMap();
_REGC2M = new WeakMap();
_regStrC2M = new WeakMap();
_regStrC2M4not = new WeakMap();
_hC2M = new WeakMap();
class AnalyzeTagArg {
  constructor() {
    __privateAdd2(this, _REG_TAGARG, /;[^\n]*|(?<key>\w+)(?:\s|;[^\n]*\n)*=(?:\s|;[^\n]*\n)*(?:(?<val>[^\s"'#|;]+)|(["'#])(?<val2>.*?)\3)(?:\|(?:(?<def>[^\s"'#;]+)|(["'#])(?<def2>.*?)\6))?|(?<literal>[^\s;]+)/g);
    __privateAdd2(this, _hPrm, {});
    __privateAdd2(this, _isKomeParam, false);
  }
  go(args) {
    var _a3, _b3;
    __privateSet2(this, _hPrm, {});
    __privateSet2(this, _isKomeParam, false);
    if (!args)
      return;
    let e = null;
    while (e = __privateGet2(this, _REG_TAGARG).exec(args)) {
      const g2 = e == null ? void 0 : e.groups;
      if (!g2)
        continue;
      if (g2.key)
        __privateGet2(this, _hPrm)[g2.key] = {
          val: (_a3 = g2.val) != null ? _a3 : g2.val2,
          def: (_b3 = g2.def) != null ? _b3 : g2.def2
        };
      else if (g2.literal) {
        if (g2.literal === "*")
          __privateSet2(this, _isKomeParam, true);
        else
          __privateGet2(this, _hPrm)[g2.literal] = { val: "1" };
      }
    }
  }
  get hPrm() {
    return __privateGet2(this, _hPrm);
  }
  get isKomeParam() {
    return __privateGet2(this, _isKomeParam);
  }
}
_REG_TAGARG = new WeakMap();
_hPrm = new WeakMap();
_isKomeParam = new WeakMap();
var parsimmon_umd_min = { exports: {} };
(function(module, exports) {
  !function(n, t) {
    module.exports = t();
  }(typeof self != "undefined" ? self : commonjsGlobal, function() {
    return function(n) {
      var t = {};
      function r2(e) {
        if (t[e])
          return t[e].exports;
        var u2 = t[e] = { i: e, l: false, exports: {} };
        return n[e].call(u2.exports, u2, u2.exports, r2), u2.l = true, u2.exports;
      }
      return r2.m = n, r2.c = t, r2.d = function(n2, t2, e) {
        r2.o(n2, t2) || Object.defineProperty(n2, t2, { configurable: false, enumerable: true, get: e });
      }, r2.r = function(n2) {
        Object.defineProperty(n2, "__esModule", { value: true });
      }, r2.n = function(n2) {
        var t2 = n2 && n2.__esModule ? function() {
          return n2.default;
        } : function() {
          return n2;
        };
        return r2.d(t2, "a", t2), t2;
      }, r2.o = function(n2, t2) {
        return Object.prototype.hasOwnProperty.call(n2, t2);
      }, r2.p = "", r2(r2.s = 0);
    }([function(n, t, r2) {
      function e(n2) {
        if (!(this instanceof e))
          return new e(n2);
        this._ = n2;
      }
      var u2 = e.prototype;
      function o(n2, t2) {
        for (var r3 = 0; r3 < n2; r3++)
          t2(r3);
      }
      function i2(n2, t2, r3) {
        return function(n3, t3) {
          o(t3.length, function(r4) {
            n3(t3[r4], r4, t3);
          });
        }(function(r4, e2, u3) {
          t2 = n2(t2, r4, e2, u3);
        }, r3), t2;
      }
      function a2(n2, t2) {
        return i2(function(t3, r3, e2, u3) {
          return t3.concat([n2(r3, e2, u3)]);
        }, [], t2);
      }
      function f2(n2, t2) {
        var r3 = { v: 0, buf: t2 };
        return o(n2, function() {
          var n3;
          r3 = { v: r3.v << 1 | (n3 = r3.buf, n3[0] >> 7), buf: function(n4) {
            var t3 = i2(function(n5, t4, r4, e2) {
              return n5.concat(r4 === e2.length - 1 ? Buffer.from([t4, 0]).readUInt16BE(0) : e2.readUInt16BE(r4));
            }, [], n4);
            return Buffer.from(a2(function(n5) {
              return (n5 << 1 & 65535) >> 8;
            }, t3));
          }(r3.buf) };
        }), r3;
      }
      function c2() {
        return typeof Buffer != "undefined";
      }
      function s2() {
        if (!c2())
          throw new Error("Buffer global does not exist; please use webpack if you need to parse Buffers in the browser.");
      }
      function l2(n2) {
        s2();
        var t2 = i2(function(n3, t3) {
          return n3 + t3;
        }, 0, n2);
        if (t2 % 8 != 0)
          throw new Error("The bits [" + n2.join(", ") + "] add up to " + t2 + " which is not an even number of bytes; the total should be divisible by 8");
        var r3, u3 = t2 / 8, o2 = (r3 = function(n3) {
          return n3 > 48;
        }, i2(function(n3, t3) {
          return n3 || (r3(t3) ? t3 : n3);
        }, null, n2));
        if (o2)
          throw new Error(o2 + " bit range requested exceeds 48 bit (6 byte) Number max.");
        return new e(function(t3, r4) {
          var e2 = u3 + r4;
          return e2 > t3.length ? x2(r4, u3.toString() + " bytes") : b2(e2, i2(function(n3, t4) {
            var r5 = f2(t4, n3.buf);
            return { coll: n3.coll.concat(r5.v), buf: r5.buf };
          }, { coll: [], buf: t3.slice(r4, e2) }, n2).coll);
        });
      }
      function h2(n2, t2) {
        return new e(function(r3, e2) {
          return s2(), e2 + t2 > r3.length ? x2(e2, t2 + " bytes for " + n2) : b2(e2 + t2, r3.slice(e2, e2 + t2));
        });
      }
      function p2(n2, t2) {
        if (typeof (r3 = t2) != "number" || Math.floor(r3) !== r3 || t2 < 0 || t2 > 6)
          throw new Error(n2 + " requires integer length in range [0, 6].");
        var r3;
      }
      function d2(n2) {
        return p2("uintBE", n2), h2("uintBE(" + n2 + ")", n2).map(function(t2) {
          return t2.readUIntBE(0, n2);
        });
      }
      function v2(n2) {
        return p2("uintLE", n2), h2("uintLE(" + n2 + ")", n2).map(function(t2) {
          return t2.readUIntLE(0, n2);
        });
      }
      function g2(n2) {
        return p2("intBE", n2), h2("intBE(" + n2 + ")", n2).map(function(t2) {
          return t2.readIntBE(0, n2);
        });
      }
      function m2(n2) {
        return p2("intLE", n2), h2("intLE(" + n2 + ")", n2).map(function(t2) {
          return t2.readIntLE(0, n2);
        });
      }
      function y2(n2) {
        return n2 instanceof e;
      }
      function E2(n2) {
        return {}.toString.call(n2) === "[object Array]";
      }
      function w2(n2) {
        return c2() && Buffer.isBuffer(n2);
      }
      function b2(n2, t2) {
        return { status: true, index: n2, value: t2, furthest: -1, expected: [] };
      }
      function x2(n2, t2) {
        return E2(t2) || (t2 = [t2]), { status: false, index: -1, value: null, furthest: n2, expected: t2 };
      }
      function B(n2, t2) {
        if (!t2)
          return n2;
        if (n2.furthest > t2.furthest)
          return n2;
        var r3 = n2.furthest === t2.furthest ? function(n3, t3) {
          if (function() {
            if (e._supportsSet !== void 0)
              return e._supportsSet;
            var n4 = typeof Set != "undefined";
            return e._supportsSet = n4, n4;
          }() && Array.from) {
            for (var r4 = new Set(n3), u3 = 0; u3 < t3.length; u3++)
              r4.add(t3[u3]);
            var o2 = Array.from(r4);
            return o2.sort(), o2;
          }
          for (var i3 = {}, a3 = 0; a3 < n3.length; a3++)
            i3[n3[a3]] = true;
          for (var f3 = 0; f3 < t3.length; f3++)
            i3[t3[f3]] = true;
          var c3 = [];
          for (var s3 in i3)
            ({}).hasOwnProperty.call(i3, s3) && c3.push(s3);
          return c3.sort(), c3;
        }(n2.expected, t2.expected) : t2.expected;
        return { status: n2.status, index: n2.index, value: n2.value, furthest: t2.furthest, expected: r3 };
      }
      var j2 = {};
      function S2(n2, t2) {
        if (w2(n2))
          return { offset: t2, line: -1, column: -1 };
        n2 in j2 || (j2[n2] = {});
        for (var r3 = j2[n2], e2 = 0, u3 = 0, o2 = 0, i3 = t2; i3 >= 0; ) {
          if (i3 in r3) {
            e2 = r3[i3].line, o2 === 0 && (o2 = r3[i3].lineStart);
            break;
          }
          (n2.charAt(i3) === "\n" || n2.charAt(i3) === "\r" && n2.charAt(i3 + 1) !== "\n") && (u3++, o2 === 0 && (o2 = i3 + 1)), i3--;
        }
        var a3 = e2 + u3, f3 = t2 - o2;
        return r3[t2] = { line: a3, lineStart: o2 }, { offset: t2, line: a3 + 1, column: f3 + 1 };
      }
      function _2(n2) {
        if (!y2(n2))
          throw new Error("not a parser: " + n2);
      }
      function L(n2, t2) {
        return typeof n2 == "string" ? n2.charAt(t2) : n2[t2];
      }
      function O2(n2) {
        if (typeof n2 != "number")
          throw new Error("not a number: " + n2);
      }
      function k(n2) {
        if (typeof n2 != "function")
          throw new Error("not a function: " + n2);
      }
      function P2(n2) {
        if (typeof n2 != "string")
          throw new Error("not a string: " + n2);
      }
      var q = 2, A2 = 3, I2 = 8, F2 = 5 * I2, M = 4 * I2, z = "  ";
      function R(n2, t2) {
        return new Array(t2 + 1).join(n2);
      }
      function U(n2, t2, r3) {
        var e2 = t2 - n2.length;
        return e2 <= 0 ? n2 : R(r3, e2) + n2;
      }
      function W(n2, t2, r3, e2) {
        return { from: n2 - t2 > 0 ? n2 - t2 : 0, to: n2 + r3 > e2 ? e2 : n2 + r3 };
      }
      function D(n2, t2) {
        var r3, e2, u3, o2, f3, c3 = t2.index, s3 = c3.offset, l3 = 1;
        if (s3 === n2.length)
          return "Got the end of the input";
        if (w2(n2)) {
          var h3 = s3 - s3 % I2, p3 = s3 - h3, d3 = W(h3, F2, M + I2, n2.length), v3 = a2(function(n3) {
            return a2(function(n4) {
              return U(n4.toString(16), 2, "0");
            }, n3);
          }, function(n3, t3) {
            var r4 = n3.length, e3 = [], u4 = 0;
            if (r4 <= t3)
              return [n3.slice()];
            for (var o3 = 0; o3 < r4; o3++)
              e3[u4] || e3.push([]), e3[u4].push(n3[o3]), (o3 + 1) % t3 == 0 && u4++;
            return e3;
          }(n2.slice(d3.from, d3.to).toJSON().data, I2));
          o2 = function(n3) {
            return n3.from === 0 && n3.to === 1 ? { from: n3.from, to: n3.to } : { from: n3.from / I2, to: Math.floor(n3.to / I2) };
          }(d3), e2 = h3 / I2, r3 = 3 * p3, p3 >= 4 && (r3 += 1), l3 = 2, u3 = a2(function(n3) {
            return n3.length <= 4 ? n3.join(" ") : n3.slice(0, 4).join(" ") + "  " + n3.slice(4).join(" ");
          }, v3), (f3 = (8 * (o2.to > 0 ? o2.to - 1 : o2.to)).toString(16).length) < 2 && (f3 = 2);
        } else {
          var g3 = n2.split(/\r\n|[\n\r\u2028\u2029]/);
          r3 = c3.column - 1, e2 = c3.line - 1, o2 = W(e2, q, A2, g3.length), u3 = g3.slice(o2.from, o2.to), f3 = o2.to.toString().length;
        }
        var m3 = e2 - o2.from;
        return w2(n2) && (f3 = (8 * (o2.to > 0 ? o2.to - 1 : o2.to)).toString(16).length) < 2 && (f3 = 2), i2(function(t3, e3, u4) {
          var i3, a3 = u4 === m3, c4 = a3 ? "> " : z;
          return i3 = w2(n2) ? U((8 * (o2.from + u4)).toString(16), f3, "0") : U((o2.from + u4 + 1).toString(), f3, " "), [].concat(t3, [c4 + i3 + " | " + e3], a3 ? [z + R(" ", f3) + " | " + U("", r3, " ") + R("^", l3)] : []);
        }, [], u3).join("\n");
      }
      function N(n2, t2) {
        return ["\n", "-- PARSING FAILED " + R("-", 50), "\n\n", D(n2, t2), "\n\n", (r3 = t2.expected, r3.length === 1 ? "Expected:\n\n" + r3[0] : "Expected one of the following: \n\n" + r3.join(", ")), "\n"].join("");
        var r3;
      }
      function G2(n2) {
        return n2.flags !== void 0 ? n2.flags : [n2.global ? "g" : "", n2.ignoreCase ? "i" : "", n2.multiline ? "m" : "", n2.unicode ? "u" : "", n2.sticky ? "y" : ""].join("");
      }
      function C2() {
        for (var n2 = [].slice.call(arguments), t2 = n2.length, r3 = 0; r3 < t2; r3 += 1)
          _2(n2[r3]);
        return e(function(r4, e2) {
          for (var u3, o2 = new Array(t2), i3 = 0; i3 < t2; i3 += 1) {
            if (!(u3 = B(n2[i3]._(r4, e2), u3)).status)
              return u3;
            o2[i3] = u3.value, e2 = u3.index;
          }
          return B(b2(e2, o2), u3);
        });
      }
      function J() {
        var n2 = [].slice.call(arguments);
        if (n2.length === 0)
          throw new Error("seqMap needs at least one argument");
        var t2 = n2.pop();
        return k(t2), C2.apply(null, n2).map(function(n3) {
          return t2.apply(null, n3);
        });
      }
      function T2() {
        var n2 = [].slice.call(arguments), t2 = n2.length;
        if (t2 === 0)
          return Y("zero alternates");
        for (var r3 = 0; r3 < t2; r3 += 1)
          _2(n2[r3]);
        return e(function(t3, r4) {
          for (var e2, u3 = 0; u3 < n2.length; u3 += 1)
            if ((e2 = B(n2[u3]._(t3, r4), e2)).status)
              return e2;
          return e2;
        });
      }
      function V(n2, t2) {
        return H(n2, t2).or(X([]));
      }
      function H(n2, t2) {
        return _2(n2), _2(t2), J(n2, t2.then(n2).many(), function(n3, t3) {
          return [n3].concat(t3);
        });
      }
      function K(n2) {
        P2(n2);
        var t2 = "'" + n2 + "'";
        return e(function(r3, e2) {
          var u3 = e2 + n2.length, o2 = r3.slice(e2, u3);
          return o2 === n2 ? b2(u3, o2) : x2(e2, t2);
        });
      }
      function Q(n2, t2) {
        !function(n3) {
          if (!(n3 instanceof RegExp))
            throw new Error("not a regexp: " + n3);
          for (var t3 = G2(n3), r4 = 0; r4 < t3.length; r4++) {
            var e2 = t3.charAt(r4);
            if (e2 !== "i" && e2 !== "m" && e2 !== "u" && e2 !== "s")
              throw new Error('unsupported regexp flag "' + e2 + '": ' + n3);
          }
        }(n2), arguments.length >= 2 ? O2(t2) : t2 = 0;
        var r3 = function(n3) {
          return RegExp("^(?:" + n3.source + ")", G2(n3));
        }(n2), u3 = "" + n2;
        return e(function(n3, e2) {
          var o2 = r3.exec(n3.slice(e2));
          if (o2) {
            if (0 <= t2 && t2 <= o2.length) {
              var i3 = o2[0], a3 = o2[t2];
              return b2(e2 + i3.length, a3);
            }
            return x2(e2, "valid match group (0 to " + o2.length + ") in " + u3);
          }
          return x2(e2, u3);
        });
      }
      function X(n2) {
        return e(function(t2, r3) {
          return b2(r3, n2);
        });
      }
      function Y(n2) {
        return e(function(t2, r3) {
          return x2(r3, n2);
        });
      }
      function Z(n2) {
        if (y2(n2))
          return e(function(t2, r3) {
            var e2 = n2._(t2, r3);
            return e2.index = r3, e2.value = "", e2;
          });
        if (typeof n2 == "string")
          return Z(K(n2));
        if (n2 instanceof RegExp)
          return Z(Q(n2));
        throw new Error("not a string, regexp, or parser: " + n2);
      }
      function $(n2) {
        return _2(n2), e(function(t2, r3) {
          var e2 = n2._(t2, r3), u3 = t2.slice(r3, e2.index);
          return e2.status ? x2(r3, 'not "' + u3 + '"') : b2(r3, null);
        });
      }
      function nn(n2) {
        return k(n2), e(function(t2, r3) {
          var e2 = L(t2, r3);
          return r3 < t2.length && n2(e2) ? b2(r3 + 1, e2) : x2(r3, "a character/byte matching " + n2);
        });
      }
      function tn(n2, t2) {
        arguments.length < 2 && (t2 = n2, n2 = void 0);
        var r3 = e(function(n3, e2) {
          return r3._ = t2()._, r3._(n3, e2);
        });
        return n2 ? r3.desc(n2) : r3;
      }
      function rn() {
        return Y("fantasy-land/empty");
      }
      u2.parse = function(n2) {
        if (typeof n2 != "string" && !w2(n2))
          throw new Error(".parse must be called with a string or Buffer as its argument");
        var t2, r3 = this.skip(an)._(n2, 0);
        return t2 = r3.status ? { status: true, value: r3.value } : { status: false, index: S2(n2, r3.furthest), expected: r3.expected }, delete j2[n2], t2;
      }, u2.tryParse = function(n2) {
        var t2 = this.parse(n2);
        if (t2.status)
          return t2.value;
        var r3 = N(n2, t2), e2 = new Error(r3);
        throw e2.type = "ParsimmonError", e2.result = t2, e2;
      }, u2.assert = function(n2, t2) {
        return this.chain(function(r3) {
          return n2(r3) ? X(r3) : Y(t2);
        });
      }, u2.or = function(n2) {
        return T2(this, n2);
      }, u2.trim = function(n2) {
        return this.wrap(n2, n2);
      }, u2.wrap = function(n2, t2) {
        return J(n2, this, t2, function(n3, t3) {
          return t3;
        });
      }, u2.thru = function(n2) {
        return n2(this);
      }, u2.then = function(n2) {
        return _2(n2), C2(this, n2).map(function(n3) {
          return n3[1];
        });
      }, u2.many = function() {
        var n2 = this;
        return e(function(t2, r3) {
          for (var e2 = [], u3 = void 0; ; ) {
            if (!(u3 = B(n2._(t2, r3), u3)).status)
              return B(b2(r3, e2), u3);
            if (r3 === u3.index)
              throw new Error("infinite loop detected in .many() parser --- calling .many() on a parser which can accept zero characters is usually the cause");
            r3 = u3.index, e2.push(u3.value);
          }
        });
      }, u2.tieWith = function(n2) {
        return P2(n2), this.map(function(t2) {
          if (function(n3) {
            if (!E2(n3))
              throw new Error("not an array: " + n3);
          }(t2), t2.length) {
            P2(t2[0]);
            for (var r3 = t2[0], e2 = 1; e2 < t2.length; e2++)
              P2(t2[e2]), r3 += n2 + t2[e2];
            return r3;
          }
          return "";
        });
      }, u2.tie = function() {
        return this.tieWith("");
      }, u2.times = function(n2, t2) {
        var r3 = this;
        return arguments.length < 2 && (t2 = n2), O2(n2), O2(t2), e(function(e2, u3) {
          for (var o2 = [], i3 = void 0, a3 = void 0, f3 = 0; f3 < n2; f3 += 1) {
            if (a3 = B(i3 = r3._(e2, u3), a3), !i3.status)
              return a3;
            u3 = i3.index, o2.push(i3.value);
          }
          for (; f3 < t2 && (a3 = B(i3 = r3._(e2, u3), a3), i3.status); f3 += 1)
            u3 = i3.index, o2.push(i3.value);
          return B(b2(u3, o2), a3);
        });
      }, u2.result = function(n2) {
        return this.map(function() {
          return n2;
        });
      }, u2.atMost = function(n2) {
        return this.times(0, n2);
      }, u2.atLeast = function(n2) {
        return J(this.times(n2), this.many(), function(n3, t2) {
          return n3.concat(t2);
        });
      }, u2.map = function(n2) {
        k(n2);
        var t2 = this;
        return e(function(r3, e2) {
          var u3 = t2._(r3, e2);
          return u3.status ? B(b2(u3.index, n2(u3.value)), u3) : u3;
        });
      }, u2.contramap = function(n2) {
        k(n2);
        var t2 = this;
        return e(function(r3, e2) {
          var u3 = t2.parse(n2(r3.slice(e2)));
          return u3.status ? b2(e2 + r3.length, u3.value) : u3;
        });
      }, u2.promap = function(n2, t2) {
        return k(n2), k(t2), this.contramap(n2).map(t2);
      }, u2.skip = function(n2) {
        return C2(this, n2).map(function(n3) {
          return n3[0];
        });
      }, u2.mark = function() {
        return J(en, this, en, function(n2, t2, r3) {
          return { start: n2, value: t2, end: r3 };
        });
      }, u2.node = function(n2) {
        return J(en, this, en, function(t2, r3, e2) {
          return { name: n2, value: r3, start: t2, end: e2 };
        });
      }, u2.sepBy = function(n2) {
        return V(this, n2);
      }, u2.sepBy1 = function(n2) {
        return H(this, n2);
      }, u2.lookahead = function(n2) {
        return this.skip(Z(n2));
      }, u2.notFollowedBy = function(n2) {
        return this.skip($(n2));
      }, u2.desc = function(n2) {
        E2(n2) || (n2 = [n2]);
        var t2 = this;
        return e(function(r3, e2) {
          var u3 = t2._(r3, e2);
          return u3.status || (u3.expected = n2), u3;
        });
      }, u2.fallback = function(n2) {
        return this.or(X(n2));
      }, u2.ap = function(n2) {
        return J(n2, this, function(n3, t2) {
          return n3(t2);
        });
      }, u2.chain = function(n2) {
        var t2 = this;
        return e(function(r3, e2) {
          var u3 = t2._(r3, e2);
          return u3.status ? B(n2(u3.value)._(r3, u3.index), u3) : u3;
        });
      }, u2.concat = u2.or, u2.empty = rn, u2.of = X, u2["fantasy-land/ap"] = u2.ap, u2["fantasy-land/chain"] = u2.chain, u2["fantasy-land/concat"] = u2.concat, u2["fantasy-land/empty"] = u2.empty, u2["fantasy-land/of"] = u2.of, u2["fantasy-land/map"] = u2.map;
      var en = e(function(n2, t2) {
        return b2(t2, S2(n2, t2));
      }), un = e(function(n2, t2) {
        return t2 >= n2.length ? x2(t2, "any character/byte") : b2(t2 + 1, L(n2, t2));
      }), on2 = e(function(n2, t2) {
        return b2(n2.length, n2.slice(t2));
      }), an = e(function(n2, t2) {
        return t2 < n2.length ? x2(t2, "EOF") : b2(t2, null);
      }), fn = Q(/[0-9]/).desc("a digit"), cn = Q(/[0-9]*/).desc("optional digits"), sn = Q(/[a-z]/i).desc("a letter"), ln = Q(/[a-z]*/i).desc("optional letters"), hn = Q(/\s*/).desc("optional whitespace"), pn = Q(/\s+/).desc("whitespace"), dn = K("\r"), vn = K("\n"), gn = K("\r\n"), mn = T2(gn, vn, dn).desc("newline"), yn = T2(mn, an);
      e.all = on2, e.alt = T2, e.any = un, e.cr = dn, e.createLanguage = function(n2) {
        var t2 = {};
        for (var r3 in n2)
          ({}).hasOwnProperty.call(n2, r3) && function(r4) {
            t2[r4] = tn(function() {
              return n2[r4](t2);
            });
          }(r3);
        return t2;
      }, e.crlf = gn, e.custom = function(n2) {
        return e(n2(b2, x2));
      }, e.digit = fn, e.digits = cn, e.empty = rn, e.end = yn, e.eof = an, e.fail = Y, e.formatError = N, e.index = en, e.isParser = y2, e.lazy = tn, e.letter = sn, e.letters = ln, e.lf = vn, e.lookahead = Z, e.makeFailure = x2, e.makeSuccess = b2, e.newline = mn, e.noneOf = function(n2) {
        return nn(function(t2) {
          return n2.indexOf(t2) < 0;
        }).desc("none of '" + n2 + "'");
      }, e.notFollowedBy = $, e.of = X, e.oneOf = function(n2) {
        for (var t2 = n2.split(""), r3 = 0; r3 < t2.length; r3++)
          t2[r3] = "'" + t2[r3] + "'";
        return nn(function(t3) {
          return n2.indexOf(t3) >= 0;
        }).desc(t2);
      }, e.optWhitespace = hn, e.Parser = e, e.range = function(n2, t2) {
        return nn(function(r3) {
          return n2 <= r3 && r3 <= t2;
        }).desc(n2 + "-" + t2);
      }, e.regex = Q, e.regexp = Q, e.sepBy = V, e.sepBy1 = H, e.seq = C2, e.seqMap = J, e.seqObj = function() {
        for (var n2, t2 = {}, r3 = 0, u3 = (n2 = arguments, Array.prototype.slice.call(n2)), o2 = u3.length, i3 = 0; i3 < o2; i3 += 1) {
          var a3 = u3[i3];
          if (!y2(a3)) {
            if (E2(a3) && a3.length === 2 && typeof a3[0] == "string" && y2(a3[1])) {
              var f3 = a3[0];
              if (Object.prototype.hasOwnProperty.call(t2, f3))
                throw new Error("seqObj: duplicate key " + f3);
              t2[f3] = true, r3++;
              continue;
            }
            throw new Error("seqObj arguments must be parsers or [string, parser] array pairs.");
          }
        }
        if (r3 === 0)
          throw new Error("seqObj expects at least one named parser, found zero");
        return e(function(n3, t3) {
          for (var r4, e2 = {}, i4 = 0; i4 < o2; i4 += 1) {
            var a4, f4;
            if (E2(u3[i4]) ? (a4 = u3[i4][0], f4 = u3[i4][1]) : (a4 = null, f4 = u3[i4]), !(r4 = B(f4._(n3, t3), r4)).status)
              return r4;
            a4 && (e2[a4] = r4.value), t3 = r4.index;
          }
          return B(b2(t3, e2), r4);
        });
      }, e.string = K, e.succeed = X, e.takeWhile = function(n2) {
        return k(n2), e(function(t2, r3) {
          for (var e2 = r3; e2 < t2.length && n2(L(t2, e2)); )
            e2++;
          return b2(e2, t2.slice(r3, e2));
        });
      }, e.test = nn, e.whitespace = pn, e["fantasy-land/empty"] = rn, e["fantasy-land/of"] = X, e.Binary = { bitSeq: l2, bitSeqObj: function(n2) {
        s2();
        var t2 = {}, r3 = 0, e2 = a2(function(n3) {
          if (E2(n3)) {
            var e3 = n3;
            if (e3.length !== 2)
              throw new Error("[" + e3.join(", ") + "] should be length 2, got length " + e3.length);
            if (P2(e3[0]), O2(e3[1]), Object.prototype.hasOwnProperty.call(t2, e3[0]))
              throw new Error("duplicate key in bitSeqObj: " + e3[0]);
            return t2[e3[0]] = true, r3++, e3;
          }
          return O2(n3), [null, n3];
        }, n2);
        if (r3 < 1)
          throw new Error("bitSeqObj expects at least one named pair, got [" + n2.join(", ") + "]");
        var u3 = a2(function(n3) {
          return n3[0];
        }, e2);
        return l2(a2(function(n3) {
          return n3[1];
        }, e2)).map(function(n3) {
          return i2(function(n4, t3) {
            return t3[0] !== null && (n4[t3[0]] = t3[1]), n4;
          }, {}, a2(function(t3, r4) {
            return [t3, n3[r4]];
          }, u3));
        });
      }, byte: function(n2) {
        if (s2(), O2(n2), n2 > 255)
          throw new Error("Value specified to byte constructor (" + n2 + "=0x" + n2.toString(16) + ") is larger in value than a single byte.");
        var t2 = (n2 > 15 ? "0x" : "0x0") + n2.toString(16);
        return e(function(r3, e2) {
          var u3 = L(r3, e2);
          return u3 === n2 ? b2(e2 + 1, u3) : x2(e2, t2);
        });
      }, buffer: function(n2) {
        return h2("buffer", n2).map(function(n3) {
          return Buffer.from(n3);
        });
      }, encodedString: function(n2, t2) {
        return h2("string", t2).map(function(t3) {
          return t3.toString(n2);
        });
      }, uintBE: d2, uint8BE: d2(1), uint16BE: d2(2), uint32BE: d2(4), uintLE: v2, uint8LE: v2(1), uint16LE: v2(2), uint32LE: v2(4), intBE: g2, int8BE: g2(1), int16BE: g2(2), int32BE: g2(4), intLE: m2, int8LE: m2(1), int16LE: m2(2), int32LE: m2(4), floatBE: h2("floatBE", 4).map(function(n2) {
        return n2.readFloatBE(0);
      }), floatLE: h2("floatLE", 4).map(function(n2) {
        return n2.readFloatLE(0);
      }), doubleBE: h2("doubleBE", 8).map(function(n2) {
        return n2.readDoubleBE(0);
      }), doubleLE: h2("doubleLE", 8).map(function(n2) {
        return n2.readDoubleLE(0);
      }) }, n.exports = e;
    }]);
  });
})(parsimmon_umd_min);
const _PropParser = class {
  constructor(val, ce = "\\") {
    __privateAdd2(this, _calc);
    __privateAdd2(this, _fncSub_ChkNum);
    __privateAdd2(this, _procEmbedVar);
    __privateAdd2(this, _parser, void 0);
    __privateAdd2(this, _hFnc, void 0);
    __privateAdd2(this, _REG_EMBEDVAR, void 0);
    this.val = val;
    __privateSet2(this, _parser, null);
    __privateSet2(this, _hFnc, {
      "!num!": (a2) => a2.shift(),
      "!str!": (a2) => __privateMethod2(this, _procEmbedVar, procEmbedVar_fn).call(this, a2.shift()),
      "!bool!": (a2) => a2.shift(),
      "!": (a2) => {
        const b2 = a2.shift();
        return b2[0] === "!bool!" ? !Boolean(b2[1]) : !(String(__privateMethod2(this, _calc, calc_fn).call(this, b2)) === "true");
      },
      "~": (a2) => ~Number(__privateMethod2(this, _calc, calc_fn).call(this, a2.shift())),
      "**": (a2) => Number(__privateMethod2(this, _calc, calc_fn).call(this, a2.shift())) ** Number(__privateMethod2(this, _calc, calc_fn).call(this, a2.shift())),
      "*": (a2) => Number(__privateMethod2(this, _calc, calc_fn).call(this, a2.shift())) * Number(__privateMethod2(this, _calc, calc_fn).call(this, a2.shift())),
      "/": (a2) => Number(__privateMethod2(this, _calc, calc_fn).call(this, a2.shift())) / Number(__privateMethod2(this, _calc, calc_fn).call(this, a2.shift())),
      "\xA5": (a2) => Math.floor(__privateGet2(this, _hFnc)["/"](a2)),
      "%": (a2) => Number(__privateMethod2(this, _calc, calc_fn).call(this, a2.shift())) % Number(__privateMethod2(this, _calc, calc_fn).call(this, a2.shift())),
      "+": (a2) => {
        const b2 = __privateMethod2(this, _calc, calc_fn).call(this, a2.shift());
        const c2 = __privateMethod2(this, _calc, calc_fn).call(this, a2.shift());
        if (Object.prototype.toString.call(b2) === "[object String]" || Object.prototype.toString.call(c2) === "[object String]") {
          return String(b2) + String(c2);
        }
        return Number(b2) + Number(c2);
      },
      "-": (a2) => Number(__privateMethod2(this, _calc, calc_fn).call(this, a2.shift())) - Number(__privateMethod2(this, _calc, calc_fn).call(this, a2.shift())),
      "int": (a2) => int(__privateMethod2(this, _fncSub_ChkNum, fncSub_ChkNum_fn).call(this, a2.shift())),
      "parseInt": (a2) => int(__privateGet2(this, _hFnc)["Number"](a2)),
      "Number": (a2) => {
        const b2 = __privateMethod2(this, _calc, calc_fn).call(this, a2.shift());
        if (Object.prototype.toString.call(b2) !== "[object String]")
          return Number(b2);
        return __privateMethod2(this, _fncSub_ChkNum, fncSub_ChkNum_fn).call(this, __privateGet2(this, _parser).parse(String(b2)).value);
      },
      "ceil": (a2) => Math.ceil(__privateMethod2(this, _fncSub_ChkNum, fncSub_ChkNum_fn).call(this, a2.shift())),
      "floor": (a2) => Math.floor(__privateMethod2(this, _fncSub_ChkNum, fncSub_ChkNum_fn).call(this, a2.shift())),
      "round": (a2) => Math.round(__privateMethod2(this, _fncSub_ChkNum, fncSub_ChkNum_fn).call(this, a2.shift())),
      "isNaN": (a2) => isNaN(Number(__privateMethod2(this, _calc, calc_fn).call(this, a2.shift()))),
      "<<": (a2) => Number(__privateMethod2(this, _calc, calc_fn).call(this, a2.shift())) << Number(__privateMethod2(this, _calc, calc_fn).call(this, a2.shift())),
      ">>": (a2) => Number(__privateMethod2(this, _calc, calc_fn).call(this, a2.shift())) >> Number(__privateMethod2(this, _calc, calc_fn).call(this, a2.shift())),
      ">>>": (a2) => Number(__privateMethod2(this, _calc, calc_fn).call(this, a2.shift())) >>> Number(__privateMethod2(this, _calc, calc_fn).call(this, a2.shift())),
      "<": (a2) => Number(__privateMethod2(this, _calc, calc_fn).call(this, a2.shift())) < Number(__privateMethod2(this, _calc, calc_fn).call(this, a2.shift())),
      "<=": (a2) => Number(__privateMethod2(this, _calc, calc_fn).call(this, a2.shift())) <= Number(__privateMethod2(this, _calc, calc_fn).call(this, a2.shift())),
      ">": (a2) => Number(__privateMethod2(this, _calc, calc_fn).call(this, a2.shift())) > Number(__privateMethod2(this, _calc, calc_fn).call(this, a2.shift())),
      ">=": (a2) => Number(__privateMethod2(this, _calc, calc_fn).call(this, a2.shift())) >= Number(__privateMethod2(this, _calc, calc_fn).call(this, a2.shift())),
      "==": (a2) => {
        const b2 = __privateMethod2(this, _calc, calc_fn).call(this, a2.shift());
        const c2 = __privateMethod2(this, _calc, calc_fn).call(this, a2.shift());
        if (b2 == null && c2 == null && (!b2 || !c2))
          return b2 == c2;
        return String(b2) === String(c2);
      },
      "!=": (a2) => !__privateGet2(this, _hFnc)["=="](a2),
      "===": (a2) => {
        const b2 = __privateMethod2(this, _calc, calc_fn).call(this, a2.shift());
        const c2 = __privateMethod2(this, _calc, calc_fn).call(this, a2.shift());
        if (Object.prototype.toString.call(b2) != Object.prototype.toString.call(c2))
          return false;
        return String(b2) === String(c2);
      },
      "!==": (a2) => !__privateGet2(this, _hFnc)["==="](a2),
      "&": (a2) => Number(__privateMethod2(this, _calc, calc_fn).call(this, a2.shift())) & Number(__privateMethod2(this, _calc, calc_fn).call(this, a2.shift())),
      "^": (a2) => Number(__privateMethod2(this, _calc, calc_fn).call(this, a2.shift())) ^ Number(__privateMethod2(this, _calc, calc_fn).call(this, a2.shift())),
      "|": (a2) => Number(__privateMethod2(this, _calc, calc_fn).call(this, a2.shift())) | Number(__privateMethod2(this, _calc, calc_fn).call(this, a2.shift())),
      "&&": (a2) => String(__privateMethod2(this, _calc, calc_fn).call(this, a2.shift())) === "true" && String(__privateMethod2(this, _calc, calc_fn).call(this, a2.shift())) === "true",
      "||": (a2) => String(__privateMethod2(this, _calc, calc_fn).call(this, a2.shift())) === "true" || String(__privateMethod2(this, _calc, calc_fn).call(this, a2.shift())) === "true",
      "?": (a2) => {
        const b2 = a2.shift();
        let cond = false;
        if (b2[0] === "!bool!") {
          cond = Boolean(b2[1]);
        } else {
          const cond2 = String(__privateMethod2(this, _calc, calc_fn).call(this, b2));
          cond = cond2 !== "true" && cond2 !== "false" ? int(cond2) !== 0 : cond2 === "true";
        }
        const elm2 = a2.shift();
        if (elm2[0] !== ":")
          throw Error("(PropParser)\u4E09\u9805\u6F14\u7B97\u5B50\u306E\u6587\u6CD5\u30A8\u30E9\u30FC\u3067\u3059\u3002: \u304C\u898B\u3064\u304B\u308A\u307E\u305B\u3093");
        return __privateMethod2(this, _calc, calc_fn).call(this, elm2[cond ? 1 : 2]);
      },
      ":": () => {
        throw Error("(PropParser)\u4E09\u9805\u6F14\u7B97\u5B50\u306E\u6587\u6CD5\u30A8\u30E9\u30FC\u3067\u3059\u3002? \u304C\u898B\u3064\u304B\u308A\u307E\u305B\u3093");
      }
    });
    __privateSet2(this, _REG_EMBEDVAR, /(\$((tmp|sys|save|mp):)?[^\s!--\/:-@[-^`{-~]+|\#\{[^\}]+})/g);
    this.getValAmpersand = (val2) => val2.charAt(0) === "&" ? String(this.parse(val2.slice(1))) : val2;
    function ope(a2) {
      const ps = [];
      a2.forEach((v2) => ps.push((v2 instanceof RegExp ? parsimmon_umd_min.exports.regex(v2) : parsimmon_umd_min.exports.string(v2)).trim(parsimmon_umd_min.exports.optWhitespace)));
      return parsimmon_umd_min.exports.alt.apply(null, ps);
    }
    function PREFIX2(operatorsParser, nextParser) {
      const parser2 = parsimmon_umd_min.exports.lazy(() => parsimmon_umd_min.exports.seq(operatorsParser, parser2).or(nextParser));
      return parser2;
    }
    function BINARY_RIGHT(operatorsParser, nextParser) {
      let parser2 = parsimmon_umd_min.exports.lazy(() => nextParser.chain((next) => parsimmon_umd_min.exports.seq(operatorsParser, parsimmon_umd_min.exports.of(next), parser2).or(parsimmon_umd_min.exports.of(next))));
      return parser2;
    }
    function BINARY_LEFT(operatorsParser, nextParser) {
      return parsimmon_umd_min.exports.seqMap(nextParser, parsimmon_umd_min.exports.seq(operatorsParser, nextParser).many(), (first, rest) => rest.reduce((acc, ch) => [ch[0], acc, ch[1]], first));
    }
    const Num = parsimmon_umd_min.exports.alt(parsimmon_umd_min.exports.alt(parsimmon_umd_min.exports.regex(/-?(0|[1-9][0-9]*)\.[0-9]+/), parsimmon_umd_min.exports.regex(/0x[0-9a-fA-F]+/)).map(Number), parsimmon_umd_min.exports.alt(parsimmon_umd_min.exports.regex(/-?(0|[1-9][0-9]*)/)).map((n) => int(n))).map((str2) => ["!num!", str2]).desc("number");
    const NullLiteral = parsimmon_umd_min.exports.string("null").map(() => ["!str!", null]);
    const BooleanLiteral = parsimmon_umd_min.exports.regex(/(true|false)/).map((b2) => ["!bool!", b2 === "true"]).desc("boolean");
    const StringLiteral = parsimmon_umd_min.exports.regex(new RegExp(`(?:"(?:\\${ce}["'#\\n]|[^"])*"|'(?:\\${ce}["'#\\n]|[^'])*'|\\#(?:\\${ce}["'#\\n]|[^#])*\\#)`)).map((b2) => ["!str!", b2.slice(1, -1).replaceAll(ce, "")]).desc("string");
    const REG_BRACKETS = /\[[^\]]+\]/g;
    const VarLiteral = parsimmon_umd_min.exports.regex(/-?(?:(?:tmp|sys|save|mp):)?[^\s!-\/:-@[-^`{-~]+(?:\.[^\s!-\/:-@[-^`{-~]+|\[[^\]]+\])*(?:@str)?/).map((b2) => {
      const s2 = String(b2).replace(REG_BRACKETS, (v2) => "." + this.parse(v2.slice(1, -1)));
      if (s2.charAt(0) === "-") {
        const val3 = this.val.getVal(s2.slice(1));
        if (val3 == null || String(val3) === "null")
          throw Error("(PropParser)\u6570\u5024\u4EE5\u5916\u306B-\u7B26\u53F7\u304C\u3064\u3044\u3066\u3044\u307E\u3059");
        return ["!num!", -Number(val3)];
      }
      const val2 = this.val.getVal(s2);
      if (val2 == null)
        return ["!str!", val2];
      if (typeof val2 === "boolean")
        return ["!bool!", val2];
      return Object.prototype.toString.call(val2) === "[object String]" ? ["!str!", String(val2)] : ["!num!", Number(val2)];
    }).desc("string");
    const Basic = parsimmon_umd_min.exports.lazy(() => parsimmon_umd_min.exports.string("(").then(__privateGet2(this, _parser)).skip(parsimmon_umd_min.exports.string(")")).or(Num).or(NullLiteral).or(BooleanLiteral).or(StringLiteral).or(VarLiteral));
    const table = [
      { type: PREFIX2, ops: ope([/[A-Za-z_][A-Za-z0-9_]*(?=\()/]) },
      { type: PREFIX2, ops: ope([/(!(?!=)|~)/]) },
      { type: BINARY_RIGHT, ops: ope(["**"]) },
      { type: BINARY_LEFT, ops: ope(["*", "/", "\xA5", "%"]) },
      { type: BINARY_LEFT, ops: ope(["+", "-"]) },
      { type: BINARY_LEFT, ops: ope([/(>>>|<<|>>)/]) },
      { type: BINARY_LEFT, ops: ope([/(<=|<|>=|>)/]) },
      { type: BINARY_LEFT, ops: ope([/(===|!==|==|!=)/]) },
      { type: BINARY_LEFT, ops: ope([/&(?!&)/]) },
      { type: BINARY_LEFT, ops: ope(["^"]) },
      { type: BINARY_LEFT, ops: ope([/\|(?!\|)/]) },
      { type: BINARY_LEFT, ops: ope(["&&"]) },
      { type: BINARY_LEFT, ops: ope(["||"]) },
      { type: BINARY_RIGHT, ops: ope([":"]) },
      { type: BINARY_RIGHT, ops: ope(["?"]) }
    ];
    const tableParser = table.reduce((acc, level) => level.type(level.ops, acc), Basic);
    __privateSet2(this, _parser, tableParser.trim(parsimmon_umd_min.exports.optWhitespace));
  }
  parse(s2) {
    const p2 = __privateGet2(this, _parser).parse(s2);
    if (!p2.status)
      throw Error("(PropParser)\u6587\u6CD5\u30A8\u30E9\u30FC\u3010" + s2 + "\u3011");
    const a2 = p2.value;
    if (a2[0] === "!str!")
      return __privateMethod2(this, _procEmbedVar, procEmbedVar_fn).call(this, a2[1]);
    return __privateMethod2(this, _calc, calc_fn).call(this, a2);
  }
  static getValName(arg_name) {
    var _a3, _b3;
    const e = __privateGet2(this, _REG_VAL).exec(arg_name.trim());
    const g2 = e == null ? void 0 : e.groups;
    if (!g2)
      return void 0;
    return {
      scope: g2.scope || "tmp",
      name: __privateMethod2(_a3 = _PropParser, _getValName_B2D, getValName_B2D_fn).call(_a3, g2.name),
      at: (_b3 = g2.at) != null ? _b3 : ""
    };
  }
};
let PropParser = _PropParser;
_parser = new WeakMap();
_calc = new WeakSet();
calc_fn = function(a2) {
  const elm = a2.shift();
  if (elm instanceof Array)
    return __privateMethod2(this, _calc, calc_fn).call(this, elm);
  const fnc = __privateGet2(this, _hFnc)[elm];
  return fnc ? fnc(a2) : Object(null);
};
_hFnc = new WeakMap();
_fncSub_ChkNum = new WeakSet();
fncSub_ChkNum_fn = function(v2) {
  const b2 = __privateMethod2(this, _calc, calc_fn).call(this, v2);
  if (Object.prototype.toString.call(b2) !== "[object Number]")
    throw Error("(PropParser)\u5F15\u6570\u3010" + b2 + "\u3011\u304C\u6570\u5024\u3067\u306F\u3042\u308A\u307E\u305B\u3093");
  return Number(b2);
};
_REG_EMBEDVAR = new WeakMap();
_procEmbedVar = new WeakSet();
procEmbedVar_fn = function(b2) {
  if (b2 == null)
    return b2;
  return String(b2).replace(__privateGet2(this, _REG_EMBEDVAR), (v2) => {
    return v2.charAt(0) === "$" ? this.val.getVal(v2.slice(1)) : this.parse(v2.slice(2, -1));
  });
};
_REG_VAL = new WeakMap();
_getValName_B2D = new WeakSet();
getValName_B2D_fn = function(str2) {
  let i2 = 0, e = 0;
  while (true) {
    i2 = str2.indexOf('["');
    if (i2 < 0) {
      i2 = str2.indexOf("['");
      if (i2 < 0)
        break;
      e = str2.indexOf("']", i2 + 2);
    } else {
      e = str2.indexOf('"]', i2 + 2);
    }
    if (e < 0)
      break;
    str2 = str2.slice(0, i2) + "." + str2.slice(i2 + 2, e) + str2.slice(e + 2);
    i2 = e - 2;
  }
  return str2;
};
__privateAdd2(PropParser, _getValName_B2D);
__privateAdd2(PropParser, _REG_VAL, /^((?<scope>\w+?):)?(?<name>[^\s :@]+)(?<at>\@str)?$/);
var __accessCheck$4 = (obj, member, msg) => {
  if (!member.has(obj))
    throw TypeError("Cannot " + msg);
};
var __privateGet$4 = (obj, member, getter) => {
  __accessCheck$4(obj, member, "read from private field");
  return getter ? getter.call(obj) : member.get(obj);
};
var __privateAdd$4 = (obj, member, value) => {
  if (member.has(obj))
    throw TypeError("Cannot add the same private member more than once");
  member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
};
var __privateSet$4 = (obj, member, value, setter) => {
  __accessCheck$4(obj, member, "write to private field");
  setter ? setter.call(obj, value) : member.set(obj, value);
  return value;
};
var __privateMethod$4 = (obj, member, method) => {
  __accessCheck$4(obj, member, "access private method");
  return method;
};
var _scrItr$1, _hTag, _title, _spnDbg, _first, _log, log_fn, _trace, trace_fn, _st_trace, st_trace_fn, _dspDbg, dspDbg_fn;
const _DebugMng = class {
  constructor(sys, hTag, scrItr) {
    this.sys = sys;
    __privateAdd$4(this, _log);
    __privateAdd$4(this, _trace);
    __privateAdd$4(this, _first, true);
    __privateSet$4(_DebugMng, _scrItr$1, scrItr);
    __privateSet$4(_DebugMng, _hTag, hTag);
    __privateSet$4(_DebugMng, _title, hTag.title);
    _DebugMng.myTrace = __privateMethod$4(_DebugMng, _st_trace, st_trace_fn);
    hTag.log = (o) => __privateMethod$4(this, _log, log_fn).call(this, o);
    hTag.trace = (o) => __privateMethod$4(this, _trace, trace_fn).call(this, o);
    __privateSet$4(_DebugMng, _spnDbg, document.createElement("span"));
    __privateGet$4(_DebugMng, _spnDbg).hidden = true;
    __privateGet$4(_DebugMng, _spnDbg).textContent = "";
    __privateGet$4(_DebugMng, _spnDbg).style.cssText = `	z-index: ${Number.MAX_SAFE_INTEGER};
			position: absolute; left: 0; top: 0;
			color: black;
			background-color: rgba(255, 255, 255, 0.7);`;
    document.body.appendChild(__privateGet$4(_DebugMng, _spnDbg));
  }
  destroy() {
    __privateSet$4(_DebugMng, _title, () => false);
    document.body.removeChild(__privateGet$4(_DebugMng, _spnDbg));
    _DebugMng.myTrace = _DebugMng.trace_beforeNew;
  }
  static trace_beforeNew(txt, lvl = "E") {
    let mes = `{${lvl}} ` + txt;
    let sty = "";
    switch (lvl) {
      case "D":
        sty = `color:#${CmnLib.isDarkMode ? "49F" : "05A"};`;
        break;
      case "W":
        sty = "color:#FF8800;";
        break;
      case "F":
        sty = "color:#BB0000;";
        break;
      case "ET":
        throw mes;
      case "E":
        console.error("%c" + mes, "color:#FF3300;");
        return;
      default:
        sty = "color:black;";
        mes = " " + mes;
    }
    console.info("%c" + mes, sty);
  }
};
let DebugMng = _DebugMng;
_scrItr$1 = /* @__PURE__ */ new WeakMap();
_hTag = /* @__PURE__ */ new WeakMap();
_title = /* @__PURE__ */ new WeakMap();
_spnDbg = /* @__PURE__ */ new WeakMap();
_first = /* @__PURE__ */ new WeakMap();
_log = /* @__PURE__ */ new WeakSet();
log_fn = function(hArg) {
  let dat = "";
  if (__privateGet$4(this, _first)) {
    __privateSet$4(this, _first, false);
    dat = `== ${platform.description} ==
`;
  }
  this.sys.appendFile(this.sys.path_downloads + "log.txt", `${dat}--- ${getDateStr("-", "_", "")} [fn:${__privateGet$4(_DebugMng, _scrItr$1).scriptFn} line:${__privateGet$4(_DebugMng, _scrItr$1).lineNum}] prj:${this.sys.cur}
${hArg.text || `(text is ${hArg.text})`}
`, (err) => {
    if (err)
      console.log(err);
  });
  return false;
};
_trace = /* @__PURE__ */ new WeakSet();
trace_fn = function(hArg) {
  _DebugMng.myTrace(hArg.text || `(text is ${hArg.text})`, "I");
  return false;
};
_st_trace = /* @__PURE__ */ new WeakSet();
st_trace_fn = function(txt, lvl = "E") {
  var _a3, _b3;
  let mes = `{${lvl}} `;
  if (__privateGet$4(_DebugMng, _scrItr$1) && __privateGet$4(_DebugMng, _scrItr$1).lineNum > 0)
    mes += `(fn:${__privateGet$4(_DebugMng, _scrItr$1).scriptFn} line:${__privateGet$4(_DebugMng, _scrItr$1).lineNum}) `;
  mes += txt;
  __privateMethod$4(_a3 = _DebugMng, _dspDbg, dspDbg_fn).call(_a3, mes, lvl);
  let sty = "";
  switch (lvl) {
    case "D":
      sty = `color:#${CmnLib.isDarkMode ? "49F" : "05A"};`;
      break;
    case "W":
      sty = "color:#F80;";
      break;
    case "F":
      sty = "color:#B00;";
      break;
    case "ET":
    case "E":
      __privateGet$4(_b3 = _DebugMng, _title).call(_b3, { text: txt });
      __privateGet$4(this, _hTag).dump_lay({});
      __privateGet$4(this, _hTag).dump_val({});
      __privateGet$4(_DebugMng, _scrItr$1).dumpErrForeLine();
      __privateGet$4(this, _hTag).dump_stack({});
      if (lvl === "ET")
        throw mes;
      console.error("%c" + mes, "color:#F30;");
      return;
    default:
      sty = "";
      mes = " " + mes;
  }
  console.info("%c" + mes, sty);
};
_dspDbg = /* @__PURE__ */ new WeakSet();
dspDbg_fn = function(mes, lvl) {
  let sty = "";
  switch (lvl) {
    case "D":
      sty = "color:#05A;";
      break;
    case "W":
      sty = "color:#F80;";
      break;
    case "F":
      sty = "color:#B00;";
      break;
    case "ET":
    case "E":
      sty = "color:#F30;";
      break;
    default:
      sty = "";
  }
  __privateGet$4(_DebugMng, _spnDbg).innerHTML += `<span style='${sty}'>${mes}</span><br/>`;
  __privateGet$4(_DebugMng, _spnDbg).hidden = false;
};
__privateAdd$4(DebugMng, _st_trace);
__privateAdd$4(DebugMng, _dspDbg);
__privateAdd$4(DebugMng, _scrItr$1, void 0);
__privateAdd$4(DebugMng, _hTag, void 0);
__privateAdd$4(DebugMng, _title, void 0);
__privateAdd$4(DebugMng, _spnDbg, void 0);
DebugMng.myTrace = _DebugMng.trace_beforeNew;
class Areas {
  constructor() {
    this.hAreas = {};
  }
  clear() {
    this.hAreas = {};
  }
  search(idx) {
    for (const begin in this.hAreas) {
      if (idx < parseInt(begin))
        continue;
      if (idx <= this.hAreas[begin])
        return true;
    }
    return false;
  }
  record(idx) {
    if (this.search(idx))
      return;
    for (const begin in this.hAreas) {
      if (this.hAreas[begin] + 1 === idx) {
        if (idx + 1 in this.hAreas) {
          this.hAreas[begin] = this.hAreas[idx + 1];
          delete this.hAreas[idx + 1];
        } else {
          this.hAreas[begin] = idx;
        }
        return;
      }
    }
    if (idx + 1 in this.hAreas) {
      this.hAreas[idx] = this.hAreas[idx + 1];
      delete this.hAreas[idx + 1];
      return;
    }
    this.hAreas[idx] = idx;
  }
  erase(idx) {
    if (!this.search(idx))
      return;
    if (idx in this.hAreas) {
      if (this.hAreas[idx] > idx)
        this.hAreas[idx + 1] = this.hAreas[idx];
      delete this.hAreas[idx];
      return;
    }
    for (const begin in this.hAreas) {
      if (idx < parseInt(begin))
        continue;
      if (this.hAreas[begin] < idx)
        continue;
      if (this.hAreas[begin] === idx) {
        this.hAreas[begin] = idx - 1;
        return;
      }
      this.hAreas[idx + 1] = this.hAreas[begin];
      this.hAreas[begin] = idx - 1;
      return;
    }
  }
  get count() {
    return Object.keys(this.hAreas).length;
  }
  toString() {
    let ret = "";
    const aBegin = [];
    for (const begin in this.hAreas)
      aBegin.push(parseInt(begin));
    aBegin.sort(function(x2, y2) {
      return x2 - y2;
    });
    aBegin.forEach((v2) => {
      ret += "," + v2 + (v2 === this.hAreas[v2]) ? "" : "~" + this.hAreas[v2];
    });
    if (ret !== "")
      ret = ret.slice(1);
    return ret;
  }
}
const _Variable = class {
  constructor(cfg, hTag) {
    __privateAdd2(this, _set_data_break);
    __privateAdd2(this, _copybookmark);
    __privateAdd2(this, _erasebookmark);
    __privateAdd2(this, _let);
    __privateAdd2(this, _let_abs);
    __privateAdd2(this, _let_char_at);
    __privateAdd2(this, _let_index_of);
    __privateAdd2(this, _let_length);
    __privateAdd2(this, _let_replace);
    __privateAdd2(this, _let_round);
    __privateAdd2(this, _let_search);
    __privateAdd2(this, _let_substr);
    __privateAdd2(this, _clearsysvar);
    __privateAdd2(this, _clearvar);
    __privateAdd2(this, _castAuto);
    __privateAdd2(this, _runFirst_Bool_hSysVal_true);
    __privateAdd2(this, _runFirst_sys_an_tagCh_msecWait);
    __privateAdd2(this, _runFirst_sys_an_tagCh_msecWait_Kidoku);
    __privateAdd2(this, _runFirst_sys_an_auto_msecPageWait);
    __privateAdd2(this, _runFirst_sys_an_auto_msecLineWait);
    __privateAdd2(this, _runFirst_Bool_hSaveVal_true);
    __privateAdd2(this, _runFirst_Bool_hTmp_true);
    __privateAdd2(this, _runFirst_Bool_hTmp_false);
    __privateAdd2(this, _hScopes, void 0);
    __privateAdd2(this, _hSave, void 0);
    __privateAdd2(this, _hTmp, void 0);
    __privateAdd2(this, _sys2, void 0);
    __privateAdd2(this, _data, void 0);
    __privateAdd2(this, _hSys, void 0);
    __privateAdd2(this, _hAreaKidoku, void 0);
    __privateAdd2(this, _callHook, void 0);
    __privateAdd2(this, _hProcDbgRes, void 0);
    __privateAdd2(this, _flush, void 0);
    __privateAdd2(this, _doRecProc, void 0);
    __privateAdd2(this, _setVal, void 0);
    __privateAdd2(this, _REG_NUMERICLITERAL, void 0);
    __privateAdd2(this, _dump_val, void 0);
    __privateAdd2(this, _doRecLog, void 0);
    __privateAdd2(this, _hValTrg, void 0);
    var _a3;
    this.cfg = cfg;
    __privateSet2(this, _hScopes, { sys: {}, save: {}, tmp: {}, mp: {} });
    __privateSet2(this, _hSave, __privateGet2(this, _hScopes).save);
    __privateSet2(this, _hTmp, __privateGet2(this, _hScopes).tmp);
    __privateSet2(this, _data, { sys: {}, mark: {}, kidoku: {} });
    __privateSet2(this, _hAreaKidoku, {});
    __privateSet2(this, _hProcDbgRes, {
      auth: (_2, o) => __privateMethod2(this, _set_data_break, set_data_break_fn).call(this, o.hBreakpoint.aData),
      var: (_2, o) => {
        var _a4;
        return __privateGet2(this, _sys2).send2Dbg(o.ri, { v: (_a4 = __privateGet2(this, _hScopes)[o.scope]) != null ? _a4 : {} });
      },
      set_var: (_2, o) => {
        try {
          __privateGet2(this, _setVal).call(this, o.nm, o.val);
          __privateGet2(this, _sys2).send2Dbg(o.ri, {});
        } catch {
        }
      },
      set_data_break: (_2, o) => {
        __privateMethod2(this, _set_data_break, set_data_break_fn).call(this, o.a);
        __privateGet2(this, _sys2).send2Dbg(o.ri, {});
      },
      disconnect: (_2) => __privateSet2(_Variable, _hSetEvent, {})
    });
    __privateSet2(this, _flush, () => {
    });
    __privateSet2(this, _doRecProc, (_doRec) => {
    });
    this.getMark = (place) => __privateGet2(this, _data).mark[place];
    this.getAreaKidoku = (fn) => __privateGet2(this, _hAreaKidoku)[fn];
    __privateSet2(this, _setVal, (arg_name, val, autocast = true) => {
      if (!arg_name)
        throw "[\u5909\u6570\u306B\u5024\u30BB\u30C3\u30C8] name\u306F\u5FC5\u9808\u3067\u3059";
      if (val == null)
        throw "[\u5909\u6570\u306B\u5024\u30BB\u30C3\u30C8] text\u306F\u5FC5\u9808\u3067\u3059\uFF08\u7A7A\u6587\u5B57\u306FOK\uFF09";
      const o = PropParser.getValName(arg_name);
      if (o === void 0)
        throw "[\u5909\u6570\u53C2\u7167] name(" + arg_name + ")\u304C\u5909\u6570\u540D\u3068\u3057\u3066\u7570\u5E38\u3067\u3059";
      const hScope = __privateGet2(this, _hScopes)[o.scope];
      if (!hScope)
        throw "[\u5909\u6570\u306B\u5024\u30BB\u30C3\u30C8] scope\u304C\u7570\u5E38\u3010" + o.scope + "\u3011\u3067\u3059";
      const nm = o["name"];
      if (nm.slice(0, 6) === "const." && nm in hScope) {
        throw "[\u5909\u6570\u306B\u5024\u30BB\u30C3\u30C8] \u5909\u6570\u3010" + nm + "\u3011\u306F\u66F8\u304D\u63DB\u3048\u4E0D\u53EF\u3067\u3059";
      }
      this.setVal_Nochk(o.scope, nm, val, autocast);
    });
    this.getVal = (arg_name, def) => {
      if (!arg_name)
        throw "[\u5909\u6570\u53C2\u7167] name\u306F\u5FC5\u9808\u3067\u3059";
      const o = PropParser.getValName(arg_name);
      if (o === void 0)
        throw "[\u5909\u6570\u53C2\u7167] name(" + arg_name + ")\u304C\u5909\u6570\u540D\u3068\u3057\u3066\u7570\u5E38\u3067\u3059";
      const hScope = __privateGet2(this, _hScopes)[o["scope"]];
      if (!hScope)
        throw "[\u5909\u6570\u53C2\u7167] scope\u304C\u7570\u5E38\u3010" + o["scope"] + "\u3011\u3067\u3059";
      const val_name = o["name"];
      let val = hScope[val_name];
      if (!(val_name in hScope)) {
        val = def;
        let nm = "";
        const aNm = val_name.split(".");
        const len = aNm.length;
        for (let i2 = 0; i2 < len; ++i2, nm += ".") {
          nm += aNm[i2];
          if (!(nm in hScope))
            continue;
          let v2 = JSON.parse(hScope[nm]);
          if (Object.prototype.toString.call(v2) !== "[object Object]") {
            if (i2 + 1 === len) {
              val = v2;
              break;
            }
            continue;
          }
          let j2 = i2;
          while (++j2 < len) {
            if (!(aNm[j2] in v2)) {
              val = def;
              break;
            }
            v2 = v2[aNm[j2]];
            if (Object.prototype.toString.call(v2) !== "[object Object]" || j2 + 1 === len) {
              val = v2;
              break;
            }
          }
          if (val instanceof Object)
            val = JSON.stringify(val);
          break;
        }
      }
      if (val instanceof Function)
        val = val();
      return o["at"] === "@str" ? val : __privateMethod2(this, _castAuto, castAuto_fn).call(this, val);
    };
    __privateSet2(this, _REG_NUMERICLITERAL, /^-?[\d\.]+$/);
    __privateSet2(this, _dump_val, () => {
      const val = { tmp: {}, sys: {}, save: {}, mp: {} };
      for (let scope in val) {
        const hVal = __privateGet2(this, _hScopes)[scope];
        const hRet = val[scope];
        for (let key in hVal) {
          const v2 = hVal[key];
          if (Object.prototype.toString.call(v2) === "[object Function]") {
            hRet[key] = v2();
          } else
            hRet[key] = v2;
        }
      }
      console.info("\u{1F95F} [dump_val]", val);
      return false;
    });
    __privateSet2(this, _doRecLog, false);
    __privateSet2(this, _hValTrg, {
      "sys:sn.tagCh.doWait": (name2) => __privateMethod2(this, _runFirst_Bool_hSysVal_true, runFirst_Bool_hSysVal_true_fn).call(this, name2),
      "sys:sn.tagCh.doWait_Kidoku": (name2) => __privateMethod2(this, _runFirst_Bool_hSysVal_true, runFirst_Bool_hSysVal_true_fn).call(this, name2),
      "sys:sn.tagCh.msecWait": (name2) => __privateMethod2(this, _runFirst_sys_an_tagCh_msecWait, runFirst_sys_an_tagCh_msecWait_fn).call(this, name2),
      "sys:sn.tagCh.msecWait_Kidoku": (name2) => __privateMethod2(this, _runFirst_sys_an_tagCh_msecWait_Kidoku, runFirst_sys_an_tagCh_msecWait_Kidoku_fn).call(this, name2),
      "sys:sn.tagCh.canskip": (name2) => __privateMethod2(this, _runFirst_Bool_hSysVal_true, runFirst_Bool_hSysVal_true_fn).call(this, name2),
      "sys:sn.auto.msecPageWait": (name2) => __privateMethod2(this, _runFirst_sys_an_auto_msecPageWait, runFirst_sys_an_auto_msecPageWait_fn).call(this, name2),
      "sys:sn.auto.msecPageWait_Kidoku": (name2) => __privateMethod2(this, _runFirst_sys_an_auto_msecPageWait, runFirst_sys_an_auto_msecPageWait_fn).call(this, name2),
      "sys:sn.auto.msecLineWait": (name2) => __privateMethod2(this, _runFirst_sys_an_auto_msecLineWait, runFirst_sys_an_auto_msecLineWait_fn).call(this, name2),
      "sys:sn.auto.msecLineWait_Kidoku": (name2) => __privateMethod2(this, _runFirst_sys_an_auto_msecLineWait, runFirst_sys_an_auto_msecLineWait_fn).call(this, name2),
      "save:sn.doRecLog": (name2) => {
        __privateGet2(this, _doRecProc).call(this, __privateSet2(this, _doRecLog, __privateMethod2(this, _runFirst_Bool_hSaveVal_true, runFirst_Bool_hSaveVal_true_fn).call(this, name2)));
      },
      "save:sn.userFnTail": (_name, val) => this.cfg.userFnTail = val,
      "tmp:sn.tagL.enabled": (name2) => __privateMethod2(this, _runFirst_Bool_hTmp_true, runFirst_Bool_hTmp_true_fn).call(this, name2),
      "tmp:sn.skip.all": (name2) => __privateMethod2(this, _runFirst_Bool_hTmp_false, runFirst_Bool_hTmp_false_fn).call(this, name2),
      "tmp:sn.skip.enabled": (name2) => __privateMethod2(this, _runFirst_Bool_hTmp_false, runFirst_Bool_hTmp_false_fn).call(this, name2),
      "tmp:sn.auto.enabled": (name2) => __privateMethod2(this, _runFirst_Bool_hTmp_false, runFirst_Bool_hTmp_false_fn).call(this, name2),
      "tmp:flash.desktop.NativeApplication.nativeApplication.systemIdleMode": () => {
      }
    });
    hTag.let = (o) => __privateMethod2(this, _let, let_fn).call(this, o);
    hTag.let_abs = (o) => __privateMethod2(this, _let_abs, let_abs_fn).call(this, o);
    hTag.let_char_at = (o) => __privateMethod2(this, _let_char_at, let_char_at_fn).call(this, o);
    hTag.let_index_of = (o) => __privateMethod2(this, _let_index_of, let_index_of_fn).call(this, o);
    hTag.let_length = (o) => __privateMethod2(this, _let_length, let_length_fn).call(this, o);
    hTag.let_replace = (o) => __privateMethod2(this, _let_replace, let_replace_fn).call(this, o);
    hTag.let_round = (o) => __privateMethod2(this, _let_round, let_round_fn).call(this, o);
    hTag.let_search = (o) => __privateMethod2(this, _let_search, let_search_fn).call(this, o);
    hTag.let_substr = (o) => __privateMethod2(this, _let_substr, let_substr_fn).call(this, o);
    hTag.clearsysvar = () => __privateMethod2(this, _clearsysvar, clearsysvar_fn).call(this);
    hTag.clearvar = () => __privateMethod2(this, _clearvar, clearvar_fn).call(this);
    hTag.dump_val = () => __privateGet2(this, _dump_val).call(this);
    hTag.copybookmark = (o) => __privateMethod2(this, _copybookmark, copybookmark_fn).call(this, o);
    hTag.erasebookmark = (o) => __privateMethod2(this, _erasebookmark, erasebookmark_fn).call(this, o);
    __privateGet2(this, _hSave)["sn.userFnTail"] = "";
    this.defTmp("const.sn.bookmark.json", () => {
      const a2 = [];
      Object.keys(__privateGet2(this, _data).mark).sort().forEach((k) => {
        const o = __spreadValues({}, __privateGet2(this, _data).mark[k].json);
        o.place = k;
        a2.push(o);
      });
      return JSON.stringify(a2);
    });
    __privateGet2(this, _hTmp)["const.sn.isFirstBoot"] = true;
    __privateGet2(this, _hTmp)["sn.tagL.enabled"] = true;
    __privateGet2(this, _hTmp)["sn.skip.all"] = false;
    __privateGet2(this, _hTmp)["sn.skip.enabled"] = false;
    __privateGet2(this, _hTmp)["sn.auto.enabled"] = false;
    __privateGet2(this, _hTmp)["const.sn.last_page_text"] = "";
    __privateGet2(this, _hTmp)["const.sn.displayState"] = false;
    __privateGet2(this, _hTmp)["const.Date.getTime"] = () => new Date().getTime();
    __privateGet2(this, _hTmp)["const.Date.getDateStr"] = () => getDateStr();
    __privateGet2(this, _hTmp)["const.sn.platform"] = JSON.stringify(platform);
    __privateMethod2(this, _clearsysvar, clearsysvar_fn).call(this);
    __privateMethod2(this, _clearvar, clearvar_fn).call(this);
    __privateGet2(this, _hTmp)["const.sn.config.window.width"] = cfg.oCfg.window.width;
    __privateGet2(this, _hTmp)["const.sn.config.window.height"] = cfg.oCfg.window.height;
    __privateGet2(this, _hTmp)["const.sn.config.book.title"] = cfg.oCfg.book.title;
    __privateGet2(this, _hTmp)["const.sn.config.book.version"] = cfg.oCfg.book.version;
    __privateGet2(this, _hTmp)["const.sn.Math.PI"] = Math.PI;
    if (typeof window === "undefined")
      return;
    const win = window;
    const ac = (_a3 = win["AudioContext"]) != null ? _a3 : win["webkitAudioContext"];
    __privateGet2(this, _hTmp)["const.sn.needClick2Play"] = () => new ac().state === "suspended";
  }
  setSys(sys) {
    __privateSet2(this, _sys2, sys);
    sys.initVal(__privateGet2(this, _data), __privateGet2(this, _hTmp), (data) => {
      this.updateData(data);
      sessionStorage.clear();
      const ns = this.cfg.getNs();
      __privateSet2(this, _flush, this.cfg.oCfg.debug.variable ? () => {
        const oSys = {};
        Object.keys(__privateGet2(this, _hSys)).forEach((k) => {
          const v2 = __privateGet2(this, _hSys)[k];
          oSys["sys:" + k] = v2 instanceof Function ? v2() : v2;
        });
        sessionStorage[ns + "sys"] = JSON.stringify(oSys);
        const oSave = {};
        Object.keys(__privateGet2(this, _hSave)).forEach((k) => {
          const v2 = __privateGet2(this, _hSave)[k];
          oSave["save:" + k] = v2 instanceof Function ? v2() : v2;
        });
        sessionStorage[ns + "save"] = JSON.stringify(oSave);
        const oTmp = {};
        Object.keys(__privateGet2(this, _hTmp)).forEach((k) => {
          const v2 = __privateGet2(this, _hTmp)[k];
          oTmp[k] = v2 instanceof Function ? v2() : v2;
        });
        sessionStorage[ns + "tmp"] = JSON.stringify(oTmp);
        const oMp = {};
        Object.keys(__privateGet2(this, _hScopes).mp).forEach((k) => {
          const v2 = __privateGet2(this, _hScopes).mp[k];
          oMp[k] = v2 instanceof Function ? v2() : v2;
        });
        sessionStorage[ns + "mp"] = JSON.stringify(oMp);
        const oMark = {};
        Object.keys(__privateGet2(this, _data).mark).forEach((k) => {
          const v2 = __privateGet2(this, _data).mark[k];
          oMark[k] = v2 instanceof Function ? v2() : v2;
        });
        sessionStorage[ns + "mark"] = JSON.stringify(oMark);
        const oKidoku = {};
        Object.keys(__privateGet2(this, _data).kidoku).forEach((k) => {
          const v2 = __privateGet2(this, _data).kidoku[k];
          oKidoku[k] = v2 instanceof Function ? v2() : v2;
        });
        sessionStorage[ns + "kidoku"] = JSON.stringify(oKidoku);
        sys.flush();
      } : () => sys.flush());
      __privateSet2(this, _callHook, (type, o) => sys.callHook(type, o));
      sys.addHook((type, o) => {
        var _a3, _b3;
        return (_b3 = (_a3 = __privateGet2(this, _hProcDbgRes))[type]) == null ? void 0 : _b3.call(_a3, type, o);
      });
      const tm = this.getVal("sys:sn.tagCh.msecWait", -1);
      if (__privateGet2(this, _hTmp)["const.sn.isFirstBoot"] || tm === -1)
        __privateMethod2(this, _clearsysvar, clearsysvar_fn).call(this);
    });
  }
  updateData(data) {
    __privateSet2(this, _data, data);
    __privateSet2(this, _hSys, __privateGet2(this, _hScopes).sys = __privateGet2(this, _data).sys);
    __privateSet2(this, _hAreaKidoku, {});
    for (const fn in __privateGet2(this, _data).kidoku) {
      const areas = new Areas();
      areas.hAreas = __spreadValues({}, __privateGet2(this, _data).kidoku[fn]);
      __privateGet2(this, _hAreaKidoku)[fn] = areas;
    }
  }
  flush() {
    __privateGet2(this, _flush).call(this);
  }
  setDoRecProc(fnc) {
    __privateSet2(this, _doRecProc, fnc);
  }
  defTmp(name2, fnc) {
    __privateGet2(this, _hTmp)[name2] = fnc;
  }
  cloneMp() {
    return __spreadValues({}, __privateGet2(this, _hScopes).mp);
  }
  setMp(mp) {
    __privateGet2(this, _hScopes).mp = mp;
  }
  setMark(place, mark) {
    __privateGet2(this, _data).mark[place] = mark;
    this.flush();
  }
  cloneSave() {
    return __spreadValues({}, __privateGet2(this, _hScopes).save);
  }
  mark2save(mark) {
    var _a3;
    __privateSet2(this, _hSave, __privateGet2(this, _hScopes).save = __spreadValues({}, mark.hSave));
    __privateSet2(this, _doRecLog, (_a3 = __privateGet2(this, _hSave)["sn.doRecLog"]) != null ? _a3 : false);
  }
  loadScrWork(fn) {
    if (!(fn in __privateGet2(this, _hAreaKidoku)))
      __privateGet2(this, _hAreaKidoku)[fn] = new Areas();
  }
  saveKidoku() {
    for (const fn in __privateGet2(this, _hAreaKidoku)) {
      __privateGet2(this, _data).kidoku[fn] = __spreadValues({}, __privateGet2(this, _hAreaKidoku)[fn].hAreas);
    }
    this.flush();
  }
  setVal_Nochk(scope, nm, val, autocast = false) {
    var _a3, _b3;
    const hScope = __privateGet2(this, _hScopes)[scope];
    if (autocast)
      val = __privateMethod2(this, _castAuto, castAuto_fn).call(this, val);
    const fullnm = scope + ":" + nm;
    if (fullnm in __privateGet2(_Variable, _hSetEvent)) {
      const old_v = hScope[nm];
      const new_v = val;
      if (old_v != new_v)
        __privateGet2(this, _callHook).call(this, "data_break", {
          dataId: fullnm,
          old_v,
          new_v
        });
    }
    hScope[nm] = val;
    (_b3 = (_a3 = __privateGet2(this, _hValTrg))[fullnm]) == null ? void 0 : _b3.call(_a3, nm, val);
  }
  doRecLog() {
    return __privateGet2(this, _doRecLog);
  }
  defValTrg(name2, fnc) {
    __privateGet2(this, _hValTrg)[name2] = fnc;
  }
};
let Variable = _Variable;
_hScopes = new WeakMap();
_hSave = new WeakMap();
_hTmp = new WeakMap();
_sys2 = new WeakMap();
_data = new WeakMap();
_hSys = new WeakMap();
_hAreaKidoku = new WeakMap();
_callHook = new WeakMap();
_hProcDbgRes = new WeakMap();
_set_data_break = new WeakSet();
set_data_break_fn = function(a2) {
  __privateSet2(_Variable, _hSetEvent, {});
  a2.forEach((v2) => __privateGet2(_Variable, _hSetEvent)[v2.dataId] = 1);
};
_flush = new WeakMap();
_doRecProc = new WeakMap();
_copybookmark = new WeakSet();
copybookmark_fn = function(hArg) {
  if (!("from" in hArg))
    throw "from\u306F\u5FC5\u9808\u3067\u3059";
  if (!("to" in hArg))
    throw "to\u306F\u5FC5\u9808\u3067\u3059";
  const from = Number(hArg.from);
  const to = Number(hArg.to);
  if (from === to)
    return false;
  if (!(from in __privateGet2(this, _data).mark))
    throw `from:${from} \u306E\u30BB\u30FC\u30D6\u30C7\u30FC\u30BF\u306F\u5B58\u5728\u3057\u307E\u305B\u3093`;
  this.setMark(to, __spreadValues({}, __privateGet2(this, _data).mark[from]));
  __privateGet2(this, _sys2).copyBMFolder(from, to);
  return false;
};
_erasebookmark = new WeakSet();
erasebookmark_fn = function(hArg) {
  const { place } = hArg;
  if (!place)
    throw "place\u306F\u5FC5\u9808\u3067\u3059";
  delete __privateGet2(this, _data).mark[place];
  this.flush();
  __privateGet2(this, _sys2).eraseBMFolder(place);
  return false;
};
_let = new WeakSet();
let_fn = function(hArg) {
  if (!hArg.name)
    throw "name\u306F\u5FC5\u9808\u3067\u3059";
  let autocast = true;
  if (hArg.cast) {
    switch (hArg.cast) {
      case "num":
        argChk_Num(hArg, "text", NaN);
        break;
      case "int":
        hArg.text = String(int(argChk_Num(hArg, "text", NaN)));
        break;
      case "uint":
        hArg.text = String(uint(argChk_Num(hArg, "text", NaN)));
        break;
      case "bool":
        argChk_Boolean(hArg, "text", false);
        break;
      case "str":
        autocast = false;
        break;
      default:
        throw "cast\u3010" + hArg.cast + "\u3011\u306F\u672A\u5B9A\u7FA9\u3067\u3059";
    }
  }
  __privateGet2(this, _setVal).call(this, hArg.name, hArg.text, autocast);
  return false;
};
_let_abs = new WeakSet();
let_abs_fn = function(hArg) {
  const n = argChk_Num(hArg, "text", 0);
  hArg.text = String(n < 0 ? -n : n);
  __privateMethod2(this, _let, let_fn).call(this, hArg);
  return false;
};
_let_char_at = new WeakSet();
let_char_at_fn = function(hArg) {
  var _a3;
  hArg.text = ((_a3 = hArg.text) != null ? _a3 : "").charAt(argChk_Num(hArg, "pos", 0));
  __privateMethod2(this, _let, let_fn).call(this, hArg);
  return false;
};
_let_index_of = new WeakSet();
let_index_of_fn = function(hArg) {
  var _a3;
  const { val } = hArg;
  if (!val)
    throw "val\u306F\u5FC5\u9808\u3067\u3059";
  const start = argChk_Num(hArg, "start", 0);
  hArg.text = String(((_a3 = hArg.text) != null ? _a3 : "").indexOf(val, start));
  __privateMethod2(this, _let, let_fn).call(this, hArg);
  return false;
};
_let_length = new WeakSet();
let_length_fn = function(hArg) {
  var _a3;
  hArg.text = String(((_a3 = hArg.text) != null ? _a3 : "").length);
  __privateMethod2(this, _let, let_fn).call(this, hArg);
  return false;
};
_let_replace = new WeakSet();
let_replace_fn = function(hArg) {
  var _a3;
  if (!hArg.reg)
    throw "reg\u306F\u5FC5\u9808\u3067\u3059";
  const { flags } = hArg;
  const reg = !flags ? new RegExp(hArg.reg) : new RegExp(hArg.reg, flags);
  hArg.text = String((_a3 = hArg.text) != null ? _a3 : "").replace(reg, String(hArg.val));
  __privateMethod2(this, _let, let_fn).call(this, hArg);
  return false;
};
_let_round = new WeakSet();
let_round_fn = function(hArg) {
  const n = argChk_Num(hArg, "text", 0);
  hArg.text = String(Math.round(n));
  __privateMethod2(this, _let, let_fn).call(this, hArg);
  return false;
};
_let_search = new WeakSet();
let_search_fn = function(hArg) {
  var _a3;
  if (!hArg.reg)
    throw "reg\u306F\u5FC5\u9808\u3067\u3059";
  const { flags } = hArg;
  const reg = !flags ? new RegExp(hArg.reg) : new RegExp(hArg.reg, flags);
  hArg.text = String(((_a3 = hArg.text) != null ? _a3 : "").search(reg));
  __privateMethod2(this, _let, let_fn).call(this, hArg);
  return false;
};
_let_substr = new WeakSet();
let_substr_fn = function(hArg) {
  var _a3, _b3;
  const i2 = argChk_Num(hArg, "pos", 0);
  hArg.text = hArg.len !== "all" ? ((_a3 = hArg.text) != null ? _a3 : "").slice(i2, i2 + int(argChk_Num(hArg, "len", 1))) : ((_b3 = hArg.text) != null ? _b3 : "").slice(i2);
  __privateMethod2(this, _let, let_fn).call(this, hArg);
  return false;
};
_clearsysvar = new WeakSet();
clearsysvar_fn = function() {
  var _a3, _b3;
  const sys = __privateSet2(this, _hSys, __privateGet2(this, _hScopes)["sys"] = __privateGet2(this, _data).sys = {});
  const is_nw = typeof process !== "undefined";
  if (is_nw)
    ;
  else {
    this.setVal_Nochk("sys", "const.sn.window.x", 0);
    this.setVal_Nochk("sys", "const.sn.window.y", 0);
  }
  this.setVal_Nochk("sys", "sn.tagCh.doWait", true);
  this.setVal_Nochk("sys", "sn.tagCh.doWait_Kidoku", true);
  this.setVal_Nochk("sys", "sn.tagCh.msecWait", this.cfg.oCfg.init.tagch_msecwait);
  this.setVal_Nochk("sys", "sn.tagCh.msecWait_Kidoku", this.cfg.oCfg.init.tagch_msecwait);
  this.setVal_Nochk("sys", "sn.tagCh.canskip", true);
  this.setVal_Nochk("sys", "sn.skip.mode", "s");
  this.setVal_Nochk("sys", "sn.auto.msecPageWait", argChk_Num(sys, "sn.auto.msecPageWait", (_a3 = this.cfg.oCfg.init.auto_msecpagewait) != null ? _a3 : 3500));
  this.setVal_Nochk("sys", "sn.auto.msecPageWait_Kidoku", argChk_Num(sys, "sn.auto.msecPageWait", (_b3 = this.cfg.oCfg.init.auto_msecpagewait) != null ? _b3 : 3500));
  this.setVal_Nochk("sys", "sn.auto.msecLineWait", 500);
  this.setVal_Nochk("sys", "sn.auto.msecLineWait_Kidoku", 500);
  this.setVal_Nochk("sys", "const.sn.sound.BGM.volume", 1);
  this.setVal_Nochk("sys", "const.sn.sound.SE.volume", 1);
  this.setVal_Nochk("sys", "const.sn.sound.SYS.volume", 1);
  for (const fn in __privateGet2(this, _data).kidoku) {
    __privateGet2(this, _data).kidoku[fn].hAreas = {};
    __privateGet2(this, _hAreaKidoku)[fn].clear();
  }
  this.setVal_Nochk("sys", "TextLayer.Back.Alpha", 0.5);
  __privateGet2(this, _hScopes)["mark"] = __privateGet2(this, _data).mark = {};
  this.setVal_Nochk("sys", "const.sn.save.place", 1);
  this.flush();
  return false;
};
_clearvar = new WeakSet();
clearvar_fn = function() {
  var _a3, _b3, _c3;
  const mesLayer = (_a3 = __privateGet2(this, _hSave)["const.sn.mesLayer"]) != null ? _a3 : "";
  const doRecLog = (_b3 = __privateGet2(this, _hSave)["sn.doRecLog"]) != null ? _b3 : false;
  const sLog = (_c3 = __privateGet2(this, _hSave)["const.sn.sLog"]) != null ? _c3 : "[]";
  __privateSet2(this, _hSave, __privateGet2(this, _hScopes).save = {});
  this.setVal_Nochk("save", "const.sn.mesLayer", mesLayer);
  this.setVal_Nochk("save", "sn.doRecLog", doRecLog);
  this.setVal_Nochk("save", "const.sn.sLog", sLog);
  return false;
};
_setVal = new WeakMap();
_hSetEvent = new WeakMap();
_castAuto = new WeakSet();
castAuto_fn = function(val) {
  const s_val = val;
  if (s_val === "true")
    return true;
  if (s_val === "false")
    return false;
  if (s_val === "null")
    return null;
  if (s_val === "undefined")
    return void 0;
  __privateGet2(this, _REG_NUMERICLITERAL).lastIndex = 0;
  if (__privateGet2(this, _REG_NUMERICLITERAL).test(s_val))
    return parseFloat(s_val);
  return val;
};
_REG_NUMERICLITERAL = new WeakMap();
_dump_val = new WeakMap();
_doRecLog = new WeakMap();
_hValTrg = new WeakMap();
_runFirst_Bool_hSysVal_true = new WeakSet();
runFirst_Bool_hSysVal_true_fn = function(name2) {
  argChk_Boolean(__privateGet2(this, _hSys), name2, true);
};
_runFirst_sys_an_tagCh_msecWait = new WeakSet();
runFirst_sys_an_tagCh_msecWait_fn = function(name2) {
  argChk_Num(__privateGet2(this, _hSys), name2, 10);
  if (__privateGet2(this, _hSys)["sn.tagCh.doWait"])
    ;
};
_runFirst_sys_an_tagCh_msecWait_Kidoku = new WeakSet();
runFirst_sys_an_tagCh_msecWait_Kidoku_fn = function(name2) {
  argChk_Num(__privateGet2(this, _hSys), name2, this.cfg.oCfg.init.tagch_msecwait === void 0 ? 10 : this.cfg.oCfg.init.tagch_msecwait);
  if (__privateGet2(this, _hSys)["sn.tagCh.doWait_Kidoku"])
    ;
};
_runFirst_sys_an_auto_msecPageWait = new WeakSet();
runFirst_sys_an_auto_msecPageWait_fn = function(name2) {
  argChk_Num(__privateGet2(this, _hSys), name2, this.cfg.oCfg.init.auto_msecpagewait === void 0 ? 3500 : this.cfg.oCfg.init.auto_msecpagewait);
};
_runFirst_sys_an_auto_msecLineWait = new WeakSet();
runFirst_sys_an_auto_msecLineWait_fn = function(name2) {
  argChk_Num(__privateGet2(this, _hSys), name2, 500);
};
_runFirst_Bool_hSaveVal_true = new WeakSet();
runFirst_Bool_hSaveVal_true_fn = function(name2) {
  return argChk_Boolean(__privateGet2(this, _hSave), name2, true);
};
_runFirst_Bool_hTmp_true = new WeakSet();
runFirst_Bool_hTmp_true_fn = function(name2) {
  argChk_Boolean(__privateGet2(this, _hTmp), name2, true);
};
_runFirst_Bool_hTmp_false = new WeakSet();
runFirst_Bool_hTmp_false_fn = function(name2) {
  argChk_Boolean(__privateGet2(this, _hTmp), name2, false);
};
__privateAdd2(Variable, _hSetEvent, {});
var Easing = {
  Linear: {
    None: function(amount) {
      return amount;
    }
  },
  Quadratic: {
    In: function(amount) {
      return amount * amount;
    },
    Out: function(amount) {
      return amount * (2 - amount);
    },
    InOut: function(amount) {
      if ((amount *= 2) < 1) {
        return 0.5 * amount * amount;
      }
      return -0.5 * (--amount * (amount - 2) - 1);
    }
  },
  Cubic: {
    In: function(amount) {
      return amount * amount * amount;
    },
    Out: function(amount) {
      return --amount * amount * amount + 1;
    },
    InOut: function(amount) {
      if ((amount *= 2) < 1) {
        return 0.5 * amount * amount * amount;
      }
      return 0.5 * ((amount -= 2) * amount * amount + 2);
    }
  },
  Quartic: {
    In: function(amount) {
      return amount * amount * amount * amount;
    },
    Out: function(amount) {
      return 1 - --amount * amount * amount * amount;
    },
    InOut: function(amount) {
      if ((amount *= 2) < 1) {
        return 0.5 * amount * amount * amount * amount;
      }
      return -0.5 * ((amount -= 2) * amount * amount * amount - 2);
    }
  },
  Quintic: {
    In: function(amount) {
      return amount * amount * amount * amount * amount;
    },
    Out: function(amount) {
      return --amount * amount * amount * amount * amount + 1;
    },
    InOut: function(amount) {
      if ((amount *= 2) < 1) {
        return 0.5 * amount * amount * amount * amount * amount;
      }
      return 0.5 * ((amount -= 2) * amount * amount * amount * amount + 2);
    }
  },
  Sinusoidal: {
    In: function(amount) {
      return 1 - Math.cos(amount * Math.PI / 2);
    },
    Out: function(amount) {
      return Math.sin(amount * Math.PI / 2);
    },
    InOut: function(amount) {
      return 0.5 * (1 - Math.cos(Math.PI * amount));
    }
  },
  Exponential: {
    In: function(amount) {
      return amount === 0 ? 0 : Math.pow(1024, amount - 1);
    },
    Out: function(amount) {
      return amount === 1 ? 1 : 1 - Math.pow(2, -10 * amount);
    },
    InOut: function(amount) {
      if (amount === 0) {
        return 0;
      }
      if (amount === 1) {
        return 1;
      }
      if ((amount *= 2) < 1) {
        return 0.5 * Math.pow(1024, amount - 1);
      }
      return 0.5 * (-Math.pow(2, -10 * (amount - 1)) + 2);
    }
  },
  Circular: {
    In: function(amount) {
      return 1 - Math.sqrt(1 - amount * amount);
    },
    Out: function(amount) {
      return Math.sqrt(1 - --amount * amount);
    },
    InOut: function(amount) {
      if ((amount *= 2) < 1) {
        return -0.5 * (Math.sqrt(1 - amount * amount) - 1);
      }
      return 0.5 * (Math.sqrt(1 - (amount -= 2) * amount) + 1);
    }
  },
  Elastic: {
    In: function(amount) {
      if (amount === 0) {
        return 0;
      }
      if (amount === 1) {
        return 1;
      }
      return -Math.pow(2, 10 * (amount - 1)) * Math.sin((amount - 1.1) * 5 * Math.PI);
    },
    Out: function(amount) {
      if (amount === 0) {
        return 0;
      }
      if (amount === 1) {
        return 1;
      }
      return Math.pow(2, -10 * amount) * Math.sin((amount - 0.1) * 5 * Math.PI) + 1;
    },
    InOut: function(amount) {
      if (amount === 0) {
        return 0;
      }
      if (amount === 1) {
        return 1;
      }
      amount *= 2;
      if (amount < 1) {
        return -0.5 * Math.pow(2, 10 * (amount - 1)) * Math.sin((amount - 1.1) * 5 * Math.PI);
      }
      return 0.5 * Math.pow(2, -10 * (amount - 1)) * Math.sin((amount - 1.1) * 5 * Math.PI) + 1;
    }
  },
  Back: {
    In: function(amount) {
      var s2 = 1.70158;
      return amount * amount * ((s2 + 1) * amount - s2);
    },
    Out: function(amount) {
      var s2 = 1.70158;
      return --amount * amount * ((s2 + 1) * amount + s2) + 1;
    },
    InOut: function(amount) {
      var s2 = 1.70158 * 1.525;
      if ((amount *= 2) < 1) {
        return 0.5 * (amount * amount * ((s2 + 1) * amount - s2));
      }
      return 0.5 * ((amount -= 2) * amount * ((s2 + 1) * amount + s2) + 2);
    }
  },
  Bounce: {
    In: function(amount) {
      return 1 - Easing.Bounce.Out(1 - amount);
    },
    Out: function(amount) {
      if (amount < 1 / 2.75) {
        return 7.5625 * amount * amount;
      } else if (amount < 2 / 2.75) {
        return 7.5625 * (amount -= 1.5 / 2.75) * amount + 0.75;
      } else if (amount < 2.5 / 2.75) {
        return 7.5625 * (amount -= 2.25 / 2.75) * amount + 0.9375;
      } else {
        return 7.5625 * (amount -= 2.625 / 2.75) * amount + 0.984375;
      }
    },
    InOut: function(amount) {
      if (amount < 0.5) {
        return Easing.Bounce.In(amount * 2) * 0.5;
      }
      return Easing.Bounce.Out(amount * 2 - 1) * 0.5 + 0.5;
    }
  }
};
var now$1;
if (typeof self === "undefined" && typeof process !== "undefined" && process.hrtime) {
  now$1 = function() {
    var time = process.hrtime();
    return time[0] * 1e3 + time[1] / 1e6;
  };
} else if (typeof self !== "undefined" && self.performance !== void 0 && self.performance.now !== void 0) {
  now$1 = self.performance.now.bind(self.performance);
} else if (Date.now !== void 0) {
  now$1 = Date.now;
} else {
  now$1 = function() {
    return new Date().getTime();
  };
}
var now$1$1 = now$1;
var Group = function() {
  function Group2() {
    this._tweens = {};
    this._tweensAddedDuringUpdate = {};
  }
  Group2.prototype.getAll = function() {
    var _this = this;
    return Object.keys(this._tweens).map(function(tweenId) {
      return _this._tweens[tweenId];
    });
  };
  Group2.prototype.removeAll = function() {
    this._tweens = {};
  };
  Group2.prototype.add = function(tween) {
    this._tweens[tween.getId()] = tween;
    this._tweensAddedDuringUpdate[tween.getId()] = tween;
  };
  Group2.prototype.remove = function(tween) {
    delete this._tweens[tween.getId()];
    delete this._tweensAddedDuringUpdate[tween.getId()];
  };
  Group2.prototype.update = function(time, preserve) {
    if (time === void 0) {
      time = now$1$1();
    }
    if (preserve === void 0) {
      preserve = false;
    }
    var tweenIds = Object.keys(this._tweens);
    if (tweenIds.length === 0) {
      return false;
    }
    while (tweenIds.length > 0) {
      this._tweensAddedDuringUpdate = {};
      for (var i2 = 0; i2 < tweenIds.length; i2++) {
        var tween = this._tweens[tweenIds[i2]];
        var autoStart = !preserve;
        if (tween && tween.update(time, autoStart) === false && !preserve) {
          delete this._tweens[tweenIds[i2]];
        }
      }
      tweenIds = Object.keys(this._tweensAddedDuringUpdate);
    }
    return true;
  };
  return Group2;
}();
var Interpolation = {
  Linear: function(v2, k) {
    var m2 = v2.length - 1;
    var f2 = m2 * k;
    var i2 = Math.floor(f2);
    var fn = Interpolation.Utils.Linear;
    if (k < 0) {
      return fn(v2[0], v2[1], f2);
    }
    if (k > 1) {
      return fn(v2[m2], v2[m2 - 1], m2 - f2);
    }
    return fn(v2[i2], v2[i2 + 1 > m2 ? m2 : i2 + 1], f2 - i2);
  },
  Bezier: function(v2, k) {
    var b2 = 0;
    var n = v2.length - 1;
    var pw = Math.pow;
    var bn = Interpolation.Utils.Bernstein;
    for (var i2 = 0; i2 <= n; i2++) {
      b2 += pw(1 - k, n - i2) * pw(k, i2) * v2[i2] * bn(n, i2);
    }
    return b2;
  },
  CatmullRom: function(v2, k) {
    var m2 = v2.length - 1;
    var f2 = m2 * k;
    var i2 = Math.floor(f2);
    var fn = Interpolation.Utils.CatmullRom;
    if (v2[0] === v2[m2]) {
      if (k < 0) {
        i2 = Math.floor(f2 = m2 * (1 + k));
      }
      return fn(v2[(i2 - 1 + m2) % m2], v2[i2], v2[(i2 + 1) % m2], v2[(i2 + 2) % m2], f2 - i2);
    } else {
      if (k < 0) {
        return v2[0] - (fn(v2[0], v2[0], v2[1], v2[1], -f2) - v2[0]);
      }
      if (k > 1) {
        return v2[m2] - (fn(v2[m2], v2[m2], v2[m2 - 1], v2[m2 - 1], f2 - m2) - v2[m2]);
      }
      return fn(v2[i2 ? i2 - 1 : 0], v2[i2], v2[m2 < i2 + 1 ? m2 : i2 + 1], v2[m2 < i2 + 2 ? m2 : i2 + 2], f2 - i2);
    }
  },
  Utils: {
    Linear: function(p0, p1, t) {
      return (p1 - p0) * t + p0;
    },
    Bernstein: function(n, i2) {
      var fc = Interpolation.Utils.Factorial;
      return fc(n) / fc(i2) / fc(n - i2);
    },
    Factorial: function() {
      var a2 = [1];
      return function(n) {
        var s2 = 1;
        if (a2[n]) {
          return a2[n];
        }
        for (var i2 = n; i2 > 1; i2--) {
          s2 *= i2;
        }
        a2[n] = s2;
        return s2;
      };
    }(),
    CatmullRom: function(p0, p1, p2, p3, t) {
      var v0 = (p2 - p0) * 0.5;
      var v1 = (p3 - p1) * 0.5;
      var t2 = t * t;
      var t3 = t * t2;
      return (2 * p1 - 2 * p2 + v0 + v1) * t3 + (-3 * p1 + 3 * p2 - 2 * v0 - v1) * t2 + v0 * t + p1;
    }
  }
};
var Sequence = function() {
  function Sequence2() {
  }
  Sequence2.nextId = function() {
    return Sequence2._nextId++;
  };
  Sequence2._nextId = 0;
  return Sequence2;
}();
var mainGroup = new Group();
var Tween = function() {
  function Tween2(_object, _group) {
    if (_group === void 0) {
      _group = mainGroup;
    }
    this._object = _object;
    this._group = _group;
    this._isPaused = false;
    this._pauseStart = 0;
    this._valuesStart = {};
    this._valuesEnd = {};
    this._valuesStartRepeat = {};
    this._duration = 1e3;
    this._initialRepeat = 0;
    this._repeat = 0;
    this._yoyo = false;
    this._isPlaying = false;
    this._reversed = false;
    this._delayTime = 0;
    this._startTime = 0;
    this._easingFunction = Easing.Linear.None;
    this._interpolationFunction = Interpolation.Linear;
    this._chainedTweens = [];
    this._onStartCallbackFired = false;
    this._id = Sequence.nextId();
    this._isChainStopped = false;
    this._goToEnd = false;
  }
  Tween2.prototype.getId = function() {
    return this._id;
  };
  Tween2.prototype.isPlaying = function() {
    return this._isPlaying;
  };
  Tween2.prototype.isPaused = function() {
    return this._isPaused;
  };
  Tween2.prototype.to = function(properties, duration) {
    this._valuesEnd = Object.create(properties);
    if (duration !== void 0) {
      this._duration = duration;
    }
    return this;
  };
  Tween2.prototype.duration = function(d2) {
    this._duration = d2;
    return this;
  };
  Tween2.prototype.start = function(time) {
    if (this._isPlaying) {
      return this;
    }
    this._group && this._group.add(this);
    this._repeat = this._initialRepeat;
    if (this._reversed) {
      this._reversed = false;
      for (var property in this._valuesStartRepeat) {
        this._swapEndStartRepeatValues(property);
        this._valuesStart[property] = this._valuesStartRepeat[property];
      }
    }
    this._isPlaying = true;
    this._isPaused = false;
    this._onStartCallbackFired = false;
    this._isChainStopped = false;
    this._startTime = time !== void 0 ? typeof time === "string" ? now$1$1() + parseFloat(time) : time : now$1$1();
    this._startTime += this._delayTime;
    this._setupProperties(this._object, this._valuesStart, this._valuesEnd, this._valuesStartRepeat);
    return this;
  };
  Tween2.prototype._setupProperties = function(_object, _valuesStart, _valuesEnd, _valuesStartRepeat) {
    for (var property in _valuesEnd) {
      var startValue = _object[property];
      var startValueIsArray = Array.isArray(startValue);
      var propType = startValueIsArray ? "array" : typeof startValue;
      var isInterpolationList = !startValueIsArray && Array.isArray(_valuesEnd[property]);
      if (propType === "undefined" || propType === "function") {
        continue;
      }
      if (isInterpolationList) {
        var endValues = _valuesEnd[property];
        if (endValues.length === 0) {
          continue;
        }
        endValues = endValues.map(this._handleRelativeValue.bind(this, startValue));
        _valuesEnd[property] = [startValue].concat(endValues);
      }
      if ((propType === "object" || startValueIsArray) && startValue && !isInterpolationList) {
        _valuesStart[property] = startValueIsArray ? [] : {};
        for (var prop in startValue) {
          _valuesStart[property][prop] = startValue[prop];
        }
        _valuesStartRepeat[property] = startValueIsArray ? [] : {};
        this._setupProperties(startValue, _valuesStart[property], _valuesEnd[property], _valuesStartRepeat[property]);
      } else {
        if (typeof _valuesStart[property] === "undefined") {
          _valuesStart[property] = startValue;
        }
        if (!startValueIsArray) {
          _valuesStart[property] *= 1;
        }
        if (isInterpolationList) {
          _valuesStartRepeat[property] = _valuesEnd[property].slice().reverse();
        } else {
          _valuesStartRepeat[property] = _valuesStart[property] || 0;
        }
      }
    }
  };
  Tween2.prototype.stop = function() {
    if (!this._isChainStopped) {
      this._isChainStopped = true;
      this.stopChainedTweens();
    }
    if (!this._isPlaying) {
      return this;
    }
    this._group && this._group.remove(this);
    this._isPlaying = false;
    this._isPaused = false;
    if (this._onStopCallback) {
      this._onStopCallback(this._object);
    }
    return this;
  };
  Tween2.prototype.end = function() {
    this._goToEnd = true;
    this.update(Infinity);
    return this;
  };
  Tween2.prototype.pause = function(time) {
    if (time === void 0) {
      time = now$1$1();
    }
    if (this._isPaused || !this._isPlaying) {
      return this;
    }
    this._isPaused = true;
    this._pauseStart = time;
    this._group && this._group.remove(this);
    return this;
  };
  Tween2.prototype.resume = function(time) {
    if (time === void 0) {
      time = now$1$1();
    }
    if (!this._isPaused || !this._isPlaying) {
      return this;
    }
    this._isPaused = false;
    this._startTime += time - this._pauseStart;
    this._pauseStart = 0;
    this._group && this._group.add(this);
    return this;
  };
  Tween2.prototype.stopChainedTweens = function() {
    for (var i2 = 0, numChainedTweens = this._chainedTweens.length; i2 < numChainedTweens; i2++) {
      this._chainedTweens[i2].stop();
    }
    return this;
  };
  Tween2.prototype.group = function(group) {
    this._group = group;
    return this;
  };
  Tween2.prototype.delay = function(amount) {
    this._delayTime = amount;
    return this;
  };
  Tween2.prototype.repeat = function(times) {
    this._initialRepeat = times;
    this._repeat = times;
    return this;
  };
  Tween2.prototype.repeatDelay = function(amount) {
    this._repeatDelayTime = amount;
    return this;
  };
  Tween2.prototype.yoyo = function(yoyo) {
    this._yoyo = yoyo;
    return this;
  };
  Tween2.prototype.easing = function(easingFunction) {
    this._easingFunction = easingFunction;
    return this;
  };
  Tween2.prototype.interpolation = function(interpolationFunction) {
    this._interpolationFunction = interpolationFunction;
    return this;
  };
  Tween2.prototype.chain = function() {
    var tweens = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      tweens[_i] = arguments[_i];
    }
    this._chainedTweens = tweens;
    return this;
  };
  Tween2.prototype.onStart = function(callback) {
    this._onStartCallback = callback;
    return this;
  };
  Tween2.prototype.onUpdate = function(callback) {
    this._onUpdateCallback = callback;
    return this;
  };
  Tween2.prototype.onRepeat = function(callback) {
    this._onRepeatCallback = callback;
    return this;
  };
  Tween2.prototype.onComplete = function(callback) {
    this._onCompleteCallback = callback;
    return this;
  };
  Tween2.prototype.onStop = function(callback) {
    this._onStopCallback = callback;
    return this;
  };
  Tween2.prototype.update = function(time, autoStart) {
    if (time === void 0) {
      time = now$1$1();
    }
    if (autoStart === void 0) {
      autoStart = true;
    }
    if (this._isPaused)
      return true;
    var property;
    var elapsed;
    var endTime = this._startTime + this._duration;
    if (!this._goToEnd && !this._isPlaying) {
      if (time > endTime)
        return false;
      if (autoStart)
        this.start(time);
    }
    this._goToEnd = false;
    if (time < this._startTime) {
      return true;
    }
    if (this._onStartCallbackFired === false) {
      if (this._onStartCallback) {
        this._onStartCallback(this._object);
      }
      this._onStartCallbackFired = true;
    }
    elapsed = (time - this._startTime) / this._duration;
    elapsed = this._duration === 0 || elapsed > 1 ? 1 : elapsed;
    var value = this._easingFunction(elapsed);
    this._updateProperties(this._object, this._valuesStart, this._valuesEnd, value);
    if (this._onUpdateCallback) {
      this._onUpdateCallback(this._object, elapsed);
    }
    if (elapsed === 1) {
      if (this._repeat > 0) {
        if (isFinite(this._repeat)) {
          this._repeat--;
        }
        for (property in this._valuesStartRepeat) {
          if (!this._yoyo && typeof this._valuesEnd[property] === "string") {
            this._valuesStartRepeat[property] = this._valuesStartRepeat[property] + parseFloat(this._valuesEnd[property]);
          }
          if (this._yoyo) {
            this._swapEndStartRepeatValues(property);
          }
          this._valuesStart[property] = this._valuesStartRepeat[property];
        }
        if (this._yoyo) {
          this._reversed = !this._reversed;
        }
        if (this._repeatDelayTime !== void 0) {
          this._startTime = time + this._repeatDelayTime;
        } else {
          this._startTime = time + this._delayTime;
        }
        if (this._onRepeatCallback) {
          this._onRepeatCallback(this._object);
        }
        return true;
      } else {
        if (this._onCompleteCallback) {
          this._onCompleteCallback(this._object);
        }
        for (var i2 = 0, numChainedTweens = this._chainedTweens.length; i2 < numChainedTweens; i2++) {
          this._chainedTweens[i2].start(this._startTime + this._duration);
        }
        this._isPlaying = false;
        return false;
      }
    }
    return true;
  };
  Tween2.prototype._updateProperties = function(_object, _valuesStart, _valuesEnd, value) {
    for (var property in _valuesEnd) {
      if (_valuesStart[property] === void 0) {
        continue;
      }
      var start = _valuesStart[property] || 0;
      var end = _valuesEnd[property];
      var startIsArray = Array.isArray(_object[property]);
      var endIsArray = Array.isArray(end);
      var isInterpolationList = !startIsArray && endIsArray;
      if (isInterpolationList) {
        _object[property] = this._interpolationFunction(end, value);
      } else if (typeof end === "object" && end) {
        this._updateProperties(_object[property], start, end, value);
      } else {
        end = this._handleRelativeValue(start, end);
        if (typeof end === "number") {
          _object[property] = start + (end - start) * value;
        }
      }
    }
  };
  Tween2.prototype._handleRelativeValue = function(start, end) {
    if (typeof end !== "string") {
      return end;
    }
    if (end.charAt(0) === "+" || end.charAt(0) === "-") {
      return start + parseFloat(end);
    } else {
      return parseFloat(end);
    }
  };
  Tween2.prototype._swapEndStartRepeatValues = function(property) {
    var tmp = this._valuesStartRepeat[property];
    var endValue = this._valuesEnd[property];
    if (typeof endValue === "string") {
      this._valuesStartRepeat[property] = this._valuesStartRepeat[property] + parseFloat(endValue);
    } else {
      this._valuesStartRepeat[property] = this._valuesEnd[property];
    }
    this._valuesEnd[property] = tmp;
  };
  return Tween2;
}();
var TWEEN = mainGroup;
TWEEN.getAll.bind(TWEEN);
var removeAll = TWEEN.removeAll.bind(TWEEN);
TWEEN.add.bind(TWEEN);
TWEEN.remove.bind(TWEEN);
var update = TWEEN.update.bind(TWEEN);
const _CmnTween = class {
  static ease(nm) {
    if (!nm)
      return (k) => Easing.Linear.None(k);
    if (!(nm in __privateGet2(_CmnTween, _hEase)))
      throw "\u7570\u5E38\u306Aease\u6307\u5B9A\u3067\u3059";
    return __privateGet2(_CmnTween, _hEase)[nm];
  }
};
let CmnTween = _CmnTween;
_hEase = new WeakMap();
__privateAdd2(CmnTween, _hEase, {
  "Back.In": (k) => Easing.Back.In(k),
  "Back.InOut": (k) => Easing.Back.InOut(k),
  "Back.Out": (k) => Easing.Back.Out(k),
  "Bounce.In": (k) => Easing.Bounce.In(k),
  "Bounce.InOut": (k) => Easing.Bounce.InOut(k),
  "Bounce.Out": (k) => Easing.Bounce.Out(k),
  "Circular.In": (k) => Easing.Circular.In(k),
  "Circular.InOut": (k) => Easing.Circular.InOut(k),
  "Circular.Out": (k) => Easing.Circular.Out(k),
  "Cubic.In": (k) => Easing.Cubic.In(k),
  "Cubic.InOut": (k) => Easing.Cubic.InOut(k),
  "Cubic.Out": (k) => Easing.Cubic.Out(k),
  "Elastic.In": (k) => Easing.Elastic.In(k),
  "Elastic.InOut": (k) => Easing.Elastic.InOut(k),
  "Elastic.Out": (k) => Easing.Elastic.Out(k),
  "Exponential.In": (k) => Easing.Exponential.In(k),
  "Exponential.InOut": (k) => Easing.Exponential.InOut(k),
  "Exponential.Out": (k) => Easing.Exponential.Out(k),
  "Linear.None": (k) => Easing.Linear.None(k),
  "Quadratic.In": (k) => Easing.Quadratic.In(k),
  "Quadratic.InOut": (k) => Easing.Quadratic.InOut(k),
  "Quadratic.Out": (k) => Easing.Quadratic.Out(k),
  "Quartic.In": (k) => Easing.Quartic.In(k),
  "Quartic.InOut": (k) => Easing.Quartic.InOut(k),
  "Quartic.Out": (k) => Easing.Quartic.Out(k),
  "Quintic.In": (k) => Easing.Quintic.In(k),
  "Quintic.InOut": (k) => Easing.Quintic.InOut(k),
  "Quintic.Out": (k) => Easing.Quintic.Out(k),
  "Sinusoidal.In": (k) => Easing.Sinusoidal.In(k),
  "Sinusoidal.InOut": (k) => Easing.Sinusoidal.InOut(k),
  "Sinusoidal.Out": (k) => Easing.Sinusoidal.Out(k)
});
var appleIphone = /iPhone/i;
var appleIpod = /iPod/i;
var appleTablet = /iPad/i;
var appleUniversal = /\biOS-universal(?:.+)Mac\b/i;
var androidPhone = /\bAndroid(?:.+)Mobile\b/i;
var androidTablet = /Android/i;
var amazonPhone = /(?:SD4930UR|\bSilk(?:.+)Mobile\b)/i;
var amazonTablet = /Silk/i;
var windowsPhone = /Windows Phone/i;
var windowsTablet = /\bWindows(?:.+)ARM\b/i;
var otherBlackBerry = /BlackBerry/i;
var otherBlackBerry10 = /BB10/i;
var otherOpera = /Opera Mini/i;
var otherChrome = /\b(CriOS|Chrome)(?:.+)Mobile/i;
var otherFirefox = /Mobile(?:.+)Firefox\b/i;
var isAppleTabletOnIos13 = function(navigator2) {
  return typeof navigator2 !== "undefined" && navigator2.platform === "MacIntel" && typeof navigator2.maxTouchPoints === "number" && navigator2.maxTouchPoints > 1 && typeof MSStream === "undefined";
};
function createMatch(userAgent) {
  return function(regex) {
    return regex.test(userAgent);
  };
}
function isMobile$1(param) {
  var nav = {
    userAgent: "",
    platform: "",
    maxTouchPoints: 0
  };
  if (!param && typeof navigator !== "undefined") {
    nav = {
      userAgent: navigator.userAgent,
      platform: navigator.platform,
      maxTouchPoints: navigator.maxTouchPoints || 0
    };
  } else if (typeof param === "string") {
    nav.userAgent = param;
  } else if (param && param.userAgent) {
    nav = {
      userAgent: param.userAgent,
      platform: param.platform,
      maxTouchPoints: param.maxTouchPoints || 0
    };
  }
  var userAgent = nav.userAgent;
  var tmp = userAgent.split("[FBAN");
  if (typeof tmp[1] !== "undefined") {
    userAgent = tmp[0];
  }
  tmp = userAgent.split("Twitter");
  if (typeof tmp[1] !== "undefined") {
    userAgent = tmp[0];
  }
  var match = createMatch(userAgent);
  var result = {
    apple: {
      phone: match(appleIphone) && !match(windowsPhone),
      ipod: match(appleIpod),
      tablet: !match(appleIphone) && (match(appleTablet) || isAppleTabletOnIos13(nav)) && !match(windowsPhone),
      universal: match(appleUniversal),
      device: (match(appleIphone) || match(appleIpod) || match(appleTablet) || match(appleUniversal) || isAppleTabletOnIos13(nav)) && !match(windowsPhone)
    },
    amazon: {
      phone: match(amazonPhone),
      tablet: !match(amazonPhone) && match(amazonTablet),
      device: match(amazonPhone) || match(amazonTablet)
    },
    android: {
      phone: !match(windowsPhone) && match(amazonPhone) || !match(windowsPhone) && match(androidPhone),
      tablet: !match(windowsPhone) && !match(amazonPhone) && !match(androidPhone) && (match(amazonTablet) || match(androidTablet)),
      device: !match(windowsPhone) && (match(amazonPhone) || match(amazonTablet) || match(androidPhone) || match(androidTablet)) || match(/\bokhttp\b/i)
    },
    windows: {
      phone: match(windowsPhone),
      tablet: match(windowsTablet),
      device: match(windowsPhone) || match(windowsTablet)
    },
    other: {
      blackberry: match(otherBlackBerry),
      blackberry10: match(otherBlackBerry10),
      opera: match(otherOpera),
      firefox: match(otherFirefox),
      chrome: match(otherChrome),
      device: match(otherBlackBerry) || match(otherBlackBerry10) || match(otherOpera) || match(otherFirefox) || match(otherChrome)
    },
    any: false,
    phone: false,
    tablet: false
  };
  result.any = result.apple.device || result.android.device || result.windows.device || result.other.device;
  result.phone = result.apple.phone || result.android.phone || result.windows.phone;
  result.tablet = result.apple.tablet || result.android.tablet || result.windows.tablet;
  return result;
}
/*!
 * @pixi/settings - v6.3.0
 * Compiled Wed, 23 Mar 2022 18:58:56 UTC
 *
 * @pixi/settings is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
var isMobile = isMobile$1(globalThis.navigator);
function maxRecommendedTextures(max) {
  var allowMax = true;
  if (isMobile.tablet || isMobile.phone) {
    if (isMobile.apple.device) {
      var match = navigator.userAgent.match(/OS (\d+)_(\d+)?/);
      if (match) {
        var majorVersion = parseInt(match[1], 10);
        if (majorVersion < 11) {
          allowMax = false;
        }
      }
    }
    if (isMobile.android.device) {
      var match = navigator.userAgent.match(/Android\s([0-9.]*)/);
      if (match) {
        var majorVersion = parseInt(match[1], 10);
        if (majorVersion < 7) {
          allowMax = false;
        }
      }
    }
  }
  return allowMax ? max : 4;
}
function canUploadSameBuffer() {
  return !isMobile.apple.device;
}
/*!
 * @pixi/constants - v6.3.0
 * Compiled Wed, 23 Mar 2022 18:58:56 UTC
 *
 * @pixi/constants is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
var ENV$4;
(function(ENV2) {
  ENV2[ENV2["WEBGL_LEGACY"] = 0] = "WEBGL_LEGACY";
  ENV2[ENV2["WEBGL"] = 1] = "WEBGL";
  ENV2[ENV2["WEBGL2"] = 2] = "WEBGL2";
})(ENV$4 || (ENV$4 = {}));
var RENDERER_TYPE$4;
(function(RENDERER_TYPE2) {
  RENDERER_TYPE2[RENDERER_TYPE2["UNKNOWN"] = 0] = "UNKNOWN";
  RENDERER_TYPE2[RENDERER_TYPE2["WEBGL"] = 1] = "WEBGL";
  RENDERER_TYPE2[RENDERER_TYPE2["CANVAS"] = 2] = "CANVAS";
})(RENDERER_TYPE$4 || (RENDERER_TYPE$4 = {}));
var BUFFER_BITS$4;
(function(BUFFER_BITS2) {
  BUFFER_BITS2[BUFFER_BITS2["COLOR"] = 16384] = "COLOR";
  BUFFER_BITS2[BUFFER_BITS2["DEPTH"] = 256] = "DEPTH";
  BUFFER_BITS2[BUFFER_BITS2["STENCIL"] = 1024] = "STENCIL";
})(BUFFER_BITS$4 || (BUFFER_BITS$4 = {}));
var BLEND_MODES$4;
(function(BLEND_MODES2) {
  BLEND_MODES2[BLEND_MODES2["NORMAL"] = 0] = "NORMAL";
  BLEND_MODES2[BLEND_MODES2["ADD"] = 1] = "ADD";
  BLEND_MODES2[BLEND_MODES2["MULTIPLY"] = 2] = "MULTIPLY";
  BLEND_MODES2[BLEND_MODES2["SCREEN"] = 3] = "SCREEN";
  BLEND_MODES2[BLEND_MODES2["OVERLAY"] = 4] = "OVERLAY";
  BLEND_MODES2[BLEND_MODES2["DARKEN"] = 5] = "DARKEN";
  BLEND_MODES2[BLEND_MODES2["LIGHTEN"] = 6] = "LIGHTEN";
  BLEND_MODES2[BLEND_MODES2["COLOR_DODGE"] = 7] = "COLOR_DODGE";
  BLEND_MODES2[BLEND_MODES2["COLOR_BURN"] = 8] = "COLOR_BURN";
  BLEND_MODES2[BLEND_MODES2["HARD_LIGHT"] = 9] = "HARD_LIGHT";
  BLEND_MODES2[BLEND_MODES2["SOFT_LIGHT"] = 10] = "SOFT_LIGHT";
  BLEND_MODES2[BLEND_MODES2["DIFFERENCE"] = 11] = "DIFFERENCE";
  BLEND_MODES2[BLEND_MODES2["EXCLUSION"] = 12] = "EXCLUSION";
  BLEND_MODES2[BLEND_MODES2["HUE"] = 13] = "HUE";
  BLEND_MODES2[BLEND_MODES2["SATURATION"] = 14] = "SATURATION";
  BLEND_MODES2[BLEND_MODES2["COLOR"] = 15] = "COLOR";
  BLEND_MODES2[BLEND_MODES2["LUMINOSITY"] = 16] = "LUMINOSITY";
  BLEND_MODES2[BLEND_MODES2["NORMAL_NPM"] = 17] = "NORMAL_NPM";
  BLEND_MODES2[BLEND_MODES2["ADD_NPM"] = 18] = "ADD_NPM";
  BLEND_MODES2[BLEND_MODES2["SCREEN_NPM"] = 19] = "SCREEN_NPM";
  BLEND_MODES2[BLEND_MODES2["NONE"] = 20] = "NONE";
  BLEND_MODES2[BLEND_MODES2["SRC_OVER"] = 0] = "SRC_OVER";
  BLEND_MODES2[BLEND_MODES2["SRC_IN"] = 21] = "SRC_IN";
  BLEND_MODES2[BLEND_MODES2["SRC_OUT"] = 22] = "SRC_OUT";
  BLEND_MODES2[BLEND_MODES2["SRC_ATOP"] = 23] = "SRC_ATOP";
  BLEND_MODES2[BLEND_MODES2["DST_OVER"] = 24] = "DST_OVER";
  BLEND_MODES2[BLEND_MODES2["DST_IN"] = 25] = "DST_IN";
  BLEND_MODES2[BLEND_MODES2["DST_OUT"] = 26] = "DST_OUT";
  BLEND_MODES2[BLEND_MODES2["DST_ATOP"] = 27] = "DST_ATOP";
  BLEND_MODES2[BLEND_MODES2["ERASE"] = 26] = "ERASE";
  BLEND_MODES2[BLEND_MODES2["SUBTRACT"] = 28] = "SUBTRACT";
  BLEND_MODES2[BLEND_MODES2["XOR"] = 29] = "XOR";
})(BLEND_MODES$4 || (BLEND_MODES$4 = {}));
var DRAW_MODES$4;
(function(DRAW_MODES2) {
  DRAW_MODES2[DRAW_MODES2["POINTS"] = 0] = "POINTS";
  DRAW_MODES2[DRAW_MODES2["LINES"] = 1] = "LINES";
  DRAW_MODES2[DRAW_MODES2["LINE_LOOP"] = 2] = "LINE_LOOP";
  DRAW_MODES2[DRAW_MODES2["LINE_STRIP"] = 3] = "LINE_STRIP";
  DRAW_MODES2[DRAW_MODES2["TRIANGLES"] = 4] = "TRIANGLES";
  DRAW_MODES2[DRAW_MODES2["TRIANGLE_STRIP"] = 5] = "TRIANGLE_STRIP";
  DRAW_MODES2[DRAW_MODES2["TRIANGLE_FAN"] = 6] = "TRIANGLE_FAN";
})(DRAW_MODES$4 || (DRAW_MODES$4 = {}));
var FORMATS$4;
(function(FORMATS2) {
  FORMATS2[FORMATS2["RGBA"] = 6408] = "RGBA";
  FORMATS2[FORMATS2["RGB"] = 6407] = "RGB";
  FORMATS2[FORMATS2["RG"] = 33319] = "RG";
  FORMATS2[FORMATS2["RED"] = 6403] = "RED";
  FORMATS2[FORMATS2["RGBA_INTEGER"] = 36249] = "RGBA_INTEGER";
  FORMATS2[FORMATS2["RGB_INTEGER"] = 36248] = "RGB_INTEGER";
  FORMATS2[FORMATS2["RG_INTEGER"] = 33320] = "RG_INTEGER";
  FORMATS2[FORMATS2["RED_INTEGER"] = 36244] = "RED_INTEGER";
  FORMATS2[FORMATS2["ALPHA"] = 6406] = "ALPHA";
  FORMATS2[FORMATS2["LUMINANCE"] = 6409] = "LUMINANCE";
  FORMATS2[FORMATS2["LUMINANCE_ALPHA"] = 6410] = "LUMINANCE_ALPHA";
  FORMATS2[FORMATS2["DEPTH_COMPONENT"] = 6402] = "DEPTH_COMPONENT";
  FORMATS2[FORMATS2["DEPTH_STENCIL"] = 34041] = "DEPTH_STENCIL";
})(FORMATS$4 || (FORMATS$4 = {}));
var TARGETS$4;
(function(TARGETS2) {
  TARGETS2[TARGETS2["TEXTURE_2D"] = 3553] = "TEXTURE_2D";
  TARGETS2[TARGETS2["TEXTURE_CUBE_MAP"] = 34067] = "TEXTURE_CUBE_MAP";
  TARGETS2[TARGETS2["TEXTURE_2D_ARRAY"] = 35866] = "TEXTURE_2D_ARRAY";
  TARGETS2[TARGETS2["TEXTURE_CUBE_MAP_POSITIVE_X"] = 34069] = "TEXTURE_CUBE_MAP_POSITIVE_X";
  TARGETS2[TARGETS2["TEXTURE_CUBE_MAP_NEGATIVE_X"] = 34070] = "TEXTURE_CUBE_MAP_NEGATIVE_X";
  TARGETS2[TARGETS2["TEXTURE_CUBE_MAP_POSITIVE_Y"] = 34071] = "TEXTURE_CUBE_MAP_POSITIVE_Y";
  TARGETS2[TARGETS2["TEXTURE_CUBE_MAP_NEGATIVE_Y"] = 34072] = "TEXTURE_CUBE_MAP_NEGATIVE_Y";
  TARGETS2[TARGETS2["TEXTURE_CUBE_MAP_POSITIVE_Z"] = 34073] = "TEXTURE_CUBE_MAP_POSITIVE_Z";
  TARGETS2[TARGETS2["TEXTURE_CUBE_MAP_NEGATIVE_Z"] = 34074] = "TEXTURE_CUBE_MAP_NEGATIVE_Z";
})(TARGETS$4 || (TARGETS$4 = {}));
var TYPES$4;
(function(TYPES2) {
  TYPES2[TYPES2["UNSIGNED_BYTE"] = 5121] = "UNSIGNED_BYTE";
  TYPES2[TYPES2["UNSIGNED_SHORT"] = 5123] = "UNSIGNED_SHORT";
  TYPES2[TYPES2["UNSIGNED_SHORT_5_6_5"] = 33635] = "UNSIGNED_SHORT_5_6_5";
  TYPES2[TYPES2["UNSIGNED_SHORT_4_4_4_4"] = 32819] = "UNSIGNED_SHORT_4_4_4_4";
  TYPES2[TYPES2["UNSIGNED_SHORT_5_5_5_1"] = 32820] = "UNSIGNED_SHORT_5_5_5_1";
  TYPES2[TYPES2["UNSIGNED_INT"] = 5125] = "UNSIGNED_INT";
  TYPES2[TYPES2["UNSIGNED_INT_10F_11F_11F_REV"] = 35899] = "UNSIGNED_INT_10F_11F_11F_REV";
  TYPES2[TYPES2["UNSIGNED_INT_2_10_10_10_REV"] = 33640] = "UNSIGNED_INT_2_10_10_10_REV";
  TYPES2[TYPES2["UNSIGNED_INT_24_8"] = 34042] = "UNSIGNED_INT_24_8";
  TYPES2[TYPES2["UNSIGNED_INT_5_9_9_9_REV"] = 35902] = "UNSIGNED_INT_5_9_9_9_REV";
  TYPES2[TYPES2["BYTE"] = 5120] = "BYTE";
  TYPES2[TYPES2["SHORT"] = 5122] = "SHORT";
  TYPES2[TYPES2["INT"] = 5124] = "INT";
  TYPES2[TYPES2["FLOAT"] = 5126] = "FLOAT";
  TYPES2[TYPES2["FLOAT_32_UNSIGNED_INT_24_8_REV"] = 36269] = "FLOAT_32_UNSIGNED_INT_24_8_REV";
  TYPES2[TYPES2["HALF_FLOAT"] = 36193] = "HALF_FLOAT";
})(TYPES$4 || (TYPES$4 = {}));
var SAMPLER_TYPES$4;
(function(SAMPLER_TYPES2) {
  SAMPLER_TYPES2[SAMPLER_TYPES2["FLOAT"] = 0] = "FLOAT";
  SAMPLER_TYPES2[SAMPLER_TYPES2["INT"] = 1] = "INT";
  SAMPLER_TYPES2[SAMPLER_TYPES2["UINT"] = 2] = "UINT";
})(SAMPLER_TYPES$4 || (SAMPLER_TYPES$4 = {}));
var SCALE_MODES$4;
(function(SCALE_MODES2) {
  SCALE_MODES2[SCALE_MODES2["NEAREST"] = 0] = "NEAREST";
  SCALE_MODES2[SCALE_MODES2["LINEAR"] = 1] = "LINEAR";
})(SCALE_MODES$4 || (SCALE_MODES$4 = {}));
var WRAP_MODES$4;
(function(WRAP_MODES2) {
  WRAP_MODES2[WRAP_MODES2["CLAMP"] = 33071] = "CLAMP";
  WRAP_MODES2[WRAP_MODES2["REPEAT"] = 10497] = "REPEAT";
  WRAP_MODES2[WRAP_MODES2["MIRRORED_REPEAT"] = 33648] = "MIRRORED_REPEAT";
})(WRAP_MODES$4 || (WRAP_MODES$4 = {}));
var MIPMAP_MODES$4;
(function(MIPMAP_MODES2) {
  MIPMAP_MODES2[MIPMAP_MODES2["OFF"] = 0] = "OFF";
  MIPMAP_MODES2[MIPMAP_MODES2["POW2"] = 1] = "POW2";
  MIPMAP_MODES2[MIPMAP_MODES2["ON"] = 2] = "ON";
  MIPMAP_MODES2[MIPMAP_MODES2["ON_MANUAL"] = 3] = "ON_MANUAL";
})(MIPMAP_MODES$4 || (MIPMAP_MODES$4 = {}));
var ALPHA_MODES$4;
(function(ALPHA_MODES2) {
  ALPHA_MODES2[ALPHA_MODES2["NPM"] = 0] = "NPM";
  ALPHA_MODES2[ALPHA_MODES2["UNPACK"] = 1] = "UNPACK";
  ALPHA_MODES2[ALPHA_MODES2["PMA"] = 2] = "PMA";
  ALPHA_MODES2[ALPHA_MODES2["NO_PREMULTIPLIED_ALPHA"] = 0] = "NO_PREMULTIPLIED_ALPHA";
  ALPHA_MODES2[ALPHA_MODES2["PREMULTIPLY_ON_UPLOAD"] = 1] = "PREMULTIPLY_ON_UPLOAD";
  ALPHA_MODES2[ALPHA_MODES2["PREMULTIPLY_ALPHA"] = 2] = "PREMULTIPLY_ALPHA";
  ALPHA_MODES2[ALPHA_MODES2["PREMULTIPLIED_ALPHA"] = 2] = "PREMULTIPLIED_ALPHA";
})(ALPHA_MODES$4 || (ALPHA_MODES$4 = {}));
var CLEAR_MODES$4;
(function(CLEAR_MODES2) {
  CLEAR_MODES2[CLEAR_MODES2["NO"] = 0] = "NO";
  CLEAR_MODES2[CLEAR_MODES2["YES"] = 1] = "YES";
  CLEAR_MODES2[CLEAR_MODES2["AUTO"] = 2] = "AUTO";
  CLEAR_MODES2[CLEAR_MODES2["BLEND"] = 0] = "BLEND";
  CLEAR_MODES2[CLEAR_MODES2["CLEAR"] = 1] = "CLEAR";
  CLEAR_MODES2[CLEAR_MODES2["BLIT"] = 2] = "BLIT";
})(CLEAR_MODES$4 || (CLEAR_MODES$4 = {}));
var GC_MODES$4;
(function(GC_MODES2) {
  GC_MODES2[GC_MODES2["AUTO"] = 0] = "AUTO";
  GC_MODES2[GC_MODES2["MANUAL"] = 1] = "MANUAL";
})(GC_MODES$4 || (GC_MODES$4 = {}));
var PRECISION$4;
(function(PRECISION2) {
  PRECISION2["LOW"] = "lowp";
  PRECISION2["MEDIUM"] = "mediump";
  PRECISION2["HIGH"] = "highp";
})(PRECISION$4 || (PRECISION$4 = {}));
var MASK_TYPES$4;
(function(MASK_TYPES2) {
  MASK_TYPES2[MASK_TYPES2["NONE"] = 0] = "NONE";
  MASK_TYPES2[MASK_TYPES2["SCISSOR"] = 1] = "SCISSOR";
  MASK_TYPES2[MASK_TYPES2["STENCIL"] = 2] = "STENCIL";
  MASK_TYPES2[MASK_TYPES2["SPRITE"] = 3] = "SPRITE";
})(MASK_TYPES$4 || (MASK_TYPES$4 = {}));
var MSAA_QUALITY$4;
(function(MSAA_QUALITY2) {
  MSAA_QUALITY2[MSAA_QUALITY2["NONE"] = 0] = "NONE";
  MSAA_QUALITY2[MSAA_QUALITY2["LOW"] = 2] = "LOW";
  MSAA_QUALITY2[MSAA_QUALITY2["MEDIUM"] = 4] = "MEDIUM";
  MSAA_QUALITY2[MSAA_QUALITY2["HIGH"] = 8] = "HIGH";
})(MSAA_QUALITY$4 || (MSAA_QUALITY$4 = {}));
var BUFFER_TYPE$4;
(function(BUFFER_TYPE2) {
  BUFFER_TYPE2[BUFFER_TYPE2["ELEMENT_ARRAY_BUFFER"] = 34963] = "ELEMENT_ARRAY_BUFFER";
  BUFFER_TYPE2[BUFFER_TYPE2["ARRAY_BUFFER"] = 34962] = "ARRAY_BUFFER";
  BUFFER_TYPE2[BUFFER_TYPE2["UNIFORM_BUFFER"] = 35345] = "UNIFORM_BUFFER";
})(BUFFER_TYPE$4 || (BUFFER_TYPE$4 = {}));
var settings = {
  MIPMAP_TEXTURES: MIPMAP_MODES$4.POW2,
  ANISOTROPIC_LEVEL: 0,
  RESOLUTION: 1,
  FILTER_RESOLUTION: 1,
  FILTER_MULTISAMPLE: MSAA_QUALITY$4.NONE,
  SPRITE_MAX_TEXTURES: maxRecommendedTextures(32),
  SPRITE_BATCH_SIZE: 4096,
  RENDER_OPTIONS: {
    view: null,
    antialias: false,
    autoDensity: false,
    backgroundColor: 0,
    backgroundAlpha: 1,
    useContextAlpha: true,
    clearBeforeRender: true,
    preserveDrawingBuffer: false,
    width: 800,
    height: 600,
    legacy: false
  },
  GC_MODE: GC_MODES$4.AUTO,
  GC_MAX_IDLE: 60 * 60,
  GC_MAX_CHECK_COUNT: 60 * 10,
  WRAP_MODE: WRAP_MODES$4.CLAMP,
  SCALE_MODE: SCALE_MODES$4.LINEAR,
  PRECISION_VERTEX: PRECISION$4.HIGH,
  PRECISION_FRAGMENT: isMobile.apple.device ? PRECISION$4.HIGH : PRECISION$4.MEDIUM,
  CAN_UPLOAD_SAME_BUFFER: canUploadSameBuffer(),
  CREATE_IMAGE_BITMAP: false,
  ROUND_PIXELS: false
};
/*!
 * @pixi/constants - v6.3.0
 * Compiled Wed, 23 Mar 2022 18:58:56 UTC
 *
 * @pixi/constants is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
var ENV$3;
(function(ENV2) {
  ENV2[ENV2["WEBGL_LEGACY"] = 0] = "WEBGL_LEGACY";
  ENV2[ENV2["WEBGL"] = 1] = "WEBGL";
  ENV2[ENV2["WEBGL2"] = 2] = "WEBGL2";
})(ENV$3 || (ENV$3 = {}));
var RENDERER_TYPE$3;
(function(RENDERER_TYPE2) {
  RENDERER_TYPE2[RENDERER_TYPE2["UNKNOWN"] = 0] = "UNKNOWN";
  RENDERER_TYPE2[RENDERER_TYPE2["WEBGL"] = 1] = "WEBGL";
  RENDERER_TYPE2[RENDERER_TYPE2["CANVAS"] = 2] = "CANVAS";
})(RENDERER_TYPE$3 || (RENDERER_TYPE$3 = {}));
var BUFFER_BITS$3;
(function(BUFFER_BITS2) {
  BUFFER_BITS2[BUFFER_BITS2["COLOR"] = 16384] = "COLOR";
  BUFFER_BITS2[BUFFER_BITS2["DEPTH"] = 256] = "DEPTH";
  BUFFER_BITS2[BUFFER_BITS2["STENCIL"] = 1024] = "STENCIL";
})(BUFFER_BITS$3 || (BUFFER_BITS$3 = {}));
var BLEND_MODES$3;
(function(BLEND_MODES2) {
  BLEND_MODES2[BLEND_MODES2["NORMAL"] = 0] = "NORMAL";
  BLEND_MODES2[BLEND_MODES2["ADD"] = 1] = "ADD";
  BLEND_MODES2[BLEND_MODES2["MULTIPLY"] = 2] = "MULTIPLY";
  BLEND_MODES2[BLEND_MODES2["SCREEN"] = 3] = "SCREEN";
  BLEND_MODES2[BLEND_MODES2["OVERLAY"] = 4] = "OVERLAY";
  BLEND_MODES2[BLEND_MODES2["DARKEN"] = 5] = "DARKEN";
  BLEND_MODES2[BLEND_MODES2["LIGHTEN"] = 6] = "LIGHTEN";
  BLEND_MODES2[BLEND_MODES2["COLOR_DODGE"] = 7] = "COLOR_DODGE";
  BLEND_MODES2[BLEND_MODES2["COLOR_BURN"] = 8] = "COLOR_BURN";
  BLEND_MODES2[BLEND_MODES2["HARD_LIGHT"] = 9] = "HARD_LIGHT";
  BLEND_MODES2[BLEND_MODES2["SOFT_LIGHT"] = 10] = "SOFT_LIGHT";
  BLEND_MODES2[BLEND_MODES2["DIFFERENCE"] = 11] = "DIFFERENCE";
  BLEND_MODES2[BLEND_MODES2["EXCLUSION"] = 12] = "EXCLUSION";
  BLEND_MODES2[BLEND_MODES2["HUE"] = 13] = "HUE";
  BLEND_MODES2[BLEND_MODES2["SATURATION"] = 14] = "SATURATION";
  BLEND_MODES2[BLEND_MODES2["COLOR"] = 15] = "COLOR";
  BLEND_MODES2[BLEND_MODES2["LUMINOSITY"] = 16] = "LUMINOSITY";
  BLEND_MODES2[BLEND_MODES2["NORMAL_NPM"] = 17] = "NORMAL_NPM";
  BLEND_MODES2[BLEND_MODES2["ADD_NPM"] = 18] = "ADD_NPM";
  BLEND_MODES2[BLEND_MODES2["SCREEN_NPM"] = 19] = "SCREEN_NPM";
  BLEND_MODES2[BLEND_MODES2["NONE"] = 20] = "NONE";
  BLEND_MODES2[BLEND_MODES2["SRC_OVER"] = 0] = "SRC_OVER";
  BLEND_MODES2[BLEND_MODES2["SRC_IN"] = 21] = "SRC_IN";
  BLEND_MODES2[BLEND_MODES2["SRC_OUT"] = 22] = "SRC_OUT";
  BLEND_MODES2[BLEND_MODES2["SRC_ATOP"] = 23] = "SRC_ATOP";
  BLEND_MODES2[BLEND_MODES2["DST_OVER"] = 24] = "DST_OVER";
  BLEND_MODES2[BLEND_MODES2["DST_IN"] = 25] = "DST_IN";
  BLEND_MODES2[BLEND_MODES2["DST_OUT"] = 26] = "DST_OUT";
  BLEND_MODES2[BLEND_MODES2["DST_ATOP"] = 27] = "DST_ATOP";
  BLEND_MODES2[BLEND_MODES2["ERASE"] = 26] = "ERASE";
  BLEND_MODES2[BLEND_MODES2["SUBTRACT"] = 28] = "SUBTRACT";
  BLEND_MODES2[BLEND_MODES2["XOR"] = 29] = "XOR";
})(BLEND_MODES$3 || (BLEND_MODES$3 = {}));
var DRAW_MODES$3;
(function(DRAW_MODES2) {
  DRAW_MODES2[DRAW_MODES2["POINTS"] = 0] = "POINTS";
  DRAW_MODES2[DRAW_MODES2["LINES"] = 1] = "LINES";
  DRAW_MODES2[DRAW_MODES2["LINE_LOOP"] = 2] = "LINE_LOOP";
  DRAW_MODES2[DRAW_MODES2["LINE_STRIP"] = 3] = "LINE_STRIP";
  DRAW_MODES2[DRAW_MODES2["TRIANGLES"] = 4] = "TRIANGLES";
  DRAW_MODES2[DRAW_MODES2["TRIANGLE_STRIP"] = 5] = "TRIANGLE_STRIP";
  DRAW_MODES2[DRAW_MODES2["TRIANGLE_FAN"] = 6] = "TRIANGLE_FAN";
})(DRAW_MODES$3 || (DRAW_MODES$3 = {}));
var FORMATS$3;
(function(FORMATS2) {
  FORMATS2[FORMATS2["RGBA"] = 6408] = "RGBA";
  FORMATS2[FORMATS2["RGB"] = 6407] = "RGB";
  FORMATS2[FORMATS2["RG"] = 33319] = "RG";
  FORMATS2[FORMATS2["RED"] = 6403] = "RED";
  FORMATS2[FORMATS2["RGBA_INTEGER"] = 36249] = "RGBA_INTEGER";
  FORMATS2[FORMATS2["RGB_INTEGER"] = 36248] = "RGB_INTEGER";
  FORMATS2[FORMATS2["RG_INTEGER"] = 33320] = "RG_INTEGER";
  FORMATS2[FORMATS2["RED_INTEGER"] = 36244] = "RED_INTEGER";
  FORMATS2[FORMATS2["ALPHA"] = 6406] = "ALPHA";
  FORMATS2[FORMATS2["LUMINANCE"] = 6409] = "LUMINANCE";
  FORMATS2[FORMATS2["LUMINANCE_ALPHA"] = 6410] = "LUMINANCE_ALPHA";
  FORMATS2[FORMATS2["DEPTH_COMPONENT"] = 6402] = "DEPTH_COMPONENT";
  FORMATS2[FORMATS2["DEPTH_STENCIL"] = 34041] = "DEPTH_STENCIL";
})(FORMATS$3 || (FORMATS$3 = {}));
var TARGETS$3;
(function(TARGETS2) {
  TARGETS2[TARGETS2["TEXTURE_2D"] = 3553] = "TEXTURE_2D";
  TARGETS2[TARGETS2["TEXTURE_CUBE_MAP"] = 34067] = "TEXTURE_CUBE_MAP";
  TARGETS2[TARGETS2["TEXTURE_2D_ARRAY"] = 35866] = "TEXTURE_2D_ARRAY";
  TARGETS2[TARGETS2["TEXTURE_CUBE_MAP_POSITIVE_X"] = 34069] = "TEXTURE_CUBE_MAP_POSITIVE_X";
  TARGETS2[TARGETS2["TEXTURE_CUBE_MAP_NEGATIVE_X"] = 34070] = "TEXTURE_CUBE_MAP_NEGATIVE_X";
  TARGETS2[TARGETS2["TEXTURE_CUBE_MAP_POSITIVE_Y"] = 34071] = "TEXTURE_CUBE_MAP_POSITIVE_Y";
  TARGETS2[TARGETS2["TEXTURE_CUBE_MAP_NEGATIVE_Y"] = 34072] = "TEXTURE_CUBE_MAP_NEGATIVE_Y";
  TARGETS2[TARGETS2["TEXTURE_CUBE_MAP_POSITIVE_Z"] = 34073] = "TEXTURE_CUBE_MAP_POSITIVE_Z";
  TARGETS2[TARGETS2["TEXTURE_CUBE_MAP_NEGATIVE_Z"] = 34074] = "TEXTURE_CUBE_MAP_NEGATIVE_Z";
})(TARGETS$3 || (TARGETS$3 = {}));
var TYPES$3;
(function(TYPES2) {
  TYPES2[TYPES2["UNSIGNED_BYTE"] = 5121] = "UNSIGNED_BYTE";
  TYPES2[TYPES2["UNSIGNED_SHORT"] = 5123] = "UNSIGNED_SHORT";
  TYPES2[TYPES2["UNSIGNED_SHORT_5_6_5"] = 33635] = "UNSIGNED_SHORT_5_6_5";
  TYPES2[TYPES2["UNSIGNED_SHORT_4_4_4_4"] = 32819] = "UNSIGNED_SHORT_4_4_4_4";
  TYPES2[TYPES2["UNSIGNED_SHORT_5_5_5_1"] = 32820] = "UNSIGNED_SHORT_5_5_5_1";
  TYPES2[TYPES2["UNSIGNED_INT"] = 5125] = "UNSIGNED_INT";
  TYPES2[TYPES2["UNSIGNED_INT_10F_11F_11F_REV"] = 35899] = "UNSIGNED_INT_10F_11F_11F_REV";
  TYPES2[TYPES2["UNSIGNED_INT_2_10_10_10_REV"] = 33640] = "UNSIGNED_INT_2_10_10_10_REV";
  TYPES2[TYPES2["UNSIGNED_INT_24_8"] = 34042] = "UNSIGNED_INT_24_8";
  TYPES2[TYPES2["UNSIGNED_INT_5_9_9_9_REV"] = 35902] = "UNSIGNED_INT_5_9_9_9_REV";
  TYPES2[TYPES2["BYTE"] = 5120] = "BYTE";
  TYPES2[TYPES2["SHORT"] = 5122] = "SHORT";
  TYPES2[TYPES2["INT"] = 5124] = "INT";
  TYPES2[TYPES2["FLOAT"] = 5126] = "FLOAT";
  TYPES2[TYPES2["FLOAT_32_UNSIGNED_INT_24_8_REV"] = 36269] = "FLOAT_32_UNSIGNED_INT_24_8_REV";
  TYPES2[TYPES2["HALF_FLOAT"] = 36193] = "HALF_FLOAT";
})(TYPES$3 || (TYPES$3 = {}));
var SAMPLER_TYPES$3;
(function(SAMPLER_TYPES2) {
  SAMPLER_TYPES2[SAMPLER_TYPES2["FLOAT"] = 0] = "FLOAT";
  SAMPLER_TYPES2[SAMPLER_TYPES2["INT"] = 1] = "INT";
  SAMPLER_TYPES2[SAMPLER_TYPES2["UINT"] = 2] = "UINT";
})(SAMPLER_TYPES$3 || (SAMPLER_TYPES$3 = {}));
var SCALE_MODES$3;
(function(SCALE_MODES2) {
  SCALE_MODES2[SCALE_MODES2["NEAREST"] = 0] = "NEAREST";
  SCALE_MODES2[SCALE_MODES2["LINEAR"] = 1] = "LINEAR";
})(SCALE_MODES$3 || (SCALE_MODES$3 = {}));
var WRAP_MODES$3;
(function(WRAP_MODES2) {
  WRAP_MODES2[WRAP_MODES2["CLAMP"] = 33071] = "CLAMP";
  WRAP_MODES2[WRAP_MODES2["REPEAT"] = 10497] = "REPEAT";
  WRAP_MODES2[WRAP_MODES2["MIRRORED_REPEAT"] = 33648] = "MIRRORED_REPEAT";
})(WRAP_MODES$3 || (WRAP_MODES$3 = {}));
var MIPMAP_MODES$3;
(function(MIPMAP_MODES2) {
  MIPMAP_MODES2[MIPMAP_MODES2["OFF"] = 0] = "OFF";
  MIPMAP_MODES2[MIPMAP_MODES2["POW2"] = 1] = "POW2";
  MIPMAP_MODES2[MIPMAP_MODES2["ON"] = 2] = "ON";
  MIPMAP_MODES2[MIPMAP_MODES2["ON_MANUAL"] = 3] = "ON_MANUAL";
})(MIPMAP_MODES$3 || (MIPMAP_MODES$3 = {}));
var ALPHA_MODES$3;
(function(ALPHA_MODES2) {
  ALPHA_MODES2[ALPHA_MODES2["NPM"] = 0] = "NPM";
  ALPHA_MODES2[ALPHA_MODES2["UNPACK"] = 1] = "UNPACK";
  ALPHA_MODES2[ALPHA_MODES2["PMA"] = 2] = "PMA";
  ALPHA_MODES2[ALPHA_MODES2["NO_PREMULTIPLIED_ALPHA"] = 0] = "NO_PREMULTIPLIED_ALPHA";
  ALPHA_MODES2[ALPHA_MODES2["PREMULTIPLY_ON_UPLOAD"] = 1] = "PREMULTIPLY_ON_UPLOAD";
  ALPHA_MODES2[ALPHA_MODES2["PREMULTIPLY_ALPHA"] = 2] = "PREMULTIPLY_ALPHA";
  ALPHA_MODES2[ALPHA_MODES2["PREMULTIPLIED_ALPHA"] = 2] = "PREMULTIPLIED_ALPHA";
})(ALPHA_MODES$3 || (ALPHA_MODES$3 = {}));
var CLEAR_MODES$3;
(function(CLEAR_MODES2) {
  CLEAR_MODES2[CLEAR_MODES2["NO"] = 0] = "NO";
  CLEAR_MODES2[CLEAR_MODES2["YES"] = 1] = "YES";
  CLEAR_MODES2[CLEAR_MODES2["AUTO"] = 2] = "AUTO";
  CLEAR_MODES2[CLEAR_MODES2["BLEND"] = 0] = "BLEND";
  CLEAR_MODES2[CLEAR_MODES2["CLEAR"] = 1] = "CLEAR";
  CLEAR_MODES2[CLEAR_MODES2["BLIT"] = 2] = "BLIT";
})(CLEAR_MODES$3 || (CLEAR_MODES$3 = {}));
var GC_MODES$3;
(function(GC_MODES2) {
  GC_MODES2[GC_MODES2["AUTO"] = 0] = "AUTO";
  GC_MODES2[GC_MODES2["MANUAL"] = 1] = "MANUAL";
})(GC_MODES$3 || (GC_MODES$3 = {}));
var PRECISION$3;
(function(PRECISION2) {
  PRECISION2["LOW"] = "lowp";
  PRECISION2["MEDIUM"] = "mediump";
  PRECISION2["HIGH"] = "highp";
})(PRECISION$3 || (PRECISION$3 = {}));
var MASK_TYPES$3;
(function(MASK_TYPES2) {
  MASK_TYPES2[MASK_TYPES2["NONE"] = 0] = "NONE";
  MASK_TYPES2[MASK_TYPES2["SCISSOR"] = 1] = "SCISSOR";
  MASK_TYPES2[MASK_TYPES2["STENCIL"] = 2] = "STENCIL";
  MASK_TYPES2[MASK_TYPES2["SPRITE"] = 3] = "SPRITE";
})(MASK_TYPES$3 || (MASK_TYPES$3 = {}));
var MSAA_QUALITY$3;
(function(MSAA_QUALITY2) {
  MSAA_QUALITY2[MSAA_QUALITY2["NONE"] = 0] = "NONE";
  MSAA_QUALITY2[MSAA_QUALITY2["LOW"] = 2] = "LOW";
  MSAA_QUALITY2[MSAA_QUALITY2["MEDIUM"] = 4] = "MEDIUM";
  MSAA_QUALITY2[MSAA_QUALITY2["HIGH"] = 8] = "HIGH";
})(MSAA_QUALITY$3 || (MSAA_QUALITY$3 = {}));
var BUFFER_TYPE$3;
(function(BUFFER_TYPE2) {
  BUFFER_TYPE2[BUFFER_TYPE2["ELEMENT_ARRAY_BUFFER"] = 34963] = "ELEMENT_ARRAY_BUFFER";
  BUFFER_TYPE2[BUFFER_TYPE2["ARRAY_BUFFER"] = 34962] = "ARRAY_BUFFER";
  BUFFER_TYPE2[BUFFER_TYPE2["UNIFORM_BUFFER"] = 35345] = "UNIFORM_BUFFER";
})(BUFFER_TYPE$3 || (BUFFER_TYPE$3 = {}));
var eventemitter3 = { exports: {} };
(function(module) {
  var has = Object.prototype.hasOwnProperty, prefix2 = "~";
  function Events() {
  }
  if (Object.create) {
    Events.prototype = /* @__PURE__ */ Object.create(null);
    if (!new Events().__proto__)
      prefix2 = false;
  }
  function EE(fn, context2, once) {
    this.fn = fn;
    this.context = context2;
    this.once = once || false;
  }
  function addListener(emitter, event, fn, context2, once) {
    if (typeof fn !== "function") {
      throw new TypeError("The listener must be a function");
    }
    var listener = new EE(fn, context2 || emitter, once), evt = prefix2 ? prefix2 + event : event;
    if (!emitter._events[evt])
      emitter._events[evt] = listener, emitter._eventsCount++;
    else if (!emitter._events[evt].fn)
      emitter._events[evt].push(listener);
    else
      emitter._events[evt] = [emitter._events[evt], listener];
    return emitter;
  }
  function clearEvent(emitter, evt) {
    if (--emitter._eventsCount === 0)
      emitter._events = new Events();
    else
      delete emitter._events[evt];
  }
  function EventEmitter2() {
    this._events = new Events();
    this._eventsCount = 0;
  }
  EventEmitter2.prototype.eventNames = function eventNames() {
    var names = [], events, name2;
    if (this._eventsCount === 0)
      return names;
    for (name2 in events = this._events) {
      if (has.call(events, name2))
        names.push(prefix2 ? name2.slice(1) : name2);
    }
    if (Object.getOwnPropertySymbols) {
      return names.concat(Object.getOwnPropertySymbols(events));
    }
    return names;
  };
  EventEmitter2.prototype.listeners = function listeners(event) {
    var evt = prefix2 ? prefix2 + event : event, handlers = this._events[evt];
    if (!handlers)
      return [];
    if (handlers.fn)
      return [handlers.fn];
    for (var i2 = 0, l2 = handlers.length, ee = new Array(l2); i2 < l2; i2++) {
      ee[i2] = handlers[i2].fn;
    }
    return ee;
  };
  EventEmitter2.prototype.listenerCount = function listenerCount(event) {
    var evt = prefix2 ? prefix2 + event : event, listeners = this._events[evt];
    if (!listeners)
      return 0;
    if (listeners.fn)
      return 1;
    return listeners.length;
  };
  EventEmitter2.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {
    var evt = prefix2 ? prefix2 + event : event;
    if (!this._events[evt])
      return false;
    var listeners = this._events[evt], len = arguments.length, args, i2;
    if (listeners.fn) {
      if (listeners.once)
        this.removeListener(event, listeners.fn, void 0, true);
      switch (len) {
        case 1:
          return listeners.fn.call(listeners.context), true;
        case 2:
          return listeners.fn.call(listeners.context, a1), true;
        case 3:
          return listeners.fn.call(listeners.context, a1, a2), true;
        case 4:
          return listeners.fn.call(listeners.context, a1, a2, a3), true;
        case 5:
          return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;
        case 6:
          return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;
      }
      for (i2 = 1, args = new Array(len - 1); i2 < len; i2++) {
        args[i2 - 1] = arguments[i2];
      }
      listeners.fn.apply(listeners.context, args);
    } else {
      var length2 = listeners.length, j2;
      for (i2 = 0; i2 < length2; i2++) {
        if (listeners[i2].once)
          this.removeListener(event, listeners[i2].fn, void 0, true);
        switch (len) {
          case 1:
            listeners[i2].fn.call(listeners[i2].context);
            break;
          case 2:
            listeners[i2].fn.call(listeners[i2].context, a1);
            break;
          case 3:
            listeners[i2].fn.call(listeners[i2].context, a1, a2);
            break;
          case 4:
            listeners[i2].fn.call(listeners[i2].context, a1, a2, a3);
            break;
          default:
            if (!args)
              for (j2 = 1, args = new Array(len - 1); j2 < len; j2++) {
                args[j2 - 1] = arguments[j2];
              }
            listeners[i2].fn.apply(listeners[i2].context, args);
        }
      }
    }
    return true;
  };
  EventEmitter2.prototype.on = function on2(event, fn, context2) {
    return addListener(this, event, fn, context2, false);
  };
  EventEmitter2.prototype.once = function once(event, fn, context2) {
    return addListener(this, event, fn, context2, true);
  };
  EventEmitter2.prototype.removeListener = function removeListener(event, fn, context2, once) {
    var evt = prefix2 ? prefix2 + event : event;
    if (!this._events[evt])
      return this;
    if (!fn) {
      clearEvent(this, evt);
      return this;
    }
    var listeners = this._events[evt];
    if (listeners.fn) {
      if (listeners.fn === fn && (!once || listeners.once) && (!context2 || listeners.context === context2)) {
        clearEvent(this, evt);
      }
    } else {
      for (var i2 = 0, events = [], length2 = listeners.length; i2 < length2; i2++) {
        if (listeners[i2].fn !== fn || once && !listeners[i2].once || context2 && listeners[i2].context !== context2) {
          events.push(listeners[i2]);
        }
      }
      if (events.length)
        this._events[evt] = events.length === 1 ? events[0] : events;
      else
        clearEvent(this, evt);
    }
    return this;
  };
  EventEmitter2.prototype.removeAllListeners = function removeAllListeners(event) {
    var evt;
    if (event) {
      evt = prefix2 ? prefix2 + event : event;
      if (this._events[evt])
        clearEvent(this, evt);
    } else {
      this._events = new Events();
      this._eventsCount = 0;
    }
    return this;
  };
  EventEmitter2.prototype.off = EventEmitter2.prototype.removeListener;
  EventEmitter2.prototype.addListener = EventEmitter2.prototype.on;
  EventEmitter2.prefixed = prefix2;
  EventEmitter2.EventEmitter = EventEmitter2;
  {
    module.exports = EventEmitter2;
  }
})(eventemitter3);
var EventEmitter$3 = eventemitter3.exports;
var earcut$2 = { exports: {} };
earcut$2.exports = earcut;
earcut$2.exports.default = earcut;
function earcut(data, holeIndices, dim) {
  dim = dim || 2;
  var hasHoles = holeIndices && holeIndices.length, outerLen = hasHoles ? holeIndices[0] * dim : data.length, outerNode = linkedList(data, 0, outerLen, dim, true), triangles = [];
  if (!outerNode || outerNode.next === outerNode.prev)
    return triangles;
  var minX, minY, maxX, maxY, x2, y2, invSize;
  if (hasHoles)
    outerNode = eliminateHoles(data, holeIndices, outerNode, dim);
  if (data.length > 80 * dim) {
    minX = maxX = data[0];
    minY = maxY = data[1];
    for (var i2 = dim; i2 < outerLen; i2 += dim) {
      x2 = data[i2];
      y2 = data[i2 + 1];
      if (x2 < minX)
        minX = x2;
      if (y2 < minY)
        minY = y2;
      if (x2 > maxX)
        maxX = x2;
      if (y2 > maxY)
        maxY = y2;
    }
    invSize = Math.max(maxX - minX, maxY - minY);
    invSize = invSize !== 0 ? 1 / invSize : 0;
  }
  earcutLinked(outerNode, triangles, dim, minX, minY, invSize);
  return triangles;
}
function linkedList(data, start, end, dim, clockwise) {
  var i2, last;
  if (clockwise === signedArea(data, start, end, dim) > 0) {
    for (i2 = start; i2 < end; i2 += dim)
      last = insertNode(i2, data[i2], data[i2 + 1], last);
  } else {
    for (i2 = end - dim; i2 >= start; i2 -= dim)
      last = insertNode(i2, data[i2], data[i2 + 1], last);
  }
  if (last && equals$1(last, last.next)) {
    removeNode(last);
    last = last.next;
  }
  return last;
}
function filterPoints(start, end) {
  if (!start)
    return start;
  if (!end)
    end = start;
  var p2 = start, again;
  do {
    again = false;
    if (!p2.steiner && (equals$1(p2, p2.next) || area(p2.prev, p2, p2.next) === 0)) {
      removeNode(p2);
      p2 = end = p2.prev;
      if (p2 === p2.next)
        break;
      again = true;
    } else {
      p2 = p2.next;
    }
  } while (again || p2 !== end);
  return end;
}
function earcutLinked(ear, triangles, dim, minX, minY, invSize, pass) {
  if (!ear)
    return;
  if (!pass && invSize)
    indexCurve(ear, minX, minY, invSize);
  var stop = ear, prev2, next;
  while (ear.prev !== ear.next) {
    prev2 = ear.prev;
    next = ear.next;
    if (invSize ? isEarHashed(ear, minX, minY, invSize) : isEar(ear)) {
      triangles.push(prev2.i / dim);
      triangles.push(ear.i / dim);
      triangles.push(next.i / dim);
      removeNode(ear);
      ear = next.next;
      stop = next.next;
      continue;
    }
    ear = next;
    if (ear === stop) {
      if (!pass) {
        earcutLinked(filterPoints(ear), triangles, dim, minX, minY, invSize, 1);
      } else if (pass === 1) {
        ear = cureLocalIntersections(filterPoints(ear), triangles, dim);
        earcutLinked(ear, triangles, dim, minX, minY, invSize, 2);
      } else if (pass === 2) {
        splitEarcut(ear, triangles, dim, minX, minY, invSize);
      }
      break;
    }
  }
}
function isEar(ear) {
  var a2 = ear.prev, b2 = ear, c2 = ear.next;
  if (area(a2, b2, c2) >= 0)
    return false;
  var p2 = ear.next.next;
  while (p2 !== ear.prev) {
    if (pointInTriangle(a2.x, a2.y, b2.x, b2.y, c2.x, c2.y, p2.x, p2.y) && area(p2.prev, p2, p2.next) >= 0)
      return false;
    p2 = p2.next;
  }
  return true;
}
function isEarHashed(ear, minX, minY, invSize) {
  var a2 = ear.prev, b2 = ear, c2 = ear.next;
  if (area(a2, b2, c2) >= 0)
    return false;
  var minTX = a2.x < b2.x ? a2.x < c2.x ? a2.x : c2.x : b2.x < c2.x ? b2.x : c2.x, minTY = a2.y < b2.y ? a2.y < c2.y ? a2.y : c2.y : b2.y < c2.y ? b2.y : c2.y, maxTX = a2.x > b2.x ? a2.x > c2.x ? a2.x : c2.x : b2.x > c2.x ? b2.x : c2.x, maxTY = a2.y > b2.y ? a2.y > c2.y ? a2.y : c2.y : b2.y > c2.y ? b2.y : c2.y;
  var minZ = zOrder(minTX, minTY, minX, minY, invSize), maxZ = zOrder(maxTX, maxTY, minX, minY, invSize);
  var p2 = ear.prevZ, n = ear.nextZ;
  while (p2 && p2.z >= minZ && n && n.z <= maxZ) {
    if (p2 !== ear.prev && p2 !== ear.next && pointInTriangle(a2.x, a2.y, b2.x, b2.y, c2.x, c2.y, p2.x, p2.y) && area(p2.prev, p2, p2.next) >= 0)
      return false;
    p2 = p2.prevZ;
    if (n !== ear.prev && n !== ear.next && pointInTriangle(a2.x, a2.y, b2.x, b2.y, c2.x, c2.y, n.x, n.y) && area(n.prev, n, n.next) >= 0)
      return false;
    n = n.nextZ;
  }
  while (p2 && p2.z >= minZ) {
    if (p2 !== ear.prev && p2 !== ear.next && pointInTriangle(a2.x, a2.y, b2.x, b2.y, c2.x, c2.y, p2.x, p2.y) && area(p2.prev, p2, p2.next) >= 0)
      return false;
    p2 = p2.prevZ;
  }
  while (n && n.z <= maxZ) {
    if (n !== ear.prev && n !== ear.next && pointInTriangle(a2.x, a2.y, b2.x, b2.y, c2.x, c2.y, n.x, n.y) && area(n.prev, n, n.next) >= 0)
      return false;
    n = n.nextZ;
  }
  return true;
}
function cureLocalIntersections(start, triangles, dim) {
  var p2 = start;
  do {
    var a2 = p2.prev, b2 = p2.next.next;
    if (!equals$1(a2, b2) && intersects(a2, p2, p2.next, b2) && locallyInside(a2, b2) && locallyInside(b2, a2)) {
      triangles.push(a2.i / dim);
      triangles.push(p2.i / dim);
      triangles.push(b2.i / dim);
      removeNode(p2);
      removeNode(p2.next);
      p2 = start = b2;
    }
    p2 = p2.next;
  } while (p2 !== start);
  return filterPoints(p2);
}
function splitEarcut(start, triangles, dim, minX, minY, invSize) {
  var a2 = start;
  do {
    var b2 = a2.next.next;
    while (b2 !== a2.prev) {
      if (a2.i !== b2.i && isValidDiagonal(a2, b2)) {
        var c2 = splitPolygon(a2, b2);
        a2 = filterPoints(a2, a2.next);
        c2 = filterPoints(c2, c2.next);
        earcutLinked(a2, triangles, dim, minX, minY, invSize);
        earcutLinked(c2, triangles, dim, minX, minY, invSize);
        return;
      }
      b2 = b2.next;
    }
    a2 = a2.next;
  } while (a2 !== start);
}
function eliminateHoles(data, holeIndices, outerNode, dim) {
  var queue = [], i2, len, start, end, list;
  for (i2 = 0, len = holeIndices.length; i2 < len; i2++) {
    start = holeIndices[i2] * dim;
    end = i2 < len - 1 ? holeIndices[i2 + 1] * dim : data.length;
    list = linkedList(data, start, end, dim, false);
    if (list === list.next)
      list.steiner = true;
    queue.push(getLeftmost(list));
  }
  queue.sort(compareX);
  for (i2 = 0; i2 < queue.length; i2++) {
    outerNode = eliminateHole(queue[i2], outerNode);
    outerNode = filterPoints(outerNode, outerNode.next);
  }
  return outerNode;
}
function compareX(a2, b2) {
  return a2.x - b2.x;
}
function eliminateHole(hole, outerNode) {
  var bridge = findHoleBridge(hole, outerNode);
  if (!bridge) {
    return outerNode;
  }
  var bridgeReverse = splitPolygon(bridge, hole);
  var filteredBridge = filterPoints(bridge, bridge.next);
  filterPoints(bridgeReverse, bridgeReverse.next);
  return outerNode === bridge ? filteredBridge : outerNode;
}
function findHoleBridge(hole, outerNode) {
  var p2 = outerNode, hx = hole.x, hy = hole.y, qx = -Infinity, m2;
  do {
    if (hy <= p2.y && hy >= p2.next.y && p2.next.y !== p2.y) {
      var x2 = p2.x + (hy - p2.y) * (p2.next.x - p2.x) / (p2.next.y - p2.y);
      if (x2 <= hx && x2 > qx) {
        qx = x2;
        if (x2 === hx) {
          if (hy === p2.y)
            return p2;
          if (hy === p2.next.y)
            return p2.next;
        }
        m2 = p2.x < p2.next.x ? p2 : p2.next;
      }
    }
    p2 = p2.next;
  } while (p2 !== outerNode);
  if (!m2)
    return null;
  if (hx === qx)
    return m2;
  var stop = m2, mx = m2.x, my = m2.y, tanMin = Infinity, tan2;
  p2 = m2;
  do {
    if (hx >= p2.x && p2.x >= mx && hx !== p2.x && pointInTriangle(hy < my ? hx : qx, hy, mx, my, hy < my ? qx : hx, hy, p2.x, p2.y)) {
      tan2 = Math.abs(hy - p2.y) / (hx - p2.x);
      if (locallyInside(p2, hole) && (tan2 < tanMin || tan2 === tanMin && (p2.x > m2.x || p2.x === m2.x && sectorContainsSector(m2, p2)))) {
        m2 = p2;
        tanMin = tan2;
      }
    }
    p2 = p2.next;
  } while (p2 !== stop);
  return m2;
}
function sectorContainsSector(m2, p2) {
  return area(m2.prev, m2, p2.prev) < 0 && area(p2.next, m2, m2.next) < 0;
}
function indexCurve(start, minX, minY, invSize) {
  var p2 = start;
  do {
    if (p2.z === null)
      p2.z = zOrder(p2.x, p2.y, minX, minY, invSize);
    p2.prevZ = p2.prev;
    p2.nextZ = p2.next;
    p2 = p2.next;
  } while (p2 !== start);
  p2.prevZ.nextZ = null;
  p2.prevZ = null;
  sortLinked(p2);
}
function sortLinked(list) {
  var i2, p2, q, e, tail, numMerges, pSize, qSize, inSize = 1;
  do {
    p2 = list;
    list = null;
    tail = null;
    numMerges = 0;
    while (p2) {
      numMerges++;
      q = p2;
      pSize = 0;
      for (i2 = 0; i2 < inSize; i2++) {
        pSize++;
        q = q.nextZ;
        if (!q)
          break;
      }
      qSize = inSize;
      while (pSize > 0 || qSize > 0 && q) {
        if (pSize !== 0 && (qSize === 0 || !q || p2.z <= q.z)) {
          e = p2;
          p2 = p2.nextZ;
          pSize--;
        } else {
          e = q;
          q = q.nextZ;
          qSize--;
        }
        if (tail)
          tail.nextZ = e;
        else
          list = e;
        e.prevZ = tail;
        tail = e;
      }
      p2 = q;
    }
    tail.nextZ = null;
    inSize *= 2;
  } while (numMerges > 1);
  return list;
}
function zOrder(x2, y2, minX, minY, invSize) {
  x2 = 32767 * (x2 - minX) * invSize;
  y2 = 32767 * (y2 - minY) * invSize;
  x2 = (x2 | x2 << 8) & 16711935;
  x2 = (x2 | x2 << 4) & 252645135;
  x2 = (x2 | x2 << 2) & 858993459;
  x2 = (x2 | x2 << 1) & 1431655765;
  y2 = (y2 | y2 << 8) & 16711935;
  y2 = (y2 | y2 << 4) & 252645135;
  y2 = (y2 | y2 << 2) & 858993459;
  y2 = (y2 | y2 << 1) & 1431655765;
  return x2 | y2 << 1;
}
function getLeftmost(start) {
  var p2 = start, leftmost = start;
  do {
    if (p2.x < leftmost.x || p2.x === leftmost.x && p2.y < leftmost.y)
      leftmost = p2;
    p2 = p2.next;
  } while (p2 !== start);
  return leftmost;
}
function pointInTriangle(ax, ay, bx, by, cx, cy, px, py) {
  return (cx - px) * (ay - py) - (ax - px) * (cy - py) >= 0 && (ax - px) * (by - py) - (bx - px) * (ay - py) >= 0 && (bx - px) * (cy - py) - (cx - px) * (by - py) >= 0;
}
function isValidDiagonal(a2, b2) {
  return a2.next.i !== b2.i && a2.prev.i !== b2.i && !intersectsPolygon(a2, b2) && (locallyInside(a2, b2) && locallyInside(b2, a2) && middleInside(a2, b2) && (area(a2.prev, a2, b2.prev) || area(a2, b2.prev, b2)) || equals$1(a2, b2) && area(a2.prev, a2, a2.next) > 0 && area(b2.prev, b2, b2.next) > 0);
}
function area(p2, q, r2) {
  return (q.y - p2.y) * (r2.x - q.x) - (q.x - p2.x) * (r2.y - q.y);
}
function equals$1(p1, p2) {
  return p1.x === p2.x && p1.y === p2.y;
}
function intersects(p1, q1, p2, q2) {
  var o1 = sign$1(area(p1, q1, p2));
  var o2 = sign$1(area(p1, q1, q2));
  var o3 = sign$1(area(p2, q2, p1));
  var o4 = sign$1(area(p2, q2, q1));
  if (o1 !== o2 && o3 !== o4)
    return true;
  if (o1 === 0 && onSegment(p1, p2, q1))
    return true;
  if (o2 === 0 && onSegment(p1, q2, q1))
    return true;
  if (o3 === 0 && onSegment(p2, p1, q2))
    return true;
  if (o4 === 0 && onSegment(p2, q1, q2))
    return true;
  return false;
}
function onSegment(p2, q, r2) {
  return q.x <= Math.max(p2.x, r2.x) && q.x >= Math.min(p2.x, r2.x) && q.y <= Math.max(p2.y, r2.y) && q.y >= Math.min(p2.y, r2.y);
}
function sign$1(num) {
  return num > 0 ? 1 : num < 0 ? -1 : 0;
}
function intersectsPolygon(a2, b2) {
  var p2 = a2;
  do {
    if (p2.i !== a2.i && p2.next.i !== a2.i && p2.i !== b2.i && p2.next.i !== b2.i && intersects(p2, p2.next, a2, b2))
      return true;
    p2 = p2.next;
  } while (p2 !== a2);
  return false;
}
function locallyInside(a2, b2) {
  return area(a2.prev, a2, a2.next) < 0 ? area(a2, b2, a2.next) >= 0 && area(a2, a2.prev, b2) >= 0 : area(a2, b2, a2.prev) < 0 || area(a2, a2.next, b2) < 0;
}
function middleInside(a2, b2) {
  var p2 = a2, inside = false, px = (a2.x + b2.x) / 2, py = (a2.y + b2.y) / 2;
  do {
    if (p2.y > py !== p2.next.y > py && p2.next.y !== p2.y && px < (p2.next.x - p2.x) * (py - p2.y) / (p2.next.y - p2.y) + p2.x)
      inside = !inside;
    p2 = p2.next;
  } while (p2 !== a2);
  return inside;
}
function splitPolygon(a2, b2) {
  var a22 = new Node$1(a2.i, a2.x, a2.y), b22 = new Node$1(b2.i, b2.x, b2.y), an = a2.next, bp = b2.prev;
  a2.next = b2;
  b2.prev = a2;
  a22.next = an;
  an.prev = a22;
  b22.next = a22;
  a22.prev = b22;
  bp.next = b22;
  b22.prev = bp;
  return b22;
}
function insertNode(i2, x2, y2, last) {
  var p2 = new Node$1(i2, x2, y2);
  if (!last) {
    p2.prev = p2;
    p2.next = p2;
  } else {
    p2.next = last.next;
    p2.prev = last;
    last.next.prev = p2;
    last.next = p2;
  }
  return p2;
}
function removeNode(p2) {
  p2.next.prev = p2.prev;
  p2.prev.next = p2.next;
  if (p2.prevZ)
    p2.prevZ.nextZ = p2.nextZ;
  if (p2.nextZ)
    p2.nextZ.prevZ = p2.prevZ;
}
function Node$1(i2, x2, y2) {
  this.i = i2;
  this.x = x2;
  this.y = y2;
  this.prev = null;
  this.next = null;
  this.z = null;
  this.prevZ = null;
  this.nextZ = null;
  this.steiner = false;
}
earcut.deviation = function(data, holeIndices, dim, triangles) {
  var hasHoles = holeIndices && holeIndices.length;
  var outerLen = hasHoles ? holeIndices[0] * dim : data.length;
  var polygonArea = Math.abs(signedArea(data, 0, outerLen, dim));
  if (hasHoles) {
    for (var i2 = 0, len = holeIndices.length; i2 < len; i2++) {
      var start = holeIndices[i2] * dim;
      var end = i2 < len - 1 ? holeIndices[i2 + 1] * dim : data.length;
      polygonArea -= Math.abs(signedArea(data, start, end, dim));
    }
  }
  var trianglesArea = 0;
  for (i2 = 0; i2 < triangles.length; i2 += 3) {
    var a2 = triangles[i2] * dim;
    var b2 = triangles[i2 + 1] * dim;
    var c2 = triangles[i2 + 2] * dim;
    trianglesArea += Math.abs((data[a2] - data[c2]) * (data[b2 + 1] - data[a2 + 1]) - (data[a2] - data[b2]) * (data[c2 + 1] - data[a2 + 1]));
  }
  return polygonArea === 0 && trianglesArea === 0 ? 0 : Math.abs((trianglesArea - polygonArea) / polygonArea);
};
function signedArea(data, start, end, dim) {
  var sum2 = 0;
  for (var i2 = start, j2 = end - dim; i2 < end; i2 += dim) {
    sum2 += (data[j2] - data[i2]) * (data[i2 + 1] + data[j2 + 1]);
    j2 = i2;
  }
  return sum2;
}
earcut.flatten = function(data) {
  var dim = data[0][0].length, result = { vertices: [], holes: [], dimensions: dim }, holeIndex = 0;
  for (var i2 = 0; i2 < data.length; i2++) {
    for (var j2 = 0; j2 < data[i2].length; j2++) {
      for (var d2 = 0; d2 < dim; d2++)
        result.vertices.push(data[i2][j2][d2]);
    }
    if (i2 > 0) {
      holeIndex += data[i2 - 1].length;
      result.holes.push(holeIndex);
    }
  }
  return result;
};
var earcut$1 = earcut$2.exports;
var punycode$1 = { exports: {} };
/*! https://mths.be/punycode v1.3.2 by @mathias */
(function(module, exports) {
  (function(root) {
    var freeExports = exports && !exports.nodeType && exports;
    var freeModule = module && !module.nodeType && module;
    var freeGlobal = typeof commonjsGlobal == "object" && commonjsGlobal;
    if (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal || freeGlobal.self === freeGlobal) {
      root = freeGlobal;
    }
    var punycode2, maxInt = 2147483647, base = 36, tMin = 1, tMax = 26, skew = 38, damp = 700, initialBias = 72, initialN = 128, delimiter = "-", regexPunycode = /^xn--/, regexNonASCII = /[^\x20-\x7E]/, regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g, errors = {
      "overflow": "Overflow: input needs wider integers to process",
      "not-basic": "Illegal input >= 0x80 (not a basic code point)",
      "invalid-input": "Invalid input"
    }, baseMinusTMin = base - tMin, floor = Math.floor, stringFromCharCode = String.fromCharCode, key;
    function error(type) {
      throw RangeError(errors[type]);
    }
    function map2(array, fn) {
      var length2 = array.length;
      var result = [];
      while (length2--) {
        result[length2] = fn(array[length2]);
      }
      return result;
    }
    function mapDomain(string, fn) {
      var parts2 = string.split("@");
      var result = "";
      if (parts2.length > 1) {
        result = parts2[0] + "@";
        string = parts2[1];
      }
      string = string.replace(regexSeparators, ".");
      var labels = string.split(".");
      var encoded = map2(labels, fn).join(".");
      return result + encoded;
    }
    function ucs2decode(string) {
      var output = [], counter = 0, length2 = string.length, value, extra;
      while (counter < length2) {
        value = string.charCodeAt(counter++);
        if (value >= 55296 && value <= 56319 && counter < length2) {
          extra = string.charCodeAt(counter++);
          if ((extra & 64512) == 56320) {
            output.push(((value & 1023) << 10) + (extra & 1023) + 65536);
          } else {
            output.push(value);
            counter--;
          }
        } else {
          output.push(value);
        }
      }
      return output;
    }
    function ucs2encode(array) {
      return map2(array, function(value) {
        var output = "";
        if (value > 65535) {
          value -= 65536;
          output += stringFromCharCode(value >>> 10 & 1023 | 55296);
          value = 56320 | value & 1023;
        }
        output += stringFromCharCode(value);
        return output;
      }).join("");
    }
    function basicToDigit(codePoint) {
      if (codePoint - 48 < 10) {
        return codePoint - 22;
      }
      if (codePoint - 65 < 26) {
        return codePoint - 65;
      }
      if (codePoint - 97 < 26) {
        return codePoint - 97;
      }
      return base;
    }
    function digitToBasic(digit, flag) {
      return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
    }
    function adapt(delta, numPoints, firstTime) {
      var k = 0;
      delta = firstTime ? floor(delta / damp) : delta >> 1;
      delta += floor(delta / numPoints);
      for (; delta > baseMinusTMin * tMax >> 1; k += base) {
        delta = floor(delta / baseMinusTMin);
      }
      return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));
    }
    function decode2(input) {
      var output = [], inputLength = input.length, out, i2 = 0, n = initialN, bias = initialBias, basic, j2, index, oldi, w2, k, digit, t, baseMinusT;
      basic = input.lastIndexOf(delimiter);
      if (basic < 0) {
        basic = 0;
      }
      for (j2 = 0; j2 < basic; ++j2) {
        if (input.charCodeAt(j2) >= 128) {
          error("not-basic");
        }
        output.push(input.charCodeAt(j2));
      }
      for (index = basic > 0 ? basic + 1 : 0; index < inputLength; ) {
        for (oldi = i2, w2 = 1, k = base; ; k += base) {
          if (index >= inputLength) {
            error("invalid-input");
          }
          digit = basicToDigit(input.charCodeAt(index++));
          if (digit >= base || digit > floor((maxInt - i2) / w2)) {
            error("overflow");
          }
          i2 += digit * w2;
          t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;
          if (digit < t) {
            break;
          }
          baseMinusT = base - t;
          if (w2 > floor(maxInt / baseMinusT)) {
            error("overflow");
          }
          w2 *= baseMinusT;
        }
        out = output.length + 1;
        bias = adapt(i2 - oldi, out, oldi == 0);
        if (floor(i2 / out) > maxInt - n) {
          error("overflow");
        }
        n += floor(i2 / out);
        i2 %= out;
        output.splice(i2++, 0, n);
      }
      return ucs2encode(output);
    }
    function encode2(input) {
      var n, delta, handledCPCount, basicLength, bias, j2, m2, q, k, t, currentValue, output = [], inputLength, handledCPCountPlusOne, baseMinusT, qMinusT;
      input = ucs2decode(input);
      inputLength = input.length;
      n = initialN;
      delta = 0;
      bias = initialBias;
      for (j2 = 0; j2 < inputLength; ++j2) {
        currentValue = input[j2];
        if (currentValue < 128) {
          output.push(stringFromCharCode(currentValue));
        }
      }
      handledCPCount = basicLength = output.length;
      if (basicLength) {
        output.push(delimiter);
      }
      while (handledCPCount < inputLength) {
        for (m2 = maxInt, j2 = 0; j2 < inputLength; ++j2) {
          currentValue = input[j2];
          if (currentValue >= n && currentValue < m2) {
            m2 = currentValue;
          }
        }
        handledCPCountPlusOne = handledCPCount + 1;
        if (m2 - n > floor((maxInt - delta) / handledCPCountPlusOne)) {
          error("overflow");
        }
        delta += (m2 - n) * handledCPCountPlusOne;
        n = m2;
        for (j2 = 0; j2 < inputLength; ++j2) {
          currentValue = input[j2];
          if (currentValue < n && ++delta > maxInt) {
            error("overflow");
          }
          if (currentValue == n) {
            for (q = delta, k = base; ; k += base) {
              t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;
              if (q < t) {
                break;
              }
              qMinusT = q - t;
              baseMinusT = base - t;
              output.push(stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0)));
              q = floor(qMinusT / baseMinusT);
            }
            output.push(stringFromCharCode(digitToBasic(q, 0)));
            bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);
            delta = 0;
            ++handledCPCount;
          }
        }
        ++delta;
        ++n;
      }
      return output.join("");
    }
    function toUnicode(input) {
      return mapDomain(input, function(string) {
        return regexPunycode.test(string) ? decode2(string.slice(4).toLowerCase()) : string;
      });
    }
    function toASCII(input) {
      return mapDomain(input, function(string) {
        return regexNonASCII.test(string) ? "xn--" + encode2(string) : string;
      });
    }
    punycode2 = {
      "version": "1.3.2",
      "ucs2": {
        "decode": ucs2decode,
        "encode": ucs2encode
      },
      "decode": decode2,
      "encode": encode2,
      "toASCII": toASCII,
      "toUnicode": toUnicode
    };
    if (freeExports && freeModule) {
      if (module.exports == freeExports) {
        freeModule.exports = punycode2;
      } else {
        for (key in punycode2) {
          punycode2.hasOwnProperty(key) && (freeExports[key] = punycode2[key]);
        }
      }
    } else {
      root.punycode = punycode2;
    }
  })(commonjsGlobal);
})(punycode$1, punycode$1.exports);
var util$8 = {
  isString: function(arg) {
    return typeof arg === "string";
  },
  isObject: function(arg) {
    return typeof arg === "object" && arg !== null;
  },
  isNull: function(arg) {
    return arg === null;
  },
  isNullOrUndefined: function(arg) {
    return arg == null;
  }
};
var querystring$1 = {};
function hasOwnProperty$1(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}
var decode = function(qs, sep, eq, options) {
  sep = sep || "&";
  eq = eq || "=";
  var obj = {};
  if (typeof qs !== "string" || qs.length === 0) {
    return obj;
  }
  var regexp = /\+/g;
  qs = qs.split(sep);
  var maxKeys = 1e3;
  if (options && typeof options.maxKeys === "number") {
    maxKeys = options.maxKeys;
  }
  var len = qs.length;
  if (maxKeys > 0 && len > maxKeys) {
    len = maxKeys;
  }
  for (var i2 = 0; i2 < len; ++i2) {
    var x2 = qs[i2].replace(regexp, "%20"), idx = x2.indexOf(eq), kstr, vstr, k, v2;
    if (idx >= 0) {
      kstr = x2.substr(0, idx);
      vstr = x2.substr(idx + 1);
    } else {
      kstr = x2;
      vstr = "";
    }
    k = decodeURIComponent(kstr);
    v2 = decodeURIComponent(vstr);
    if (!hasOwnProperty$1(obj, k)) {
      obj[k] = v2;
    } else if (Array.isArray(obj[k])) {
      obj[k].push(v2);
    } else {
      obj[k] = [obj[k], v2];
    }
  }
  return obj;
};
var stringifyPrimitive = function(v2) {
  switch (typeof v2) {
    case "string":
      return v2;
    case "boolean":
      return v2 ? "true" : "false";
    case "number":
      return isFinite(v2) ? v2 : "";
    default:
      return "";
  }
};
var encode = function(obj, sep, eq, name2) {
  sep = sep || "&";
  eq = eq || "=";
  if (obj === null) {
    obj = void 0;
  }
  if (typeof obj === "object") {
    return Object.keys(obj).map(function(k) {
      var ks = encodeURIComponent(stringifyPrimitive(k)) + eq;
      if (Array.isArray(obj[k])) {
        return obj[k].map(function(v2) {
          return ks + encodeURIComponent(stringifyPrimitive(v2));
        }).join(sep);
      } else {
        return ks + encodeURIComponent(stringifyPrimitive(obj[k]));
      }
    }).join(sep);
  }
  if (!name2)
    return "";
  return encodeURIComponent(stringifyPrimitive(name2)) + eq + encodeURIComponent(stringifyPrimitive(obj));
};
querystring$1.decode = querystring$1.parse = decode;
querystring$1.encode = querystring$1.stringify = encode;
var punycode = punycode$1.exports;
var util$7 = util$8;
var parse$1 = urlParse;
var resolve$1 = urlResolve;
var format = urlFormat;
function Url$1() {
  this.protocol = null;
  this.slashes = null;
  this.auth = null;
  this.host = null;
  this.port = null;
  this.hostname = null;
  this.hash = null;
  this.search = null;
  this.query = null;
  this.pathname = null;
  this.path = null;
  this.href = null;
}
var protocolPattern = /^([a-z0-9.+-]+:)/i, portPattern = /:[0-9]*$/, simplePathPattern = /^(\/\/?(?!\/)[^\?\s]*)(\?[^\s]*)?$/, delims = ["<", ">", '"', "`", " ", "\r", "\n", "	"], unwise = ["{", "}", "|", "\\", "^", "`"].concat(delims), autoEscape = ["'"].concat(unwise), nonHostChars = ["%", "/", "?", ";", "#"].concat(autoEscape), hostEndingChars = ["/", "?", "#"], hostnameMaxLen = 255, hostnamePartPattern = /^[+a-z0-9A-Z_-]{0,63}$/, hostnamePartStart = /^([+a-z0-9A-Z_-]{0,63})(.*)$/, unsafeProtocol = {
  "javascript": true,
  "javascript:": true
}, hostlessProtocol = {
  "javascript": true,
  "javascript:": true
}, slashedProtocol = {
  "http": true,
  "https": true,
  "ftp": true,
  "gopher": true,
  "file": true,
  "http:": true,
  "https:": true,
  "ftp:": true,
  "gopher:": true,
  "file:": true
}, querystring = querystring$1;
function urlParse(url2, parseQueryString, slashesDenoteHost) {
  if (url2 && util$7.isObject(url2) && url2 instanceof Url$1)
    return url2;
  var u2 = new Url$1();
  u2.parse(url2, parseQueryString, slashesDenoteHost);
  return u2;
}
Url$1.prototype.parse = function(url2, parseQueryString, slashesDenoteHost) {
  if (!util$7.isString(url2)) {
    throw new TypeError("Parameter 'url' must be a string, not " + typeof url2);
  }
  var queryIndex = url2.indexOf("?"), splitter = queryIndex !== -1 && queryIndex < url2.indexOf("#") ? "?" : "#", uSplit = url2.split(splitter), slashRegex = /\\/g;
  uSplit[0] = uSplit[0].replace(slashRegex, "/");
  url2 = uSplit.join(splitter);
  var rest = url2;
  rest = rest.trim();
  if (!slashesDenoteHost && url2.split("#").length === 1) {
    var simplePath = simplePathPattern.exec(rest);
    if (simplePath) {
      this.path = rest;
      this.href = rest;
      this.pathname = simplePath[1];
      if (simplePath[2]) {
        this.search = simplePath[2];
        if (parseQueryString) {
          this.query = querystring.parse(this.search.substr(1));
        } else {
          this.query = this.search.substr(1);
        }
      } else if (parseQueryString) {
        this.search = "";
        this.query = {};
      }
      return this;
    }
  }
  var proto = protocolPattern.exec(rest);
  if (proto) {
    proto = proto[0];
    var lowerProto = proto.toLowerCase();
    this.protocol = lowerProto;
    rest = rest.substr(proto.length);
  }
  if (slashesDenoteHost || proto || rest.match(/^\/\/[^@\/]+@[^@\/]+/)) {
    var slashes = rest.substr(0, 2) === "//";
    if (slashes && !(proto && hostlessProtocol[proto])) {
      rest = rest.substr(2);
      this.slashes = true;
    }
  }
  if (!hostlessProtocol[proto] && (slashes || proto && !slashedProtocol[proto])) {
    var hostEnd = -1;
    for (var i2 = 0; i2 < hostEndingChars.length; i2++) {
      var hec = rest.indexOf(hostEndingChars[i2]);
      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))
        hostEnd = hec;
    }
    var auth, atSign;
    if (hostEnd === -1) {
      atSign = rest.lastIndexOf("@");
    } else {
      atSign = rest.lastIndexOf("@", hostEnd);
    }
    if (atSign !== -1) {
      auth = rest.slice(0, atSign);
      rest = rest.slice(atSign + 1);
      this.auth = decodeURIComponent(auth);
    }
    hostEnd = -1;
    for (var i2 = 0; i2 < nonHostChars.length; i2++) {
      var hec = rest.indexOf(nonHostChars[i2]);
      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))
        hostEnd = hec;
    }
    if (hostEnd === -1)
      hostEnd = rest.length;
    this.host = rest.slice(0, hostEnd);
    rest = rest.slice(hostEnd);
    this.parseHost();
    this.hostname = this.hostname || "";
    var ipv6Hostname = this.hostname[0] === "[" && this.hostname[this.hostname.length - 1] === "]";
    if (!ipv6Hostname) {
      var hostparts = this.hostname.split(/\./);
      for (var i2 = 0, l2 = hostparts.length; i2 < l2; i2++) {
        var part = hostparts[i2];
        if (!part)
          continue;
        if (!part.match(hostnamePartPattern)) {
          var newpart = "";
          for (var j2 = 0, k = part.length; j2 < k; j2++) {
            if (part.charCodeAt(j2) > 127) {
              newpart += "x";
            } else {
              newpart += part[j2];
            }
          }
          if (!newpart.match(hostnamePartPattern)) {
            var validParts = hostparts.slice(0, i2);
            var notHost = hostparts.slice(i2 + 1);
            var bit = part.match(hostnamePartStart);
            if (bit) {
              validParts.push(bit[1]);
              notHost.unshift(bit[2]);
            }
            if (notHost.length) {
              rest = "/" + notHost.join(".") + rest;
            }
            this.hostname = validParts.join(".");
            break;
          }
        }
      }
    }
    if (this.hostname.length > hostnameMaxLen) {
      this.hostname = "";
    } else {
      this.hostname = this.hostname.toLowerCase();
    }
    if (!ipv6Hostname) {
      this.hostname = punycode.toASCII(this.hostname);
    }
    var p2 = this.port ? ":" + this.port : "";
    var h2 = this.hostname || "";
    this.host = h2 + p2;
    this.href += this.host;
    if (ipv6Hostname) {
      this.hostname = this.hostname.substr(1, this.hostname.length - 2);
      if (rest[0] !== "/") {
        rest = "/" + rest;
      }
    }
  }
  if (!unsafeProtocol[lowerProto]) {
    for (var i2 = 0, l2 = autoEscape.length; i2 < l2; i2++) {
      var ae = autoEscape[i2];
      if (rest.indexOf(ae) === -1)
        continue;
      var esc = encodeURIComponent(ae);
      if (esc === ae) {
        esc = escape(ae);
      }
      rest = rest.split(ae).join(esc);
    }
  }
  var hash2 = rest.indexOf("#");
  if (hash2 !== -1) {
    this.hash = rest.substr(hash2);
    rest = rest.slice(0, hash2);
  }
  var qm = rest.indexOf("?");
  if (qm !== -1) {
    this.search = rest.substr(qm);
    this.query = rest.substr(qm + 1);
    if (parseQueryString) {
      this.query = querystring.parse(this.query);
    }
    rest = rest.slice(0, qm);
  } else if (parseQueryString) {
    this.search = "";
    this.query = {};
  }
  if (rest)
    this.pathname = rest;
  if (slashedProtocol[lowerProto] && this.hostname && !this.pathname) {
    this.pathname = "/";
  }
  if (this.pathname || this.search) {
    var p2 = this.pathname || "";
    var s2 = this.search || "";
    this.path = p2 + s2;
  }
  this.href = this.format();
  return this;
};
function urlFormat(obj) {
  if (util$7.isString(obj))
    obj = urlParse(obj);
  if (!(obj instanceof Url$1))
    return Url$1.prototype.format.call(obj);
  return obj.format();
}
Url$1.prototype.format = function() {
  var auth = this.auth || "";
  if (auth) {
    auth = encodeURIComponent(auth);
    auth = auth.replace(/%3A/i, ":");
    auth += "@";
  }
  var protocol2 = this.protocol || "", pathname = this.pathname || "", hash2 = this.hash || "", host = false, query = "";
  if (this.host) {
    host = auth + this.host;
  } else if (this.hostname) {
    host = auth + (this.hostname.indexOf(":") === -1 ? this.hostname : "[" + this.hostname + "]");
    if (this.port) {
      host += ":" + this.port;
    }
  }
  if (this.query && util$7.isObject(this.query) && Object.keys(this.query).length) {
    query = querystring.stringify(this.query);
  }
  var search = this.search || query && "?" + query || "";
  if (protocol2 && protocol2.substr(-1) !== ":")
    protocol2 += ":";
  if (this.slashes || (!protocol2 || slashedProtocol[protocol2]) && host !== false) {
    host = "//" + (host || "");
    if (pathname && pathname.charAt(0) !== "/")
      pathname = "/" + pathname;
  } else if (!host) {
    host = "";
  }
  if (hash2 && hash2.charAt(0) !== "#")
    hash2 = "#" + hash2;
  if (search && search.charAt(0) !== "?")
    search = "?" + search;
  pathname = pathname.replace(/[?#]/g, function(match) {
    return encodeURIComponent(match);
  });
  search = search.replace("#", "%23");
  return protocol2 + host + pathname + search + hash2;
};
function urlResolve(source, relative) {
  return urlParse(source, false, true).resolve(relative);
}
Url$1.prototype.resolve = function(relative) {
  return this.resolveObject(urlParse(relative, false, true)).format();
};
Url$1.prototype.resolveObject = function(relative) {
  if (util$7.isString(relative)) {
    var rel = new Url$1();
    rel.parse(relative, false, true);
    relative = rel;
  }
  var result = new Url$1();
  var tkeys = Object.keys(this);
  for (var tk = 0; tk < tkeys.length; tk++) {
    var tkey = tkeys[tk];
    result[tkey] = this[tkey];
  }
  result.hash = relative.hash;
  if (relative.href === "") {
    result.href = result.format();
    return result;
  }
  if (relative.slashes && !relative.protocol) {
    var rkeys = Object.keys(relative);
    for (var rk = 0; rk < rkeys.length; rk++) {
      var rkey = rkeys[rk];
      if (rkey !== "protocol")
        result[rkey] = relative[rkey];
    }
    if (slashedProtocol[result.protocol] && result.hostname && !result.pathname) {
      result.path = result.pathname = "/";
    }
    result.href = result.format();
    return result;
  }
  if (relative.protocol && relative.protocol !== result.protocol) {
    if (!slashedProtocol[relative.protocol]) {
      var keys = Object.keys(relative);
      for (var v2 = 0; v2 < keys.length; v2++) {
        var k = keys[v2];
        result[k] = relative[k];
      }
      result.href = result.format();
      return result;
    }
    result.protocol = relative.protocol;
    if (!relative.host && !hostlessProtocol[relative.protocol]) {
      var relPath = (relative.pathname || "").split("/");
      while (relPath.length && !(relative.host = relPath.shift()))
        ;
      if (!relative.host)
        relative.host = "";
      if (!relative.hostname)
        relative.hostname = "";
      if (relPath[0] !== "")
        relPath.unshift("");
      if (relPath.length < 2)
        relPath.unshift("");
      result.pathname = relPath.join("/");
    } else {
      result.pathname = relative.pathname;
    }
    result.search = relative.search;
    result.query = relative.query;
    result.host = relative.host || "";
    result.auth = relative.auth;
    result.hostname = relative.hostname || relative.host;
    result.port = relative.port;
    if (result.pathname || result.search) {
      var p2 = result.pathname || "";
      var s2 = result.search || "";
      result.path = p2 + s2;
    }
    result.slashes = result.slashes || relative.slashes;
    result.href = result.format();
    return result;
  }
  var isSourceAbs = result.pathname && result.pathname.charAt(0) === "/", isRelAbs = relative.host || relative.pathname && relative.pathname.charAt(0) === "/", mustEndAbs = isRelAbs || isSourceAbs || result.host && relative.pathname, removeAllDots = mustEndAbs, srcPath = result.pathname && result.pathname.split("/") || [], relPath = relative.pathname && relative.pathname.split("/") || [], psychotic = result.protocol && !slashedProtocol[result.protocol];
  if (psychotic) {
    result.hostname = "";
    result.port = null;
    if (result.host) {
      if (srcPath[0] === "")
        srcPath[0] = result.host;
      else
        srcPath.unshift(result.host);
    }
    result.host = "";
    if (relative.protocol) {
      relative.hostname = null;
      relative.port = null;
      if (relative.host) {
        if (relPath[0] === "")
          relPath[0] = relative.host;
        else
          relPath.unshift(relative.host);
      }
      relative.host = null;
    }
    mustEndAbs = mustEndAbs && (relPath[0] === "" || srcPath[0] === "");
  }
  if (isRelAbs) {
    result.host = relative.host || relative.host === "" ? relative.host : result.host;
    result.hostname = relative.hostname || relative.hostname === "" ? relative.hostname : result.hostname;
    result.search = relative.search;
    result.query = relative.query;
    srcPath = relPath;
  } else if (relPath.length) {
    if (!srcPath)
      srcPath = [];
    srcPath.pop();
    srcPath = srcPath.concat(relPath);
    result.search = relative.search;
    result.query = relative.query;
  } else if (!util$7.isNullOrUndefined(relative.search)) {
    if (psychotic) {
      result.hostname = result.host = srcPath.shift();
      var authInHost = result.host && result.host.indexOf("@") > 0 ? result.host.split("@") : false;
      if (authInHost) {
        result.auth = authInHost.shift();
        result.host = result.hostname = authInHost.shift();
      }
    }
    result.search = relative.search;
    result.query = relative.query;
    if (!util$7.isNull(result.pathname) || !util$7.isNull(result.search)) {
      result.path = (result.pathname ? result.pathname : "") + (result.search ? result.search : "");
    }
    result.href = result.format();
    return result;
  }
  if (!srcPath.length) {
    result.pathname = null;
    if (result.search) {
      result.path = "/" + result.search;
    } else {
      result.path = null;
    }
    result.href = result.format();
    return result;
  }
  var last = srcPath.slice(-1)[0];
  var hasTrailingSlash = (result.host || relative.host || srcPath.length > 1) && (last === "." || last === "..") || last === "";
  var up = 0;
  for (var i2 = srcPath.length; i2 >= 0; i2--) {
    last = srcPath[i2];
    if (last === ".") {
      srcPath.splice(i2, 1);
    } else if (last === "..") {
      srcPath.splice(i2, 1);
      up++;
    } else if (up) {
      srcPath.splice(i2, 1);
      up--;
    }
  }
  if (!mustEndAbs && !removeAllDots) {
    for (; up--; up) {
      srcPath.unshift("..");
    }
  }
  if (mustEndAbs && srcPath[0] !== "" && (!srcPath[0] || srcPath[0].charAt(0) !== "/")) {
    srcPath.unshift("");
  }
  if (hasTrailingSlash && srcPath.join("/").substr(-1) !== "/") {
    srcPath.push("");
  }
  var isAbsolute = srcPath[0] === "" || srcPath[0] && srcPath[0].charAt(0) === "/";
  if (psychotic) {
    result.hostname = result.host = isAbsolute ? "" : srcPath.length ? srcPath.shift() : "";
    var authInHost = result.host && result.host.indexOf("@") > 0 ? result.host.split("@") : false;
    if (authInHost) {
      result.auth = authInHost.shift();
      result.host = result.hostname = authInHost.shift();
    }
  }
  mustEndAbs = mustEndAbs || result.host && srcPath.length;
  if (mustEndAbs && !isAbsolute) {
    srcPath.unshift("");
  }
  if (!srcPath.length) {
    result.pathname = null;
    result.path = null;
  } else {
    result.pathname = srcPath.join("/");
  }
  if (!util$7.isNull(result.pathname) || !util$7.isNull(result.search)) {
    result.path = (result.pathname ? result.pathname : "") + (result.search ? result.search : "");
  }
  result.auth = relative.auth || result.auth;
  result.slashes = result.slashes || relative.slashes;
  result.href = result.format();
  return result;
};
Url$1.prototype.parseHost = function() {
  var host = this.host;
  var port = portPattern.exec(host);
  if (port) {
    port = port[0];
    if (port !== ":") {
      this.port = port.substr(1);
    }
    host = host.substr(0, host.length - port.length);
  }
  if (host)
    this.hostname = host;
};
/*!
 * @pixi/utils - v6.3.0
 * Compiled Wed, 23 Mar 2022 18:58:56 UTC
 *
 * @pixi/utils is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
var url = {
  parse: parse$1,
  format,
  resolve: resolve$1
};
settings.RETINA_PREFIX = /@([0-9\.]+)x/;
settings.FAIL_IF_MAJOR_PERFORMANCE_CAVEAT = false;
var saidHello = false;
var VERSION = "6.3.0";
function skipHello() {
  saidHello = true;
}
function sayHello(type) {
  var _a3;
  if (saidHello) {
    return;
  }
  if (navigator.userAgent.toLowerCase().indexOf("chrome") > -1) {
    var args = [
      "\n %c %c %c PixiJS " + VERSION + " - \u2730 " + type + " \u2730  %c  %c  http://www.pixijs.com/  %c %c \u2665%c\u2665%c\u2665 \n\n",
      "background: #ff66a5; padding:5px 0;",
      "background: #ff66a5; padding:5px 0;",
      "color: #ff66a5; background: #030307; padding:5px 0;",
      "background: #ff66a5; padding:5px 0;",
      "background: #ffc3dc; padding:5px 0;",
      "background: #ff66a5; padding:5px 0;",
      "color: #ff2424; background: #fff; padding:5px 0;",
      "color: #ff2424; background: #fff; padding:5px 0;",
      "color: #ff2424; background: #fff; padding:5px 0;"
    ];
    (_a3 = globalThis.console).log.apply(_a3, args);
  } else if (globalThis.console) {
    globalThis.console.log("PixiJS " + VERSION + " - " + type + " - http://www.pixijs.com/");
  }
  saidHello = true;
}
var supported;
function isWebGLSupported() {
  if (typeof supported === "undefined") {
    supported = function supported2() {
      var contextOptions = {
        stencil: true,
        failIfMajorPerformanceCaveat: settings.FAIL_IF_MAJOR_PERFORMANCE_CAVEAT
      };
      try {
        if (!globalThis.WebGLRenderingContext) {
          return false;
        }
        var canvas2 = document.createElement("canvas");
        var gl = canvas2.getContext("webgl", contextOptions) || canvas2.getContext("experimental-webgl", contextOptions);
        var success = !!(gl && gl.getContextAttributes().stencil);
        if (gl) {
          var loseContext = gl.getExtension("WEBGL_lose_context");
          if (loseContext) {
            loseContext.loseContext();
          }
        }
        gl = null;
        return success;
      } catch (e) {
        return false;
      }
    }();
  }
  return supported;
}
var aliceblue = "#f0f8ff";
var antiquewhite = "#faebd7";
var aqua = "#00ffff";
var aquamarine = "#7fffd4";
var azure = "#f0ffff";
var beige = "#f5f5dc";
var bisque = "#ffe4c4";
var black = "#000000";
var blanchedalmond = "#ffebcd";
var blue = "#0000ff";
var blueviolet = "#8a2be2";
var brown = "#a52a2a";
var burlywood = "#deb887";
var cadetblue = "#5f9ea0";
var chartreuse = "#7fff00";
var chocolate = "#d2691e";
var coral = "#ff7f50";
var cornflowerblue = "#6495ed";
var cornsilk = "#fff8dc";
var crimson = "#dc143c";
var cyan = "#00ffff";
var darkblue = "#00008b";
var darkcyan = "#008b8b";
var darkgoldenrod = "#b8860b";
var darkgray = "#a9a9a9";
var darkgreen = "#006400";
var darkgrey = "#a9a9a9";
var darkkhaki = "#bdb76b";
var darkmagenta = "#8b008b";
var darkolivegreen = "#556b2f";
var darkorange = "#ff8c00";
var darkorchid = "#9932cc";
var darkred = "#8b0000";
var darksalmon = "#e9967a";
var darkseagreen = "#8fbc8f";
var darkslateblue = "#483d8b";
var darkslategray = "#2f4f4f";
var darkslategrey = "#2f4f4f";
var darkturquoise = "#00ced1";
var darkviolet = "#9400d3";
var deeppink = "#ff1493";
var deepskyblue = "#00bfff";
var dimgray = "#696969";
var dimgrey = "#696969";
var dodgerblue = "#1e90ff";
var firebrick = "#b22222";
var floralwhite = "#fffaf0";
var forestgreen = "#228b22";
var fuchsia = "#ff00ff";
var gainsboro = "#dcdcdc";
var ghostwhite = "#f8f8ff";
var goldenrod = "#daa520";
var gold = "#ffd700";
var gray = "#808080";
var green = "#008000";
var greenyellow = "#adff2f";
var grey = "#808080";
var honeydew = "#f0fff0";
var hotpink = "#ff69b4";
var indianred = "#cd5c5c";
var indigo = "#4b0082";
var ivory = "#fffff0";
var khaki = "#f0e68c";
var lavenderblush = "#fff0f5";
var lavender = "#e6e6fa";
var lawngreen = "#7cfc00";
var lemonchiffon = "#fffacd";
var lightblue = "#add8e6";
var lightcoral = "#f08080";
var lightcyan = "#e0ffff";
var lightgoldenrodyellow = "#fafad2";
var lightgray = "#d3d3d3";
var lightgreen = "#90ee90";
var lightgrey = "#d3d3d3";
var lightpink = "#ffb6c1";
var lightsalmon = "#ffa07a";
var lightseagreen = "#20b2aa";
var lightskyblue = "#87cefa";
var lightslategray = "#778899";
var lightslategrey = "#778899";
var lightsteelblue = "#b0c4de";
var lightyellow = "#ffffe0";
var lime = "#00ff00";
var limegreen = "#32cd32";
var linen = "#faf0e6";
var magenta = "#ff00ff";
var maroon = "#800000";
var mediumaquamarine = "#66cdaa";
var mediumblue = "#0000cd";
var mediumorchid = "#ba55d3";
var mediumpurple = "#9370db";
var mediumseagreen = "#3cb371";
var mediumslateblue = "#7b68ee";
var mediumspringgreen = "#00fa9a";
var mediumturquoise = "#48d1cc";
var mediumvioletred = "#c71585";
var midnightblue = "#191970";
var mintcream = "#f5fffa";
var mistyrose = "#ffe4e1";
var moccasin = "#ffe4b5";
var navajowhite = "#ffdead";
var navy = "#000080";
var oldlace = "#fdf5e6";
var olive = "#808000";
var olivedrab = "#6b8e23";
var orange = "#ffa500";
var orangered = "#ff4500";
var orchid = "#da70d6";
var palegoldenrod = "#eee8aa";
var palegreen = "#98fb98";
var paleturquoise = "#afeeee";
var palevioletred = "#db7093";
var papayawhip = "#ffefd5";
var peachpuff = "#ffdab9";
var peru = "#cd853f";
var pink = "#ffc0cb";
var plum = "#dda0dd";
var powderblue = "#b0e0e6";
var purple = "#800080";
var rebeccapurple = "#663399";
var red = "#ff0000";
var rosybrown = "#bc8f8f";
var royalblue = "#4169e1";
var saddlebrown = "#8b4513";
var salmon = "#fa8072";
var sandybrown = "#f4a460";
var seagreen = "#2e8b57";
var seashell = "#fff5ee";
var sienna = "#a0522d";
var silver = "#c0c0c0";
var skyblue = "#87ceeb";
var slateblue = "#6a5acd";
var slategray = "#708090";
var slategrey = "#708090";
var snow = "#fffafa";
var springgreen = "#00ff7f";
var steelblue = "#4682b4";
var tan = "#d2b48c";
var teal = "#008080";
var thistle = "#d8bfd8";
var tomato = "#ff6347";
var turquoise = "#40e0d0";
var violet = "#ee82ee";
var wheat = "#f5deb3";
var white = "#ffffff";
var whitesmoke = "#f5f5f5";
var yellow = "#ffff00";
var yellowgreen = "#9acd32";
var cssColorNames = {
  aliceblue,
  antiquewhite,
  aqua,
  aquamarine,
  azure,
  beige,
  bisque,
  black,
  blanchedalmond,
  blue,
  blueviolet,
  brown,
  burlywood,
  cadetblue,
  chartreuse,
  chocolate,
  coral,
  cornflowerblue,
  cornsilk,
  crimson,
  cyan,
  darkblue,
  darkcyan,
  darkgoldenrod,
  darkgray,
  darkgreen,
  darkgrey,
  darkkhaki,
  darkmagenta,
  darkolivegreen,
  darkorange,
  darkorchid,
  darkred,
  darksalmon,
  darkseagreen,
  darkslateblue,
  darkslategray,
  darkslategrey,
  darkturquoise,
  darkviolet,
  deeppink,
  deepskyblue,
  dimgray,
  dimgrey,
  dodgerblue,
  firebrick,
  floralwhite,
  forestgreen,
  fuchsia,
  gainsboro,
  ghostwhite,
  goldenrod,
  gold,
  gray,
  green,
  greenyellow,
  grey,
  honeydew,
  hotpink,
  indianred,
  indigo,
  ivory,
  khaki,
  lavenderblush,
  lavender,
  lawngreen,
  lemonchiffon,
  lightblue,
  lightcoral,
  lightcyan,
  lightgoldenrodyellow,
  lightgray,
  lightgreen,
  lightgrey,
  lightpink,
  lightsalmon,
  lightseagreen,
  lightskyblue,
  lightslategray,
  lightslategrey,
  lightsteelblue,
  lightyellow,
  lime,
  limegreen,
  linen,
  magenta,
  maroon,
  mediumaquamarine,
  mediumblue,
  mediumorchid,
  mediumpurple,
  mediumseagreen,
  mediumslateblue,
  mediumspringgreen,
  mediumturquoise,
  mediumvioletred,
  midnightblue,
  mintcream,
  mistyrose,
  moccasin,
  navajowhite,
  navy,
  oldlace,
  olive,
  olivedrab,
  orange,
  orangered,
  orchid,
  palegoldenrod,
  palegreen,
  paleturquoise,
  palevioletred,
  papayawhip,
  peachpuff,
  peru,
  pink,
  plum,
  powderblue,
  purple,
  rebeccapurple,
  red,
  rosybrown,
  royalblue,
  saddlebrown,
  salmon,
  sandybrown,
  seagreen,
  seashell,
  sienna,
  silver,
  skyblue,
  slateblue,
  slategray,
  slategrey,
  snow,
  springgreen,
  steelblue,
  tan,
  teal,
  thistle,
  tomato,
  turquoise,
  violet,
  wheat,
  white,
  whitesmoke,
  yellow,
  yellowgreen
};
function hex2rgb(hex, out) {
  if (out === void 0) {
    out = [];
  }
  out[0] = (hex >> 16 & 255) / 255;
  out[1] = (hex >> 8 & 255) / 255;
  out[2] = (hex & 255) / 255;
  return out;
}
function hex2string(hex) {
  var hexString = hex.toString(16);
  hexString = "000000".substring(0, 6 - hexString.length) + hexString;
  return "#" + hexString;
}
function string2hex(string) {
  if (typeof string === "string") {
    string = cssColorNames[string.toLowerCase()] || string;
    if (string[0] === "#") {
      string = string.slice(1);
    }
  }
  return parseInt(string, 16);
}
function mapPremultipliedBlendModes() {
  var pm = [];
  var npm = [];
  for (var i2 = 0; i2 < 32; i2++) {
    pm[i2] = i2;
    npm[i2] = i2;
  }
  pm[BLEND_MODES$3.NORMAL_NPM] = BLEND_MODES$3.NORMAL;
  pm[BLEND_MODES$3.ADD_NPM] = BLEND_MODES$3.ADD;
  pm[BLEND_MODES$3.SCREEN_NPM] = BLEND_MODES$3.SCREEN;
  npm[BLEND_MODES$3.NORMAL] = BLEND_MODES$3.NORMAL_NPM;
  npm[BLEND_MODES$3.ADD] = BLEND_MODES$3.ADD_NPM;
  npm[BLEND_MODES$3.SCREEN] = BLEND_MODES$3.SCREEN_NPM;
  var array = [];
  array.push(npm);
  array.push(pm);
  return array;
}
var premultiplyBlendMode = mapPremultipliedBlendModes();
function correctBlendMode(blendMode, premultiplied) {
  return premultiplyBlendMode[premultiplied ? 1 : 0][blendMode];
}
function premultiplyRgba(rgb, alpha, out, premultiply) {
  out = out || new Float32Array(4);
  if (premultiply || premultiply === void 0) {
    out[0] = rgb[0] * alpha;
    out[1] = rgb[1] * alpha;
    out[2] = rgb[2] * alpha;
  } else {
    out[0] = rgb[0];
    out[1] = rgb[1];
    out[2] = rgb[2];
  }
  out[3] = alpha;
  return out;
}
function premultiplyTint(tint, alpha) {
  if (alpha === 1) {
    return (alpha * 255 << 24) + tint;
  }
  if (alpha === 0) {
    return 0;
  }
  var R = tint >> 16 & 255;
  var G2 = tint >> 8 & 255;
  var B = tint & 255;
  R = R * alpha + 0.5 | 0;
  G2 = G2 * alpha + 0.5 | 0;
  B = B * alpha + 0.5 | 0;
  return (alpha * 255 << 24) + (R << 16) + (G2 << 8) + B;
}
function premultiplyTintToRgba(tint, alpha, out, premultiply) {
  out = out || new Float32Array(4);
  out[0] = (tint >> 16 & 255) / 255;
  out[1] = (tint >> 8 & 255) / 255;
  out[2] = (tint & 255) / 255;
  if (premultiply || premultiply === void 0) {
    out[0] *= alpha;
    out[1] *= alpha;
    out[2] *= alpha;
  }
  out[3] = alpha;
  return out;
}
function createIndicesForQuads(size, outBuffer) {
  if (outBuffer === void 0) {
    outBuffer = null;
  }
  var totalIndices = size * 6;
  outBuffer = outBuffer || new Uint16Array(totalIndices);
  if (outBuffer.length !== totalIndices) {
    throw new Error("Out buffer length is incorrect, got " + outBuffer.length + " and expected " + totalIndices);
  }
  for (var i2 = 0, j2 = 0; i2 < totalIndices; i2 += 6, j2 += 4) {
    outBuffer[i2 + 0] = j2 + 0;
    outBuffer[i2 + 1] = j2 + 1;
    outBuffer[i2 + 2] = j2 + 2;
    outBuffer[i2 + 3] = j2 + 0;
    outBuffer[i2 + 4] = j2 + 2;
    outBuffer[i2 + 5] = j2 + 3;
  }
  return outBuffer;
}
function getBufferType(array) {
  if (array.BYTES_PER_ELEMENT === 4) {
    if (array instanceof Float32Array) {
      return "Float32Array";
    } else if (array instanceof Uint32Array) {
      return "Uint32Array";
    }
    return "Int32Array";
  } else if (array.BYTES_PER_ELEMENT === 2) {
    if (array instanceof Uint16Array) {
      return "Uint16Array";
    }
  } else if (array.BYTES_PER_ELEMENT === 1) {
    if (array instanceof Uint8Array) {
      return "Uint8Array";
    }
  }
  return null;
}
function nextPow2(v2) {
  v2 += v2 === 0 ? 1 : 0;
  --v2;
  v2 |= v2 >>> 1;
  v2 |= v2 >>> 2;
  v2 |= v2 >>> 4;
  v2 |= v2 >>> 8;
  v2 |= v2 >>> 16;
  return v2 + 1;
}
function isPow2(v2) {
  return !(v2 & v2 - 1) && !!v2;
}
function log2(v2) {
  var r2 = (v2 > 65535 ? 1 : 0) << 4;
  v2 >>>= r2;
  var shift = (v2 > 255 ? 1 : 0) << 3;
  v2 >>>= shift;
  r2 |= shift;
  shift = (v2 > 15 ? 1 : 0) << 2;
  v2 >>>= shift;
  r2 |= shift;
  shift = (v2 > 3 ? 1 : 0) << 1;
  v2 >>>= shift;
  r2 |= shift;
  return r2 | v2 >> 1;
}
function removeItems(arr, startIdx, removeCount) {
  var length2 = arr.length;
  var i2;
  if (startIdx >= length2 || removeCount === 0) {
    return;
  }
  removeCount = startIdx + removeCount > length2 ? length2 - startIdx : removeCount;
  var len = length2 - removeCount;
  for (i2 = startIdx; i2 < len; ++i2) {
    arr[i2] = arr[i2 + removeCount];
  }
  arr.length = len;
}
function sign(n) {
  if (n === 0) {
    return 0;
  }
  return n < 0 ? -1 : 1;
}
var nextUid = 0;
function uid() {
  return ++nextUid;
}
var warnings = {};
function deprecation(version2, message, ignoreDepth) {
  if (ignoreDepth === void 0) {
    ignoreDepth = 3;
  }
  if (warnings[message]) {
    return;
  }
  var stack = new Error().stack;
  if (typeof stack === "undefined") {
    console.warn("PixiJS Deprecation Warning: ", message + "\nDeprecated since v" + version2);
  } else {
    stack = stack.split("\n").splice(ignoreDepth).join("\n");
    if (console.groupCollapsed) {
      console.groupCollapsed("%cPixiJS Deprecation Warning: %c%s", "color:#614108;background:#fffbe6", "font-weight:normal;color:#614108;background:#fffbe6", message + "\nDeprecated since v" + version2);
      console.warn(stack);
      console.groupEnd();
    } else {
      console.warn("PixiJS Deprecation Warning: ", message + "\nDeprecated since v" + version2);
      console.warn(stack);
    }
  }
  warnings[message] = true;
}
var ProgramCache = {};
var TextureCache = /* @__PURE__ */ Object.create(null);
var BaseTextureCache = /* @__PURE__ */ Object.create(null);
function clearTextureCache() {
  var key;
  for (key in TextureCache) {
    delete TextureCache[key];
  }
  for (key in BaseTextureCache) {
    delete BaseTextureCache[key];
  }
}
var CanvasRenderTarget = function() {
  function CanvasRenderTarget2(width, height, resolution) {
    this.canvas = document.createElement("canvas");
    this.context = this.canvas.getContext("2d");
    this.resolution = resolution || settings.RESOLUTION;
    this.resize(width, height);
  }
  CanvasRenderTarget2.prototype.clear = function() {
    this.context.setTransform(1, 0, 0, 1, 0, 0);
    this.context.clearRect(0, 0, this.canvas.width, this.canvas.height);
  };
  CanvasRenderTarget2.prototype.resize = function(desiredWidth, desiredHeight) {
    this.canvas.width = Math.round(desiredWidth * this.resolution);
    this.canvas.height = Math.round(desiredHeight * this.resolution);
  };
  CanvasRenderTarget2.prototype.destroy = function() {
    this.context = null;
    this.canvas = null;
  };
  Object.defineProperty(CanvasRenderTarget2.prototype, "width", {
    get: function() {
      return this.canvas.width;
    },
    set: function(val) {
      this.canvas.width = Math.round(val);
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(CanvasRenderTarget2.prototype, "height", {
    get: function() {
      return this.canvas.height;
    },
    set: function(val) {
      this.canvas.height = Math.round(val);
    },
    enumerable: false,
    configurable: true
  });
  return CanvasRenderTarget2;
}();
function trimCanvas(canvas2) {
  var width = canvas2.width;
  var height = canvas2.height;
  var context2 = canvas2.getContext("2d");
  var imageData = context2.getImageData(0, 0, width, height);
  var pixels = imageData.data;
  var len = pixels.length;
  var bound = {
    top: null,
    left: null,
    right: null,
    bottom: null
  };
  var data = null;
  var i2;
  var x2;
  var y2;
  for (i2 = 0; i2 < len; i2 += 4) {
    if (pixels[i2 + 3] !== 0) {
      x2 = i2 / 4 % width;
      y2 = ~~(i2 / 4 / width);
      if (bound.top === null) {
        bound.top = y2;
      }
      if (bound.left === null) {
        bound.left = x2;
      } else if (x2 < bound.left) {
        bound.left = x2;
      }
      if (bound.right === null) {
        bound.right = x2 + 1;
      } else if (bound.right < x2) {
        bound.right = x2 + 1;
      }
      if (bound.bottom === null) {
        bound.bottom = y2;
      } else if (bound.bottom < y2) {
        bound.bottom = y2;
      }
    }
  }
  if (bound.top !== null) {
    width = bound.right - bound.left;
    height = bound.bottom - bound.top + 1;
    data = context2.getImageData(bound.left, bound.top, width, height);
  }
  return {
    height,
    width,
    data
  };
}
var tempAnchor$1;
function determineCrossOrigin(url$12, loc) {
  if (loc === void 0) {
    loc = globalThis.location;
  }
  if (url$12.indexOf("data:") === 0) {
    return "";
  }
  loc = loc || globalThis.location;
  if (!tempAnchor$1) {
    tempAnchor$1 = document.createElement("a");
  }
  tempAnchor$1.href = url$12;
  var parsedUrl = url.parse(tempAnchor$1.href);
  var samePort = !parsedUrl.port && loc.port === "" || parsedUrl.port === loc.port;
  if (parsedUrl.hostname !== loc.hostname || !samePort || parsedUrl.protocol !== loc.protocol) {
    return "anonymous";
  }
  return "";
}
function getResolutionOfUrl(url2, defaultValue2) {
  var resolution = settings.RETINA_PREFIX.exec(url2);
  if (resolution) {
    return parseFloat(resolution[1]);
  }
  return defaultValue2 !== void 0 ? defaultValue2 : 1;
}
/*!
 * @pixi/runner - v6.3.0
 * Compiled Wed, 23 Mar 2022 18:58:56 UTC
 *
 * @pixi/runner is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
var Runner = function() {
  function Runner2(name2) {
    this.items = [];
    this._name = name2;
    this._aliasCount = 0;
  }
  Runner2.prototype.emit = function(a0, a1, a2, a3, a4, a5, a6, a7) {
    if (arguments.length > 8) {
      throw new Error("max arguments reached");
    }
    var _a3 = this, name2 = _a3.name, items = _a3.items;
    this._aliasCount++;
    for (var i2 = 0, len = items.length; i2 < len; i2++) {
      items[i2][name2](a0, a1, a2, a3, a4, a5, a6, a7);
    }
    if (items === this.items) {
      this._aliasCount--;
    }
    return this;
  };
  Runner2.prototype.ensureNonAliasedItems = function() {
    if (this._aliasCount > 0 && this.items.length > 1) {
      this._aliasCount = 0;
      this.items = this.items.slice(0);
    }
  };
  Runner2.prototype.add = function(item) {
    if (item[this._name]) {
      this.ensureNonAliasedItems();
      this.remove(item);
      this.items.push(item);
    }
    return this;
  };
  Runner2.prototype.remove = function(item) {
    var index = this.items.indexOf(item);
    if (index !== -1) {
      this.ensureNonAliasedItems();
      this.items.splice(index, 1);
    }
    return this;
  };
  Runner2.prototype.contains = function(item) {
    return this.items.indexOf(item) !== -1;
  };
  Runner2.prototype.removeAll = function() {
    this.ensureNonAliasedItems();
    this.items.length = 0;
    return this;
  };
  Runner2.prototype.destroy = function() {
    this.removeAll();
    this.items = null;
    this._name = null;
  };
  Object.defineProperty(Runner2.prototype, "empty", {
    get: function() {
      return this.items.length === 0;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Runner2.prototype, "name", {
    get: function() {
      return this._name;
    },
    enumerable: false,
    configurable: true
  });
  return Runner2;
}();
Object.defineProperties(Runner.prototype, {
  dispatch: { value: Runner.prototype.emit },
  run: { value: Runner.prototype.emit }
});
/*!
 * @pixi/ticker - v6.3.0
 * Compiled Wed, 23 Mar 2022 18:58:56 UTC
 *
 * @pixi/ticker is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
settings.TARGET_FPMS = 0.06;
var UPDATE_PRIORITY;
(function(UPDATE_PRIORITY2) {
  UPDATE_PRIORITY2[UPDATE_PRIORITY2["INTERACTION"] = 50] = "INTERACTION";
  UPDATE_PRIORITY2[UPDATE_PRIORITY2["HIGH"] = 25] = "HIGH";
  UPDATE_PRIORITY2[UPDATE_PRIORITY2["NORMAL"] = 0] = "NORMAL";
  UPDATE_PRIORITY2[UPDATE_PRIORITY2["LOW"] = -25] = "LOW";
  UPDATE_PRIORITY2[UPDATE_PRIORITY2["UTILITY"] = -50] = "UTILITY";
})(UPDATE_PRIORITY || (UPDATE_PRIORITY = {}));
var TickerListener = function() {
  function TickerListener2(fn, context2, priority, once) {
    if (context2 === void 0) {
      context2 = null;
    }
    if (priority === void 0) {
      priority = 0;
    }
    if (once === void 0) {
      once = false;
    }
    this.next = null;
    this.previous = null;
    this._destroyed = false;
    this.fn = fn;
    this.context = context2;
    this.priority = priority;
    this.once = once;
  }
  TickerListener2.prototype.match = function(fn, context2) {
    if (context2 === void 0) {
      context2 = null;
    }
    return this.fn === fn && this.context === context2;
  };
  TickerListener2.prototype.emit = function(deltaTime) {
    if (this.fn) {
      if (this.context) {
        this.fn.call(this.context, deltaTime);
      } else {
        this.fn(deltaTime);
      }
    }
    var redirect = this.next;
    if (this.once) {
      this.destroy(true);
    }
    if (this._destroyed) {
      this.next = null;
    }
    return redirect;
  };
  TickerListener2.prototype.connect = function(previous) {
    this.previous = previous;
    if (previous.next) {
      previous.next.previous = this;
    }
    this.next = previous.next;
    previous.next = this;
  };
  TickerListener2.prototype.destroy = function(hard) {
    if (hard === void 0) {
      hard = false;
    }
    this._destroyed = true;
    this.fn = null;
    this.context = null;
    if (this.previous) {
      this.previous.next = this.next;
    }
    if (this.next) {
      this.next.previous = this.previous;
    }
    var redirect = this.next;
    this.next = hard ? null : redirect;
    this.previous = null;
    return redirect;
  };
  return TickerListener2;
}();
var Ticker = function() {
  function Ticker2() {
    var _this = this;
    this.autoStart = false;
    this.deltaTime = 1;
    this.lastTime = -1;
    this.speed = 1;
    this.started = false;
    this._requestId = null;
    this._maxElapsedMS = 100;
    this._minElapsedMS = 0;
    this._protected = false;
    this._lastFrame = -1;
    this._head = new TickerListener(null, null, Infinity);
    this.deltaMS = 1 / settings.TARGET_FPMS;
    this.elapsedMS = 1 / settings.TARGET_FPMS;
    this._tick = function(time) {
      _this._requestId = null;
      if (_this.started) {
        _this.update(time);
        if (_this.started && _this._requestId === null && _this._head.next) {
          _this._requestId = requestAnimationFrame(_this._tick);
        }
      }
    };
  }
  Ticker2.prototype._requestIfNeeded = function() {
    if (this._requestId === null && this._head.next) {
      this.lastTime = performance.now();
      this._lastFrame = this.lastTime;
      this._requestId = requestAnimationFrame(this._tick);
    }
  };
  Ticker2.prototype._cancelIfNeeded = function() {
    if (this._requestId !== null) {
      cancelAnimationFrame(this._requestId);
      this._requestId = null;
    }
  };
  Ticker2.prototype._startIfPossible = function() {
    if (this.started) {
      this._requestIfNeeded();
    } else if (this.autoStart) {
      this.start();
    }
  };
  Ticker2.prototype.add = function(fn, context2, priority) {
    if (priority === void 0) {
      priority = UPDATE_PRIORITY.NORMAL;
    }
    return this._addListener(new TickerListener(fn, context2, priority));
  };
  Ticker2.prototype.addOnce = function(fn, context2, priority) {
    if (priority === void 0) {
      priority = UPDATE_PRIORITY.NORMAL;
    }
    return this._addListener(new TickerListener(fn, context2, priority, true));
  };
  Ticker2.prototype._addListener = function(listener) {
    var current = this._head.next;
    var previous = this._head;
    if (!current) {
      listener.connect(previous);
    } else {
      while (current) {
        if (listener.priority > current.priority) {
          listener.connect(previous);
          break;
        }
        previous = current;
        current = current.next;
      }
      if (!listener.previous) {
        listener.connect(previous);
      }
    }
    this._startIfPossible();
    return this;
  };
  Ticker2.prototype.remove = function(fn, context2) {
    var listener = this._head.next;
    while (listener) {
      if (listener.match(fn, context2)) {
        listener = listener.destroy();
      } else {
        listener = listener.next;
      }
    }
    if (!this._head.next) {
      this._cancelIfNeeded();
    }
    return this;
  };
  Object.defineProperty(Ticker2.prototype, "count", {
    get: function() {
      if (!this._head) {
        return 0;
      }
      var count = 0;
      var current = this._head;
      while (current = current.next) {
        count++;
      }
      return count;
    },
    enumerable: false,
    configurable: true
  });
  Ticker2.prototype.start = function() {
    if (!this.started) {
      this.started = true;
      this._requestIfNeeded();
    }
  };
  Ticker2.prototype.stop = function() {
    if (this.started) {
      this.started = false;
      this._cancelIfNeeded();
    }
  };
  Ticker2.prototype.destroy = function() {
    if (!this._protected) {
      this.stop();
      var listener = this._head.next;
      while (listener) {
        listener = listener.destroy(true);
      }
      this._head.destroy();
      this._head = null;
    }
  };
  Ticker2.prototype.update = function(currentTime) {
    if (currentTime === void 0) {
      currentTime = performance.now();
    }
    var elapsedMS;
    if (currentTime > this.lastTime) {
      elapsedMS = this.elapsedMS = currentTime - this.lastTime;
      if (elapsedMS > this._maxElapsedMS) {
        elapsedMS = this._maxElapsedMS;
      }
      elapsedMS *= this.speed;
      if (this._minElapsedMS) {
        var delta = currentTime - this._lastFrame | 0;
        if (delta < this._minElapsedMS) {
          return;
        }
        this._lastFrame = currentTime - delta % this._minElapsedMS;
      }
      this.deltaMS = elapsedMS;
      this.deltaTime = this.deltaMS * settings.TARGET_FPMS;
      var head = this._head;
      var listener = head.next;
      while (listener) {
        listener = listener.emit(this.deltaTime);
      }
      if (!head.next) {
        this._cancelIfNeeded();
      }
    } else {
      this.deltaTime = this.deltaMS = this.elapsedMS = 0;
    }
    this.lastTime = currentTime;
  };
  Object.defineProperty(Ticker2.prototype, "FPS", {
    get: function() {
      return 1e3 / this.elapsedMS;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Ticker2.prototype, "minFPS", {
    get: function() {
      return 1e3 / this._maxElapsedMS;
    },
    set: function(fps) {
      var minFPS = Math.min(this.maxFPS, fps);
      var minFPMS = Math.min(Math.max(0, minFPS) / 1e3, settings.TARGET_FPMS);
      this._maxElapsedMS = 1 / minFPMS;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Ticker2.prototype, "maxFPS", {
    get: function() {
      if (this._minElapsedMS) {
        return Math.round(1e3 / this._minElapsedMS);
      }
      return 0;
    },
    set: function(fps) {
      if (fps === 0) {
        this._minElapsedMS = 0;
      } else {
        var maxFPS = Math.max(this.minFPS, fps);
        this._minElapsedMS = 1 / (maxFPS / 1e3);
      }
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Ticker2, "shared", {
    get: function() {
      if (!Ticker2._shared) {
        var shared = Ticker2._shared = new Ticker2();
        shared.autoStart = true;
        shared._protected = true;
      }
      return Ticker2._shared;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Ticker2, "system", {
    get: function() {
      if (!Ticker2._system) {
        var system = Ticker2._system = new Ticker2();
        system.autoStart = true;
        system._protected = true;
      }
      return Ticker2._system;
    },
    enumerable: false,
    configurable: true
  });
  return Ticker2;
}();
var TickerPlugin = function() {
  function TickerPlugin2() {
  }
  TickerPlugin2.init = function(options) {
    var _this = this;
    options = Object.assign({
      autoStart: true,
      sharedTicker: false
    }, options);
    Object.defineProperty(this, "ticker", {
      set: function(ticker) {
        if (this._ticker) {
          this._ticker.remove(this.render, this);
        }
        this._ticker = ticker;
        if (ticker) {
          ticker.add(this.render, this, UPDATE_PRIORITY.LOW);
        }
      },
      get: function() {
        return this._ticker;
      }
    });
    this.stop = function() {
      _this._ticker.stop();
    };
    this.start = function() {
      _this._ticker.start();
    };
    this._ticker = null;
    this.ticker = options.sharedTicker ? Ticker.shared : new Ticker();
    if (options.autoStart) {
      this.start();
    }
  };
  TickerPlugin2.destroy = function() {
    if (this._ticker) {
      var oldTicker = this._ticker;
      this.ticker = null;
      oldTicker.destroy();
    }
  };
  return TickerPlugin2;
}();
/*!
 * @pixi/math - v6.3.0
 * Compiled Wed, 23 Mar 2022 18:58:56 UTC
 *
 * @pixi/math is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
var PI_2 = Math.PI * 2;
var RAD_TO_DEG = 180 / Math.PI;
var DEG_TO_RAD = Math.PI / 180;
var SHAPES;
(function(SHAPES2) {
  SHAPES2[SHAPES2["POLY"] = 0] = "POLY";
  SHAPES2[SHAPES2["RECT"] = 1] = "RECT";
  SHAPES2[SHAPES2["CIRC"] = 2] = "CIRC";
  SHAPES2[SHAPES2["ELIP"] = 3] = "ELIP";
  SHAPES2[SHAPES2["RREC"] = 4] = "RREC";
})(SHAPES || (SHAPES = {}));
var Point = function() {
  function Point2(x2, y2) {
    if (x2 === void 0) {
      x2 = 0;
    }
    if (y2 === void 0) {
      y2 = 0;
    }
    this.x = 0;
    this.y = 0;
    this.x = x2;
    this.y = y2;
  }
  Point2.prototype.clone = function() {
    return new Point2(this.x, this.y);
  };
  Point2.prototype.copyFrom = function(p2) {
    this.set(p2.x, p2.y);
    return this;
  };
  Point2.prototype.copyTo = function(p2) {
    p2.set(this.x, this.y);
    return p2;
  };
  Point2.prototype.equals = function(p2) {
    return p2.x === this.x && p2.y === this.y;
  };
  Point2.prototype.set = function(x2, y2) {
    if (x2 === void 0) {
      x2 = 0;
    }
    if (y2 === void 0) {
      y2 = x2;
    }
    this.x = x2;
    this.y = y2;
    return this;
  };
  Point2.prototype.toString = function() {
    return "[@pixi/math:Point x=" + this.x + " y=" + this.y + "]";
  };
  return Point2;
}();
var tempPoints$1 = [new Point(), new Point(), new Point(), new Point()];
var Rectangle = function() {
  function Rectangle2(x2, y2, width, height) {
    if (x2 === void 0) {
      x2 = 0;
    }
    if (y2 === void 0) {
      y2 = 0;
    }
    if (width === void 0) {
      width = 0;
    }
    if (height === void 0) {
      height = 0;
    }
    this.x = Number(x2);
    this.y = Number(y2);
    this.width = Number(width);
    this.height = Number(height);
    this.type = SHAPES.RECT;
  }
  Object.defineProperty(Rectangle2.prototype, "left", {
    get: function() {
      return this.x;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Rectangle2.prototype, "right", {
    get: function() {
      return this.x + this.width;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Rectangle2.prototype, "top", {
    get: function() {
      return this.y;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Rectangle2.prototype, "bottom", {
    get: function() {
      return this.y + this.height;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Rectangle2, "EMPTY", {
    get: function() {
      return new Rectangle2(0, 0, 0, 0);
    },
    enumerable: false,
    configurable: true
  });
  Rectangle2.prototype.clone = function() {
    return new Rectangle2(this.x, this.y, this.width, this.height);
  };
  Rectangle2.prototype.copyFrom = function(rectangle) {
    this.x = rectangle.x;
    this.y = rectangle.y;
    this.width = rectangle.width;
    this.height = rectangle.height;
    return this;
  };
  Rectangle2.prototype.copyTo = function(rectangle) {
    rectangle.x = this.x;
    rectangle.y = this.y;
    rectangle.width = this.width;
    rectangle.height = this.height;
    return rectangle;
  };
  Rectangle2.prototype.contains = function(x2, y2) {
    if (this.width <= 0 || this.height <= 0) {
      return false;
    }
    if (x2 >= this.x && x2 < this.x + this.width) {
      if (y2 >= this.y && y2 < this.y + this.height) {
        return true;
      }
    }
    return false;
  };
  Rectangle2.prototype.intersects = function(other, transform) {
    if (!transform) {
      var x0_1 = this.x < other.x ? other.x : this.x;
      var x1_1 = this.right > other.right ? other.right : this.right;
      if (x1_1 <= x0_1) {
        return false;
      }
      var y0_1 = this.y < other.y ? other.y : this.y;
      var y1_1 = this.bottom > other.bottom ? other.bottom : this.bottom;
      return y1_1 > y0_1;
    }
    var x0 = this.left;
    var x1 = this.right;
    var y0 = this.top;
    var y1 = this.bottom;
    if (x1 <= x0 || y1 <= y0) {
      return false;
    }
    var lt = tempPoints$1[0].set(other.left, other.top);
    var lb = tempPoints$1[1].set(other.left, other.bottom);
    var rt = tempPoints$1[2].set(other.right, other.top);
    var rb = tempPoints$1[3].set(other.right, other.bottom);
    if (rt.x <= lt.x || lb.y <= lt.y) {
      return false;
    }
    var s2 = Math.sign(transform.a * transform.d - transform.b * transform.c);
    if (s2 === 0) {
      return false;
    }
    transform.apply(lt, lt);
    transform.apply(lb, lb);
    transform.apply(rt, rt);
    transform.apply(rb, rb);
    if (Math.max(lt.x, lb.x, rt.x, rb.x) <= x0 || Math.min(lt.x, lb.x, rt.x, rb.x) >= x1 || Math.max(lt.y, lb.y, rt.y, rb.y) <= y0 || Math.min(lt.y, lb.y, rt.y, rb.y) >= y1) {
      return false;
    }
    var nx = s2 * (lb.y - lt.y);
    var ny = s2 * (lt.x - lb.x);
    var n00 = nx * x0 + ny * y0;
    var n10 = nx * x1 + ny * y0;
    var n01 = nx * x0 + ny * y1;
    var n11 = nx * x1 + ny * y1;
    if (Math.max(n00, n10, n01, n11) <= nx * lt.x + ny * lt.y || Math.min(n00, n10, n01, n11) >= nx * rb.x + ny * rb.y) {
      return false;
    }
    var mx = s2 * (lt.y - rt.y);
    var my = s2 * (rt.x - lt.x);
    var m00 = mx * x0 + my * y0;
    var m10 = mx * x1 + my * y0;
    var m01 = mx * x0 + my * y1;
    var m11 = mx * x1 + my * y1;
    if (Math.max(m00, m10, m01, m11) <= mx * lt.x + my * lt.y || Math.min(m00, m10, m01, m11) >= mx * rb.x + my * rb.y) {
      return false;
    }
    return true;
  };
  Rectangle2.prototype.pad = function(paddingX, paddingY) {
    if (paddingX === void 0) {
      paddingX = 0;
    }
    if (paddingY === void 0) {
      paddingY = paddingX;
    }
    this.x -= paddingX;
    this.y -= paddingY;
    this.width += paddingX * 2;
    this.height += paddingY * 2;
    return this;
  };
  Rectangle2.prototype.fit = function(rectangle) {
    var x1 = Math.max(this.x, rectangle.x);
    var x2 = Math.min(this.x + this.width, rectangle.x + rectangle.width);
    var y1 = Math.max(this.y, rectangle.y);
    var y2 = Math.min(this.y + this.height, rectangle.y + rectangle.height);
    this.x = x1;
    this.width = Math.max(x2 - x1, 0);
    this.y = y1;
    this.height = Math.max(y2 - y1, 0);
    return this;
  };
  Rectangle2.prototype.ceil = function(resolution, eps) {
    if (resolution === void 0) {
      resolution = 1;
    }
    if (eps === void 0) {
      eps = 1e-3;
    }
    var x2 = Math.ceil((this.x + this.width - eps) * resolution) / resolution;
    var y2 = Math.ceil((this.y + this.height - eps) * resolution) / resolution;
    this.x = Math.floor((this.x + eps) * resolution) / resolution;
    this.y = Math.floor((this.y + eps) * resolution) / resolution;
    this.width = x2 - this.x;
    this.height = y2 - this.y;
    return this;
  };
  Rectangle2.prototype.enlarge = function(rectangle) {
    var x1 = Math.min(this.x, rectangle.x);
    var x2 = Math.max(this.x + this.width, rectangle.x + rectangle.width);
    var y1 = Math.min(this.y, rectangle.y);
    var y2 = Math.max(this.y + this.height, rectangle.y + rectangle.height);
    this.x = x1;
    this.width = x2 - x1;
    this.y = y1;
    this.height = y2 - y1;
    return this;
  };
  Rectangle2.prototype.toString = function() {
    return "[@pixi/math:Rectangle x=" + this.x + " y=" + this.y + " width=" + this.width + " height=" + this.height + "]";
  };
  return Rectangle2;
}();
var Circle = function() {
  function Circle2(x2, y2, radius) {
    if (x2 === void 0) {
      x2 = 0;
    }
    if (y2 === void 0) {
      y2 = 0;
    }
    if (radius === void 0) {
      radius = 0;
    }
    this.x = x2;
    this.y = y2;
    this.radius = radius;
    this.type = SHAPES.CIRC;
  }
  Circle2.prototype.clone = function() {
    return new Circle2(this.x, this.y, this.radius);
  };
  Circle2.prototype.contains = function(x2, y2) {
    if (this.radius <= 0) {
      return false;
    }
    var r2 = this.radius * this.radius;
    var dx = this.x - x2;
    var dy = this.y - y2;
    dx *= dx;
    dy *= dy;
    return dx + dy <= r2;
  };
  Circle2.prototype.getBounds = function() {
    return new Rectangle(this.x - this.radius, this.y - this.radius, this.radius * 2, this.radius * 2);
  };
  Circle2.prototype.toString = function() {
    return "[@pixi/math:Circle x=" + this.x + " y=" + this.y + " radius=" + this.radius + "]";
  };
  return Circle2;
}();
var Ellipse = function() {
  function Ellipse2(x2, y2, halfWidth, halfHeight) {
    if (x2 === void 0) {
      x2 = 0;
    }
    if (y2 === void 0) {
      y2 = 0;
    }
    if (halfWidth === void 0) {
      halfWidth = 0;
    }
    if (halfHeight === void 0) {
      halfHeight = 0;
    }
    this.x = x2;
    this.y = y2;
    this.width = halfWidth;
    this.height = halfHeight;
    this.type = SHAPES.ELIP;
  }
  Ellipse2.prototype.clone = function() {
    return new Ellipse2(this.x, this.y, this.width, this.height);
  };
  Ellipse2.prototype.contains = function(x2, y2) {
    if (this.width <= 0 || this.height <= 0) {
      return false;
    }
    var normx = (x2 - this.x) / this.width;
    var normy = (y2 - this.y) / this.height;
    normx *= normx;
    normy *= normy;
    return normx + normy <= 1;
  };
  Ellipse2.prototype.getBounds = function() {
    return new Rectangle(this.x - this.width, this.y - this.height, this.width, this.height);
  };
  Ellipse2.prototype.toString = function() {
    return "[@pixi/math:Ellipse x=" + this.x + " y=" + this.y + " width=" + this.width + " height=" + this.height + "]";
  };
  return Ellipse2;
}();
var Polygon = function() {
  function Polygon2() {
    var arguments$1 = arguments;
    var points = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      points[_i] = arguments$1[_i];
    }
    var flat2 = Array.isArray(points[0]) ? points[0] : points;
    if (typeof flat2[0] !== "number") {
      var p2 = [];
      for (var i2 = 0, il = flat2.length; i2 < il; i2++) {
        p2.push(flat2[i2].x, flat2[i2].y);
      }
      flat2 = p2;
    }
    this.points = flat2;
    this.type = SHAPES.POLY;
    this.closeStroke = true;
  }
  Polygon2.prototype.clone = function() {
    var points = this.points.slice();
    var polygon = new Polygon2(points);
    polygon.closeStroke = this.closeStroke;
    return polygon;
  };
  Polygon2.prototype.contains = function(x2, y2) {
    var inside = false;
    var length2 = this.points.length / 2;
    for (var i2 = 0, j2 = length2 - 1; i2 < length2; j2 = i2++) {
      var xi = this.points[i2 * 2];
      var yi = this.points[i2 * 2 + 1];
      var xj = this.points[j2 * 2];
      var yj = this.points[j2 * 2 + 1];
      var intersect = yi > y2 !== yj > y2 && x2 < (xj - xi) * ((y2 - yi) / (yj - yi)) + xi;
      if (intersect) {
        inside = !inside;
      }
    }
    return inside;
  };
  Polygon2.prototype.toString = function() {
    return "[@pixi/math:Polygon" + ("closeStroke=" + this.closeStroke) + ("points=" + this.points.reduce(function(pointsDesc, currentPoint) {
      return pointsDesc + ", " + currentPoint;
    }, "") + "]");
  };
  return Polygon2;
}();
var RoundedRectangle = function() {
  function RoundedRectangle2(x2, y2, width, height, radius) {
    if (x2 === void 0) {
      x2 = 0;
    }
    if (y2 === void 0) {
      y2 = 0;
    }
    if (width === void 0) {
      width = 0;
    }
    if (height === void 0) {
      height = 0;
    }
    if (radius === void 0) {
      radius = 20;
    }
    this.x = x2;
    this.y = y2;
    this.width = width;
    this.height = height;
    this.radius = radius;
    this.type = SHAPES.RREC;
  }
  RoundedRectangle2.prototype.clone = function() {
    return new RoundedRectangle2(this.x, this.y, this.width, this.height, this.radius);
  };
  RoundedRectangle2.prototype.contains = function(x2, y2) {
    if (this.width <= 0 || this.height <= 0) {
      return false;
    }
    if (x2 >= this.x && x2 <= this.x + this.width) {
      if (y2 >= this.y && y2 <= this.y + this.height) {
        var radius = Math.max(0, Math.min(this.radius, Math.min(this.width, this.height) / 2));
        if (y2 >= this.y + radius && y2 <= this.y + this.height - radius || x2 >= this.x + radius && x2 <= this.x + this.width - radius) {
          return true;
        }
        var dx = x2 - (this.x + radius);
        var dy = y2 - (this.y + radius);
        var radius2 = radius * radius;
        if (dx * dx + dy * dy <= radius2) {
          return true;
        }
        dx = x2 - (this.x + this.width - radius);
        if (dx * dx + dy * dy <= radius2) {
          return true;
        }
        dy = y2 - (this.y + this.height - radius);
        if (dx * dx + dy * dy <= radius2) {
          return true;
        }
        dx = x2 - (this.x + radius);
        if (dx * dx + dy * dy <= radius2) {
          return true;
        }
      }
    }
    return false;
  };
  RoundedRectangle2.prototype.toString = function() {
    return "[@pixi/math:RoundedRectangle x=" + this.x + " y=" + this.y + ("width=" + this.width + " height=" + this.height + " radius=" + this.radius + "]");
  };
  return RoundedRectangle2;
}();
var ObservablePoint = function() {
  function ObservablePoint2(cb, scope, x2, y2) {
    if (x2 === void 0) {
      x2 = 0;
    }
    if (y2 === void 0) {
      y2 = 0;
    }
    this._x = x2;
    this._y = y2;
    this.cb = cb;
    this.scope = scope;
  }
  ObservablePoint2.prototype.clone = function(cb, scope) {
    if (cb === void 0) {
      cb = this.cb;
    }
    if (scope === void 0) {
      scope = this.scope;
    }
    return new ObservablePoint2(cb, scope, this._x, this._y);
  };
  ObservablePoint2.prototype.set = function(x2, y2) {
    if (x2 === void 0) {
      x2 = 0;
    }
    if (y2 === void 0) {
      y2 = x2;
    }
    if (this._x !== x2 || this._y !== y2) {
      this._x = x2;
      this._y = y2;
      this.cb.call(this.scope);
    }
    return this;
  };
  ObservablePoint2.prototype.copyFrom = function(p2) {
    if (this._x !== p2.x || this._y !== p2.y) {
      this._x = p2.x;
      this._y = p2.y;
      this.cb.call(this.scope);
    }
    return this;
  };
  ObservablePoint2.prototype.copyTo = function(p2) {
    p2.set(this._x, this._y);
    return p2;
  };
  ObservablePoint2.prototype.equals = function(p2) {
    return p2.x === this._x && p2.y === this._y;
  };
  ObservablePoint2.prototype.toString = function() {
    return "[@pixi/math:ObservablePoint x=" + 0 + " y=" + 0 + " scope=" + this.scope + "]";
  };
  Object.defineProperty(ObservablePoint2.prototype, "x", {
    get: function() {
      return this._x;
    },
    set: function(value) {
      if (this._x !== value) {
        this._x = value;
        this.cb.call(this.scope);
      }
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(ObservablePoint2.prototype, "y", {
    get: function() {
      return this._y;
    },
    set: function(value) {
      if (this._y !== value) {
        this._y = value;
        this.cb.call(this.scope);
      }
    },
    enumerable: false,
    configurable: true
  });
  return ObservablePoint2;
}();
var Matrix = function() {
  function Matrix2(a2, b2, c2, d2, tx, ty) {
    if (a2 === void 0) {
      a2 = 1;
    }
    if (b2 === void 0) {
      b2 = 0;
    }
    if (c2 === void 0) {
      c2 = 0;
    }
    if (d2 === void 0) {
      d2 = 1;
    }
    if (tx === void 0) {
      tx = 0;
    }
    if (ty === void 0) {
      ty = 0;
    }
    this.array = null;
    this.a = a2;
    this.b = b2;
    this.c = c2;
    this.d = d2;
    this.tx = tx;
    this.ty = ty;
  }
  Matrix2.prototype.fromArray = function(array) {
    this.a = array[0];
    this.b = array[1];
    this.c = array[3];
    this.d = array[4];
    this.tx = array[2];
    this.ty = array[5];
  };
  Matrix2.prototype.set = function(a2, b2, c2, d2, tx, ty) {
    this.a = a2;
    this.b = b2;
    this.c = c2;
    this.d = d2;
    this.tx = tx;
    this.ty = ty;
    return this;
  };
  Matrix2.prototype.toArray = function(transpose2, out) {
    if (!this.array) {
      this.array = new Float32Array(9);
    }
    var array = out || this.array;
    if (transpose2) {
      array[0] = this.a;
      array[1] = this.b;
      array[2] = 0;
      array[3] = this.c;
      array[4] = this.d;
      array[5] = 0;
      array[6] = this.tx;
      array[7] = this.ty;
      array[8] = 1;
    } else {
      array[0] = this.a;
      array[1] = this.c;
      array[2] = this.tx;
      array[3] = this.b;
      array[4] = this.d;
      array[5] = this.ty;
      array[6] = 0;
      array[7] = 0;
      array[8] = 1;
    }
    return array;
  };
  Matrix2.prototype.apply = function(pos, newPos) {
    newPos = newPos || new Point();
    var x2 = pos.x;
    var y2 = pos.y;
    newPos.x = this.a * x2 + this.c * y2 + this.tx;
    newPos.y = this.b * x2 + this.d * y2 + this.ty;
    return newPos;
  };
  Matrix2.prototype.applyInverse = function(pos, newPos) {
    newPos = newPos || new Point();
    var id = 1 / (this.a * this.d + this.c * -this.b);
    var x2 = pos.x;
    var y2 = pos.y;
    newPos.x = this.d * id * x2 + -this.c * id * y2 + (this.ty * this.c - this.tx * this.d) * id;
    newPos.y = this.a * id * y2 + -this.b * id * x2 + (-this.ty * this.a + this.tx * this.b) * id;
    return newPos;
  };
  Matrix2.prototype.translate = function(x2, y2) {
    this.tx += x2;
    this.ty += y2;
    return this;
  };
  Matrix2.prototype.scale = function(x2, y2) {
    this.a *= x2;
    this.d *= y2;
    this.c *= x2;
    this.b *= y2;
    this.tx *= x2;
    this.ty *= y2;
    return this;
  };
  Matrix2.prototype.rotate = function(angle) {
    var cos = Math.cos(angle);
    var sin = Math.sin(angle);
    var a1 = this.a;
    var c1 = this.c;
    var tx1 = this.tx;
    this.a = a1 * cos - this.b * sin;
    this.b = a1 * sin + this.b * cos;
    this.c = c1 * cos - this.d * sin;
    this.d = c1 * sin + this.d * cos;
    this.tx = tx1 * cos - this.ty * sin;
    this.ty = tx1 * sin + this.ty * cos;
    return this;
  };
  Matrix2.prototype.append = function(matrix) {
    var a1 = this.a;
    var b1 = this.b;
    var c1 = this.c;
    var d1 = this.d;
    this.a = matrix.a * a1 + matrix.b * c1;
    this.b = matrix.a * b1 + matrix.b * d1;
    this.c = matrix.c * a1 + matrix.d * c1;
    this.d = matrix.c * b1 + matrix.d * d1;
    this.tx = matrix.tx * a1 + matrix.ty * c1 + this.tx;
    this.ty = matrix.tx * b1 + matrix.ty * d1 + this.ty;
    return this;
  };
  Matrix2.prototype.setTransform = function(x2, y2, pivotX, pivotY, scaleX, scaleY, rotation, skewX, skewY) {
    this.a = Math.cos(rotation + skewY) * scaleX;
    this.b = Math.sin(rotation + skewY) * scaleX;
    this.c = -Math.sin(rotation - skewX) * scaleY;
    this.d = Math.cos(rotation - skewX) * scaleY;
    this.tx = x2 - (pivotX * this.a + pivotY * this.c);
    this.ty = y2 - (pivotX * this.b + pivotY * this.d);
    return this;
  };
  Matrix2.prototype.prepend = function(matrix) {
    var tx1 = this.tx;
    if (matrix.a !== 1 || matrix.b !== 0 || matrix.c !== 0 || matrix.d !== 1) {
      var a1 = this.a;
      var c1 = this.c;
      this.a = a1 * matrix.a + this.b * matrix.c;
      this.b = a1 * matrix.b + this.b * matrix.d;
      this.c = c1 * matrix.a + this.d * matrix.c;
      this.d = c1 * matrix.b + this.d * matrix.d;
    }
    this.tx = tx1 * matrix.a + this.ty * matrix.c + matrix.tx;
    this.ty = tx1 * matrix.b + this.ty * matrix.d + matrix.ty;
    return this;
  };
  Matrix2.prototype.decompose = function(transform) {
    var a2 = this.a;
    var b2 = this.b;
    var c2 = this.c;
    var d2 = this.d;
    var pivot = transform.pivot;
    var skewX = -Math.atan2(-c2, d2);
    var skewY = Math.atan2(b2, a2);
    var delta = Math.abs(skewX + skewY);
    if (delta < 1e-5 || Math.abs(PI_2 - delta) < 1e-5) {
      transform.rotation = skewY;
      transform.skew.x = transform.skew.y = 0;
    } else {
      transform.rotation = 0;
      transform.skew.x = skewX;
      transform.skew.y = skewY;
    }
    transform.scale.x = Math.sqrt(a2 * a2 + b2 * b2);
    transform.scale.y = Math.sqrt(c2 * c2 + d2 * d2);
    transform.position.x = this.tx + (pivot.x * a2 + pivot.y * c2);
    transform.position.y = this.ty + (pivot.x * b2 + pivot.y * d2);
    return transform;
  };
  Matrix2.prototype.invert = function() {
    var a1 = this.a;
    var b1 = this.b;
    var c1 = this.c;
    var d1 = this.d;
    var tx1 = this.tx;
    var n = a1 * d1 - b1 * c1;
    this.a = d1 / n;
    this.b = -b1 / n;
    this.c = -c1 / n;
    this.d = a1 / n;
    this.tx = (c1 * this.ty - d1 * tx1) / n;
    this.ty = -(a1 * this.ty - b1 * tx1) / n;
    return this;
  };
  Matrix2.prototype.identity = function() {
    this.a = 1;
    this.b = 0;
    this.c = 0;
    this.d = 1;
    this.tx = 0;
    this.ty = 0;
    return this;
  };
  Matrix2.prototype.clone = function() {
    var matrix = new Matrix2();
    matrix.a = this.a;
    matrix.b = this.b;
    matrix.c = this.c;
    matrix.d = this.d;
    matrix.tx = this.tx;
    matrix.ty = this.ty;
    return matrix;
  };
  Matrix2.prototype.copyTo = function(matrix) {
    matrix.a = this.a;
    matrix.b = this.b;
    matrix.c = this.c;
    matrix.d = this.d;
    matrix.tx = this.tx;
    matrix.ty = this.ty;
    return matrix;
  };
  Matrix2.prototype.copyFrom = function(matrix) {
    this.a = matrix.a;
    this.b = matrix.b;
    this.c = matrix.c;
    this.d = matrix.d;
    this.tx = matrix.tx;
    this.ty = matrix.ty;
    return this;
  };
  Matrix2.prototype.toString = function() {
    return "[@pixi/math:Matrix a=" + this.a + " b=" + this.b + " c=" + this.c + " d=" + this.d + " tx=" + this.tx + " ty=" + this.ty + "]";
  };
  Object.defineProperty(Matrix2, "IDENTITY", {
    get: function() {
      return new Matrix2();
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Matrix2, "TEMP_MATRIX", {
    get: function() {
      return new Matrix2();
    },
    enumerable: false,
    configurable: true
  });
  return Matrix2;
}();
var ux = [1, 1, 0, -1, -1, -1, 0, 1, 1, 1, 0, -1, -1, -1, 0, 1];
var uy = [0, 1, 1, 1, 0, -1, -1, -1, 0, 1, 1, 1, 0, -1, -1, -1];
var vx = [0, -1, -1, -1, 0, 1, 1, 1, 0, 1, 1, 1, 0, -1, -1, -1];
var vy = [1, 1, 0, -1, -1, -1, 0, 1, -1, -1, 0, 1, 1, 1, 0, -1];
var rotationCayley = [];
var rotationMatrices = [];
var signum = Math.sign;
function init() {
  for (var i2 = 0; i2 < 16; i2++) {
    var row = [];
    rotationCayley.push(row);
    for (var j2 = 0; j2 < 16; j2++) {
      var _ux = signum(ux[i2] * ux[j2] + vx[i2] * uy[j2]);
      var _uy = signum(uy[i2] * ux[j2] + vy[i2] * uy[j2]);
      var _vx = signum(ux[i2] * vx[j2] + vx[i2] * vy[j2]);
      var _vy = signum(uy[i2] * vx[j2] + vy[i2] * vy[j2]);
      for (var k = 0; k < 16; k++) {
        if (ux[k] === _ux && uy[k] === _uy && vx[k] === _vx && vy[k] === _vy) {
          row.push(k);
          break;
        }
      }
    }
  }
  for (var i2 = 0; i2 < 16; i2++) {
    var mat = new Matrix();
    mat.set(ux[i2], uy[i2], vx[i2], vy[i2], 0, 0);
    rotationMatrices.push(mat);
  }
}
init();
var groupD8 = {
  E: 0,
  SE: 1,
  S: 2,
  SW: 3,
  W: 4,
  NW: 5,
  N: 6,
  NE: 7,
  MIRROR_VERTICAL: 8,
  MAIN_DIAGONAL: 10,
  MIRROR_HORIZONTAL: 12,
  REVERSE_DIAGONAL: 14,
  uX: function(ind) {
    return ux[ind];
  },
  uY: function(ind) {
    return uy[ind];
  },
  vX: function(ind) {
    return vx[ind];
  },
  vY: function(ind) {
    return vy[ind];
  },
  inv: function(rotation) {
    if (rotation & 8) {
      return rotation & 15;
    }
    return -rotation & 7;
  },
  add: function(rotationSecond, rotationFirst) {
    return rotationCayley[rotationSecond][rotationFirst];
  },
  sub: function(rotationSecond, rotationFirst) {
    return rotationCayley[rotationSecond][groupD8.inv(rotationFirst)];
  },
  rotate180: function(rotation) {
    return rotation ^ 4;
  },
  isVertical: function(rotation) {
    return (rotation & 3) === 2;
  },
  byDirection: function(dx, dy) {
    if (Math.abs(dx) * 2 <= Math.abs(dy)) {
      if (dy >= 0) {
        return groupD8.S;
      }
      return groupD8.N;
    } else if (Math.abs(dy) * 2 <= Math.abs(dx)) {
      if (dx > 0) {
        return groupD8.E;
      }
      return groupD8.W;
    } else if (dy > 0) {
      if (dx > 0) {
        return groupD8.SE;
      }
      return groupD8.SW;
    } else if (dx > 0) {
      return groupD8.NE;
    }
    return groupD8.NW;
  },
  matrixAppendRotationInv: function(matrix, rotation, tx, ty) {
    if (tx === void 0) {
      tx = 0;
    }
    if (ty === void 0) {
      ty = 0;
    }
    var mat = rotationMatrices[groupD8.inv(rotation)];
    mat.tx = tx;
    mat.ty = ty;
    matrix.append(mat);
  }
};
var Transform = function() {
  function Transform2() {
    this.worldTransform = new Matrix();
    this.localTransform = new Matrix();
    this.position = new ObservablePoint(this.onChange, this, 0, 0);
    this.scale = new ObservablePoint(this.onChange, this, 1, 1);
    this.pivot = new ObservablePoint(this.onChange, this, 0, 0);
    this.skew = new ObservablePoint(this.updateSkew, this, 0, 0);
    this._rotation = 0;
    this._cx = 1;
    this._sx = 0;
    this._cy = 0;
    this._sy = 1;
    this._localID = 0;
    this._currentLocalID = 0;
    this._worldID = 0;
    this._parentID = 0;
  }
  Transform2.prototype.onChange = function() {
    this._localID++;
  };
  Transform2.prototype.updateSkew = function() {
    this._cx = Math.cos(this._rotation + this.skew.y);
    this._sx = Math.sin(this._rotation + this.skew.y);
    this._cy = -Math.sin(this._rotation - this.skew.x);
    this._sy = Math.cos(this._rotation - this.skew.x);
    this._localID++;
  };
  Transform2.prototype.toString = function() {
    return "[@pixi/math:Transform " + ("position=(" + this.position.x + ", " + this.position.y + ") ") + ("rotation=" + this.rotation + " ") + ("scale=(" + this.scale.x + ", " + this.scale.y + ") ") + ("skew=(" + this.skew.x + ", " + this.skew.y + ") ") + "]";
  };
  Transform2.prototype.updateLocalTransform = function() {
    var lt = this.localTransform;
    if (this._localID !== this._currentLocalID) {
      lt.a = this._cx * this.scale.x;
      lt.b = this._sx * this.scale.x;
      lt.c = this._cy * this.scale.y;
      lt.d = this._sy * this.scale.y;
      lt.tx = this.position.x - (this.pivot.x * lt.a + this.pivot.y * lt.c);
      lt.ty = this.position.y - (this.pivot.x * lt.b + this.pivot.y * lt.d);
      this._currentLocalID = this._localID;
      this._parentID = -1;
    }
  };
  Transform2.prototype.updateTransform = function(parentTransform) {
    var lt = this.localTransform;
    if (this._localID !== this._currentLocalID) {
      lt.a = this._cx * this.scale.x;
      lt.b = this._sx * this.scale.x;
      lt.c = this._cy * this.scale.y;
      lt.d = this._sy * this.scale.y;
      lt.tx = this.position.x - (this.pivot.x * lt.a + this.pivot.y * lt.c);
      lt.ty = this.position.y - (this.pivot.x * lt.b + this.pivot.y * lt.d);
      this._currentLocalID = this._localID;
      this._parentID = -1;
    }
    if (this._parentID !== parentTransform._worldID) {
      var pt = parentTransform.worldTransform;
      var wt = this.worldTransform;
      wt.a = lt.a * pt.a + lt.b * pt.c;
      wt.b = lt.a * pt.b + lt.b * pt.d;
      wt.c = lt.c * pt.a + lt.d * pt.c;
      wt.d = lt.c * pt.b + lt.d * pt.d;
      wt.tx = lt.tx * pt.a + lt.ty * pt.c + pt.tx;
      wt.ty = lt.tx * pt.b + lt.ty * pt.d + pt.ty;
      this._parentID = parentTransform._worldID;
      this._worldID++;
    }
  };
  Transform2.prototype.setFromMatrix = function(matrix) {
    matrix.decompose(this);
    this._localID++;
  };
  Object.defineProperty(Transform2.prototype, "rotation", {
    get: function() {
      return this._rotation;
    },
    set: function(value) {
      if (this._rotation !== value) {
        this._rotation = value;
        this.updateSkew();
      }
    },
    enumerable: false,
    configurable: true
  });
  Transform2.IDENTITY = new Transform2();
  return Transform2;
}();
/*!
 * @pixi/core - v6.3.0
 * Compiled Wed, 23 Mar 2022 18:58:56 UTC
 *
 * @pixi/core is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
settings.PREFER_ENV = isMobile.any ? ENV$3.WEBGL : ENV$3.WEBGL2;
settings.STRICT_TEXTURE_CACHE = false;
var INSTALLED = [];
function autoDetectResource(source, options) {
  if (!source) {
    return null;
  }
  var extension = "";
  if (typeof source === "string") {
    var result = /\.(\w{3,4})(?:$|\?|#)/i.exec(source);
    if (result) {
      extension = result[1].toLowerCase();
    }
  }
  for (var i2 = INSTALLED.length - 1; i2 >= 0; --i2) {
    var ResourcePlugin = INSTALLED[i2];
    if (ResourcePlugin.test && ResourcePlugin.test(source, extension)) {
      return new ResourcePlugin(source, options);
    }
  }
  throw new Error("Unrecognized source type to auto-detect Resource");
}
/*! *****************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */
var extendStatics$q = function(d2, b2) {
  extendStatics$q = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {
    d3.__proto__ = b3;
  } || function(d3, b3) {
    for (var p2 in b3) {
      if (b3.hasOwnProperty(p2)) {
        d3[p2] = b3[p2];
      }
    }
  };
  return extendStatics$q(d2, b2);
};
function __extends$q(d2, b2) {
  extendStatics$q(d2, b2);
  function __() {
    this.constructor = d2;
  }
  d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
}
var __assign$8 = function() {
  __assign$8 = Object.assign || function __assign2(t) {
    var arguments$1 = arguments;
    for (var s2, i2 = 1, n = arguments.length; i2 < n; i2++) {
      s2 = arguments$1[i2];
      for (var p2 in s2) {
        if (Object.prototype.hasOwnProperty.call(s2, p2)) {
          t[p2] = s2[p2];
        }
      }
    }
    return t;
  };
  return __assign$8.apply(this, arguments);
};
function __rest$3(s2, e) {
  var t = {};
  for (var p2 in s2) {
    if (Object.prototype.hasOwnProperty.call(s2, p2) && e.indexOf(p2) < 0) {
      t[p2] = s2[p2];
    }
  }
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function") {
    for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s2); i2 < p2.length; i2++) {
      if (e.indexOf(p2[i2]) < 0) {
        t[p2[i2]] = s2[p2[i2]];
      }
    }
  }
  return t;
}
var Resource = function() {
  function Resource2(width, height) {
    if (width === void 0) {
      width = 0;
    }
    if (height === void 0) {
      height = 0;
    }
    this._width = width;
    this._height = height;
    this.destroyed = false;
    this.internal = false;
    this.onResize = new Runner("setRealSize");
    this.onUpdate = new Runner("update");
    this.onError = new Runner("onError");
  }
  Resource2.prototype.bind = function(baseTexture) {
    this.onResize.add(baseTexture);
    this.onUpdate.add(baseTexture);
    this.onError.add(baseTexture);
    if (this._width || this._height) {
      this.onResize.emit(this._width, this._height);
    }
  };
  Resource2.prototype.unbind = function(baseTexture) {
    this.onResize.remove(baseTexture);
    this.onUpdate.remove(baseTexture);
    this.onError.remove(baseTexture);
  };
  Resource2.prototype.resize = function(width, height) {
    if (width !== this._width || height !== this._height) {
      this._width = width;
      this._height = height;
      this.onResize.emit(width, height);
    }
  };
  Object.defineProperty(Resource2.prototype, "valid", {
    get: function() {
      return !!this._width && !!this._height;
    },
    enumerable: false,
    configurable: true
  });
  Resource2.prototype.update = function() {
    if (!this.destroyed) {
      this.onUpdate.emit();
    }
  };
  Resource2.prototype.load = function() {
    return Promise.resolve(this);
  };
  Object.defineProperty(Resource2.prototype, "width", {
    get: function() {
      return this._width;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Resource2.prototype, "height", {
    get: function() {
      return this._height;
    },
    enumerable: false,
    configurable: true
  });
  Resource2.prototype.style = function(_renderer, _baseTexture, _glTexture) {
    return false;
  };
  Resource2.prototype.dispose = function() {
  };
  Resource2.prototype.destroy = function() {
    if (!this.destroyed) {
      this.destroyed = true;
      this.dispose();
      this.onError.removeAll();
      this.onError = null;
      this.onResize.removeAll();
      this.onResize = null;
      this.onUpdate.removeAll();
      this.onUpdate = null;
    }
  };
  Resource2.test = function(_source, _extension) {
    return false;
  };
  return Resource2;
}();
var BufferResource = function(_super) {
  __extends$q(BufferResource2, _super);
  function BufferResource2(source, options) {
    var _this = this;
    var _a3 = options || {}, width = _a3.width, height = _a3.height;
    if (!width || !height) {
      throw new Error("BufferResource width or height invalid");
    }
    _this = _super.call(this, width, height) || this;
    _this.data = source;
    return _this;
  }
  BufferResource2.prototype.upload = function(renderer, baseTexture, glTexture) {
    var gl = renderer.gl;
    gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, baseTexture.alphaMode === ALPHA_MODES$3.UNPACK);
    var width = baseTexture.realWidth;
    var height = baseTexture.realHeight;
    if (glTexture.width === width && glTexture.height === height) {
      gl.texSubImage2D(baseTexture.target, 0, 0, 0, width, height, baseTexture.format, glTexture.type, this.data);
    } else {
      glTexture.width = width;
      glTexture.height = height;
      gl.texImage2D(baseTexture.target, 0, glTexture.internalFormat, width, height, 0, baseTexture.format, glTexture.type, this.data);
    }
    return true;
  };
  BufferResource2.prototype.dispose = function() {
    this.data = null;
  };
  BufferResource2.test = function(source) {
    return source instanceof Float32Array || source instanceof Uint8Array || source instanceof Uint32Array;
  };
  return BufferResource2;
}(Resource);
var defaultBufferOptions = {
  scaleMode: SCALE_MODES$3.NEAREST,
  format: FORMATS$3.RGBA,
  alphaMode: ALPHA_MODES$3.NPM
};
var BaseTexture = function(_super) {
  __extends$q(BaseTexture2, _super);
  function BaseTexture2(resource, options) {
    if (resource === void 0) {
      resource = null;
    }
    if (options === void 0) {
      options = null;
    }
    var _this = _super.call(this) || this;
    options = options || {};
    var alphaMode = options.alphaMode, mipmap = options.mipmap, anisotropicLevel = options.anisotropicLevel, scaleMode = options.scaleMode, width = options.width, height = options.height, wrapMode = options.wrapMode, format2 = options.format, type = options.type, target = options.target, resolution = options.resolution, resourceOptions = options.resourceOptions;
    if (resource && !(resource instanceof Resource)) {
      resource = autoDetectResource(resource, resourceOptions);
      resource.internal = true;
    }
    _this.resolution = resolution || settings.RESOLUTION;
    _this.width = Math.round((width || 0) * _this.resolution) / _this.resolution;
    _this.height = Math.round((height || 0) * _this.resolution) / _this.resolution;
    _this._mipmap = mipmap !== void 0 ? mipmap : settings.MIPMAP_TEXTURES;
    _this.anisotropicLevel = anisotropicLevel !== void 0 ? anisotropicLevel : settings.ANISOTROPIC_LEVEL;
    _this._wrapMode = wrapMode || settings.WRAP_MODE;
    _this._scaleMode = scaleMode !== void 0 ? scaleMode : settings.SCALE_MODE;
    _this.format = format2 || FORMATS$3.RGBA;
    _this.type = type || TYPES$3.UNSIGNED_BYTE;
    _this.target = target || TARGETS$3.TEXTURE_2D;
    _this.alphaMode = alphaMode !== void 0 ? alphaMode : ALPHA_MODES$3.UNPACK;
    _this.uid = uid();
    _this.touched = 0;
    _this.isPowerOfTwo = false;
    _this._refreshPOT();
    _this._glTextures = {};
    _this.dirtyId = 0;
    _this.dirtyStyleId = 0;
    _this.cacheId = null;
    _this.valid = width > 0 && height > 0;
    _this.textureCacheIds = [];
    _this.destroyed = false;
    _this.resource = null;
    _this._batchEnabled = 0;
    _this._batchLocation = 0;
    _this.parentTextureArray = null;
    _this.setResource(resource);
    return _this;
  }
  Object.defineProperty(BaseTexture2.prototype, "realWidth", {
    get: function() {
      return Math.round(this.width * this.resolution);
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(BaseTexture2.prototype, "realHeight", {
    get: function() {
      return Math.round(this.height * this.resolution);
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(BaseTexture2.prototype, "mipmap", {
    get: function() {
      return this._mipmap;
    },
    set: function(value) {
      if (this._mipmap !== value) {
        this._mipmap = value;
        this.dirtyStyleId++;
      }
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(BaseTexture2.prototype, "scaleMode", {
    get: function() {
      return this._scaleMode;
    },
    set: function(value) {
      if (this._scaleMode !== value) {
        this._scaleMode = value;
        this.dirtyStyleId++;
      }
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(BaseTexture2.prototype, "wrapMode", {
    get: function() {
      return this._wrapMode;
    },
    set: function(value) {
      if (this._wrapMode !== value) {
        this._wrapMode = value;
        this.dirtyStyleId++;
      }
    },
    enumerable: false,
    configurable: true
  });
  BaseTexture2.prototype.setStyle = function(scaleMode, mipmap) {
    var dirty;
    if (scaleMode !== void 0 && scaleMode !== this.scaleMode) {
      this.scaleMode = scaleMode;
      dirty = true;
    }
    if (mipmap !== void 0 && mipmap !== this.mipmap) {
      this.mipmap = mipmap;
      dirty = true;
    }
    if (dirty) {
      this.dirtyStyleId++;
    }
    return this;
  };
  BaseTexture2.prototype.setSize = function(desiredWidth, desiredHeight, resolution) {
    resolution = resolution || this.resolution;
    return this.setRealSize(desiredWidth * resolution, desiredHeight * resolution, resolution);
  };
  BaseTexture2.prototype.setRealSize = function(realWidth, realHeight, resolution) {
    this.resolution = resolution || this.resolution;
    this.width = Math.round(realWidth) / this.resolution;
    this.height = Math.round(realHeight) / this.resolution;
    this._refreshPOT();
    this.update();
    return this;
  };
  BaseTexture2.prototype._refreshPOT = function() {
    this.isPowerOfTwo = isPow2(this.realWidth) && isPow2(this.realHeight);
  };
  BaseTexture2.prototype.setResolution = function(resolution) {
    var oldResolution = this.resolution;
    if (oldResolution === resolution) {
      return this;
    }
    this.resolution = resolution;
    if (this.valid) {
      this.width = Math.round(this.width * oldResolution) / resolution;
      this.height = Math.round(this.height * oldResolution) / resolution;
      this.emit("update", this);
    }
    this._refreshPOT();
    return this;
  };
  BaseTexture2.prototype.setResource = function(resource) {
    if (this.resource === resource) {
      return this;
    }
    if (this.resource) {
      throw new Error("Resource can be set only once");
    }
    resource.bind(this);
    this.resource = resource;
    return this;
  };
  BaseTexture2.prototype.update = function() {
    if (!this.valid) {
      if (this.width > 0 && this.height > 0) {
        this.valid = true;
        this.emit("loaded", this);
        this.emit("update", this);
      }
    } else {
      this.dirtyId++;
      this.dirtyStyleId++;
      this.emit("update", this);
    }
  };
  BaseTexture2.prototype.onError = function(event) {
    this.emit("error", this, event);
  };
  BaseTexture2.prototype.destroy = function() {
    if (this.resource) {
      this.resource.unbind(this);
      if (this.resource.internal) {
        this.resource.destroy();
      }
      this.resource = null;
    }
    if (this.cacheId) {
      delete BaseTextureCache[this.cacheId];
      delete TextureCache[this.cacheId];
      this.cacheId = null;
    }
    this.dispose();
    BaseTexture2.removeFromCache(this);
    this.textureCacheIds = null;
    this.destroyed = true;
  };
  BaseTexture2.prototype.dispose = function() {
    this.emit("dispose", this);
  };
  BaseTexture2.prototype.castToBaseTexture = function() {
    return this;
  };
  BaseTexture2.from = function(source, options, strict) {
    if (strict === void 0) {
      strict = settings.STRICT_TEXTURE_CACHE;
    }
    var isFrame = typeof source === "string";
    var cacheId = null;
    if (isFrame) {
      cacheId = source;
    } else {
      if (!source._pixiId) {
        var prefix2 = options && options.pixiIdPrefix || "pixiid";
        source._pixiId = prefix2 + "_" + uid();
      }
      cacheId = source._pixiId;
    }
    var baseTexture = BaseTextureCache[cacheId];
    if (isFrame && strict && !baseTexture) {
      throw new Error('The cacheId "' + cacheId + '" does not exist in BaseTextureCache.');
    }
    if (!baseTexture) {
      baseTexture = new BaseTexture2(source, options);
      baseTexture.cacheId = cacheId;
      BaseTexture2.addToCache(baseTexture, cacheId);
    }
    return baseTexture;
  };
  BaseTexture2.fromBuffer = function(buffer, width, height, options) {
    buffer = buffer || new Float32Array(width * height * 4);
    var resource = new BufferResource(buffer, { width, height });
    var type = buffer instanceof Float32Array ? TYPES$3.FLOAT : TYPES$3.UNSIGNED_BYTE;
    return new BaseTexture2(resource, Object.assign(defaultBufferOptions, options || { width, height, type }));
  };
  BaseTexture2.addToCache = function(baseTexture, id) {
    if (id) {
      if (baseTexture.textureCacheIds.indexOf(id) === -1) {
        baseTexture.textureCacheIds.push(id);
      }
      if (BaseTextureCache[id]) {
        console.warn("BaseTexture added to the cache with an id [" + id + "] that already had an entry");
      }
      BaseTextureCache[id] = baseTexture;
    }
  };
  BaseTexture2.removeFromCache = function(baseTexture) {
    if (typeof baseTexture === "string") {
      var baseTextureFromCache = BaseTextureCache[baseTexture];
      if (baseTextureFromCache) {
        var index = baseTextureFromCache.textureCacheIds.indexOf(baseTexture);
        if (index > -1) {
          baseTextureFromCache.textureCacheIds.splice(index, 1);
        }
        delete BaseTextureCache[baseTexture];
        return baseTextureFromCache;
      }
    } else if (baseTexture && baseTexture.textureCacheIds) {
      for (var i2 = 0; i2 < baseTexture.textureCacheIds.length; ++i2) {
        delete BaseTextureCache[baseTexture.textureCacheIds[i2]];
      }
      baseTexture.textureCacheIds.length = 0;
      return baseTexture;
    }
    return null;
  };
  BaseTexture2._globalBatch = 0;
  return BaseTexture2;
}(EventEmitter$3);
var AbstractMultiResource = function(_super) {
  __extends$q(AbstractMultiResource2, _super);
  function AbstractMultiResource2(length2, options) {
    var _this = this;
    var _a3 = options || {}, width = _a3.width, height = _a3.height;
    _this = _super.call(this, width, height) || this;
    _this.items = [];
    _this.itemDirtyIds = [];
    for (var i2 = 0; i2 < length2; i2++) {
      var partTexture = new BaseTexture();
      _this.items.push(partTexture);
      _this.itemDirtyIds.push(-2);
    }
    _this.length = length2;
    _this._load = null;
    _this.baseTexture = null;
    return _this;
  }
  AbstractMultiResource2.prototype.initFromArray = function(resources2, options) {
    for (var i2 = 0; i2 < this.length; i2++) {
      if (!resources2[i2]) {
        continue;
      }
      if (resources2[i2].castToBaseTexture) {
        this.addBaseTextureAt(resources2[i2].castToBaseTexture(), i2);
      } else if (resources2[i2] instanceof Resource) {
        this.addResourceAt(resources2[i2], i2);
      } else {
        this.addResourceAt(autoDetectResource(resources2[i2], options), i2);
      }
    }
  };
  AbstractMultiResource2.prototype.dispose = function() {
    for (var i2 = 0, len = this.length; i2 < len; i2++) {
      this.items[i2].destroy();
    }
    this.items = null;
    this.itemDirtyIds = null;
    this._load = null;
  };
  AbstractMultiResource2.prototype.addResourceAt = function(resource, index) {
    if (!this.items[index]) {
      throw new Error("Index " + index + " is out of bounds");
    }
    if (resource.valid && !this.valid) {
      this.resize(resource.width, resource.height);
    }
    this.items[index].setResource(resource);
    return this;
  };
  AbstractMultiResource2.prototype.bind = function(baseTexture) {
    if (this.baseTexture !== null) {
      throw new Error("Only one base texture per TextureArray is allowed");
    }
    _super.prototype.bind.call(this, baseTexture);
    for (var i2 = 0; i2 < this.length; i2++) {
      this.items[i2].parentTextureArray = baseTexture;
      this.items[i2].on("update", baseTexture.update, baseTexture);
    }
  };
  AbstractMultiResource2.prototype.unbind = function(baseTexture) {
    _super.prototype.unbind.call(this, baseTexture);
    for (var i2 = 0; i2 < this.length; i2++) {
      this.items[i2].parentTextureArray = null;
      this.items[i2].off("update", baseTexture.update, baseTexture);
    }
  };
  AbstractMultiResource2.prototype.load = function() {
    var _this = this;
    if (this._load) {
      return this._load;
    }
    var resources2 = this.items.map(function(item) {
      return item.resource;
    }).filter(function(item) {
      return item;
    });
    var promises = resources2.map(function(item) {
      return item.load();
    });
    this._load = Promise.all(promises).then(function() {
      var _a3 = _this.items[0], realWidth = _a3.realWidth, realHeight = _a3.realHeight;
      _this.resize(realWidth, realHeight);
      return Promise.resolve(_this);
    });
    return this._load;
  };
  return AbstractMultiResource2;
}(Resource);
var ArrayResource = function(_super) {
  __extends$q(ArrayResource2, _super);
  function ArrayResource2(source, options) {
    var _this = this;
    var _a3 = options || {}, width = _a3.width, height = _a3.height;
    var urls;
    var length2;
    if (Array.isArray(source)) {
      urls = source;
      length2 = source.length;
    } else {
      length2 = source;
    }
    _this = _super.call(this, length2, { width, height }) || this;
    if (urls) {
      _this.initFromArray(urls, options);
    }
    return _this;
  }
  ArrayResource2.prototype.addBaseTextureAt = function(baseTexture, index) {
    if (baseTexture.resource) {
      this.addResourceAt(baseTexture.resource, index);
    } else {
      throw new Error("ArrayResource does not support RenderTexture");
    }
    return this;
  };
  ArrayResource2.prototype.bind = function(baseTexture) {
    _super.prototype.bind.call(this, baseTexture);
    baseTexture.target = TARGETS$3.TEXTURE_2D_ARRAY;
  };
  ArrayResource2.prototype.upload = function(renderer, texture, glTexture) {
    var _a3 = this, length2 = _a3.length, itemDirtyIds = _a3.itemDirtyIds, items = _a3.items;
    var gl = renderer.gl;
    if (glTexture.dirtyId < 0) {
      gl.texImage3D(gl.TEXTURE_2D_ARRAY, 0, glTexture.internalFormat, this._width, this._height, length2, 0, texture.format, glTexture.type, null);
    }
    for (var i2 = 0; i2 < length2; i2++) {
      var item = items[i2];
      if (itemDirtyIds[i2] < item.dirtyId) {
        itemDirtyIds[i2] = item.dirtyId;
        if (item.valid) {
          gl.texSubImage3D(gl.TEXTURE_2D_ARRAY, 0, 0, 0, i2, item.resource.width, item.resource.height, 1, texture.format, glTexture.type, item.resource.source);
        }
      }
    }
    return true;
  };
  return ArrayResource2;
}(AbstractMultiResource);
var BaseImageResource = function(_super) {
  __extends$q(BaseImageResource2, _super);
  function BaseImageResource2(source) {
    var _this = this;
    var sourceAny = source;
    var width = sourceAny.naturalWidth || sourceAny.videoWidth || sourceAny.width;
    var height = sourceAny.naturalHeight || sourceAny.videoHeight || sourceAny.height;
    _this = _super.call(this, width, height) || this;
    _this.source = source;
    _this.noSubImage = false;
    return _this;
  }
  BaseImageResource2.crossOrigin = function(element, url2, crossorigin) {
    if (crossorigin === void 0 && url2.indexOf("data:") !== 0) {
      element.crossOrigin = determineCrossOrigin(url2);
    } else if (crossorigin !== false) {
      element.crossOrigin = typeof crossorigin === "string" ? crossorigin : "anonymous";
    }
  };
  BaseImageResource2.prototype.upload = function(renderer, baseTexture, glTexture, source) {
    var gl = renderer.gl;
    var width = baseTexture.realWidth;
    var height = baseTexture.realHeight;
    source = source || this.source;
    if (source instanceof HTMLImageElement) {
      if (!source.complete || source.naturalWidth === 0) {
        return false;
      }
    } else if (source instanceof HTMLVideoElement) {
      if (source.readyState <= 1) {
        return false;
      }
    }
    gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, baseTexture.alphaMode === ALPHA_MODES$3.UNPACK);
    if (!this.noSubImage && baseTexture.target === gl.TEXTURE_2D && glTexture.width === width && glTexture.height === height) {
      gl.texSubImage2D(gl.TEXTURE_2D, 0, 0, 0, baseTexture.format, glTexture.type, source);
    } else {
      glTexture.width = width;
      glTexture.height = height;
      gl.texImage2D(baseTexture.target, 0, glTexture.internalFormat, baseTexture.format, glTexture.type, source);
    }
    return true;
  };
  BaseImageResource2.prototype.update = function() {
    if (this.destroyed) {
      return;
    }
    var source = this.source;
    var width = source.naturalWidth || source.videoWidth || source.width;
    var height = source.naturalHeight || source.videoHeight || source.height;
    this.resize(width, height);
    _super.prototype.update.call(this);
  };
  BaseImageResource2.prototype.dispose = function() {
    this.source = null;
  };
  return BaseImageResource2;
}(Resource);
var CanvasResource = function(_super) {
  __extends$q(CanvasResource2, _super);
  function CanvasResource2(source) {
    return _super.call(this, source) || this;
  }
  CanvasResource2.test = function(source) {
    var OffscreenCanvas2 = globalThis.OffscreenCanvas;
    if (OffscreenCanvas2 && source instanceof OffscreenCanvas2) {
      return true;
    }
    return globalThis.HTMLCanvasElement && source instanceof HTMLCanvasElement;
  };
  return CanvasResource2;
}(BaseImageResource);
var CubeResource = function(_super) {
  __extends$q(CubeResource2, _super);
  function CubeResource2(source, options) {
    var _this = this;
    var _a3 = options || {}, width = _a3.width, height = _a3.height, autoLoad = _a3.autoLoad, linkBaseTexture = _a3.linkBaseTexture;
    if (source && source.length !== CubeResource2.SIDES) {
      throw new Error("Invalid length. Got " + source.length + ", expected 6");
    }
    _this = _super.call(this, 6, { width, height }) || this;
    for (var i2 = 0; i2 < CubeResource2.SIDES; i2++) {
      _this.items[i2].target = TARGETS$3.TEXTURE_CUBE_MAP_POSITIVE_X + i2;
    }
    _this.linkBaseTexture = linkBaseTexture !== false;
    if (source) {
      _this.initFromArray(source, options);
    }
    if (autoLoad !== false) {
      _this.load();
    }
    return _this;
  }
  CubeResource2.prototype.bind = function(baseTexture) {
    _super.prototype.bind.call(this, baseTexture);
    baseTexture.target = TARGETS$3.TEXTURE_CUBE_MAP;
  };
  CubeResource2.prototype.addBaseTextureAt = function(baseTexture, index, linkBaseTexture) {
    if (!this.items[index]) {
      throw new Error("Index " + index + " is out of bounds");
    }
    if (!this.linkBaseTexture || baseTexture.parentTextureArray || Object.keys(baseTexture._glTextures).length > 0) {
      if (baseTexture.resource) {
        this.addResourceAt(baseTexture.resource, index);
      } else {
        throw new Error("CubeResource does not support copying of renderTexture.");
      }
    } else {
      baseTexture.target = TARGETS$3.TEXTURE_CUBE_MAP_POSITIVE_X + index;
      baseTexture.parentTextureArray = this.baseTexture;
      this.items[index] = baseTexture;
    }
    if (baseTexture.valid && !this.valid) {
      this.resize(baseTexture.realWidth, baseTexture.realHeight);
    }
    this.items[index] = baseTexture;
    return this;
  };
  CubeResource2.prototype.upload = function(renderer, _baseTexture, glTexture) {
    var dirty = this.itemDirtyIds;
    for (var i2 = 0; i2 < CubeResource2.SIDES; i2++) {
      var side = this.items[i2];
      if (dirty[i2] < side.dirtyId) {
        if (side.valid && side.resource) {
          side.resource.upload(renderer, side, glTexture);
          dirty[i2] = side.dirtyId;
        } else if (dirty[i2] < -1) {
          renderer.gl.texImage2D(side.target, 0, glTexture.internalFormat, _baseTexture.realWidth, _baseTexture.realHeight, 0, _baseTexture.format, glTexture.type, null);
          dirty[i2] = -1;
        }
      }
    }
    return true;
  };
  CubeResource2.test = function(source) {
    return Array.isArray(source) && source.length === CubeResource2.SIDES;
  };
  CubeResource2.SIDES = 6;
  return CubeResource2;
}(AbstractMultiResource);
var ImageResource = function(_super) {
  __extends$q(ImageResource2, _super);
  function ImageResource2(source, options) {
    var _this = this;
    options = options || {};
    if (!(source instanceof HTMLImageElement)) {
      var imageElement = new Image();
      BaseImageResource.crossOrigin(imageElement, source, options.crossorigin);
      imageElement.src = source;
      source = imageElement;
    }
    _this = _super.call(this, source) || this;
    if (!source.complete && !!_this._width && !!_this._height) {
      _this._width = 0;
      _this._height = 0;
    }
    _this.url = source.src;
    _this._process = null;
    _this.preserveBitmap = false;
    _this.createBitmap = (options.createBitmap !== void 0 ? options.createBitmap : settings.CREATE_IMAGE_BITMAP) && !!globalThis.createImageBitmap;
    _this.alphaMode = typeof options.alphaMode === "number" ? options.alphaMode : null;
    _this.bitmap = null;
    _this._load = null;
    if (options.autoLoad !== false) {
      _this.load();
    }
    return _this;
  }
  ImageResource2.prototype.load = function(createBitmap) {
    var _this = this;
    if (this._load) {
      return this._load;
    }
    if (createBitmap !== void 0) {
      this.createBitmap = createBitmap;
    }
    this._load = new Promise(function(resolve2, reject2) {
      var source = _this.source;
      _this.url = source.src;
      var completed = function() {
        if (_this.destroyed) {
          return;
        }
        source.onload = null;
        source.onerror = null;
        _this.resize(source.width, source.height);
        _this._load = null;
        if (_this.createBitmap) {
          resolve2(_this.process());
        } else {
          resolve2(_this);
        }
      };
      if (source.complete && source.src) {
        completed();
      } else {
        source.onload = completed;
        source.onerror = function(event) {
          reject2(event);
          _this.onError.emit(event);
        };
      }
    });
    return this._load;
  };
  ImageResource2.prototype.process = function() {
    var _this = this;
    var source = this.source;
    if (this._process !== null) {
      return this._process;
    }
    if (this.bitmap !== null || !globalThis.createImageBitmap) {
      return Promise.resolve(this);
    }
    var createImageBitmap = globalThis.createImageBitmap;
    var cors = !source.crossOrigin || source.crossOrigin === "anonymous";
    this._process = fetch(source.src, {
      mode: cors ? "cors" : "no-cors"
    }).then(function(r2) {
      return r2.blob();
    }).then(function(blob) {
      return createImageBitmap(blob, 0, 0, source.width, source.height, {
        premultiplyAlpha: _this.alphaMode === ALPHA_MODES$3.UNPACK ? "premultiply" : "none"
      });
    }).then(function(bitmap) {
      if (_this.destroyed) {
        return Promise.reject();
      }
      _this.bitmap = bitmap;
      _this.update();
      _this._process = null;
      return Promise.resolve(_this);
    });
    return this._process;
  };
  ImageResource2.prototype.upload = function(renderer, baseTexture, glTexture) {
    if (typeof this.alphaMode === "number") {
      baseTexture.alphaMode = this.alphaMode;
    }
    if (!this.createBitmap) {
      return _super.prototype.upload.call(this, renderer, baseTexture, glTexture);
    }
    if (!this.bitmap) {
      this.process();
      if (!this.bitmap) {
        return false;
      }
    }
    _super.prototype.upload.call(this, renderer, baseTexture, glTexture, this.bitmap);
    if (!this.preserveBitmap) {
      var flag = true;
      var glTextures = baseTexture._glTextures;
      for (var key in glTextures) {
        var otherTex = glTextures[key];
        if (otherTex !== glTexture && otherTex.dirtyId !== baseTexture.dirtyId) {
          flag = false;
          break;
        }
      }
      if (flag) {
        if (this.bitmap.close) {
          this.bitmap.close();
        }
        this.bitmap = null;
      }
    }
    return true;
  };
  ImageResource2.prototype.dispose = function() {
    this.source.onload = null;
    this.source.onerror = null;
    _super.prototype.dispose.call(this);
    if (this.bitmap) {
      this.bitmap.close();
      this.bitmap = null;
    }
    this._process = null;
    this._load = null;
  };
  ImageResource2.test = function(source) {
    return typeof source === "string" || source instanceof HTMLImageElement;
  };
  return ImageResource2;
}(BaseImageResource);
var SVGResource = function(_super) {
  __extends$q(SVGResource2, _super);
  function SVGResource2(sourceBase64, options) {
    var _this = this;
    options = options || {};
    _this = _super.call(this, document.createElement("canvas")) || this;
    _this._width = 0;
    _this._height = 0;
    _this.svg = sourceBase64;
    _this.scale = options.scale || 1;
    _this._overrideWidth = options.width;
    _this._overrideHeight = options.height;
    _this._resolve = null;
    _this._crossorigin = options.crossorigin;
    _this._load = null;
    if (options.autoLoad !== false) {
      _this.load();
    }
    return _this;
  }
  SVGResource2.prototype.load = function() {
    var _this = this;
    if (this._load) {
      return this._load;
    }
    this._load = new Promise(function(resolve2) {
      _this._resolve = function() {
        _this.resize(_this.source.width, _this.source.height);
        resolve2(_this);
      };
      if (SVGResource2.SVG_XML.test(_this.svg.trim())) {
        if (!btoa) {
          throw new Error("Your browser doesn't support base64 conversions.");
        }
        _this.svg = "data:image/svg+xml;base64," + btoa(unescape(encodeURIComponent(_this.svg)));
      }
      _this._loadSvg();
    });
    return this._load;
  };
  SVGResource2.prototype._loadSvg = function() {
    var _this = this;
    var tempImage = new Image();
    BaseImageResource.crossOrigin(tempImage, this.svg, this._crossorigin);
    tempImage.src = this.svg;
    tempImage.onerror = function(event) {
      if (!_this._resolve) {
        return;
      }
      tempImage.onerror = null;
      _this.onError.emit(event);
    };
    tempImage.onload = function() {
      if (!_this._resolve) {
        return;
      }
      var svgWidth = tempImage.width;
      var svgHeight = tempImage.height;
      if (!svgWidth || !svgHeight) {
        throw new Error("The SVG image must have width and height defined (in pixels), canvas API needs them.");
      }
      var width = svgWidth * _this.scale;
      var height = svgHeight * _this.scale;
      if (_this._overrideWidth || _this._overrideHeight) {
        width = _this._overrideWidth || _this._overrideHeight / svgHeight * svgWidth;
        height = _this._overrideHeight || _this._overrideWidth / svgWidth * svgHeight;
      }
      width = Math.round(width);
      height = Math.round(height);
      var canvas2 = _this.source;
      canvas2.width = width;
      canvas2.height = height;
      canvas2._pixiId = "canvas_" + uid();
      canvas2.getContext("2d").drawImage(tempImage, 0, 0, svgWidth, svgHeight, 0, 0, width, height);
      _this._resolve();
      _this._resolve = null;
    };
  };
  SVGResource2.getSize = function(svgString) {
    var sizeMatch = SVGResource2.SVG_SIZE.exec(svgString);
    var size = {};
    if (sizeMatch) {
      size[sizeMatch[1]] = Math.round(parseFloat(sizeMatch[3]));
      size[sizeMatch[5]] = Math.round(parseFloat(sizeMatch[7]));
    }
    return size;
  };
  SVGResource2.prototype.dispose = function() {
    _super.prototype.dispose.call(this);
    this._resolve = null;
    this._crossorigin = null;
  };
  SVGResource2.test = function(source, extension) {
    return extension === "svg" || typeof source === "string" && /^data:image\/svg\+xml(;(charset=utf8|utf8))?;base64/.test(source) || typeof source === "string" && SVGResource2.SVG_XML.test(source);
  };
  SVGResource2.SVG_XML = /^(<\?xml[^?]+\?>)?\s*(<!--[^(-->)]*-->)?\s*\<svg/m;
  SVGResource2.SVG_SIZE = /<svg[^>]*(?:\s(width|height)=('|")(\d*(?:\.\d+)?)(?:px)?('|"))[^>]*(?:\s(width|height)=('|")(\d*(?:\.\d+)?)(?:px)?('|"))[^>]*>/i;
  return SVGResource2;
}(BaseImageResource);
var VideoResource = function(_super) {
  __extends$q(VideoResource2, _super);
  function VideoResource2(source, options) {
    var _this = this;
    options = options || {};
    if (!(source instanceof HTMLVideoElement)) {
      var videoElement = document.createElement("video");
      videoElement.setAttribute("preload", "auto");
      videoElement.setAttribute("webkit-playsinline", "");
      videoElement.setAttribute("playsinline", "");
      if (typeof source === "string") {
        source = [source];
      }
      var firstSrc = source[0].src || source[0];
      BaseImageResource.crossOrigin(videoElement, firstSrc, options.crossorigin);
      for (var i2 = 0; i2 < source.length; ++i2) {
        var sourceElement = document.createElement("source");
        var _a3 = source[i2], src = _a3.src, mime = _a3.mime;
        src = src || source[i2];
        var baseSrc = src.split("?").shift().toLowerCase();
        var ext = baseSrc.slice(baseSrc.lastIndexOf(".") + 1);
        mime = mime || VideoResource2.MIME_TYPES[ext] || "video/" + ext;
        sourceElement.src = src;
        sourceElement.type = mime;
        videoElement.appendChild(sourceElement);
      }
      source = videoElement;
    }
    _this = _super.call(this, source) || this;
    _this.noSubImage = true;
    _this._autoUpdate = true;
    _this._isConnectedToTicker = false;
    _this._updateFPS = options.updateFPS || 0;
    _this._msToNextUpdate = 0;
    _this.autoPlay = options.autoPlay !== false;
    _this._load = null;
    _this._resolve = null;
    _this._onCanPlay = _this._onCanPlay.bind(_this);
    _this._onError = _this._onError.bind(_this);
    if (options.autoLoad !== false) {
      _this.load();
    }
    return _this;
  }
  VideoResource2.prototype.update = function(_deltaTime) {
    if (!this.destroyed) {
      var elapsedMS = Ticker.shared.elapsedMS * this.source.playbackRate;
      this._msToNextUpdate = Math.floor(this._msToNextUpdate - elapsedMS);
      if (!this._updateFPS || this._msToNextUpdate <= 0) {
        _super.prototype.update.call(this);
        this._msToNextUpdate = this._updateFPS ? Math.floor(1e3 / this._updateFPS) : 0;
      }
    }
  };
  VideoResource2.prototype.load = function() {
    var _this = this;
    if (this._load) {
      return this._load;
    }
    var source = this.source;
    if ((source.readyState === source.HAVE_ENOUGH_DATA || source.readyState === source.HAVE_FUTURE_DATA) && source.width && source.height) {
      source.complete = true;
    }
    source.addEventListener("play", this._onPlayStart.bind(this));
    source.addEventListener("pause", this._onPlayStop.bind(this));
    if (!this._isSourceReady()) {
      source.addEventListener("canplay", this._onCanPlay);
      source.addEventListener("canplaythrough", this._onCanPlay);
      source.addEventListener("error", this._onError, true);
    } else {
      this._onCanPlay();
    }
    this._load = new Promise(function(resolve2) {
      if (_this.valid) {
        resolve2(_this);
      } else {
        _this._resolve = resolve2;
        source.load();
      }
    });
    return this._load;
  };
  VideoResource2.prototype._onError = function(event) {
    this.source.removeEventListener("error", this._onError, true);
    this.onError.emit(event);
  };
  VideoResource2.prototype._isSourcePlaying = function() {
    var source = this.source;
    return source.currentTime > 0 && source.paused === false && source.ended === false && source.readyState > 2;
  };
  VideoResource2.prototype._isSourceReady = function() {
    var source = this.source;
    return source.readyState === 3 || source.readyState === 4;
  };
  VideoResource2.prototype._onPlayStart = function() {
    if (!this.valid) {
      this._onCanPlay();
    }
    if (this.autoUpdate && !this._isConnectedToTicker) {
      Ticker.shared.add(this.update, this);
      this._isConnectedToTicker = true;
    }
  };
  VideoResource2.prototype._onPlayStop = function() {
    if (this._isConnectedToTicker) {
      Ticker.shared.remove(this.update, this);
      this._isConnectedToTicker = false;
    }
  };
  VideoResource2.prototype._onCanPlay = function() {
    var source = this.source;
    source.removeEventListener("canplay", this._onCanPlay);
    source.removeEventListener("canplaythrough", this._onCanPlay);
    var valid = this.valid;
    this.resize(source.videoWidth, source.videoHeight);
    if (!valid && this._resolve) {
      this._resolve(this);
      this._resolve = null;
    }
    if (this._isSourcePlaying()) {
      this._onPlayStart();
    } else if (this.autoPlay) {
      source.play();
    }
  };
  VideoResource2.prototype.dispose = function() {
    if (this._isConnectedToTicker) {
      Ticker.shared.remove(this.update, this);
      this._isConnectedToTicker = false;
    }
    var source = this.source;
    if (source) {
      source.removeEventListener("error", this._onError, true);
      source.pause();
      source.src = "";
      source.load();
    }
    _super.prototype.dispose.call(this);
  };
  Object.defineProperty(VideoResource2.prototype, "autoUpdate", {
    get: function() {
      return this._autoUpdate;
    },
    set: function(value) {
      if (value !== this._autoUpdate) {
        this._autoUpdate = value;
        if (!this._autoUpdate && this._isConnectedToTicker) {
          Ticker.shared.remove(this.update, this);
          this._isConnectedToTicker = false;
        } else if (this._autoUpdate && !this._isConnectedToTicker && this._isSourcePlaying()) {
          Ticker.shared.add(this.update, this);
          this._isConnectedToTicker = true;
        }
      }
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(VideoResource2.prototype, "updateFPS", {
    get: function() {
      return this._updateFPS;
    },
    set: function(value) {
      if (value !== this._updateFPS) {
        this._updateFPS = value;
      }
    },
    enumerable: false,
    configurable: true
  });
  VideoResource2.test = function(source, extension) {
    return globalThis.HTMLVideoElement && source instanceof HTMLVideoElement || VideoResource2.TYPES.indexOf(extension) > -1;
  };
  VideoResource2.TYPES = ["mp4", "m4v", "webm", "ogg", "ogv", "h264", "avi", "mov"];
  VideoResource2.MIME_TYPES = {
    ogv: "video/ogg",
    mov: "video/quicktime",
    m4v: "video/mp4"
  };
  return VideoResource2;
}(BaseImageResource);
var ImageBitmapResource = function(_super) {
  __extends$q(ImageBitmapResource2, _super);
  function ImageBitmapResource2(source) {
    return _super.call(this, source) || this;
  }
  ImageBitmapResource2.test = function(source) {
    return !!globalThis.createImageBitmap && source instanceof ImageBitmap;
  };
  return ImageBitmapResource2;
}(BaseImageResource);
INSTALLED.push(ImageResource, ImageBitmapResource, CanvasResource, VideoResource, SVGResource, BufferResource, CubeResource, ArrayResource);
var _resources = {
  __proto__: null,
  Resource,
  BaseImageResource,
  INSTALLED,
  autoDetectResource,
  AbstractMultiResource,
  ArrayResource,
  BufferResource,
  CanvasResource,
  CubeResource,
  ImageResource,
  SVGResource,
  VideoResource,
  ImageBitmapResource
};
var DepthResource = function(_super) {
  __extends$q(DepthResource2, _super);
  function DepthResource2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  DepthResource2.prototype.upload = function(renderer, baseTexture, glTexture) {
    var gl = renderer.gl;
    gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, baseTexture.alphaMode === ALPHA_MODES$3.UNPACK);
    var width = baseTexture.realWidth;
    var height = baseTexture.realHeight;
    if (glTexture.width === width && glTexture.height === height) {
      gl.texSubImage2D(baseTexture.target, 0, 0, 0, width, height, baseTexture.format, glTexture.type, this.data);
    } else {
      glTexture.width = width;
      glTexture.height = height;
      gl.texImage2D(baseTexture.target, 0, glTexture.internalFormat, width, height, 0, baseTexture.format, glTexture.type, this.data);
    }
    return true;
  };
  return DepthResource2;
}(BufferResource);
var Framebuffer = function() {
  function Framebuffer2(width, height) {
    this.width = Math.round(width || 100);
    this.height = Math.round(height || 100);
    this.stencil = false;
    this.depth = false;
    this.dirtyId = 0;
    this.dirtyFormat = 0;
    this.dirtySize = 0;
    this.depthTexture = null;
    this.colorTextures = [];
    this.glFramebuffers = {};
    this.disposeRunner = new Runner("disposeFramebuffer");
    this.multisample = MSAA_QUALITY$3.NONE;
  }
  Object.defineProperty(Framebuffer2.prototype, "colorTexture", {
    get: function() {
      return this.colorTextures[0];
    },
    enumerable: false,
    configurable: true
  });
  Framebuffer2.prototype.addColorTexture = function(index, texture) {
    if (index === void 0) {
      index = 0;
    }
    this.colorTextures[index] = texture || new BaseTexture(null, {
      scaleMode: SCALE_MODES$3.NEAREST,
      resolution: 1,
      mipmap: MIPMAP_MODES$3.OFF,
      width: this.width,
      height: this.height
    });
    this.dirtyId++;
    this.dirtyFormat++;
    return this;
  };
  Framebuffer2.prototype.addDepthTexture = function(texture) {
    this.depthTexture = texture || new BaseTexture(new DepthResource(null, { width: this.width, height: this.height }), {
      scaleMode: SCALE_MODES$3.NEAREST,
      resolution: 1,
      width: this.width,
      height: this.height,
      mipmap: MIPMAP_MODES$3.OFF,
      format: FORMATS$3.DEPTH_COMPONENT,
      type: TYPES$3.UNSIGNED_SHORT
    });
    this.dirtyId++;
    this.dirtyFormat++;
    return this;
  };
  Framebuffer2.prototype.enableDepth = function() {
    this.depth = true;
    this.dirtyId++;
    this.dirtyFormat++;
    return this;
  };
  Framebuffer2.prototype.enableStencil = function() {
    this.stencil = true;
    this.dirtyId++;
    this.dirtyFormat++;
    return this;
  };
  Framebuffer2.prototype.resize = function(width, height) {
    width = Math.round(width);
    height = Math.round(height);
    if (width === this.width && height === this.height) {
      return;
    }
    this.width = width;
    this.height = height;
    this.dirtyId++;
    this.dirtySize++;
    for (var i2 = 0; i2 < this.colorTextures.length; i2++) {
      var texture = this.colorTextures[i2];
      var resolution = texture.resolution;
      texture.setSize(width / resolution, height / resolution);
    }
    if (this.depthTexture) {
      var resolution = this.depthTexture.resolution;
      this.depthTexture.setSize(width / resolution, height / resolution);
    }
  };
  Framebuffer2.prototype.dispose = function() {
    this.disposeRunner.emit(this, false);
  };
  Framebuffer2.prototype.destroyDepthTexture = function() {
    if (this.depthTexture) {
      this.depthTexture.destroy();
      this.depthTexture = null;
      ++this.dirtyId;
      ++this.dirtyFormat;
    }
  };
  return Framebuffer2;
}();
var BaseRenderTexture = function(_super) {
  __extends$q(BaseRenderTexture2, _super);
  function BaseRenderTexture2(options) {
    if (options === void 0) {
      options = {};
    }
    var _this = this;
    if (typeof options === "number") {
      var width = arguments[0];
      var height = arguments[1];
      var scaleMode = arguments[2];
      var resolution = arguments[3];
      options = { width, height, scaleMode, resolution };
    }
    options.width = options.width || 100;
    options.height = options.height || 100;
    options.multisample = options.multisample !== void 0 ? options.multisample : MSAA_QUALITY$3.NONE;
    _this = _super.call(this, null, options) || this;
    _this.mipmap = MIPMAP_MODES$3.OFF;
    _this.valid = true;
    _this.clearColor = [0, 0, 0, 0];
    _this.framebuffer = new Framebuffer(_this.realWidth, _this.realHeight).addColorTexture(0, _this);
    _this.framebuffer.multisample = options.multisample;
    _this.maskStack = [];
    _this.filterStack = [{}];
    return _this;
  }
  BaseRenderTexture2.prototype.resize = function(desiredWidth, desiredHeight) {
    this.framebuffer.resize(desiredWidth * this.resolution, desiredHeight * this.resolution);
    this.setRealSize(this.framebuffer.width, this.framebuffer.height);
  };
  BaseRenderTexture2.prototype.dispose = function() {
    this.framebuffer.dispose();
    _super.prototype.dispose.call(this);
  };
  BaseRenderTexture2.prototype.destroy = function() {
    _super.prototype.destroy.call(this);
    this.framebuffer.destroyDepthTexture();
    this.framebuffer = null;
  };
  return BaseRenderTexture2;
}(BaseTexture);
var TextureUvs = function() {
  function TextureUvs2() {
    this.x0 = 0;
    this.y0 = 0;
    this.x1 = 1;
    this.y1 = 0;
    this.x2 = 1;
    this.y2 = 1;
    this.x3 = 0;
    this.y3 = 1;
    this.uvsFloat32 = new Float32Array(8);
  }
  TextureUvs2.prototype.set = function(frame, baseFrame, rotate2) {
    var tw = baseFrame.width;
    var th = baseFrame.height;
    if (rotate2) {
      var w2 = frame.width / 2 / tw;
      var h2 = frame.height / 2 / th;
      var cX = frame.x / tw + w2;
      var cY = frame.y / th + h2;
      rotate2 = groupD8.add(rotate2, groupD8.NW);
      this.x0 = cX + w2 * groupD8.uX(rotate2);
      this.y0 = cY + h2 * groupD8.uY(rotate2);
      rotate2 = groupD8.add(rotate2, 2);
      this.x1 = cX + w2 * groupD8.uX(rotate2);
      this.y1 = cY + h2 * groupD8.uY(rotate2);
      rotate2 = groupD8.add(rotate2, 2);
      this.x2 = cX + w2 * groupD8.uX(rotate2);
      this.y2 = cY + h2 * groupD8.uY(rotate2);
      rotate2 = groupD8.add(rotate2, 2);
      this.x3 = cX + w2 * groupD8.uX(rotate2);
      this.y3 = cY + h2 * groupD8.uY(rotate2);
    } else {
      this.x0 = frame.x / tw;
      this.y0 = frame.y / th;
      this.x1 = (frame.x + frame.width) / tw;
      this.y1 = frame.y / th;
      this.x2 = (frame.x + frame.width) / tw;
      this.y2 = (frame.y + frame.height) / th;
      this.x3 = frame.x / tw;
      this.y3 = (frame.y + frame.height) / th;
    }
    this.uvsFloat32[0] = this.x0;
    this.uvsFloat32[1] = this.y0;
    this.uvsFloat32[2] = this.x1;
    this.uvsFloat32[3] = this.y1;
    this.uvsFloat32[4] = this.x2;
    this.uvsFloat32[5] = this.y2;
    this.uvsFloat32[6] = this.x3;
    this.uvsFloat32[7] = this.y3;
  };
  TextureUvs2.prototype.toString = function() {
    return "[@pixi/core:TextureUvs " + ("x0=" + this.x0 + " y0=" + this.y0 + " ") + ("x1=" + this.x1 + " y1=" + this.y1 + " x2=" + this.x2 + " ") + ("y2=" + this.y2 + " x3=" + this.x3 + " y3=" + this.y3) + "]";
  };
  return TextureUvs2;
}();
var DEFAULT_UVS = new TextureUvs();
var Texture = function(_super) {
  __extends$q(Texture2, _super);
  function Texture2(baseTexture, frame, orig, trim2, rotate2, anchor) {
    var _this = _super.call(this) || this;
    _this.noFrame = false;
    if (!frame) {
      _this.noFrame = true;
      frame = new Rectangle(0, 0, 1, 1);
    }
    if (baseTexture instanceof Texture2) {
      baseTexture = baseTexture.baseTexture;
    }
    _this.baseTexture = baseTexture;
    _this._frame = frame;
    _this.trim = trim2;
    _this.valid = false;
    _this._uvs = DEFAULT_UVS;
    _this.uvMatrix = null;
    _this.orig = orig || frame;
    _this._rotate = Number(rotate2 || 0);
    if (rotate2 === true) {
      _this._rotate = 2;
    } else if (_this._rotate % 2 !== 0) {
      throw new Error("attempt to use diamond-shaped UVs. If you are sure, set rotation manually");
    }
    _this.defaultAnchor = anchor ? new Point(anchor.x, anchor.y) : new Point(0, 0);
    _this._updateID = 0;
    _this.textureCacheIds = [];
    if (!baseTexture.valid) {
      baseTexture.once("loaded", _this.onBaseTextureUpdated, _this);
    } else if (_this.noFrame) {
      if (baseTexture.valid) {
        _this.onBaseTextureUpdated(baseTexture);
      }
    } else {
      _this.frame = frame;
    }
    if (_this.noFrame) {
      baseTexture.on("update", _this.onBaseTextureUpdated, _this);
    }
    return _this;
  }
  Texture2.prototype.update = function() {
    if (this.baseTexture.resource) {
      this.baseTexture.resource.update();
    }
  };
  Texture2.prototype.onBaseTextureUpdated = function(baseTexture) {
    if (this.noFrame) {
      if (!this.baseTexture.valid) {
        return;
      }
      this._frame.width = baseTexture.width;
      this._frame.height = baseTexture.height;
      this.valid = true;
      this.updateUvs();
    } else {
      this.frame = this._frame;
    }
    this.emit("update", this);
  };
  Texture2.prototype.destroy = function(destroyBase) {
    if (this.baseTexture) {
      if (destroyBase) {
        var resource = this.baseTexture.resource;
        if (resource && resource.url && TextureCache[resource.url]) {
          Texture2.removeFromCache(resource.url);
        }
        this.baseTexture.destroy();
      }
      this.baseTexture.off("loaded", this.onBaseTextureUpdated, this);
      this.baseTexture.off("update", this.onBaseTextureUpdated, this);
      this.baseTexture = null;
    }
    this._frame = null;
    this._uvs = null;
    this.trim = null;
    this.orig = null;
    this.valid = false;
    Texture2.removeFromCache(this);
    this.textureCacheIds = null;
  };
  Texture2.prototype.clone = function() {
    var clonedFrame = this._frame.clone();
    var clonedOrig = this._frame === this.orig ? clonedFrame : this.orig.clone();
    var clonedTexture = new Texture2(this.baseTexture, !this.noFrame && clonedFrame, clonedOrig, this.trim && this.trim.clone(), this.rotate, this.defaultAnchor);
    if (this.noFrame) {
      clonedTexture._frame = clonedFrame;
    }
    return clonedTexture;
  };
  Texture2.prototype.updateUvs = function() {
    if (this._uvs === DEFAULT_UVS) {
      this._uvs = new TextureUvs();
    }
    this._uvs.set(this._frame, this.baseTexture, this.rotate);
    this._updateID++;
  };
  Texture2.from = function(source, options, strict) {
    if (options === void 0) {
      options = {};
    }
    if (strict === void 0) {
      strict = settings.STRICT_TEXTURE_CACHE;
    }
    var isFrame = typeof source === "string";
    var cacheId = null;
    if (isFrame) {
      cacheId = source;
    } else if (source instanceof BaseTexture) {
      if (!source.cacheId) {
        var prefix2 = options && options.pixiIdPrefix || "pixiid";
        source.cacheId = prefix2 + "-" + uid();
        BaseTexture.addToCache(source, source.cacheId);
      }
      cacheId = source.cacheId;
    } else {
      if (!source._pixiId) {
        var prefix2 = options && options.pixiIdPrefix || "pixiid";
        source._pixiId = prefix2 + "_" + uid();
      }
      cacheId = source._pixiId;
    }
    var texture = TextureCache[cacheId];
    if (isFrame && strict && !texture) {
      throw new Error('The cacheId "' + cacheId + '" does not exist in TextureCache.');
    }
    if (!texture && !(source instanceof BaseTexture)) {
      if (!options.resolution) {
        options.resolution = getResolutionOfUrl(source);
      }
      texture = new Texture2(new BaseTexture(source, options));
      texture.baseTexture.cacheId = cacheId;
      BaseTexture.addToCache(texture.baseTexture, cacheId);
      Texture2.addToCache(texture, cacheId);
    } else if (!texture && source instanceof BaseTexture) {
      texture = new Texture2(source);
      Texture2.addToCache(texture, cacheId);
    }
    return texture;
  };
  Texture2.fromURL = function(url2, options) {
    var resourceOptions = Object.assign({ autoLoad: false }, options === null || options === void 0 ? void 0 : options.resourceOptions);
    var texture = Texture2.from(url2, Object.assign({ resourceOptions }, options), false);
    var resource = texture.baseTexture.resource;
    if (texture.baseTexture.valid) {
      return Promise.resolve(texture);
    }
    return resource.load().then(function() {
      return Promise.resolve(texture);
    });
  };
  Texture2.fromBuffer = function(buffer, width, height, options) {
    return new Texture2(BaseTexture.fromBuffer(buffer, width, height, options));
  };
  Texture2.fromLoader = function(source, imageUrl, name2, options) {
    var baseTexture = new BaseTexture(source, Object.assign({
      scaleMode: settings.SCALE_MODE,
      resolution: getResolutionOfUrl(imageUrl)
    }, options));
    var resource = baseTexture.resource;
    if (resource instanceof ImageResource) {
      resource.url = imageUrl;
    }
    var texture = new Texture2(baseTexture);
    if (!name2) {
      name2 = imageUrl;
    }
    BaseTexture.addToCache(texture.baseTexture, name2);
    Texture2.addToCache(texture, name2);
    if (name2 !== imageUrl) {
      BaseTexture.addToCache(texture.baseTexture, imageUrl);
      Texture2.addToCache(texture, imageUrl);
    }
    if (texture.baseTexture.valid) {
      return Promise.resolve(texture);
    }
    return new Promise(function(resolve2) {
      texture.baseTexture.once("loaded", function() {
        return resolve2(texture);
      });
    });
  };
  Texture2.addToCache = function(texture, id) {
    if (id) {
      if (texture.textureCacheIds.indexOf(id) === -1) {
        texture.textureCacheIds.push(id);
      }
      if (TextureCache[id]) {
        console.warn("Texture added to the cache with an id [" + id + "] that already had an entry");
      }
      TextureCache[id] = texture;
    }
  };
  Texture2.removeFromCache = function(texture) {
    if (typeof texture === "string") {
      var textureFromCache = TextureCache[texture];
      if (textureFromCache) {
        var index = textureFromCache.textureCacheIds.indexOf(texture);
        if (index > -1) {
          textureFromCache.textureCacheIds.splice(index, 1);
        }
        delete TextureCache[texture];
        return textureFromCache;
      }
    } else if (texture && texture.textureCacheIds) {
      for (var i2 = 0; i2 < texture.textureCacheIds.length; ++i2) {
        if (TextureCache[texture.textureCacheIds[i2]] === texture) {
          delete TextureCache[texture.textureCacheIds[i2]];
        }
      }
      texture.textureCacheIds.length = 0;
      return texture;
    }
    return null;
  };
  Object.defineProperty(Texture2.prototype, "resolution", {
    get: function() {
      return this.baseTexture.resolution;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Texture2.prototype, "frame", {
    get: function() {
      return this._frame;
    },
    set: function(frame) {
      this._frame = frame;
      this.noFrame = false;
      var x2 = frame.x, y2 = frame.y, width = frame.width, height = frame.height;
      var xNotFit = x2 + width > this.baseTexture.width;
      var yNotFit = y2 + height > this.baseTexture.height;
      if (xNotFit || yNotFit) {
        var relationship = xNotFit && yNotFit ? "and" : "or";
        var errorX = "X: " + x2 + " + " + width + " = " + (x2 + width) + " > " + this.baseTexture.width;
        var errorY = "Y: " + y2 + " + " + height + " = " + (y2 + height) + " > " + this.baseTexture.height;
        throw new Error("Texture Error: frame does not fit inside the base Texture dimensions: " + (errorX + " " + relationship + " " + errorY));
      }
      this.valid = width && height && this.baseTexture.valid;
      if (!this.trim && !this.rotate) {
        this.orig = frame;
      }
      if (this.valid) {
        this.updateUvs();
      }
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Texture2.prototype, "rotate", {
    get: function() {
      return this._rotate;
    },
    set: function(rotate2) {
      this._rotate = rotate2;
      if (this.valid) {
        this.updateUvs();
      }
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Texture2.prototype, "width", {
    get: function() {
      return this.orig.width;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Texture2.prototype, "height", {
    get: function() {
      return this.orig.height;
    },
    enumerable: false,
    configurable: true
  });
  Texture2.prototype.castToBaseTexture = function() {
    return this.baseTexture;
  };
  return Texture2;
}(EventEmitter$3);
function createWhiteTexture() {
  var canvas2 = document.createElement("canvas");
  canvas2.width = 16;
  canvas2.height = 16;
  var context2 = canvas2.getContext("2d");
  context2.fillStyle = "white";
  context2.fillRect(0, 0, 16, 16);
  return new Texture(new BaseTexture(new CanvasResource(canvas2)));
}
function removeAllHandlers(tex) {
  tex.destroy = function _emptyDestroy() {
  };
  tex.on = function _emptyOn() {
  };
  tex.once = function _emptyOnce() {
  };
  tex.emit = function _emptyEmit() {
  };
}
Texture.EMPTY = new Texture(new BaseTexture());
removeAllHandlers(Texture.EMPTY);
removeAllHandlers(Texture.EMPTY.baseTexture);
Texture.WHITE = createWhiteTexture();
removeAllHandlers(Texture.WHITE);
removeAllHandlers(Texture.WHITE.baseTexture);
var RenderTexture = function(_super) {
  __extends$q(RenderTexture2, _super);
  function RenderTexture2(baseRenderTexture, frame) {
    var _this = _super.call(this, baseRenderTexture, frame) || this;
    _this.valid = true;
    _this.filterFrame = null;
    _this.filterPoolKey = null;
    _this.updateUvs();
    return _this;
  }
  Object.defineProperty(RenderTexture2.prototype, "framebuffer", {
    get: function() {
      return this.baseTexture.framebuffer;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(RenderTexture2.prototype, "multisample", {
    get: function() {
      return this.framebuffer.multisample;
    },
    set: function(value) {
      this.framebuffer.multisample = value;
    },
    enumerable: false,
    configurable: true
  });
  RenderTexture2.prototype.resize = function(desiredWidth, desiredHeight, resizeBaseTexture) {
    if (resizeBaseTexture === void 0) {
      resizeBaseTexture = true;
    }
    var resolution = this.baseTexture.resolution;
    var width = Math.round(desiredWidth * resolution) / resolution;
    var height = Math.round(desiredHeight * resolution) / resolution;
    this.valid = width > 0 && height > 0;
    this._frame.width = this.orig.width = width;
    this._frame.height = this.orig.height = height;
    if (resizeBaseTexture) {
      this.baseTexture.resize(width, height);
    }
    this.updateUvs();
  };
  RenderTexture2.prototype.setResolution = function(resolution) {
    var baseTexture = this.baseTexture;
    if (baseTexture.resolution === resolution) {
      return;
    }
    baseTexture.setResolution(resolution);
    this.resize(baseTexture.width, baseTexture.height, false);
  };
  RenderTexture2.create = function(options) {
    var arguments$1 = arguments;
    var rest = [];
    for (var _i = 1; _i < arguments.length; _i++) {
      rest[_i - 1] = arguments$1[_i];
    }
    if (typeof options === "number") {
      deprecation("6.0.0", "Arguments (width, height, scaleMode, resolution) have been deprecated.");
      options = {
        width: options,
        height: rest[0],
        scaleMode: rest[1],
        resolution: rest[2]
      };
    }
    return new RenderTexture2(new BaseRenderTexture(options));
  };
  return RenderTexture2;
}(Texture);
var RenderTexturePool = function() {
  function RenderTexturePool2(textureOptions) {
    this.texturePool = {};
    this.textureOptions = textureOptions || {};
    this.enableFullScreen = false;
    this._pixelsWidth = 0;
    this._pixelsHeight = 0;
  }
  RenderTexturePool2.prototype.createTexture = function(realWidth, realHeight, multisample) {
    if (multisample === void 0) {
      multisample = MSAA_QUALITY$3.NONE;
    }
    var baseRenderTexture = new BaseRenderTexture(Object.assign({
      width: realWidth,
      height: realHeight,
      resolution: 1,
      multisample
    }, this.textureOptions));
    return new RenderTexture(baseRenderTexture);
  };
  RenderTexturePool2.prototype.getOptimalTexture = function(minWidth, minHeight, resolution, multisample) {
    if (resolution === void 0) {
      resolution = 1;
    }
    if (multisample === void 0) {
      multisample = MSAA_QUALITY$3.NONE;
    }
    var key;
    minWidth = Math.ceil(minWidth * resolution - 1e-6);
    minHeight = Math.ceil(minHeight * resolution - 1e-6);
    if (!this.enableFullScreen || minWidth !== this._pixelsWidth || minHeight !== this._pixelsHeight) {
      minWidth = nextPow2(minWidth);
      minHeight = nextPow2(minHeight);
      key = ((minWidth & 65535) << 16 | minHeight & 65535) >>> 0;
      if (multisample > 1) {
        key += multisample * 4294967296;
      }
    } else {
      key = multisample > 1 ? -multisample : -1;
    }
    if (!this.texturePool[key]) {
      this.texturePool[key] = [];
    }
    var renderTexture = this.texturePool[key].pop();
    if (!renderTexture) {
      renderTexture = this.createTexture(minWidth, minHeight, multisample);
    }
    renderTexture.filterPoolKey = key;
    renderTexture.setResolution(resolution);
    return renderTexture;
  };
  RenderTexturePool2.prototype.getFilterTexture = function(input, resolution, multisample) {
    var filterTexture = this.getOptimalTexture(input.width, input.height, resolution || input.resolution, multisample || MSAA_QUALITY$3.NONE);
    filterTexture.filterFrame = input.filterFrame;
    return filterTexture;
  };
  RenderTexturePool2.prototype.returnTexture = function(renderTexture) {
    var key = renderTexture.filterPoolKey;
    renderTexture.filterFrame = null;
    this.texturePool[key].push(renderTexture);
  };
  RenderTexturePool2.prototype.returnFilterTexture = function(renderTexture) {
    this.returnTexture(renderTexture);
  };
  RenderTexturePool2.prototype.clear = function(destroyTextures) {
    destroyTextures = destroyTextures !== false;
    if (destroyTextures) {
      for (var i2 in this.texturePool) {
        var textures = this.texturePool[i2];
        if (textures) {
          for (var j2 = 0; j2 < textures.length; j2++) {
            textures[j2].destroy(true);
          }
        }
      }
    }
    this.texturePool = {};
  };
  RenderTexturePool2.prototype.setScreenSize = function(size) {
    if (size.width === this._pixelsWidth && size.height === this._pixelsHeight) {
      return;
    }
    this.enableFullScreen = size.width > 0 && size.height > 0;
    for (var i2 in this.texturePool) {
      if (!(Number(i2) < 0)) {
        continue;
      }
      var textures = this.texturePool[i2];
      if (textures) {
        for (var j2 = 0; j2 < textures.length; j2++) {
          textures[j2].destroy(true);
        }
      }
      this.texturePool[i2] = [];
    }
    this._pixelsWidth = size.width;
    this._pixelsHeight = size.height;
  };
  RenderTexturePool2.SCREEN_KEY = -1;
  return RenderTexturePool2;
}();
var Attribute = function() {
  function Attribute2(buffer, size, normalized, type, stride, start, instance) {
    if (size === void 0) {
      size = 0;
    }
    if (normalized === void 0) {
      normalized = false;
    }
    if (type === void 0) {
      type = TYPES$3.FLOAT;
    }
    this.buffer = buffer;
    this.size = size;
    this.normalized = normalized;
    this.type = type;
    this.stride = stride;
    this.start = start;
    this.instance = instance;
  }
  Attribute2.prototype.destroy = function() {
    this.buffer = null;
  };
  Attribute2.from = function(buffer, size, normalized, type, stride) {
    return new Attribute2(buffer, size, normalized, type, stride);
  };
  return Attribute2;
}();
var UID = 0;
var Buffer$1 = function() {
  function Buffer2(data, _static, index) {
    if (_static === void 0) {
      _static = true;
    }
    if (index === void 0) {
      index = false;
    }
    this.data = data || new Float32Array(1);
    this._glBuffers = {};
    this._updateID = 0;
    this.index = index;
    this.static = _static;
    this.id = UID++;
    this.disposeRunner = new Runner("disposeBuffer");
  }
  Buffer2.prototype.update = function(data) {
    if (data instanceof Array) {
      data = new Float32Array(data);
    }
    this.data = data || this.data;
    this._updateID++;
  };
  Buffer2.prototype.dispose = function() {
    this.disposeRunner.emit(this, false);
  };
  Buffer2.prototype.destroy = function() {
    this.dispose();
    this.data = null;
  };
  Object.defineProperty(Buffer2.prototype, "index", {
    get: function() {
      return this.type === BUFFER_TYPE$3.ELEMENT_ARRAY_BUFFER;
    },
    set: function(value) {
      this.type = value ? BUFFER_TYPE$3.ELEMENT_ARRAY_BUFFER : BUFFER_TYPE$3.ARRAY_BUFFER;
    },
    enumerable: false,
    configurable: true
  });
  Buffer2.from = function(data) {
    if (data instanceof Array) {
      data = new Float32Array(data);
    }
    return new Buffer2(data);
  };
  return Buffer2;
}();
var map$1 = {
  Float32Array,
  Uint32Array,
  Int32Array,
  Uint8Array
};
function interleaveTypedArrays(arrays, sizes) {
  var outSize = 0;
  var stride = 0;
  var views = {};
  for (var i2 = 0; i2 < arrays.length; i2++) {
    stride += sizes[i2];
    outSize += arrays[i2].length;
  }
  var buffer = new ArrayBuffer(outSize * 4);
  var out = null;
  var littleOffset = 0;
  for (var i2 = 0; i2 < arrays.length; i2++) {
    var size = sizes[i2];
    var array = arrays[i2];
    var type = getBufferType(array);
    if (!views[type]) {
      views[type] = new map$1[type](buffer);
    }
    out = views[type];
    for (var j2 = 0; j2 < array.length; j2++) {
      var indexStart = (j2 / size | 0) * stride + littleOffset;
      var index = j2 % size;
      out[indexStart + index] = array[j2];
    }
    littleOffset += size;
  }
  return new Float32Array(buffer);
}
var byteSizeMap = { 5126: 4, 5123: 2, 5121: 1 };
var UID$1 = 0;
var map$1$1 = {
  Float32Array,
  Uint32Array,
  Int32Array,
  Uint8Array,
  Uint16Array
};
var Geometry = function() {
  function Geometry2(buffers, attributes) {
    if (buffers === void 0) {
      buffers = [];
    }
    if (attributes === void 0) {
      attributes = {};
    }
    this.buffers = buffers;
    this.indexBuffer = null;
    this.attributes = attributes;
    this.glVertexArrayObjects = {};
    this.id = UID$1++;
    this.instanced = false;
    this.instanceCount = 1;
    this.disposeRunner = new Runner("disposeGeometry");
    this.refCount = 0;
  }
  Geometry2.prototype.addAttribute = function(id, buffer, size, normalized, type, stride, start, instance) {
    if (size === void 0) {
      size = 0;
    }
    if (normalized === void 0) {
      normalized = false;
    }
    if (instance === void 0) {
      instance = false;
    }
    if (!buffer) {
      throw new Error("You must pass a buffer when creating an attribute");
    }
    if (!(buffer instanceof Buffer$1)) {
      if (buffer instanceof Array) {
        buffer = new Float32Array(buffer);
      }
      buffer = new Buffer$1(buffer);
    }
    var ids = id.split("|");
    if (ids.length > 1) {
      for (var i2 = 0; i2 < ids.length; i2++) {
        this.addAttribute(ids[i2], buffer, size, normalized, type);
      }
      return this;
    }
    var bufferIndex = this.buffers.indexOf(buffer);
    if (bufferIndex === -1) {
      this.buffers.push(buffer);
      bufferIndex = this.buffers.length - 1;
    }
    this.attributes[id] = new Attribute(bufferIndex, size, normalized, type, stride, start, instance);
    this.instanced = this.instanced || instance;
    return this;
  };
  Geometry2.prototype.getAttribute = function(id) {
    return this.attributes[id];
  };
  Geometry2.prototype.getBuffer = function(id) {
    return this.buffers[this.getAttribute(id).buffer];
  };
  Geometry2.prototype.addIndex = function(buffer) {
    if (!(buffer instanceof Buffer$1)) {
      if (buffer instanceof Array) {
        buffer = new Uint16Array(buffer);
      }
      buffer = new Buffer$1(buffer);
    }
    buffer.type = BUFFER_TYPE$3.ELEMENT_ARRAY_BUFFER;
    this.indexBuffer = buffer;
    if (this.buffers.indexOf(buffer) === -1) {
      this.buffers.push(buffer);
    }
    return this;
  };
  Geometry2.prototype.getIndex = function() {
    return this.indexBuffer;
  };
  Geometry2.prototype.interleave = function() {
    if (this.buffers.length === 1 || this.buffers.length === 2 && this.indexBuffer) {
      return this;
    }
    var arrays = [];
    var sizes = [];
    var interleavedBuffer = new Buffer$1();
    var i2;
    for (i2 in this.attributes) {
      var attribute = this.attributes[i2];
      var buffer = this.buffers[attribute.buffer];
      arrays.push(buffer.data);
      sizes.push(attribute.size * byteSizeMap[attribute.type] / 4);
      attribute.buffer = 0;
    }
    interleavedBuffer.data = interleaveTypedArrays(arrays, sizes);
    for (i2 = 0; i2 < this.buffers.length; i2++) {
      if (this.buffers[i2] !== this.indexBuffer) {
        this.buffers[i2].destroy();
      }
    }
    this.buffers = [interleavedBuffer];
    if (this.indexBuffer) {
      this.buffers.push(this.indexBuffer);
    }
    return this;
  };
  Geometry2.prototype.getSize = function() {
    for (var i2 in this.attributes) {
      var attribute = this.attributes[i2];
      var buffer = this.buffers[attribute.buffer];
      return buffer.data.length / (attribute.stride / 4 || attribute.size);
    }
    return 0;
  };
  Geometry2.prototype.dispose = function() {
    this.disposeRunner.emit(this, false);
  };
  Geometry2.prototype.destroy = function() {
    this.dispose();
    this.buffers = null;
    this.indexBuffer = null;
    this.attributes = null;
  };
  Geometry2.prototype.clone = function() {
    var geometry = new Geometry2();
    for (var i2 = 0; i2 < this.buffers.length; i2++) {
      geometry.buffers[i2] = new Buffer$1(this.buffers[i2].data.slice(0));
    }
    for (var i2 in this.attributes) {
      var attrib = this.attributes[i2];
      geometry.attributes[i2] = new Attribute(attrib.buffer, attrib.size, attrib.normalized, attrib.type, attrib.stride, attrib.start, attrib.instance);
    }
    if (this.indexBuffer) {
      geometry.indexBuffer = geometry.buffers[this.buffers.indexOf(this.indexBuffer)];
      geometry.indexBuffer.type = BUFFER_TYPE$3.ELEMENT_ARRAY_BUFFER;
    }
    return geometry;
  };
  Geometry2.merge = function(geometries) {
    var geometryOut = new Geometry2();
    var arrays = [];
    var sizes = [];
    var offsets = [];
    var geometry;
    for (var i2 = 0; i2 < geometries.length; i2++) {
      geometry = geometries[i2];
      for (var j2 = 0; j2 < geometry.buffers.length; j2++) {
        sizes[j2] = sizes[j2] || 0;
        sizes[j2] += geometry.buffers[j2].data.length;
        offsets[j2] = 0;
      }
    }
    for (var i2 = 0; i2 < geometry.buffers.length; i2++) {
      arrays[i2] = new map$1$1[getBufferType(geometry.buffers[i2].data)](sizes[i2]);
      geometryOut.buffers[i2] = new Buffer$1(arrays[i2]);
    }
    for (var i2 = 0; i2 < geometries.length; i2++) {
      geometry = geometries[i2];
      for (var j2 = 0; j2 < geometry.buffers.length; j2++) {
        arrays[j2].set(geometry.buffers[j2].data, offsets[j2]);
        offsets[j2] += geometry.buffers[j2].data.length;
      }
    }
    geometryOut.attributes = geometry.attributes;
    if (geometry.indexBuffer) {
      geometryOut.indexBuffer = geometryOut.buffers[geometry.buffers.indexOf(geometry.indexBuffer)];
      geometryOut.indexBuffer.type = BUFFER_TYPE$3.ELEMENT_ARRAY_BUFFER;
      var offset = 0;
      var stride = 0;
      var offset2 = 0;
      var bufferIndexToCount = 0;
      for (var i2 = 0; i2 < geometry.buffers.length; i2++) {
        if (geometry.buffers[i2] !== geometry.indexBuffer) {
          bufferIndexToCount = i2;
          break;
        }
      }
      for (var i2 in geometry.attributes) {
        var attribute = geometry.attributes[i2];
        if ((attribute.buffer | 0) === bufferIndexToCount) {
          stride += attribute.size * byteSizeMap[attribute.type] / 4;
        }
      }
      for (var i2 = 0; i2 < geometries.length; i2++) {
        var indexBufferData = geometries[i2].indexBuffer.data;
        for (var j2 = 0; j2 < indexBufferData.length; j2++) {
          geometryOut.indexBuffer.data[j2 + offset2] += offset;
        }
        offset += geometries[i2].buffers[bufferIndexToCount].data.length / stride;
        offset2 += indexBufferData.length;
      }
    }
    return geometryOut;
  };
  return Geometry2;
}();
var Quad = function(_super) {
  __extends$q(Quad2, _super);
  function Quad2() {
    var _this = _super.call(this) || this;
    _this.addAttribute("aVertexPosition", new Float32Array([
      0,
      0,
      1,
      0,
      1,
      1,
      0,
      1
    ])).addIndex([0, 1, 3, 2]);
    return _this;
  }
  return Quad2;
}(Geometry);
var QuadUv = function(_super) {
  __extends$q(QuadUv2, _super);
  function QuadUv2() {
    var _this = _super.call(this) || this;
    _this.vertices = new Float32Array([
      -1,
      -1,
      1,
      -1,
      1,
      1,
      -1,
      1
    ]);
    _this.uvs = new Float32Array([
      0,
      0,
      1,
      0,
      1,
      1,
      0,
      1
    ]);
    _this.vertexBuffer = new Buffer$1(_this.vertices);
    _this.uvBuffer = new Buffer$1(_this.uvs);
    _this.addAttribute("aVertexPosition", _this.vertexBuffer).addAttribute("aTextureCoord", _this.uvBuffer).addIndex([0, 1, 2, 0, 2, 3]);
    return _this;
  }
  QuadUv2.prototype.map = function(targetTextureFrame, destinationFrame) {
    var x2 = 0;
    var y2 = 0;
    this.uvs[0] = x2;
    this.uvs[1] = y2;
    this.uvs[2] = x2 + destinationFrame.width / targetTextureFrame.width;
    this.uvs[3] = y2;
    this.uvs[4] = x2 + destinationFrame.width / targetTextureFrame.width;
    this.uvs[5] = y2 + destinationFrame.height / targetTextureFrame.height;
    this.uvs[6] = x2;
    this.uvs[7] = y2 + destinationFrame.height / targetTextureFrame.height;
    x2 = destinationFrame.x;
    y2 = destinationFrame.y;
    this.vertices[0] = x2;
    this.vertices[1] = y2;
    this.vertices[2] = x2 + destinationFrame.width;
    this.vertices[3] = y2;
    this.vertices[4] = x2 + destinationFrame.width;
    this.vertices[5] = y2 + destinationFrame.height;
    this.vertices[6] = x2;
    this.vertices[7] = y2 + destinationFrame.height;
    this.invalidate();
    return this;
  };
  QuadUv2.prototype.invalidate = function() {
    this.vertexBuffer._updateID++;
    this.uvBuffer._updateID++;
    return this;
  };
  return QuadUv2;
}(Geometry);
var UID$2 = 0;
var UniformGroup = function() {
  function UniformGroup2(uniforms, isStatic, isUbo) {
    this.group = true;
    this.syncUniforms = {};
    this.dirtyId = 0;
    this.id = UID$2++;
    this.static = !!isStatic;
    this.ubo = !!isUbo;
    if (uniforms instanceof Buffer$1) {
      this.buffer = uniforms;
      this.buffer.type = BUFFER_TYPE$3.UNIFORM_BUFFER;
      this.autoManage = false;
      this.ubo = true;
    } else {
      this.uniforms = uniforms;
      if (this.ubo) {
        this.buffer = new Buffer$1(new Float32Array(1));
        this.buffer.type = BUFFER_TYPE$3.UNIFORM_BUFFER;
        this.autoManage = true;
      }
    }
  }
  UniformGroup2.prototype.update = function() {
    this.dirtyId++;
    if (!this.autoManage && this.buffer) {
      this.buffer.update();
    }
  };
  UniformGroup2.prototype.add = function(name2, uniforms, _static) {
    if (!this.ubo) {
      this.uniforms[name2] = new UniformGroup2(uniforms, _static);
    } else {
      throw new Error("[UniformGroup] uniform groups in ubo mode cannot be modified, or have uniform groups nested in them");
    }
  };
  UniformGroup2.from = function(uniforms, _static, _ubo) {
    return new UniformGroup2(uniforms, _static, _ubo);
  };
  UniformGroup2.uboFrom = function(uniforms, _static) {
    return new UniformGroup2(uniforms, _static !== null && _static !== void 0 ? _static : true, true);
  };
  return UniformGroup2;
}();
var FilterState = function() {
  function FilterState2() {
    this.renderTexture = null;
    this.target = null;
    this.legacy = false;
    this.resolution = 1;
    this.multisample = MSAA_QUALITY$3.NONE;
    this.sourceFrame = new Rectangle();
    this.destinationFrame = new Rectangle();
    this.bindingSourceFrame = new Rectangle();
    this.bindingDestinationFrame = new Rectangle();
    this.filters = [];
    this.transform = null;
  }
  FilterState2.prototype.clear = function() {
    this.target = null;
    this.filters = null;
    this.renderTexture = null;
  };
  return FilterState2;
}();
var tempPoints = [new Point(), new Point(), new Point(), new Point()];
var tempMatrix = new Matrix();
var FilterSystem = function() {
  function FilterSystem2(renderer) {
    this.renderer = renderer;
    this.defaultFilterStack = [{}];
    this.texturePool = new RenderTexturePool();
    this.texturePool.setScreenSize(renderer.view);
    this.statePool = [];
    this.quad = new Quad();
    this.quadUv = new QuadUv();
    this.tempRect = new Rectangle();
    this.activeState = {};
    this.globalUniforms = new UniformGroup({
      outputFrame: new Rectangle(),
      inputSize: new Float32Array(4),
      inputPixel: new Float32Array(4),
      inputClamp: new Float32Array(4),
      resolution: 1,
      filterArea: new Float32Array(4),
      filterClamp: new Float32Array(4)
    }, true);
    this.forceClear = false;
    this.useMaxPadding = false;
  }
  FilterSystem2.prototype.push = function(target, filters) {
    var _a3, _b3;
    var renderer = this.renderer;
    var filterStack = this.defaultFilterStack;
    var state = this.statePool.pop() || new FilterState();
    var renderTextureSystem = this.renderer.renderTexture;
    var resolution = filters[0].resolution;
    var multisample = filters[0].multisample;
    var padding = filters[0].padding;
    var autoFit = filters[0].autoFit;
    var legacy = (_a3 = filters[0].legacy) !== null && _a3 !== void 0 ? _a3 : true;
    for (var i2 = 1; i2 < filters.length; i2++) {
      var filter = filters[i2];
      resolution = Math.min(resolution, filter.resolution);
      multisample = Math.min(multisample, filter.multisample);
      padding = this.useMaxPadding ? Math.max(padding, filter.padding) : padding + filter.padding;
      autoFit = autoFit && filter.autoFit;
      legacy = legacy || ((_b3 = filter.legacy) !== null && _b3 !== void 0 ? _b3 : true);
    }
    if (filterStack.length === 1) {
      this.defaultFilterStack[0].renderTexture = renderTextureSystem.current;
    }
    filterStack.push(state);
    state.resolution = resolution;
    state.multisample = multisample;
    state.legacy = legacy;
    state.target = target;
    state.sourceFrame.copyFrom(target.filterArea || target.getBounds(true));
    state.sourceFrame.pad(padding);
    if (autoFit) {
      var sourceFrameProjected = this.tempRect.copyFrom(renderTextureSystem.sourceFrame);
      if (renderer.projection.transform) {
        this.transformAABB(tempMatrix.copyFrom(renderer.projection.transform).invert(), sourceFrameProjected);
      }
      state.sourceFrame.fit(sourceFrameProjected);
    }
    this.roundFrame(state.sourceFrame, renderTextureSystem.current ? renderTextureSystem.current.resolution : renderer.resolution, renderTextureSystem.sourceFrame, renderTextureSystem.destinationFrame, renderer.projection.transform);
    state.renderTexture = this.getOptimalFilterTexture(state.sourceFrame.width, state.sourceFrame.height, resolution, multisample);
    state.filters = filters;
    state.destinationFrame.width = state.renderTexture.width;
    state.destinationFrame.height = state.renderTexture.height;
    var destinationFrame = this.tempRect;
    destinationFrame.x = 0;
    destinationFrame.y = 0;
    destinationFrame.width = state.sourceFrame.width;
    destinationFrame.height = state.sourceFrame.height;
    state.renderTexture.filterFrame = state.sourceFrame;
    state.bindingSourceFrame.copyFrom(renderTextureSystem.sourceFrame);
    state.bindingDestinationFrame.copyFrom(renderTextureSystem.destinationFrame);
    state.transform = renderer.projection.transform;
    renderer.projection.transform = null;
    renderTextureSystem.bind(state.renderTexture, state.sourceFrame, destinationFrame);
    renderer.framebuffer.clear(0, 0, 0, 0);
  };
  FilterSystem2.prototype.pop = function() {
    var filterStack = this.defaultFilterStack;
    var state = filterStack.pop();
    var filters = state.filters;
    this.activeState = state;
    var globalUniforms = this.globalUniforms.uniforms;
    globalUniforms.outputFrame = state.sourceFrame;
    globalUniforms.resolution = state.resolution;
    var inputSize = globalUniforms.inputSize;
    var inputPixel = globalUniforms.inputPixel;
    var inputClamp = globalUniforms.inputClamp;
    inputSize[0] = state.destinationFrame.width;
    inputSize[1] = state.destinationFrame.height;
    inputSize[2] = 1 / inputSize[0];
    inputSize[3] = 1 / inputSize[1];
    inputPixel[0] = Math.round(inputSize[0] * state.resolution);
    inputPixel[1] = Math.round(inputSize[1] * state.resolution);
    inputPixel[2] = 1 / inputPixel[0];
    inputPixel[3] = 1 / inputPixel[1];
    inputClamp[0] = 0.5 * inputPixel[2];
    inputClamp[1] = 0.5 * inputPixel[3];
    inputClamp[2] = state.sourceFrame.width * inputSize[2] - 0.5 * inputPixel[2];
    inputClamp[3] = state.sourceFrame.height * inputSize[3] - 0.5 * inputPixel[3];
    if (state.legacy) {
      var filterArea = globalUniforms.filterArea;
      filterArea[0] = state.destinationFrame.width;
      filterArea[1] = state.destinationFrame.height;
      filterArea[2] = state.sourceFrame.x;
      filterArea[3] = state.sourceFrame.y;
      globalUniforms.filterClamp = globalUniforms.inputClamp;
    }
    this.globalUniforms.update();
    var lastState = filterStack[filterStack.length - 1];
    this.renderer.framebuffer.blit();
    if (filters.length === 1) {
      filters[0].apply(this, state.renderTexture, lastState.renderTexture, CLEAR_MODES$3.BLEND, state);
      this.returnFilterTexture(state.renderTexture);
    } else {
      var flip = state.renderTexture;
      var flop = this.getOptimalFilterTexture(flip.width, flip.height, state.resolution);
      flop.filterFrame = flip.filterFrame;
      var i2 = 0;
      for (i2 = 0; i2 < filters.length - 1; ++i2) {
        if (i2 === 1 && state.multisample > 1) {
          flop = this.getOptimalFilterTexture(flip.width, flip.height, state.resolution);
          flop.filterFrame = flip.filterFrame;
        }
        filters[i2].apply(this, flip, flop, CLEAR_MODES$3.CLEAR, state);
        var t = flip;
        flip = flop;
        flop = t;
      }
      filters[i2].apply(this, flip, lastState.renderTexture, CLEAR_MODES$3.BLEND, state);
      if (i2 > 1 && state.multisample > 1) {
        this.returnFilterTexture(state.renderTexture);
      }
      this.returnFilterTexture(flip);
      this.returnFilterTexture(flop);
    }
    state.clear();
    this.statePool.push(state);
  };
  FilterSystem2.prototype.bindAndClear = function(filterTexture, clearMode) {
    if (clearMode === void 0) {
      clearMode = CLEAR_MODES$3.CLEAR;
    }
    var _a3 = this.renderer, renderTextureSystem = _a3.renderTexture, stateSystem = _a3.state;
    if (filterTexture === this.defaultFilterStack[this.defaultFilterStack.length - 1].renderTexture) {
      this.renderer.projection.transform = this.activeState.transform;
    } else {
      this.renderer.projection.transform = null;
    }
    if (filterTexture && filterTexture.filterFrame) {
      var destinationFrame = this.tempRect;
      destinationFrame.x = 0;
      destinationFrame.y = 0;
      destinationFrame.width = filterTexture.filterFrame.width;
      destinationFrame.height = filterTexture.filterFrame.height;
      renderTextureSystem.bind(filterTexture, filterTexture.filterFrame, destinationFrame);
    } else if (filterTexture !== this.defaultFilterStack[this.defaultFilterStack.length - 1].renderTexture) {
      renderTextureSystem.bind(filterTexture);
    } else {
      this.renderer.renderTexture.bind(filterTexture, this.activeState.bindingSourceFrame, this.activeState.bindingDestinationFrame);
    }
    var autoClear = stateSystem.stateId & 1 || this.forceClear;
    if (clearMode === CLEAR_MODES$3.CLEAR || clearMode === CLEAR_MODES$3.BLIT && autoClear) {
      this.renderer.framebuffer.clear(0, 0, 0, 0);
    }
  };
  FilterSystem2.prototype.applyFilter = function(filter, input, output, clearMode) {
    var renderer = this.renderer;
    renderer.state.set(filter.state);
    this.bindAndClear(output, clearMode);
    filter.uniforms.uSampler = input;
    filter.uniforms.filterGlobals = this.globalUniforms;
    renderer.shader.bind(filter);
    filter.legacy = !!filter.program.attributeData.aTextureCoord;
    if (filter.legacy) {
      this.quadUv.map(input._frame, input.filterFrame);
      renderer.geometry.bind(this.quadUv);
      renderer.geometry.draw(DRAW_MODES$3.TRIANGLES);
    } else {
      renderer.geometry.bind(this.quad);
      renderer.geometry.draw(DRAW_MODES$3.TRIANGLE_STRIP);
    }
  };
  FilterSystem2.prototype.calculateSpriteMatrix = function(outputMatrix, sprite) {
    var _a3 = this.activeState, sourceFrame = _a3.sourceFrame, destinationFrame = _a3.destinationFrame;
    var orig = sprite._texture.orig;
    var mappedMatrix = outputMatrix.set(destinationFrame.width, 0, 0, destinationFrame.height, sourceFrame.x, sourceFrame.y);
    var worldTransform = sprite.worldTransform.copyTo(Matrix.TEMP_MATRIX);
    worldTransform.invert();
    mappedMatrix.prepend(worldTransform);
    mappedMatrix.scale(1 / orig.width, 1 / orig.height);
    mappedMatrix.translate(sprite.anchor.x, sprite.anchor.y);
    return mappedMatrix;
  };
  FilterSystem2.prototype.destroy = function() {
    this.renderer = null;
    this.texturePool.clear(false);
  };
  FilterSystem2.prototype.getOptimalFilterTexture = function(minWidth, minHeight, resolution, multisample) {
    if (resolution === void 0) {
      resolution = 1;
    }
    if (multisample === void 0) {
      multisample = MSAA_QUALITY$3.NONE;
    }
    return this.texturePool.getOptimalTexture(minWidth, minHeight, resolution, multisample);
  };
  FilterSystem2.prototype.getFilterTexture = function(input, resolution, multisample) {
    if (typeof input === "number") {
      var swap2 = input;
      input = resolution;
      resolution = swap2;
    }
    input = input || this.activeState.renderTexture;
    var filterTexture = this.texturePool.getOptimalTexture(input.width, input.height, resolution || input.resolution, multisample || MSAA_QUALITY$3.NONE);
    filterTexture.filterFrame = input.filterFrame;
    return filterTexture;
  };
  FilterSystem2.prototype.returnFilterTexture = function(renderTexture) {
    this.texturePool.returnTexture(renderTexture);
  };
  FilterSystem2.prototype.emptyPool = function() {
    this.texturePool.clear(true);
  };
  FilterSystem2.prototype.resize = function() {
    this.texturePool.setScreenSize(this.renderer.view);
  };
  FilterSystem2.prototype.transformAABB = function(matrix, rect) {
    var lt = tempPoints[0];
    var lb = tempPoints[1];
    var rt = tempPoints[2];
    var rb = tempPoints[3];
    lt.set(rect.left, rect.top);
    lb.set(rect.left, rect.bottom);
    rt.set(rect.right, rect.top);
    rb.set(rect.right, rect.bottom);
    matrix.apply(lt, lt);
    matrix.apply(lb, lb);
    matrix.apply(rt, rt);
    matrix.apply(rb, rb);
    var x0 = Math.min(lt.x, lb.x, rt.x, rb.x);
    var y0 = Math.min(lt.y, lb.y, rt.y, rb.y);
    var x1 = Math.max(lt.x, lb.x, rt.x, rb.x);
    var y1 = Math.max(lt.y, lb.y, rt.y, rb.y);
    rect.x = x0;
    rect.y = y0;
    rect.width = x1 - x0;
    rect.height = y1 - y0;
  };
  FilterSystem2.prototype.roundFrame = function(frame, resolution, bindingSourceFrame, bindingDestinationFrame, transform) {
    if (frame.width <= 0 || frame.height <= 0 || bindingSourceFrame.width <= 0 || bindingSourceFrame.height <= 0) {
      return;
    }
    if (transform) {
      var a2 = transform.a, b2 = transform.b, c2 = transform.c, d2 = transform.d;
      if ((Math.abs(b2) > 1e-4 || Math.abs(c2) > 1e-4) && (Math.abs(a2) > 1e-4 || Math.abs(d2) > 1e-4)) {
        return;
      }
    }
    transform = transform ? tempMatrix.copyFrom(transform) : tempMatrix.identity();
    transform.translate(-bindingSourceFrame.x, -bindingSourceFrame.y).scale(bindingDestinationFrame.width / bindingSourceFrame.width, bindingDestinationFrame.height / bindingSourceFrame.height).translate(bindingDestinationFrame.x, bindingDestinationFrame.y);
    this.transformAABB(transform, frame);
    frame.ceil(resolution);
    this.transformAABB(transform.invert(), frame);
  };
  return FilterSystem2;
}();
var ObjectRenderer = function() {
  function ObjectRenderer2(renderer) {
    this.renderer = renderer;
  }
  ObjectRenderer2.prototype.flush = function() {
  };
  ObjectRenderer2.prototype.destroy = function() {
    this.renderer = null;
  };
  ObjectRenderer2.prototype.start = function() {
  };
  ObjectRenderer2.prototype.stop = function() {
    this.flush();
  };
  ObjectRenderer2.prototype.render = function(_object) {
  };
  return ObjectRenderer2;
}();
var BatchSystem = function() {
  function BatchSystem2(renderer) {
    this.renderer = renderer;
    this.emptyRenderer = new ObjectRenderer(renderer);
    this.currentRenderer = this.emptyRenderer;
  }
  BatchSystem2.prototype.setObjectRenderer = function(objectRenderer) {
    if (this.currentRenderer === objectRenderer) {
      return;
    }
    this.currentRenderer.stop();
    this.currentRenderer = objectRenderer;
    this.currentRenderer.start();
  };
  BatchSystem2.prototype.flush = function() {
    this.setObjectRenderer(this.emptyRenderer);
  };
  BatchSystem2.prototype.reset = function() {
    this.setObjectRenderer(this.emptyRenderer);
  };
  BatchSystem2.prototype.copyBoundTextures = function(arr, maxTextures) {
    var boundTextures = this.renderer.texture.boundTextures;
    for (var i2 = maxTextures - 1; i2 >= 0; --i2) {
      arr[i2] = boundTextures[i2] || null;
      if (arr[i2]) {
        arr[i2]._batchLocation = i2;
      }
    }
  };
  BatchSystem2.prototype.boundArray = function(texArray, boundTextures, batchId, maxTextures) {
    var elements = texArray.elements, ids = texArray.ids, count = texArray.count;
    var j2 = 0;
    for (var i2 = 0; i2 < count; i2++) {
      var tex = elements[i2];
      var loc = tex._batchLocation;
      if (loc >= 0 && loc < maxTextures && boundTextures[loc] === tex) {
        ids[i2] = loc;
        continue;
      }
      while (j2 < maxTextures) {
        var bound = boundTextures[j2];
        if (bound && bound._batchEnabled === batchId && bound._batchLocation === j2) {
          j2++;
          continue;
        }
        ids[i2] = j2;
        tex._batchLocation = j2;
        boundTextures[j2] = tex;
        break;
      }
    }
  };
  BatchSystem2.prototype.destroy = function() {
    this.renderer = null;
  };
  return BatchSystem2;
}();
var CONTEXT_UID_COUNTER = 0;
var ContextSystem = function() {
  function ContextSystem2(renderer) {
    this.renderer = renderer;
    this.webGLVersion = 1;
    this.extensions = {};
    this.supports = {
      uint32Indices: false
    };
    this.handleContextLost = this.handleContextLost.bind(this);
    this.handleContextRestored = this.handleContextRestored.bind(this);
    renderer.view.addEventListener("webglcontextlost", this.handleContextLost, false);
    renderer.view.addEventListener("webglcontextrestored", this.handleContextRestored, false);
  }
  Object.defineProperty(ContextSystem2.prototype, "isLost", {
    get: function() {
      return !this.gl || this.gl.isContextLost();
    },
    enumerable: false,
    configurable: true
  });
  ContextSystem2.prototype.contextChange = function(gl) {
    this.gl = gl;
    this.renderer.gl = gl;
    this.renderer.CONTEXT_UID = CONTEXT_UID_COUNTER++;
    if (gl.isContextLost() && gl.getExtension("WEBGL_lose_context")) {
      gl.getExtension("WEBGL_lose_context").restoreContext();
    }
  };
  ContextSystem2.prototype.initFromContext = function(gl) {
    this.gl = gl;
    this.validateContext(gl);
    this.renderer.gl = gl;
    this.renderer.CONTEXT_UID = CONTEXT_UID_COUNTER++;
    this.renderer.runners.contextChange.emit(gl);
  };
  ContextSystem2.prototype.initFromOptions = function(options) {
    var gl = this.createContext(this.renderer.view, options);
    this.initFromContext(gl);
  };
  ContextSystem2.prototype.createContext = function(canvas2, options) {
    var gl;
    if (settings.PREFER_ENV >= ENV$3.WEBGL2) {
      gl = canvas2.getContext("webgl2", options);
    }
    if (gl) {
      this.webGLVersion = 2;
    } else {
      this.webGLVersion = 1;
      gl = canvas2.getContext("webgl", options) || canvas2.getContext("experimental-webgl", options);
      if (!gl) {
        throw new Error("This browser does not support WebGL. Try using the canvas renderer");
      }
    }
    this.gl = gl;
    this.getExtensions();
    return this.gl;
  };
  ContextSystem2.prototype.getExtensions = function() {
    var gl = this.gl;
    var common = {
      anisotropicFiltering: gl.getExtension("EXT_texture_filter_anisotropic"),
      floatTextureLinear: gl.getExtension("OES_texture_float_linear"),
      s3tc: gl.getExtension("WEBGL_compressed_texture_s3tc"),
      s3tc_sRGB: gl.getExtension("WEBGL_compressed_texture_s3tc_srgb"),
      etc: gl.getExtension("WEBGL_compressed_texture_etc"),
      etc1: gl.getExtension("WEBGL_compressed_texture_etc1"),
      pvrtc: gl.getExtension("WEBGL_compressed_texture_pvrtc") || gl.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc"),
      atc: gl.getExtension("WEBGL_compressed_texture_atc"),
      astc: gl.getExtension("WEBGL_compressed_texture_astc")
    };
    if (this.webGLVersion === 1) {
      Object.assign(this.extensions, common, {
        drawBuffers: gl.getExtension("WEBGL_draw_buffers"),
        depthTexture: gl.getExtension("WEBGL_depth_texture"),
        loseContext: gl.getExtension("WEBGL_lose_context"),
        vertexArrayObject: gl.getExtension("OES_vertex_array_object") || gl.getExtension("MOZ_OES_vertex_array_object") || gl.getExtension("WEBKIT_OES_vertex_array_object"),
        uint32ElementIndex: gl.getExtension("OES_element_index_uint"),
        floatTexture: gl.getExtension("OES_texture_float"),
        floatTextureLinear: gl.getExtension("OES_texture_float_linear"),
        textureHalfFloat: gl.getExtension("OES_texture_half_float"),
        textureHalfFloatLinear: gl.getExtension("OES_texture_half_float_linear")
      });
    } else if (this.webGLVersion === 2) {
      Object.assign(this.extensions, common, {
        colorBufferFloat: gl.getExtension("EXT_color_buffer_float")
      });
    }
  };
  ContextSystem2.prototype.handleContextLost = function(event) {
    event.preventDefault();
  };
  ContextSystem2.prototype.handleContextRestored = function() {
    this.renderer.runners.contextChange.emit(this.gl);
  };
  ContextSystem2.prototype.destroy = function() {
    var view = this.renderer.view;
    this.renderer = null;
    view.removeEventListener("webglcontextlost", this.handleContextLost);
    view.removeEventListener("webglcontextrestored", this.handleContextRestored);
    this.gl.useProgram(null);
    if (this.extensions.loseContext) {
      this.extensions.loseContext.loseContext();
    }
  };
  ContextSystem2.prototype.postrender = function() {
    if (this.renderer.renderingToScreen) {
      this.gl.flush();
    }
  };
  ContextSystem2.prototype.validateContext = function(gl) {
    var attributes = gl.getContextAttributes();
    var isWebGl2 = "WebGL2RenderingContext" in globalThis && gl instanceof globalThis.WebGL2RenderingContext;
    if (isWebGl2) {
      this.webGLVersion = 2;
    }
    if (!attributes.stencil) {
      console.warn("Provided WebGL context does not have a stencil buffer, masks may not render correctly");
    }
    var hasuint32 = isWebGl2 || !!gl.getExtension("OES_element_index_uint");
    this.supports.uint32Indices = hasuint32;
    if (!hasuint32) {
      console.warn("Provided WebGL context does not support 32 index buffer, complex graphics may not render correctly");
    }
  };
  return ContextSystem2;
}();
var GLFramebuffer = function() {
  function GLFramebuffer2(framebuffer) {
    this.framebuffer = framebuffer;
    this.stencil = null;
    this.dirtyId = -1;
    this.dirtyFormat = -1;
    this.dirtySize = -1;
    this.multisample = MSAA_QUALITY$3.NONE;
    this.msaaBuffer = null;
    this.blitFramebuffer = null;
    this.mipLevel = 0;
  }
  return GLFramebuffer2;
}();
var tempRectangle = new Rectangle();
var FramebufferSystem = function() {
  function FramebufferSystem2(renderer) {
    this.renderer = renderer;
    this.managedFramebuffers = [];
    this.unknownFramebuffer = new Framebuffer(10, 10);
    this.msaaSamples = null;
  }
  FramebufferSystem2.prototype.contextChange = function() {
    var gl = this.gl = this.renderer.gl;
    this.CONTEXT_UID = this.renderer.CONTEXT_UID;
    this.current = this.unknownFramebuffer;
    this.viewport = new Rectangle();
    this.hasMRT = true;
    this.writeDepthTexture = true;
    this.disposeAll(true);
    if (this.renderer.context.webGLVersion === 1) {
      var nativeDrawBuffersExtension_1 = this.renderer.context.extensions.drawBuffers;
      var nativeDepthTextureExtension = this.renderer.context.extensions.depthTexture;
      if (settings.PREFER_ENV === ENV$3.WEBGL_LEGACY) {
        nativeDrawBuffersExtension_1 = null;
        nativeDepthTextureExtension = null;
      }
      if (nativeDrawBuffersExtension_1) {
        gl.drawBuffers = function(activeTextures) {
          return nativeDrawBuffersExtension_1.drawBuffersWEBGL(activeTextures);
        };
      } else {
        this.hasMRT = false;
        gl.drawBuffers = function() {
        };
      }
      if (!nativeDepthTextureExtension) {
        this.writeDepthTexture = false;
      }
    } else {
      this.msaaSamples = gl.getInternalformatParameter(gl.RENDERBUFFER, gl.RGBA8, gl.SAMPLES);
    }
  };
  FramebufferSystem2.prototype.bind = function(framebuffer, frame, mipLevel) {
    if (mipLevel === void 0) {
      mipLevel = 0;
    }
    var gl = this.gl;
    if (framebuffer) {
      var fbo = framebuffer.glFramebuffers[this.CONTEXT_UID] || this.initFramebuffer(framebuffer);
      if (this.current !== framebuffer) {
        this.current = framebuffer;
        gl.bindFramebuffer(gl.FRAMEBUFFER, fbo.framebuffer);
      }
      if (fbo.mipLevel !== mipLevel) {
        framebuffer.dirtyId++;
        framebuffer.dirtyFormat++;
        fbo.mipLevel = mipLevel;
      }
      if (fbo.dirtyId !== framebuffer.dirtyId) {
        fbo.dirtyId = framebuffer.dirtyId;
        if (fbo.dirtyFormat !== framebuffer.dirtyFormat) {
          fbo.dirtyFormat = framebuffer.dirtyFormat;
          fbo.dirtySize = framebuffer.dirtySize;
          this.updateFramebuffer(framebuffer, mipLevel);
        } else if (fbo.dirtySize !== framebuffer.dirtySize) {
          fbo.dirtySize = framebuffer.dirtySize;
          this.resizeFramebuffer(framebuffer);
        }
      }
      for (var i2 = 0; i2 < framebuffer.colorTextures.length; i2++) {
        var tex = framebuffer.colorTextures[i2];
        this.renderer.texture.unbind(tex.parentTextureArray || tex);
      }
      if (framebuffer.depthTexture) {
        this.renderer.texture.unbind(framebuffer.depthTexture);
      }
      if (frame) {
        var mipWidth = frame.width >> mipLevel;
        var mipHeight = frame.height >> mipLevel;
        var scale = mipWidth / frame.width;
        this.setViewport(frame.x * scale, frame.y * scale, mipWidth, mipHeight);
      } else {
        var mipWidth = framebuffer.width >> mipLevel;
        var mipHeight = framebuffer.height >> mipLevel;
        this.setViewport(0, 0, mipWidth, mipHeight);
      }
    } else {
      if (this.current) {
        this.current = null;
        gl.bindFramebuffer(gl.FRAMEBUFFER, null);
      }
      if (frame) {
        this.setViewport(frame.x, frame.y, frame.width, frame.height);
      } else {
        this.setViewport(0, 0, this.renderer.width, this.renderer.height);
      }
    }
  };
  FramebufferSystem2.prototype.setViewport = function(x2, y2, width, height) {
    var v2 = this.viewport;
    x2 = Math.round(x2);
    y2 = Math.round(y2);
    width = Math.round(width);
    height = Math.round(height);
    if (v2.width !== width || v2.height !== height || v2.x !== x2 || v2.y !== y2) {
      v2.x = x2;
      v2.y = y2;
      v2.width = width;
      v2.height = height;
      this.gl.viewport(x2, y2, width, height);
    }
  };
  Object.defineProperty(FramebufferSystem2.prototype, "size", {
    get: function() {
      if (this.current) {
        return { x: 0, y: 0, width: this.current.width, height: this.current.height };
      }
      return { x: 0, y: 0, width: this.renderer.width, height: this.renderer.height };
    },
    enumerable: false,
    configurable: true
  });
  FramebufferSystem2.prototype.clear = function(r2, g2, b2, a2, mask) {
    if (mask === void 0) {
      mask = BUFFER_BITS$3.COLOR | BUFFER_BITS$3.DEPTH;
    }
    var gl = this.gl;
    gl.clearColor(r2, g2, b2, a2);
    gl.clear(mask);
  };
  FramebufferSystem2.prototype.initFramebuffer = function(framebuffer) {
    var gl = this.gl;
    var fbo = new GLFramebuffer(gl.createFramebuffer());
    fbo.multisample = this.detectSamples(framebuffer.multisample);
    framebuffer.glFramebuffers[this.CONTEXT_UID] = fbo;
    this.managedFramebuffers.push(framebuffer);
    framebuffer.disposeRunner.add(this);
    return fbo;
  };
  FramebufferSystem2.prototype.resizeFramebuffer = function(framebuffer) {
    var gl = this.gl;
    var fbo = framebuffer.glFramebuffers[this.CONTEXT_UID];
    if (fbo.msaaBuffer) {
      gl.bindRenderbuffer(gl.RENDERBUFFER, fbo.msaaBuffer);
      gl.renderbufferStorageMultisample(gl.RENDERBUFFER, fbo.multisample, gl.RGBA8, framebuffer.width, framebuffer.height);
    }
    if (fbo.stencil) {
      gl.bindRenderbuffer(gl.RENDERBUFFER, fbo.stencil);
      if (fbo.msaaBuffer) {
        gl.renderbufferStorageMultisample(gl.RENDERBUFFER, fbo.multisample, gl.DEPTH24_STENCIL8, framebuffer.width, framebuffer.height);
      } else {
        gl.renderbufferStorage(gl.RENDERBUFFER, gl.DEPTH_STENCIL, framebuffer.width, framebuffer.height);
      }
    }
    var colorTextures = framebuffer.colorTextures;
    var count = colorTextures.length;
    if (!gl.drawBuffers) {
      count = Math.min(count, 1);
    }
    for (var i2 = 0; i2 < count; i2++) {
      var texture = colorTextures[i2];
      var parentTexture = texture.parentTextureArray || texture;
      this.renderer.texture.bind(parentTexture, 0);
    }
    if (framebuffer.depthTexture && this.writeDepthTexture) {
      this.renderer.texture.bind(framebuffer.depthTexture, 0);
    }
  };
  FramebufferSystem2.prototype.updateFramebuffer = function(framebuffer, mipLevel) {
    var gl = this.gl;
    var fbo = framebuffer.glFramebuffers[this.CONTEXT_UID];
    var colorTextures = framebuffer.colorTextures;
    var count = colorTextures.length;
    if (!gl.drawBuffers) {
      count = Math.min(count, 1);
    }
    if (fbo.multisample > 1 && this.canMultisampleFramebuffer(framebuffer)) {
      fbo.msaaBuffer = fbo.msaaBuffer || gl.createRenderbuffer();
      gl.bindRenderbuffer(gl.RENDERBUFFER, fbo.msaaBuffer);
      gl.renderbufferStorageMultisample(gl.RENDERBUFFER, fbo.multisample, gl.RGBA8, framebuffer.width, framebuffer.height);
      gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.RENDERBUFFER, fbo.msaaBuffer);
    } else if (fbo.msaaBuffer) {
      gl.deleteRenderbuffer(fbo.msaaBuffer);
      fbo.msaaBuffer = null;
      if (fbo.blitFramebuffer) {
        fbo.blitFramebuffer.dispose();
        fbo.blitFramebuffer = null;
      }
    }
    var activeTextures = [];
    for (var i2 = 0; i2 < count; i2++) {
      var texture = colorTextures[i2];
      var parentTexture = texture.parentTextureArray || texture;
      this.renderer.texture.bind(parentTexture, 0);
      if (i2 === 0 && fbo.msaaBuffer) {
        continue;
      }
      gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0 + i2, texture.target, parentTexture._glTextures[this.CONTEXT_UID].texture, mipLevel);
      activeTextures.push(gl.COLOR_ATTACHMENT0 + i2);
    }
    if (activeTextures.length > 1) {
      gl.drawBuffers(activeTextures);
    }
    if (framebuffer.depthTexture) {
      var writeDepthTexture = this.writeDepthTexture;
      if (writeDepthTexture) {
        var depthTexture = framebuffer.depthTexture;
        this.renderer.texture.bind(depthTexture, 0);
        gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT, gl.TEXTURE_2D, depthTexture._glTextures[this.CONTEXT_UID].texture, mipLevel);
      }
    }
    if ((framebuffer.stencil || framebuffer.depth) && !(framebuffer.depthTexture && this.writeDepthTexture)) {
      fbo.stencil = fbo.stencil || gl.createRenderbuffer();
      gl.bindRenderbuffer(gl.RENDERBUFFER, fbo.stencil);
      if (fbo.msaaBuffer) {
        gl.renderbufferStorageMultisample(gl.RENDERBUFFER, fbo.multisample, gl.DEPTH24_STENCIL8, framebuffer.width, framebuffer.height);
      } else {
        gl.renderbufferStorage(gl.RENDERBUFFER, gl.DEPTH_STENCIL, framebuffer.width, framebuffer.height);
      }
      gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_STENCIL_ATTACHMENT, gl.RENDERBUFFER, fbo.stencil);
    } else if (fbo.stencil) {
      gl.deleteRenderbuffer(fbo.stencil);
      fbo.stencil = null;
    }
  };
  FramebufferSystem2.prototype.canMultisampleFramebuffer = function(framebuffer) {
    return this.renderer.context.webGLVersion !== 1 && framebuffer.colorTextures.length <= 1 && !framebuffer.depthTexture;
  };
  FramebufferSystem2.prototype.detectSamples = function(samples) {
    var msaaSamples = this.msaaSamples;
    var res = MSAA_QUALITY$3.NONE;
    if (samples <= 1 || msaaSamples === null) {
      return res;
    }
    for (var i2 = 0; i2 < msaaSamples.length; i2++) {
      if (msaaSamples[i2] <= samples) {
        res = msaaSamples[i2];
        break;
      }
    }
    if (res === 1) {
      res = MSAA_QUALITY$3.NONE;
    }
    return res;
  };
  FramebufferSystem2.prototype.blit = function(framebuffer, sourcePixels, destPixels) {
    var _a3 = this, current = _a3.current, renderer = _a3.renderer, gl = _a3.gl, CONTEXT_UID = _a3.CONTEXT_UID;
    if (renderer.context.webGLVersion !== 2) {
      return;
    }
    if (!current) {
      return;
    }
    var fbo = current.glFramebuffers[CONTEXT_UID];
    if (!fbo) {
      return;
    }
    if (!framebuffer) {
      if (!fbo.msaaBuffer) {
        return;
      }
      var colorTexture = current.colorTextures[0];
      if (!colorTexture) {
        return;
      }
      if (!fbo.blitFramebuffer) {
        fbo.blitFramebuffer = new Framebuffer(current.width, current.height);
        fbo.blitFramebuffer.addColorTexture(0, colorTexture);
      }
      framebuffer = fbo.blitFramebuffer;
      if (framebuffer.colorTextures[0] !== colorTexture) {
        framebuffer.colorTextures[0] = colorTexture;
        framebuffer.dirtyId++;
        framebuffer.dirtyFormat++;
      }
      if (framebuffer.width !== current.width || framebuffer.height !== current.height) {
        framebuffer.width = current.width;
        framebuffer.height = current.height;
        framebuffer.dirtyId++;
        framebuffer.dirtySize++;
      }
    }
    if (!sourcePixels) {
      sourcePixels = tempRectangle;
      sourcePixels.width = current.width;
      sourcePixels.height = current.height;
    }
    if (!destPixels) {
      destPixels = sourcePixels;
    }
    var sameSize = sourcePixels.width === destPixels.width && sourcePixels.height === destPixels.height;
    this.bind(framebuffer);
    gl.bindFramebuffer(gl.READ_FRAMEBUFFER, fbo.framebuffer);
    gl.blitFramebuffer(sourcePixels.left, sourcePixels.top, sourcePixels.right, sourcePixels.bottom, destPixels.left, destPixels.top, destPixels.right, destPixels.bottom, gl.COLOR_BUFFER_BIT, sameSize ? gl.NEAREST : gl.LINEAR);
  };
  FramebufferSystem2.prototype.disposeFramebuffer = function(framebuffer, contextLost) {
    var fbo = framebuffer.glFramebuffers[this.CONTEXT_UID];
    var gl = this.gl;
    if (!fbo) {
      return;
    }
    delete framebuffer.glFramebuffers[this.CONTEXT_UID];
    var index = this.managedFramebuffers.indexOf(framebuffer);
    if (index >= 0) {
      this.managedFramebuffers.splice(index, 1);
    }
    framebuffer.disposeRunner.remove(this);
    if (!contextLost) {
      gl.deleteFramebuffer(fbo.framebuffer);
      if (fbo.msaaBuffer) {
        gl.deleteRenderbuffer(fbo.msaaBuffer);
      }
      if (fbo.stencil) {
        gl.deleteRenderbuffer(fbo.stencil);
      }
    }
    if (fbo.blitFramebuffer) {
      fbo.blitFramebuffer.dispose();
    }
  };
  FramebufferSystem2.prototype.disposeAll = function(contextLost) {
    var list = this.managedFramebuffers;
    this.managedFramebuffers = [];
    for (var i2 = 0; i2 < list.length; i2++) {
      this.disposeFramebuffer(list[i2], contextLost);
    }
  };
  FramebufferSystem2.prototype.forceStencil = function() {
    var framebuffer = this.current;
    if (!framebuffer) {
      return;
    }
    var fbo = framebuffer.glFramebuffers[this.CONTEXT_UID];
    if (!fbo || fbo.stencil) {
      return;
    }
    framebuffer.stencil = true;
    var w2 = framebuffer.width;
    var h2 = framebuffer.height;
    var gl = this.gl;
    var stencil = gl.createRenderbuffer();
    gl.bindRenderbuffer(gl.RENDERBUFFER, stencil);
    if (fbo.msaaBuffer) {
      gl.renderbufferStorageMultisample(gl.RENDERBUFFER, fbo.multisample, gl.DEPTH24_STENCIL8, w2, h2);
    } else {
      gl.renderbufferStorage(gl.RENDERBUFFER, gl.DEPTH_STENCIL, w2, h2);
    }
    fbo.stencil = stencil;
    gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_STENCIL_ATTACHMENT, gl.RENDERBUFFER, stencil);
  };
  FramebufferSystem2.prototype.reset = function() {
    this.current = this.unknownFramebuffer;
    this.viewport = new Rectangle();
  };
  FramebufferSystem2.prototype.destroy = function() {
    this.renderer = null;
  };
  return FramebufferSystem2;
}();
var byteSizeMap$1 = { 5126: 4, 5123: 2, 5121: 1 };
var GeometrySystem = function() {
  function GeometrySystem2(renderer) {
    this.renderer = renderer;
    this._activeGeometry = null;
    this._activeVao = null;
    this.hasVao = true;
    this.hasInstance = true;
    this.canUseUInt32ElementIndex = false;
    this.managedGeometries = {};
  }
  GeometrySystem2.prototype.contextChange = function() {
    this.disposeAll(true);
    var gl = this.gl = this.renderer.gl;
    var context2 = this.renderer.context;
    this.CONTEXT_UID = this.renderer.CONTEXT_UID;
    if (context2.webGLVersion !== 2) {
      var nativeVaoExtension_1 = this.renderer.context.extensions.vertexArrayObject;
      if (settings.PREFER_ENV === ENV$3.WEBGL_LEGACY) {
        nativeVaoExtension_1 = null;
      }
      if (nativeVaoExtension_1) {
        gl.createVertexArray = function() {
          return nativeVaoExtension_1.createVertexArrayOES();
        };
        gl.bindVertexArray = function(vao) {
          return nativeVaoExtension_1.bindVertexArrayOES(vao);
        };
        gl.deleteVertexArray = function(vao) {
          return nativeVaoExtension_1.deleteVertexArrayOES(vao);
        };
      } else {
        this.hasVao = false;
        gl.createVertexArray = function() {
          return null;
        };
        gl.bindVertexArray = function() {
          return null;
        };
        gl.deleteVertexArray = function() {
          return null;
        };
      }
    }
    if (context2.webGLVersion !== 2) {
      var instanceExt_1 = gl.getExtension("ANGLE_instanced_arrays");
      if (instanceExt_1) {
        gl.vertexAttribDivisor = function(a2, b2) {
          return instanceExt_1.vertexAttribDivisorANGLE(a2, b2);
        };
        gl.drawElementsInstanced = function(a2, b2, c2, d2, e) {
          return instanceExt_1.drawElementsInstancedANGLE(a2, b2, c2, d2, e);
        };
        gl.drawArraysInstanced = function(a2, b2, c2, d2) {
          return instanceExt_1.drawArraysInstancedANGLE(a2, b2, c2, d2);
        };
      } else {
        this.hasInstance = false;
      }
    }
    this.canUseUInt32ElementIndex = context2.webGLVersion === 2 || !!context2.extensions.uint32ElementIndex;
  };
  GeometrySystem2.prototype.bind = function(geometry, shader) {
    shader = shader || this.renderer.shader.shader;
    var gl = this.gl;
    var vaos = geometry.glVertexArrayObjects[this.CONTEXT_UID];
    var incRefCount = false;
    if (!vaos) {
      this.managedGeometries[geometry.id] = geometry;
      geometry.disposeRunner.add(this);
      geometry.glVertexArrayObjects[this.CONTEXT_UID] = vaos = {};
      incRefCount = true;
    }
    var vao = vaos[shader.program.id] || this.initGeometryVao(geometry, shader, incRefCount);
    this._activeGeometry = geometry;
    if (this._activeVao !== vao) {
      this._activeVao = vao;
      if (this.hasVao) {
        gl.bindVertexArray(vao);
      } else {
        this.activateVao(geometry, shader.program);
      }
    }
    this.updateBuffers();
  };
  GeometrySystem2.prototype.reset = function() {
    this.unbind();
  };
  GeometrySystem2.prototype.updateBuffers = function() {
    var geometry = this._activeGeometry;
    var bufferSystem = this.renderer.buffer;
    for (var i2 = 0; i2 < geometry.buffers.length; i2++) {
      var buffer = geometry.buffers[i2];
      bufferSystem.update(buffer);
    }
  };
  GeometrySystem2.prototype.checkCompatibility = function(geometry, program) {
    var geometryAttributes = geometry.attributes;
    var shaderAttributes = program.attributeData;
    for (var j2 in shaderAttributes) {
      if (!geometryAttributes[j2]) {
        throw new Error('shader and geometry incompatible, geometry missing the "' + j2 + '" attribute');
      }
    }
  };
  GeometrySystem2.prototype.getSignature = function(geometry, program) {
    var attribs = geometry.attributes;
    var shaderAttributes = program.attributeData;
    var strings = ["g", geometry.id];
    for (var i2 in attribs) {
      if (shaderAttributes[i2]) {
        strings.push(i2, shaderAttributes[i2].location);
      }
    }
    return strings.join("-");
  };
  GeometrySystem2.prototype.initGeometryVao = function(geometry, shader, incRefCount) {
    if (incRefCount === void 0) {
      incRefCount = true;
    }
    var gl = this.gl;
    var CONTEXT_UID = this.CONTEXT_UID;
    var bufferSystem = this.renderer.buffer;
    var program = shader.program;
    if (!program.glPrograms[CONTEXT_UID]) {
      this.renderer.shader.generateProgram(shader);
    }
    this.checkCompatibility(geometry, program);
    var signature = this.getSignature(geometry, program);
    var vaoObjectHash = geometry.glVertexArrayObjects[this.CONTEXT_UID];
    var vao = vaoObjectHash[signature];
    if (vao) {
      vaoObjectHash[program.id] = vao;
      return vao;
    }
    var buffers = geometry.buffers;
    var attributes = geometry.attributes;
    var tempStride = {};
    var tempStart = {};
    for (var j2 in buffers) {
      tempStride[j2] = 0;
      tempStart[j2] = 0;
    }
    for (var j2 in attributes) {
      if (!attributes[j2].size && program.attributeData[j2]) {
        attributes[j2].size = program.attributeData[j2].size;
      } else if (!attributes[j2].size) {
        console.warn("PIXI Geometry attribute '" + j2 + "' size cannot be determined (likely the bound shader does not have the attribute)");
      }
      tempStride[attributes[j2].buffer] += attributes[j2].size * byteSizeMap$1[attributes[j2].type];
    }
    for (var j2 in attributes) {
      var attribute = attributes[j2];
      var attribSize = attribute.size;
      if (attribute.stride === void 0) {
        if (tempStride[attribute.buffer] === attribSize * byteSizeMap$1[attribute.type]) {
          attribute.stride = 0;
        } else {
          attribute.stride = tempStride[attribute.buffer];
        }
      }
      if (attribute.start === void 0) {
        attribute.start = tempStart[attribute.buffer];
        tempStart[attribute.buffer] += attribSize * byteSizeMap$1[attribute.type];
      }
    }
    vao = gl.createVertexArray();
    gl.bindVertexArray(vao);
    for (var i2 = 0; i2 < buffers.length; i2++) {
      var buffer = buffers[i2];
      bufferSystem.bind(buffer);
      if (incRefCount) {
        buffer._glBuffers[CONTEXT_UID].refCount++;
      }
    }
    this.activateVao(geometry, program);
    this._activeVao = vao;
    vaoObjectHash[program.id] = vao;
    vaoObjectHash[signature] = vao;
    return vao;
  };
  GeometrySystem2.prototype.disposeGeometry = function(geometry, contextLost) {
    var _a3;
    if (!this.managedGeometries[geometry.id]) {
      return;
    }
    delete this.managedGeometries[geometry.id];
    var vaos = geometry.glVertexArrayObjects[this.CONTEXT_UID];
    var gl = this.gl;
    var buffers = geometry.buffers;
    var bufferSystem = (_a3 = this.renderer) === null || _a3 === void 0 ? void 0 : _a3.buffer;
    geometry.disposeRunner.remove(this);
    if (!vaos) {
      return;
    }
    if (bufferSystem) {
      for (var i2 = 0; i2 < buffers.length; i2++) {
        var buf = buffers[i2]._glBuffers[this.CONTEXT_UID];
        if (buf) {
          buf.refCount--;
          if (buf.refCount === 0 && !contextLost) {
            bufferSystem.dispose(buffers[i2], contextLost);
          }
        }
      }
    }
    if (!contextLost) {
      for (var vaoId in vaos) {
        if (vaoId[0] === "g") {
          var vao = vaos[vaoId];
          if (this._activeVao === vao) {
            this.unbind();
          }
          gl.deleteVertexArray(vao);
        }
      }
    }
    delete geometry.glVertexArrayObjects[this.CONTEXT_UID];
  };
  GeometrySystem2.prototype.disposeAll = function(contextLost) {
    var all2 = Object.keys(this.managedGeometries);
    for (var i2 = 0; i2 < all2.length; i2++) {
      this.disposeGeometry(this.managedGeometries[all2[i2]], contextLost);
    }
  };
  GeometrySystem2.prototype.activateVao = function(geometry, program) {
    var gl = this.gl;
    var CONTEXT_UID = this.CONTEXT_UID;
    var bufferSystem = this.renderer.buffer;
    var buffers = geometry.buffers;
    var attributes = geometry.attributes;
    if (geometry.indexBuffer) {
      bufferSystem.bind(geometry.indexBuffer);
    }
    var lastBuffer = null;
    for (var j2 in attributes) {
      var attribute = attributes[j2];
      var buffer = buffers[attribute.buffer];
      var glBuffer = buffer._glBuffers[CONTEXT_UID];
      if (program.attributeData[j2]) {
        if (lastBuffer !== glBuffer) {
          bufferSystem.bind(buffer);
          lastBuffer = glBuffer;
        }
        var location2 = program.attributeData[j2].location;
        gl.enableVertexAttribArray(location2);
        gl.vertexAttribPointer(location2, attribute.size, attribute.type || gl.FLOAT, attribute.normalized, attribute.stride, attribute.start);
        if (attribute.instance) {
          if (this.hasInstance) {
            gl.vertexAttribDivisor(location2, 1);
          } else {
            throw new Error("geometry error, GPU Instancing is not supported on this device");
          }
        }
      }
    }
  };
  GeometrySystem2.prototype.draw = function(type, size, start, instanceCount) {
    var gl = this.gl;
    var geometry = this._activeGeometry;
    if (geometry.indexBuffer) {
      var byteSize = geometry.indexBuffer.data.BYTES_PER_ELEMENT;
      var glType = byteSize === 2 ? gl.UNSIGNED_SHORT : gl.UNSIGNED_INT;
      if (byteSize === 2 || byteSize === 4 && this.canUseUInt32ElementIndex) {
        if (geometry.instanced) {
          gl.drawElementsInstanced(type, size || geometry.indexBuffer.data.length, glType, (start || 0) * byteSize, instanceCount || 1);
        } else {
          gl.drawElements(type, size || geometry.indexBuffer.data.length, glType, (start || 0) * byteSize);
        }
      } else {
        console.warn("unsupported index buffer type: uint32");
      }
    } else if (geometry.instanced) {
      gl.drawArraysInstanced(type, start, size || geometry.getSize(), instanceCount || 1);
    } else {
      gl.drawArrays(type, start, size || geometry.getSize());
    }
    return this;
  };
  GeometrySystem2.prototype.unbind = function() {
    this.gl.bindVertexArray(null);
    this._activeVao = null;
    this._activeGeometry = null;
  };
  GeometrySystem2.prototype.destroy = function() {
    this.renderer = null;
  };
  return GeometrySystem2;
}();
var MaskData = function() {
  function MaskData2(maskObject) {
    if (maskObject === void 0) {
      maskObject = null;
    }
    this.type = MASK_TYPES$3.NONE;
    this.autoDetect = true;
    this.maskObject = maskObject || null;
    this.pooled = false;
    this.isMaskData = true;
    this.resolution = null;
    this.multisample = settings.FILTER_MULTISAMPLE;
    this.enabled = true;
    this._filters = null;
    this._stencilCounter = 0;
    this._scissorCounter = 0;
    this._scissorRect = null;
    this._scissorRectLocal = null;
    this._target = null;
  }
  Object.defineProperty(MaskData2.prototype, "filter", {
    get: function() {
      return this._filters ? this._filters[0] : null;
    },
    set: function(value) {
      if (value) {
        if (this._filters) {
          this._filters[0] = value;
        } else {
          this._filters = [value];
        }
      } else {
        this._filters = null;
      }
    },
    enumerable: false,
    configurable: true
  });
  MaskData2.prototype.reset = function() {
    if (this.pooled) {
      this.maskObject = null;
      this.type = MASK_TYPES$3.NONE;
      this.autoDetect = true;
    }
    this._target = null;
    this._scissorRectLocal = null;
  };
  MaskData2.prototype.copyCountersOrReset = function(maskAbove) {
    if (maskAbove) {
      this._stencilCounter = maskAbove._stencilCounter;
      this._scissorCounter = maskAbove._scissorCounter;
      this._scissorRect = maskAbove._scissorRect;
    } else {
      this._stencilCounter = 0;
      this._scissorCounter = 0;
      this._scissorRect = null;
    }
  };
  return MaskData2;
}();
function compileShader(gl, type, src) {
  var shader = gl.createShader(type);
  gl.shaderSource(shader, src);
  gl.compileShader(shader);
  return shader;
}
function logPrettyShaderError(gl, shader) {
  var shaderSrc = gl.getShaderSource(shader).split("\n").map(function(line, index) {
    return index + ": " + line;
  });
  var shaderLog = gl.getShaderInfoLog(shader);
  var splitShader = shaderLog.split("\n");
  var dedupe = {};
  var lineNumbers = splitShader.map(function(line) {
    return parseFloat(line.replace(/^ERROR\: 0\:([\d]+)\:.*$/, "$1"));
  }).filter(function(n) {
    if (n && !dedupe[n]) {
      dedupe[n] = true;
      return true;
    }
    return false;
  });
  var logArgs = [""];
  lineNumbers.forEach(function(number) {
    shaderSrc[number - 1] = "%c" + shaderSrc[number - 1] + "%c";
    logArgs.push("background: #FF0000; color:#FFFFFF; font-size: 10px", "font-size: 10px");
  });
  var fragmentSourceToLog = shaderSrc.join("\n");
  logArgs[0] = fragmentSourceToLog;
  console.error(shaderLog);
  console.groupCollapsed("click to view full shader code");
  console.warn.apply(console, logArgs);
  console.groupEnd();
}
function logProgramError(gl, program, vertexShader, fragmentShader) {
  if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
    if (!gl.getShaderParameter(vertexShader, gl.COMPILE_STATUS)) {
      logPrettyShaderError(gl, vertexShader);
    }
    if (!gl.getShaderParameter(fragmentShader, gl.COMPILE_STATUS)) {
      logPrettyShaderError(gl, fragmentShader);
    }
    console.error("PixiJS Error: Could not initialize shader.");
    if (gl.getProgramInfoLog(program) !== "") {
      console.warn("PixiJS Warning: gl.getProgramInfoLog()", gl.getProgramInfoLog(program));
    }
  }
}
function booleanArray(size) {
  var array = new Array(size);
  for (var i2 = 0; i2 < array.length; i2++) {
    array[i2] = false;
  }
  return array;
}
function defaultValue(type, size) {
  switch (type) {
    case "float":
      return 0;
    case "vec2":
      return new Float32Array(2 * size);
    case "vec3":
      return new Float32Array(3 * size);
    case "vec4":
      return new Float32Array(4 * size);
    case "int":
    case "uint":
    case "sampler2D":
    case "sampler2DArray":
      return 0;
    case "ivec2":
      return new Int32Array(2 * size);
    case "ivec3":
      return new Int32Array(3 * size);
    case "ivec4":
      return new Int32Array(4 * size);
    case "uvec2":
      return new Uint32Array(2 * size);
    case "uvec3":
      return new Uint32Array(3 * size);
    case "uvec4":
      return new Uint32Array(4 * size);
    case "bool":
      return false;
    case "bvec2":
      return booleanArray(2 * size);
    case "bvec3":
      return booleanArray(3 * size);
    case "bvec4":
      return booleanArray(4 * size);
    case "mat2":
      return new Float32Array([
        1,
        0,
        0,
        1
      ]);
    case "mat3":
      return new Float32Array([
        1,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        1
      ]);
    case "mat4":
      return new Float32Array([
        1,
        0,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        0,
        1
      ]);
  }
  return null;
}
var unknownContext = {};
var context = unknownContext;
function getTestContext() {
  if (context === unknownContext || context && context.isContextLost()) {
    var canvas2 = document.createElement("canvas");
    var gl = void 0;
    if (settings.PREFER_ENV >= ENV$3.WEBGL2) {
      gl = canvas2.getContext("webgl2", {});
    }
    if (!gl) {
      gl = canvas2.getContext("webgl", {}) || canvas2.getContext("experimental-webgl", {});
      if (!gl) {
        gl = null;
      } else {
        gl.getExtension("WEBGL_draw_buffers");
      }
    }
    context = gl;
  }
  return context;
}
var maxFragmentPrecision;
function getMaxFragmentPrecision() {
  if (!maxFragmentPrecision) {
    maxFragmentPrecision = PRECISION$3.MEDIUM;
    var gl = getTestContext();
    if (gl) {
      if (gl.getShaderPrecisionFormat) {
        var shaderFragment = gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.HIGH_FLOAT);
        maxFragmentPrecision = shaderFragment.precision ? PRECISION$3.HIGH : PRECISION$3.MEDIUM;
      }
    }
  }
  return maxFragmentPrecision;
}
function setPrecision(src, requestedPrecision, maxSupportedPrecision) {
  if (src.substring(0, 9) !== "precision") {
    var precision = requestedPrecision;
    if (requestedPrecision === PRECISION$3.HIGH && maxSupportedPrecision !== PRECISION$3.HIGH) {
      precision = PRECISION$3.MEDIUM;
    }
    return "precision " + precision + " float;\n" + src;
  } else if (maxSupportedPrecision !== PRECISION$3.HIGH && src.substring(0, 15) === "precision highp") {
    return src.replace("precision highp", "precision mediump");
  }
  return src;
}
var GLSL_TO_SIZE = {
  float: 1,
  vec2: 2,
  vec3: 3,
  vec4: 4,
  int: 1,
  ivec2: 2,
  ivec3: 3,
  ivec4: 4,
  uint: 1,
  uvec2: 2,
  uvec3: 3,
  uvec4: 4,
  bool: 1,
  bvec2: 2,
  bvec3: 3,
  bvec4: 4,
  mat2: 4,
  mat3: 9,
  mat4: 16,
  sampler2D: 1
};
function mapSize(type) {
  return GLSL_TO_SIZE[type];
}
var GL_TABLE = null;
var GL_TO_GLSL_TYPES = {
  FLOAT: "float",
  FLOAT_VEC2: "vec2",
  FLOAT_VEC3: "vec3",
  FLOAT_VEC4: "vec4",
  INT: "int",
  INT_VEC2: "ivec2",
  INT_VEC3: "ivec3",
  INT_VEC4: "ivec4",
  UNSIGNED_INT: "uint",
  UNSIGNED_INT_VEC2: "uvec2",
  UNSIGNED_INT_VEC3: "uvec3",
  UNSIGNED_INT_VEC4: "uvec4",
  BOOL: "bool",
  BOOL_VEC2: "bvec2",
  BOOL_VEC3: "bvec3",
  BOOL_VEC4: "bvec4",
  FLOAT_MAT2: "mat2",
  FLOAT_MAT3: "mat3",
  FLOAT_MAT4: "mat4",
  SAMPLER_2D: "sampler2D",
  INT_SAMPLER_2D: "sampler2D",
  UNSIGNED_INT_SAMPLER_2D: "sampler2D",
  SAMPLER_CUBE: "samplerCube",
  INT_SAMPLER_CUBE: "samplerCube",
  UNSIGNED_INT_SAMPLER_CUBE: "samplerCube",
  SAMPLER_2D_ARRAY: "sampler2DArray",
  INT_SAMPLER_2D_ARRAY: "sampler2DArray",
  UNSIGNED_INT_SAMPLER_2D_ARRAY: "sampler2DArray"
};
function mapType(gl, type) {
  if (!GL_TABLE) {
    var typeNames = Object.keys(GL_TO_GLSL_TYPES);
    GL_TABLE = {};
    for (var i2 = 0; i2 < typeNames.length; ++i2) {
      var tn = typeNames[i2];
      GL_TABLE[gl[tn]] = GL_TO_GLSL_TYPES[tn];
    }
  }
  return GL_TABLE[type];
}
var uniformParsers = [
  {
    test: function(data) {
      return data.type === "float" && data.size === 1;
    },
    code: function(name2) {
      return '\n            if(uv["' + name2 + '"] !== ud["' + name2 + '"].value)\n            {\n                ud["' + name2 + '"].value = uv["' + name2 + '"]\n                gl.uniform1f(ud["' + name2 + '"].location, uv["' + name2 + '"])\n            }\n            ';
    }
  },
  {
    test: function(data) {
      return (data.type === "sampler2D" || data.type === "samplerCube" || data.type === "sampler2DArray") && data.size === 1 && !data.isArray;
    },
    code: function(name2) {
      return 't = syncData.textureCount++;\n\n            renderer.texture.bind(uv["' + name2 + '"], t);\n\n            if(ud["' + name2 + '"].value !== t)\n            {\n                ud["' + name2 + '"].value = t;\n                gl.uniform1i(ud["' + name2 + '"].location, t);\n; // eslint-disable-line max-len\n            }';
    }
  },
  {
    test: function(data, uniform) {
      return data.type === "mat3" && data.size === 1 && uniform.a !== void 0;
    },
    code: function(name2) {
      return '\n            gl.uniformMatrix3fv(ud["' + name2 + '"].location, false, uv["' + name2 + '"].toArray(true));\n            ';
    },
    codeUbo: function(name2) {
      return "\n                var " + name2 + "_matrix = uv." + name2 + ".toArray(true);\n\n                data[offset] = " + name2 + "_matrix[0];\n                data[offset+1] = " + name2 + "_matrix[1];\n                data[offset+2] = " + name2 + "_matrix[2];\n        \n                data[offset + 4] = " + name2 + "_matrix[3];\n                data[offset + 5] = " + name2 + "_matrix[4];\n                data[offset + 6] = " + name2 + "_matrix[5];\n        \n                data[offset + 8] = " + name2 + "_matrix[6];\n                data[offset + 9] = " + name2 + "_matrix[7];\n                data[offset + 10] = " + name2 + "_matrix[8];\n            ";
    }
  },
  {
    test: function(data, uniform) {
      return data.type === "vec2" && data.size === 1 && uniform.x !== void 0;
    },
    code: function(name2) {
      return '\n                cv = ud["' + name2 + '"].value;\n                v = uv["' + name2 + '"];\n\n                if(cv[0] !== v.x || cv[1] !== v.y)\n                {\n                    cv[0] = v.x;\n                    cv[1] = v.y;\n                    gl.uniform2f(ud["' + name2 + '"].location, v.x, v.y);\n                }';
    },
    codeUbo: function(name2) {
      return "\n                v = uv." + name2 + ";\n\n                data[offset] = v.x;\n                data[offset+1] = v.y;\n            ";
    }
  },
  {
    test: function(data) {
      return data.type === "vec2" && data.size === 1;
    },
    code: function(name2) {
      return '\n                cv = ud["' + name2 + '"].value;\n                v = uv["' + name2 + '"];\n\n                if(cv[0] !== v[0] || cv[1] !== v[1])\n                {\n                    cv[0] = v[0];\n                    cv[1] = v[1];\n                    gl.uniform2f(ud["' + name2 + '"].location, v[0], v[1]);\n                }\n            ';
    }
  },
  {
    test: function(data, uniform) {
      return data.type === "vec4" && data.size === 1 && uniform.width !== void 0;
    },
    code: function(name2) {
      return '\n                cv = ud["' + name2 + '"].value;\n                v = uv["' + name2 + '"];\n\n                if(cv[0] !== v.x || cv[1] !== v.y || cv[2] !== v.width || cv[3] !== v.height)\n                {\n                    cv[0] = v.x;\n                    cv[1] = v.y;\n                    cv[2] = v.width;\n                    cv[3] = v.height;\n                    gl.uniform4f(ud["' + name2 + '"].location, v.x, v.y, v.width, v.height)\n                }';
    },
    codeUbo: function(name2) {
      return "\n                    v = uv." + name2 + ";\n\n                    data[offset] = v.x;\n                    data[offset+1] = v.y;\n                    data[offset+2] = v.width;\n                    data[offset+3] = v.height;\n                ";
    }
  },
  {
    test: function(data) {
      return data.type === "vec4" && data.size === 1;
    },
    code: function(name2) {
      return '\n                cv = ud["' + name2 + '"].value;\n                v = uv["' + name2 + '"];\n\n                if(cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3])\n                {\n                    cv[0] = v[0];\n                    cv[1] = v[1];\n                    cv[2] = v[2];\n                    cv[3] = v[3];\n\n                    gl.uniform4f(ud["' + name2 + '"].location, v[0], v[1], v[2], v[3])\n                }';
    }
  }
];
var GLSL_TO_SINGLE_SETTERS_CACHED = {
  float: "\n    if (cv !== v)\n    {\n        cu.value = v;\n        gl.uniform1f(location, v);\n    }",
  vec2: "\n    if (cv[0] !== v[0] || cv[1] !== v[1])\n    {\n        cv[0] = v[0];\n        cv[1] = v[1];\n\n        gl.uniform2f(location, v[0], v[1])\n    }",
  vec3: "\n    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2])\n    {\n        cv[0] = v[0];\n        cv[1] = v[1];\n        cv[2] = v[2];\n\n        gl.uniform3f(location, v[0], v[1], v[2])\n    }",
  vec4: "\n    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3])\n    {\n        cv[0] = v[0];\n        cv[1] = v[1];\n        cv[2] = v[2];\n        cv[3] = v[3];\n\n        gl.uniform4f(location, v[0], v[1], v[2], v[3]);\n    }",
  int: "\n    if (cv !== v)\n    {\n        cu.value = v;\n\n        gl.uniform1i(location, v);\n    }",
  ivec2: "\n    if (cv[0] !== v[0] || cv[1] !== v[1])\n    {\n        cv[0] = v[0];\n        cv[1] = v[1];\n\n        gl.uniform2i(location, v[0], v[1]);\n    }",
  ivec3: "\n    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2])\n    {\n        cv[0] = v[0];\n        cv[1] = v[1];\n        cv[2] = v[2];\n\n        gl.uniform3i(location, v[0], v[1], v[2]);\n    }",
  ivec4: "\n    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3])\n    {\n        cv[0] = v[0];\n        cv[1] = v[1];\n        cv[2] = v[2];\n        cv[3] = v[3];\n\n        gl.uniform4i(location, v[0], v[1], v[2], v[3]);\n    }",
  uint: "\n    if (cv !== v)\n    {\n        cu.value = v;\n\n        gl.uniform1ui(location, v);\n    }",
  uvec2: "\n    if (cv[0] !== v[0] || cv[1] !== v[1])\n    {\n        cv[0] = v[0];\n        cv[1] = v[1];\n\n        gl.uniform2ui(location, v[0], v[1]);\n    }",
  uvec3: "\n    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2])\n    {\n        cv[0] = v[0];\n        cv[1] = v[1];\n        cv[2] = v[2];\n\n        gl.uniform3ui(location, v[0], v[1], v[2]);\n    }",
  uvec4: "\n    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3])\n    {\n        cv[0] = v[0];\n        cv[1] = v[1];\n        cv[2] = v[2];\n        cv[3] = v[3];\n\n        gl.uniform4ui(location, v[0], v[1], v[2], v[3]);\n    }",
  bool: "\n    if (cv !== v)\n    {\n        cu.value = v;\n        gl.uniform1i(location, v);\n    }",
  bvec2: "\n    if (cv[0] != v[0] || cv[1] != v[1])\n    {\n        cv[0] = v[0];\n        cv[1] = v[1];\n\n        gl.uniform2i(location, v[0], v[1]);\n    }",
  bvec3: "\n    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2])\n    {\n        cv[0] = v[0];\n        cv[1] = v[1];\n        cv[2] = v[2];\n\n        gl.uniform3i(location, v[0], v[1], v[2]);\n    }",
  bvec4: "\n    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3])\n    {\n        cv[0] = v[0];\n        cv[1] = v[1];\n        cv[2] = v[2];\n        cv[3] = v[3];\n\n        gl.uniform4i(location, v[0], v[1], v[2], v[3]);\n    }",
  mat2: "gl.uniformMatrix2fv(location, false, v)",
  mat3: "gl.uniformMatrix3fv(location, false, v)",
  mat4: "gl.uniformMatrix4fv(location, false, v)",
  sampler2D: "gl.uniform1i(location, v)",
  samplerCube: "gl.uniform1i(location, v)",
  sampler2DArray: "gl.uniform1i(location, v)"
};
var GLSL_TO_ARRAY_SETTERS = {
  float: "gl.uniform1fv(location, v)",
  vec2: "gl.uniform2fv(location, v)",
  vec3: "gl.uniform3fv(location, v)",
  vec4: "gl.uniform4fv(location, v)",
  mat4: "gl.uniformMatrix4fv(location, false, v)",
  mat3: "gl.uniformMatrix3fv(location, false, v)",
  mat2: "gl.uniformMatrix2fv(location, false, v)",
  int: "gl.uniform1iv(location, v)",
  ivec2: "gl.uniform2iv(location, v)",
  ivec3: "gl.uniform3iv(location, v)",
  ivec4: "gl.uniform4iv(location, v)",
  uint: "gl.uniform1uiv(location, v)",
  uvec2: "gl.uniform2uiv(location, v)",
  uvec3: "gl.uniform3uiv(location, v)",
  uvec4: "gl.uniform4uiv(location, v)",
  bool: "gl.uniform1iv(location, v)",
  bvec2: "gl.uniform2iv(location, v)",
  bvec3: "gl.uniform3iv(location, v)",
  bvec4: "gl.uniform4iv(location, v)",
  sampler2D: "gl.uniform1iv(location, v)",
  samplerCube: "gl.uniform1iv(location, v)",
  sampler2DArray: "gl.uniform1iv(location, v)"
};
function generateUniformsSync(group, uniformData) {
  var _a3;
  var funcFragments = ["\n        var v = null;\n        var cv = null;\n        var cu = null;\n        var t = 0;\n        var gl = renderer.gl;\n    "];
  for (var i2 in group.uniforms) {
    var data = uniformData[i2];
    if (!data) {
      if ((_a3 = group.uniforms[i2]) === null || _a3 === void 0 ? void 0 : _a3.group) {
        if (group.uniforms[i2].ubo) {
          funcFragments.push("\n                        renderer.shader.syncUniformBufferGroup(uv." + i2 + ", '" + i2 + "');\n                    ");
        } else {
          funcFragments.push("\n                        renderer.shader.syncUniformGroup(uv." + i2 + ", syncData);\n                    ");
        }
      }
      continue;
    }
    var uniform = group.uniforms[i2];
    var parsed = false;
    for (var j2 = 0; j2 < uniformParsers.length; j2++) {
      if (uniformParsers[j2].test(data, uniform)) {
        funcFragments.push(uniformParsers[j2].code(i2, uniform));
        parsed = true;
        break;
      }
    }
    if (!parsed) {
      var templateType = data.size === 1 ? GLSL_TO_SINGLE_SETTERS_CACHED : GLSL_TO_ARRAY_SETTERS;
      var template = templateType[data.type].replace("location", 'ud["' + i2 + '"].location');
      funcFragments.push('\n            cu = ud["' + i2 + '"];\n            cv = cu.value;\n            v = uv["' + i2 + '"];\n            ' + template + ";");
    }
  }
  return new Function("ud", "uv", "renderer", "syncData", funcFragments.join("\n"));
}
var fragTemplate$1 = [
  "precision mediump float;",
  "void main(void){",
  "float test = 0.1;",
  "%forloop%",
  "gl_FragColor = vec4(0.0);",
  "}"
].join("\n");
function generateIfTestSrc(maxIfs) {
  var src = "";
  for (var i2 = 0; i2 < maxIfs; ++i2) {
    if (i2 > 0) {
      src += "\nelse ";
    }
    if (i2 < maxIfs - 1) {
      src += "if(test == " + i2 + ".0){}";
    }
  }
  return src;
}
function checkMaxIfStatementsInShader(maxIfs, gl) {
  if (maxIfs === 0) {
    throw new Error("Invalid value of `0` passed to `checkMaxIfStatementsInShader`");
  }
  var shader = gl.createShader(gl.FRAGMENT_SHADER);
  while (true) {
    var fragmentSrc = fragTemplate$1.replace(/%forloop%/gi, generateIfTestSrc(maxIfs));
    gl.shaderSource(shader, fragmentSrc);
    gl.compileShader(shader);
    if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
      maxIfs = maxIfs / 2 | 0;
    } else {
      break;
    }
  }
  return maxIfs;
}
var unsafeEval;
function unsafeEvalSupported() {
  if (typeof unsafeEval === "boolean") {
    return unsafeEval;
  }
  try {
    var func = new Function("param1", "param2", "param3", "return param1[param2] === param3;");
    unsafeEval = func({ a: "b" }, "a", "b") === true;
  } catch (e) {
    unsafeEval = false;
  }
  return unsafeEval;
}
var defaultFragment = "varying vec2 vTextureCoord;\n\nuniform sampler2D uSampler;\n\nvoid main(void){\n   gl_FragColor *= texture2D(uSampler, vTextureCoord);\n}";
var defaultVertex = "attribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\n\nvarying vec2 vTextureCoord;\n\nvoid main(void){\n   gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n   vTextureCoord = aTextureCoord;\n}\n";
var UID$3 = 0;
var nameCache = {};
var Program = function() {
  function Program2(vertexSrc, fragmentSrc, name2) {
    if (name2 === void 0) {
      name2 = "pixi-shader";
    }
    this.id = UID$3++;
    this.vertexSrc = vertexSrc || Program2.defaultVertexSrc;
    this.fragmentSrc = fragmentSrc || Program2.defaultFragmentSrc;
    this.vertexSrc = this.vertexSrc.trim();
    this.fragmentSrc = this.fragmentSrc.trim();
    if (this.vertexSrc.substring(0, 8) !== "#version") {
      name2 = name2.replace(/\s+/g, "-");
      if (nameCache[name2]) {
        nameCache[name2]++;
        name2 += "-" + nameCache[name2];
      } else {
        nameCache[name2] = 1;
      }
      this.vertexSrc = "#define SHADER_NAME " + name2 + "\n" + this.vertexSrc;
      this.fragmentSrc = "#define SHADER_NAME " + name2 + "\n" + this.fragmentSrc;
      this.vertexSrc = setPrecision(this.vertexSrc, settings.PRECISION_VERTEX, PRECISION$3.HIGH);
      this.fragmentSrc = setPrecision(this.fragmentSrc, settings.PRECISION_FRAGMENT, getMaxFragmentPrecision());
    }
    this.glPrograms = {};
    this.syncUniforms = null;
  }
  Object.defineProperty(Program2, "defaultVertexSrc", {
    get: function() {
      return defaultVertex;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Program2, "defaultFragmentSrc", {
    get: function() {
      return defaultFragment;
    },
    enumerable: false,
    configurable: true
  });
  Program2.from = function(vertexSrc, fragmentSrc, name2) {
    var key = vertexSrc + fragmentSrc;
    var program = ProgramCache[key];
    if (!program) {
      ProgramCache[key] = program = new Program2(vertexSrc, fragmentSrc, name2);
    }
    return program;
  };
  return Program2;
}();
var Shader = function() {
  function Shader2(program, uniforms) {
    this.uniformBindCount = 0;
    this.program = program;
    if (uniforms) {
      if (uniforms instanceof UniformGroup) {
        this.uniformGroup = uniforms;
      } else {
        this.uniformGroup = new UniformGroup(uniforms);
      }
    } else {
      this.uniformGroup = new UniformGroup({});
    }
  }
  Shader2.prototype.checkUniformExists = function(name2, group) {
    if (group.uniforms[name2]) {
      return true;
    }
    for (var i2 in group.uniforms) {
      var uniform = group.uniforms[i2];
      if (uniform.group) {
        if (this.checkUniformExists(name2, uniform)) {
          return true;
        }
      }
    }
    return false;
  };
  Shader2.prototype.destroy = function() {
    this.uniformGroup = null;
  };
  Object.defineProperty(Shader2.prototype, "uniforms", {
    get: function() {
      return this.uniformGroup.uniforms;
    },
    enumerable: false,
    configurable: true
  });
  Shader2.from = function(vertexSrc, fragmentSrc, uniforms) {
    var program = Program.from(vertexSrc, fragmentSrc);
    return new Shader2(program, uniforms);
  };
  return Shader2;
}();
var BLEND = 0;
var OFFSET = 1;
var CULLING = 2;
var DEPTH_TEST = 3;
var WINDING = 4;
var DEPTH_MASK = 5;
var State = function() {
  function State2() {
    this.data = 0;
    this.blendMode = BLEND_MODES$3.NORMAL;
    this.polygonOffset = 0;
    this.blend = true;
    this.depthMask = true;
  }
  Object.defineProperty(State2.prototype, "blend", {
    get: function() {
      return !!(this.data & 1 << BLEND);
    },
    set: function(value) {
      if (!!(this.data & 1 << BLEND) !== value) {
        this.data ^= 1 << BLEND;
      }
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(State2.prototype, "offsets", {
    get: function() {
      return !!(this.data & 1 << OFFSET);
    },
    set: function(value) {
      if (!!(this.data & 1 << OFFSET) !== value) {
        this.data ^= 1 << OFFSET;
      }
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(State2.prototype, "culling", {
    get: function() {
      return !!(this.data & 1 << CULLING);
    },
    set: function(value) {
      if (!!(this.data & 1 << CULLING) !== value) {
        this.data ^= 1 << CULLING;
      }
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(State2.prototype, "depthTest", {
    get: function() {
      return !!(this.data & 1 << DEPTH_TEST);
    },
    set: function(value) {
      if (!!(this.data & 1 << DEPTH_TEST) !== value) {
        this.data ^= 1 << DEPTH_TEST;
      }
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(State2.prototype, "depthMask", {
    get: function() {
      return !!(this.data & 1 << DEPTH_MASK);
    },
    set: function(value) {
      if (!!(this.data & 1 << DEPTH_MASK) !== value) {
        this.data ^= 1 << DEPTH_MASK;
      }
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(State2.prototype, "clockwiseFrontFace", {
    get: function() {
      return !!(this.data & 1 << WINDING);
    },
    set: function(value) {
      if (!!(this.data & 1 << WINDING) !== value) {
        this.data ^= 1 << WINDING;
      }
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(State2.prototype, "blendMode", {
    get: function() {
      return this._blendMode;
    },
    set: function(value) {
      this.blend = value !== BLEND_MODES$3.NONE;
      this._blendMode = value;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(State2.prototype, "polygonOffset", {
    get: function() {
      return this._polygonOffset;
    },
    set: function(value) {
      this.offsets = !!value;
      this._polygonOffset = value;
    },
    enumerable: false,
    configurable: true
  });
  State2.prototype.toString = function() {
    return "[@pixi/core:State " + ("blendMode=" + this.blendMode + " ") + ("clockwiseFrontFace=" + this.clockwiseFrontFace + " ") + ("culling=" + this.culling + " ") + ("depthMask=" + this.depthMask + " ") + ("polygonOffset=" + this.polygonOffset) + "]";
  };
  State2.for2d = function() {
    var state = new State2();
    state.depthTest = false;
    state.blend = true;
    return state;
  };
  return State2;
}();
var defaultVertex$1 = "attribute vec2 aVertexPosition;\n\nuniform mat3 projectionMatrix;\n\nvarying vec2 vTextureCoord;\n\nuniform vec4 inputSize;\nuniform vec4 outputFrame;\n\nvec4 filterVertexPosition( void )\n{\n    vec2 position = aVertexPosition * max(outputFrame.zw, vec2(0.)) + outputFrame.xy;\n\n    return vec4((projectionMatrix * vec3(position, 1.0)).xy, 0.0, 1.0);\n}\n\nvec2 filterTextureCoord( void )\n{\n    return aVertexPosition * (outputFrame.zw * inputSize.zw);\n}\n\nvoid main(void)\n{\n    gl_Position = filterVertexPosition();\n    vTextureCoord = filterTextureCoord();\n}\n";
var defaultFragment$1 = "varying vec2 vTextureCoord;\n\nuniform sampler2D uSampler;\n\nvoid main(void){\n   gl_FragColor = texture2D(uSampler, vTextureCoord);\n}\n";
var Filter = function(_super) {
  __extends$q(Filter2, _super);
  function Filter2(vertexSrc, fragmentSrc, uniforms) {
    var _this = this;
    var program = Program.from(vertexSrc || Filter2.defaultVertexSrc, fragmentSrc || Filter2.defaultFragmentSrc);
    _this = _super.call(this, program, uniforms) || this;
    _this.padding = 0;
    _this.resolution = settings.FILTER_RESOLUTION;
    _this.multisample = settings.FILTER_MULTISAMPLE;
    _this.enabled = true;
    _this.autoFit = true;
    _this.state = new State();
    return _this;
  }
  Filter2.prototype.apply = function(filterManager, input, output, clearMode, _currentState) {
    filterManager.applyFilter(this, input, output, clearMode);
  };
  Object.defineProperty(Filter2.prototype, "blendMode", {
    get: function() {
      return this.state.blendMode;
    },
    set: function(value) {
      this.state.blendMode = value;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Filter2.prototype, "resolution", {
    get: function() {
      return this._resolution;
    },
    set: function(value) {
      this._resolution = value;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Filter2, "defaultVertexSrc", {
    get: function() {
      return defaultVertex$1;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Filter2, "defaultFragmentSrc", {
    get: function() {
      return defaultFragment$1;
    },
    enumerable: false,
    configurable: true
  });
  return Filter2;
}(Shader);
var vertex$4 = "attribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\nuniform mat3 otherMatrix;\n\nvarying vec2 vMaskCoord;\nvarying vec2 vTextureCoord;\n\nvoid main(void)\n{\n    gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n\n    vTextureCoord = aTextureCoord;\n    vMaskCoord = ( otherMatrix * vec3( aTextureCoord, 1.0)  ).xy;\n}\n";
var fragment$7 = "varying vec2 vMaskCoord;\nvarying vec2 vTextureCoord;\n\nuniform sampler2D uSampler;\nuniform sampler2D mask;\nuniform float alpha;\nuniform float npmAlpha;\nuniform vec4 maskClamp;\n\nvoid main(void)\n{\n    float clip = step(3.5,\n        step(maskClamp.x, vMaskCoord.x) +\n        step(maskClamp.y, vMaskCoord.y) +\n        step(vMaskCoord.x, maskClamp.z) +\n        step(vMaskCoord.y, maskClamp.w));\n\n    vec4 original = texture2D(uSampler, vTextureCoord);\n    vec4 masky = texture2D(mask, vMaskCoord);\n    float alphaMul = 1.0 - npmAlpha * (1.0 - masky.a);\n\n    original *= (alphaMul * masky.r * alpha * clip);\n\n    gl_FragColor = original;\n}\n";
var tempMat$1 = new Matrix();
var TextureMatrix = function() {
  function TextureMatrix2(texture, clampMargin) {
    this._texture = texture;
    this.mapCoord = new Matrix();
    this.uClampFrame = new Float32Array(4);
    this.uClampOffset = new Float32Array(2);
    this._textureID = -1;
    this._updateID = 0;
    this.clampOffset = 0;
    this.clampMargin = typeof clampMargin === "undefined" ? 0.5 : clampMargin;
    this.isSimple = false;
  }
  Object.defineProperty(TextureMatrix2.prototype, "texture", {
    get: function() {
      return this._texture;
    },
    set: function(value) {
      this._texture = value;
      this._textureID = -1;
    },
    enumerable: false,
    configurable: true
  });
  TextureMatrix2.prototype.multiplyUvs = function(uvs, out) {
    if (out === void 0) {
      out = uvs;
    }
    var mat = this.mapCoord;
    for (var i2 = 0; i2 < uvs.length; i2 += 2) {
      var x2 = uvs[i2];
      var y2 = uvs[i2 + 1];
      out[i2] = x2 * mat.a + y2 * mat.c + mat.tx;
      out[i2 + 1] = x2 * mat.b + y2 * mat.d + mat.ty;
    }
    return out;
  };
  TextureMatrix2.prototype.update = function(forceUpdate) {
    var tex = this._texture;
    if (!tex || !tex.valid) {
      return false;
    }
    if (!forceUpdate && this._textureID === tex._updateID) {
      return false;
    }
    this._textureID = tex._updateID;
    this._updateID++;
    var uvs = tex._uvs;
    this.mapCoord.set(uvs.x1 - uvs.x0, uvs.y1 - uvs.y0, uvs.x3 - uvs.x0, uvs.y3 - uvs.y0, uvs.x0, uvs.y0);
    var orig = tex.orig;
    var trim2 = tex.trim;
    if (trim2) {
      tempMat$1.set(orig.width / trim2.width, 0, 0, orig.height / trim2.height, -trim2.x / trim2.width, -trim2.y / trim2.height);
      this.mapCoord.append(tempMat$1);
    }
    var texBase = tex.baseTexture;
    var frame = this.uClampFrame;
    var margin = this.clampMargin / texBase.resolution;
    var offset = this.clampOffset;
    frame[0] = (tex._frame.x + margin + offset) / texBase.width;
    frame[1] = (tex._frame.y + margin + offset) / texBase.height;
    frame[2] = (tex._frame.x + tex._frame.width - margin + offset) / texBase.width;
    frame[3] = (tex._frame.y + tex._frame.height - margin + offset) / texBase.height;
    this.uClampOffset[0] = offset / texBase.realWidth;
    this.uClampOffset[1] = offset / texBase.realHeight;
    this.isSimple = tex._frame.width === texBase.width && tex._frame.height === texBase.height && tex.rotate === 0;
    return true;
  };
  return TextureMatrix2;
}();
var SpriteMaskFilter = function(_super) {
  __extends$q(SpriteMaskFilter2, _super);
  function SpriteMaskFilter2(vertexSrc, fragmentSrc, uniforms) {
    var _this = this;
    var sprite = null;
    if (typeof vertexSrc !== "string" && fragmentSrc === void 0 && uniforms === void 0) {
      sprite = vertexSrc;
      vertexSrc = void 0;
      fragmentSrc = void 0;
      uniforms = void 0;
    }
    _this = _super.call(this, vertexSrc || vertex$4, fragmentSrc || fragment$7, uniforms) || this;
    _this.maskSprite = sprite;
    _this.maskMatrix = new Matrix();
    return _this;
  }
  Object.defineProperty(SpriteMaskFilter2.prototype, "maskSprite", {
    get: function() {
      return this._maskSprite;
    },
    set: function(value) {
      this._maskSprite = value;
      if (this._maskSprite) {
        this._maskSprite.renderable = false;
      }
    },
    enumerable: false,
    configurable: true
  });
  SpriteMaskFilter2.prototype.apply = function(filterManager, input, output, clearMode) {
    var maskSprite = this._maskSprite;
    var tex = maskSprite._texture;
    if (!tex.valid) {
      return;
    }
    if (!tex.uvMatrix) {
      tex.uvMatrix = new TextureMatrix(tex, 0);
    }
    tex.uvMatrix.update();
    this.uniforms.npmAlpha = tex.baseTexture.alphaMode ? 0 : 1;
    this.uniforms.mask = tex;
    this.uniforms.otherMatrix = filterManager.calculateSpriteMatrix(this.maskMatrix, maskSprite).prepend(tex.uvMatrix.mapCoord);
    this.uniforms.alpha = maskSprite.worldAlpha;
    this.uniforms.maskClamp = tex.uvMatrix.uClampFrame;
    filterManager.applyFilter(this, input, output, clearMode);
  };
  return SpriteMaskFilter2;
}(Filter);
var MaskSystem = function() {
  function MaskSystem2(renderer) {
    this.renderer = renderer;
    this.enableScissor = true;
    this.alphaMaskPool = [];
    this.maskDataPool = [];
    this.maskStack = [];
    this.alphaMaskIndex = 0;
  }
  MaskSystem2.prototype.setMaskStack = function(maskStack) {
    this.maskStack = maskStack;
    this.renderer.scissor.setMaskStack(maskStack);
    this.renderer.stencil.setMaskStack(maskStack);
  };
  MaskSystem2.prototype.push = function(target, maskDataOrTarget) {
    var maskData = maskDataOrTarget;
    if (!maskData.isMaskData) {
      var d2 = this.maskDataPool.pop() || new MaskData();
      d2.pooled = true;
      d2.maskObject = maskDataOrTarget;
      maskData = d2;
    }
    var maskAbove = this.maskStack.length !== 0 ? this.maskStack[this.maskStack.length - 1] : null;
    maskData.copyCountersOrReset(maskAbove);
    if (maskData.autoDetect) {
      this.detect(maskData);
    }
    maskData._target = target;
    if (maskData.type !== MASK_TYPES$3.SPRITE) {
      this.maskStack.push(maskData);
    }
    if (maskData.enabled) {
      switch (maskData.type) {
        case MASK_TYPES$3.SCISSOR:
          this.renderer.scissor.push(maskData);
          break;
        case MASK_TYPES$3.STENCIL:
          this.renderer.stencil.push(maskData);
          break;
        case MASK_TYPES$3.SPRITE:
          maskData.copyCountersOrReset(null);
          this.pushSpriteMask(maskData);
          break;
      }
    }
    if (maskData.type === MASK_TYPES$3.SPRITE) {
      this.maskStack.push(maskData);
    }
  };
  MaskSystem2.prototype.pop = function(target) {
    var maskData = this.maskStack.pop();
    if (!maskData || maskData._target !== target) {
      return;
    }
    if (maskData.enabled) {
      switch (maskData.type) {
        case MASK_TYPES$3.SCISSOR:
          this.renderer.scissor.pop();
          break;
        case MASK_TYPES$3.STENCIL:
          this.renderer.stencil.pop(maskData.maskObject);
          break;
        case MASK_TYPES$3.SPRITE:
          this.popSpriteMask(maskData);
          break;
      }
    }
    maskData.reset();
    if (maskData.pooled) {
      this.maskDataPool.push(maskData);
    }
    if (this.maskStack.length !== 0) {
      var maskCurrent = this.maskStack[this.maskStack.length - 1];
      if (maskCurrent.type === MASK_TYPES$3.SPRITE && maskCurrent._filters) {
        maskCurrent._filters[0].maskSprite = maskCurrent.maskObject;
      }
    }
  };
  MaskSystem2.prototype.detect = function(maskData) {
    var maskObject = maskData.maskObject;
    if (maskObject.isSprite) {
      maskData.type = MASK_TYPES$3.SPRITE;
    } else if (this.enableScissor && this.renderer.scissor.testScissor(maskData)) {
      maskData.type = MASK_TYPES$3.SCISSOR;
    } else {
      maskData.type = MASK_TYPES$3.STENCIL;
    }
  };
  MaskSystem2.prototype.pushSpriteMask = function(maskData) {
    var _a3, _b3;
    var maskObject = maskData.maskObject;
    var target = maskData._target;
    var alphaMaskFilter = maskData._filters;
    if (!alphaMaskFilter) {
      alphaMaskFilter = this.alphaMaskPool[this.alphaMaskIndex];
      if (!alphaMaskFilter) {
        alphaMaskFilter = this.alphaMaskPool[this.alphaMaskIndex] = [new SpriteMaskFilter()];
      }
    }
    var renderer = this.renderer;
    var renderTextureSystem = renderer.renderTexture;
    var resolution;
    var multisample;
    if (renderTextureSystem.current) {
      var renderTexture = renderTextureSystem.current;
      resolution = maskData.resolution || renderTexture.resolution;
      multisample = (_a3 = maskData.multisample) !== null && _a3 !== void 0 ? _a3 : renderTexture.multisample;
    } else {
      resolution = maskData.resolution || renderer.resolution;
      multisample = (_b3 = maskData.multisample) !== null && _b3 !== void 0 ? _b3 : renderer.multisample;
    }
    alphaMaskFilter[0].resolution = resolution;
    alphaMaskFilter[0].multisample = multisample;
    alphaMaskFilter[0].maskSprite = maskObject;
    var stashFilterArea = target.filterArea;
    target.filterArea = maskObject.getBounds(true);
    renderer.filter.push(target, alphaMaskFilter);
    target.filterArea = stashFilterArea;
    if (!maskData._filters) {
      this.alphaMaskIndex++;
    }
  };
  MaskSystem2.prototype.popSpriteMask = function(maskData) {
    this.renderer.filter.pop();
    if (maskData._filters) {
      maskData._filters[0].maskSprite = null;
    } else {
      this.alphaMaskIndex--;
      this.alphaMaskPool[this.alphaMaskIndex][0].maskSprite = null;
    }
  };
  MaskSystem2.prototype.destroy = function() {
    this.renderer = null;
  };
  return MaskSystem2;
}();
var AbstractMaskSystem = function() {
  function AbstractMaskSystem2(renderer) {
    this.renderer = renderer;
    this.maskStack = [];
    this.glConst = 0;
  }
  AbstractMaskSystem2.prototype.getStackLength = function() {
    return this.maskStack.length;
  };
  AbstractMaskSystem2.prototype.setMaskStack = function(maskStack) {
    var gl = this.renderer.gl;
    var curStackLen = this.getStackLength();
    this.maskStack = maskStack;
    var newStackLen = this.getStackLength();
    if (newStackLen !== curStackLen) {
      if (newStackLen === 0) {
        gl.disable(this.glConst);
      } else {
        gl.enable(this.glConst);
        this._useCurrent();
      }
    }
  };
  AbstractMaskSystem2.prototype._useCurrent = function() {
  };
  AbstractMaskSystem2.prototype.destroy = function() {
    this.renderer = null;
    this.maskStack = null;
  };
  return AbstractMaskSystem2;
}();
var tempMatrix$1 = new Matrix();
var ScissorSystem = function(_super) {
  __extends$q(ScissorSystem2, _super);
  function ScissorSystem2(renderer) {
    var _this = _super.call(this, renderer) || this;
    _this.glConst = WebGLRenderingContext.SCISSOR_TEST;
    return _this;
  }
  ScissorSystem2.prototype.getStackLength = function() {
    var maskData = this.maskStack[this.maskStack.length - 1];
    if (maskData) {
      return maskData._scissorCounter;
    }
    return 0;
  };
  ScissorSystem2.prototype.calcScissorRect = function(maskData) {
    if (maskData._scissorRectLocal) {
      return;
    }
    var prevData = maskData._scissorRect;
    var maskObject = maskData.maskObject;
    var renderer = this.renderer;
    var renderTextureSystem = renderer.renderTexture;
    maskObject.renderable = true;
    var rect = maskObject.getBounds();
    this.roundFrameToPixels(rect, renderTextureSystem.current ? renderTextureSystem.current.resolution : renderer.resolution, renderTextureSystem.sourceFrame, renderTextureSystem.destinationFrame, renderer.projection.transform);
    maskObject.renderable = false;
    if (prevData) {
      rect.fit(prevData);
    }
    maskData._scissorRectLocal = rect;
  };
  ScissorSystem2.isMatrixRotated = function(matrix) {
    if (!matrix) {
      return false;
    }
    var a2 = matrix.a, b2 = matrix.b, c2 = matrix.c, d2 = matrix.d;
    return (Math.abs(b2) > 1e-4 || Math.abs(c2) > 1e-4) && (Math.abs(a2) > 1e-4 || Math.abs(d2) > 1e-4);
  };
  ScissorSystem2.prototype.testScissor = function(maskData) {
    var maskObject = maskData.maskObject;
    if (!maskObject.isFastRect || !maskObject.isFastRect()) {
      return false;
    }
    if (ScissorSystem2.isMatrixRotated(maskObject.worldTransform)) {
      return false;
    }
    if (ScissorSystem2.isMatrixRotated(this.renderer.projection.transform)) {
      return false;
    }
    this.calcScissorRect(maskData);
    var rect = maskData._scissorRectLocal;
    return rect.width > 0 && rect.height > 0;
  };
  ScissorSystem2.prototype.roundFrameToPixels = function(frame, resolution, bindingSourceFrame, bindingDestinationFrame, transform) {
    if (ScissorSystem2.isMatrixRotated(transform)) {
      return;
    }
    transform = transform ? tempMatrix$1.copyFrom(transform) : tempMatrix$1.identity();
    transform.translate(-bindingSourceFrame.x, -bindingSourceFrame.y).scale(bindingDestinationFrame.width / bindingSourceFrame.width, bindingDestinationFrame.height / bindingSourceFrame.height).translate(bindingDestinationFrame.x, bindingDestinationFrame.y);
    this.renderer.filter.transformAABB(transform, frame);
    frame.fit(bindingDestinationFrame);
    frame.x = Math.round(frame.x * resolution);
    frame.y = Math.round(frame.y * resolution);
    frame.width = Math.round(frame.width * resolution);
    frame.height = Math.round(frame.height * resolution);
  };
  ScissorSystem2.prototype.push = function(maskData) {
    if (!maskData._scissorRectLocal) {
      this.calcScissorRect(maskData);
    }
    var gl = this.renderer.gl;
    if (!maskData._scissorRect) {
      gl.enable(gl.SCISSOR_TEST);
    }
    maskData._scissorCounter++;
    maskData._scissorRect = maskData._scissorRectLocal;
    this._useCurrent();
  };
  ScissorSystem2.prototype.pop = function() {
    var gl = this.renderer.gl;
    if (this.getStackLength() > 0) {
      this._useCurrent();
    } else {
      gl.disable(gl.SCISSOR_TEST);
    }
  };
  ScissorSystem2.prototype._useCurrent = function() {
    var rect = this.maskStack[this.maskStack.length - 1]._scissorRect;
    var y2;
    if (this.renderer.renderTexture.current) {
      y2 = rect.y;
    } else {
      y2 = this.renderer.height - rect.height - rect.y;
    }
    this.renderer.gl.scissor(rect.x, y2, rect.width, rect.height);
  };
  return ScissorSystem2;
}(AbstractMaskSystem);
var StencilSystem = function(_super) {
  __extends$q(StencilSystem2, _super);
  function StencilSystem2(renderer) {
    var _this = _super.call(this, renderer) || this;
    _this.glConst = WebGLRenderingContext.STENCIL_TEST;
    return _this;
  }
  StencilSystem2.prototype.getStackLength = function() {
    var maskData = this.maskStack[this.maskStack.length - 1];
    if (maskData) {
      return maskData._stencilCounter;
    }
    return 0;
  };
  StencilSystem2.prototype.push = function(maskData) {
    var maskObject = maskData.maskObject;
    var gl = this.renderer.gl;
    var prevMaskCount = maskData._stencilCounter;
    if (prevMaskCount === 0) {
      this.renderer.framebuffer.forceStencil();
      gl.clearStencil(0);
      gl.clear(gl.STENCIL_BUFFER_BIT);
      gl.enable(gl.STENCIL_TEST);
    }
    maskData._stencilCounter++;
    gl.colorMask(false, false, false, false);
    gl.stencilFunc(gl.EQUAL, prevMaskCount, 4294967295);
    gl.stencilOp(gl.KEEP, gl.KEEP, gl.INCR);
    maskObject.renderable = true;
    maskObject.render(this.renderer);
    this.renderer.batch.flush();
    maskObject.renderable = false;
    this._useCurrent();
  };
  StencilSystem2.prototype.pop = function(maskObject) {
    var gl = this.renderer.gl;
    if (this.getStackLength() === 0) {
      gl.disable(gl.STENCIL_TEST);
    } else {
      gl.colorMask(false, false, false, false);
      gl.stencilOp(gl.KEEP, gl.KEEP, gl.DECR);
      maskObject.renderable = true;
      maskObject.render(this.renderer);
      this.renderer.batch.flush();
      maskObject.renderable = false;
      this._useCurrent();
    }
  };
  StencilSystem2.prototype._useCurrent = function() {
    var gl = this.renderer.gl;
    gl.colorMask(true, true, true, true);
    gl.stencilFunc(gl.EQUAL, this.getStackLength(), 4294967295);
    gl.stencilOp(gl.KEEP, gl.KEEP, gl.KEEP);
  };
  return StencilSystem2;
}(AbstractMaskSystem);
var ProjectionSystem = function() {
  function ProjectionSystem2(renderer) {
    this.renderer = renderer;
    this.destinationFrame = null;
    this.sourceFrame = null;
    this.defaultFrame = null;
    this.projectionMatrix = new Matrix();
    this.transform = null;
  }
  ProjectionSystem2.prototype.update = function(destinationFrame, sourceFrame, resolution, root) {
    this.destinationFrame = destinationFrame || this.destinationFrame || this.defaultFrame;
    this.sourceFrame = sourceFrame || this.sourceFrame || destinationFrame;
    this.calculateProjection(this.destinationFrame, this.sourceFrame, resolution, root);
    if (this.transform) {
      this.projectionMatrix.append(this.transform);
    }
    var renderer = this.renderer;
    renderer.globalUniforms.uniforms.projectionMatrix = this.projectionMatrix;
    renderer.globalUniforms.update();
    if (renderer.shader.shader) {
      renderer.shader.syncUniformGroup(renderer.shader.shader.uniforms.globals);
    }
  };
  ProjectionSystem2.prototype.calculateProjection = function(_destinationFrame, sourceFrame, _resolution, root) {
    var pm = this.projectionMatrix;
    var sign2 = !root ? 1 : -1;
    pm.identity();
    pm.a = 1 / sourceFrame.width * 2;
    pm.d = sign2 * (1 / sourceFrame.height * 2);
    pm.tx = -1 - sourceFrame.x * pm.a;
    pm.ty = -sign2 - sourceFrame.y * pm.d;
  };
  ProjectionSystem2.prototype.setTransform = function(_matrix) {
  };
  ProjectionSystem2.prototype.destroy = function() {
    this.renderer = null;
  };
  return ProjectionSystem2;
}();
var tempRect = new Rectangle();
var tempRect2 = new Rectangle();
var RenderTextureSystem = function() {
  function RenderTextureSystem2(renderer) {
    this.renderer = renderer;
    this.clearColor = renderer._backgroundColorRgba;
    this.defaultMaskStack = [];
    this.current = null;
    this.sourceFrame = new Rectangle();
    this.destinationFrame = new Rectangle();
    this.viewportFrame = new Rectangle();
  }
  RenderTextureSystem2.prototype.bind = function(renderTexture, sourceFrame, destinationFrame) {
    if (renderTexture === void 0) {
      renderTexture = null;
    }
    var renderer = this.renderer;
    this.current = renderTexture;
    var baseTexture;
    var framebuffer;
    var resolution;
    if (renderTexture) {
      baseTexture = renderTexture.baseTexture;
      resolution = baseTexture.resolution;
      if (!sourceFrame) {
        tempRect.width = renderTexture.frame.width;
        tempRect.height = renderTexture.frame.height;
        sourceFrame = tempRect;
      }
      if (!destinationFrame) {
        tempRect2.x = renderTexture.frame.x;
        tempRect2.y = renderTexture.frame.y;
        tempRect2.width = sourceFrame.width;
        tempRect2.height = sourceFrame.height;
        destinationFrame = tempRect2;
      }
      framebuffer = baseTexture.framebuffer;
    } else {
      resolution = renderer.resolution;
      if (!sourceFrame) {
        tempRect.width = renderer.screen.width;
        tempRect.height = renderer.screen.height;
        sourceFrame = tempRect;
      }
      if (!destinationFrame) {
        destinationFrame = tempRect;
        destinationFrame.width = sourceFrame.width;
        destinationFrame.height = sourceFrame.height;
      }
    }
    var viewportFrame = this.viewportFrame;
    viewportFrame.x = destinationFrame.x * resolution;
    viewportFrame.y = destinationFrame.y * resolution;
    viewportFrame.width = destinationFrame.width * resolution;
    viewportFrame.height = destinationFrame.height * resolution;
    if (!renderTexture) {
      viewportFrame.y = renderer.view.height - (viewportFrame.y + viewportFrame.height);
    }
    viewportFrame.ceil();
    this.renderer.framebuffer.bind(framebuffer, viewportFrame);
    this.renderer.projection.update(destinationFrame, sourceFrame, resolution, !framebuffer);
    if (renderTexture) {
      this.renderer.mask.setMaskStack(baseTexture.maskStack);
    } else {
      this.renderer.mask.setMaskStack(this.defaultMaskStack);
    }
    this.sourceFrame.copyFrom(sourceFrame);
    this.destinationFrame.copyFrom(destinationFrame);
  };
  RenderTextureSystem2.prototype.clear = function(clearColor, mask) {
    if (this.current) {
      clearColor = clearColor || this.current.baseTexture.clearColor;
    } else {
      clearColor = clearColor || this.clearColor;
    }
    var destinationFrame = this.destinationFrame;
    var baseFrame = this.current ? this.current.baseTexture : this.renderer.screen;
    var clearMask = destinationFrame.width !== baseFrame.width || destinationFrame.height !== baseFrame.height;
    if (clearMask) {
      var _a3 = this.viewportFrame, x2 = _a3.x, y2 = _a3.y, width = _a3.width, height = _a3.height;
      x2 = Math.round(x2);
      y2 = Math.round(y2);
      width = Math.round(width);
      height = Math.round(height);
      this.renderer.gl.enable(this.renderer.gl.SCISSOR_TEST);
      this.renderer.gl.scissor(x2, y2, width, height);
    }
    this.renderer.framebuffer.clear(clearColor[0], clearColor[1], clearColor[2], clearColor[3], mask);
    if (clearMask) {
      this.renderer.scissor.pop();
    }
  };
  RenderTextureSystem2.prototype.resize = function() {
    this.bind(null);
  };
  RenderTextureSystem2.prototype.reset = function() {
    this.bind(null);
  };
  RenderTextureSystem2.prototype.destroy = function() {
    this.renderer = null;
  };
  return RenderTextureSystem2;
}();
function uboUpdate(_ud, _uv, _renderer, _syncData, buffer) {
  _renderer.buffer.update(buffer);
}
var UBO_TO_SINGLE_SETTERS = {
  float: "\n        data[offset] = v;\n    ",
  vec2: "\n        data[offset] = v[0];\n        data[offset+1] = v[1];\n    ",
  vec3: "\n        data[offset] = v[0];\n        data[offset+1] = v[1];\n        data[offset+2] = v[2];\n\n    ",
  vec4: "\n        data[offset] = v[0];\n        data[offset+1] = v[1];\n        data[offset+2] = v[2];\n        data[offset+3] = v[3];\n    ",
  mat2: "\n        data[offset] = v[0];\n        data[offset+1] = v[1];\n\n        data[offset+4] = v[2];\n        data[offset+5] = v[3];\n    ",
  mat3: "\n        data[offset] = v[0];\n        data[offset+1] = v[1];\n        data[offset+2] = v[2];\n\n        data[offset + 4] = v[3];\n        data[offset + 5] = v[4];\n        data[offset + 6] = v[5];\n\n        data[offset + 8] = v[6];\n        data[offset + 9] = v[7];\n        data[offset + 10] = v[8];\n    ",
  mat4: "\n        for(var i = 0; i < 16; i++)\n        {\n            data[offset + i] = v[i];\n        }\n    "
};
var GLSL_TO_STD40_SIZE = {
  float: 4,
  vec2: 8,
  vec3: 12,
  vec4: 16,
  int: 4,
  ivec2: 8,
  ivec3: 12,
  ivec4: 16,
  uint: 4,
  uvec2: 8,
  uvec3: 12,
  uvec4: 16,
  bool: 4,
  bvec2: 8,
  bvec3: 12,
  bvec4: 16,
  mat2: 16 * 2,
  mat3: 16 * 3,
  mat4: 16 * 4
};
function createUBOElements(uniformData) {
  var uboElements = uniformData.map(function(data) {
    return {
      data,
      offset: 0,
      dataLen: 0,
      dirty: 0
    };
  });
  var size = 0;
  var chunkSize = 0;
  var offset = 0;
  for (var i2 = 0; i2 < uboElements.length; i2++) {
    var uboElement = uboElements[i2];
    size = GLSL_TO_STD40_SIZE[uboElement.data.type];
    if (uboElement.data.size > 1) {
      size = Math.max(size, 16) * uboElement.data.size;
    }
    uboElement.dataLen = size;
    if (chunkSize % size !== 0 && chunkSize < 16) {
      var lineUpValue = chunkSize % size % 16;
      chunkSize += lineUpValue;
      offset += lineUpValue;
    }
    if (chunkSize + size > 16) {
      offset = Math.ceil(offset / 16) * 16;
      uboElement.offset = offset;
      offset += size;
      chunkSize = size;
    } else {
      uboElement.offset = offset;
      chunkSize += size;
      offset += size;
    }
  }
  offset = Math.ceil(offset / 16) * 16;
  return { uboElements, size: offset };
}
function getUBOData(uniforms, uniformData) {
  var usedUniformDatas = [];
  for (var i2 in uniforms) {
    if (uniformData[i2]) {
      usedUniformDatas.push(uniformData[i2]);
    }
  }
  usedUniformDatas.sort(function(a2, b2) {
    return a2.index - b2.index;
  });
  return usedUniformDatas;
}
function generateUniformBufferSync(group, uniformData) {
  if (!group.autoManage) {
    return { size: 0, syncFunc: uboUpdate };
  }
  var usedUniformDatas = getUBOData(group.uniforms, uniformData);
  var _a3 = createUBOElements(usedUniformDatas), uboElements = _a3.uboElements, size = _a3.size;
  var funcFragments = ["\n    var v = null;\n    var v2 = null;\n    var cv = null;\n    var t = 0;\n    var gl = renderer.gl\n    var index = 0;\n    var data = buffer.data;\n    "];
  for (var i2 = 0; i2 < uboElements.length; i2++) {
    var uboElement = uboElements[i2];
    var uniform = group.uniforms[uboElement.data.name];
    var name2 = uboElement.data.name;
    var parsed = false;
    for (var j2 = 0; j2 < uniformParsers.length; j2++) {
      var uniformParser = uniformParsers[j2];
      if (uniformParser.codeUbo && uniformParser.test(uboElement.data, uniform)) {
        funcFragments.push("offset = " + uboElement.offset / 4 + ";", uniformParsers[j2].codeUbo(uboElement.data.name, uniform));
        parsed = true;
        break;
      }
    }
    if (!parsed) {
      if (uboElement.data.size > 1) {
        var size_1 = mapSize(uboElement.data.type);
        var rowSize = Math.max(GLSL_TO_STD40_SIZE[uboElement.data.type] / 16, 1);
        var elementSize = size_1 / rowSize;
        var remainder = (4 - elementSize % 4) % 4;
        funcFragments.push("\n                cv = ud." + name2 + ".value;\n                v = uv." + name2 + ";\n                offset = " + uboElement.offset / 4 + ";\n\n                t = 0;\n\n                for(var i=0; i < " + uboElement.data.size * rowSize + "; i++)\n                {\n                    for(var j = 0; j < " + elementSize + "; j++)\n                    {\n                        data[offset++] = v[t++];\n                    }\n                    offset += " + remainder + ";\n                }\n\n                ");
      } else {
        var template = UBO_TO_SINGLE_SETTERS[uboElement.data.type];
        funcFragments.push("\n                cv = ud." + name2 + ".value;\n                v = uv." + name2 + ";\n                offset = " + uboElement.offset / 4 + ";\n                " + template + ";\n                ");
      }
    }
  }
  funcFragments.push("\n       renderer.buffer.update(buffer);\n    ");
  return {
    size,
    syncFunc: new Function("ud", "uv", "renderer", "syncData", "buffer", funcFragments.join("\n"))
  };
}
var GLProgram = function() {
  function GLProgram2(program, uniformData) {
    this.program = program;
    this.uniformData = uniformData;
    this.uniformGroups = {};
    this.uniformDirtyGroups = {};
    this.uniformBufferBindings = {};
  }
  GLProgram2.prototype.destroy = function() {
    this.uniformData = null;
    this.uniformGroups = null;
    this.uniformDirtyGroups = null;
    this.uniformBufferBindings = null;
    this.program = null;
  };
  return GLProgram2;
}();
function getAttributeData(program, gl) {
  var attributes = {};
  var totalAttributes = gl.getProgramParameter(program, gl.ACTIVE_ATTRIBUTES);
  for (var i2 = 0; i2 < totalAttributes; i2++) {
    var attribData = gl.getActiveAttrib(program, i2);
    if (attribData.name.indexOf("gl_") === 0) {
      continue;
    }
    var type = mapType(gl, attribData.type);
    var data = {
      type,
      name: attribData.name,
      size: mapSize(type),
      location: gl.getAttribLocation(program, attribData.name)
    };
    attributes[attribData.name] = data;
  }
  return attributes;
}
function getUniformData(program, gl) {
  var uniforms = {};
  var totalUniforms = gl.getProgramParameter(program, gl.ACTIVE_UNIFORMS);
  for (var i2 = 0; i2 < totalUniforms; i2++) {
    var uniformData = gl.getActiveUniform(program, i2);
    var name2 = uniformData.name.replace(/\[.*?\]$/, "");
    var isArray2 = !!uniformData.name.match(/\[.*?\]$/);
    var type = mapType(gl, uniformData.type);
    uniforms[name2] = {
      name: name2,
      index: i2,
      type,
      size: uniformData.size,
      isArray: isArray2,
      value: defaultValue(type, uniformData.size)
    };
  }
  return uniforms;
}
function generateProgram(gl, program) {
  var glVertShader = compileShader(gl, gl.VERTEX_SHADER, program.vertexSrc);
  var glFragShader = compileShader(gl, gl.FRAGMENT_SHADER, program.fragmentSrc);
  var webGLProgram = gl.createProgram();
  gl.attachShader(webGLProgram, glVertShader);
  gl.attachShader(webGLProgram, glFragShader);
  gl.linkProgram(webGLProgram);
  if (!gl.getProgramParameter(webGLProgram, gl.LINK_STATUS)) {
    logProgramError(gl, webGLProgram, glVertShader, glFragShader);
  }
  program.attributeData = getAttributeData(webGLProgram, gl);
  program.uniformData = getUniformData(webGLProgram, gl);
  if (!/^[ \t]*#[ \t]*version[ \t]+300[ \t]+es[ \t]*$/m.test(program.vertexSrc)) {
    var keys = Object.keys(program.attributeData);
    keys.sort(function(a2, b2) {
      return a2 > b2 ? 1 : -1;
    });
    for (var i2 = 0; i2 < keys.length; i2++) {
      program.attributeData[keys[i2]].location = i2;
      gl.bindAttribLocation(webGLProgram, i2, keys[i2]);
    }
    gl.linkProgram(webGLProgram);
  }
  gl.deleteShader(glVertShader);
  gl.deleteShader(glFragShader);
  var uniformData = {};
  for (var i2 in program.uniformData) {
    var data = program.uniformData[i2];
    uniformData[i2] = {
      location: gl.getUniformLocation(webGLProgram, i2),
      value: defaultValue(data.type, data.size)
    };
  }
  var glProgram = new GLProgram(webGLProgram, uniformData);
  return glProgram;
}
var UID$4 = 0;
var defaultSyncData = { textureCount: 0, uboCount: 0 };
var ShaderSystem = function() {
  function ShaderSystem2(renderer) {
    this.destroyed = false;
    this.renderer = renderer;
    this.systemCheck();
    this.gl = null;
    this.shader = null;
    this.program = null;
    this.cache = {};
    this._uboCache = {};
    this.id = UID$4++;
  }
  ShaderSystem2.prototype.systemCheck = function() {
    if (!unsafeEvalSupported()) {
      throw new Error("Current environment does not allow unsafe-eval, please use @pixi/unsafe-eval module to enable support.");
    }
  };
  ShaderSystem2.prototype.contextChange = function(gl) {
    this.gl = gl;
    this.reset();
  };
  ShaderSystem2.prototype.bind = function(shader, dontSync) {
    shader.uniforms.globals = this.renderer.globalUniforms;
    var program = shader.program;
    var glProgram = program.glPrograms[this.renderer.CONTEXT_UID] || this.generateProgram(shader);
    this.shader = shader;
    if (this.program !== program) {
      this.program = program;
      this.gl.useProgram(glProgram.program);
    }
    if (!dontSync) {
      defaultSyncData.textureCount = 0;
      defaultSyncData.uboCount = 0;
      this.syncUniformGroup(shader.uniformGroup, defaultSyncData);
    }
    return glProgram;
  };
  ShaderSystem2.prototype.setUniforms = function(uniforms) {
    var shader = this.shader.program;
    var glProgram = shader.glPrograms[this.renderer.CONTEXT_UID];
    shader.syncUniforms(glProgram.uniformData, uniforms, this.renderer);
  };
  ShaderSystem2.prototype.syncUniformGroup = function(group, syncData) {
    var glProgram = this.getGlProgram();
    if (!group.static || group.dirtyId !== glProgram.uniformDirtyGroups[group.id]) {
      glProgram.uniformDirtyGroups[group.id] = group.dirtyId;
      this.syncUniforms(group, glProgram, syncData);
    }
  };
  ShaderSystem2.prototype.syncUniforms = function(group, glProgram, syncData) {
    var syncFunc = group.syncUniforms[this.shader.program.id] || this.createSyncGroups(group);
    syncFunc(glProgram.uniformData, group.uniforms, this.renderer, syncData);
  };
  ShaderSystem2.prototype.createSyncGroups = function(group) {
    var id = this.getSignature(group, this.shader.program.uniformData, "u");
    if (!this.cache[id]) {
      this.cache[id] = generateUniformsSync(group, this.shader.program.uniformData);
    }
    group.syncUniforms[this.shader.program.id] = this.cache[id];
    return group.syncUniforms[this.shader.program.id];
  };
  ShaderSystem2.prototype.syncUniformBufferGroup = function(group, name2) {
    var glProgram = this.getGlProgram();
    if (!group.static || group.dirtyId !== 0 || !glProgram.uniformGroups[group.id]) {
      group.dirtyId = 0;
      var syncFunc = glProgram.uniformGroups[group.id] || this.createSyncBufferGroup(group, glProgram, name2);
      group.buffer.update();
      syncFunc(glProgram.uniformData, group.uniforms, this.renderer, defaultSyncData, group.buffer);
    }
    this.renderer.buffer.bindBufferBase(group.buffer, glProgram.uniformBufferBindings[name2]);
  };
  ShaderSystem2.prototype.createSyncBufferGroup = function(group, glProgram, name2) {
    var gl = this.renderer.gl;
    this.renderer.buffer.bind(group.buffer);
    var uniformBlockIndex = this.gl.getUniformBlockIndex(glProgram.program, name2);
    glProgram.uniformBufferBindings[name2] = this.shader.uniformBindCount;
    gl.uniformBlockBinding(glProgram.program, uniformBlockIndex, this.shader.uniformBindCount);
    this.shader.uniformBindCount++;
    var id = this.getSignature(group, this.shader.program.uniformData, "ubo");
    var uboData = this._uboCache[id];
    if (!uboData) {
      uboData = this._uboCache[id] = generateUniformBufferSync(group, this.shader.program.uniformData);
    }
    if (group.autoManage) {
      var data = new Float32Array(uboData.size / 4);
      group.buffer.update(data);
    }
    glProgram.uniformGroups[group.id] = uboData.syncFunc;
    return glProgram.uniformGroups[group.id];
  };
  ShaderSystem2.prototype.getSignature = function(group, uniformData, preFix) {
    var uniforms = group.uniforms;
    var strings = [preFix + "-"];
    for (var i2 in uniforms) {
      strings.push(i2);
      if (uniformData[i2]) {
        strings.push(uniformData[i2].type);
      }
    }
    return strings.join("-");
  };
  ShaderSystem2.prototype.getGlProgram = function() {
    if (this.shader) {
      return this.shader.program.glPrograms[this.renderer.CONTEXT_UID];
    }
    return null;
  };
  ShaderSystem2.prototype.generateProgram = function(shader) {
    var gl = this.gl;
    var program = shader.program;
    var glProgram = generateProgram(gl, program);
    program.glPrograms[this.renderer.CONTEXT_UID] = glProgram;
    return glProgram;
  };
  ShaderSystem2.prototype.reset = function() {
    this.program = null;
    this.shader = null;
  };
  ShaderSystem2.prototype.destroy = function() {
    this.renderer = null;
    this.destroyed = true;
  };
  return ShaderSystem2;
}();
function mapWebGLBlendModesToPixi(gl, array) {
  if (array === void 0) {
    array = [];
  }
  array[BLEND_MODES$3.NORMAL] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
  array[BLEND_MODES$3.ADD] = [gl.ONE, gl.ONE];
  array[BLEND_MODES$3.MULTIPLY] = [gl.DST_COLOR, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
  array[BLEND_MODES$3.SCREEN] = [gl.ONE, gl.ONE_MINUS_SRC_COLOR, gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
  array[BLEND_MODES$3.OVERLAY] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
  array[BLEND_MODES$3.DARKEN] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
  array[BLEND_MODES$3.LIGHTEN] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
  array[BLEND_MODES$3.COLOR_DODGE] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
  array[BLEND_MODES$3.COLOR_BURN] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
  array[BLEND_MODES$3.HARD_LIGHT] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
  array[BLEND_MODES$3.SOFT_LIGHT] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
  array[BLEND_MODES$3.DIFFERENCE] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
  array[BLEND_MODES$3.EXCLUSION] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
  array[BLEND_MODES$3.HUE] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
  array[BLEND_MODES$3.SATURATION] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
  array[BLEND_MODES$3.COLOR] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
  array[BLEND_MODES$3.LUMINOSITY] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
  array[BLEND_MODES$3.NONE] = [0, 0];
  array[BLEND_MODES$3.NORMAL_NPM] = [gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
  array[BLEND_MODES$3.ADD_NPM] = [gl.SRC_ALPHA, gl.ONE, gl.ONE, gl.ONE];
  array[BLEND_MODES$3.SCREEN_NPM] = [gl.SRC_ALPHA, gl.ONE_MINUS_SRC_COLOR, gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
  array[BLEND_MODES$3.SRC_IN] = [gl.DST_ALPHA, gl.ZERO];
  array[BLEND_MODES$3.SRC_OUT] = [gl.ONE_MINUS_DST_ALPHA, gl.ZERO];
  array[BLEND_MODES$3.SRC_ATOP] = [gl.DST_ALPHA, gl.ONE_MINUS_SRC_ALPHA];
  array[BLEND_MODES$3.DST_OVER] = [gl.ONE_MINUS_DST_ALPHA, gl.ONE];
  array[BLEND_MODES$3.DST_IN] = [gl.ZERO, gl.SRC_ALPHA];
  array[BLEND_MODES$3.DST_OUT] = [gl.ZERO, gl.ONE_MINUS_SRC_ALPHA];
  array[BLEND_MODES$3.DST_ATOP] = [gl.ONE_MINUS_DST_ALPHA, gl.SRC_ALPHA];
  array[BLEND_MODES$3.XOR] = [gl.ONE_MINUS_DST_ALPHA, gl.ONE_MINUS_SRC_ALPHA];
  array[BLEND_MODES$3.SUBTRACT] = [gl.ONE, gl.ONE, gl.ONE, gl.ONE, gl.FUNC_REVERSE_SUBTRACT, gl.FUNC_ADD];
  return array;
}
var BLEND$1 = 0;
var OFFSET$1 = 1;
var CULLING$1 = 2;
var DEPTH_TEST$1 = 3;
var WINDING$1 = 4;
var DEPTH_MASK$1 = 5;
var StateSystem = function() {
  function StateSystem2() {
    this.gl = null;
    this.stateId = 0;
    this.polygonOffset = 0;
    this.blendMode = BLEND_MODES$3.NONE;
    this._blendEq = false;
    this.map = [];
    this.map[BLEND$1] = this.setBlend;
    this.map[OFFSET$1] = this.setOffset;
    this.map[CULLING$1] = this.setCullFace;
    this.map[DEPTH_TEST$1] = this.setDepthTest;
    this.map[WINDING$1] = this.setFrontFace;
    this.map[DEPTH_MASK$1] = this.setDepthMask;
    this.checks = [];
    this.defaultState = new State();
    this.defaultState.blend = true;
  }
  StateSystem2.prototype.contextChange = function(gl) {
    this.gl = gl;
    this.blendModes = mapWebGLBlendModesToPixi(gl);
    this.set(this.defaultState);
    this.reset();
  };
  StateSystem2.prototype.set = function(state) {
    state = state || this.defaultState;
    if (this.stateId !== state.data) {
      var diff2 = this.stateId ^ state.data;
      var i2 = 0;
      while (diff2) {
        if (diff2 & 1) {
          this.map[i2].call(this, !!(state.data & 1 << i2));
        }
        diff2 = diff2 >> 1;
        i2++;
      }
      this.stateId = state.data;
    }
    for (var i2 = 0; i2 < this.checks.length; i2++) {
      this.checks[i2](this, state);
    }
  };
  StateSystem2.prototype.forceState = function(state) {
    state = state || this.defaultState;
    for (var i2 = 0; i2 < this.map.length; i2++) {
      this.map[i2].call(this, !!(state.data & 1 << i2));
    }
    for (var i2 = 0; i2 < this.checks.length; i2++) {
      this.checks[i2](this, state);
    }
    this.stateId = state.data;
  };
  StateSystem2.prototype.setBlend = function(value) {
    this.updateCheck(StateSystem2.checkBlendMode, value);
    this.gl[value ? "enable" : "disable"](this.gl.BLEND);
  };
  StateSystem2.prototype.setOffset = function(value) {
    this.updateCheck(StateSystem2.checkPolygonOffset, value);
    this.gl[value ? "enable" : "disable"](this.gl.POLYGON_OFFSET_FILL);
  };
  StateSystem2.prototype.setDepthTest = function(value) {
    this.gl[value ? "enable" : "disable"](this.gl.DEPTH_TEST);
  };
  StateSystem2.prototype.setDepthMask = function(value) {
    this.gl.depthMask(value);
  };
  StateSystem2.prototype.setCullFace = function(value) {
    this.gl[value ? "enable" : "disable"](this.gl.CULL_FACE);
  };
  StateSystem2.prototype.setFrontFace = function(value) {
    this.gl.frontFace(this.gl[value ? "CW" : "CCW"]);
  };
  StateSystem2.prototype.setBlendMode = function(value) {
    if (value === this.blendMode) {
      return;
    }
    this.blendMode = value;
    var mode = this.blendModes[value];
    var gl = this.gl;
    if (mode.length === 2) {
      gl.blendFunc(mode[0], mode[1]);
    } else {
      gl.blendFuncSeparate(mode[0], mode[1], mode[2], mode[3]);
    }
    if (mode.length === 6) {
      this._blendEq = true;
      gl.blendEquationSeparate(mode[4], mode[5]);
    } else if (this._blendEq) {
      this._blendEq = false;
      gl.blendEquationSeparate(gl.FUNC_ADD, gl.FUNC_ADD);
    }
  };
  StateSystem2.prototype.setPolygonOffset = function(value, scale) {
    this.gl.polygonOffset(value, scale);
  };
  StateSystem2.prototype.reset = function() {
    this.gl.pixelStorei(this.gl.UNPACK_FLIP_Y_WEBGL, false);
    this.forceState(this.defaultState);
    this._blendEq = true;
    this.blendMode = -1;
    this.setBlendMode(0);
  };
  StateSystem2.prototype.updateCheck = function(func, value) {
    var index = this.checks.indexOf(func);
    if (value && index === -1) {
      this.checks.push(func);
    } else if (!value && index !== -1) {
      this.checks.splice(index, 1);
    }
  };
  StateSystem2.checkBlendMode = function(system, state) {
    system.setBlendMode(state.blendMode);
  };
  StateSystem2.checkPolygonOffset = function(system, state) {
    system.setPolygonOffset(1, state.polygonOffset);
  };
  StateSystem2.prototype.destroy = function() {
    this.gl = null;
  };
  return StateSystem2;
}();
var TextureGCSystem = function() {
  function TextureGCSystem2(renderer) {
    this.renderer = renderer;
    this.count = 0;
    this.checkCount = 0;
    this.maxIdle = settings.GC_MAX_IDLE;
    this.checkCountMax = settings.GC_MAX_CHECK_COUNT;
    this.mode = settings.GC_MODE;
  }
  TextureGCSystem2.prototype.postrender = function() {
    if (!this.renderer.renderingToScreen) {
      return;
    }
    this.count++;
    if (this.mode === GC_MODES$3.MANUAL) {
      return;
    }
    this.checkCount++;
    if (this.checkCount > this.checkCountMax) {
      this.checkCount = 0;
      this.run();
    }
  };
  TextureGCSystem2.prototype.run = function() {
    var tm = this.renderer.texture;
    var managedTextures = tm.managedTextures;
    var wasRemoved = false;
    for (var i2 = 0; i2 < managedTextures.length; i2++) {
      var texture = managedTextures[i2];
      if (!texture.framebuffer && this.count - texture.touched > this.maxIdle) {
        tm.destroyTexture(texture, true);
        managedTextures[i2] = null;
        wasRemoved = true;
      }
    }
    if (wasRemoved) {
      var j2 = 0;
      for (var i2 = 0; i2 < managedTextures.length; i2++) {
        if (managedTextures[i2] !== null) {
          managedTextures[j2++] = managedTextures[i2];
        }
      }
      managedTextures.length = j2;
    }
  };
  TextureGCSystem2.prototype.unload = function(displayObject) {
    var tm = this.renderer.texture;
    var texture = displayObject._texture;
    if (texture && !texture.framebuffer) {
      tm.destroyTexture(texture);
    }
    for (var i2 = displayObject.children.length - 1; i2 >= 0; i2--) {
      this.unload(displayObject.children[i2]);
    }
  };
  TextureGCSystem2.prototype.destroy = function() {
    this.renderer = null;
  };
  return TextureGCSystem2;
}();
function mapTypeAndFormatToInternalFormat(gl) {
  var _a3, _b3, _c3, _d2, _e, _f, _g, _h, _j, _k, _l2, _m, _o, _p2, _q, _r2, _s, _t, _u, _v, _w, _x;
  var table;
  if ("WebGL2RenderingContext" in globalThis && gl instanceof globalThis.WebGL2RenderingContext) {
    table = (_a3 = {}, _a3[TYPES$3.UNSIGNED_BYTE] = (_b3 = {}, _b3[FORMATS$3.RGBA] = gl.RGBA8, _b3[FORMATS$3.RGB] = gl.RGB8, _b3[FORMATS$3.RG] = gl.RG8, _b3[FORMATS$3.RED] = gl.R8, _b3[FORMATS$3.RGBA_INTEGER] = gl.RGBA8UI, _b3[FORMATS$3.RGB_INTEGER] = gl.RGB8UI, _b3[FORMATS$3.RG_INTEGER] = gl.RG8UI, _b3[FORMATS$3.RED_INTEGER] = gl.R8UI, _b3[FORMATS$3.ALPHA] = gl.ALPHA, _b3[FORMATS$3.LUMINANCE] = gl.LUMINANCE, _b3[FORMATS$3.LUMINANCE_ALPHA] = gl.LUMINANCE_ALPHA, _b3), _a3[TYPES$3.BYTE] = (_c3 = {}, _c3[FORMATS$3.RGBA] = gl.RGBA8_SNORM, _c3[FORMATS$3.RGB] = gl.RGB8_SNORM, _c3[FORMATS$3.RG] = gl.RG8_SNORM, _c3[FORMATS$3.RED] = gl.R8_SNORM, _c3[FORMATS$3.RGBA_INTEGER] = gl.RGBA8I, _c3[FORMATS$3.RGB_INTEGER] = gl.RGB8I, _c3[FORMATS$3.RG_INTEGER] = gl.RG8I, _c3[FORMATS$3.RED_INTEGER] = gl.R8I, _c3), _a3[TYPES$3.UNSIGNED_SHORT] = (_d2 = {}, _d2[FORMATS$3.RGBA_INTEGER] = gl.RGBA16UI, _d2[FORMATS$3.RGB_INTEGER] = gl.RGB16UI, _d2[FORMATS$3.RG_INTEGER] = gl.RG16UI, _d2[FORMATS$3.RED_INTEGER] = gl.R16UI, _d2[FORMATS$3.DEPTH_COMPONENT] = gl.DEPTH_COMPONENT16, _d2), _a3[TYPES$3.SHORT] = (_e = {}, _e[FORMATS$3.RGBA_INTEGER] = gl.RGBA16I, _e[FORMATS$3.RGB_INTEGER] = gl.RGB16I, _e[FORMATS$3.RG_INTEGER] = gl.RG16I, _e[FORMATS$3.RED_INTEGER] = gl.R16I, _e), _a3[TYPES$3.UNSIGNED_INT] = (_f = {}, _f[FORMATS$3.RGBA_INTEGER] = gl.RGBA32UI, _f[FORMATS$3.RGB_INTEGER] = gl.RGB32UI, _f[FORMATS$3.RG_INTEGER] = gl.RG32UI, _f[FORMATS$3.RED_INTEGER] = gl.R32UI, _f[FORMATS$3.DEPTH_COMPONENT] = gl.DEPTH_COMPONENT24, _f), _a3[TYPES$3.INT] = (_g = {}, _g[FORMATS$3.RGBA_INTEGER] = gl.RGBA32I, _g[FORMATS$3.RGB_INTEGER] = gl.RGB32I, _g[FORMATS$3.RG_INTEGER] = gl.RG32I, _g[FORMATS$3.RED_INTEGER] = gl.R32I, _g), _a3[TYPES$3.FLOAT] = (_h = {}, _h[FORMATS$3.RGBA] = gl.RGBA32F, _h[FORMATS$3.RGB] = gl.RGB32F, _h[FORMATS$3.RG] = gl.RG32F, _h[FORMATS$3.RED] = gl.R32F, _h[FORMATS$3.DEPTH_COMPONENT] = gl.DEPTH_COMPONENT32F, _h), _a3[TYPES$3.HALF_FLOAT] = (_j = {}, _j[FORMATS$3.RGBA] = gl.RGBA16F, _j[FORMATS$3.RGB] = gl.RGB16F, _j[FORMATS$3.RG] = gl.RG16F, _j[FORMATS$3.RED] = gl.R16F, _j), _a3[TYPES$3.UNSIGNED_SHORT_5_6_5] = (_k = {}, _k[FORMATS$3.RGB] = gl.RGB565, _k), _a3[TYPES$3.UNSIGNED_SHORT_4_4_4_4] = (_l2 = {}, _l2[FORMATS$3.RGBA] = gl.RGBA4, _l2), _a3[TYPES$3.UNSIGNED_SHORT_5_5_5_1] = (_m = {}, _m[FORMATS$3.RGBA] = gl.RGB5_A1, _m), _a3[TYPES$3.UNSIGNED_INT_2_10_10_10_REV] = (_o = {}, _o[FORMATS$3.RGBA] = gl.RGB10_A2, _o[FORMATS$3.RGBA_INTEGER] = gl.RGB10_A2UI, _o), _a3[TYPES$3.UNSIGNED_INT_10F_11F_11F_REV] = (_p2 = {}, _p2[FORMATS$3.RGB] = gl.R11F_G11F_B10F, _p2), _a3[TYPES$3.UNSIGNED_INT_5_9_9_9_REV] = (_q = {}, _q[FORMATS$3.RGB] = gl.RGB9_E5, _q), _a3[TYPES$3.UNSIGNED_INT_24_8] = (_r2 = {}, _r2[FORMATS$3.DEPTH_STENCIL] = gl.DEPTH24_STENCIL8, _r2), _a3[TYPES$3.FLOAT_32_UNSIGNED_INT_24_8_REV] = (_s = {}, _s[FORMATS$3.DEPTH_STENCIL] = gl.DEPTH32F_STENCIL8, _s), _a3);
  } else {
    table = (_t = {}, _t[TYPES$3.UNSIGNED_BYTE] = (_u = {}, _u[FORMATS$3.RGBA] = gl.RGBA, _u[FORMATS$3.RGB] = gl.RGB, _u[FORMATS$3.ALPHA] = gl.ALPHA, _u[FORMATS$3.LUMINANCE] = gl.LUMINANCE, _u[FORMATS$3.LUMINANCE_ALPHA] = gl.LUMINANCE_ALPHA, _u), _t[TYPES$3.UNSIGNED_SHORT_5_6_5] = (_v = {}, _v[FORMATS$3.RGB] = gl.RGB, _v), _t[TYPES$3.UNSIGNED_SHORT_4_4_4_4] = (_w = {}, _w[FORMATS$3.RGBA] = gl.RGBA, _w), _t[TYPES$3.UNSIGNED_SHORT_5_5_5_1] = (_x = {}, _x[FORMATS$3.RGBA] = gl.RGBA, _x), _t);
  }
  return table;
}
var GLTexture = function() {
  function GLTexture2(texture) {
    this.texture = texture;
    this.width = -1;
    this.height = -1;
    this.dirtyId = -1;
    this.dirtyStyleId = -1;
    this.mipmap = false;
    this.wrapMode = 33071;
    this.type = TYPES$3.UNSIGNED_BYTE;
    this.internalFormat = FORMATS$3.RGBA;
    this.samplerType = 0;
  }
  return GLTexture2;
}();
var TextureSystem = function() {
  function TextureSystem2(renderer) {
    this.renderer = renderer;
    this.boundTextures = [];
    this.currentLocation = -1;
    this.managedTextures = [];
    this._unknownBoundTextures = false;
    this.unknownTexture = new BaseTexture();
    this.hasIntegerTextures = false;
  }
  TextureSystem2.prototype.contextChange = function() {
    var gl = this.gl = this.renderer.gl;
    this.CONTEXT_UID = this.renderer.CONTEXT_UID;
    this.webGLVersion = this.renderer.context.webGLVersion;
    this.internalFormats = mapTypeAndFormatToInternalFormat(gl);
    var maxTextures = gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS);
    this.boundTextures.length = maxTextures;
    for (var i2 = 0; i2 < maxTextures; i2++) {
      this.boundTextures[i2] = null;
    }
    this.emptyTextures = {};
    var emptyTexture2D = new GLTexture(gl.createTexture());
    gl.bindTexture(gl.TEXTURE_2D, emptyTexture2D.texture);
    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, new Uint8Array(4));
    this.emptyTextures[gl.TEXTURE_2D] = emptyTexture2D;
    this.emptyTextures[gl.TEXTURE_CUBE_MAP] = new GLTexture(gl.createTexture());
    gl.bindTexture(gl.TEXTURE_CUBE_MAP, this.emptyTextures[gl.TEXTURE_CUBE_MAP].texture);
    for (var i2 = 0; i2 < 6; i2++) {
      gl.texImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + i2, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);
    }
    gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
    gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
    for (var i2 = 0; i2 < this.boundTextures.length; i2++) {
      this.bind(null, i2);
    }
  };
  TextureSystem2.prototype.bind = function(texture, location2) {
    if (location2 === void 0) {
      location2 = 0;
    }
    var gl = this.gl;
    texture = texture === null || texture === void 0 ? void 0 : texture.castToBaseTexture();
    if (texture && texture.valid && !texture.parentTextureArray) {
      texture.touched = this.renderer.textureGC.count;
      var glTexture = texture._glTextures[this.CONTEXT_UID] || this.initTexture(texture);
      if (this.boundTextures[location2] !== texture) {
        if (this.currentLocation !== location2) {
          this.currentLocation = location2;
          gl.activeTexture(gl.TEXTURE0 + location2);
        }
        gl.bindTexture(texture.target, glTexture.texture);
      }
      if (glTexture.dirtyId !== texture.dirtyId) {
        if (this.currentLocation !== location2) {
          this.currentLocation = location2;
          gl.activeTexture(gl.TEXTURE0 + location2);
        }
        this.updateTexture(texture);
      }
      this.boundTextures[location2] = texture;
    } else {
      if (this.currentLocation !== location2) {
        this.currentLocation = location2;
        gl.activeTexture(gl.TEXTURE0 + location2);
      }
      gl.bindTexture(gl.TEXTURE_2D, this.emptyTextures[gl.TEXTURE_2D].texture);
      this.boundTextures[location2] = null;
    }
  };
  TextureSystem2.prototype.reset = function() {
    this._unknownBoundTextures = true;
    this.hasIntegerTextures = false;
    this.currentLocation = -1;
    for (var i2 = 0; i2 < this.boundTextures.length; i2++) {
      this.boundTextures[i2] = this.unknownTexture;
    }
  };
  TextureSystem2.prototype.unbind = function(texture) {
    var _a3 = this, gl = _a3.gl, boundTextures = _a3.boundTextures;
    if (this._unknownBoundTextures) {
      this._unknownBoundTextures = false;
      for (var i2 = 0; i2 < boundTextures.length; i2++) {
        if (boundTextures[i2] === this.unknownTexture) {
          this.bind(null, i2);
        }
      }
    }
    for (var i2 = 0; i2 < boundTextures.length; i2++) {
      if (boundTextures[i2] === texture) {
        if (this.currentLocation !== i2) {
          gl.activeTexture(gl.TEXTURE0 + i2);
          this.currentLocation = i2;
        }
        gl.bindTexture(texture.target, this.emptyTextures[texture.target].texture);
        boundTextures[i2] = null;
      }
    }
  };
  TextureSystem2.prototype.ensureSamplerType = function(maxTextures) {
    var _a3 = this, boundTextures = _a3.boundTextures, hasIntegerTextures = _a3.hasIntegerTextures, CONTEXT_UID = _a3.CONTEXT_UID;
    if (!hasIntegerTextures) {
      return;
    }
    for (var i2 = maxTextures - 1; i2 >= 0; --i2) {
      var tex = boundTextures[i2];
      if (tex) {
        var glTexture = tex._glTextures[CONTEXT_UID];
        if (glTexture.samplerType !== SAMPLER_TYPES$3.FLOAT) {
          this.renderer.texture.unbind(tex);
        }
      }
    }
  };
  TextureSystem2.prototype.initTexture = function(texture) {
    var glTexture = new GLTexture(this.gl.createTexture());
    glTexture.dirtyId = -1;
    texture._glTextures[this.CONTEXT_UID] = glTexture;
    this.managedTextures.push(texture);
    texture.on("dispose", this.destroyTexture, this);
    return glTexture;
  };
  TextureSystem2.prototype.initTextureType = function(texture, glTexture) {
    var _a3, _b3;
    glTexture.internalFormat = (_b3 = (_a3 = this.internalFormats[texture.type]) === null || _a3 === void 0 ? void 0 : _a3[texture.format]) !== null && _b3 !== void 0 ? _b3 : texture.format;
    if (this.webGLVersion === 2 && texture.type === TYPES$3.HALF_FLOAT) {
      glTexture.type = this.gl.HALF_FLOAT;
    } else {
      glTexture.type = texture.type;
    }
  };
  TextureSystem2.prototype.updateTexture = function(texture) {
    var glTexture = texture._glTextures[this.CONTEXT_UID];
    if (!glTexture) {
      return;
    }
    var renderer = this.renderer;
    this.initTextureType(texture, glTexture);
    if (texture.resource && texture.resource.upload(renderer, texture, glTexture)) {
      if (glTexture.samplerType !== SAMPLER_TYPES$3.FLOAT) {
        this.hasIntegerTextures = true;
      }
    } else {
      var width = texture.realWidth;
      var height = texture.realHeight;
      var gl = renderer.gl;
      if (glTexture.width !== width || glTexture.height !== height || glTexture.dirtyId < 0) {
        glTexture.width = width;
        glTexture.height = height;
        gl.texImage2D(texture.target, 0, glTexture.internalFormat, width, height, 0, texture.format, glTexture.type, null);
      }
    }
    if (texture.dirtyStyleId !== glTexture.dirtyStyleId) {
      this.updateTextureStyle(texture);
    }
    glTexture.dirtyId = texture.dirtyId;
  };
  TextureSystem2.prototype.destroyTexture = function(texture, skipRemove) {
    var gl = this.gl;
    texture = texture.castToBaseTexture();
    if (texture._glTextures[this.CONTEXT_UID]) {
      this.unbind(texture);
      gl.deleteTexture(texture._glTextures[this.CONTEXT_UID].texture);
      texture.off("dispose", this.destroyTexture, this);
      delete texture._glTextures[this.CONTEXT_UID];
      if (!skipRemove) {
        var i2 = this.managedTextures.indexOf(texture);
        if (i2 !== -1) {
          removeItems(this.managedTextures, i2, 1);
        }
      }
    }
  };
  TextureSystem2.prototype.updateTextureStyle = function(texture) {
    var glTexture = texture._glTextures[this.CONTEXT_UID];
    if (!glTexture) {
      return;
    }
    if ((texture.mipmap === MIPMAP_MODES$3.POW2 || this.webGLVersion !== 2) && !texture.isPowerOfTwo) {
      glTexture.mipmap = false;
    } else {
      glTexture.mipmap = texture.mipmap >= 1;
    }
    if (this.webGLVersion !== 2 && !texture.isPowerOfTwo) {
      glTexture.wrapMode = WRAP_MODES$3.CLAMP;
    } else {
      glTexture.wrapMode = texture.wrapMode;
    }
    if (texture.resource && texture.resource.style(this.renderer, texture, glTexture))
      ;
    else {
      this.setStyle(texture, glTexture);
    }
    glTexture.dirtyStyleId = texture.dirtyStyleId;
  };
  TextureSystem2.prototype.setStyle = function(texture, glTexture) {
    var gl = this.gl;
    if (glTexture.mipmap && texture.mipmap !== MIPMAP_MODES$3.ON_MANUAL) {
      gl.generateMipmap(texture.target);
    }
    gl.texParameteri(texture.target, gl.TEXTURE_WRAP_S, glTexture.wrapMode);
    gl.texParameteri(texture.target, gl.TEXTURE_WRAP_T, glTexture.wrapMode);
    if (glTexture.mipmap) {
      gl.texParameteri(texture.target, gl.TEXTURE_MIN_FILTER, texture.scaleMode === SCALE_MODES$3.LINEAR ? gl.LINEAR_MIPMAP_LINEAR : gl.NEAREST_MIPMAP_NEAREST);
      var anisotropicExt = this.renderer.context.extensions.anisotropicFiltering;
      if (anisotropicExt && texture.anisotropicLevel > 0 && texture.scaleMode === SCALE_MODES$3.LINEAR) {
        var level = Math.min(texture.anisotropicLevel, gl.getParameter(anisotropicExt.MAX_TEXTURE_MAX_ANISOTROPY_EXT));
        gl.texParameterf(texture.target, anisotropicExt.TEXTURE_MAX_ANISOTROPY_EXT, level);
      }
    } else {
      gl.texParameteri(texture.target, gl.TEXTURE_MIN_FILTER, texture.scaleMode === SCALE_MODES$3.LINEAR ? gl.LINEAR : gl.NEAREST);
    }
    gl.texParameteri(texture.target, gl.TEXTURE_MAG_FILTER, texture.scaleMode === SCALE_MODES$3.LINEAR ? gl.LINEAR : gl.NEAREST);
  };
  TextureSystem2.prototype.destroy = function() {
    this.renderer = null;
  };
  return TextureSystem2;
}();
var _systems = {
  __proto__: null,
  FilterSystem,
  BatchSystem,
  ContextSystem,
  FramebufferSystem,
  GeometrySystem,
  MaskSystem,
  ScissorSystem,
  StencilSystem,
  ProjectionSystem,
  RenderTextureSystem,
  ShaderSystem,
  StateSystem,
  TextureGCSystem,
  TextureSystem
};
var tempMatrix$2 = new Matrix();
var AbstractRenderer = function(_super) {
  __extends$q(AbstractRenderer2, _super);
  function AbstractRenderer2(type, options) {
    if (type === void 0) {
      type = RENDERER_TYPE$3.UNKNOWN;
    }
    var _this = _super.call(this) || this;
    options = Object.assign({}, settings.RENDER_OPTIONS, options);
    _this.options = options;
    _this.type = type;
    _this.screen = new Rectangle(0, 0, options.width, options.height);
    _this.view = options.view || document.createElement("canvas");
    _this.resolution = options.resolution || settings.RESOLUTION;
    _this.useContextAlpha = options.useContextAlpha;
    _this.autoDensity = !!options.autoDensity;
    _this.preserveDrawingBuffer = options.preserveDrawingBuffer;
    _this.clearBeforeRender = options.clearBeforeRender;
    _this._backgroundColor = 0;
    _this._backgroundColorRgba = [0, 0, 0, 1];
    _this._backgroundColorString = "#000000";
    _this.backgroundColor = options.backgroundColor || _this._backgroundColor;
    _this.backgroundAlpha = options.backgroundAlpha;
    if (options.transparent !== void 0) {
      deprecation("6.0.0", "Option transparent is deprecated, please use backgroundAlpha instead.");
      _this.useContextAlpha = options.transparent;
      _this.backgroundAlpha = options.transparent ? 0 : 1;
    }
    _this._lastObjectRendered = null;
    _this.plugins = {};
    return _this;
  }
  AbstractRenderer2.prototype.initPlugins = function(staticMap) {
    for (var o in staticMap) {
      this.plugins[o] = new staticMap[o](this);
    }
  };
  Object.defineProperty(AbstractRenderer2.prototype, "width", {
    get: function() {
      return this.view.width;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(AbstractRenderer2.prototype, "height", {
    get: function() {
      return this.view.height;
    },
    enumerable: false,
    configurable: true
  });
  AbstractRenderer2.prototype.resize = function(desiredScreenWidth, desiredScreenHeight) {
    this.view.width = Math.round(desiredScreenWidth * this.resolution);
    this.view.height = Math.round(desiredScreenHeight * this.resolution);
    var screenWidth = this.view.width / this.resolution;
    var screenHeight = this.view.height / this.resolution;
    this.screen.width = screenWidth;
    this.screen.height = screenHeight;
    if (this.autoDensity) {
      this.view.style.width = screenWidth + "px";
      this.view.style.height = screenHeight + "px";
    }
    this.emit("resize", screenWidth, screenHeight);
  };
  AbstractRenderer2.prototype.generateTexture = function(displayObject, options, resolution, region) {
    if (options === void 0) {
      options = {};
    }
    if (typeof options === "number") {
      deprecation("6.1.0", "generateTexture options (scaleMode, resolution, region) are now object options.");
      options = { scaleMode: options, resolution, region };
    }
    var manualRegion = options.region, textureOptions = __rest$3(options, ["region"]);
    region = manualRegion || displayObject.getLocalBounds(null, true);
    if (region.width === 0) {
      region.width = 1;
    }
    if (region.height === 0) {
      region.height = 1;
    }
    var renderTexture = RenderTexture.create(__assign$8({ width: region.width, height: region.height }, textureOptions));
    tempMatrix$2.tx = -region.x;
    tempMatrix$2.ty = -region.y;
    this.render(displayObject, {
      renderTexture,
      clear: false,
      transform: tempMatrix$2,
      skipUpdateTransform: !!displayObject.parent
    });
    return renderTexture;
  };
  AbstractRenderer2.prototype.destroy = function(removeView) {
    for (var o in this.plugins) {
      this.plugins[o].destroy();
      this.plugins[o] = null;
    }
    if (removeView && this.view.parentNode) {
      this.view.parentNode.removeChild(this.view);
    }
    var thisAny = this;
    thisAny.plugins = null;
    thisAny.type = RENDERER_TYPE$3.UNKNOWN;
    thisAny.view = null;
    thisAny.screen = null;
    thisAny._tempDisplayObjectParent = null;
    thisAny.options = null;
    this._backgroundColorRgba = null;
    this._backgroundColorString = null;
    this._lastObjectRendered = null;
  };
  Object.defineProperty(AbstractRenderer2.prototype, "backgroundColor", {
    get: function() {
      return this._backgroundColor;
    },
    set: function(value) {
      this._backgroundColor = value;
      this._backgroundColorString = hex2string(value);
      hex2rgb(value, this._backgroundColorRgba);
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(AbstractRenderer2.prototype, "backgroundAlpha", {
    get: function() {
      return this._backgroundColorRgba[3];
    },
    set: function(value) {
      this._backgroundColorRgba[3] = value;
    },
    enumerable: false,
    configurable: true
  });
  return AbstractRenderer2;
}(EventEmitter$3);
var GLBuffer = function() {
  function GLBuffer2(buffer) {
    this.buffer = buffer || null;
    this.updateID = -1;
    this.byteLength = -1;
    this.refCount = 0;
  }
  return GLBuffer2;
}();
var BufferSystem = function() {
  function BufferSystem2(renderer) {
    this.renderer = renderer;
    this.managedBuffers = {};
    this.boundBufferBases = {};
  }
  BufferSystem2.prototype.destroy = function() {
    this.renderer = null;
  };
  BufferSystem2.prototype.contextChange = function() {
    this.disposeAll(true);
    this.gl = this.renderer.gl;
    this.CONTEXT_UID = this.renderer.CONTEXT_UID;
  };
  BufferSystem2.prototype.bind = function(buffer) {
    var _a3 = this, gl = _a3.gl, CONTEXT_UID = _a3.CONTEXT_UID;
    var glBuffer = buffer._glBuffers[CONTEXT_UID] || this.createGLBuffer(buffer);
    gl.bindBuffer(buffer.type, glBuffer.buffer);
  };
  BufferSystem2.prototype.bindBufferBase = function(buffer, index) {
    var _a3 = this, gl = _a3.gl, CONTEXT_UID = _a3.CONTEXT_UID;
    if (this.boundBufferBases[index] !== buffer) {
      var glBuffer = buffer._glBuffers[CONTEXT_UID] || this.createGLBuffer(buffer);
      this.boundBufferBases[index] = buffer;
      gl.bindBufferBase(gl.UNIFORM_BUFFER, index, glBuffer.buffer);
    }
  };
  BufferSystem2.prototype.bindBufferRange = function(buffer, index, offset) {
    var _a3 = this, gl = _a3.gl, CONTEXT_UID = _a3.CONTEXT_UID;
    offset = offset || 0;
    var glBuffer = buffer._glBuffers[CONTEXT_UID] || this.createGLBuffer(buffer);
    gl.bindBufferRange(gl.UNIFORM_BUFFER, index || 0, glBuffer.buffer, offset * 256, 256);
  };
  BufferSystem2.prototype.update = function(buffer) {
    var _a3 = this, gl = _a3.gl, CONTEXT_UID = _a3.CONTEXT_UID;
    var glBuffer = buffer._glBuffers[CONTEXT_UID];
    if (buffer._updateID === glBuffer.updateID) {
      return;
    }
    glBuffer.updateID = buffer._updateID;
    gl.bindBuffer(buffer.type, glBuffer.buffer);
    if (glBuffer.byteLength >= buffer.data.byteLength) {
      gl.bufferSubData(buffer.type, 0, buffer.data);
    } else {
      var drawType = buffer.static ? gl.STATIC_DRAW : gl.DYNAMIC_DRAW;
      glBuffer.byteLength = buffer.data.byteLength;
      gl.bufferData(buffer.type, buffer.data, drawType);
    }
  };
  BufferSystem2.prototype.dispose = function(buffer, contextLost) {
    if (!this.managedBuffers[buffer.id]) {
      return;
    }
    delete this.managedBuffers[buffer.id];
    var glBuffer = buffer._glBuffers[this.CONTEXT_UID];
    var gl = this.gl;
    buffer.disposeRunner.remove(this);
    if (!glBuffer) {
      return;
    }
    if (!contextLost) {
      gl.deleteBuffer(glBuffer.buffer);
    }
    delete buffer._glBuffers[this.CONTEXT_UID];
  };
  BufferSystem2.prototype.disposeAll = function(contextLost) {
    var all2 = Object.keys(this.managedBuffers);
    for (var i2 = 0; i2 < all2.length; i2++) {
      this.dispose(this.managedBuffers[all2[i2]], contextLost);
    }
  };
  BufferSystem2.prototype.createGLBuffer = function(buffer) {
    var _a3 = this, CONTEXT_UID = _a3.CONTEXT_UID, gl = _a3.gl;
    buffer._glBuffers[CONTEXT_UID] = new GLBuffer(gl.createBuffer());
    this.managedBuffers[buffer.id] = buffer;
    buffer.disposeRunner.add(this);
    return buffer._glBuffers[CONTEXT_UID];
  };
  return BufferSystem2;
}();
var Renderer = function(_super) {
  __extends$q(Renderer2, _super);
  function Renderer2(options) {
    var _this = _super.call(this, RENDERER_TYPE$3.WEBGL, options) || this;
    options = _this.options;
    _this.gl = null;
    _this.CONTEXT_UID = 0;
    _this.runners = {
      destroy: new Runner("destroy"),
      contextChange: new Runner("contextChange"),
      reset: new Runner("reset"),
      update: new Runner("update"),
      postrender: new Runner("postrender"),
      prerender: new Runner("prerender"),
      resize: new Runner("resize")
    };
    _this.runners.contextChange.add(_this);
    _this.globalUniforms = new UniformGroup({
      projectionMatrix: new Matrix()
    }, true);
    _this.addSystem(MaskSystem, "mask").addSystem(ContextSystem, "context").addSystem(StateSystem, "state").addSystem(ShaderSystem, "shader").addSystem(TextureSystem, "texture").addSystem(BufferSystem, "buffer").addSystem(GeometrySystem, "geometry").addSystem(FramebufferSystem, "framebuffer").addSystem(ScissorSystem, "scissor").addSystem(StencilSystem, "stencil").addSystem(ProjectionSystem, "projection").addSystem(TextureGCSystem, "textureGC").addSystem(FilterSystem, "filter").addSystem(RenderTextureSystem, "renderTexture").addSystem(BatchSystem, "batch");
    _this.initPlugins(Renderer2.__plugins);
    _this.multisample = void 0;
    if (options.context) {
      _this.context.initFromContext(options.context);
    } else {
      _this.context.initFromOptions({
        alpha: !!_this.useContextAlpha,
        antialias: options.antialias,
        premultipliedAlpha: _this.useContextAlpha && _this.useContextAlpha !== "notMultiplied",
        stencil: true,
        preserveDrawingBuffer: options.preserveDrawingBuffer,
        powerPreference: _this.options.powerPreference
      });
    }
    _this.renderingToScreen = true;
    sayHello(_this.context.webGLVersion === 2 ? "WebGL 2" : "WebGL 1");
    _this.resize(_this.options.width, _this.options.height);
    return _this;
  }
  Renderer2.create = function(options) {
    if (isWebGLSupported()) {
      return new Renderer2(options);
    }
    throw new Error('WebGL unsupported in this browser, use "pixi.js-legacy" for fallback canvas2d support.');
  };
  Renderer2.prototype.contextChange = function() {
    var gl = this.gl;
    var samples;
    if (this.context.webGLVersion === 1) {
      var framebuffer = gl.getParameter(gl.FRAMEBUFFER_BINDING);
      gl.bindFramebuffer(gl.FRAMEBUFFER, null);
      samples = gl.getParameter(gl.SAMPLES);
      gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer);
    } else {
      var framebuffer = gl.getParameter(gl.DRAW_FRAMEBUFFER_BINDING);
      gl.bindFramebuffer(gl.DRAW_FRAMEBUFFER, null);
      samples = gl.getParameter(gl.SAMPLES);
      gl.bindFramebuffer(gl.DRAW_FRAMEBUFFER, framebuffer);
    }
    if (samples >= MSAA_QUALITY$3.HIGH) {
      this.multisample = MSAA_QUALITY$3.HIGH;
    } else if (samples >= MSAA_QUALITY$3.MEDIUM) {
      this.multisample = MSAA_QUALITY$3.MEDIUM;
    } else if (samples >= MSAA_QUALITY$3.LOW) {
      this.multisample = MSAA_QUALITY$3.LOW;
    } else {
      this.multisample = MSAA_QUALITY$3.NONE;
    }
  };
  Renderer2.prototype.addSystem = function(ClassRef, name2) {
    var system = new ClassRef(this);
    if (this[name2]) {
      throw new Error('Whoops! The name "' + name2 + '" is already in use');
    }
    this[name2] = system;
    for (var i2 in this.runners) {
      this.runners[i2].add(system);
    }
    return this;
  };
  Renderer2.prototype.render = function(displayObject, options) {
    var renderTexture;
    var clear;
    var transform;
    var skipUpdateTransform;
    if (options) {
      if (options instanceof RenderTexture) {
        deprecation("6.0.0", "Renderer#render arguments changed, use options instead.");
        renderTexture = options;
        clear = arguments[2];
        transform = arguments[3];
        skipUpdateTransform = arguments[4];
      } else {
        renderTexture = options.renderTexture;
        clear = options.clear;
        transform = options.transform;
        skipUpdateTransform = options.skipUpdateTransform;
      }
    }
    this.renderingToScreen = !renderTexture;
    this.runners.prerender.emit();
    this.emit("prerender");
    this.projection.transform = transform;
    if (this.context.isLost) {
      return;
    }
    if (!renderTexture) {
      this._lastObjectRendered = displayObject;
    }
    if (!skipUpdateTransform) {
      var cacheParent = displayObject.enableTempParent();
      displayObject.updateTransform();
      displayObject.disableTempParent(cacheParent);
    }
    this.renderTexture.bind(renderTexture);
    this.batch.currentRenderer.start();
    if (clear !== void 0 ? clear : this.clearBeforeRender) {
      this.renderTexture.clear();
    }
    displayObject.render(this);
    this.batch.currentRenderer.flush();
    if (renderTexture) {
      renderTexture.baseTexture.update();
    }
    this.runners.postrender.emit();
    this.projection.transform = null;
    this.emit("postrender");
  };
  Renderer2.prototype.generateTexture = function(displayObject, options, resolution, region) {
    if (options === void 0) {
      options = {};
    }
    var renderTexture = _super.prototype.generateTexture.call(this, displayObject, options, resolution, region);
    this.framebuffer.blit();
    return renderTexture;
  };
  Renderer2.prototype.resize = function(desiredScreenWidth, desiredScreenHeight) {
    _super.prototype.resize.call(this, desiredScreenWidth, desiredScreenHeight);
    this.runners.resize.emit(this.screen.height, this.screen.width);
  };
  Renderer2.prototype.reset = function() {
    this.runners.reset.emit();
    return this;
  };
  Renderer2.prototype.clear = function() {
    this.renderTexture.bind();
    this.renderTexture.clear();
  };
  Renderer2.prototype.destroy = function(removeView) {
    this.runners.destroy.emit();
    for (var r2 in this.runners) {
      this.runners[r2].destroy();
    }
    _super.prototype.destroy.call(this, removeView);
    this.gl = null;
  };
  Object.defineProperty(Renderer2.prototype, "extract", {
    get: function() {
      deprecation("6.0.0", "Renderer#extract has been deprecated, please use Renderer#plugins.extract instead.");
      return this.plugins.extract;
    },
    enumerable: false,
    configurable: true
  });
  Renderer2.registerPlugin = function(pluginName, ctor) {
    Renderer2.__plugins = Renderer2.__plugins || {};
    Renderer2.__plugins[pluginName] = ctor;
  };
  return Renderer2;
}(AbstractRenderer);
function autoDetectRenderer(options) {
  return Renderer.create(options);
}
var $defaultVertex = "attribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\n\nvarying vec2 vTextureCoord;\n\nvoid main(void)\n{\n    gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n    vTextureCoord = aTextureCoord;\n}";
var $defaultFilterVertex = "attribute vec2 aVertexPosition;\n\nuniform mat3 projectionMatrix;\n\nvarying vec2 vTextureCoord;\n\nuniform vec4 inputSize;\nuniform vec4 outputFrame;\n\nvec4 filterVertexPosition( void )\n{\n    vec2 position = aVertexPosition * max(outputFrame.zw, vec2(0.)) + outputFrame.xy;\n\n    return vec4((projectionMatrix * vec3(position, 1.0)).xy, 0.0, 1.0);\n}\n\nvec2 filterTextureCoord( void )\n{\n    return aVertexPosition * (outputFrame.zw * inputSize.zw);\n}\n\nvoid main(void)\n{\n    gl_Position = filterVertexPosition();\n    vTextureCoord = filterTextureCoord();\n}\n";
var defaultVertex$2 = $defaultVertex;
var defaultFilterVertex = $defaultFilterVertex;
var BatchDrawCall = function() {
  function BatchDrawCall2() {
    this.texArray = null;
    this.blend = 0;
    this.type = DRAW_MODES$3.TRIANGLES;
    this.start = 0;
    this.size = 0;
    this.data = null;
  }
  return BatchDrawCall2;
}();
var BatchTextureArray = function() {
  function BatchTextureArray2() {
    this.elements = [];
    this.ids = [];
    this.count = 0;
  }
  BatchTextureArray2.prototype.clear = function() {
    for (var i2 = 0; i2 < this.count; i2++) {
      this.elements[i2] = null;
    }
    this.count = 0;
  };
  return BatchTextureArray2;
}();
var ViewableBuffer = function() {
  function ViewableBuffer2(sizeOrBuffer) {
    if (typeof sizeOrBuffer === "number") {
      this.rawBinaryData = new ArrayBuffer(sizeOrBuffer);
    } else if (sizeOrBuffer instanceof Uint8Array) {
      this.rawBinaryData = sizeOrBuffer.buffer;
    } else {
      this.rawBinaryData = sizeOrBuffer;
    }
    this.uint32View = new Uint32Array(this.rawBinaryData);
    this.float32View = new Float32Array(this.rawBinaryData);
  }
  Object.defineProperty(ViewableBuffer2.prototype, "int8View", {
    get: function() {
      if (!this._int8View) {
        this._int8View = new Int8Array(this.rawBinaryData);
      }
      return this._int8View;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(ViewableBuffer2.prototype, "uint8View", {
    get: function() {
      if (!this._uint8View) {
        this._uint8View = new Uint8Array(this.rawBinaryData);
      }
      return this._uint8View;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(ViewableBuffer2.prototype, "int16View", {
    get: function() {
      if (!this._int16View) {
        this._int16View = new Int16Array(this.rawBinaryData);
      }
      return this._int16View;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(ViewableBuffer2.prototype, "uint16View", {
    get: function() {
      if (!this._uint16View) {
        this._uint16View = new Uint16Array(this.rawBinaryData);
      }
      return this._uint16View;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(ViewableBuffer2.prototype, "int32View", {
    get: function() {
      if (!this._int32View) {
        this._int32View = new Int32Array(this.rawBinaryData);
      }
      return this._int32View;
    },
    enumerable: false,
    configurable: true
  });
  ViewableBuffer2.prototype.view = function(type) {
    return this[type + "View"];
  };
  ViewableBuffer2.prototype.destroy = function() {
    this.rawBinaryData = null;
    this._int8View = null;
    this._uint8View = null;
    this._int16View = null;
    this._uint16View = null;
    this._int32View = null;
    this.uint32View = null;
    this.float32View = null;
  };
  ViewableBuffer2.sizeOf = function(type) {
    switch (type) {
      case "int8":
      case "uint8":
        return 1;
      case "int16":
      case "uint16":
        return 2;
      case "int32":
      case "uint32":
      case "float32":
        return 4;
      default:
        throw new Error(type + " isn't a valid view type");
    }
  };
  return ViewableBuffer2;
}();
var AbstractBatchRenderer = function(_super) {
  __extends$q(AbstractBatchRenderer2, _super);
  function AbstractBatchRenderer2(renderer) {
    var _this = _super.call(this, renderer) || this;
    _this.shaderGenerator = null;
    _this.geometryClass = null;
    _this.vertexSize = null;
    _this.state = State.for2d();
    _this.size = settings.SPRITE_BATCH_SIZE * 4;
    _this._vertexCount = 0;
    _this._indexCount = 0;
    _this._bufferedElements = [];
    _this._bufferedTextures = [];
    _this._bufferSize = 0;
    _this._shader = null;
    _this._packedGeometries = [];
    _this._packedGeometryPoolSize = 2;
    _this._flushId = 0;
    _this._aBuffers = {};
    _this._iBuffers = {};
    _this.MAX_TEXTURES = 1;
    _this.renderer.on("prerender", _this.onPrerender, _this);
    renderer.runners.contextChange.add(_this);
    _this._dcIndex = 0;
    _this._aIndex = 0;
    _this._iIndex = 0;
    _this._attributeBuffer = null;
    _this._indexBuffer = null;
    _this._tempBoundTextures = [];
    return _this;
  }
  AbstractBatchRenderer2.prototype.contextChange = function() {
    var gl = this.renderer.gl;
    if (settings.PREFER_ENV === ENV$3.WEBGL_LEGACY) {
      this.MAX_TEXTURES = 1;
    } else {
      this.MAX_TEXTURES = Math.min(gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS), settings.SPRITE_MAX_TEXTURES);
      this.MAX_TEXTURES = checkMaxIfStatementsInShader(this.MAX_TEXTURES, gl);
    }
    this._shader = this.shaderGenerator.generateShader(this.MAX_TEXTURES);
    for (var i2 = 0; i2 < this._packedGeometryPoolSize; i2++) {
      this._packedGeometries[i2] = new this.geometryClass();
    }
    this.initFlushBuffers();
  };
  AbstractBatchRenderer2.prototype.initFlushBuffers = function() {
    var _drawCallPool = AbstractBatchRenderer2._drawCallPool, _textureArrayPool = AbstractBatchRenderer2._textureArrayPool;
    var MAX_SPRITES = this.size / 4;
    var MAX_TA = Math.floor(MAX_SPRITES / this.MAX_TEXTURES) + 1;
    while (_drawCallPool.length < MAX_SPRITES) {
      _drawCallPool.push(new BatchDrawCall());
    }
    while (_textureArrayPool.length < MAX_TA) {
      _textureArrayPool.push(new BatchTextureArray());
    }
    for (var i2 = 0; i2 < this.MAX_TEXTURES; i2++) {
      this._tempBoundTextures[i2] = null;
    }
  };
  AbstractBatchRenderer2.prototype.onPrerender = function() {
    this._flushId = 0;
  };
  AbstractBatchRenderer2.prototype.render = function(element) {
    if (!element._texture.valid) {
      return;
    }
    if (this._vertexCount + element.vertexData.length / 2 > this.size) {
      this.flush();
    }
    this._vertexCount += element.vertexData.length / 2;
    this._indexCount += element.indices.length;
    this._bufferedTextures[this._bufferSize] = element._texture.baseTexture;
    this._bufferedElements[this._bufferSize++] = element;
  };
  AbstractBatchRenderer2.prototype.buildTexturesAndDrawCalls = function() {
    var _a3 = this, textures = _a3._bufferedTextures, MAX_TEXTURES = _a3.MAX_TEXTURES;
    var textureArrays = AbstractBatchRenderer2._textureArrayPool;
    var batch = this.renderer.batch;
    var boundTextures = this._tempBoundTextures;
    var touch = this.renderer.textureGC.count;
    var TICK = ++BaseTexture._globalBatch;
    var countTexArrays = 0;
    var texArray = textureArrays[0];
    var start = 0;
    batch.copyBoundTextures(boundTextures, MAX_TEXTURES);
    for (var i2 = 0; i2 < this._bufferSize; ++i2) {
      var tex = textures[i2];
      textures[i2] = null;
      if (tex._batchEnabled === TICK) {
        continue;
      }
      if (texArray.count >= MAX_TEXTURES) {
        batch.boundArray(texArray, boundTextures, TICK, MAX_TEXTURES);
        this.buildDrawCalls(texArray, start, i2);
        start = i2;
        texArray = textureArrays[++countTexArrays];
        ++TICK;
      }
      tex._batchEnabled = TICK;
      tex.touched = touch;
      texArray.elements[texArray.count++] = tex;
    }
    if (texArray.count > 0) {
      batch.boundArray(texArray, boundTextures, TICK, MAX_TEXTURES);
      this.buildDrawCalls(texArray, start, this._bufferSize);
      ++countTexArrays;
      ++TICK;
    }
    for (var i2 = 0; i2 < boundTextures.length; i2++) {
      boundTextures[i2] = null;
    }
    BaseTexture._globalBatch = TICK;
  };
  AbstractBatchRenderer2.prototype.buildDrawCalls = function(texArray, start, finish) {
    var _a3 = this, elements = _a3._bufferedElements, _attributeBuffer = _a3._attributeBuffer, _indexBuffer = _a3._indexBuffer, vertexSize = _a3.vertexSize;
    var drawCalls = AbstractBatchRenderer2._drawCallPool;
    var dcIndex = this._dcIndex;
    var aIndex = this._aIndex;
    var iIndex = this._iIndex;
    var drawCall = drawCalls[dcIndex];
    drawCall.start = this._iIndex;
    drawCall.texArray = texArray;
    for (var i2 = start; i2 < finish; ++i2) {
      var sprite = elements[i2];
      var tex = sprite._texture.baseTexture;
      var spriteBlendMode = premultiplyBlendMode[tex.alphaMode ? 1 : 0][sprite.blendMode];
      elements[i2] = null;
      if (start < i2 && drawCall.blend !== spriteBlendMode) {
        drawCall.size = iIndex - drawCall.start;
        start = i2;
        drawCall = drawCalls[++dcIndex];
        drawCall.texArray = texArray;
        drawCall.start = iIndex;
      }
      this.packInterleavedGeometry(sprite, _attributeBuffer, _indexBuffer, aIndex, iIndex);
      aIndex += sprite.vertexData.length / 2 * vertexSize;
      iIndex += sprite.indices.length;
      drawCall.blend = spriteBlendMode;
    }
    if (start < finish) {
      drawCall.size = iIndex - drawCall.start;
      ++dcIndex;
    }
    this._dcIndex = dcIndex;
    this._aIndex = aIndex;
    this._iIndex = iIndex;
  };
  AbstractBatchRenderer2.prototype.bindAndClearTexArray = function(texArray) {
    var textureSystem = this.renderer.texture;
    for (var j2 = 0; j2 < texArray.count; j2++) {
      textureSystem.bind(texArray.elements[j2], texArray.ids[j2]);
      texArray.elements[j2] = null;
    }
    texArray.count = 0;
  };
  AbstractBatchRenderer2.prototype.updateGeometry = function() {
    var _a3 = this, packedGeometries = _a3._packedGeometries, attributeBuffer = _a3._attributeBuffer, indexBuffer = _a3._indexBuffer;
    if (!settings.CAN_UPLOAD_SAME_BUFFER) {
      if (this._packedGeometryPoolSize <= this._flushId) {
        this._packedGeometryPoolSize++;
        packedGeometries[this._flushId] = new this.geometryClass();
      }
      packedGeometries[this._flushId]._buffer.update(attributeBuffer.rawBinaryData);
      packedGeometries[this._flushId]._indexBuffer.update(indexBuffer);
      this.renderer.geometry.bind(packedGeometries[this._flushId]);
      this.renderer.geometry.updateBuffers();
      this._flushId++;
    } else {
      packedGeometries[this._flushId]._buffer.update(attributeBuffer.rawBinaryData);
      packedGeometries[this._flushId]._indexBuffer.update(indexBuffer);
      this.renderer.geometry.updateBuffers();
    }
  };
  AbstractBatchRenderer2.prototype.drawBatches = function() {
    var dcCount = this._dcIndex;
    var _a3 = this.renderer, gl = _a3.gl, stateSystem = _a3.state;
    var drawCalls = AbstractBatchRenderer2._drawCallPool;
    var curTexArray = null;
    for (var i2 = 0; i2 < dcCount; i2++) {
      var _b3 = drawCalls[i2], texArray = _b3.texArray, type = _b3.type, size = _b3.size, start = _b3.start, blend = _b3.blend;
      if (curTexArray !== texArray) {
        curTexArray = texArray;
        this.bindAndClearTexArray(texArray);
      }
      this.state.blendMode = blend;
      stateSystem.set(this.state);
      gl.drawElements(type, size, gl.UNSIGNED_SHORT, start * 2);
    }
  };
  AbstractBatchRenderer2.prototype.flush = function() {
    if (this._vertexCount === 0) {
      return;
    }
    this._attributeBuffer = this.getAttributeBuffer(this._vertexCount);
    this._indexBuffer = this.getIndexBuffer(this._indexCount);
    this._aIndex = 0;
    this._iIndex = 0;
    this._dcIndex = 0;
    this.buildTexturesAndDrawCalls();
    this.updateGeometry();
    this.drawBatches();
    this._bufferSize = 0;
    this._vertexCount = 0;
    this._indexCount = 0;
  };
  AbstractBatchRenderer2.prototype.start = function() {
    this.renderer.state.set(this.state);
    this.renderer.texture.ensureSamplerType(this.MAX_TEXTURES);
    this.renderer.shader.bind(this._shader);
    if (settings.CAN_UPLOAD_SAME_BUFFER) {
      this.renderer.geometry.bind(this._packedGeometries[this._flushId]);
    }
  };
  AbstractBatchRenderer2.prototype.stop = function() {
    this.flush();
  };
  AbstractBatchRenderer2.prototype.destroy = function() {
    for (var i2 = 0; i2 < this._packedGeometryPoolSize; i2++) {
      if (this._packedGeometries[i2]) {
        this._packedGeometries[i2].destroy();
      }
    }
    this.renderer.off("prerender", this.onPrerender, this);
    this._aBuffers = null;
    this._iBuffers = null;
    this._packedGeometries = null;
    this._attributeBuffer = null;
    this._indexBuffer = null;
    if (this._shader) {
      this._shader.destroy();
      this._shader = null;
    }
    _super.prototype.destroy.call(this);
  };
  AbstractBatchRenderer2.prototype.getAttributeBuffer = function(size) {
    var roundedP2 = nextPow2(Math.ceil(size / 8));
    var roundedSizeIndex = log2(roundedP2);
    var roundedSize = roundedP2 * 8;
    if (this._aBuffers.length <= roundedSizeIndex) {
      this._iBuffers.length = roundedSizeIndex + 1;
    }
    var buffer = this._aBuffers[roundedSize];
    if (!buffer) {
      this._aBuffers[roundedSize] = buffer = new ViewableBuffer(roundedSize * this.vertexSize * 4);
    }
    return buffer;
  };
  AbstractBatchRenderer2.prototype.getIndexBuffer = function(size) {
    var roundedP2 = nextPow2(Math.ceil(size / 12));
    var roundedSizeIndex = log2(roundedP2);
    var roundedSize = roundedP2 * 12;
    if (this._iBuffers.length <= roundedSizeIndex) {
      this._iBuffers.length = roundedSizeIndex + 1;
    }
    var buffer = this._iBuffers[roundedSizeIndex];
    if (!buffer) {
      this._iBuffers[roundedSizeIndex] = buffer = new Uint16Array(roundedSize);
    }
    return buffer;
  };
  AbstractBatchRenderer2.prototype.packInterleavedGeometry = function(element, attributeBuffer, indexBuffer, aIndex, iIndex) {
    var uint32View = attributeBuffer.uint32View, float32View = attributeBuffer.float32View;
    var packedVertices = aIndex / this.vertexSize;
    var uvs = element.uvs;
    var indicies = element.indices;
    var vertexData = element.vertexData;
    var textureId = element._texture.baseTexture._batchLocation;
    var alpha = Math.min(element.worldAlpha, 1);
    var argb = alpha < 1 && element._texture.baseTexture.alphaMode ? premultiplyTint(element._tintRGB, alpha) : element._tintRGB + (alpha * 255 << 24);
    for (var i2 = 0; i2 < vertexData.length; i2 += 2) {
      float32View[aIndex++] = vertexData[i2];
      float32View[aIndex++] = vertexData[i2 + 1];
      float32View[aIndex++] = uvs[i2];
      float32View[aIndex++] = uvs[i2 + 1];
      uint32View[aIndex++] = argb;
      float32View[aIndex++] = textureId;
    }
    for (var i2 = 0; i2 < indicies.length; i2++) {
      indexBuffer[iIndex++] = packedVertices + indicies[i2];
    }
  };
  AbstractBatchRenderer2._drawCallPool = [];
  AbstractBatchRenderer2._textureArrayPool = [];
  return AbstractBatchRenderer2;
}(ObjectRenderer);
var BatchShaderGenerator = function() {
  function BatchShaderGenerator2(vertexSrc, fragTemplate2) {
    this.vertexSrc = vertexSrc;
    this.fragTemplate = fragTemplate2;
    this.programCache = {};
    this.defaultGroupCache = {};
    if (fragTemplate2.indexOf("%count%") < 0) {
      throw new Error('Fragment template must contain "%count%".');
    }
    if (fragTemplate2.indexOf("%forloop%") < 0) {
      throw new Error('Fragment template must contain "%forloop%".');
    }
  }
  BatchShaderGenerator2.prototype.generateShader = function(maxTextures) {
    if (!this.programCache[maxTextures]) {
      var sampleValues = new Int32Array(maxTextures);
      for (var i2 = 0; i2 < maxTextures; i2++) {
        sampleValues[i2] = i2;
      }
      this.defaultGroupCache[maxTextures] = UniformGroup.from({ uSamplers: sampleValues }, true);
      var fragmentSrc = this.fragTemplate;
      fragmentSrc = fragmentSrc.replace(/%count%/gi, "" + maxTextures);
      fragmentSrc = fragmentSrc.replace(/%forloop%/gi, this.generateSampleSrc(maxTextures));
      this.programCache[maxTextures] = new Program(this.vertexSrc, fragmentSrc);
    }
    var uniforms = {
      tint: new Float32Array([1, 1, 1, 1]),
      translationMatrix: new Matrix(),
      default: this.defaultGroupCache[maxTextures]
    };
    return new Shader(this.programCache[maxTextures], uniforms);
  };
  BatchShaderGenerator2.prototype.generateSampleSrc = function(maxTextures) {
    var src = "";
    src += "\n";
    src += "\n";
    for (var i2 = 0; i2 < maxTextures; i2++) {
      if (i2 > 0) {
        src += "\nelse ";
      }
      if (i2 < maxTextures - 1) {
        src += "if(vTextureId < " + i2 + ".5)";
      }
      src += "\n{";
      src += "\n	color = texture2D(uSamplers[" + i2 + "], vTextureCoord);";
      src += "\n}";
    }
    src += "\n";
    src += "\n";
    return src;
  };
  return BatchShaderGenerator2;
}();
var BatchGeometry = function(_super) {
  __extends$q(BatchGeometry2, _super);
  function BatchGeometry2(_static) {
    if (_static === void 0) {
      _static = false;
    }
    var _this = _super.call(this) || this;
    _this._buffer = new Buffer$1(null, _static, false);
    _this._indexBuffer = new Buffer$1(null, _static, true);
    _this.addAttribute("aVertexPosition", _this._buffer, 2, false, TYPES$3.FLOAT).addAttribute("aTextureCoord", _this._buffer, 2, false, TYPES$3.FLOAT).addAttribute("aColor", _this._buffer, 4, true, TYPES$3.UNSIGNED_BYTE).addAttribute("aTextureId", _this._buffer, 1, true, TYPES$3.FLOAT).addIndex(_this._indexBuffer);
    return _this;
  }
  return BatchGeometry2;
}(Geometry);
var defaultVertex$3 = "precision highp float;\nattribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\nattribute vec4 aColor;\nattribute float aTextureId;\n\nuniform mat3 projectionMatrix;\nuniform mat3 translationMatrix;\nuniform vec4 tint;\n\nvarying vec2 vTextureCoord;\nvarying vec4 vColor;\nvarying float vTextureId;\n\nvoid main(void){\n    gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n\n    vTextureCoord = aTextureCoord;\n    vTextureId = aTextureId;\n    vColor = aColor * tint;\n}\n";
var defaultFragment$2 = "varying vec2 vTextureCoord;\nvarying vec4 vColor;\nvarying float vTextureId;\nuniform sampler2D uSamplers[%count%];\n\nvoid main(void){\n    vec4 color;\n    %forloop%\n    gl_FragColor = color * vColor;\n}\n";
var BatchPluginFactory = function() {
  function BatchPluginFactory2() {
  }
  BatchPluginFactory2.create = function(options) {
    var _a3 = Object.assign({
      vertex: defaultVertex$3,
      fragment: defaultFragment$2,
      geometryClass: BatchGeometry,
      vertexSize: 6
    }, options), vertex2 = _a3.vertex, fragment2 = _a3.fragment, vertexSize = _a3.vertexSize, geometryClass = _a3.geometryClass;
    return function(_super) {
      __extends$q(BatchPlugin, _super);
      function BatchPlugin(renderer) {
        var _this = _super.call(this, renderer) || this;
        _this.shaderGenerator = new BatchShaderGenerator(vertex2, fragment2);
        _this.geometryClass = geometryClass;
        _this.vertexSize = vertexSize;
        return _this;
      }
      return BatchPlugin;
    }(AbstractBatchRenderer);
  };
  Object.defineProperty(BatchPluginFactory2, "defaultVertexSrc", {
    get: function() {
      return defaultVertex$3;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(BatchPluginFactory2, "defaultFragmentTemplate", {
    get: function() {
      return defaultFragment$2;
    },
    enumerable: false,
    configurable: true
  });
  return BatchPluginFactory2;
}();
var BatchRenderer = BatchPluginFactory.create();
var resources = {};
var _loop_1 = function(name2) {
  Object.defineProperty(resources, name2, {
    get: function() {
      deprecation("6.0.0", "PIXI.systems." + name2 + " has moved to PIXI." + name2);
      return _resources[name2];
    }
  });
};
for (var name in _resources) {
  _loop_1(name);
}
var systems = {};
var _loop_2 = function(name2) {
  Object.defineProperty(systems, name2, {
    get: function() {
      deprecation("6.0.0", "PIXI.resources." + name2 + " has moved to PIXI." + name2);
      return _systems[name2];
    }
  });
};
for (var name in _systems) {
  _loop_2(name);
}
/*!
 * @pixi/loaders - v6.3.0
 * Compiled Wed, 23 Mar 2022 18:58:56 UTC
 *
 * @pixi/loaders is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
var SignalBinding = function() {
  function SignalBinding2(fn, once, thisArg) {
    if (once === void 0) {
      once = false;
    }
    this._fn = fn;
    this._once = once;
    this._thisArg = thisArg;
    this._next = this._prev = this._owner = null;
  }
  SignalBinding2.prototype.detach = function() {
    if (this._owner === null) {
      return false;
    }
    this._owner.detach(this);
    return true;
  };
  return SignalBinding2;
}();
function _addSignalBinding(self2, node) {
  if (!self2._head) {
    self2._head = node;
    self2._tail = node;
  } else {
    self2._tail._next = node;
    node._prev = self2._tail;
    self2._tail = node;
  }
  node._owner = self2;
  return node;
}
var Signal = function() {
  function Signal2() {
    this._head = this._tail = void 0;
  }
  Signal2.prototype.handlers = function(exists) {
    if (exists === void 0) {
      exists = false;
    }
    var node = this._head;
    if (exists) {
      return !!node;
    }
    var ee = [];
    while (node) {
      ee.push(node);
      node = node._next;
    }
    return ee;
  };
  Signal2.prototype.has = function(node) {
    if (!(node instanceof SignalBinding)) {
      throw new Error("MiniSignal#has(): First arg must be a SignalBinding object.");
    }
    return node._owner === this;
  };
  Signal2.prototype.dispatch = function() {
    var arguments$1 = arguments;
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      args[_i] = arguments$1[_i];
    }
    var node = this._head;
    if (!node) {
      return false;
    }
    while (node) {
      if (node._once) {
        this.detach(node);
      }
      node._fn.apply(node._thisArg, args);
      node = node._next;
    }
    return true;
  };
  Signal2.prototype.add = function(fn, thisArg) {
    if (thisArg === void 0) {
      thisArg = null;
    }
    if (typeof fn !== "function") {
      throw new Error("MiniSignal#add(): First arg must be a Function.");
    }
    return _addSignalBinding(this, new SignalBinding(fn, false, thisArg));
  };
  Signal2.prototype.once = function(fn, thisArg) {
    if (thisArg === void 0) {
      thisArg = null;
    }
    if (typeof fn !== "function") {
      throw new Error("MiniSignal#once(): First arg must be a Function.");
    }
    return _addSignalBinding(this, new SignalBinding(fn, true, thisArg));
  };
  Signal2.prototype.detach = function(node) {
    if (!(node instanceof SignalBinding)) {
      throw new Error("MiniSignal#detach(): First arg must be a SignalBinding object.");
    }
    if (node._owner !== this) {
      return this;
    }
    if (node._prev) {
      node._prev._next = node._next;
    }
    if (node._next) {
      node._next._prev = node._prev;
    }
    if (node === this._head) {
      this._head = node._next;
      if (node._next === null) {
        this._tail = null;
      }
    } else if (node === this._tail) {
      this._tail = node._prev;
      this._tail._next = null;
    }
    node._owner = null;
    return this;
  };
  Signal2.prototype.detachAll = function() {
    var node = this._head;
    if (!node) {
      return this;
    }
    this._head = this._tail = null;
    while (node) {
      node._owner = null;
      node = node._next;
    }
    return this;
  };
  return Signal2;
}();
function parseUri(str2, opts) {
  opts = opts || {};
  var o = {
    key: ["source", "protocol", "authority", "userInfo", "user", "password", "host", "port", "relative", "path", "directory", "file", "query", "anchor"],
    q: {
      name: "queryKey",
      parser: /(?:^|&)([^&=]*)=?([^&]*)/g
    },
    parser: {
      strict: /^(?:([^:\/?#]+):)?(?:\/\/((?:(([^:@]*)(?::([^:@]*))?)?@)?([^:\/?#]*)(?::(\d*))?))?((((?:[^?#\/]*\/)*)([^?#]*))(?:\?([^#]*))?(?:#(.*))?)/,
      loose: /^(?:(?![^:@]+:[^:@\/]*@)([^:\/?#.]+):)?(?:\/\/)?((?:(([^:@]*)(?::([^:@]*))?)?@)?([^:\/?#]*)(?::(\d*))?)(((\/(?:[^?#](?![^?#\/]*\.[^?#\/.]+(?:[?#]|$)))*\/?)?([^?#\/]*))(?:\?([^#]*))?(?:#(.*))?)/
    }
  };
  var m2 = o.parser[opts.strictMode ? "strict" : "loose"].exec(str2);
  var uri = {};
  var i2 = 14;
  while (i2--) {
    uri[o.key[i2]] = m2[i2] || "";
  }
  uri[o.q.name] = {};
  uri[o.key[12]].replace(o.q.parser, function(_t0, t1, t2) {
    if (t1) {
      uri[o.q.name][t1] = t2;
    }
  });
  return uri;
}
var useXdr = !!(globalThis.XDomainRequest && !("withCredentials" in new XMLHttpRequest()));
var tempAnchor = null;
var STATUS_NONE = 0;
var STATUS_OK = 200;
var STATUS_EMPTY = 204;
var STATUS_IE_BUG_EMPTY = 1223;
var STATUS_TYPE_OK = 2;
function _noop() {
}
function setExtMap(map2, extname, val) {
  if (extname && extname.indexOf(".") === 0) {
    extname = extname.substring(1);
  }
  if (!extname) {
    return;
  }
  map2[extname] = val;
}
function reqType(xhr) {
  return xhr.toString().replace("object ", "");
}
var LoaderResource = function() {
  function LoaderResource2(name2, url2, options) {
    this._dequeue = _noop;
    this._onLoadBinding = null;
    this._elementTimer = 0;
    this._boundComplete = null;
    this._boundOnError = null;
    this._boundOnProgress = null;
    this._boundOnTimeout = null;
    this._boundXhrOnError = null;
    this._boundXhrOnTimeout = null;
    this._boundXhrOnAbort = null;
    this._boundXhrOnLoad = null;
    if (typeof name2 !== "string" || typeof url2 !== "string") {
      throw new Error("Both name and url are required for constructing a resource.");
    }
    options = options || {};
    this._flags = 0;
    this._setFlag(LoaderResource2.STATUS_FLAGS.DATA_URL, url2.indexOf("data:") === 0);
    this.name = name2;
    this.url = url2;
    this.extension = this._getExtension();
    this.data = null;
    this.crossOrigin = options.crossOrigin === true ? "anonymous" : options.crossOrigin;
    this.timeout = options.timeout || 0;
    this.loadType = options.loadType || this._determineLoadType();
    this.xhrType = options.xhrType;
    this.metadata = options.metadata || {};
    this.error = null;
    this.xhr = null;
    this.children = [];
    this.type = LoaderResource2.TYPE.UNKNOWN;
    this.progressChunk = 0;
    this._dequeue = _noop;
    this._onLoadBinding = null;
    this._elementTimer = 0;
    this._boundComplete = this.complete.bind(this);
    this._boundOnError = this._onError.bind(this);
    this._boundOnProgress = this._onProgress.bind(this);
    this._boundOnTimeout = this._onTimeout.bind(this);
    this._boundXhrOnError = this._xhrOnError.bind(this);
    this._boundXhrOnTimeout = this._xhrOnTimeout.bind(this);
    this._boundXhrOnAbort = this._xhrOnAbort.bind(this);
    this._boundXhrOnLoad = this._xhrOnLoad.bind(this);
    this.onStart = new Signal();
    this.onProgress = new Signal();
    this.onComplete = new Signal();
    this.onAfterMiddleware = new Signal();
  }
  LoaderResource2.setExtensionLoadType = function(extname, loadType) {
    setExtMap(LoaderResource2._loadTypeMap, extname, loadType);
  };
  LoaderResource2.setExtensionXhrType = function(extname, xhrType) {
    setExtMap(LoaderResource2._xhrTypeMap, extname, xhrType);
  };
  Object.defineProperty(LoaderResource2.prototype, "isDataUrl", {
    get: function() {
      return this._hasFlag(LoaderResource2.STATUS_FLAGS.DATA_URL);
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(LoaderResource2.prototype, "isComplete", {
    get: function() {
      return this._hasFlag(LoaderResource2.STATUS_FLAGS.COMPLETE);
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(LoaderResource2.prototype, "isLoading", {
    get: function() {
      return this._hasFlag(LoaderResource2.STATUS_FLAGS.LOADING);
    },
    enumerable: false,
    configurable: true
  });
  LoaderResource2.prototype.complete = function() {
    this._clearEvents();
    this._finish();
  };
  LoaderResource2.prototype.abort = function(message) {
    if (this.error) {
      return;
    }
    this.error = new Error(message);
    this._clearEvents();
    if (this.xhr) {
      this.xhr.abort();
    } else if (this.xdr) {
      this.xdr.abort();
    } else if (this.data) {
      if (this.data.src) {
        this.data.src = LoaderResource2.EMPTY_GIF;
      } else {
        while (this.data.firstChild) {
          this.data.removeChild(this.data.firstChild);
        }
      }
    }
    this._finish();
  };
  LoaderResource2.prototype.load = function(cb) {
    var _this = this;
    if (this.isLoading) {
      return;
    }
    if (this.isComplete) {
      if (cb) {
        setTimeout(function() {
          return cb(_this);
        }, 1);
      }
      return;
    } else if (cb) {
      this.onComplete.once(cb);
    }
    this._setFlag(LoaderResource2.STATUS_FLAGS.LOADING, true);
    this.onStart.dispatch(this);
    if (this.crossOrigin === false || typeof this.crossOrigin !== "string") {
      this.crossOrigin = this._determineCrossOrigin(this.url);
    }
    switch (this.loadType) {
      case LoaderResource2.LOAD_TYPE.IMAGE:
        this.type = LoaderResource2.TYPE.IMAGE;
        this._loadElement("image");
        break;
      case LoaderResource2.LOAD_TYPE.AUDIO:
        this.type = LoaderResource2.TYPE.AUDIO;
        this._loadSourceElement("audio");
        break;
      case LoaderResource2.LOAD_TYPE.VIDEO:
        this.type = LoaderResource2.TYPE.VIDEO;
        this._loadSourceElement("video");
        break;
      case LoaderResource2.LOAD_TYPE.XHR:
      default:
        if (useXdr && this.crossOrigin) {
          this._loadXdr();
        } else {
          this._loadXhr();
        }
        break;
    }
  };
  LoaderResource2.prototype._hasFlag = function(flag) {
    return (this._flags & flag) !== 0;
  };
  LoaderResource2.prototype._setFlag = function(flag, value) {
    this._flags = value ? this._flags | flag : this._flags & ~flag;
  };
  LoaderResource2.prototype._clearEvents = function() {
    clearTimeout(this._elementTimer);
    if (this.data && this.data.removeEventListener) {
      this.data.removeEventListener("error", this._boundOnError, false);
      this.data.removeEventListener("load", this._boundComplete, false);
      this.data.removeEventListener("progress", this._boundOnProgress, false);
      this.data.removeEventListener("canplaythrough", this._boundComplete, false);
    }
    if (this.xhr) {
      if (this.xhr.removeEventListener) {
        this.xhr.removeEventListener("error", this._boundXhrOnError, false);
        this.xhr.removeEventListener("timeout", this._boundXhrOnTimeout, false);
        this.xhr.removeEventListener("abort", this._boundXhrOnAbort, false);
        this.xhr.removeEventListener("progress", this._boundOnProgress, false);
        this.xhr.removeEventListener("load", this._boundXhrOnLoad, false);
      } else {
        this.xhr.onerror = null;
        this.xhr.ontimeout = null;
        this.xhr.onprogress = null;
        this.xhr.onload = null;
      }
    }
  };
  LoaderResource2.prototype._finish = function() {
    if (this.isComplete) {
      throw new Error("Complete called again for an already completed resource.");
    }
    this._setFlag(LoaderResource2.STATUS_FLAGS.COMPLETE, true);
    this._setFlag(LoaderResource2.STATUS_FLAGS.LOADING, false);
    this.onComplete.dispatch(this);
  };
  LoaderResource2.prototype._loadElement = function(type) {
    if (this.metadata.loadElement) {
      this.data = this.metadata.loadElement;
    } else if (type === "image" && typeof globalThis.Image !== "undefined") {
      this.data = new Image();
    } else {
      this.data = document.createElement(type);
    }
    if (this.crossOrigin) {
      this.data.crossOrigin = this.crossOrigin;
    }
    if (!this.metadata.skipSource) {
      this.data.src = this.url;
    }
    this.data.addEventListener("error", this._boundOnError, false);
    this.data.addEventListener("load", this._boundComplete, false);
    this.data.addEventListener("progress", this._boundOnProgress, false);
    if (this.timeout) {
      this._elementTimer = setTimeout(this._boundOnTimeout, this.timeout);
    }
  };
  LoaderResource2.prototype._loadSourceElement = function(type) {
    if (this.metadata.loadElement) {
      this.data = this.metadata.loadElement;
    } else if (type === "audio" && typeof globalThis.Audio !== "undefined") {
      this.data = new Audio();
    } else {
      this.data = document.createElement(type);
    }
    if (this.data === null) {
      this.abort("Unsupported element: " + type);
      return;
    }
    if (this.crossOrigin) {
      this.data.crossOrigin = this.crossOrigin;
    }
    if (!this.metadata.skipSource) {
      if (navigator.isCocoonJS) {
        this.data.src = Array.isArray(this.url) ? this.url[0] : this.url;
      } else if (Array.isArray(this.url)) {
        var mimeTypes = this.metadata.mimeType;
        for (var i2 = 0; i2 < this.url.length; ++i2) {
          this.data.appendChild(this._createSource(type, this.url[i2], Array.isArray(mimeTypes) ? mimeTypes[i2] : mimeTypes));
        }
      } else {
        var mimeTypes = this.metadata.mimeType;
        this.data.appendChild(this._createSource(type, this.url, Array.isArray(mimeTypes) ? mimeTypes[0] : mimeTypes));
      }
    }
    this.data.addEventListener("error", this._boundOnError, false);
    this.data.addEventListener("load", this._boundComplete, false);
    this.data.addEventListener("progress", this._boundOnProgress, false);
    this.data.addEventListener("canplaythrough", this._boundComplete, false);
    this.data.load();
    if (this.timeout) {
      this._elementTimer = setTimeout(this._boundOnTimeout, this.timeout);
    }
  };
  LoaderResource2.prototype._loadXhr = function() {
    if (typeof this.xhrType !== "string") {
      this.xhrType = this._determineXhrType();
    }
    var xhr = this.xhr = new XMLHttpRequest();
    if (this.crossOrigin === "use-credentials") {
      xhr.withCredentials = true;
    }
    xhr.open("GET", this.url, true);
    xhr.timeout = this.timeout;
    if (this.xhrType === LoaderResource2.XHR_RESPONSE_TYPE.JSON || this.xhrType === LoaderResource2.XHR_RESPONSE_TYPE.DOCUMENT) {
      xhr.responseType = LoaderResource2.XHR_RESPONSE_TYPE.TEXT;
    } else {
      xhr.responseType = this.xhrType;
    }
    xhr.addEventListener("error", this._boundXhrOnError, false);
    xhr.addEventListener("timeout", this._boundXhrOnTimeout, false);
    xhr.addEventListener("abort", this._boundXhrOnAbort, false);
    xhr.addEventListener("progress", this._boundOnProgress, false);
    xhr.addEventListener("load", this._boundXhrOnLoad, false);
    xhr.send();
  };
  LoaderResource2.prototype._loadXdr = function() {
    if (typeof this.xhrType !== "string") {
      this.xhrType = this._determineXhrType();
    }
    var xdr = this.xhr = new globalThis.XDomainRequest();
    xdr.timeout = this.timeout || 5e3;
    xdr.onerror = this._boundXhrOnError;
    xdr.ontimeout = this._boundXhrOnTimeout;
    xdr.onprogress = this._boundOnProgress;
    xdr.onload = this._boundXhrOnLoad;
    xdr.open("GET", this.url, true);
    setTimeout(function() {
      return xdr.send();
    }, 1);
  };
  LoaderResource2.prototype._createSource = function(type, url2, mime) {
    if (!mime) {
      mime = type + "/" + this._getExtension(url2);
    }
    var source = document.createElement("source");
    source.src = url2;
    source.type = mime;
    return source;
  };
  LoaderResource2.prototype._onError = function(event) {
    this.abort("Failed to load element using: " + event.target.nodeName);
  };
  LoaderResource2.prototype._onProgress = function(event) {
    if (event && event.lengthComputable) {
      this.onProgress.dispatch(this, event.loaded / event.total);
    }
  };
  LoaderResource2.prototype._onTimeout = function() {
    this.abort("Load timed out.");
  };
  LoaderResource2.prototype._xhrOnError = function() {
    var xhr = this.xhr;
    this.abort(reqType(xhr) + " Request failed. Status: " + xhr.status + ', text: "' + xhr.statusText + '"');
  };
  LoaderResource2.prototype._xhrOnTimeout = function() {
    var xhr = this.xhr;
    this.abort(reqType(xhr) + " Request timed out.");
  };
  LoaderResource2.prototype._xhrOnAbort = function() {
    var xhr = this.xhr;
    this.abort(reqType(xhr) + " Request was aborted by the user.");
  };
  LoaderResource2.prototype._xhrOnLoad = function() {
    var xhr = this.xhr;
    var text2 = "";
    var status = typeof xhr.status === "undefined" ? STATUS_OK : xhr.status;
    if (xhr.responseType === "" || xhr.responseType === "text" || typeof xhr.responseType === "undefined") {
      text2 = xhr.responseText;
    }
    if (status === STATUS_NONE && (text2.length > 0 || xhr.responseType === LoaderResource2.XHR_RESPONSE_TYPE.BUFFER)) {
      status = STATUS_OK;
    } else if (status === STATUS_IE_BUG_EMPTY) {
      status = STATUS_EMPTY;
    }
    var statusType = status / 100 | 0;
    if (statusType === STATUS_TYPE_OK) {
      if (this.xhrType === LoaderResource2.XHR_RESPONSE_TYPE.TEXT) {
        this.data = text2;
        this.type = LoaderResource2.TYPE.TEXT;
      } else if (this.xhrType === LoaderResource2.XHR_RESPONSE_TYPE.JSON) {
        try {
          this.data = JSON.parse(text2);
          this.type = LoaderResource2.TYPE.JSON;
        } catch (e) {
          this.abort("Error trying to parse loaded json: " + e);
          return;
        }
      } else if (this.xhrType === LoaderResource2.XHR_RESPONSE_TYPE.DOCUMENT) {
        try {
          if (globalThis.DOMParser) {
            var domparser = new DOMParser();
            this.data = domparser.parseFromString(text2, "text/xml");
          } else {
            var div = document.createElement("div");
            div.innerHTML = text2;
            this.data = div;
          }
          this.type = LoaderResource2.TYPE.XML;
        } catch (e$1) {
          this.abort("Error trying to parse loaded xml: " + e$1);
          return;
        }
      } else {
        this.data = xhr.response || text2;
      }
    } else {
      this.abort("[" + xhr.status + "] " + xhr.statusText + ": " + xhr.responseURL);
      return;
    }
    this.complete();
  };
  LoaderResource2.prototype._determineCrossOrigin = function(url2, loc) {
    if (url2.indexOf("data:") === 0) {
      return "";
    }
    if (globalThis.origin !== globalThis.location.origin) {
      return "anonymous";
    }
    loc = loc || globalThis.location;
    if (!tempAnchor) {
      tempAnchor = document.createElement("a");
    }
    tempAnchor.href = url2;
    var parsedUrl = parseUri(tempAnchor.href, { strictMode: true });
    var samePort = !parsedUrl.port && loc.port === "" || parsedUrl.port === loc.port;
    var protocol2 = parsedUrl.protocol ? parsedUrl.protocol + ":" : "";
    if (parsedUrl.host !== loc.hostname || !samePort || protocol2 !== loc.protocol) {
      return "anonymous";
    }
    return "";
  };
  LoaderResource2.prototype._determineXhrType = function() {
    return LoaderResource2._xhrTypeMap[this.extension] || LoaderResource2.XHR_RESPONSE_TYPE.TEXT;
  };
  LoaderResource2.prototype._determineLoadType = function() {
    return LoaderResource2._loadTypeMap[this.extension] || LoaderResource2.LOAD_TYPE.XHR;
  };
  LoaderResource2.prototype._getExtension = function(url2) {
    if (url2 === void 0) {
      url2 = this.url;
    }
    var ext = "";
    if (this.isDataUrl) {
      var slashIndex = url2.indexOf("/");
      ext = url2.substring(slashIndex + 1, url2.indexOf(";", slashIndex));
    } else {
      var queryStart = url2.indexOf("?");
      var hashStart = url2.indexOf("#");
      var index = Math.min(queryStart > -1 ? queryStart : url2.length, hashStart > -1 ? hashStart : url2.length);
      url2 = url2.substring(0, index);
      ext = url2.substring(url2.lastIndexOf(".") + 1);
    }
    return ext.toLowerCase();
  };
  LoaderResource2.prototype._getMimeFromXhrType = function(type) {
    switch (type) {
      case LoaderResource2.XHR_RESPONSE_TYPE.BUFFER:
        return "application/octet-binary";
      case LoaderResource2.XHR_RESPONSE_TYPE.BLOB:
        return "application/blob";
      case LoaderResource2.XHR_RESPONSE_TYPE.DOCUMENT:
        return "application/xml";
      case LoaderResource2.XHR_RESPONSE_TYPE.JSON:
        return "application/json";
      case LoaderResource2.XHR_RESPONSE_TYPE.DEFAULT:
      case LoaderResource2.XHR_RESPONSE_TYPE.TEXT:
      default:
        return "text/plain";
    }
  };
  return LoaderResource2;
}();
(function(LoaderResource2) {
  (function(STATUS_FLAGS) {
    STATUS_FLAGS[STATUS_FLAGS["NONE"] = 0] = "NONE";
    STATUS_FLAGS[STATUS_FLAGS["DATA_URL"] = 1] = "DATA_URL";
    STATUS_FLAGS[STATUS_FLAGS["COMPLETE"] = 2] = "COMPLETE";
    STATUS_FLAGS[STATUS_FLAGS["LOADING"] = 4] = "LOADING";
  })(LoaderResource2.STATUS_FLAGS || (LoaderResource2.STATUS_FLAGS = {}));
  (function(TYPE) {
    TYPE[TYPE["UNKNOWN"] = 0] = "UNKNOWN";
    TYPE[TYPE["JSON"] = 1] = "JSON";
    TYPE[TYPE["XML"] = 2] = "XML";
    TYPE[TYPE["IMAGE"] = 3] = "IMAGE";
    TYPE[TYPE["AUDIO"] = 4] = "AUDIO";
    TYPE[TYPE["VIDEO"] = 5] = "VIDEO";
    TYPE[TYPE["TEXT"] = 6] = "TEXT";
  })(LoaderResource2.TYPE || (LoaderResource2.TYPE = {}));
  (function(LOAD_TYPE) {
    LOAD_TYPE[LOAD_TYPE["XHR"] = 1] = "XHR";
    LOAD_TYPE[LOAD_TYPE["IMAGE"] = 2] = "IMAGE";
    LOAD_TYPE[LOAD_TYPE["AUDIO"] = 3] = "AUDIO";
    LOAD_TYPE[LOAD_TYPE["VIDEO"] = 4] = "VIDEO";
  })(LoaderResource2.LOAD_TYPE || (LoaderResource2.LOAD_TYPE = {}));
  (function(XHR_RESPONSE_TYPE) {
    XHR_RESPONSE_TYPE["DEFAULT"] = "text";
    XHR_RESPONSE_TYPE["BUFFER"] = "arraybuffer";
    XHR_RESPONSE_TYPE["BLOB"] = "blob";
    XHR_RESPONSE_TYPE["DOCUMENT"] = "document";
    XHR_RESPONSE_TYPE["JSON"] = "json";
    XHR_RESPONSE_TYPE["TEXT"] = "text";
  })(LoaderResource2.XHR_RESPONSE_TYPE || (LoaderResource2.XHR_RESPONSE_TYPE = {}));
  LoaderResource2._loadTypeMap = {
    gif: LoaderResource2.LOAD_TYPE.IMAGE,
    png: LoaderResource2.LOAD_TYPE.IMAGE,
    bmp: LoaderResource2.LOAD_TYPE.IMAGE,
    jpg: LoaderResource2.LOAD_TYPE.IMAGE,
    jpeg: LoaderResource2.LOAD_TYPE.IMAGE,
    tif: LoaderResource2.LOAD_TYPE.IMAGE,
    tiff: LoaderResource2.LOAD_TYPE.IMAGE,
    webp: LoaderResource2.LOAD_TYPE.IMAGE,
    tga: LoaderResource2.LOAD_TYPE.IMAGE,
    svg: LoaderResource2.LOAD_TYPE.IMAGE,
    "svg+xml": LoaderResource2.LOAD_TYPE.IMAGE,
    mp3: LoaderResource2.LOAD_TYPE.AUDIO,
    ogg: LoaderResource2.LOAD_TYPE.AUDIO,
    wav: LoaderResource2.LOAD_TYPE.AUDIO,
    mp4: LoaderResource2.LOAD_TYPE.VIDEO,
    webm: LoaderResource2.LOAD_TYPE.VIDEO
  };
  LoaderResource2._xhrTypeMap = {
    xhtml: LoaderResource2.XHR_RESPONSE_TYPE.DOCUMENT,
    html: LoaderResource2.XHR_RESPONSE_TYPE.DOCUMENT,
    htm: LoaderResource2.XHR_RESPONSE_TYPE.DOCUMENT,
    xml: LoaderResource2.XHR_RESPONSE_TYPE.DOCUMENT,
    tmx: LoaderResource2.XHR_RESPONSE_TYPE.DOCUMENT,
    svg: LoaderResource2.XHR_RESPONSE_TYPE.DOCUMENT,
    tsx: LoaderResource2.XHR_RESPONSE_TYPE.DOCUMENT,
    gif: LoaderResource2.XHR_RESPONSE_TYPE.BLOB,
    png: LoaderResource2.XHR_RESPONSE_TYPE.BLOB,
    bmp: LoaderResource2.XHR_RESPONSE_TYPE.BLOB,
    jpg: LoaderResource2.XHR_RESPONSE_TYPE.BLOB,
    jpeg: LoaderResource2.XHR_RESPONSE_TYPE.BLOB,
    tif: LoaderResource2.XHR_RESPONSE_TYPE.BLOB,
    tiff: LoaderResource2.XHR_RESPONSE_TYPE.BLOB,
    webp: LoaderResource2.XHR_RESPONSE_TYPE.BLOB,
    tga: LoaderResource2.XHR_RESPONSE_TYPE.BLOB,
    json: LoaderResource2.XHR_RESPONSE_TYPE.JSON,
    text: LoaderResource2.XHR_RESPONSE_TYPE.TEXT,
    txt: LoaderResource2.XHR_RESPONSE_TYPE.TEXT,
    ttf: LoaderResource2.XHR_RESPONSE_TYPE.BUFFER,
    otf: LoaderResource2.XHR_RESPONSE_TYPE.BUFFER
  };
  LoaderResource2.EMPTY_GIF = "data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACH5BAEAAAAALAAAAAABAAEAAAICRAEAOw==";
})(LoaderResource || (LoaderResource = {}));
function _noop$1() {
}
function onlyOnce(fn) {
  return function onceWrapper() {
    var arguments$1 = arguments;
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      args[_i] = arguments$1[_i];
    }
    if (fn === null) {
      throw new Error("Callback was already called.");
    }
    var callFn = fn;
    fn = null;
    callFn.apply(this, args);
  };
}
var AsyncQueueItem = function() {
  function AsyncQueueItem2(data, callback) {
    this.data = data;
    this.callback = callback;
  }
  return AsyncQueueItem2;
}();
var AsyncQueue = function() {
  function AsyncQueue2(worker, concurrency) {
    var _this = this;
    if (concurrency === void 0) {
      concurrency = 1;
    }
    this.workers = 0;
    this.saturated = _noop$1;
    this.unsaturated = _noop$1;
    this.empty = _noop$1;
    this.drain = _noop$1;
    this.error = _noop$1;
    this.started = false;
    this.paused = false;
    this._tasks = [];
    this._insert = function(data, insertAtFront, callback) {
      if (callback && typeof callback !== "function") {
        throw new Error("task callback must be a function");
      }
      _this.started = true;
      if (data == null && _this.idle()) {
        setTimeout(function() {
          return _this.drain();
        }, 1);
        return;
      }
      var item = new AsyncQueueItem(data, typeof callback === "function" ? callback : _noop$1);
      if (insertAtFront) {
        _this._tasks.unshift(item);
      } else {
        _this._tasks.push(item);
      }
      setTimeout(_this.process, 1);
    };
    this.process = function() {
      while (!_this.paused && _this.workers < _this.concurrency && _this._tasks.length) {
        var task = _this._tasks.shift();
        if (_this._tasks.length === 0) {
          _this.empty();
        }
        _this.workers += 1;
        if (_this.workers === _this.concurrency) {
          _this.saturated();
        }
        _this._worker(task.data, onlyOnce(_this._next(task)));
      }
    };
    this._worker = worker;
    if (concurrency === 0) {
      throw new Error("Concurrency must not be zero");
    }
    this.concurrency = concurrency;
    this.buffer = concurrency / 4;
  }
  AsyncQueue2.prototype._next = function(task) {
    var _this = this;
    return function() {
      var arguments$1 = arguments;
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments$1[_i];
      }
      _this.workers -= 1;
      task.callback.apply(task, args);
      if (args[0] != null) {
        _this.error(args[0], task.data);
      }
      if (_this.workers <= _this.concurrency - _this.buffer) {
        _this.unsaturated();
      }
      if (_this.idle()) {
        _this.drain();
      }
      _this.process();
    };
  };
  AsyncQueue2.prototype.push = function(data, callback) {
    this._insert(data, false, callback);
  };
  AsyncQueue2.prototype.kill = function() {
    this.workers = 0;
    this.drain = _noop$1;
    this.started = false;
    this._tasks = [];
  };
  AsyncQueue2.prototype.unshift = function(data, callback) {
    this._insert(data, true, callback);
  };
  AsyncQueue2.prototype.length = function() {
    return this._tasks.length;
  };
  AsyncQueue2.prototype.running = function() {
    return this.workers;
  };
  AsyncQueue2.prototype.idle = function() {
    return this._tasks.length + this.workers === 0;
  };
  AsyncQueue2.prototype.pause = function() {
    if (this.paused === true) {
      return;
    }
    this.paused = true;
  };
  AsyncQueue2.prototype.resume = function() {
    if (this.paused === false) {
      return;
    }
    this.paused = false;
    for (var w2 = 1; w2 <= this.concurrency; w2++) {
      this.process();
    }
  };
  AsyncQueue2.eachSeries = function(array, iterator, callback, deferNext) {
    var i2 = 0;
    var len = array.length;
    function next(err) {
      if (err || i2 === len) {
        if (callback) {
          callback(err);
        }
        return;
      }
      if (deferNext) {
        setTimeout(function() {
          iterator(array[i2++], next);
        }, 1);
      } else {
        iterator(array[i2++], next);
      }
    }
    next();
  };
  AsyncQueue2.queue = function(worker, concurrency) {
    return new AsyncQueue2(worker, concurrency);
  };
  return AsyncQueue2;
}();
var MAX_PROGRESS = 100;
var rgxExtractUrlHash = /(#[\w-]+)?$/;
var Loader = function() {
  function Loader2(baseUrl, concurrency) {
    var _this = this;
    if (baseUrl === void 0) {
      baseUrl = "";
    }
    if (concurrency === void 0) {
      concurrency = 10;
    }
    this.progress = 0;
    this.loading = false;
    this.defaultQueryString = "";
    this._beforeMiddleware = [];
    this._afterMiddleware = [];
    this._resourcesParsing = [];
    this._boundLoadResource = function(r2, d2) {
      return _this._loadResource(r2, d2);
    };
    this.resources = {};
    this.baseUrl = baseUrl;
    this._beforeMiddleware = [];
    this._afterMiddleware = [];
    this._resourcesParsing = [];
    this._boundLoadResource = function(r2, d2) {
      return _this._loadResource(r2, d2);
    };
    this._queue = AsyncQueue.queue(this._boundLoadResource, concurrency);
    this._queue.pause();
    this.resources = {};
    this.onProgress = new Signal();
    this.onError = new Signal();
    this.onLoad = new Signal();
    this.onStart = new Signal();
    this.onComplete = new Signal();
    for (var i2 = 0; i2 < Loader2._plugins.length; ++i2) {
      var plugin = Loader2._plugins[i2];
      var pre = plugin.pre, use = plugin.use;
      if (pre) {
        this.pre(pre);
      }
      if (use) {
        this.use(use);
      }
    }
    this._protected = false;
  }
  Loader2.prototype._add = function(name2, url2, options, callback) {
    if (this.loading && (!options || !options.parentResource)) {
      throw new Error("Cannot add resources while the loader is running.");
    }
    if (this.resources[name2]) {
      throw new Error('Resource named "' + name2 + '" already exists.');
    }
    url2 = this._prepareUrl(url2);
    this.resources[name2] = new LoaderResource(name2, url2, options);
    if (typeof callback === "function") {
      this.resources[name2].onAfterMiddleware.once(callback);
    }
    if (this.loading) {
      var parent = options.parentResource;
      var incompleteChildren = [];
      for (var i2 = 0; i2 < parent.children.length; ++i2) {
        if (!parent.children[i2].isComplete) {
          incompleteChildren.push(parent.children[i2]);
        }
      }
      var fullChunk = parent.progressChunk * (incompleteChildren.length + 1);
      var eachChunk = fullChunk / (incompleteChildren.length + 2);
      parent.children.push(this.resources[name2]);
      parent.progressChunk = eachChunk;
      for (var i2 = 0; i2 < incompleteChildren.length; ++i2) {
        incompleteChildren[i2].progressChunk = eachChunk;
      }
      this.resources[name2].progressChunk = eachChunk;
    }
    this._queue.push(this.resources[name2]);
    return this;
  };
  Loader2.prototype.pre = function(fn) {
    this._beforeMiddleware.push(fn);
    return this;
  };
  Loader2.prototype.use = function(fn) {
    this._afterMiddleware.push(fn);
    return this;
  };
  Loader2.prototype.reset = function() {
    this.progress = 0;
    this.loading = false;
    this._queue.kill();
    this._queue.pause();
    for (var k in this.resources) {
      var res = this.resources[k];
      if (res._onLoadBinding) {
        res._onLoadBinding.detach();
      }
      if (res.isLoading) {
        res.abort("loader reset");
      }
    }
    this.resources = {};
    return this;
  };
  Loader2.prototype.load = function(cb) {
    if (typeof cb === "function") {
      this.onComplete.once(cb);
    }
    if (this.loading) {
      return this;
    }
    if (this._queue.idle()) {
      this._onStart();
      this._onComplete();
    } else {
      var numTasks = this._queue._tasks.length;
      var chunk = MAX_PROGRESS / numTasks;
      for (var i2 = 0; i2 < this._queue._tasks.length; ++i2) {
        this._queue._tasks[i2].data.progressChunk = chunk;
      }
      this._onStart();
      this._queue.resume();
    }
    return this;
  };
  Object.defineProperty(Loader2.prototype, "concurrency", {
    get: function() {
      return this._queue.concurrency;
    },
    set: function(concurrency) {
      this._queue.concurrency = concurrency;
    },
    enumerable: false,
    configurable: true
  });
  Loader2.prototype._prepareUrl = function(url2) {
    var parsedUrl = parseUri(url2, { strictMode: true });
    var result;
    if (parsedUrl.protocol || !parsedUrl.path || url2.indexOf("//") === 0) {
      result = url2;
    } else if (this.baseUrl.length && this.baseUrl.lastIndexOf("/") !== this.baseUrl.length - 1 && url2.charAt(0) !== "/") {
      result = this.baseUrl + "/" + url2;
    } else {
      result = this.baseUrl + url2;
    }
    if (this.defaultQueryString) {
      var hash2 = rgxExtractUrlHash.exec(result)[0];
      result = result.slice(0, result.length - hash2.length);
      if (result.indexOf("?") !== -1) {
        result += "&" + this.defaultQueryString;
      } else {
        result += "?" + this.defaultQueryString;
      }
      result += hash2;
    }
    return result;
  };
  Loader2.prototype._loadResource = function(resource, dequeue) {
    var _this = this;
    resource._dequeue = dequeue;
    AsyncQueue.eachSeries(this._beforeMiddleware, function(fn, next) {
      fn.call(_this, resource, function() {
        next(resource.isComplete ? {} : null);
      });
    }, function() {
      if (resource.isComplete) {
        _this._onLoad(resource);
      } else {
        resource._onLoadBinding = resource.onComplete.once(_this._onLoad, _this);
        resource.load();
      }
    }, true);
  };
  Loader2.prototype._onStart = function() {
    this.progress = 0;
    this.loading = true;
    this.onStart.dispatch(this);
  };
  Loader2.prototype._onComplete = function() {
    this.progress = MAX_PROGRESS;
    this.loading = false;
    this.onComplete.dispatch(this, this.resources);
  };
  Loader2.prototype._onLoad = function(resource) {
    var _this = this;
    resource._onLoadBinding = null;
    this._resourcesParsing.push(resource);
    resource._dequeue();
    AsyncQueue.eachSeries(this._afterMiddleware, function(fn, next) {
      fn.call(_this, resource, next);
    }, function() {
      resource.onAfterMiddleware.dispatch(resource);
      _this.progress = Math.min(MAX_PROGRESS, _this.progress + resource.progressChunk);
      _this.onProgress.dispatch(_this, resource);
      if (resource.error) {
        _this.onError.dispatch(resource.error, _this, resource);
      } else {
        _this.onLoad.dispatch(_this, resource);
      }
      _this._resourcesParsing.splice(_this._resourcesParsing.indexOf(resource), 1);
      if (_this._queue.idle() && _this._resourcesParsing.length === 0) {
        _this._onComplete();
      }
    }, true);
  };
  Loader2.prototype.destroy = function() {
    if (!this._protected) {
      this.reset();
    }
  };
  Object.defineProperty(Loader2, "shared", {
    get: function() {
      var shared = Loader2._shared;
      if (!shared) {
        shared = new Loader2();
        shared._protected = true;
        Loader2._shared = shared;
      }
      return shared;
    },
    enumerable: false,
    configurable: true
  });
  Loader2.registerPlugin = function(plugin) {
    Loader2._plugins.push(plugin);
    if (plugin.add) {
      plugin.add();
    }
    return Loader2;
  };
  Loader2._plugins = [];
  return Loader2;
}();
Loader.prototype.add = function add2(name2, url2, options, callback) {
  if (Array.isArray(name2)) {
    for (var i2 = 0; i2 < name2.length; ++i2) {
      this.add(name2[i2]);
    }
    return this;
  }
  if (typeof name2 === "object") {
    options = name2;
    callback = url2 || options.callback || options.onComplete;
    url2 = options.url;
    name2 = options.name || options.key || options.url;
  }
  if (typeof url2 !== "string") {
    callback = options;
    options = url2;
    url2 = name2;
  }
  if (typeof url2 !== "string") {
    throw new Error("No url passed to add resource to loader.");
  }
  if (typeof options === "function") {
    callback = options;
    options = null;
  }
  return this._add(name2, url2, options, callback);
};
var AppLoaderPlugin = function() {
  function AppLoaderPlugin2() {
  }
  AppLoaderPlugin2.init = function(options) {
    options = Object.assign({
      sharedLoader: false
    }, options);
    this.loader = options.sharedLoader ? Loader.shared : new Loader();
  };
  AppLoaderPlugin2.destroy = function() {
    if (this.loader) {
      this.loader.destroy();
      this.loader = null;
    }
  };
  return AppLoaderPlugin2;
}();
var TextureLoader = function() {
  function TextureLoader2() {
  }
  TextureLoader2.add = function() {
    LoaderResource.setExtensionLoadType("svg", LoaderResource.LOAD_TYPE.XHR);
    LoaderResource.setExtensionXhrType("svg", LoaderResource.XHR_RESPONSE_TYPE.TEXT);
  };
  TextureLoader2.use = function(resource, next) {
    if (resource.data && (resource.type === LoaderResource.TYPE.IMAGE || resource.extension === "svg")) {
      var data = resource.data, url2 = resource.url, name2 = resource.name, metadata = resource.metadata;
      Texture.fromLoader(data, url2, name2, metadata).then(function(texture) {
        resource.texture = texture;
        next();
      }).catch(next);
    } else {
      next();
    }
  };
  return TextureLoader2;
}();
var _keyStr = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
function encodeBinary(input) {
  var output = "";
  var inx = 0;
  while (inx < input.length) {
    var bytebuffer = [0, 0, 0];
    var encodedCharIndexes = [0, 0, 0, 0];
    for (var jnx = 0; jnx < bytebuffer.length; ++jnx) {
      if (inx < input.length) {
        bytebuffer[jnx] = input.charCodeAt(inx++) & 255;
      } else {
        bytebuffer[jnx] = 0;
      }
    }
    encodedCharIndexes[0] = bytebuffer[0] >> 2;
    encodedCharIndexes[1] = (bytebuffer[0] & 3) << 4 | bytebuffer[1] >> 4;
    encodedCharIndexes[2] = (bytebuffer[1] & 15) << 2 | bytebuffer[2] >> 6;
    encodedCharIndexes[3] = bytebuffer[2] & 63;
    var paddingBytes = inx - (input.length - 1);
    switch (paddingBytes) {
      case 2:
        encodedCharIndexes[3] = 64;
        encodedCharIndexes[2] = 64;
        break;
      case 1:
        encodedCharIndexes[3] = 64;
        break;
    }
    for (var jnx = 0; jnx < encodedCharIndexes.length; ++jnx) {
      output += _keyStr.charAt(encodedCharIndexes[jnx]);
    }
  }
  return output;
}
var Url = self.URL || self.webkitURL;
function parsing(resource, next) {
  if (!resource.data) {
    next();
    return;
  }
  if (resource.xhr && resource.xhrType === LoaderResource.XHR_RESPONSE_TYPE.BLOB) {
    if (!self.Blob || typeof resource.data === "string") {
      var type = resource.xhr.getResponseHeader("content-type");
      if (type && type.indexOf("image") === 0) {
        resource.data = new Image();
        resource.data.src = "data:" + type + ";base64," + encodeBinary(resource.xhr.responseText);
        resource.type = LoaderResource.TYPE.IMAGE;
        resource.data.onload = function() {
          resource.data.onload = null;
          next();
        };
        return;
      }
    } else if (resource.data.type.indexOf("image") === 0) {
      var src_1 = Url.createObjectURL(resource.data);
      resource.blob = resource.data;
      resource.data = new Image();
      resource.data.src = src_1;
      resource.type = LoaderResource.TYPE.IMAGE;
      resource.data.onload = function() {
        Url.revokeObjectURL(src_1);
        resource.data.onload = null;
        next();
      };
      return;
    }
  }
  next();
}
Loader.registerPlugin({ use: parsing });
Loader.registerPlugin(TextureLoader);
/*!
 * @pixi/sound - v4.2.0
 * https://github.com/pixijs/pixi-sound
 * Compiled Wed, 05 Jan 2022 14:56:00 UTC
 *
 * @pixi/sound is licensed under the MIT license.
 * http://www.opensource.org/licenses/mit-license
 */
var r;
function s() {
  return r;
}
var u = function(t, e) {
  return (u = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t2, e2) {
    t2.__proto__ = e2;
  } || function(t2, e2) {
    for (var n in e2)
      Object.prototype.hasOwnProperty.call(e2, n) && (t2[n] = e2[n]);
  })(t, e);
};
function a(t, e) {
  if (typeof e != "function" && e !== null)
    throw new TypeError("Class extends value " + String(e) + " is not a constructor or null");
  function n() {
    this.constructor = t;
  }
  u(t, e), t.prototype = e === null ? Object.create(e) : (n.prototype = e.prototype, new n());
}
var c = function() {
  return (c = Object.assign || function(t) {
    for (var e, n = 1, o = arguments.length; n < o; n++)
      for (var i2 in e = arguments[n])
        Object.prototype.hasOwnProperty.call(e, i2) && (t[i2] = e[i2]);
    return t;
  }).apply(this, arguments);
}, l = ["mp3", "ogg", "oga", "opus", "mpeg", "wav", "m4a", "aiff", "wma", "mid", "caf"], p$1 = {};
function h(t) {
  var e = c({ m4a: "audio/mp4", oga: "audio/ogg", opus: 'audio/ogg; codecs="opus"', caf: 'audio/x-caf; codecs="opus"' }, t || {}), n = document.createElement("audio"), o = {}, i2 = /^no$/;
  l.forEach(function(t2) {
    var r2 = n.canPlayType("audio/".concat(t2)).replace(i2, ""), s2 = e[t2] ? n.canPlayType(e[t2]).replace(i2, "") : "";
    o[t2] = !!r2 || !!s2;
  }), Object.assign(p$1, o);
}
h();
var f = /\.(\{([^\}]+)\})(\?.*)?$/;
function d(t) {
  var e = f, n = typeof t == "string" ? t : t.url;
  if (!e.test(n))
    return n;
  for (var o = e.exec(n), i2 = o[2].split(","), r2 = i2[i2.length - 1], s2 = 0, u2 = i2.length; s2 < u2; s2++) {
    var a2 = i2[s2];
    if (p$1[a2]) {
      r2 = a2;
      break;
    }
  }
  var c2 = n.replace(o[1], r2);
  if (typeof t != "string") {
    var l2 = t;
    l2.extension = r2, l2.url = c2;
  }
  return c2;
}
var _ = function() {
  function e() {
  }
  return e.add = function() {
    e.setLegacy(s().useLegacy);
  }, e.setLegacy = function(e2) {
    var n = l;
    e2 ? n.forEach(function(e3) {
      LoaderResource.setExtensionXhrType(e3, LoaderResource.XHR_RESPONSE_TYPE.DEFAULT), LoaderResource.setExtensionLoadType(e3, LoaderResource.LOAD_TYPE.AUDIO);
    }) : n.forEach(function(e3) {
      LoaderResource.setExtensionXhrType(e3, LoaderResource.XHR_RESPONSE_TYPE.BUFFER), LoaderResource.setExtensionLoadType(e3, LoaderResource.LOAD_TYPE.XHR);
    });
  }, e.pre = function(t, e2) {
    d(t), e2();
  }, e.use = function(t, e2) {
    t.data && l.indexOf(t.extension) > -1 ? t.sound = s().add(t.name, { loaded: e2, preload: true, url: t.url, source: t.data }) : e2();
  }, e;
}(), y = 0, m = function(t) {
  function e(e2) {
    var n = t.call(this) || this;
    return n.id = y++, n.init(e2), n;
  }
  return a(e, t), e.prototype.set = function(t2, e2) {
    if (this[t2] === void 0)
      throw new Error("Property with name ".concat(t2, " does not exist."));
    switch (t2) {
      case "speed":
        this.speed = e2;
        break;
      case "volume":
        this.volume = e2;
        break;
      case "paused":
        this.paused = e2;
        break;
      case "loop":
        this.loop = e2;
        break;
      case "muted":
        this.muted = e2;
    }
    return this;
  }, Object.defineProperty(e.prototype, "progress", { get: function() {
    return this._source.currentTime / this._duration;
  }, enumerable: false, configurable: true }), Object.defineProperty(e.prototype, "paused", { get: function() {
    return this._paused;
  }, set: function(t2) {
    this._paused = t2, this.refreshPaused();
  }, enumerable: false, configurable: true }), e.prototype._onPlay = function() {
    this._playing = true;
  }, e.prototype._onPause = function() {
    this._playing = false;
  }, e.prototype.init = function(t2) {
    this._playing = false, this._duration = t2.source.duration;
    var e2 = this._source = t2.source.cloneNode(false);
    e2.src = t2.parent.url, e2.onplay = this._onPlay.bind(this), e2.onpause = this._onPause.bind(this), t2.context.on("refresh", this.refresh, this), t2.context.on("refreshPaused", this.refreshPaused, this), this._media = t2;
  }, e.prototype._internalStop = function() {
    this._source && this._playing && (this._source.onended = null, this._source.pause());
  }, e.prototype.stop = function() {
    this._internalStop(), this._source && this.emit("stop");
  }, Object.defineProperty(e.prototype, "speed", { get: function() {
    return this._speed;
  }, set: function(t2) {
    this._speed = t2, this.refresh();
  }, enumerable: false, configurable: true }), Object.defineProperty(e.prototype, "volume", { get: function() {
    return this._volume;
  }, set: function(t2) {
    this._volume = t2, this.refresh();
  }, enumerable: false, configurable: true }), Object.defineProperty(e.prototype, "loop", { get: function() {
    return this._loop;
  }, set: function(t2) {
    this._loop = t2, this.refresh();
  }, enumerable: false, configurable: true }), Object.defineProperty(e.prototype, "muted", { get: function() {
    return this._muted;
  }, set: function(t2) {
    this._muted = t2, this.refresh();
  }, enumerable: false, configurable: true }), Object.defineProperty(e.prototype, "filters", { get: function() {
    return null;
  }, set: function(t2) {
  }, enumerable: false, configurable: true }), e.prototype.refresh = function() {
    var t2 = this._media.context, e2 = this._media.parent;
    this._source.loop = this._loop || e2.loop;
    var n = t2.volume * (t2.muted ? 0 : 1), o = e2.volume * (e2.muted ? 0 : 1), i2 = this._volume * (this._muted ? 0 : 1);
    this._source.volume = i2 * n * o, this._source.playbackRate = this._speed * t2.speed * e2.speed;
  }, e.prototype.refreshPaused = function() {
    var t2 = this._media.context, e2 = this._media.parent, n = this._paused || e2.paused || t2.paused;
    n !== this._pausedReal && (this._pausedReal = n, n ? (this._internalStop(), this.emit("paused")) : (this.emit("resumed"), this.play({ start: this._source.currentTime, end: this._end, volume: this._volume, speed: this._speed, loop: this._loop })), this.emit("pause", n));
  }, e.prototype.play = function(t2) {
    var n = this, i2 = t2.start, r2 = t2.end, s2 = t2.speed, u2 = t2.loop, a2 = t2.volume, c2 = t2.muted;
    this._speed = s2, this._volume = a2, this._loop = !!u2, this._muted = c2, this.refresh(), this.loop && r2 !== null && (this.loop = false), this._start = i2, this._end = r2 || this._duration, this._start = Math.max(0, this._start - e.PADDING), this._end = Math.min(this._end + e.PADDING, this._duration), this._source.onloadedmetadata = function() {
      n._source && (n._source.currentTime = i2, n._source.onloadedmetadata = null, n.emit("progress", i2, n._duration), Ticker.shared.add(n._onUpdate, n));
    }, this._source.onended = this._onComplete.bind(this), this._source.play(), this.emit("start");
  }, e.prototype._onUpdate = function() {
    this.emit("progress", this.progress, this._duration), this._source.currentTime >= this._end && !this._source.loop && this._onComplete();
  }, e.prototype._onComplete = function() {
    Ticker.shared.remove(this._onUpdate, this), this._internalStop(), this.emit("progress", 1, this._duration), this.emit("end", this);
  }, e.prototype.destroy = function() {
    Ticker.shared.remove(this._onUpdate, this), this.removeAllListeners();
    var t2 = this._source;
    t2 && (t2.onended = null, t2.onplay = null, t2.onpause = null, this._internalStop()), this._source = null, this._speed = 1, this._volume = 1, this._loop = false, this._end = null, this._start = 0, this._duration = 0, this._playing = false, this._pausedReal = false, this._paused = false, this._muted = false, this._media && (this._media.context.off("refresh", this.refresh, this), this._media.context.off("refreshPaused", this.refreshPaused, this), this._media = null);
  }, e.prototype.toString = function() {
    return "[HTMLAudioInstance id=".concat(this.id, "]");
  }, e.PADDING = 0.1, e;
}(EventEmitter$3), g = function(t) {
  function e() {
    return t !== null && t.apply(this, arguments) || this;
  }
  return a(e, t), e.prototype.init = function(t2) {
    this.parent = t2, this._source = t2.options.source || new Audio(), t2.url && (this._source.src = t2.url);
  }, e.prototype.create = function() {
    return new m(this);
  }, Object.defineProperty(e.prototype, "isPlayable", { get: function() {
    return !!this._source && this._source.readyState === 4;
  }, enumerable: false, configurable: true }), Object.defineProperty(e.prototype, "duration", { get: function() {
    return this._source.duration;
  }, enumerable: false, configurable: true }), Object.defineProperty(e.prototype, "context", { get: function() {
    return this.parent.context;
  }, enumerable: false, configurable: true }), Object.defineProperty(e.prototype, "filters", { get: function() {
    return null;
  }, set: function(t2) {
  }, enumerable: false, configurable: true }), e.prototype.destroy = function() {
    this.removeAllListeners(), this.parent = null, this._source && (this._source.src = "", this._source.load(), this._source = null);
  }, Object.defineProperty(e.prototype, "source", { get: function() {
    return this._source;
  }, enumerable: false, configurable: true }), e.prototype.load = function(t2) {
    var e2 = this._source, n = this.parent;
    if (e2.readyState !== 4)
      if (n.url) {
        e2.src = n.url;
        var o = function() {
          s2(), n.isLoaded = true;
          var e3 = n.autoPlayStart();
          t2 && t2(null, n, e3);
        }, i2 = function() {
          s2(), t2 && t2(new Error("Sound loading has been aborted"));
        }, r2 = function() {
          s2();
          var n2 = "Failed to load audio element (code: ".concat(e2.error.code, ")");
          t2 && t2(new Error(n2));
        }, s2 = function() {
          e2.removeEventListener("canplaythrough", o), e2.removeEventListener("load", o), e2.removeEventListener("abort", i2), e2.removeEventListener("error", r2);
        };
        e2.addEventListener("canplaythrough", o, false), e2.addEventListener("load", o, false), e2.addEventListener("abort", i2, false), e2.addEventListener("error", r2, false), e2.load();
      } else
        t2(new Error("sound.url or sound.source must be set"));
    else {
      n.isLoaded = true;
      var u2 = n.autoPlayStart();
      t2 && setTimeout(function() {
        t2(null, n, u2);
      }, 0);
    }
  }, e;
}(EventEmitter$3), b = function() {
  function t(t2, e) {
    this.parent = t2, Object.assign(this, e), this.duration = this.end - this.start;
  }
  return t.prototype.play = function(t2) {
    return this.parent.play({ complete: t2, speed: this.speed || this.parent.speed, end: this.end, start: this.start, loop: this.loop });
  }, t.prototype.destroy = function() {
    this.parent = null;
  }, t;
}(), v = function() {
  function t() {
  }
  return t.setParamValue = function(t2, e) {
    if (t2.setValueAtTime) {
      var n = s().context;
      t2.setValueAtTime(e, n.audioContext.currentTime);
    } else
      t2.value = e;
    return e;
  }, t;
}(), P = 0, x$1 = function(t) {
  function e(e2) {
    var n = t.call(this) || this;
    return n.id = P++, n._media = null, n._paused = false, n._muted = false, n._elapsed = 0, n.init(e2), n;
  }
  return a(e, t), e.prototype.set = function(t2, e2) {
    if (this[t2] === void 0)
      throw new Error("Property with name ".concat(t2, " does not exist."));
    switch (t2) {
      case "speed":
        this.speed = e2;
        break;
      case "volume":
        this.volume = e2;
        break;
      case "muted":
        this.muted = e2;
        break;
      case "loop":
        this.loop = e2;
        break;
      case "paused":
        this.paused = e2;
    }
    return this;
  }, e.prototype.stop = function() {
    this._source && (this._internalStop(), this.emit("stop"));
  }, Object.defineProperty(e.prototype, "speed", { get: function() {
    return this._speed;
  }, set: function(t2) {
    this._speed = t2, this.refresh(), this._update(true);
  }, enumerable: false, configurable: true }), Object.defineProperty(e.prototype, "volume", { get: function() {
    return this._volume;
  }, set: function(t2) {
    this._volume = t2, this.refresh();
  }, enumerable: false, configurable: true }), Object.defineProperty(e.prototype, "muted", { get: function() {
    return this._muted;
  }, set: function(t2) {
    this._muted = t2, this.refresh();
  }, enumerable: false, configurable: true }), Object.defineProperty(e.prototype, "loop", { get: function() {
    return this._loop;
  }, set: function(t2) {
    this._loop = t2, this.refresh();
  }, enumerable: false, configurable: true }), Object.defineProperty(e.prototype, "filters", { get: function() {
    return this._filters;
  }, set: function(t2) {
    var e2;
    this._filters && ((e2 = this._filters) === null || e2 === void 0 || e2.filter(function(t3) {
      return t3;
    }).forEach(function(t3) {
      return t3.disconnect();
    }), this._filters = null, this._source.connect(this._gain)), this._filters = (t2 == null ? void 0 : t2.length) ? t2.slice(0) : null, this.refresh();
  }, enumerable: false, configurable: true }), e.prototype.refresh = function() {
    if (this._source) {
      var t2 = this._media.context, e2 = this._media.parent;
      this._source.loop = this._loop || e2.loop;
      var n = t2.volume * (t2.muted ? 0 : 1), o = e2.volume * (e2.muted ? 0 : 1), i2 = this._volume * (this._muted ? 0 : 1);
      v.setParamValue(this._gain.gain, i2 * o * n), v.setParamValue(this._source.playbackRate, this._speed * e2.speed * t2.speed), this.applyFilters();
    }
  }, e.prototype.applyFilters = function() {
    var t2;
    if ((t2 = this._filters) === null || t2 === void 0 ? void 0 : t2.length) {
      this._source.disconnect();
      var e2 = this._source;
      this._filters.forEach(function(t3) {
        e2.connect(t3.destination), e2 = t3;
      }), e2.connect(this._gain);
    }
  }, e.prototype.refreshPaused = function() {
    var t2 = this._media.context, e2 = this._media.parent, n = this._paused || e2.paused || t2.paused;
    n !== this._pausedReal && (this._pausedReal = n, n ? (this._internalStop(), this.emit("paused")) : (this.emit("resumed"), this.play({ start: this._elapsed % this._duration, end: this._end, speed: this._speed, loop: this._loop, volume: this._volume })), this.emit("pause", n));
  }, e.prototype.play = function(t2) {
    var e2 = t2.start, n = t2.end, o = t2.speed, i2 = t2.loop, r2 = t2.volume, s2 = t2.muted, u2 = t2.filters;
    this._paused = false;
    var a2 = this._media.nodes.cloneBufferSource(), c2 = a2.source, l2 = a2.gain;
    this._source = c2, this._gain = l2, this._speed = o, this._volume = r2, this._loop = !!i2, this._muted = s2, this._filters = u2, this.refresh();
    var p2 = this._source.buffer.duration;
    this._duration = p2, this._end = n, this._lastUpdate = this._now(), this._elapsed = e2, this._source.onended = this._onComplete.bind(this), this._loop ? (this._source.loopEnd = n, this._source.loopStart = e2, this._source.start(0, e2)) : n ? this._source.start(0, e2, n - e2) : this._source.start(0, e2), this.emit("start"), this._update(true), this.enableTicker(true);
  }, e.prototype.enableTicker = function(t2) {
    Ticker.shared.remove(this._updateListener, this), t2 && Ticker.shared.add(this._updateListener, this);
  }, Object.defineProperty(e.prototype, "progress", { get: function() {
    return this._progress;
  }, enumerable: false, configurable: true }), Object.defineProperty(e.prototype, "paused", { get: function() {
    return this._paused;
  }, set: function(t2) {
    this._paused = t2, this.refreshPaused();
  }, enumerable: false, configurable: true }), e.prototype.destroy = function() {
    var t2;
    this.removeAllListeners(), this._internalStop(), this._gain && (this._gain.disconnect(), this._gain = null), this._media && (this._media.context.events.off("refresh", this.refresh, this), this._media.context.events.off("refreshPaused", this.refreshPaused, this), this._media = null), (t2 = this._filters) === null || t2 === void 0 || t2.forEach(function(t3) {
      return t3.disconnect();
    }), this._filters = null, this._end = null, this._speed = 1, this._volume = 1, this._loop = false, this._elapsed = 0, this._duration = 0, this._paused = false, this._muted = false, this._pausedReal = false;
  }, e.prototype.toString = function() {
    return "[WebAudioInstance id=".concat(this.id, "]");
  }, e.prototype._now = function() {
    return this._media.context.audioContext.currentTime;
  }, e.prototype._updateListener = function() {
    this._update();
  }, e.prototype._update = function(t2) {
    if (t2 === void 0 && (t2 = false), this._source) {
      var e2 = this._now(), n = e2 - this._lastUpdate;
      if (n > 0 || t2) {
        var o = this._source.playbackRate.value;
        this._elapsed += n * o, this._lastUpdate = e2;
        var i2 = this._duration, r2 = void 0;
        if (this._source.loopStart) {
          var s2 = this._source.loopEnd - this._source.loopStart;
          r2 = (this._source.loopStart + this._elapsed % s2) / i2;
        } else
          r2 = this._elapsed % i2 / i2;
        this._progress = r2, this.emit("progress", this._progress, i2);
      }
    }
  }, e.prototype.init = function(t2) {
    this._media = t2, t2.context.events.on("refresh", this.refresh, this), t2.context.events.on("refreshPaused", this.refreshPaused, this);
  }, e.prototype._internalStop = function() {
    if (this._source) {
      this.enableTicker(false), this._source.onended = null, this._source.stop(0), this._source.disconnect();
      try {
        this._source.buffer = null;
      } catch (t2) {
      }
      this._source = null;
    }
  }, e.prototype._onComplete = function() {
    if (this._source) {
      this.enableTicker(false), this._source.onended = null, this._source.disconnect();
      try {
        this._source.buffer = null;
      } catch (t2) {
      }
    }
    this._source = null, this._progress = 1, this.emit("progress", 1, this._duration), this.emit("end", this);
  }, e;
}(EventEmitter$3), O = function() {
  function t(t2, e) {
    this._output = e, this._input = t2;
  }
  return Object.defineProperty(t.prototype, "destination", { get: function() {
    return this._input;
  }, enumerable: false, configurable: true }), Object.defineProperty(t.prototype, "filters", { get: function() {
    return this._filters;
  }, set: function(t2) {
    var e = this;
    if (this._filters && (this._filters.forEach(function(t3) {
      t3 && t3.disconnect();
    }), this._filters = null, this._input.connect(this._output)), t2 && t2.length) {
      this._filters = t2.slice(0), this._input.disconnect();
      var n = null;
      t2.forEach(function(t3) {
        n === null ? e._input.connect(t3.destination) : n.connect(t3.destination), n = t3;
      }), n.connect(this._output);
    }
  }, enumerable: false, configurable: true }), t.prototype.destroy = function() {
    this.filters = null, this._input = null, this._output = null;
  }, t;
}(), j = function(t) {
  function e(e2) {
    var n = this, o = e2.audioContext, i2 = o.createBufferSource(), r2 = o.createGain(), s2 = o.createAnalyser();
    return i2.connect(s2), s2.connect(r2), r2.connect(e2.destination), (n = t.call(this, s2, r2) || this).context = e2, n.bufferSource = i2, n.gain = r2, n.analyser = s2, n;
  }
  return a(e, t), Object.defineProperty(e.prototype, "script", { get: function() {
    return this._script || (this._script = this.context.audioContext.createScriptProcessor(e.BUFFER_SIZE), this._script.connect(this.context.destination)), this._script;
  }, enumerable: false, configurable: true }), e.prototype.destroy = function() {
    t.prototype.destroy.call(this), this.bufferSource.disconnect(), this._script && this._script.disconnect(), this.gain.disconnect(), this.analyser.disconnect(), this.bufferSource = null, this._script = null, this.gain = null, this.analyser = null, this.context = null;
  }, e.prototype.cloneBufferSource = function() {
    var t2 = this.bufferSource, e2 = this.context.audioContext.createBufferSource();
    e2.buffer = t2.buffer, v.setParamValue(e2.playbackRate, t2.playbackRate.value), e2.loop = t2.loop;
    var n = this.context.audioContext.createGain();
    return e2.connect(n), n.connect(this.destination), { source: e2, gain: n };
  }, Object.defineProperty(e.prototype, "bufferSize", { get: function() {
    return this.script.bufferSize;
  }, enumerable: false, configurable: true }), e.BUFFER_SIZE = 0, e;
}(O), w = function() {
  function t() {
  }
  return t.prototype.init = function(t2) {
    this.parent = t2, this._nodes = new j(this.context), this._source = this._nodes.bufferSource, this.source = t2.options.source;
  }, t.prototype.destroy = function() {
    this.parent = null, this._nodes.destroy(), this._nodes = null;
    try {
      this._source.buffer = null;
    } catch (t2) {
    }
    this._source = null, this.source = null;
  }, t.prototype.create = function() {
    return new x$1(this);
  }, Object.defineProperty(t.prototype, "context", { get: function() {
    return this.parent.context;
  }, enumerable: false, configurable: true }), Object.defineProperty(t.prototype, "isPlayable", { get: function() {
    return !!this._source && !!this._source.buffer;
  }, enumerable: false, configurable: true }), Object.defineProperty(t.prototype, "filters", { get: function() {
    return this._nodes.filters;
  }, set: function(t2) {
    this._nodes.filters = t2;
  }, enumerable: false, configurable: true }), Object.defineProperty(t.prototype, "duration", { get: function() {
    return this._source.buffer.duration;
  }, enumerable: false, configurable: true }), Object.defineProperty(t.prototype, "buffer", { get: function() {
    return this._source.buffer;
  }, set: function(t2) {
    this._source.buffer = t2;
  }, enumerable: false, configurable: true }), Object.defineProperty(t.prototype, "nodes", { get: function() {
    return this._nodes;
  }, enumerable: false, configurable: true }), t.prototype.load = function(t2) {
    this.source ? this._decode(this.source, t2) : this.parent.url ? this._loadUrl(t2) : t2 && t2(new Error("sound.url or sound.source must be set"));
  }, t.prototype._loadUrl = function(t2) {
    var e = this, n = new XMLHttpRequest(), o = this.parent.url;
    n.open("GET", o, true), n.responseType = "arraybuffer", n.onload = function() {
      e.source = n.response, e._decode(n.response, t2);
    }, n.send();
  }, t.prototype._decode = function(t2, e) {
    var n = this, o = function(t3, o2) {
      if (t3)
        e && e(t3);
      else {
        n.parent.isLoaded = true, n.buffer = o2;
        var i2 = n.parent.autoPlayStart();
        e && e(null, n.parent, i2);
      }
    };
    t2 instanceof AudioBuffer ? o(null, t2) : this.parent.context.decode(t2, o);
  }, t;
}(), A = function() {
  function t(t2, e) {
    this.media = t2, this.options = e, this._instances = [], this._sprites = {}, this.media.init(this);
    var n = e.complete;
    this._autoPlayOptions = n ? { complete: n } : null, this.isLoaded = false, this.isPlaying = false, this.autoPlay = e.autoPlay, this.singleInstance = e.singleInstance, this.preload = e.preload || this.autoPlay, this.url = e.url, this.speed = e.speed, this.volume = e.volume, this.loop = e.loop, e.sprites && this.addSprites(e.sprites), this.preload && this._preload(e.loaded);
  }
  return t.from = function(e) {
    var n = {};
    return typeof e == "string" ? n.url = e : e instanceof ArrayBuffer || e instanceof AudioBuffer || e instanceof HTMLAudioElement ? n.source = e : n = e, (n = c({ autoPlay: false, singleInstance: false, url: null, source: null, preload: false, volume: 1, speed: 1, complete: null, loaded: null, loop: false }, n)).url && (n.url = d(n.url)), Object.freeze(n), new t(s().useLegacy ? new g() : new w(), n);
  }, Object.defineProperty(t.prototype, "context", { get: function() {
    return s().context;
  }, enumerable: false, configurable: true }), t.prototype.pause = function() {
    return this.isPlaying = false, this.paused = true, this;
  }, t.prototype.resume = function() {
    return this.isPlaying = this._instances.length > 0, this.paused = false, this;
  }, Object.defineProperty(t.prototype, "paused", { get: function() {
    return this._paused;
  }, set: function(t2) {
    this._paused = t2, this.refreshPaused();
  }, enumerable: false, configurable: true }), Object.defineProperty(t.prototype, "speed", { get: function() {
    return this._speed;
  }, set: function(t2) {
    this._speed = t2, this.refresh();
  }, enumerable: false, configurable: true }), Object.defineProperty(t.prototype, "filters", { get: function() {
    return this.media.filters;
  }, set: function(t2) {
    this.media.filters = t2;
  }, enumerable: false, configurable: true }), t.prototype.addSprites = function(t2, e) {
    if (typeof t2 == "object") {
      var n = {};
      for (var o in t2)
        n[o] = this.addSprites(o, t2[o]);
      return n;
    }
    var i2 = new b(this, e);
    return this._sprites[t2] = i2, i2;
  }, t.prototype.destroy = function() {
    this._removeInstances(), this.removeSprites(), this.media.destroy(), this.media = null, this._sprites = null, this._instances = null;
  }, t.prototype.removeSprites = function(t2) {
    if (t2) {
      var e = this._sprites[t2];
      e !== void 0 && (e.destroy(), delete this._sprites[t2]);
    } else
      for (var n in this._sprites)
        this.removeSprites(n);
    return this;
  }, Object.defineProperty(t.prototype, "isPlayable", { get: function() {
    return this.isLoaded && this.media && this.media.isPlayable;
  }, enumerable: false, configurable: true }), t.prototype.stop = function() {
    if (!this.isPlayable)
      return this.autoPlay = false, this._autoPlayOptions = null, this;
    this.isPlaying = false;
    for (var t2 = this._instances.length - 1; t2 >= 0; t2--)
      this._instances[t2].stop();
    return this;
  }, t.prototype.play = function(t2, e) {
    var n, o = this;
    typeof t2 == "string" ? n = { sprite: r2 = t2, loop: this.loop, complete: e } : typeof t2 == "function" ? (n = {}).complete = t2 : n = t2;
    if ((n = c({ complete: null, loaded: null, sprite: null, end: null, start: 0, volume: 1, speed: 1, muted: false, loop: false }, n || {})).sprite) {
      var i2 = n.sprite, r2 = this._sprites[i2];
      n.start = r2.start + (n.start || 0), n.end = r2.end, n.speed = r2.speed || 1, n.loop = r2.loop || n.loop, delete n.sprite;
    }
    if (n.offset && (n.start = n.offset), !this.isLoaded)
      return new Promise(function(t3, e2) {
        o.autoPlay = true, o._autoPlayOptions = n, o._preload(function(o2, i3, r3) {
          o2 ? e2(o2) : (n.loaded && n.loaded(o2, i3, r3), t3(r3));
        });
      });
    (this.singleInstance || n.singleInstance) && this._removeInstances();
    var s2 = this._createInstance();
    return this._instances.push(s2), this.isPlaying = true, s2.once("end", function() {
      n.complete && n.complete(o), o._onComplete(s2);
    }), s2.once("stop", function() {
      o._onComplete(s2);
    }), s2.play(n), s2;
  }, t.prototype.refresh = function() {
    for (var t2 = this._instances.length, e = 0; e < t2; e++)
      this._instances[e].refresh();
  }, t.prototype.refreshPaused = function() {
    for (var t2 = this._instances.length, e = 0; e < t2; e++)
      this._instances[e].refreshPaused();
  }, Object.defineProperty(t.prototype, "volume", { get: function() {
    return this._volume;
  }, set: function(t2) {
    this._volume = t2, this.refresh();
  }, enumerable: false, configurable: true }), Object.defineProperty(t.prototype, "muted", { get: function() {
    return this._muted;
  }, set: function(t2) {
    this._muted = t2, this.refresh();
  }, enumerable: false, configurable: true }), Object.defineProperty(t.prototype, "loop", { get: function() {
    return this._loop;
  }, set: function(t2) {
    this._loop = t2, this.refresh();
  }, enumerable: false, configurable: true }), t.prototype._preload = function(t2) {
    this.media.load(t2);
  }, Object.defineProperty(t.prototype, "instances", { get: function() {
    return this._instances;
  }, enumerable: false, configurable: true }), Object.defineProperty(t.prototype, "sprites", { get: function() {
    return this._sprites;
  }, enumerable: false, configurable: true }), Object.defineProperty(t.prototype, "duration", { get: function() {
    return this.media.duration;
  }, enumerable: false, configurable: true }), t.prototype.autoPlayStart = function() {
    var t2;
    return this.autoPlay && (t2 = this.play(this._autoPlayOptions)), t2;
  }, t.prototype._removeInstances = function() {
    for (var t2 = this._instances.length - 1; t2 >= 0; t2--)
      this._poolInstance(this._instances[t2]);
    this._instances.length = 0;
  }, t.prototype._onComplete = function(t2) {
    if (this._instances) {
      var e = this._instances.indexOf(t2);
      e > -1 && this._instances.splice(e, 1), this.isPlaying = this._instances.length > 0;
    }
    this._poolInstance(t2);
  }, t.prototype._createInstance = function() {
    if (t._pool.length > 0) {
      var e = t._pool.pop();
      return e.init(this.media), e;
    }
    return this.media.create();
  }, t.prototype._poolInstance = function(e) {
    e.destroy(), t._pool.indexOf(e) < 0 && t._pool.push(e);
  }, t._pool = [], t;
}(), F = function(t) {
  function e() {
    var e2 = t !== null && t.apply(this, arguments) || this;
    return e2.speed = 1, e2.muted = false, e2.volume = 1, e2.paused = false, e2;
  }
  return a(e, t), e.prototype.refresh = function() {
    this.emit("refresh");
  }, e.prototype.refreshPaused = function() {
    this.emit("refreshPaused");
  }, Object.defineProperty(e.prototype, "filters", { get: function() {
    return null;
  }, set: function(t2) {
  }, enumerable: false, configurable: true }), Object.defineProperty(e.prototype, "audioContext", { get: function() {
    return null;
  }, enumerable: false, configurable: true }), e.prototype.toggleMute = function() {
    return this.muted = !this.muted, this.refresh(), this.muted;
  }, e.prototype.togglePause = function() {
    return this.paused = !this.paused, this.refreshPaused(), this.paused;
  }, e.prototype.destroy = function() {
    this.removeAllListeners();
  }, e;
}(EventEmitter$3), C = function(t) {
  function e() {
    var o = this, i2 = window, r2 = new e.AudioContext(), s2 = r2.createDynamicsCompressor(), u2 = r2.createAnalyser();
    return u2.connect(s2), s2.connect(r2.destination), (o = t.call(this, u2, s2) || this)._ctx = r2, o._offlineCtx = new e.OfflineAudioContext(1, 2, i2.OfflineAudioContext ? r2.sampleRate : 44100), o._unlocked = false, o.compressor = s2, o.analyser = u2, o.events = new EventEmitter$3(), o.volume = 1, o.speed = 1, o.muted = false, o.paused = false, r2.state !== "running" && (o._unlock(), o._unlock = o._unlock.bind(o), document.addEventListener("mousedown", o._unlock, true), document.addEventListener("touchstart", o._unlock, true), document.addEventListener("touchend", o._unlock, true)), o;
  }
  return a(e, t), e.prototype._unlock = function() {
    this._unlocked || (this.playEmptySound(), this._ctx.state === "running" && (document.removeEventListener("mousedown", this._unlock, true), document.removeEventListener("touchend", this._unlock, true), document.removeEventListener("touchstart", this._unlock, true), this._unlocked = true));
  }, e.prototype.playEmptySound = function() {
    var t2 = this._ctx.createBufferSource();
    t2.buffer = this._ctx.createBuffer(1, 1, 22050), t2.connect(this._ctx.destination), t2.start(0, 0, 0), t2.context.state === "suspended" && t2.context.resume();
  }, Object.defineProperty(e, "AudioContext", { get: function() {
    var t2 = window;
    return t2.AudioContext || t2.webkitAudioContext || null;
  }, enumerable: false, configurable: true }), Object.defineProperty(e, "OfflineAudioContext", { get: function() {
    var t2 = window;
    return t2.OfflineAudioContext || t2.webkitOfflineAudioContext || null;
  }, enumerable: false, configurable: true }), e.prototype.destroy = function() {
    t.prototype.destroy.call(this);
    var e2 = this._ctx;
    e2.close !== void 0 && e2.close(), this.events.removeAllListeners(), this.analyser.disconnect(), this.compressor.disconnect(), this.analyser = null, this.compressor = null, this.events = null, this._offlineCtx = null, this._ctx = null;
  }, Object.defineProperty(e.prototype, "audioContext", { get: function() {
    return this._ctx;
  }, enumerable: false, configurable: true }), Object.defineProperty(e.prototype, "offlineContext", { get: function() {
    return this._offlineCtx;
  }, enumerable: false, configurable: true }), Object.defineProperty(e.prototype, "paused", { get: function() {
    return this._paused;
  }, set: function(t2) {
    t2 && this._ctx.state === "running" ? this._ctx.suspend() : t2 || this._ctx.state !== "suspended" || this._ctx.resume(), this._paused = t2;
  }, enumerable: false, configurable: true }), e.prototype.refresh = function() {
    this.events.emit("refresh");
  }, e.prototype.refreshPaused = function() {
    this.events.emit("refreshPaused");
  }, e.prototype.toggleMute = function() {
    return this.muted = !this.muted, this.refresh(), this.muted;
  }, e.prototype.togglePause = function() {
    return this.paused = !this.paused, this.refreshPaused(), this._paused;
  }, e.prototype.decode = function(t2, e2) {
    var n = function(t3) {
      e2(new Error(t3.message || "Unable to decode file"));
    }, o = this._offlineCtx.decodeAudioData(t2, function(t3) {
      e2(null, t3);
    }, n);
    o && o.catch(n);
  }, e;
}(O), E = function() {
  function t() {
    this.init();
  }
  return t.prototype.init = function() {
    return this.supported && (this._webAudioContext = new C()), this._htmlAudioContext = new F(), this._sounds = {}, this.useLegacy = !this.supported, this;
  }, Object.defineProperty(t.prototype, "context", { get: function() {
    return this._context;
  }, enumerable: false, configurable: true }), Object.defineProperty(t.prototype, "filtersAll", { get: function() {
    return this.useLegacy ? [] : this._context.filters;
  }, set: function(t2) {
    this.useLegacy || (this._context.filters = t2);
  }, enumerable: false, configurable: true }), Object.defineProperty(t.prototype, "supported", { get: function() {
    return C.AudioContext !== null;
  }, enumerable: false, configurable: true }), t.prototype.add = function(t2, e) {
    if (typeof t2 == "object") {
      var n = {};
      for (var o in t2) {
        var i2 = this._getOptions(t2[o], e);
        n[o] = this.add(o, i2);
      }
      return n;
    }
    if (e instanceof A)
      return this._sounds[t2] = e, e;
    var r2 = this._getOptions(e), s2 = A.from(r2);
    return this._sounds[t2] = s2, s2;
  }, t.prototype._getOptions = function(t2, e) {
    var n;
    return n = typeof t2 == "string" ? { url: t2 } : t2 instanceof ArrayBuffer || t2 instanceof AudioBuffer || t2 instanceof HTMLAudioElement ? { source: t2 } : t2, n = c(c({}, n), e || {});
  }, Object.defineProperty(t.prototype, "useLegacy", { get: function() {
    return this._useLegacy;
  }, set: function(t2) {
    _.setLegacy(t2), this._useLegacy = t2, this._context = !t2 && this.supported ? this._webAudioContext : this._htmlAudioContext;
  }, enumerable: false, configurable: true }), t.prototype.remove = function(t2) {
    return this.exists(t2, true), this._sounds[t2].destroy(), delete this._sounds[t2], this;
  }, Object.defineProperty(t.prototype, "volumeAll", { get: function() {
    return this._context.volume;
  }, set: function(t2) {
    this._context.volume = t2, this._context.refresh();
  }, enumerable: false, configurable: true }), Object.defineProperty(t.prototype, "speedAll", { get: function() {
    return this._context.speed;
  }, set: function(t2) {
    this._context.speed = t2, this._context.refresh();
  }, enumerable: false, configurable: true }), t.prototype.togglePauseAll = function() {
    return this._context.togglePause();
  }, t.prototype.pauseAll = function() {
    return this._context.paused = true, this._context.refreshPaused(), this;
  }, t.prototype.resumeAll = function() {
    return this._context.paused = false, this._context.refreshPaused(), this;
  }, t.prototype.toggleMuteAll = function() {
    return this._context.toggleMute();
  }, t.prototype.muteAll = function() {
    return this._context.muted = true, this._context.refresh(), this;
  }, t.prototype.unmuteAll = function() {
    return this._context.muted = false, this._context.refresh(), this;
  }, t.prototype.removeAll = function() {
    for (var t2 in this._sounds)
      this._sounds[t2].destroy(), delete this._sounds[t2];
    return this;
  }, t.prototype.stopAll = function() {
    for (var t2 in this._sounds)
      this._sounds[t2].stop();
    return this;
  }, t.prototype.exists = function(t2, e) {
    return !!this._sounds[t2];
  }, t.prototype.find = function(t2) {
    return this.exists(t2, true), this._sounds[t2];
  }, t.prototype.play = function(t2, e) {
    return this.find(t2).play(e);
  }, t.prototype.stop = function(t2) {
    return this.find(t2).stop();
  }, t.prototype.pause = function(t2) {
    return this.find(t2).pause();
  }, t.prototype.resume = function(t2) {
    return this.find(t2).resume();
  }, t.prototype.volume = function(t2, e) {
    var n = this.find(t2);
    return e !== void 0 && (n.volume = e), n.volume;
  }, t.prototype.speed = function(t2, e) {
    var n = this.find(t2);
    return e !== void 0 && (n.speed = e), n.speed;
  }, t.prototype.duration = function(t2) {
    return this.find(t2).duration;
  }, t.prototype.close = function() {
    return this.removeAll(), this._sounds = null, this._webAudioContext && (this._webAudioContext.destroy(), this._webAudioContext = null), this._htmlAudioContext && (this._htmlAudioContext.destroy(), this._htmlAudioContext = null), this._context = null, this;
  }, t;
}(), S = function() {
  function t(t2, e) {
    this.init(t2, e);
  }
  return t.prototype.init = function(t2, e) {
    this.destination = t2, this.source = e || t2;
  }, t.prototype.connect = function(t2) {
    this.source.connect(t2);
  }, t.prototype.disconnect = function() {
    this.source.disconnect();
  }, t.prototype.destroy = function() {
    this.disconnect(), this.destination = null, this.source = null;
  }, t;
}();
({ __proto__: null, Filter: S, EqualizerFilter: function(t) {
  function e(n, o, i2, r2, u2, a2, c2, l2, p2, h2) {
    n === void 0 && (n = 0), o === void 0 && (o = 0), i2 === void 0 && (i2 = 0), r2 === void 0 && (r2 = 0), u2 === void 0 && (u2 = 0), a2 === void 0 && (a2 = 0), c2 === void 0 && (c2 = 0), l2 === void 0 && (l2 = 0), p2 === void 0 && (p2 = 0), h2 === void 0 && (h2 = 0);
    var f2 = this;
    if (!s().useLegacy) {
      var d2 = [{ f: e.F32, type: "lowshelf", gain: n }, { f: e.F64, type: "peaking", gain: o }, { f: e.F125, type: "peaking", gain: i2 }, { f: e.F250, type: "peaking", gain: r2 }, { f: e.F500, type: "peaking", gain: u2 }, { f: e.F1K, type: "peaking", gain: a2 }, { f: e.F2K, type: "peaking", gain: c2 }, { f: e.F4K, type: "peaking", gain: l2 }, { f: e.F8K, type: "peaking", gain: p2 }, { f: e.F16K, type: "highshelf", gain: h2 }].map(function(t2) {
        var e2 = s().context.audioContext.createBiquadFilter();
        return e2.type = t2.type, v.setParamValue(e2.Q, 1), e2.frequency.value = t2.f, v.setParamValue(e2.gain, t2.gain), e2;
      });
      (f2 = t.call(this, d2[0], d2[d2.length - 1]) || this).bands = d2, f2.bandsMap = {};
      for (var _2 = 0; _2 < f2.bands.length; _2++) {
        var y2 = f2.bands[_2];
        _2 > 0 && f2.bands[_2 - 1].connect(y2), f2.bandsMap[y2.frequency.value] = y2;
      }
      return f2;
    }
    f2 = t.call(this, null) || this;
  }
  return a(e, t), e.prototype.setGain = function(t2, e2) {
    if (e2 === void 0 && (e2 = 0), !this.bandsMap[t2])
      throw new Error("No band found for frequency ".concat(t2));
    v.setParamValue(this.bandsMap[t2].gain, e2);
  }, e.prototype.getGain = function(t2) {
    if (!this.bandsMap[t2])
      throw new Error("No band found for frequency ".concat(t2));
    return this.bandsMap[t2].gain.value;
  }, Object.defineProperty(e.prototype, "f32", { get: function() {
    return this.getGain(e.F32);
  }, set: function(t2) {
    this.setGain(e.F32, t2);
  }, enumerable: false, configurable: true }), Object.defineProperty(e.prototype, "f64", { get: function() {
    return this.getGain(e.F64);
  }, set: function(t2) {
    this.setGain(e.F64, t2);
  }, enumerable: false, configurable: true }), Object.defineProperty(e.prototype, "f125", { get: function() {
    return this.getGain(e.F125);
  }, set: function(t2) {
    this.setGain(e.F125, t2);
  }, enumerable: false, configurable: true }), Object.defineProperty(e.prototype, "f250", { get: function() {
    return this.getGain(e.F250);
  }, set: function(t2) {
    this.setGain(e.F250, t2);
  }, enumerable: false, configurable: true }), Object.defineProperty(e.prototype, "f500", { get: function() {
    return this.getGain(e.F500);
  }, set: function(t2) {
    this.setGain(e.F500, t2);
  }, enumerable: false, configurable: true }), Object.defineProperty(e.prototype, "f1k", { get: function() {
    return this.getGain(e.F1K);
  }, set: function(t2) {
    this.setGain(e.F1K, t2);
  }, enumerable: false, configurable: true }), Object.defineProperty(e.prototype, "f2k", { get: function() {
    return this.getGain(e.F2K);
  }, set: function(t2) {
    this.setGain(e.F2K, t2);
  }, enumerable: false, configurable: true }), Object.defineProperty(e.prototype, "f4k", { get: function() {
    return this.getGain(e.F4K);
  }, set: function(t2) {
    this.setGain(e.F4K, t2);
  }, enumerable: false, configurable: true }), Object.defineProperty(e.prototype, "f8k", { get: function() {
    return this.getGain(e.F8K);
  }, set: function(t2) {
    this.setGain(e.F8K, t2);
  }, enumerable: false, configurable: true }), Object.defineProperty(e.prototype, "f16k", { get: function() {
    return this.getGain(e.F16K);
  }, set: function(t2) {
    this.setGain(e.F16K, t2);
  }, enumerable: false, configurable: true }), e.prototype.reset = function() {
    this.bands.forEach(function(t2) {
      v.setParamValue(t2.gain, 0);
    });
  }, e.prototype.destroy = function() {
    this.bands.forEach(function(t2) {
      t2.disconnect();
    }), this.bands = null, this.bandsMap = null;
  }, e.F32 = 32, e.F64 = 64, e.F125 = 125, e.F250 = 250, e.F500 = 500, e.F1K = 1e3, e.F2K = 2e3, e.F4K = 4e3, e.F8K = 8e3, e.F16K = 16e3, e;
}(S), DistortionFilter: function(t) {
  function e(e2) {
    e2 === void 0 && (e2 = 0);
    var n = this;
    if (!s().useLegacy) {
      var o = s().context.audioContext.createWaveShaper();
      return (n = t.call(this, o) || this)._distortion = o, n.amount = e2, n;
    }
    n = t.call(this, null) || this;
  }
  return a(e, t), Object.defineProperty(e.prototype, "amount", { get: function() {
    return this._amount;
  }, set: function(t2) {
    this._amount = t2;
    for (var e2, n = 1e3 * t2, o = 44100, i2 = new Float32Array(o), r2 = Math.PI / 180, s2 = 0; s2 < o; ++s2)
      e2 = 2 * s2 / o - 1, i2[s2] = (3 + n) * e2 * 20 * r2 / (Math.PI + n * Math.abs(e2));
    this._distortion.curve = i2, this._distortion.oversample = "4x";
  }, enumerable: false, configurable: true }), e.prototype.destroy = function() {
    this._distortion = null, t.prototype.destroy.call(this);
  }, e;
}(S), StereoFilter: function(t) {
  function e(e2) {
    e2 === void 0 && (e2 = 0);
    var n = this;
    if (!s().useLegacy) {
      var o, i2, r2, u2 = s().context.audioContext;
      return u2.createStereoPanner ? r2 = o = u2.createStereoPanner() : ((i2 = u2.createPanner()).panningModel = "equalpower", r2 = i2), (n = t.call(this, r2) || this)._stereo = o, n._panner = i2, n.pan = e2, n;
    }
    n = t.call(this, null) || this;
  }
  return a(e, t), Object.defineProperty(e.prototype, "pan", { get: function() {
    return this._pan;
  }, set: function(t2) {
    this._pan = t2, this._stereo ? v.setParamValue(this._stereo.pan, t2) : this._panner.setPosition(t2, 0, 1 - Math.abs(t2));
  }, enumerable: false, configurable: true }), e.prototype.destroy = function() {
    t.prototype.destroy.call(this), this._stereo = null, this._panner = null;
  }, e;
}(S), ReverbFilter: function(t) {
  function e(e2, n, o) {
    e2 === void 0 && (e2 = 3), n === void 0 && (n = 2), o === void 0 && (o = false);
    var i2 = this;
    if (!s().useLegacy)
      return (i2 = t.call(this, null) || this)._seconds = i2._clamp(e2, 1, 50), i2._decay = i2._clamp(n, 0, 100), i2._reverse = o, i2._rebuild(), i2;
    i2 = t.call(this, null) || this;
  }
  return a(e, t), e.prototype._clamp = function(t2, e2, n) {
    return Math.min(n, Math.max(e2, t2));
  }, Object.defineProperty(e.prototype, "seconds", { get: function() {
    return this._seconds;
  }, set: function(t2) {
    this._seconds = this._clamp(t2, 1, 50), this._rebuild();
  }, enumerable: false, configurable: true }), Object.defineProperty(e.prototype, "decay", { get: function() {
    return this._decay;
  }, set: function(t2) {
    this._decay = this._clamp(t2, 0, 100), this._rebuild();
  }, enumerable: false, configurable: true }), Object.defineProperty(e.prototype, "reverse", { get: function() {
    return this._reverse;
  }, set: function(t2) {
    this._reverse = t2, this._rebuild();
  }, enumerable: false, configurable: true }), e.prototype._rebuild = function() {
    for (var t2, e2 = s().context.audioContext, n = e2.sampleRate, o = n * this._seconds, i2 = e2.createBuffer(2, o, n), r2 = i2.getChannelData(0), u2 = i2.getChannelData(1), a2 = 0; a2 < o; a2++)
      t2 = this._reverse ? o - a2 : a2, r2[a2] = (2 * Math.random() - 1) * Math.pow(1 - t2 / o, this._decay), u2[a2] = (2 * Math.random() - 1) * Math.pow(1 - t2 / o, this._decay);
    var c2 = s().context.audioContext.createConvolver();
    c2.buffer = i2, this.init(c2);
  }, e;
}(S), MonoFilter: function(t) {
  function e() {
    var e2 = this;
    if (!s().useLegacy) {
      var n = s().context.audioContext, o = n.createChannelSplitter(), i2 = n.createChannelMerger();
      return i2.connect(o), (e2 = t.call(this, i2, o) || this)._merger = i2, e2;
    }
    e2 = t.call(this, null) || this;
  }
  return a(e, t), e.prototype.destroy = function() {
    this._merger.disconnect(), this._merger = null, t.prototype.destroy.call(this);
  }, e;
}(S), StreamFilter: function(t) {
  function e() {
    var e2 = this;
    if (!s().useLegacy) {
      var n = s().context.audioContext, o = n.createMediaStreamDestination(), i2 = n.createMediaStreamSource(o.stream);
      return (e2 = t.call(this, o, i2) || this)._stream = o.stream, e2;
    }
    e2 = t.call(this, null) || this;
  }
  return a(e, t), Object.defineProperty(e.prototype, "stream", { get: function() {
    return this._stream;
  }, enumerable: false, configurable: true }), e.prototype.destroy = function() {
    this._stream = null, t.prototype.destroy.call(this);
  }, e;
}(S), TelephoneFilter: function(t) {
  function e() {
    if (!s().useLegacy) {
      var e2 = s().context.audioContext, n = e2.createBiquadFilter(), o = e2.createBiquadFilter(), i2 = e2.createBiquadFilter(), r2 = e2.createBiquadFilter();
      return n.type = "lowpass", v.setParamValue(n.frequency, 2e3), o.type = "lowpass", v.setParamValue(o.frequency, 2e3), i2.type = "highpass", v.setParamValue(i2.frequency, 500), r2.type = "highpass", v.setParamValue(r2.frequency, 500), n.connect(o), o.connect(i2), i2.connect(r2), t.call(this, n, r2) || this;
    }
    t.call(this, null);
  }
  return a(e, t), e;
}(S) });
var T = 0;
var G = { __proto__: null, playOnce: function(t, e) {
  var n = "alias".concat(T++);
  return s().add(n, { url: t, preload: true, autoPlay: true, loaded: function(t2) {
    t2 && (s().remove(n), e && e(t2));
  }, complete: function() {
    s().remove(n), e && e(null);
  } }), n;
}, get PLAY_ID() {
  return T;
}, render: function(t, e) {
  var n = document.createElement("canvas");
  e = c({ width: 512, height: 128, fill: "black" }, e || {}), n.width = e.width, n.height = e.height;
  var o = BaseTexture.from(n);
  if (!(t.media instanceof w))
    return o;
  var r2 = t.media, s2 = n.getContext("2d");
  s2.fillStyle = e.fill;
  for (var u2 = r2.buffer.getChannelData(0), a2 = Math.ceil(u2.length / e.width), l2 = e.height / 2, p2 = 0; p2 < e.width; p2++) {
    for (var h2 = 1, f2 = -1, d2 = 0; d2 < a2; d2++) {
      var _2 = u2[p2 * a2 + d2];
      _2 < h2 && (h2 = _2), _2 > f2 && (f2 = _2);
    }
    s2.fillRect(p2, (1 + h2) * l2, 1, Math.max(1, (f2 - h2) * l2));
  }
  return o;
}, resolveUrl: d, sineTone: function(t, e) {
  t === void 0 && (t = 200), e === void 0 && (e = 1);
  var n = A.from({ singleInstance: true });
  if (!(n.media instanceof w))
    return n;
  for (var o = n.media, i2 = n.context.audioContext.createBuffer(1, 48e3 * e, 48e3), r2 = i2.getChannelData(0), s2 = 0; s2 < r2.length; s2++) {
    var u2 = t * (s2 / i2.sampleRate) * Math.PI;
    r2[s2] = 2 * Math.sin(u2);
  }
  return o.buffer = i2, n.isLoaded = true, n;
}, validateFormats: h, supported: p$1, extensions: l }, I = function(t) {
  return r = t, t;
}(new E());
Loader.registerPlugin(_);
function finallyConstructor(callback) {
  var constructor = this.constructor;
  return this.then(function(value) {
    return constructor.resolve(callback()).then(function() {
      return value;
    });
  }, function(reason) {
    return constructor.resolve(callback()).then(function() {
      return constructor.reject(reason);
    });
  });
}
function allSettled(arr) {
  var P2 = this;
  return new P2(function(resolve2, reject2) {
    if (!(arr && typeof arr.length !== "undefined")) {
      return reject2(new TypeError(typeof arr + " " + arr + " is not iterable(cannot read property Symbol(Symbol.iterator))"));
    }
    var args = Array.prototype.slice.call(arr);
    if (args.length === 0)
      return resolve2([]);
    var remaining = args.length;
    function res(i3, val) {
      if (val && (typeof val === "object" || typeof val === "function")) {
        var then = val.then;
        if (typeof then === "function") {
          then.call(val, function(val2) {
            res(i3, val2);
          }, function(e) {
            args[i3] = { status: "rejected", reason: e };
            if (--remaining === 0) {
              resolve2(args);
            }
          });
          return;
        }
      }
      args[i3] = { status: "fulfilled", value: val };
      if (--remaining === 0) {
        resolve2(args);
      }
    }
    for (var i2 = 0; i2 < args.length; i2++) {
      res(i2, args[i2]);
    }
  });
}
var setTimeoutFunc = setTimeout;
function isArray$1(x2) {
  return Boolean(x2 && typeof x2.length !== "undefined");
}
function noop() {
}
function bind$2(fn, thisArg) {
  return function() {
    fn.apply(thisArg, arguments);
  };
}
function Promise$1(fn) {
  if (!(this instanceof Promise$1))
    throw new TypeError("Promises must be constructed via new");
  if (typeof fn !== "function")
    throw new TypeError("not a function");
  this._state = 0;
  this._handled = false;
  this._value = void 0;
  this._deferreds = [];
  doResolve(fn, this);
}
function handle(self2, deferred) {
  while (self2._state === 3) {
    self2 = self2._value;
  }
  if (self2._state === 0) {
    self2._deferreds.push(deferred);
    return;
  }
  self2._handled = true;
  Promise$1._immediateFn(function() {
    var cb = self2._state === 1 ? deferred.onFulfilled : deferred.onRejected;
    if (cb === null) {
      (self2._state === 1 ? resolve : reject)(deferred.promise, self2._value);
      return;
    }
    var ret;
    try {
      ret = cb(self2._value);
    } catch (e) {
      reject(deferred.promise, e);
      return;
    }
    resolve(deferred.promise, ret);
  });
}
function resolve(self2, newValue) {
  try {
    if (newValue === self2)
      throw new TypeError("A promise cannot be resolved with itself.");
    if (newValue && (typeof newValue === "object" || typeof newValue === "function")) {
      var then = newValue.then;
      if (newValue instanceof Promise$1) {
        self2._state = 3;
        self2._value = newValue;
        finale(self2);
        return;
      } else if (typeof then === "function") {
        doResolve(bind$2(then, newValue), self2);
        return;
      }
    }
    self2._state = 1;
    self2._value = newValue;
    finale(self2);
  } catch (e) {
    reject(self2, e);
  }
}
function reject(self2, newValue) {
  self2._state = 2;
  self2._value = newValue;
  finale(self2);
}
function finale(self2) {
  if (self2._state === 2 && self2._deferreds.length === 0) {
    Promise$1._immediateFn(function() {
      if (!self2._handled) {
        Promise$1._unhandledRejectionFn(self2._value);
      }
    });
  }
  for (var i2 = 0, len = self2._deferreds.length; i2 < len; i2++) {
    handle(self2, self2._deferreds[i2]);
  }
  self2._deferreds = null;
}
function Handler(onFulfilled, onRejected, promise) {
  this.onFulfilled = typeof onFulfilled === "function" ? onFulfilled : null;
  this.onRejected = typeof onRejected === "function" ? onRejected : null;
  this.promise = promise;
}
function doResolve(fn, self2) {
  var done = false;
  try {
    fn(function(value) {
      if (done)
        return;
      done = true;
      resolve(self2, value);
    }, function(reason) {
      if (done)
        return;
      done = true;
      reject(self2, reason);
    });
  } catch (ex) {
    if (done)
      return;
    done = true;
    reject(self2, ex);
  }
}
Promise$1.prototype["catch"] = function(onRejected) {
  return this.then(null, onRejected);
};
Promise$1.prototype.then = function(onFulfilled, onRejected) {
  var prom = new this.constructor(noop);
  handle(this, new Handler(onFulfilled, onRejected, prom));
  return prom;
};
Promise$1.prototype["finally"] = finallyConstructor;
Promise$1.all = function(arr) {
  return new Promise$1(function(resolve2, reject2) {
    if (!isArray$1(arr)) {
      return reject2(new TypeError("Promise.all accepts an array"));
    }
    var args = Array.prototype.slice.call(arr);
    if (args.length === 0)
      return resolve2([]);
    var remaining = args.length;
    function res(i3, val) {
      try {
        if (val && (typeof val === "object" || typeof val === "function")) {
          var then = val.then;
          if (typeof then === "function") {
            then.call(val, function(val2) {
              res(i3, val2);
            }, reject2);
            return;
          }
        }
        args[i3] = val;
        if (--remaining === 0) {
          resolve2(args);
        }
      } catch (ex) {
        reject2(ex);
      }
    }
    for (var i2 = 0; i2 < args.length; i2++) {
      res(i2, args[i2]);
    }
  });
};
Promise$1.allSettled = allSettled;
Promise$1.resolve = function(value) {
  if (value && typeof value === "object" && value.constructor === Promise$1) {
    return value;
  }
  return new Promise$1(function(resolve2) {
    resolve2(value);
  });
};
Promise$1.reject = function(value) {
  return new Promise$1(function(resolve2, reject2) {
    reject2(value);
  });
};
Promise$1.race = function(arr) {
  return new Promise$1(function(resolve2, reject2) {
    if (!isArray$1(arr)) {
      return reject2(new TypeError("Promise.race accepts an array"));
    }
    for (var i2 = 0, len = arr.length; i2 < len; i2++) {
      Promise$1.resolve(arr[i2]).then(resolve2, reject2);
    }
  });
};
Promise$1._immediateFn = typeof setImmediate === "function" && function(fn) {
  setImmediate(fn);
} || function(fn) {
  setTimeoutFunc(fn, 0);
};
Promise$1._unhandledRejectionFn = function _unhandledRejectionFn(err) {
  if (typeof console !== "undefined" && console) {
    console.warn("Possible Unhandled Promise Rejection:", err);
  }
};
/*
object-assign
(c) Sindre Sorhus
@license MIT
*/
var getOwnPropertySymbols = Object.getOwnPropertySymbols;
var hasOwnProperty = Object.prototype.hasOwnProperty;
var propIsEnumerable = Object.prototype.propertyIsEnumerable;
function toObject(val) {
  if (val === null || val === void 0) {
    throw new TypeError("Object.assign cannot be called with null or undefined");
  }
  return Object(val);
}
function shouldUseNative() {
  try {
    if (!Object.assign) {
      return false;
    }
    var test1 = new String("abc");
    test1[5] = "de";
    if (Object.getOwnPropertyNames(test1)[0] === "5") {
      return false;
    }
    var test2 = {};
    for (var i2 = 0; i2 < 10; i2++) {
      test2["_" + String.fromCharCode(i2)] = i2;
    }
    var order2 = Object.getOwnPropertyNames(test2).map(function(n) {
      return test2[n];
    });
    if (order2.join("") !== "0123456789") {
      return false;
    }
    var test3 = {};
    "abcdefghijklmnopqrst".split("").forEach(function(letter) {
      test3[letter] = letter;
    });
    if (Object.keys(Object.assign({}, test3)).join("") !== "abcdefghijklmnopqrst") {
      return false;
    }
    return true;
  } catch (err) {
    return false;
  }
}
var objectAssign = shouldUseNative() ? Object.assign : function(target, source) {
  var from;
  var to = toObject(target);
  var symbols;
  for (var s2 = 1; s2 < arguments.length; s2++) {
    from = Object(arguments[s2]);
    for (var key in from) {
      if (hasOwnProperty.call(from, key)) {
        to[key] = from[key];
      }
    }
    if (getOwnPropertySymbols) {
      symbols = getOwnPropertySymbols(from);
      for (var i2 = 0; i2 < symbols.length; i2++) {
        if (propIsEnumerable.call(from, symbols[i2])) {
          to[symbols[i2]] = from[symbols[i2]];
        }
      }
    }
  }
  return to;
};
/*!
 * @pixi/polyfill - v6.3.0
 * Compiled Wed, 23 Mar 2022 18:58:56 UTC
 *
 * @pixi/polyfill is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
if (typeof globalThis === "undefined") {
  if (typeof self !== "undefined") {
    self.globalThis = self;
  } else if (typeof global !== "undefined") {
    global.globalThis = global;
  }
}
if (!globalThis.Promise) {
  globalThis.Promise = Promise$1;
}
if (!Object.assign) {
  Object.assign = objectAssign;
}
var ONE_FRAME_TIME = 16;
if (!(Date.now && Date.prototype.getTime)) {
  Date.now = function now2() {
    return new Date().getTime();
  };
}
if (!(globalThis.performance && globalThis.performance.now)) {
  var startTime_1 = Date.now();
  if (!globalThis.performance) {
    globalThis.performance = {};
  }
  globalThis.performance.now = function() {
    return Date.now() - startTime_1;
  };
}
var lastTime = Date.now();
var vendors = ["ms", "moz", "webkit", "o"];
for (var x = 0; x < vendors.length && !globalThis.requestAnimationFrame; ++x) {
  var p = vendors[x];
  globalThis.requestAnimationFrame = globalThis[p + "RequestAnimationFrame"];
  globalThis.cancelAnimationFrame = globalThis[p + "CancelAnimationFrame"] || globalThis[p + "CancelRequestAnimationFrame"];
}
if (!globalThis.requestAnimationFrame) {
  globalThis.requestAnimationFrame = function(callback) {
    if (typeof callback !== "function") {
      throw new TypeError(callback + "is not a function");
    }
    var currentTime = Date.now();
    var delay = ONE_FRAME_TIME + lastTime - currentTime;
    if (delay < 0) {
      delay = 0;
    }
    lastTime = currentTime;
    return globalThis.self.setTimeout(function() {
      lastTime = Date.now();
      callback(performance.now());
    }, delay);
  };
}
if (!globalThis.cancelAnimationFrame) {
  globalThis.cancelAnimationFrame = function(id) {
    return clearTimeout(id);
  };
}
if (!Math.sign) {
  Math.sign = function mathSign(x2) {
    x2 = Number(x2);
    if (x2 === 0 || isNaN(x2)) {
      return x2;
    }
    return x2 > 0 ? 1 : -1;
  };
}
if (!Number.isInteger) {
  Number.isInteger = function numberIsInteger(value) {
    return typeof value === "number" && isFinite(value) && Math.floor(value) === value;
  };
}
if (!globalThis.ArrayBuffer) {
  globalThis.ArrayBuffer = Array;
}
if (!globalThis.Float32Array) {
  globalThis.Float32Array = Array;
}
if (!globalThis.Uint32Array) {
  globalThis.Uint32Array = Array;
}
if (!globalThis.Uint16Array) {
  globalThis.Uint16Array = Array;
}
if (!globalThis.Uint8Array) {
  globalThis.Uint8Array = Array;
}
if (!globalThis.Int32Array) {
  globalThis.Int32Array = Array;
}
/*!
 * @pixi/display - v6.3.0
 * Compiled Wed, 23 Mar 2022 18:58:56 UTC
 *
 * @pixi/display is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
settings.SORTABLE_CHILDREN = false;
var Bounds = function() {
  function Bounds2() {
    this.minX = Infinity;
    this.minY = Infinity;
    this.maxX = -Infinity;
    this.maxY = -Infinity;
    this.rect = null;
    this.updateID = -1;
  }
  Bounds2.prototype.isEmpty = function() {
    return this.minX > this.maxX || this.minY > this.maxY;
  };
  Bounds2.prototype.clear = function() {
    this.minX = Infinity;
    this.minY = Infinity;
    this.maxX = -Infinity;
    this.maxY = -Infinity;
  };
  Bounds2.prototype.getRectangle = function(rect) {
    if (this.minX > this.maxX || this.minY > this.maxY) {
      return Rectangle.EMPTY;
    }
    rect = rect || new Rectangle(0, 0, 1, 1);
    rect.x = this.minX;
    rect.y = this.minY;
    rect.width = this.maxX - this.minX;
    rect.height = this.maxY - this.minY;
    return rect;
  };
  Bounds2.prototype.addPoint = function(point) {
    this.minX = Math.min(this.minX, point.x);
    this.maxX = Math.max(this.maxX, point.x);
    this.minY = Math.min(this.minY, point.y);
    this.maxY = Math.max(this.maxY, point.y);
  };
  Bounds2.prototype.addPointMatrix = function(matrix, point) {
    var a2 = matrix.a, b2 = matrix.b, c2 = matrix.c, d2 = matrix.d, tx = matrix.tx, ty = matrix.ty;
    var x2 = a2 * point.x + c2 * point.y + tx;
    var y2 = b2 * point.x + d2 * point.y + ty;
    this.minX = Math.min(this.minX, x2);
    this.maxX = Math.max(this.maxX, x2);
    this.minY = Math.min(this.minY, y2);
    this.maxY = Math.max(this.maxY, y2);
  };
  Bounds2.prototype.addQuad = function(vertices) {
    var minX = this.minX;
    var minY = this.minY;
    var maxX = this.maxX;
    var maxY = this.maxY;
    var x2 = vertices[0];
    var y2 = vertices[1];
    minX = x2 < minX ? x2 : minX;
    minY = y2 < minY ? y2 : minY;
    maxX = x2 > maxX ? x2 : maxX;
    maxY = y2 > maxY ? y2 : maxY;
    x2 = vertices[2];
    y2 = vertices[3];
    minX = x2 < minX ? x2 : minX;
    minY = y2 < minY ? y2 : minY;
    maxX = x2 > maxX ? x2 : maxX;
    maxY = y2 > maxY ? y2 : maxY;
    x2 = vertices[4];
    y2 = vertices[5];
    minX = x2 < minX ? x2 : minX;
    minY = y2 < minY ? y2 : minY;
    maxX = x2 > maxX ? x2 : maxX;
    maxY = y2 > maxY ? y2 : maxY;
    x2 = vertices[6];
    y2 = vertices[7];
    minX = x2 < minX ? x2 : minX;
    minY = y2 < minY ? y2 : minY;
    maxX = x2 > maxX ? x2 : maxX;
    maxY = y2 > maxY ? y2 : maxY;
    this.minX = minX;
    this.minY = minY;
    this.maxX = maxX;
    this.maxY = maxY;
  };
  Bounds2.prototype.addFrame = function(transform, x0, y0, x1, y1) {
    this.addFrameMatrix(transform.worldTransform, x0, y0, x1, y1);
  };
  Bounds2.prototype.addFrameMatrix = function(matrix, x0, y0, x1, y1) {
    var a2 = matrix.a;
    var b2 = matrix.b;
    var c2 = matrix.c;
    var d2 = matrix.d;
    var tx = matrix.tx;
    var ty = matrix.ty;
    var minX = this.minX;
    var minY = this.minY;
    var maxX = this.maxX;
    var maxY = this.maxY;
    var x2 = a2 * x0 + c2 * y0 + tx;
    var y2 = b2 * x0 + d2 * y0 + ty;
    minX = x2 < minX ? x2 : minX;
    minY = y2 < minY ? y2 : minY;
    maxX = x2 > maxX ? x2 : maxX;
    maxY = y2 > maxY ? y2 : maxY;
    x2 = a2 * x1 + c2 * y0 + tx;
    y2 = b2 * x1 + d2 * y0 + ty;
    minX = x2 < minX ? x2 : minX;
    minY = y2 < minY ? y2 : minY;
    maxX = x2 > maxX ? x2 : maxX;
    maxY = y2 > maxY ? y2 : maxY;
    x2 = a2 * x0 + c2 * y1 + tx;
    y2 = b2 * x0 + d2 * y1 + ty;
    minX = x2 < minX ? x2 : minX;
    minY = y2 < minY ? y2 : minY;
    maxX = x2 > maxX ? x2 : maxX;
    maxY = y2 > maxY ? y2 : maxY;
    x2 = a2 * x1 + c2 * y1 + tx;
    y2 = b2 * x1 + d2 * y1 + ty;
    minX = x2 < minX ? x2 : minX;
    minY = y2 < minY ? y2 : minY;
    maxX = x2 > maxX ? x2 : maxX;
    maxY = y2 > maxY ? y2 : maxY;
    this.minX = minX;
    this.minY = minY;
    this.maxX = maxX;
    this.maxY = maxY;
  };
  Bounds2.prototype.addVertexData = function(vertexData, beginOffset, endOffset) {
    var minX = this.minX;
    var minY = this.minY;
    var maxX = this.maxX;
    var maxY = this.maxY;
    for (var i2 = beginOffset; i2 < endOffset; i2 += 2) {
      var x2 = vertexData[i2];
      var y2 = vertexData[i2 + 1];
      minX = x2 < minX ? x2 : minX;
      minY = y2 < minY ? y2 : minY;
      maxX = x2 > maxX ? x2 : maxX;
      maxY = y2 > maxY ? y2 : maxY;
    }
    this.minX = minX;
    this.minY = minY;
    this.maxX = maxX;
    this.maxY = maxY;
  };
  Bounds2.prototype.addVertices = function(transform, vertices, beginOffset, endOffset) {
    this.addVerticesMatrix(transform.worldTransform, vertices, beginOffset, endOffset);
  };
  Bounds2.prototype.addVerticesMatrix = function(matrix, vertices, beginOffset, endOffset, padX, padY) {
    if (padX === void 0) {
      padX = 0;
    }
    if (padY === void 0) {
      padY = padX;
    }
    var a2 = matrix.a;
    var b2 = matrix.b;
    var c2 = matrix.c;
    var d2 = matrix.d;
    var tx = matrix.tx;
    var ty = matrix.ty;
    var minX = this.minX;
    var minY = this.minY;
    var maxX = this.maxX;
    var maxY = this.maxY;
    for (var i2 = beginOffset; i2 < endOffset; i2 += 2) {
      var rawX = vertices[i2];
      var rawY = vertices[i2 + 1];
      var x2 = a2 * rawX + c2 * rawY + tx;
      var y2 = d2 * rawY + b2 * rawX + ty;
      minX = Math.min(minX, x2 - padX);
      maxX = Math.max(maxX, x2 + padX);
      minY = Math.min(minY, y2 - padY);
      maxY = Math.max(maxY, y2 + padY);
    }
    this.minX = minX;
    this.minY = minY;
    this.maxX = maxX;
    this.maxY = maxY;
  };
  Bounds2.prototype.addBounds = function(bounds) {
    var minX = this.minX;
    var minY = this.minY;
    var maxX = this.maxX;
    var maxY = this.maxY;
    this.minX = bounds.minX < minX ? bounds.minX : minX;
    this.minY = bounds.minY < minY ? bounds.minY : minY;
    this.maxX = bounds.maxX > maxX ? bounds.maxX : maxX;
    this.maxY = bounds.maxY > maxY ? bounds.maxY : maxY;
  };
  Bounds2.prototype.addBoundsMask = function(bounds, mask) {
    var _minX = bounds.minX > mask.minX ? bounds.minX : mask.minX;
    var _minY = bounds.minY > mask.minY ? bounds.minY : mask.minY;
    var _maxX = bounds.maxX < mask.maxX ? bounds.maxX : mask.maxX;
    var _maxY = bounds.maxY < mask.maxY ? bounds.maxY : mask.maxY;
    if (_minX <= _maxX && _minY <= _maxY) {
      var minX = this.minX;
      var minY = this.minY;
      var maxX = this.maxX;
      var maxY = this.maxY;
      this.minX = _minX < minX ? _minX : minX;
      this.minY = _minY < minY ? _minY : minY;
      this.maxX = _maxX > maxX ? _maxX : maxX;
      this.maxY = _maxY > maxY ? _maxY : maxY;
    }
  };
  Bounds2.prototype.addBoundsMatrix = function(bounds, matrix) {
    this.addFrameMatrix(matrix, bounds.minX, bounds.minY, bounds.maxX, bounds.maxY);
  };
  Bounds2.prototype.addBoundsArea = function(bounds, area2) {
    var _minX = bounds.minX > area2.x ? bounds.minX : area2.x;
    var _minY = bounds.minY > area2.y ? bounds.minY : area2.y;
    var _maxX = bounds.maxX < area2.x + area2.width ? bounds.maxX : area2.x + area2.width;
    var _maxY = bounds.maxY < area2.y + area2.height ? bounds.maxY : area2.y + area2.height;
    if (_minX <= _maxX && _minY <= _maxY) {
      var minX = this.minX;
      var minY = this.minY;
      var maxX = this.maxX;
      var maxY = this.maxY;
      this.minX = _minX < minX ? _minX : minX;
      this.minY = _minY < minY ? _minY : minY;
      this.maxX = _maxX > maxX ? _maxX : maxX;
      this.maxY = _maxY > maxY ? _maxY : maxY;
    }
  };
  Bounds2.prototype.pad = function(paddingX, paddingY) {
    if (paddingX === void 0) {
      paddingX = 0;
    }
    if (paddingY === void 0) {
      paddingY = paddingX;
    }
    if (!this.isEmpty()) {
      this.minX -= paddingX;
      this.maxX += paddingX;
      this.minY -= paddingY;
      this.maxY += paddingY;
    }
  };
  Bounds2.prototype.addFramePad = function(x0, y0, x1, y1, padX, padY) {
    x0 -= padX;
    y0 -= padY;
    x1 += padX;
    y1 += padY;
    this.minX = this.minX < x0 ? this.minX : x0;
    this.maxX = this.maxX > x1 ? this.maxX : x1;
    this.minY = this.minY < y0 ? this.minY : y0;
    this.maxY = this.maxY > y1 ? this.maxY : y1;
  };
  return Bounds2;
}();
/*! *****************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */
var extendStatics$p = function(d2, b2) {
  extendStatics$p = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {
    d3.__proto__ = b3;
  } || function(d3, b3) {
    for (var p2 in b3) {
      if (b3.hasOwnProperty(p2)) {
        d3[p2] = b3[p2];
      }
    }
  };
  return extendStatics$p(d2, b2);
};
function __extends$p(d2, b2) {
  extendStatics$p(d2, b2);
  function __() {
    this.constructor = d2;
  }
  d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
}
var DisplayObject = function(_super) {
  __extends$p(DisplayObject2, _super);
  function DisplayObject2() {
    var _this = _super.call(this) || this;
    _this.tempDisplayObjectParent = null;
    _this.transform = new Transform();
    _this.alpha = 1;
    _this.visible = true;
    _this.renderable = true;
    _this.cullable = false;
    _this.cullArea = null;
    _this.parent = null;
    _this.worldAlpha = 1;
    _this._lastSortedIndex = 0;
    _this._zIndex = 0;
    _this.filterArea = null;
    _this.filters = null;
    _this._enabledFilters = null;
    _this._bounds = new Bounds();
    _this._localBounds = null;
    _this._boundsID = 0;
    _this._boundsRect = null;
    _this._localBoundsRect = null;
    _this._mask = null;
    _this._maskRefCount = 0;
    _this._destroyed = false;
    _this.isSprite = false;
    _this.isMask = false;
    return _this;
  }
  DisplayObject2.mixin = function(source) {
    var keys = Object.keys(source);
    for (var i2 = 0; i2 < keys.length; ++i2) {
      var propertyName = keys[i2];
      Object.defineProperty(DisplayObject2.prototype, propertyName, Object.getOwnPropertyDescriptor(source, propertyName));
    }
  };
  Object.defineProperty(DisplayObject2.prototype, "destroyed", {
    get: function() {
      return this._destroyed;
    },
    enumerable: false,
    configurable: true
  });
  DisplayObject2.prototype._recursivePostUpdateTransform = function() {
    if (this.parent) {
      this.parent._recursivePostUpdateTransform();
      this.transform.updateTransform(this.parent.transform);
    } else {
      this.transform.updateTransform(this._tempDisplayObjectParent.transform);
    }
  };
  DisplayObject2.prototype.updateTransform = function() {
    this._boundsID++;
    this.transform.updateTransform(this.parent.transform);
    this.worldAlpha = this.alpha * this.parent.worldAlpha;
  };
  DisplayObject2.prototype.getBounds = function(skipUpdate, rect) {
    if (!skipUpdate) {
      if (!this.parent) {
        this.parent = this._tempDisplayObjectParent;
        this.updateTransform();
        this.parent = null;
      } else {
        this._recursivePostUpdateTransform();
        this.updateTransform();
      }
    }
    if (this._bounds.updateID !== this._boundsID) {
      this.calculateBounds();
      this._bounds.updateID = this._boundsID;
    }
    if (!rect) {
      if (!this._boundsRect) {
        this._boundsRect = new Rectangle();
      }
      rect = this._boundsRect;
    }
    return this._bounds.getRectangle(rect);
  };
  DisplayObject2.prototype.getLocalBounds = function(rect) {
    if (!rect) {
      if (!this._localBoundsRect) {
        this._localBoundsRect = new Rectangle();
      }
      rect = this._localBoundsRect;
    }
    if (!this._localBounds) {
      this._localBounds = new Bounds();
    }
    var transformRef = this.transform;
    var parentRef = this.parent;
    this.parent = null;
    this.transform = this._tempDisplayObjectParent.transform;
    var worldBounds = this._bounds;
    var worldBoundsID = this._boundsID;
    this._bounds = this._localBounds;
    var bounds = this.getBounds(false, rect);
    this.parent = parentRef;
    this.transform = transformRef;
    this._bounds = worldBounds;
    this._bounds.updateID += this._boundsID - worldBoundsID;
    return bounds;
  };
  DisplayObject2.prototype.toGlobal = function(position, point, skipUpdate) {
    if (skipUpdate === void 0) {
      skipUpdate = false;
    }
    if (!skipUpdate) {
      this._recursivePostUpdateTransform();
      if (!this.parent) {
        this.parent = this._tempDisplayObjectParent;
        this.displayObjectUpdateTransform();
        this.parent = null;
      } else {
        this.displayObjectUpdateTransform();
      }
    }
    return this.worldTransform.apply(position, point);
  };
  DisplayObject2.prototype.toLocal = function(position, from, point, skipUpdate) {
    if (from) {
      position = from.toGlobal(position, point, skipUpdate);
    }
    if (!skipUpdate) {
      this._recursivePostUpdateTransform();
      if (!this.parent) {
        this.parent = this._tempDisplayObjectParent;
        this.displayObjectUpdateTransform();
        this.parent = null;
      } else {
        this.displayObjectUpdateTransform();
      }
    }
    return this.worldTransform.applyInverse(position, point);
  };
  DisplayObject2.prototype.setParent = function(container) {
    if (!container || !container.addChild) {
      throw new Error("setParent: Argument must be a Container");
    }
    container.addChild(this);
    return container;
  };
  DisplayObject2.prototype.setTransform = function(x2, y2, scaleX, scaleY, rotation, skewX, skewY, pivotX, pivotY) {
    if (x2 === void 0) {
      x2 = 0;
    }
    if (y2 === void 0) {
      y2 = 0;
    }
    if (scaleX === void 0) {
      scaleX = 1;
    }
    if (scaleY === void 0) {
      scaleY = 1;
    }
    if (rotation === void 0) {
      rotation = 0;
    }
    if (skewX === void 0) {
      skewX = 0;
    }
    if (skewY === void 0) {
      skewY = 0;
    }
    if (pivotX === void 0) {
      pivotX = 0;
    }
    if (pivotY === void 0) {
      pivotY = 0;
    }
    this.position.x = x2;
    this.position.y = y2;
    this.scale.x = !scaleX ? 1 : scaleX;
    this.scale.y = !scaleY ? 1 : scaleY;
    this.rotation = rotation;
    this.skew.x = skewX;
    this.skew.y = skewY;
    this.pivot.x = pivotX;
    this.pivot.y = pivotY;
    return this;
  };
  DisplayObject2.prototype.destroy = function(_options) {
    if (this.parent) {
      this.parent.removeChild(this);
    }
    this.emit("destroyed");
    this.removeAllListeners();
    this.transform = null;
    this.parent = null;
    this._bounds = null;
    this.mask = null;
    this.cullArea = null;
    this.filters = null;
    this.filterArea = null;
    this.hitArea = null;
    this.interactive = false;
    this.interactiveChildren = false;
    this._destroyed = true;
  };
  Object.defineProperty(DisplayObject2.prototype, "_tempDisplayObjectParent", {
    get: function() {
      if (this.tempDisplayObjectParent === null) {
        this.tempDisplayObjectParent = new TemporaryDisplayObject();
      }
      return this.tempDisplayObjectParent;
    },
    enumerable: false,
    configurable: true
  });
  DisplayObject2.prototype.enableTempParent = function() {
    var myParent = this.parent;
    this.parent = this._tempDisplayObjectParent;
    return myParent;
  };
  DisplayObject2.prototype.disableTempParent = function(cacheParent) {
    this.parent = cacheParent;
  };
  Object.defineProperty(DisplayObject2.prototype, "x", {
    get: function() {
      return this.position.x;
    },
    set: function(value) {
      this.transform.position.x = value;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(DisplayObject2.prototype, "y", {
    get: function() {
      return this.position.y;
    },
    set: function(value) {
      this.transform.position.y = value;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(DisplayObject2.prototype, "worldTransform", {
    get: function() {
      return this.transform.worldTransform;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(DisplayObject2.prototype, "localTransform", {
    get: function() {
      return this.transform.localTransform;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(DisplayObject2.prototype, "position", {
    get: function() {
      return this.transform.position;
    },
    set: function(value) {
      this.transform.position.copyFrom(value);
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(DisplayObject2.prototype, "scale", {
    get: function() {
      return this.transform.scale;
    },
    set: function(value) {
      this.transform.scale.copyFrom(value);
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(DisplayObject2.prototype, "pivot", {
    get: function() {
      return this.transform.pivot;
    },
    set: function(value) {
      this.transform.pivot.copyFrom(value);
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(DisplayObject2.prototype, "skew", {
    get: function() {
      return this.transform.skew;
    },
    set: function(value) {
      this.transform.skew.copyFrom(value);
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(DisplayObject2.prototype, "rotation", {
    get: function() {
      return this.transform.rotation;
    },
    set: function(value) {
      this.transform.rotation = value;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(DisplayObject2.prototype, "angle", {
    get: function() {
      return this.transform.rotation * RAD_TO_DEG;
    },
    set: function(value) {
      this.transform.rotation = value * DEG_TO_RAD;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(DisplayObject2.prototype, "zIndex", {
    get: function() {
      return this._zIndex;
    },
    set: function(value) {
      this._zIndex = value;
      if (this.parent) {
        this.parent.sortDirty = true;
      }
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(DisplayObject2.prototype, "worldVisible", {
    get: function() {
      var item = this;
      do {
        if (!item.visible) {
          return false;
        }
        item = item.parent;
      } while (item);
      return true;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(DisplayObject2.prototype, "mask", {
    get: function() {
      return this._mask;
    },
    set: function(value) {
      if (this._mask === value) {
        return;
      }
      if (this._mask) {
        var maskObject = this._mask.maskObject || this._mask;
        maskObject._maskRefCount--;
        if (maskObject._maskRefCount === 0) {
          maskObject.renderable = true;
          maskObject.isMask = false;
        }
      }
      this._mask = value;
      if (this._mask) {
        var maskObject = this._mask.maskObject || this._mask;
        if (maskObject._maskRefCount === 0) {
          maskObject.renderable = false;
          maskObject.isMask = true;
        }
        maskObject._maskRefCount++;
      }
    },
    enumerable: false,
    configurable: true
  });
  return DisplayObject2;
}(EventEmitter$3);
var TemporaryDisplayObject = function(_super) {
  __extends$p(TemporaryDisplayObject2, _super);
  function TemporaryDisplayObject2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.sortDirty = null;
    return _this;
  }
  return TemporaryDisplayObject2;
}(DisplayObject);
DisplayObject.prototype.displayObjectUpdateTransform = DisplayObject.prototype.updateTransform;
/*!
 * @pixi/constants - v6.3.0
 * Compiled Wed, 23 Mar 2022 18:58:56 UTC
 *
 * @pixi/constants is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
var ENV$2;
(function(ENV2) {
  ENV2[ENV2["WEBGL_LEGACY"] = 0] = "WEBGL_LEGACY";
  ENV2[ENV2["WEBGL"] = 1] = "WEBGL";
  ENV2[ENV2["WEBGL2"] = 2] = "WEBGL2";
})(ENV$2 || (ENV$2 = {}));
var RENDERER_TYPE$2;
(function(RENDERER_TYPE2) {
  RENDERER_TYPE2[RENDERER_TYPE2["UNKNOWN"] = 0] = "UNKNOWN";
  RENDERER_TYPE2[RENDERER_TYPE2["WEBGL"] = 1] = "WEBGL";
  RENDERER_TYPE2[RENDERER_TYPE2["CANVAS"] = 2] = "CANVAS";
})(RENDERER_TYPE$2 || (RENDERER_TYPE$2 = {}));
var BUFFER_BITS$2;
(function(BUFFER_BITS2) {
  BUFFER_BITS2[BUFFER_BITS2["COLOR"] = 16384] = "COLOR";
  BUFFER_BITS2[BUFFER_BITS2["DEPTH"] = 256] = "DEPTH";
  BUFFER_BITS2[BUFFER_BITS2["STENCIL"] = 1024] = "STENCIL";
})(BUFFER_BITS$2 || (BUFFER_BITS$2 = {}));
var BLEND_MODES$2;
(function(BLEND_MODES2) {
  BLEND_MODES2[BLEND_MODES2["NORMAL"] = 0] = "NORMAL";
  BLEND_MODES2[BLEND_MODES2["ADD"] = 1] = "ADD";
  BLEND_MODES2[BLEND_MODES2["MULTIPLY"] = 2] = "MULTIPLY";
  BLEND_MODES2[BLEND_MODES2["SCREEN"] = 3] = "SCREEN";
  BLEND_MODES2[BLEND_MODES2["OVERLAY"] = 4] = "OVERLAY";
  BLEND_MODES2[BLEND_MODES2["DARKEN"] = 5] = "DARKEN";
  BLEND_MODES2[BLEND_MODES2["LIGHTEN"] = 6] = "LIGHTEN";
  BLEND_MODES2[BLEND_MODES2["COLOR_DODGE"] = 7] = "COLOR_DODGE";
  BLEND_MODES2[BLEND_MODES2["COLOR_BURN"] = 8] = "COLOR_BURN";
  BLEND_MODES2[BLEND_MODES2["HARD_LIGHT"] = 9] = "HARD_LIGHT";
  BLEND_MODES2[BLEND_MODES2["SOFT_LIGHT"] = 10] = "SOFT_LIGHT";
  BLEND_MODES2[BLEND_MODES2["DIFFERENCE"] = 11] = "DIFFERENCE";
  BLEND_MODES2[BLEND_MODES2["EXCLUSION"] = 12] = "EXCLUSION";
  BLEND_MODES2[BLEND_MODES2["HUE"] = 13] = "HUE";
  BLEND_MODES2[BLEND_MODES2["SATURATION"] = 14] = "SATURATION";
  BLEND_MODES2[BLEND_MODES2["COLOR"] = 15] = "COLOR";
  BLEND_MODES2[BLEND_MODES2["LUMINOSITY"] = 16] = "LUMINOSITY";
  BLEND_MODES2[BLEND_MODES2["NORMAL_NPM"] = 17] = "NORMAL_NPM";
  BLEND_MODES2[BLEND_MODES2["ADD_NPM"] = 18] = "ADD_NPM";
  BLEND_MODES2[BLEND_MODES2["SCREEN_NPM"] = 19] = "SCREEN_NPM";
  BLEND_MODES2[BLEND_MODES2["NONE"] = 20] = "NONE";
  BLEND_MODES2[BLEND_MODES2["SRC_OVER"] = 0] = "SRC_OVER";
  BLEND_MODES2[BLEND_MODES2["SRC_IN"] = 21] = "SRC_IN";
  BLEND_MODES2[BLEND_MODES2["SRC_OUT"] = 22] = "SRC_OUT";
  BLEND_MODES2[BLEND_MODES2["SRC_ATOP"] = 23] = "SRC_ATOP";
  BLEND_MODES2[BLEND_MODES2["DST_OVER"] = 24] = "DST_OVER";
  BLEND_MODES2[BLEND_MODES2["DST_IN"] = 25] = "DST_IN";
  BLEND_MODES2[BLEND_MODES2["DST_OUT"] = 26] = "DST_OUT";
  BLEND_MODES2[BLEND_MODES2["DST_ATOP"] = 27] = "DST_ATOP";
  BLEND_MODES2[BLEND_MODES2["ERASE"] = 26] = "ERASE";
  BLEND_MODES2[BLEND_MODES2["SUBTRACT"] = 28] = "SUBTRACT";
  BLEND_MODES2[BLEND_MODES2["XOR"] = 29] = "XOR";
})(BLEND_MODES$2 || (BLEND_MODES$2 = {}));
var DRAW_MODES$2;
(function(DRAW_MODES2) {
  DRAW_MODES2[DRAW_MODES2["POINTS"] = 0] = "POINTS";
  DRAW_MODES2[DRAW_MODES2["LINES"] = 1] = "LINES";
  DRAW_MODES2[DRAW_MODES2["LINE_LOOP"] = 2] = "LINE_LOOP";
  DRAW_MODES2[DRAW_MODES2["LINE_STRIP"] = 3] = "LINE_STRIP";
  DRAW_MODES2[DRAW_MODES2["TRIANGLES"] = 4] = "TRIANGLES";
  DRAW_MODES2[DRAW_MODES2["TRIANGLE_STRIP"] = 5] = "TRIANGLE_STRIP";
  DRAW_MODES2[DRAW_MODES2["TRIANGLE_FAN"] = 6] = "TRIANGLE_FAN";
})(DRAW_MODES$2 || (DRAW_MODES$2 = {}));
var FORMATS$2;
(function(FORMATS2) {
  FORMATS2[FORMATS2["RGBA"] = 6408] = "RGBA";
  FORMATS2[FORMATS2["RGB"] = 6407] = "RGB";
  FORMATS2[FORMATS2["RG"] = 33319] = "RG";
  FORMATS2[FORMATS2["RED"] = 6403] = "RED";
  FORMATS2[FORMATS2["RGBA_INTEGER"] = 36249] = "RGBA_INTEGER";
  FORMATS2[FORMATS2["RGB_INTEGER"] = 36248] = "RGB_INTEGER";
  FORMATS2[FORMATS2["RG_INTEGER"] = 33320] = "RG_INTEGER";
  FORMATS2[FORMATS2["RED_INTEGER"] = 36244] = "RED_INTEGER";
  FORMATS2[FORMATS2["ALPHA"] = 6406] = "ALPHA";
  FORMATS2[FORMATS2["LUMINANCE"] = 6409] = "LUMINANCE";
  FORMATS2[FORMATS2["LUMINANCE_ALPHA"] = 6410] = "LUMINANCE_ALPHA";
  FORMATS2[FORMATS2["DEPTH_COMPONENT"] = 6402] = "DEPTH_COMPONENT";
  FORMATS2[FORMATS2["DEPTH_STENCIL"] = 34041] = "DEPTH_STENCIL";
})(FORMATS$2 || (FORMATS$2 = {}));
var TARGETS$2;
(function(TARGETS2) {
  TARGETS2[TARGETS2["TEXTURE_2D"] = 3553] = "TEXTURE_2D";
  TARGETS2[TARGETS2["TEXTURE_CUBE_MAP"] = 34067] = "TEXTURE_CUBE_MAP";
  TARGETS2[TARGETS2["TEXTURE_2D_ARRAY"] = 35866] = "TEXTURE_2D_ARRAY";
  TARGETS2[TARGETS2["TEXTURE_CUBE_MAP_POSITIVE_X"] = 34069] = "TEXTURE_CUBE_MAP_POSITIVE_X";
  TARGETS2[TARGETS2["TEXTURE_CUBE_MAP_NEGATIVE_X"] = 34070] = "TEXTURE_CUBE_MAP_NEGATIVE_X";
  TARGETS2[TARGETS2["TEXTURE_CUBE_MAP_POSITIVE_Y"] = 34071] = "TEXTURE_CUBE_MAP_POSITIVE_Y";
  TARGETS2[TARGETS2["TEXTURE_CUBE_MAP_NEGATIVE_Y"] = 34072] = "TEXTURE_CUBE_MAP_NEGATIVE_Y";
  TARGETS2[TARGETS2["TEXTURE_CUBE_MAP_POSITIVE_Z"] = 34073] = "TEXTURE_CUBE_MAP_POSITIVE_Z";
  TARGETS2[TARGETS2["TEXTURE_CUBE_MAP_NEGATIVE_Z"] = 34074] = "TEXTURE_CUBE_MAP_NEGATIVE_Z";
})(TARGETS$2 || (TARGETS$2 = {}));
var TYPES$2;
(function(TYPES2) {
  TYPES2[TYPES2["UNSIGNED_BYTE"] = 5121] = "UNSIGNED_BYTE";
  TYPES2[TYPES2["UNSIGNED_SHORT"] = 5123] = "UNSIGNED_SHORT";
  TYPES2[TYPES2["UNSIGNED_SHORT_5_6_5"] = 33635] = "UNSIGNED_SHORT_5_6_5";
  TYPES2[TYPES2["UNSIGNED_SHORT_4_4_4_4"] = 32819] = "UNSIGNED_SHORT_4_4_4_4";
  TYPES2[TYPES2["UNSIGNED_SHORT_5_5_5_1"] = 32820] = "UNSIGNED_SHORT_5_5_5_1";
  TYPES2[TYPES2["UNSIGNED_INT"] = 5125] = "UNSIGNED_INT";
  TYPES2[TYPES2["UNSIGNED_INT_10F_11F_11F_REV"] = 35899] = "UNSIGNED_INT_10F_11F_11F_REV";
  TYPES2[TYPES2["UNSIGNED_INT_2_10_10_10_REV"] = 33640] = "UNSIGNED_INT_2_10_10_10_REV";
  TYPES2[TYPES2["UNSIGNED_INT_24_8"] = 34042] = "UNSIGNED_INT_24_8";
  TYPES2[TYPES2["UNSIGNED_INT_5_9_9_9_REV"] = 35902] = "UNSIGNED_INT_5_9_9_9_REV";
  TYPES2[TYPES2["BYTE"] = 5120] = "BYTE";
  TYPES2[TYPES2["SHORT"] = 5122] = "SHORT";
  TYPES2[TYPES2["INT"] = 5124] = "INT";
  TYPES2[TYPES2["FLOAT"] = 5126] = "FLOAT";
  TYPES2[TYPES2["FLOAT_32_UNSIGNED_INT_24_8_REV"] = 36269] = "FLOAT_32_UNSIGNED_INT_24_8_REV";
  TYPES2[TYPES2["HALF_FLOAT"] = 36193] = "HALF_FLOAT";
})(TYPES$2 || (TYPES$2 = {}));
var SAMPLER_TYPES$2;
(function(SAMPLER_TYPES2) {
  SAMPLER_TYPES2[SAMPLER_TYPES2["FLOAT"] = 0] = "FLOAT";
  SAMPLER_TYPES2[SAMPLER_TYPES2["INT"] = 1] = "INT";
  SAMPLER_TYPES2[SAMPLER_TYPES2["UINT"] = 2] = "UINT";
})(SAMPLER_TYPES$2 || (SAMPLER_TYPES$2 = {}));
var SCALE_MODES$2;
(function(SCALE_MODES2) {
  SCALE_MODES2[SCALE_MODES2["NEAREST"] = 0] = "NEAREST";
  SCALE_MODES2[SCALE_MODES2["LINEAR"] = 1] = "LINEAR";
})(SCALE_MODES$2 || (SCALE_MODES$2 = {}));
var WRAP_MODES$2;
(function(WRAP_MODES2) {
  WRAP_MODES2[WRAP_MODES2["CLAMP"] = 33071] = "CLAMP";
  WRAP_MODES2[WRAP_MODES2["REPEAT"] = 10497] = "REPEAT";
  WRAP_MODES2[WRAP_MODES2["MIRRORED_REPEAT"] = 33648] = "MIRRORED_REPEAT";
})(WRAP_MODES$2 || (WRAP_MODES$2 = {}));
var MIPMAP_MODES$2;
(function(MIPMAP_MODES2) {
  MIPMAP_MODES2[MIPMAP_MODES2["OFF"] = 0] = "OFF";
  MIPMAP_MODES2[MIPMAP_MODES2["POW2"] = 1] = "POW2";
  MIPMAP_MODES2[MIPMAP_MODES2["ON"] = 2] = "ON";
  MIPMAP_MODES2[MIPMAP_MODES2["ON_MANUAL"] = 3] = "ON_MANUAL";
})(MIPMAP_MODES$2 || (MIPMAP_MODES$2 = {}));
var ALPHA_MODES$2;
(function(ALPHA_MODES2) {
  ALPHA_MODES2[ALPHA_MODES2["NPM"] = 0] = "NPM";
  ALPHA_MODES2[ALPHA_MODES2["UNPACK"] = 1] = "UNPACK";
  ALPHA_MODES2[ALPHA_MODES2["PMA"] = 2] = "PMA";
  ALPHA_MODES2[ALPHA_MODES2["NO_PREMULTIPLIED_ALPHA"] = 0] = "NO_PREMULTIPLIED_ALPHA";
  ALPHA_MODES2[ALPHA_MODES2["PREMULTIPLY_ON_UPLOAD"] = 1] = "PREMULTIPLY_ON_UPLOAD";
  ALPHA_MODES2[ALPHA_MODES2["PREMULTIPLY_ALPHA"] = 2] = "PREMULTIPLY_ALPHA";
  ALPHA_MODES2[ALPHA_MODES2["PREMULTIPLIED_ALPHA"] = 2] = "PREMULTIPLIED_ALPHA";
})(ALPHA_MODES$2 || (ALPHA_MODES$2 = {}));
var CLEAR_MODES$2;
(function(CLEAR_MODES2) {
  CLEAR_MODES2[CLEAR_MODES2["NO"] = 0] = "NO";
  CLEAR_MODES2[CLEAR_MODES2["YES"] = 1] = "YES";
  CLEAR_MODES2[CLEAR_MODES2["AUTO"] = 2] = "AUTO";
  CLEAR_MODES2[CLEAR_MODES2["BLEND"] = 0] = "BLEND";
  CLEAR_MODES2[CLEAR_MODES2["CLEAR"] = 1] = "CLEAR";
  CLEAR_MODES2[CLEAR_MODES2["BLIT"] = 2] = "BLIT";
})(CLEAR_MODES$2 || (CLEAR_MODES$2 = {}));
var GC_MODES$2;
(function(GC_MODES2) {
  GC_MODES2[GC_MODES2["AUTO"] = 0] = "AUTO";
  GC_MODES2[GC_MODES2["MANUAL"] = 1] = "MANUAL";
})(GC_MODES$2 || (GC_MODES$2 = {}));
var PRECISION$2;
(function(PRECISION2) {
  PRECISION2["LOW"] = "lowp";
  PRECISION2["MEDIUM"] = "mediump";
  PRECISION2["HIGH"] = "highp";
})(PRECISION$2 || (PRECISION$2 = {}));
var MASK_TYPES$2;
(function(MASK_TYPES2) {
  MASK_TYPES2[MASK_TYPES2["NONE"] = 0] = "NONE";
  MASK_TYPES2[MASK_TYPES2["SCISSOR"] = 1] = "SCISSOR";
  MASK_TYPES2[MASK_TYPES2["STENCIL"] = 2] = "STENCIL";
  MASK_TYPES2[MASK_TYPES2["SPRITE"] = 3] = "SPRITE";
})(MASK_TYPES$2 || (MASK_TYPES$2 = {}));
var MSAA_QUALITY$2;
(function(MSAA_QUALITY2) {
  MSAA_QUALITY2[MSAA_QUALITY2["NONE"] = 0] = "NONE";
  MSAA_QUALITY2[MSAA_QUALITY2["LOW"] = 2] = "LOW";
  MSAA_QUALITY2[MSAA_QUALITY2["MEDIUM"] = 4] = "MEDIUM";
  MSAA_QUALITY2[MSAA_QUALITY2["HIGH"] = 8] = "HIGH";
})(MSAA_QUALITY$2 || (MSAA_QUALITY$2 = {}));
var BUFFER_TYPE$2;
(function(BUFFER_TYPE2) {
  BUFFER_TYPE2[BUFFER_TYPE2["ELEMENT_ARRAY_BUFFER"] = 34963] = "ELEMENT_ARRAY_BUFFER";
  BUFFER_TYPE2[BUFFER_TYPE2["ARRAY_BUFFER"] = 34962] = "ARRAY_BUFFER";
  BUFFER_TYPE2[BUFFER_TYPE2["UNIFORM_BUFFER"] = 35345] = "UNIFORM_BUFFER";
})(BUFFER_TYPE$2 || (BUFFER_TYPE$2 = {}));
function sortChildren(a2, b2) {
  if (a2.zIndex === b2.zIndex) {
    return a2._lastSortedIndex - b2._lastSortedIndex;
  }
  return a2.zIndex - b2.zIndex;
}
var Container = function(_super) {
  __extends$p(Container2, _super);
  function Container2() {
    var _this = _super.call(this) || this;
    _this.children = [];
    _this.sortableChildren = settings.SORTABLE_CHILDREN;
    _this.sortDirty = false;
    return _this;
  }
  Container2.prototype.onChildrenChange = function(_length) {
  };
  Container2.prototype.addChild = function() {
    var arguments$1 = arguments;
    var children = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      children[_i] = arguments$1[_i];
    }
    if (children.length > 1) {
      for (var i2 = 0; i2 < children.length; i2++) {
        this.addChild(children[i2]);
      }
    } else {
      var child = children[0];
      if (child.parent) {
        child.parent.removeChild(child);
      }
      child.parent = this;
      this.sortDirty = true;
      child.transform._parentID = -1;
      this.children.push(child);
      this._boundsID++;
      this.onChildrenChange(this.children.length - 1);
      this.emit("childAdded", child, this, this.children.length - 1);
      child.emit("added", this);
    }
    return children[0];
  };
  Container2.prototype.addChildAt = function(child, index) {
    if (index < 0 || index > this.children.length) {
      throw new Error(child + "addChildAt: The index " + index + " supplied is out of bounds " + this.children.length);
    }
    if (child.parent) {
      child.parent.removeChild(child);
    }
    child.parent = this;
    this.sortDirty = true;
    child.transform._parentID = -1;
    this.children.splice(index, 0, child);
    this._boundsID++;
    this.onChildrenChange(index);
    child.emit("added", this);
    this.emit("childAdded", child, this, index);
    return child;
  };
  Container2.prototype.swapChildren = function(child, child2) {
    if (child === child2) {
      return;
    }
    var index1 = this.getChildIndex(child);
    var index2 = this.getChildIndex(child2);
    this.children[index1] = child2;
    this.children[index2] = child;
    this.onChildrenChange(index1 < index2 ? index1 : index2);
  };
  Container2.prototype.getChildIndex = function(child) {
    var index = this.children.indexOf(child);
    if (index === -1) {
      throw new Error("The supplied DisplayObject must be a child of the caller");
    }
    return index;
  };
  Container2.prototype.setChildIndex = function(child, index) {
    if (index < 0 || index >= this.children.length) {
      throw new Error("The index " + index + " supplied is out of bounds " + this.children.length);
    }
    var currentIndex = this.getChildIndex(child);
    removeItems(this.children, currentIndex, 1);
    this.children.splice(index, 0, child);
    this.onChildrenChange(index);
  };
  Container2.prototype.getChildAt = function(index) {
    if (index < 0 || index >= this.children.length) {
      throw new Error("getChildAt: Index (" + index + ") does not exist.");
    }
    return this.children[index];
  };
  Container2.prototype.removeChild = function() {
    var arguments$1 = arguments;
    var children = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      children[_i] = arguments$1[_i];
    }
    if (children.length > 1) {
      for (var i2 = 0; i2 < children.length; i2++) {
        this.removeChild(children[i2]);
      }
    } else {
      var child = children[0];
      var index = this.children.indexOf(child);
      if (index === -1) {
        return null;
      }
      child.parent = null;
      child.transform._parentID = -1;
      removeItems(this.children, index, 1);
      this._boundsID++;
      this.onChildrenChange(index);
      child.emit("removed", this);
      this.emit("childRemoved", child, this, index);
    }
    return children[0];
  };
  Container2.prototype.removeChildAt = function(index) {
    var child = this.getChildAt(index);
    child.parent = null;
    child.transform._parentID = -1;
    removeItems(this.children, index, 1);
    this._boundsID++;
    this.onChildrenChange(index);
    child.emit("removed", this);
    this.emit("childRemoved", child, this, index);
    return child;
  };
  Container2.prototype.removeChildren = function(beginIndex, endIndex) {
    if (beginIndex === void 0) {
      beginIndex = 0;
    }
    if (endIndex === void 0) {
      endIndex = this.children.length;
    }
    var begin = beginIndex;
    var end = endIndex;
    var range = end - begin;
    var removed;
    if (range > 0 && range <= end) {
      removed = this.children.splice(begin, range);
      for (var i2 = 0; i2 < removed.length; ++i2) {
        removed[i2].parent = null;
        if (removed[i2].transform) {
          removed[i2].transform._parentID = -1;
        }
      }
      this._boundsID++;
      this.onChildrenChange(beginIndex);
      for (var i2 = 0; i2 < removed.length; ++i2) {
        removed[i2].emit("removed", this);
        this.emit("childRemoved", removed[i2], this, i2);
      }
      return removed;
    } else if (range === 0 && this.children.length === 0) {
      return [];
    }
    throw new RangeError("removeChildren: numeric values are outside the acceptable range.");
  };
  Container2.prototype.sortChildren = function() {
    var sortRequired = false;
    for (var i2 = 0, j2 = this.children.length; i2 < j2; ++i2) {
      var child = this.children[i2];
      child._lastSortedIndex = i2;
      if (!sortRequired && child.zIndex !== 0) {
        sortRequired = true;
      }
    }
    if (sortRequired && this.children.length > 1) {
      this.children.sort(sortChildren);
    }
    this.sortDirty = false;
  };
  Container2.prototype.updateTransform = function() {
    if (this.sortableChildren && this.sortDirty) {
      this.sortChildren();
    }
    this._boundsID++;
    this.transform.updateTransform(this.parent.transform);
    this.worldAlpha = this.alpha * this.parent.worldAlpha;
    for (var i2 = 0, j2 = this.children.length; i2 < j2; ++i2) {
      var child = this.children[i2];
      if (child.visible) {
        child.updateTransform();
      }
    }
  };
  Container2.prototype.calculateBounds = function() {
    this._bounds.clear();
    this._calculateBounds();
    for (var i2 = 0; i2 < this.children.length; i2++) {
      var child = this.children[i2];
      if (!child.visible || !child.renderable) {
        continue;
      }
      child.calculateBounds();
      if (child._mask) {
        var maskObject = child._mask.maskObject || child._mask;
        maskObject.calculateBounds();
        this._bounds.addBoundsMask(child._bounds, maskObject._bounds);
      } else if (child.filterArea) {
        this._bounds.addBoundsArea(child._bounds, child.filterArea);
      } else {
        this._bounds.addBounds(child._bounds);
      }
    }
    this._bounds.updateID = this._boundsID;
  };
  Container2.prototype.getLocalBounds = function(rect, skipChildrenUpdate) {
    if (skipChildrenUpdate === void 0) {
      skipChildrenUpdate = false;
    }
    var result = _super.prototype.getLocalBounds.call(this, rect);
    if (!skipChildrenUpdate) {
      for (var i2 = 0, j2 = this.children.length; i2 < j2; ++i2) {
        var child = this.children[i2];
        if (child.visible) {
          child.updateTransform();
        }
      }
    }
    return result;
  };
  Container2.prototype._calculateBounds = function() {
  };
  Container2.prototype._renderWithCulling = function(renderer) {
    var sourceFrame = renderer.renderTexture.sourceFrame;
    if (!(sourceFrame.width > 0 && sourceFrame.height > 0)) {
      return;
    }
    var bounds;
    var transform;
    if (this.cullArea) {
      bounds = this.cullArea;
      transform = this.worldTransform;
    } else if (this._render !== Container2.prototype._render) {
      bounds = this.getBounds(true);
    }
    if (bounds && sourceFrame.intersects(bounds, transform)) {
      this._render(renderer);
    } else if (this.cullArea) {
      return;
    }
    for (var i2 = 0, j2 = this.children.length; i2 < j2; ++i2) {
      var child = this.children[i2];
      var childCullable = child.cullable;
      child.cullable = childCullable || !this.cullArea;
      child.render(renderer);
      child.cullable = childCullable;
    }
  };
  Container2.prototype.render = function(renderer) {
    if (!this.visible || this.worldAlpha <= 0 || !this.renderable) {
      return;
    }
    if (this._mask || this.filters && this.filters.length) {
      this.renderAdvanced(renderer);
    } else if (this.cullable) {
      this._renderWithCulling(renderer);
    } else {
      this._render(renderer);
      for (var i2 = 0, j2 = this.children.length; i2 < j2; ++i2) {
        this.children[i2].render(renderer);
      }
    }
  };
  Container2.prototype.renderAdvanced = function(renderer) {
    var filters = this.filters;
    var mask = this._mask;
    if (filters) {
      if (!this._enabledFilters) {
        this._enabledFilters = [];
      }
      this._enabledFilters.length = 0;
      for (var i2 = 0; i2 < filters.length; i2++) {
        if (filters[i2].enabled) {
          this._enabledFilters.push(filters[i2]);
        }
      }
    }
    var flush = filters && this._enabledFilters && this._enabledFilters.length || mask && (!mask.isMaskData || mask.enabled && (mask.autoDetect || mask.type !== MASK_TYPES$2.NONE));
    if (flush) {
      renderer.batch.flush();
    }
    if (filters && this._enabledFilters && this._enabledFilters.length) {
      renderer.filter.push(this, this._enabledFilters);
    }
    if (mask) {
      renderer.mask.push(this, this._mask);
    }
    if (this.cullable) {
      this._renderWithCulling(renderer);
    } else {
      this._render(renderer);
      for (var i2 = 0, j2 = this.children.length; i2 < j2; ++i2) {
        this.children[i2].render(renderer);
      }
    }
    if (flush) {
      renderer.batch.flush();
    }
    if (mask) {
      renderer.mask.pop(this);
    }
    if (filters && this._enabledFilters && this._enabledFilters.length) {
      renderer.filter.pop();
    }
  };
  Container2.prototype._render = function(_renderer) {
  };
  Container2.prototype.destroy = function(options) {
    _super.prototype.destroy.call(this);
    this.sortDirty = false;
    var destroyChildren = typeof options === "boolean" ? options : options && options.children;
    var oldChildren = this.removeChildren(0, this.children.length);
    if (destroyChildren) {
      for (var i2 = 0; i2 < oldChildren.length; ++i2) {
        oldChildren[i2].destroy(options);
      }
    }
  };
  Object.defineProperty(Container2.prototype, "width", {
    get: function() {
      return this.scale.x * this.getLocalBounds().width;
    },
    set: function(value) {
      var width = this.getLocalBounds().width;
      if (width !== 0) {
        this.scale.x = value / width;
      } else {
        this.scale.x = 1;
      }
      this._width = value;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Container2.prototype, "height", {
    get: function() {
      return this.scale.y * this.getLocalBounds().height;
    },
    set: function(value) {
      var height = this.getLocalBounds().height;
      if (height !== 0) {
        this.scale.y = value / height;
      } else {
        this.scale.y = 1;
      }
      this._height = value;
    },
    enumerable: false,
    configurable: true
  });
  return Container2;
}(DisplayObject);
Container.prototype.containerUpdateTransform = Container.prototype.updateTransform;
/*!
 * @pixi/accessibility - v6.3.0
 * Compiled Wed, 23 Mar 2022 18:58:56 UTC
 *
 * @pixi/accessibility is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
var accessibleTarget = {
  accessible: false,
  accessibleTitle: null,
  accessibleHint: null,
  tabIndex: 0,
  _accessibleActive: false,
  _accessibleDiv: null,
  accessibleType: "button",
  accessiblePointerEvents: "auto",
  accessibleChildren: true,
  renderId: -1
};
DisplayObject.mixin(accessibleTarget);
var KEY_CODE_TAB = 9;
var DIV_TOUCH_SIZE = 100;
var DIV_TOUCH_POS_X = 0;
var DIV_TOUCH_POS_Y = 0;
var DIV_TOUCH_ZINDEX = 2;
var DIV_HOOK_SIZE = 1;
var DIV_HOOK_POS_X = -1e3;
var DIV_HOOK_POS_Y = -1e3;
var DIV_HOOK_ZINDEX = 2;
var AccessibilityManager = function() {
  function AccessibilityManager2(renderer) {
    this.debug = false;
    this._isActive = false;
    this._isMobileAccessibility = false;
    this.pool = [];
    this.renderId = 0;
    this.children = [];
    this.androidUpdateCount = 0;
    this.androidUpdateFrequency = 500;
    this._hookDiv = null;
    if (isMobile.tablet || isMobile.phone) {
      this.createTouchHook();
    }
    var div = document.createElement("div");
    div.style.width = DIV_TOUCH_SIZE + "px";
    div.style.height = DIV_TOUCH_SIZE + "px";
    div.style.position = "absolute";
    div.style.top = DIV_TOUCH_POS_X + "px";
    div.style.left = DIV_TOUCH_POS_Y + "px";
    div.style.zIndex = DIV_TOUCH_ZINDEX.toString();
    this.div = div;
    this.renderer = renderer;
    this._onKeyDown = this._onKeyDown.bind(this);
    this._onMouseMove = this._onMouseMove.bind(this);
    globalThis.addEventListener("keydown", this._onKeyDown, false);
  }
  Object.defineProperty(AccessibilityManager2.prototype, "isActive", {
    get: function() {
      return this._isActive;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(AccessibilityManager2.prototype, "isMobileAccessibility", {
    get: function() {
      return this._isMobileAccessibility;
    },
    enumerable: false,
    configurable: true
  });
  AccessibilityManager2.prototype.createTouchHook = function() {
    var _this = this;
    var hookDiv = document.createElement("button");
    hookDiv.style.width = DIV_HOOK_SIZE + "px";
    hookDiv.style.height = DIV_HOOK_SIZE + "px";
    hookDiv.style.position = "absolute";
    hookDiv.style.top = DIV_HOOK_POS_X + "px";
    hookDiv.style.left = DIV_HOOK_POS_Y + "px";
    hookDiv.style.zIndex = DIV_HOOK_ZINDEX.toString();
    hookDiv.style.backgroundColor = "#FF0000";
    hookDiv.title = "select to enable accessibility for this content";
    hookDiv.addEventListener("focus", function() {
      _this._isMobileAccessibility = true;
      _this.activate();
      _this.destroyTouchHook();
    });
    document.body.appendChild(hookDiv);
    this._hookDiv = hookDiv;
  };
  AccessibilityManager2.prototype.destroyTouchHook = function() {
    if (!this._hookDiv) {
      return;
    }
    document.body.removeChild(this._hookDiv);
    this._hookDiv = null;
  };
  AccessibilityManager2.prototype.activate = function() {
    var _a3;
    if (this._isActive) {
      return;
    }
    this._isActive = true;
    globalThis.document.addEventListener("mousemove", this._onMouseMove, true);
    globalThis.removeEventListener("keydown", this._onKeyDown, false);
    this.renderer.on("postrender", this.update, this);
    (_a3 = this.renderer.view.parentNode) === null || _a3 === void 0 ? void 0 : _a3.appendChild(this.div);
  };
  AccessibilityManager2.prototype.deactivate = function() {
    var _a3;
    if (!this._isActive || this._isMobileAccessibility) {
      return;
    }
    this._isActive = false;
    globalThis.document.removeEventListener("mousemove", this._onMouseMove, true);
    globalThis.addEventListener("keydown", this._onKeyDown, false);
    this.renderer.off("postrender", this.update);
    (_a3 = this.div.parentNode) === null || _a3 === void 0 ? void 0 : _a3.removeChild(this.div);
  };
  AccessibilityManager2.prototype.updateAccessibleObjects = function(displayObject) {
    if (!displayObject.visible || !displayObject.accessibleChildren) {
      return;
    }
    if (displayObject.accessible && displayObject.interactive) {
      if (!displayObject._accessibleActive) {
        this.addChild(displayObject);
      }
      displayObject.renderId = this.renderId;
    }
    var children = displayObject.children;
    if (children) {
      for (var i2 = 0; i2 < children.length; i2++) {
        this.updateAccessibleObjects(children[i2]);
      }
    }
  };
  AccessibilityManager2.prototype.update = function() {
    var now2 = performance.now();
    if (isMobile.android.device && now2 < this.androidUpdateCount) {
      return;
    }
    this.androidUpdateCount = now2 + this.androidUpdateFrequency;
    if (!this.renderer.renderingToScreen) {
      return;
    }
    if (this.renderer._lastObjectRendered) {
      this.updateAccessibleObjects(this.renderer._lastObjectRendered);
    }
    var _a3 = this.renderer.view.getBoundingClientRect(), left = _a3.left, top = _a3.top, width = _a3.width, height = _a3.height;
    var _b3 = this.renderer, viewWidth = _b3.width, viewHeight = _b3.height, resolution = _b3.resolution;
    var sx = width / viewWidth * resolution;
    var sy = height / viewHeight * resolution;
    var div = this.div;
    div.style.left = left + "px";
    div.style.top = top + "px";
    div.style.width = viewWidth + "px";
    div.style.height = viewHeight + "px";
    for (var i2 = 0; i2 < this.children.length; i2++) {
      var child = this.children[i2];
      if (child.renderId !== this.renderId) {
        child._accessibleActive = false;
        removeItems(this.children, i2, 1);
        this.div.removeChild(child._accessibleDiv);
        this.pool.push(child._accessibleDiv);
        child._accessibleDiv = null;
        i2--;
      } else {
        div = child._accessibleDiv;
        var hitArea = child.hitArea;
        var wt = child.worldTransform;
        if (child.hitArea) {
          div.style.left = (wt.tx + hitArea.x * wt.a) * sx + "px";
          div.style.top = (wt.ty + hitArea.y * wt.d) * sy + "px";
          div.style.width = hitArea.width * wt.a * sx + "px";
          div.style.height = hitArea.height * wt.d * sy + "px";
        } else {
          hitArea = child.getBounds();
          this.capHitArea(hitArea);
          div.style.left = hitArea.x * sx + "px";
          div.style.top = hitArea.y * sy + "px";
          div.style.width = hitArea.width * sx + "px";
          div.style.height = hitArea.height * sy + "px";
          if (div.title !== child.accessibleTitle && child.accessibleTitle !== null) {
            div.title = child.accessibleTitle;
          }
          if (div.getAttribute("aria-label") !== child.accessibleHint && child.accessibleHint !== null) {
            div.setAttribute("aria-label", child.accessibleHint);
          }
        }
        if (child.accessibleTitle !== div.title || child.tabIndex !== div.tabIndex) {
          div.title = child.accessibleTitle;
          div.tabIndex = child.tabIndex;
          if (this.debug) {
            this.updateDebugHTML(div);
          }
        }
      }
    }
    this.renderId++;
  };
  AccessibilityManager2.prototype.updateDebugHTML = function(div) {
    div.innerHTML = "type: " + div.type + "</br> title : " + div.title + "</br> tabIndex: " + div.tabIndex;
  };
  AccessibilityManager2.prototype.capHitArea = function(hitArea) {
    if (hitArea.x < 0) {
      hitArea.width += hitArea.x;
      hitArea.x = 0;
    }
    if (hitArea.y < 0) {
      hitArea.height += hitArea.y;
      hitArea.y = 0;
    }
    var _a3 = this.renderer, viewWidth = _a3.width, viewHeight = _a3.height;
    if (hitArea.x + hitArea.width > viewWidth) {
      hitArea.width = viewWidth - hitArea.x;
    }
    if (hitArea.y + hitArea.height > viewHeight) {
      hitArea.height = viewHeight - hitArea.y;
    }
  };
  AccessibilityManager2.prototype.addChild = function(displayObject) {
    var div = this.pool.pop();
    if (!div) {
      div = document.createElement("button");
      div.style.width = DIV_TOUCH_SIZE + "px";
      div.style.height = DIV_TOUCH_SIZE + "px";
      div.style.backgroundColor = this.debug ? "rgba(255,255,255,0.5)" : "transparent";
      div.style.position = "absolute";
      div.style.zIndex = DIV_TOUCH_ZINDEX.toString();
      div.style.borderStyle = "none";
      if (navigator.userAgent.toLowerCase().indexOf("chrome") > -1) {
        div.setAttribute("aria-live", "off");
      } else {
        div.setAttribute("aria-live", "polite");
      }
      if (navigator.userAgent.match(/rv:.*Gecko\//)) {
        div.setAttribute("aria-relevant", "additions");
      } else {
        div.setAttribute("aria-relevant", "text");
      }
      div.addEventListener("click", this._onClick.bind(this));
      div.addEventListener("focus", this._onFocus.bind(this));
      div.addEventListener("focusout", this._onFocusOut.bind(this));
    }
    div.style.pointerEvents = displayObject.accessiblePointerEvents;
    div.type = displayObject.accessibleType;
    if (displayObject.accessibleTitle && displayObject.accessibleTitle !== null) {
      div.title = displayObject.accessibleTitle;
    } else if (!displayObject.accessibleHint || displayObject.accessibleHint === null) {
      div.title = "displayObject " + displayObject.tabIndex;
    }
    if (displayObject.accessibleHint && displayObject.accessibleHint !== null) {
      div.setAttribute("aria-label", displayObject.accessibleHint);
    }
    if (this.debug) {
      this.updateDebugHTML(div);
    }
    displayObject._accessibleActive = true;
    displayObject._accessibleDiv = div;
    div.displayObject = displayObject;
    this.children.push(displayObject);
    this.div.appendChild(displayObject._accessibleDiv);
    displayObject._accessibleDiv.tabIndex = displayObject.tabIndex;
  };
  AccessibilityManager2.prototype._onClick = function(e) {
    var interactionManager = this.renderer.plugins.interaction;
    var displayObject = e.target.displayObject;
    var eventData = interactionManager.eventData;
    interactionManager.dispatchEvent(displayObject, "click", eventData);
    interactionManager.dispatchEvent(displayObject, "pointertap", eventData);
    interactionManager.dispatchEvent(displayObject, "tap", eventData);
  };
  AccessibilityManager2.prototype._onFocus = function(e) {
    if (!e.target.getAttribute("aria-live")) {
      e.target.setAttribute("aria-live", "assertive");
    }
    var interactionManager = this.renderer.plugins.interaction;
    var displayObject = e.target.displayObject;
    var eventData = interactionManager.eventData;
    interactionManager.dispatchEvent(displayObject, "mouseover", eventData);
  };
  AccessibilityManager2.prototype._onFocusOut = function(e) {
    if (!e.target.getAttribute("aria-live")) {
      e.target.setAttribute("aria-live", "polite");
    }
    var interactionManager = this.renderer.plugins.interaction;
    var displayObject = e.target.displayObject;
    var eventData = interactionManager.eventData;
    interactionManager.dispatchEvent(displayObject, "mouseout", eventData);
  };
  AccessibilityManager2.prototype._onKeyDown = function(e) {
    if (e.keyCode !== KEY_CODE_TAB) {
      return;
    }
    this.activate();
  };
  AccessibilityManager2.prototype._onMouseMove = function(e) {
    if (e.movementX === 0 && e.movementY === 0) {
      return;
    }
    this.deactivate();
  };
  AccessibilityManager2.prototype.destroy = function() {
    this.destroyTouchHook();
    this.div = null;
    globalThis.document.removeEventListener("mousemove", this._onMouseMove, true);
    globalThis.removeEventListener("keydown", this._onKeyDown);
    this.pool = null;
    this.children = null;
    this.renderer = null;
  };
  return AccessibilityManager2;
}();
/*!
 * @pixi/interaction - v6.3.0
 * Compiled Wed, 23 Mar 2022 18:58:56 UTC
 *
 * @pixi/interaction is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
var InteractionData = function() {
  function InteractionData2() {
    this.pressure = 0;
    this.rotationAngle = 0;
    this.twist = 0;
    this.tangentialPressure = 0;
    this.global = new Point();
    this.target = null;
    this.originalEvent = null;
    this.identifier = null;
    this.isPrimary = false;
    this.button = 0;
    this.buttons = 0;
    this.width = 0;
    this.height = 0;
    this.tiltX = 0;
    this.tiltY = 0;
    this.pointerType = null;
    this.pressure = 0;
    this.rotationAngle = 0;
    this.twist = 0;
    this.tangentialPressure = 0;
  }
  Object.defineProperty(InteractionData2.prototype, "pointerId", {
    get: function() {
      return this.identifier;
    },
    enumerable: false,
    configurable: true
  });
  InteractionData2.prototype.getLocalPosition = function(displayObject, point, globalPos) {
    return displayObject.worldTransform.applyInverse(globalPos || this.global, point);
  };
  InteractionData2.prototype.copyEvent = function(event) {
    if ("isPrimary" in event && event.isPrimary) {
      this.isPrimary = true;
    }
    this.button = "button" in event && event.button;
    var buttons = "buttons" in event && event.buttons;
    this.buttons = Number.isInteger(buttons) ? buttons : "which" in event && event.which;
    this.width = "width" in event && event.width;
    this.height = "height" in event && event.height;
    this.tiltX = "tiltX" in event && event.tiltX;
    this.tiltY = "tiltY" in event && event.tiltY;
    this.pointerType = "pointerType" in event && event.pointerType;
    this.pressure = "pressure" in event && event.pressure;
    this.rotationAngle = "rotationAngle" in event && event.rotationAngle;
    this.twist = "twist" in event && event.twist || 0;
    this.tangentialPressure = "tangentialPressure" in event && event.tangentialPressure || 0;
  };
  InteractionData2.prototype.reset = function() {
    this.isPrimary = false;
  };
  return InteractionData2;
}();
/*! *****************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */
var extendStatics$o = function(d2, b2) {
  extendStatics$o = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {
    d3.__proto__ = b3;
  } || function(d3, b3) {
    for (var p2 in b3) {
      if (b3.hasOwnProperty(p2)) {
        d3[p2] = b3[p2];
      }
    }
  };
  return extendStatics$o(d2, b2);
};
function __extends$o(d2, b2) {
  extendStatics$o(d2, b2);
  function __() {
    this.constructor = d2;
  }
  d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
}
var InteractionEvent = function() {
  function InteractionEvent2() {
    this.stopped = false;
    this.stopsPropagatingAt = null;
    this.stopPropagationHint = false;
    this.target = null;
    this.currentTarget = null;
    this.type = null;
    this.data = null;
  }
  InteractionEvent2.prototype.stopPropagation = function() {
    this.stopped = true;
    this.stopPropagationHint = true;
    this.stopsPropagatingAt = this.currentTarget;
  };
  InteractionEvent2.prototype.reset = function() {
    this.stopped = false;
    this.stopsPropagatingAt = null;
    this.stopPropagationHint = false;
    this.currentTarget = null;
    this.target = null;
  };
  return InteractionEvent2;
}();
var InteractionTrackingData = function() {
  function InteractionTrackingData2(pointerId) {
    this._pointerId = pointerId;
    this._flags = InteractionTrackingData2.FLAGS.NONE;
  }
  InteractionTrackingData2.prototype._doSet = function(flag, yn) {
    if (yn) {
      this._flags = this._flags | flag;
    } else {
      this._flags = this._flags & ~flag;
    }
  };
  Object.defineProperty(InteractionTrackingData2.prototype, "pointerId", {
    get: function() {
      return this._pointerId;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(InteractionTrackingData2.prototype, "flags", {
    get: function() {
      return this._flags;
    },
    set: function(flags) {
      this._flags = flags;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(InteractionTrackingData2.prototype, "none", {
    get: function() {
      return this._flags === InteractionTrackingData2.FLAGS.NONE;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(InteractionTrackingData2.prototype, "over", {
    get: function() {
      return (this._flags & InteractionTrackingData2.FLAGS.OVER) !== 0;
    },
    set: function(yn) {
      this._doSet(InteractionTrackingData2.FLAGS.OVER, yn);
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(InteractionTrackingData2.prototype, "rightDown", {
    get: function() {
      return (this._flags & InteractionTrackingData2.FLAGS.RIGHT_DOWN) !== 0;
    },
    set: function(yn) {
      this._doSet(InteractionTrackingData2.FLAGS.RIGHT_DOWN, yn);
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(InteractionTrackingData2.prototype, "leftDown", {
    get: function() {
      return (this._flags & InteractionTrackingData2.FLAGS.LEFT_DOWN) !== 0;
    },
    set: function(yn) {
      this._doSet(InteractionTrackingData2.FLAGS.LEFT_DOWN, yn);
    },
    enumerable: false,
    configurable: true
  });
  InteractionTrackingData2.FLAGS = Object.freeze({
    NONE: 0,
    OVER: 1 << 0,
    LEFT_DOWN: 1 << 1,
    RIGHT_DOWN: 1 << 2
  });
  return InteractionTrackingData2;
}();
var TreeSearch = function() {
  function TreeSearch2() {
    this._tempPoint = new Point();
  }
  TreeSearch2.prototype.recursiveFindHit = function(interactionEvent, displayObject, func, hitTest, interactive) {
    if (!displayObject || !displayObject.visible) {
      return false;
    }
    var point = interactionEvent.data.global;
    interactive = displayObject.interactive || interactive;
    var hit = false;
    var interactiveParent = interactive;
    var hitTestChildren = true;
    if (displayObject.hitArea) {
      if (hitTest) {
        displayObject.worldTransform.applyInverse(point, this._tempPoint);
        if (!displayObject.hitArea.contains(this._tempPoint.x, this._tempPoint.y)) {
          hitTest = false;
          hitTestChildren = false;
        } else {
          hit = true;
        }
      }
      interactiveParent = false;
    } else if (displayObject._mask) {
      if (hitTest) {
        if (!(displayObject._mask.containsPoint && displayObject._mask.containsPoint(point))) {
          hitTest = false;
        }
      }
    }
    if (hitTestChildren && displayObject.interactiveChildren && displayObject.children) {
      var children = displayObject.children;
      for (var i2 = children.length - 1; i2 >= 0; i2--) {
        var child = children[i2];
        var childHit = this.recursiveFindHit(interactionEvent, child, func, hitTest, interactiveParent);
        if (childHit) {
          if (!child.parent) {
            continue;
          }
          interactiveParent = false;
          if (childHit) {
            if (interactionEvent.target) {
              hitTest = false;
            }
            hit = true;
          }
        }
      }
    }
    if (interactive) {
      if (hitTest && !interactionEvent.target) {
        if (!displayObject.hitArea && displayObject.containsPoint) {
          if (displayObject.containsPoint(point)) {
            hit = true;
          }
        }
      }
      if (displayObject.interactive) {
        if (hit && !interactionEvent.target) {
          interactionEvent.target = displayObject;
        }
        if (func) {
          func(interactionEvent, displayObject, !!hit);
        }
      }
    }
    return hit;
  };
  TreeSearch2.prototype.findHit = function(interactionEvent, displayObject, func, hitTest) {
    this.recursiveFindHit(interactionEvent, displayObject, func, hitTest, false);
  };
  return TreeSearch2;
}();
var interactiveTarget = {
  interactive: false,
  interactiveChildren: true,
  hitArea: null,
  get buttonMode() {
    return this.cursor === "pointer";
  },
  set buttonMode(value) {
    if (value) {
      this.cursor = "pointer";
    } else if (this.cursor === "pointer") {
      this.cursor = null;
    }
  },
  cursor: null,
  get trackedPointers() {
    if (this._trackedPointers === void 0) {
      this._trackedPointers = {};
    }
    return this._trackedPointers;
  },
  _trackedPointers: void 0
};
DisplayObject.mixin(interactiveTarget);
var MOUSE_POINTER_ID = 1;
var hitTestEvent = {
  target: null,
  data: {
    global: null
  }
};
var InteractionManager = function(_super) {
  __extends$o(InteractionManager2, _super);
  function InteractionManager2(renderer, options) {
    var _this = _super.call(this) || this;
    options = options || {};
    _this.renderer = renderer;
    _this.autoPreventDefault = options.autoPreventDefault !== void 0 ? options.autoPreventDefault : true;
    _this.interactionFrequency = options.interactionFrequency || 10;
    _this.mouse = new InteractionData();
    _this.mouse.identifier = MOUSE_POINTER_ID;
    _this.mouse.global.set(-999999);
    _this.activeInteractionData = {};
    _this.activeInteractionData[MOUSE_POINTER_ID] = _this.mouse;
    _this.interactionDataPool = [];
    _this.eventData = new InteractionEvent();
    _this.interactionDOMElement = null;
    _this.moveWhenInside = false;
    _this.eventsAdded = false;
    _this.tickerAdded = false;
    _this.mouseOverRenderer = !("PointerEvent" in globalThis);
    _this.supportsTouchEvents = "ontouchstart" in globalThis;
    _this.supportsPointerEvents = !!globalThis.PointerEvent;
    _this.onPointerUp = _this.onPointerUp.bind(_this);
    _this.processPointerUp = _this.processPointerUp.bind(_this);
    _this.onPointerCancel = _this.onPointerCancel.bind(_this);
    _this.processPointerCancel = _this.processPointerCancel.bind(_this);
    _this.onPointerDown = _this.onPointerDown.bind(_this);
    _this.processPointerDown = _this.processPointerDown.bind(_this);
    _this.onPointerMove = _this.onPointerMove.bind(_this);
    _this.processPointerMove = _this.processPointerMove.bind(_this);
    _this.onPointerOut = _this.onPointerOut.bind(_this);
    _this.processPointerOverOut = _this.processPointerOverOut.bind(_this);
    _this.onPointerOver = _this.onPointerOver.bind(_this);
    _this.cursorStyles = {
      default: "inherit",
      pointer: "pointer"
    };
    _this.currentCursorMode = null;
    _this.cursor = null;
    _this.resolution = 1;
    _this.delayedEvents = [];
    _this.search = new TreeSearch();
    _this._tempDisplayObject = new TemporaryDisplayObject();
    _this._eventListenerOptions = { capture: true, passive: false };
    _this._useSystemTicker = options.useSystemTicker !== void 0 ? options.useSystemTicker : true;
    _this.setTargetElement(_this.renderer.view, _this.renderer.resolution);
    return _this;
  }
  Object.defineProperty(InteractionManager2.prototype, "useSystemTicker", {
    get: function() {
      return this._useSystemTicker;
    },
    set: function(useSystemTicker) {
      this._useSystemTicker = useSystemTicker;
      if (useSystemTicker) {
        this.addTickerListener();
      } else {
        this.removeTickerListener();
      }
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(InteractionManager2.prototype, "lastObjectRendered", {
    get: function() {
      return this.renderer._lastObjectRendered || this._tempDisplayObject;
    },
    enumerable: false,
    configurable: true
  });
  InteractionManager2.prototype.hitTest = function(globalPoint, root) {
    hitTestEvent.target = null;
    hitTestEvent.data.global = globalPoint;
    if (!root) {
      root = this.lastObjectRendered;
    }
    this.processInteractive(hitTestEvent, root, null, true);
    return hitTestEvent.target;
  };
  InteractionManager2.prototype.setTargetElement = function(element, resolution) {
    if (resolution === void 0) {
      resolution = 1;
    }
    this.removeTickerListener();
    this.removeEvents();
    this.interactionDOMElement = element;
    this.resolution = resolution;
    this.addEvents();
    this.addTickerListener();
  };
  InteractionManager2.prototype.addTickerListener = function() {
    if (this.tickerAdded || !this.interactionDOMElement || !this._useSystemTicker) {
      return;
    }
    Ticker.system.add(this.tickerUpdate, this, UPDATE_PRIORITY.INTERACTION);
    this.tickerAdded = true;
  };
  InteractionManager2.prototype.removeTickerListener = function() {
    if (!this.tickerAdded) {
      return;
    }
    Ticker.system.remove(this.tickerUpdate, this);
    this.tickerAdded = false;
  };
  InteractionManager2.prototype.addEvents = function() {
    if (this.eventsAdded || !this.interactionDOMElement) {
      return;
    }
    var style = this.interactionDOMElement.style;
    if (globalThis.navigator.msPointerEnabled) {
      style.msContentZooming = "none";
      style.msTouchAction = "none";
    } else if (this.supportsPointerEvents) {
      style.touchAction = "none";
    }
    if (this.supportsPointerEvents) {
      globalThis.document.addEventListener("pointermove", this.onPointerMove, this._eventListenerOptions);
      this.interactionDOMElement.addEventListener("pointerdown", this.onPointerDown, this._eventListenerOptions);
      this.interactionDOMElement.addEventListener("pointerleave", this.onPointerOut, this._eventListenerOptions);
      this.interactionDOMElement.addEventListener("pointerover", this.onPointerOver, this._eventListenerOptions);
      globalThis.addEventListener("pointercancel", this.onPointerCancel, this._eventListenerOptions);
      globalThis.addEventListener("pointerup", this.onPointerUp, this._eventListenerOptions);
    } else {
      globalThis.document.addEventListener("mousemove", this.onPointerMove, this._eventListenerOptions);
      this.interactionDOMElement.addEventListener("mousedown", this.onPointerDown, this._eventListenerOptions);
      this.interactionDOMElement.addEventListener("mouseout", this.onPointerOut, this._eventListenerOptions);
      this.interactionDOMElement.addEventListener("mouseover", this.onPointerOver, this._eventListenerOptions);
      globalThis.addEventListener("mouseup", this.onPointerUp, this._eventListenerOptions);
    }
    if (this.supportsTouchEvents) {
      this.interactionDOMElement.addEventListener("touchstart", this.onPointerDown, this._eventListenerOptions);
      this.interactionDOMElement.addEventListener("touchcancel", this.onPointerCancel, this._eventListenerOptions);
      this.interactionDOMElement.addEventListener("touchend", this.onPointerUp, this._eventListenerOptions);
      this.interactionDOMElement.addEventListener("touchmove", this.onPointerMove, this._eventListenerOptions);
    }
    this.eventsAdded = true;
  };
  InteractionManager2.prototype.removeEvents = function() {
    if (!this.eventsAdded || !this.interactionDOMElement) {
      return;
    }
    var style = this.interactionDOMElement.style;
    if (globalThis.navigator.msPointerEnabled) {
      style.msContentZooming = "";
      style.msTouchAction = "";
    } else if (this.supportsPointerEvents) {
      style.touchAction = "";
    }
    if (this.supportsPointerEvents) {
      globalThis.document.removeEventListener("pointermove", this.onPointerMove, this._eventListenerOptions);
      this.interactionDOMElement.removeEventListener("pointerdown", this.onPointerDown, this._eventListenerOptions);
      this.interactionDOMElement.removeEventListener("pointerleave", this.onPointerOut, this._eventListenerOptions);
      this.interactionDOMElement.removeEventListener("pointerover", this.onPointerOver, this._eventListenerOptions);
      globalThis.removeEventListener("pointercancel", this.onPointerCancel, this._eventListenerOptions);
      globalThis.removeEventListener("pointerup", this.onPointerUp, this._eventListenerOptions);
    } else {
      globalThis.document.removeEventListener("mousemove", this.onPointerMove, this._eventListenerOptions);
      this.interactionDOMElement.removeEventListener("mousedown", this.onPointerDown, this._eventListenerOptions);
      this.interactionDOMElement.removeEventListener("mouseout", this.onPointerOut, this._eventListenerOptions);
      this.interactionDOMElement.removeEventListener("mouseover", this.onPointerOver, this._eventListenerOptions);
      globalThis.removeEventListener("mouseup", this.onPointerUp, this._eventListenerOptions);
    }
    if (this.supportsTouchEvents) {
      this.interactionDOMElement.removeEventListener("touchstart", this.onPointerDown, this._eventListenerOptions);
      this.interactionDOMElement.removeEventListener("touchcancel", this.onPointerCancel, this._eventListenerOptions);
      this.interactionDOMElement.removeEventListener("touchend", this.onPointerUp, this._eventListenerOptions);
      this.interactionDOMElement.removeEventListener("touchmove", this.onPointerMove, this._eventListenerOptions);
    }
    this.interactionDOMElement = null;
    this.eventsAdded = false;
  };
  InteractionManager2.prototype.tickerUpdate = function(deltaTime) {
    this._deltaTime += deltaTime;
    if (this._deltaTime < this.interactionFrequency) {
      return;
    }
    this._deltaTime = 0;
    this.update();
  };
  InteractionManager2.prototype.update = function() {
    if (!this.interactionDOMElement) {
      return;
    }
    if (this._didMove) {
      this._didMove = false;
      return;
    }
    this.cursor = null;
    for (var k in this.activeInteractionData) {
      if (this.activeInteractionData.hasOwnProperty(k)) {
        var interactionData = this.activeInteractionData[k];
        if (interactionData.originalEvent && interactionData.pointerType !== "touch") {
          var interactionEvent = this.configureInteractionEventForDOMEvent(this.eventData, interactionData.originalEvent, interactionData);
          this.processInteractive(interactionEvent, this.lastObjectRendered, this.processPointerOverOut, true);
        }
      }
    }
    this.setCursorMode(this.cursor);
  };
  InteractionManager2.prototype.setCursorMode = function(mode) {
    mode = mode || "default";
    var applyStyles = true;
    if (globalThis.OffscreenCanvas && this.interactionDOMElement instanceof OffscreenCanvas) {
      applyStyles = false;
    }
    if (this.currentCursorMode === mode) {
      return;
    }
    this.currentCursorMode = mode;
    var style = this.cursorStyles[mode];
    if (style) {
      switch (typeof style) {
        case "string":
          if (applyStyles) {
            this.interactionDOMElement.style.cursor = style;
          }
          break;
        case "function":
          style(mode);
          break;
        case "object":
          if (applyStyles) {
            Object.assign(this.interactionDOMElement.style, style);
          }
          break;
      }
    } else if (applyStyles && typeof mode === "string" && !Object.prototype.hasOwnProperty.call(this.cursorStyles, mode)) {
      this.interactionDOMElement.style.cursor = mode;
    }
  };
  InteractionManager2.prototype.dispatchEvent = function(displayObject, eventString, eventData) {
    if (!eventData.stopPropagationHint || displayObject === eventData.stopsPropagatingAt) {
      eventData.currentTarget = displayObject;
      eventData.type = eventString;
      displayObject.emit(eventString, eventData);
      if (displayObject[eventString]) {
        displayObject[eventString](eventData);
      }
    }
  };
  InteractionManager2.prototype.delayDispatchEvent = function(displayObject, eventString, eventData) {
    this.delayedEvents.push({ displayObject, eventString, eventData });
  };
  InteractionManager2.prototype.mapPositionToPoint = function(point, x2, y2) {
    var rect;
    if (!this.interactionDOMElement.parentElement) {
      rect = {
        x: 0,
        y: 0,
        width: this.interactionDOMElement.width,
        height: this.interactionDOMElement.height,
        left: 0,
        top: 0
      };
    } else {
      rect = this.interactionDOMElement.getBoundingClientRect();
    }
    var resolutionMultiplier = 1 / this.resolution;
    point.x = (x2 - rect.left) * (this.interactionDOMElement.width / rect.width) * resolutionMultiplier;
    point.y = (y2 - rect.top) * (this.interactionDOMElement.height / rect.height) * resolutionMultiplier;
  };
  InteractionManager2.prototype.processInteractive = function(interactionEvent, displayObject, func, hitTest) {
    var hit = this.search.findHit(interactionEvent, displayObject, func, hitTest);
    var delayedEvents = this.delayedEvents;
    if (!delayedEvents.length) {
      return hit;
    }
    interactionEvent.stopPropagationHint = false;
    var delayedLen = delayedEvents.length;
    this.delayedEvents = [];
    for (var i2 = 0; i2 < delayedLen; i2++) {
      var _a3 = delayedEvents[i2], displayObject_1 = _a3.displayObject, eventString = _a3.eventString, eventData = _a3.eventData;
      if (eventData.stopsPropagatingAt === displayObject_1) {
        eventData.stopPropagationHint = true;
      }
      this.dispatchEvent(displayObject_1, eventString, eventData);
    }
    return hit;
  };
  InteractionManager2.prototype.onPointerDown = function(originalEvent) {
    if (this.supportsTouchEvents && originalEvent.pointerType === "touch") {
      return;
    }
    var events = this.normalizeToPointerData(originalEvent);
    if (this.autoPreventDefault && events[0].isNormalized) {
      var cancelable = originalEvent.cancelable || !("cancelable" in originalEvent);
      if (cancelable) {
        originalEvent.preventDefault();
      }
    }
    var eventLen = events.length;
    for (var i2 = 0; i2 < eventLen; i2++) {
      var event = events[i2];
      var interactionData = this.getInteractionDataForPointerId(event);
      var interactionEvent = this.configureInteractionEventForDOMEvent(this.eventData, event, interactionData);
      interactionEvent.data.originalEvent = originalEvent;
      this.processInteractive(interactionEvent, this.lastObjectRendered, this.processPointerDown, true);
      this.emit("pointerdown", interactionEvent);
      if (event.pointerType === "touch") {
        this.emit("touchstart", interactionEvent);
      } else if (event.pointerType === "mouse" || event.pointerType === "pen") {
        var isRightButton = event.button === 2;
        this.emit(isRightButton ? "rightdown" : "mousedown", this.eventData);
      }
    }
  };
  InteractionManager2.prototype.processPointerDown = function(interactionEvent, displayObject, hit) {
    var data = interactionEvent.data;
    var id = interactionEvent.data.identifier;
    if (hit) {
      if (!displayObject.trackedPointers[id]) {
        displayObject.trackedPointers[id] = new InteractionTrackingData(id);
      }
      this.dispatchEvent(displayObject, "pointerdown", interactionEvent);
      if (data.pointerType === "touch") {
        this.dispatchEvent(displayObject, "touchstart", interactionEvent);
      } else if (data.pointerType === "mouse" || data.pointerType === "pen") {
        var isRightButton = data.button === 2;
        if (isRightButton) {
          displayObject.trackedPointers[id].rightDown = true;
        } else {
          displayObject.trackedPointers[id].leftDown = true;
        }
        this.dispatchEvent(displayObject, isRightButton ? "rightdown" : "mousedown", interactionEvent);
      }
    }
  };
  InteractionManager2.prototype.onPointerComplete = function(originalEvent, cancelled, func) {
    var events = this.normalizeToPointerData(originalEvent);
    var eventLen = events.length;
    var eventAppend = originalEvent.target !== this.interactionDOMElement ? "outside" : "";
    for (var i2 = 0; i2 < eventLen; i2++) {
      var event = events[i2];
      var interactionData = this.getInteractionDataForPointerId(event);
      var interactionEvent = this.configureInteractionEventForDOMEvent(this.eventData, event, interactionData);
      interactionEvent.data.originalEvent = originalEvent;
      this.processInteractive(interactionEvent, this.lastObjectRendered, func, cancelled || !eventAppend);
      this.emit(cancelled ? "pointercancel" : "pointerup" + eventAppend, interactionEvent);
      if (event.pointerType === "mouse" || event.pointerType === "pen") {
        var isRightButton = event.button === 2;
        this.emit(isRightButton ? "rightup" + eventAppend : "mouseup" + eventAppend, interactionEvent);
      } else if (event.pointerType === "touch") {
        this.emit(cancelled ? "touchcancel" : "touchend" + eventAppend, interactionEvent);
        this.releaseInteractionDataForPointerId(event.pointerId);
      }
    }
  };
  InteractionManager2.prototype.onPointerCancel = function(event) {
    if (this.supportsTouchEvents && event.pointerType === "touch") {
      return;
    }
    this.onPointerComplete(event, true, this.processPointerCancel);
  };
  InteractionManager2.prototype.processPointerCancel = function(interactionEvent, displayObject) {
    var data = interactionEvent.data;
    var id = interactionEvent.data.identifier;
    if (displayObject.trackedPointers[id] !== void 0) {
      delete displayObject.trackedPointers[id];
      this.dispatchEvent(displayObject, "pointercancel", interactionEvent);
      if (data.pointerType === "touch") {
        this.dispatchEvent(displayObject, "touchcancel", interactionEvent);
      }
    }
  };
  InteractionManager2.prototype.onPointerUp = function(event) {
    if (this.supportsTouchEvents && event.pointerType === "touch") {
      return;
    }
    this.onPointerComplete(event, false, this.processPointerUp);
  };
  InteractionManager2.prototype.processPointerUp = function(interactionEvent, displayObject, hit) {
    var data = interactionEvent.data;
    var id = interactionEvent.data.identifier;
    var trackingData = displayObject.trackedPointers[id];
    var isTouch = data.pointerType === "touch";
    var isMouse = data.pointerType === "mouse" || data.pointerType === "pen";
    var isMouseTap = false;
    if (isMouse) {
      var isRightButton = data.button === 2;
      var flags = InteractionTrackingData.FLAGS;
      var test = isRightButton ? flags.RIGHT_DOWN : flags.LEFT_DOWN;
      var isDown = trackingData !== void 0 && trackingData.flags & test;
      if (hit) {
        this.dispatchEvent(displayObject, isRightButton ? "rightup" : "mouseup", interactionEvent);
        if (isDown) {
          this.dispatchEvent(displayObject, isRightButton ? "rightclick" : "click", interactionEvent);
          isMouseTap = true;
        }
      } else if (isDown) {
        this.dispatchEvent(displayObject, isRightButton ? "rightupoutside" : "mouseupoutside", interactionEvent);
      }
      if (trackingData) {
        if (isRightButton) {
          trackingData.rightDown = false;
        } else {
          trackingData.leftDown = false;
        }
      }
    }
    if (hit) {
      this.dispatchEvent(displayObject, "pointerup", interactionEvent);
      if (isTouch) {
        this.dispatchEvent(displayObject, "touchend", interactionEvent);
      }
      if (trackingData) {
        if (!isMouse || isMouseTap) {
          this.dispatchEvent(displayObject, "pointertap", interactionEvent);
        }
        if (isTouch) {
          this.dispatchEvent(displayObject, "tap", interactionEvent);
          trackingData.over = false;
        }
      }
    } else if (trackingData) {
      this.dispatchEvent(displayObject, "pointerupoutside", interactionEvent);
      if (isTouch) {
        this.dispatchEvent(displayObject, "touchendoutside", interactionEvent);
      }
    }
    if (trackingData && trackingData.none) {
      delete displayObject.trackedPointers[id];
    }
  };
  InteractionManager2.prototype.onPointerMove = function(originalEvent) {
    if (this.supportsTouchEvents && originalEvent.pointerType === "touch") {
      return;
    }
    var events = this.normalizeToPointerData(originalEvent);
    if (events[0].pointerType === "mouse" || events[0].pointerType === "pen") {
      this._didMove = true;
      this.cursor = null;
    }
    var eventLen = events.length;
    for (var i2 = 0; i2 < eventLen; i2++) {
      var event = events[i2];
      var interactionData = this.getInteractionDataForPointerId(event);
      var interactionEvent = this.configureInteractionEventForDOMEvent(this.eventData, event, interactionData);
      interactionEvent.data.originalEvent = originalEvent;
      this.processInteractive(interactionEvent, this.lastObjectRendered, this.processPointerMove, true);
      this.emit("pointermove", interactionEvent);
      if (event.pointerType === "touch") {
        this.emit("touchmove", interactionEvent);
      }
      if (event.pointerType === "mouse" || event.pointerType === "pen") {
        this.emit("mousemove", interactionEvent);
      }
    }
    if (events[0].pointerType === "mouse") {
      this.setCursorMode(this.cursor);
    }
  };
  InteractionManager2.prototype.processPointerMove = function(interactionEvent, displayObject, hit) {
    var data = interactionEvent.data;
    var isTouch = data.pointerType === "touch";
    var isMouse = data.pointerType === "mouse" || data.pointerType === "pen";
    if (isMouse) {
      this.processPointerOverOut(interactionEvent, displayObject, hit);
    }
    if (!this.moveWhenInside || hit) {
      this.dispatchEvent(displayObject, "pointermove", interactionEvent);
      if (isTouch) {
        this.dispatchEvent(displayObject, "touchmove", interactionEvent);
      }
      if (isMouse) {
        this.dispatchEvent(displayObject, "mousemove", interactionEvent);
      }
    }
  };
  InteractionManager2.prototype.onPointerOut = function(originalEvent) {
    if (this.supportsTouchEvents && originalEvent.pointerType === "touch") {
      return;
    }
    var events = this.normalizeToPointerData(originalEvent);
    var event = events[0];
    if (event.pointerType === "mouse") {
      this.mouseOverRenderer = false;
      this.setCursorMode(null);
    }
    var interactionData = this.getInteractionDataForPointerId(event);
    var interactionEvent = this.configureInteractionEventForDOMEvent(this.eventData, event, interactionData);
    interactionEvent.data.originalEvent = event;
    this.processInteractive(interactionEvent, this.lastObjectRendered, this.processPointerOverOut, false);
    this.emit("pointerout", interactionEvent);
    if (event.pointerType === "mouse" || event.pointerType === "pen") {
      this.emit("mouseout", interactionEvent);
    } else {
      this.releaseInteractionDataForPointerId(interactionData.identifier);
    }
  };
  InteractionManager2.prototype.processPointerOverOut = function(interactionEvent, displayObject, hit) {
    var data = interactionEvent.data;
    var id = interactionEvent.data.identifier;
    var isMouse = data.pointerType === "mouse" || data.pointerType === "pen";
    var trackingData = displayObject.trackedPointers[id];
    if (hit && !trackingData) {
      trackingData = displayObject.trackedPointers[id] = new InteractionTrackingData(id);
    }
    if (trackingData === void 0) {
      return;
    }
    if (hit && this.mouseOverRenderer) {
      if (!trackingData.over) {
        trackingData.over = true;
        this.delayDispatchEvent(displayObject, "pointerover", interactionEvent);
        if (isMouse) {
          this.delayDispatchEvent(displayObject, "mouseover", interactionEvent);
        }
      }
      if (isMouse && this.cursor === null) {
        this.cursor = displayObject.cursor;
      }
    } else if (trackingData.over) {
      trackingData.over = false;
      this.dispatchEvent(displayObject, "pointerout", this.eventData);
      if (isMouse) {
        this.dispatchEvent(displayObject, "mouseout", interactionEvent);
      }
      if (trackingData.none) {
        delete displayObject.trackedPointers[id];
      }
    }
  };
  InteractionManager2.prototype.onPointerOver = function(originalEvent) {
    var events = this.normalizeToPointerData(originalEvent);
    var event = events[0];
    var interactionData = this.getInteractionDataForPointerId(event);
    var interactionEvent = this.configureInteractionEventForDOMEvent(this.eventData, event, interactionData);
    interactionEvent.data.originalEvent = event;
    if (event.pointerType === "mouse") {
      this.mouseOverRenderer = true;
    }
    this.emit("pointerover", interactionEvent);
    if (event.pointerType === "mouse" || event.pointerType === "pen") {
      this.emit("mouseover", interactionEvent);
    }
  };
  InteractionManager2.prototype.getInteractionDataForPointerId = function(event) {
    var pointerId = event.pointerId;
    var interactionData;
    if (pointerId === MOUSE_POINTER_ID || event.pointerType === "mouse") {
      interactionData = this.mouse;
    } else if (this.activeInteractionData[pointerId]) {
      interactionData = this.activeInteractionData[pointerId];
    } else {
      interactionData = this.interactionDataPool.pop() || new InteractionData();
      interactionData.identifier = pointerId;
      this.activeInteractionData[pointerId] = interactionData;
    }
    interactionData.copyEvent(event);
    return interactionData;
  };
  InteractionManager2.prototype.releaseInteractionDataForPointerId = function(pointerId) {
    var interactionData = this.activeInteractionData[pointerId];
    if (interactionData) {
      delete this.activeInteractionData[pointerId];
      interactionData.reset();
      this.interactionDataPool.push(interactionData);
    }
  };
  InteractionManager2.prototype.configureInteractionEventForDOMEvent = function(interactionEvent, pointerEvent, interactionData) {
    interactionEvent.data = interactionData;
    this.mapPositionToPoint(interactionData.global, pointerEvent.clientX, pointerEvent.clientY);
    if (pointerEvent.pointerType === "touch") {
      pointerEvent.globalX = interactionData.global.x;
      pointerEvent.globalY = interactionData.global.y;
    }
    interactionData.originalEvent = pointerEvent;
    interactionEvent.reset();
    return interactionEvent;
  };
  InteractionManager2.prototype.normalizeToPointerData = function(event) {
    var normalizedEvents = [];
    if (this.supportsTouchEvents && event instanceof TouchEvent) {
      for (var i2 = 0, li = event.changedTouches.length; i2 < li; i2++) {
        var touch = event.changedTouches[i2];
        if (typeof touch.button === "undefined") {
          touch.button = event.touches.length ? 1 : 0;
        }
        if (typeof touch.buttons === "undefined") {
          touch.buttons = event.touches.length ? 1 : 0;
        }
        if (typeof touch.isPrimary === "undefined") {
          touch.isPrimary = event.touches.length === 1 && event.type === "touchstart";
        }
        if (typeof touch.width === "undefined") {
          touch.width = touch.radiusX || 1;
        }
        if (typeof touch.height === "undefined") {
          touch.height = touch.radiusY || 1;
        }
        if (typeof touch.tiltX === "undefined") {
          touch.tiltX = 0;
        }
        if (typeof touch.tiltY === "undefined") {
          touch.tiltY = 0;
        }
        if (typeof touch.pointerType === "undefined") {
          touch.pointerType = "touch";
        }
        if (typeof touch.pointerId === "undefined") {
          touch.pointerId = touch.identifier || 0;
        }
        if (typeof touch.pressure === "undefined") {
          touch.pressure = touch.force || 0.5;
        }
        if (typeof touch.twist === "undefined") {
          touch.twist = 0;
        }
        if (typeof touch.tangentialPressure === "undefined") {
          touch.tangentialPressure = 0;
        }
        if (typeof touch.layerX === "undefined") {
          touch.layerX = touch.offsetX = touch.clientX;
        }
        if (typeof touch.layerY === "undefined") {
          touch.layerY = touch.offsetY = touch.clientY;
        }
        touch.isNormalized = true;
        normalizedEvents.push(touch);
      }
    } else if (!globalThis.MouseEvent || event instanceof MouseEvent && (!this.supportsPointerEvents || !(event instanceof globalThis.PointerEvent))) {
      var tempEvent = event;
      if (typeof tempEvent.isPrimary === "undefined") {
        tempEvent.isPrimary = true;
      }
      if (typeof tempEvent.width === "undefined") {
        tempEvent.width = 1;
      }
      if (typeof tempEvent.height === "undefined") {
        tempEvent.height = 1;
      }
      if (typeof tempEvent.tiltX === "undefined") {
        tempEvent.tiltX = 0;
      }
      if (typeof tempEvent.tiltY === "undefined") {
        tempEvent.tiltY = 0;
      }
      if (typeof tempEvent.pointerType === "undefined") {
        tempEvent.pointerType = "mouse";
      }
      if (typeof tempEvent.pointerId === "undefined") {
        tempEvent.pointerId = MOUSE_POINTER_ID;
      }
      if (typeof tempEvent.pressure === "undefined") {
        tempEvent.pressure = 0.5;
      }
      if (typeof tempEvent.twist === "undefined") {
        tempEvent.twist = 0;
      }
      if (typeof tempEvent.tangentialPressure === "undefined") {
        tempEvent.tangentialPressure = 0;
      }
      tempEvent.isNormalized = true;
      normalizedEvents.push(tempEvent);
    } else {
      normalizedEvents.push(event);
    }
    return normalizedEvents;
  };
  InteractionManager2.prototype.destroy = function() {
    this.removeEvents();
    this.removeTickerListener();
    this.removeAllListeners();
    this.renderer = null;
    this.mouse = null;
    this.eventData = null;
    this.interactionDOMElement = null;
    this.onPointerDown = null;
    this.processPointerDown = null;
    this.onPointerUp = null;
    this.processPointerUp = null;
    this.onPointerCancel = null;
    this.processPointerCancel = null;
    this.onPointerMove = null;
    this.processPointerMove = null;
    this.onPointerOut = null;
    this.processPointerOverOut = null;
    this.onPointerOver = null;
    this.search = null;
  };
  return InteractionManager2;
}(EventEmitter$3);
/*!
 * @pixi/app - v6.3.0
 * Compiled Wed, 23 Mar 2022 18:58:56 UTC
 *
 * @pixi/app is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
var Application = function() {
  function Application2(options) {
    var _this = this;
    this.stage = new Container();
    options = Object.assign({
      forceCanvas: false
    }, options);
    this.renderer = autoDetectRenderer(options);
    Application2._plugins.forEach(function(plugin) {
      plugin.init.call(_this, options);
    });
  }
  Application2.registerPlugin = function(plugin) {
    Application2._plugins.push(plugin);
  };
  Application2.prototype.render = function() {
    this.renderer.render(this.stage);
  };
  Object.defineProperty(Application2.prototype, "view", {
    get: function() {
      return this.renderer.view;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Application2.prototype, "screen", {
    get: function() {
      return this.renderer.screen;
    },
    enumerable: false,
    configurable: true
  });
  Application2.prototype.destroy = function(removeView, stageOptions) {
    var _this = this;
    var plugins2 = Application2._plugins.slice(0);
    plugins2.reverse();
    plugins2.forEach(function(plugin) {
      plugin.destroy.call(_this);
    });
    this.stage.destroy(stageOptions);
    this.stage = null;
    this.renderer.destroy(removeView);
    this.renderer = null;
  };
  Application2._plugins = [];
  return Application2;
}();
var ResizePlugin = function() {
  function ResizePlugin2() {
  }
  ResizePlugin2.init = function(options) {
    var _this = this;
    Object.defineProperty(this, "resizeTo", {
      set: function(dom) {
        globalThis.removeEventListener("resize", this.queueResize);
        this._resizeTo = dom;
        if (dom) {
          globalThis.addEventListener("resize", this.queueResize);
          this.resize();
        }
      },
      get: function() {
        return this._resizeTo;
      }
    });
    this.queueResize = function() {
      if (!_this._resizeTo) {
        return;
      }
      _this.cancelResize();
      _this._resizeId = requestAnimationFrame(function() {
        return _this.resize();
      });
    };
    this.cancelResize = function() {
      if (_this._resizeId) {
        cancelAnimationFrame(_this._resizeId);
        _this._resizeId = null;
      }
    };
    this.resize = function() {
      if (!_this._resizeTo) {
        return;
      }
      _this.cancelResize();
      var width;
      var height;
      if (_this._resizeTo === globalThis.window) {
        width = globalThis.innerWidth;
        height = globalThis.innerHeight;
      } else {
        var _a3 = _this._resizeTo, clientWidth = _a3.clientWidth, clientHeight = _a3.clientHeight;
        width = clientWidth;
        height = clientHeight;
      }
      _this.renderer.resize(width, height);
    };
    this._resizeId = null;
    this._resizeTo = null;
    this.resizeTo = options.resizeTo || null;
  };
  ResizePlugin2.destroy = function() {
    globalThis.removeEventListener("resize", this.queueResize);
    this.cancelResize();
    this.cancelResize = null;
    this.queueResize = null;
    this.resizeTo = null;
    this.resize = null;
  };
  return ResizePlugin2;
}();
Application.registerPlugin(ResizePlugin);
/*!
 * @pixi/extract - v6.3.0
 * Compiled Wed, 23 Mar 2022 18:58:56 UTC
 *
 * @pixi/extract is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
var TEMP_RECT = new Rectangle();
var BYTES_PER_PIXEL = 4;
var Extract = function() {
  function Extract2(renderer) {
    this.renderer = renderer;
  }
  Extract2.prototype.image = function(target, format2, quality) {
    var image = new Image();
    image.src = this.base64(target, format2, quality);
    return image;
  };
  Extract2.prototype.base64 = function(target, format2, quality) {
    return this.canvas(target).toDataURL(format2, quality);
  };
  Extract2.prototype.canvas = function(target) {
    var renderer = this.renderer;
    var resolution;
    var frame;
    var flipY = false;
    var renderTexture;
    var generated = false;
    if (target) {
      if (target instanceof RenderTexture) {
        renderTexture = target;
      } else {
        renderTexture = this.renderer.generateTexture(target);
        generated = true;
      }
    }
    if (renderTexture) {
      resolution = renderTexture.baseTexture.resolution;
      frame = renderTexture.frame;
      flipY = false;
      renderer.renderTexture.bind(renderTexture);
    } else {
      resolution = this.renderer.resolution;
      flipY = true;
      frame = TEMP_RECT;
      frame.width = this.renderer.width;
      frame.height = this.renderer.height;
      renderer.renderTexture.bind(null);
    }
    var width = Math.floor(frame.width * resolution + 1e-4);
    var height = Math.floor(frame.height * resolution + 1e-4);
    var canvasBuffer = new CanvasRenderTarget(width, height, 1);
    var webglPixels = new Uint8Array(BYTES_PER_PIXEL * width * height);
    var gl = renderer.gl;
    gl.readPixels(frame.x * resolution, frame.y * resolution, width, height, gl.RGBA, gl.UNSIGNED_BYTE, webglPixels);
    var canvasData = canvasBuffer.context.getImageData(0, 0, width, height);
    Extract2.arrayPostDivide(webglPixels, canvasData.data);
    canvasBuffer.context.putImageData(canvasData, 0, 0);
    if (flipY) {
      var target_1 = new CanvasRenderTarget(canvasBuffer.width, canvasBuffer.height, 1);
      target_1.context.scale(1, -1);
      target_1.context.drawImage(canvasBuffer.canvas, 0, -height);
      canvasBuffer.destroy();
      canvasBuffer = target_1;
    }
    if (generated) {
      renderTexture.destroy(true);
    }
    return canvasBuffer.canvas;
  };
  Extract2.prototype.pixels = function(target) {
    var renderer = this.renderer;
    var resolution;
    var frame;
    var renderTexture;
    var generated = false;
    if (target) {
      if (target instanceof RenderTexture) {
        renderTexture = target;
      } else {
        renderTexture = this.renderer.generateTexture(target);
        generated = true;
      }
    }
    if (renderTexture) {
      resolution = renderTexture.baseTexture.resolution;
      frame = renderTexture.frame;
      renderer.renderTexture.bind(renderTexture);
    } else {
      resolution = renderer.resolution;
      frame = TEMP_RECT;
      frame.width = renderer.width;
      frame.height = renderer.height;
      renderer.renderTexture.bind(null);
    }
    var width = frame.width * resolution;
    var height = frame.height * resolution;
    var webglPixels = new Uint8Array(BYTES_PER_PIXEL * width * height);
    var gl = renderer.gl;
    gl.readPixels(frame.x * resolution, frame.y * resolution, width, height, gl.RGBA, gl.UNSIGNED_BYTE, webglPixels);
    if (generated) {
      renderTexture.destroy(true);
    }
    Extract2.arrayPostDivide(webglPixels, webglPixels);
    return webglPixels;
  };
  Extract2.prototype.destroy = function() {
    this.renderer = null;
  };
  Extract2.arrayPostDivide = function(pixels, out) {
    for (var i2 = 0; i2 < pixels.length; i2 += 4) {
      var alpha = out[i2 + 3] = pixels[i2 + 3];
      if (alpha !== 0) {
        out[i2] = Math.round(Math.min(pixels[i2] * 255 / alpha, 255));
        out[i2 + 1] = Math.round(Math.min(pixels[i2 + 1] * 255 / alpha, 255));
        out[i2 + 2] = Math.round(Math.min(pixels[i2 + 2] * 255 / alpha, 255));
      } else {
        out[i2] = pixels[i2];
        out[i2 + 1] = pixels[i2 + 1];
        out[i2 + 2] = pixels[i2 + 2];
      }
    }
  };
  return Extract2;
}();
/*!
 * @pixi/compressed-textures - v6.3.0
 * Compiled Wed, 23 Mar 2022 18:58:56 UTC
 *
 * @pixi/compressed-textures is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
var _a$1;
var INTERNAL_FORMATS;
(function(INTERNAL_FORMATS2) {
  INTERNAL_FORMATS2[INTERNAL_FORMATS2["COMPRESSED_RGB_S3TC_DXT1_EXT"] = 33776] = "COMPRESSED_RGB_S3TC_DXT1_EXT";
  INTERNAL_FORMATS2[INTERNAL_FORMATS2["COMPRESSED_RGBA_S3TC_DXT1_EXT"] = 33777] = "COMPRESSED_RGBA_S3TC_DXT1_EXT";
  INTERNAL_FORMATS2[INTERNAL_FORMATS2["COMPRESSED_RGBA_S3TC_DXT3_EXT"] = 33778] = "COMPRESSED_RGBA_S3TC_DXT3_EXT";
  INTERNAL_FORMATS2[INTERNAL_FORMATS2["COMPRESSED_RGBA_S3TC_DXT5_EXT"] = 33779] = "COMPRESSED_RGBA_S3TC_DXT5_EXT";
  INTERNAL_FORMATS2[INTERNAL_FORMATS2["COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT"] = 35917] = "COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT";
  INTERNAL_FORMATS2[INTERNAL_FORMATS2["COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT"] = 35918] = "COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT";
  INTERNAL_FORMATS2[INTERNAL_FORMATS2["COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT"] = 35919] = "COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT";
  INTERNAL_FORMATS2[INTERNAL_FORMATS2["COMPRESSED_SRGB_S3TC_DXT1_EXT"] = 35916] = "COMPRESSED_SRGB_S3TC_DXT1_EXT";
  INTERNAL_FORMATS2[INTERNAL_FORMATS2["COMPRESSED_R11_EAC"] = 37488] = "COMPRESSED_R11_EAC";
  INTERNAL_FORMATS2[INTERNAL_FORMATS2["COMPRESSED_SIGNED_R11_EAC"] = 37489] = "COMPRESSED_SIGNED_R11_EAC";
  INTERNAL_FORMATS2[INTERNAL_FORMATS2["COMPRESSED_RG11_EAC"] = 37490] = "COMPRESSED_RG11_EAC";
  INTERNAL_FORMATS2[INTERNAL_FORMATS2["COMPRESSED_SIGNED_RG11_EAC"] = 37491] = "COMPRESSED_SIGNED_RG11_EAC";
  INTERNAL_FORMATS2[INTERNAL_FORMATS2["COMPRESSED_RGB8_ETC2"] = 37492] = "COMPRESSED_RGB8_ETC2";
  INTERNAL_FORMATS2[INTERNAL_FORMATS2["COMPRESSED_RGBA8_ETC2_EAC"] = 37496] = "COMPRESSED_RGBA8_ETC2_EAC";
  INTERNAL_FORMATS2[INTERNAL_FORMATS2["COMPRESSED_SRGB8_ETC2"] = 37493] = "COMPRESSED_SRGB8_ETC2";
  INTERNAL_FORMATS2[INTERNAL_FORMATS2["COMPRESSED_SRGB8_ALPHA8_ETC2_EAC"] = 37497] = "COMPRESSED_SRGB8_ALPHA8_ETC2_EAC";
  INTERNAL_FORMATS2[INTERNAL_FORMATS2["COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2"] = 37494] = "COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2";
  INTERNAL_FORMATS2[INTERNAL_FORMATS2["COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2"] = 37495] = "COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2";
  INTERNAL_FORMATS2[INTERNAL_FORMATS2["COMPRESSED_RGB_PVRTC_4BPPV1_IMG"] = 35840] = "COMPRESSED_RGB_PVRTC_4BPPV1_IMG";
  INTERNAL_FORMATS2[INTERNAL_FORMATS2["COMPRESSED_RGBA_PVRTC_4BPPV1_IMG"] = 35842] = "COMPRESSED_RGBA_PVRTC_4BPPV1_IMG";
  INTERNAL_FORMATS2[INTERNAL_FORMATS2["COMPRESSED_RGB_PVRTC_2BPPV1_IMG"] = 35841] = "COMPRESSED_RGB_PVRTC_2BPPV1_IMG";
  INTERNAL_FORMATS2[INTERNAL_FORMATS2["COMPRESSED_RGBA_PVRTC_2BPPV1_IMG"] = 35843] = "COMPRESSED_RGBA_PVRTC_2BPPV1_IMG";
  INTERNAL_FORMATS2[INTERNAL_FORMATS2["COMPRESSED_RGB_ETC1_WEBGL"] = 36196] = "COMPRESSED_RGB_ETC1_WEBGL";
  INTERNAL_FORMATS2[INTERNAL_FORMATS2["COMPRESSED_RGB_ATC_WEBGL"] = 35986] = "COMPRESSED_RGB_ATC_WEBGL";
  INTERNAL_FORMATS2[INTERNAL_FORMATS2["COMPRESSED_RGBA_ATC_EXPLICIT_ALPHA_WEBGL"] = 35986] = "COMPRESSED_RGBA_ATC_EXPLICIT_ALPHA_WEBGL";
  INTERNAL_FORMATS2[INTERNAL_FORMATS2["COMPRESSED_RGBA_ATC_INTERPOLATED_ALPHA_WEBGL"] = 34798] = "COMPRESSED_RGBA_ATC_INTERPOLATED_ALPHA_WEBGL";
})(INTERNAL_FORMATS || (INTERNAL_FORMATS = {}));
var INTERNAL_FORMAT_TO_BYTES_PER_PIXEL = (_a$1 = {}, _a$1[INTERNAL_FORMATS.COMPRESSED_RGB_S3TC_DXT1_EXT] = 0.5, _a$1[INTERNAL_FORMATS.COMPRESSED_RGBA_S3TC_DXT1_EXT] = 0.5, _a$1[INTERNAL_FORMATS.COMPRESSED_RGBA_S3TC_DXT3_EXT] = 1, _a$1[INTERNAL_FORMATS.COMPRESSED_RGBA_S3TC_DXT5_EXT] = 1, _a$1[INTERNAL_FORMATS.COMPRESSED_SRGB_S3TC_DXT1_EXT] = 0.5, _a$1[INTERNAL_FORMATS.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT] = 0.5, _a$1[INTERNAL_FORMATS.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT] = 1, _a$1[INTERNAL_FORMATS.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT] = 1, _a$1[INTERNAL_FORMATS.COMPRESSED_R11_EAC] = 0.5, _a$1[INTERNAL_FORMATS.COMPRESSED_SIGNED_R11_EAC] = 0.5, _a$1[INTERNAL_FORMATS.COMPRESSED_RG11_EAC] = 1, _a$1[INTERNAL_FORMATS.COMPRESSED_SIGNED_RG11_EAC] = 1, _a$1[INTERNAL_FORMATS.COMPRESSED_RGB8_ETC2] = 0.5, _a$1[INTERNAL_FORMATS.COMPRESSED_RGBA8_ETC2_EAC] = 1, _a$1[INTERNAL_FORMATS.COMPRESSED_SRGB8_ETC2] = 0.5, _a$1[INTERNAL_FORMATS.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC] = 1, _a$1[INTERNAL_FORMATS.COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2] = 0.5, _a$1[INTERNAL_FORMATS.COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2] = 0.5, _a$1[INTERNAL_FORMATS.COMPRESSED_RGB_PVRTC_4BPPV1_IMG] = 0.5, _a$1[INTERNAL_FORMATS.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG] = 0.5, _a$1[INTERNAL_FORMATS.COMPRESSED_RGB_PVRTC_2BPPV1_IMG] = 0.25, _a$1[INTERNAL_FORMATS.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG] = 0.25, _a$1[INTERNAL_FORMATS.COMPRESSED_RGB_ETC1_WEBGL] = 0.5, _a$1[INTERNAL_FORMATS.COMPRESSED_RGB_ATC_WEBGL] = 0.5, _a$1[INTERNAL_FORMATS.COMPRESSED_RGBA_ATC_EXPLICIT_ALPHA_WEBGL] = 1, _a$1[INTERNAL_FORMATS.COMPRESSED_RGBA_ATC_INTERPOLATED_ALPHA_WEBGL] = 1, _a$1);
/*! *****************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */
var extendStatics$n = function(d2, b2) {
  extendStatics$n = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {
    d3.__proto__ = b3;
  } || function(d3, b3) {
    for (var p2 in b3) {
      if (b3.hasOwnProperty(p2)) {
        d3[p2] = b3[p2];
      }
    }
  };
  return extendStatics$n(d2, b2);
};
function __extends$n(d2, b2) {
  extendStatics$n(d2, b2);
  function __() {
    this.constructor = d2;
  }
  d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
}
function __awaiter(thisArg, _arguments, P2, generator) {
  return new (P2 || (P2 = Promise))(function(resolve2, reject2) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject2(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject2(e);
      }
    }
    function step(result) {
      result.done ? resolve2(result.value) : new P2(function(resolve3) {
        resolve3(result.value);
      }).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
}
function __generator(thisArg, body) {
  var _2 = { label: 0, sent: function() {
    if (t[0] & 1) {
      throw t[1];
    }
    return t[1];
  }, trys: [], ops: [] }, f2, y2, t, g2;
  return g2 = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g2[Symbol.iterator] = function() {
    return this;
  }), g2;
  function verb(n) {
    return function(v2) {
      return step([n, v2]);
    };
  }
  function step(op) {
    if (f2) {
      throw new TypeError("Generator is already executing.");
    }
    while (_2) {
      try {
        if (f2 = 1, y2 && (t = op[0] & 2 ? y2["return"] : op[0] ? y2["throw"] || ((t = y2["return"]) && t.call(y2), 0) : y2.next) && !(t = t.call(y2, op[1])).done) {
          return t;
        }
        if (y2 = 0, t) {
          op = [op[0] & 2, t.value];
        }
        switch (op[0]) {
          case 0:
          case 1:
            t = op;
            break;
          case 4:
            _2.label++;
            return { value: op[1], done: false };
          case 5:
            _2.label++;
            y2 = op[1];
            op = [0];
            continue;
          case 7:
            op = _2.ops.pop();
            _2.trys.pop();
            continue;
          default:
            if (!(t = _2.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
              _2 = 0;
              continue;
            }
            if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
              _2.label = op[1];
              break;
            }
            if (op[0] === 6 && _2.label < t[1]) {
              _2.label = t[1];
              t = op;
              break;
            }
            if (t && _2.label < t[2]) {
              _2.label = t[2];
              _2.ops.push(op);
              break;
            }
            if (t[2]) {
              _2.ops.pop();
            }
            _2.trys.pop();
            continue;
        }
        op = body.call(thisArg, _2);
      } catch (e) {
        op = [6, e];
        y2 = 0;
      } finally {
        f2 = t = 0;
      }
    }
    if (op[0] & 5) {
      throw op[1];
    }
    return { value: op[0] ? op[1] : void 0, done: true };
  }
}
var BlobResource = function(_super) {
  __extends$n(BlobResource2, _super);
  function BlobResource2(source, options) {
    if (options === void 0) {
      options = { width: 1, height: 1, autoLoad: true };
    }
    var _this = this;
    var origin;
    var data;
    if (typeof source === "string") {
      origin = source;
      data = new Uint8Array();
    } else {
      origin = null;
      data = source;
    }
    _this = _super.call(this, data, options) || this;
    _this.origin = origin;
    _this.buffer = data ? new ViewableBuffer(data) : null;
    if (_this.origin && options.autoLoad !== false) {
      _this.load();
    }
    if (data && data.length) {
      _this.loaded = true;
      _this.onBlobLoaded(_this.buffer.rawBinaryData);
    }
    return _this;
  }
  BlobResource2.prototype.onBlobLoaded = function(_data2) {
  };
  BlobResource2.prototype.load = function() {
    return __awaiter(this, void 0, Promise, function() {
      var response, blob, arrayBuffer;
      return __generator(this, function(_a3) {
        switch (_a3.label) {
          case 0:
            return [4, fetch(this.origin)];
          case 1:
            response = _a3.sent();
            return [4, response.blob()];
          case 2:
            blob = _a3.sent();
            return [4, blob.arrayBuffer()];
          case 3:
            arrayBuffer = _a3.sent();
            this.data = new Uint32Array(arrayBuffer);
            this.buffer = new ViewableBuffer(arrayBuffer);
            this.loaded = true;
            this.onBlobLoaded(arrayBuffer);
            this.update();
            return [2, this];
        }
      });
    });
  };
  return BlobResource2;
}(BufferResource);
var CompressedTextureResource = function(_super) {
  __extends$n(CompressedTextureResource2, _super);
  function CompressedTextureResource2(source, options) {
    var _this = _super.call(this, source, options) || this;
    _this.format = options.format;
    _this.levels = options.levels || 1;
    _this._width = options.width;
    _this._height = options.height;
    _this._extension = CompressedTextureResource2._formatToExtension(_this.format);
    if (options.levelBuffers || _this.buffer) {
      _this._levelBuffers = options.levelBuffers || CompressedTextureResource2._createLevelBuffers(source instanceof Uint8Array ? source : _this.buffer.uint8View, _this.format, _this.levels, 4, 4, _this.width, _this.height);
    }
    return _this;
  }
  CompressedTextureResource2.prototype.upload = function(renderer, _texture, _glTexture) {
    var gl = renderer.gl;
    var extension = renderer.context.extensions[this._extension];
    if (!extension) {
      throw new Error(this._extension + " textures are not supported on the current machine");
    }
    if (!this._levelBuffers) {
      return false;
    }
    for (var i2 = 0, j2 = this.levels; i2 < j2; i2++) {
      var _a3 = this._levelBuffers[i2], levelID = _a3.levelID, levelWidth = _a3.levelWidth, levelHeight = _a3.levelHeight, levelBuffer = _a3.levelBuffer;
      gl.compressedTexImage2D(gl.TEXTURE_2D, levelID, this.format, levelWidth, levelHeight, 0, levelBuffer);
    }
    return true;
  };
  CompressedTextureResource2.prototype.onBlobLoaded = function() {
    this._levelBuffers = CompressedTextureResource2._createLevelBuffers(this.buffer.uint8View, this.format, this.levels, 4, 4, this.width, this.height);
  };
  CompressedTextureResource2._formatToExtension = function(format2) {
    if (format2 >= 33776 && format2 <= 33779) {
      return "s3tc";
    } else if (format2 >= 37488 && format2 <= 37497) {
      return "etc";
    } else if (format2 >= 35840 && format2 <= 35843) {
      return "pvrtc";
    } else if (format2 >= 36196) {
      return "etc1";
    } else if (format2 >= 35986 && format2 <= 34798) {
      return "atc";
    }
    throw new Error("Invalid (compressed) texture format given!");
  };
  CompressedTextureResource2._createLevelBuffers = function(buffer, format2, levels, blockWidth, blockHeight, imageWidth, imageHeight) {
    var buffers = new Array(levels);
    var offset = buffer.byteOffset;
    var levelWidth = imageWidth;
    var levelHeight = imageHeight;
    var alignedLevelWidth = levelWidth + blockWidth - 1 & ~(blockWidth - 1);
    var alignedLevelHeight = levelHeight + blockHeight - 1 & ~(blockHeight - 1);
    var levelSize = alignedLevelWidth * alignedLevelHeight * INTERNAL_FORMAT_TO_BYTES_PER_PIXEL[format2];
    for (var i2 = 0; i2 < levels; i2++) {
      buffers[i2] = {
        levelID: i2,
        levelWidth: levels > 1 ? levelWidth : alignedLevelWidth,
        levelHeight: levels > 1 ? levelHeight : alignedLevelHeight,
        levelBuffer: new Uint8Array(buffer.buffer, offset, levelSize)
      };
      offset += levelSize;
      levelWidth = levelWidth >> 1 || 1;
      levelHeight = levelHeight >> 1 || 1;
      alignedLevelWidth = levelWidth + blockWidth - 1 & ~(blockWidth - 1);
      alignedLevelHeight = levelHeight + blockHeight - 1 & ~(blockHeight - 1);
      levelSize = alignedLevelWidth * alignedLevelHeight * INTERNAL_FORMAT_TO_BYTES_PER_PIXEL[format2];
    }
    return buffers;
  };
  return CompressedTextureResource2;
}(BlobResource);
var CompressedTextureLoader = function() {
  function CompressedTextureLoader2() {
  }
  CompressedTextureLoader2.use = function(resource, next) {
    var data = resource.data;
    var loader = this;
    if (resource.type === LoaderResource.TYPE.JSON && data && data.cacheID && data.textures) {
      var textures = data.textures;
      var textureURL = void 0;
      var fallbackURL = void 0;
      for (var i2 = 0, j2 = textures.length; i2 < j2; i2++) {
        var texture = textures[i2];
        var url_1 = texture.src;
        var format2 = texture.format;
        if (!format2) {
          fallbackURL = url_1;
        }
        if (CompressedTextureLoader2.textureFormats[format2]) {
          textureURL = url_1;
          break;
        }
      }
      textureURL = textureURL || fallbackURL;
      if (!textureURL) {
        next(new Error("Cannot load compressed-textures in " + resource.url + ", make sure you provide a fallback"));
        return;
      }
      if (textureURL === resource.url) {
        next(new Error("URL of compressed texture cannot be the same as the manifest's URL"));
        return;
      }
      var loadOptions = {
        crossOrigin: resource.crossOrigin,
        metadata: resource.metadata.imageMetadata,
        parentResource: resource
      };
      var resourcePath = url.resolve(resource.url.replace(loader.baseUrl, ""), textureURL);
      var resourceName = data.cacheID;
      loader.add(resourceName, resourcePath, loadOptions, function(res) {
        if (res.error) {
          next(res.error);
          return;
        }
        var _a3 = res.texture, texture2 = _a3 === void 0 ? null : _a3, _b3 = res.textures, textures2 = _b3 === void 0 ? {} : _b3;
        Object.assign(resource, { texture: texture2, textures: textures2 });
        next();
      });
    } else {
      next();
    }
  };
  CompressedTextureLoader2.add = function() {
    var canvas2 = document.createElement("canvas");
    var gl = canvas2.getContext("webgl");
    if (!gl) {
      console.warn("WebGL not available for compressed textures. Silently failing.");
      return;
    }
    var extensions = {
      s3tc: gl.getExtension("WEBGL_compressed_texture_s3tc"),
      s3tc_sRGB: gl.getExtension("WEBGL_compressed_texture_s3tc_srgb"),
      etc: gl.getExtension("WEBGL_compressed_texture_etc"),
      etc1: gl.getExtension("WEBGL_compressed_texture_etc1"),
      pvrtc: gl.getExtension("WEBGL_compressed_texture_pvrtc") || gl.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc"),
      atc: gl.getExtension("WEBGL_compressed_texture_atc"),
      astc: gl.getExtension("WEBGL_compressed_texture_astc")
    };
    CompressedTextureLoader2.textureExtensions = extensions;
    CompressedTextureLoader2.textureFormats = {};
    for (var extensionName in extensions) {
      var extension = extensions[extensionName];
      if (!extension) {
        continue;
      }
      Object.assign(CompressedTextureLoader2.textureFormats, Object.getPrototypeOf(extension));
    }
  };
  return CompressedTextureLoader2;
}();
function registerCompressedTextures(url2, resources2, metadata) {
  var result = {
    textures: {},
    texture: null
  };
  if (!resources2) {
    return result;
  }
  var textures = resources2.map(function(resource) {
    return new Texture(new BaseTexture(resource, Object.assign({
      mipmap: MIPMAP_MODES$3.OFF,
      alphaMode: ALPHA_MODES$3.NO_PREMULTIPLIED_ALPHA
    }, metadata)));
  });
  textures.forEach(function(texture, i2) {
    var baseTexture = texture.baseTexture;
    var cacheID = url2 + "-" + (i2 + 1);
    BaseTexture.addToCache(baseTexture, cacheID);
    Texture.addToCache(texture, cacheID);
    if (i2 === 0) {
      BaseTexture.addToCache(baseTexture, url2);
      Texture.addToCache(texture, url2);
      result.texture = texture;
    }
    result.textures[cacheID] = texture;
  });
  return result;
}
var _a$1$1, _b;
LoaderResource.setExtensionXhrType("dds", LoaderResource.XHR_RESPONSE_TYPE.BUFFER);
var DDS_MAGIC_SIZE = 4;
var DDS_HEADER_SIZE = 124;
var DDS_HEADER_PF_SIZE = 32;
var DDS_HEADER_DX10_SIZE = 20;
var DDS_MAGIC = 542327876;
var DDS_FIELDS = {
  SIZE: 1,
  FLAGS: 2,
  HEIGHT: 3,
  WIDTH: 4,
  MIPMAP_COUNT: 7,
  PIXEL_FORMAT: 19
};
var DDS_PF_FIELDS = {
  SIZE: 0,
  FLAGS: 1,
  FOURCC: 2,
  RGB_BITCOUNT: 3,
  R_BIT_MASK: 4,
  G_BIT_MASK: 5,
  B_BIT_MASK: 6,
  A_BIT_MASK: 7
};
var DDS_DX10_FIELDS = {
  DXGI_FORMAT: 0,
  RESOURCE_DIMENSION: 1,
  MISC_FLAG: 2,
  ARRAY_SIZE: 3,
  MISC_FLAGS2: 4
};
var DXGI_FORMAT;
(function(DXGI_FORMAT2) {
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_UNKNOWN"] = 0] = "DXGI_FORMAT_UNKNOWN";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R32G32B32A32_TYPELESS"] = 1] = "DXGI_FORMAT_R32G32B32A32_TYPELESS";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R32G32B32A32_FLOAT"] = 2] = "DXGI_FORMAT_R32G32B32A32_FLOAT";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R32G32B32A32_UINT"] = 3] = "DXGI_FORMAT_R32G32B32A32_UINT";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R32G32B32A32_SINT"] = 4] = "DXGI_FORMAT_R32G32B32A32_SINT";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R32G32B32_TYPELESS"] = 5] = "DXGI_FORMAT_R32G32B32_TYPELESS";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R32G32B32_FLOAT"] = 6] = "DXGI_FORMAT_R32G32B32_FLOAT";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R32G32B32_UINT"] = 7] = "DXGI_FORMAT_R32G32B32_UINT";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R32G32B32_SINT"] = 8] = "DXGI_FORMAT_R32G32B32_SINT";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R16G16B16A16_TYPELESS"] = 9] = "DXGI_FORMAT_R16G16B16A16_TYPELESS";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R16G16B16A16_FLOAT"] = 10] = "DXGI_FORMAT_R16G16B16A16_FLOAT";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R16G16B16A16_UNORM"] = 11] = "DXGI_FORMAT_R16G16B16A16_UNORM";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R16G16B16A16_UINT"] = 12] = "DXGI_FORMAT_R16G16B16A16_UINT";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R16G16B16A16_SNORM"] = 13] = "DXGI_FORMAT_R16G16B16A16_SNORM";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R16G16B16A16_SINT"] = 14] = "DXGI_FORMAT_R16G16B16A16_SINT";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R32G32_TYPELESS"] = 15] = "DXGI_FORMAT_R32G32_TYPELESS";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R32G32_FLOAT"] = 16] = "DXGI_FORMAT_R32G32_FLOAT";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R32G32_UINT"] = 17] = "DXGI_FORMAT_R32G32_UINT";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R32G32_SINT"] = 18] = "DXGI_FORMAT_R32G32_SINT";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R32G8X24_TYPELESS"] = 19] = "DXGI_FORMAT_R32G8X24_TYPELESS";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_D32_FLOAT_S8X24_UINT"] = 20] = "DXGI_FORMAT_D32_FLOAT_S8X24_UINT";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R32_FLOAT_X8X24_TYPELESS"] = 21] = "DXGI_FORMAT_R32_FLOAT_X8X24_TYPELESS";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_X32_TYPELESS_G8X24_UINT"] = 22] = "DXGI_FORMAT_X32_TYPELESS_G8X24_UINT";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R10G10B10A2_TYPELESS"] = 23] = "DXGI_FORMAT_R10G10B10A2_TYPELESS";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R10G10B10A2_UNORM"] = 24] = "DXGI_FORMAT_R10G10B10A2_UNORM";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R10G10B10A2_UINT"] = 25] = "DXGI_FORMAT_R10G10B10A2_UINT";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R11G11B10_FLOAT"] = 26] = "DXGI_FORMAT_R11G11B10_FLOAT";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R8G8B8A8_TYPELESS"] = 27] = "DXGI_FORMAT_R8G8B8A8_TYPELESS";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R8G8B8A8_UNORM"] = 28] = "DXGI_FORMAT_R8G8B8A8_UNORM";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R8G8B8A8_UNORM_SRGB"] = 29] = "DXGI_FORMAT_R8G8B8A8_UNORM_SRGB";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R8G8B8A8_UINT"] = 30] = "DXGI_FORMAT_R8G8B8A8_UINT";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R8G8B8A8_SNORM"] = 31] = "DXGI_FORMAT_R8G8B8A8_SNORM";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R8G8B8A8_SINT"] = 32] = "DXGI_FORMAT_R8G8B8A8_SINT";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R16G16_TYPELESS"] = 33] = "DXGI_FORMAT_R16G16_TYPELESS";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R16G16_FLOAT"] = 34] = "DXGI_FORMAT_R16G16_FLOAT";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R16G16_UNORM"] = 35] = "DXGI_FORMAT_R16G16_UNORM";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R16G16_UINT"] = 36] = "DXGI_FORMAT_R16G16_UINT";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R16G16_SNORM"] = 37] = "DXGI_FORMAT_R16G16_SNORM";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R16G16_SINT"] = 38] = "DXGI_FORMAT_R16G16_SINT";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R32_TYPELESS"] = 39] = "DXGI_FORMAT_R32_TYPELESS";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_D32_FLOAT"] = 40] = "DXGI_FORMAT_D32_FLOAT";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R32_FLOAT"] = 41] = "DXGI_FORMAT_R32_FLOAT";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R32_UINT"] = 42] = "DXGI_FORMAT_R32_UINT";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R32_SINT"] = 43] = "DXGI_FORMAT_R32_SINT";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R24G8_TYPELESS"] = 44] = "DXGI_FORMAT_R24G8_TYPELESS";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_D24_UNORM_S8_UINT"] = 45] = "DXGI_FORMAT_D24_UNORM_S8_UINT";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R24_UNORM_X8_TYPELESS"] = 46] = "DXGI_FORMAT_R24_UNORM_X8_TYPELESS";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_X24_TYPELESS_G8_UINT"] = 47] = "DXGI_FORMAT_X24_TYPELESS_G8_UINT";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R8G8_TYPELESS"] = 48] = "DXGI_FORMAT_R8G8_TYPELESS";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R8G8_UNORM"] = 49] = "DXGI_FORMAT_R8G8_UNORM";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R8G8_UINT"] = 50] = "DXGI_FORMAT_R8G8_UINT";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R8G8_SNORM"] = 51] = "DXGI_FORMAT_R8G8_SNORM";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R8G8_SINT"] = 52] = "DXGI_FORMAT_R8G8_SINT";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R16_TYPELESS"] = 53] = "DXGI_FORMAT_R16_TYPELESS";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R16_FLOAT"] = 54] = "DXGI_FORMAT_R16_FLOAT";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_D16_UNORM"] = 55] = "DXGI_FORMAT_D16_UNORM";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R16_UNORM"] = 56] = "DXGI_FORMAT_R16_UNORM";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R16_UINT"] = 57] = "DXGI_FORMAT_R16_UINT";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R16_SNORM"] = 58] = "DXGI_FORMAT_R16_SNORM";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R16_SINT"] = 59] = "DXGI_FORMAT_R16_SINT";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R8_TYPELESS"] = 60] = "DXGI_FORMAT_R8_TYPELESS";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R8_UNORM"] = 61] = "DXGI_FORMAT_R8_UNORM";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R8_UINT"] = 62] = "DXGI_FORMAT_R8_UINT";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R8_SNORM"] = 63] = "DXGI_FORMAT_R8_SNORM";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R8_SINT"] = 64] = "DXGI_FORMAT_R8_SINT";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_A8_UNORM"] = 65] = "DXGI_FORMAT_A8_UNORM";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R1_UNORM"] = 66] = "DXGI_FORMAT_R1_UNORM";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R9G9B9E5_SHAREDEXP"] = 67] = "DXGI_FORMAT_R9G9B9E5_SHAREDEXP";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R8G8_B8G8_UNORM"] = 68] = "DXGI_FORMAT_R8G8_B8G8_UNORM";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_G8R8_G8B8_UNORM"] = 69] = "DXGI_FORMAT_G8R8_G8B8_UNORM";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_BC1_TYPELESS"] = 70] = "DXGI_FORMAT_BC1_TYPELESS";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_BC1_UNORM"] = 71] = "DXGI_FORMAT_BC1_UNORM";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_BC1_UNORM_SRGB"] = 72] = "DXGI_FORMAT_BC1_UNORM_SRGB";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_BC2_TYPELESS"] = 73] = "DXGI_FORMAT_BC2_TYPELESS";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_BC2_UNORM"] = 74] = "DXGI_FORMAT_BC2_UNORM";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_BC2_UNORM_SRGB"] = 75] = "DXGI_FORMAT_BC2_UNORM_SRGB";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_BC3_TYPELESS"] = 76] = "DXGI_FORMAT_BC3_TYPELESS";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_BC3_UNORM"] = 77] = "DXGI_FORMAT_BC3_UNORM";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_BC3_UNORM_SRGB"] = 78] = "DXGI_FORMAT_BC3_UNORM_SRGB";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_BC4_TYPELESS"] = 79] = "DXGI_FORMAT_BC4_TYPELESS";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_BC4_UNORM"] = 80] = "DXGI_FORMAT_BC4_UNORM";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_BC4_SNORM"] = 81] = "DXGI_FORMAT_BC4_SNORM";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_BC5_TYPELESS"] = 82] = "DXGI_FORMAT_BC5_TYPELESS";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_BC5_UNORM"] = 83] = "DXGI_FORMAT_BC5_UNORM";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_BC5_SNORM"] = 84] = "DXGI_FORMAT_BC5_SNORM";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_B5G6R5_UNORM"] = 85] = "DXGI_FORMAT_B5G6R5_UNORM";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_B5G5R5A1_UNORM"] = 86] = "DXGI_FORMAT_B5G5R5A1_UNORM";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_B8G8R8A8_UNORM"] = 87] = "DXGI_FORMAT_B8G8R8A8_UNORM";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_B8G8R8X8_UNORM"] = 88] = "DXGI_FORMAT_B8G8R8X8_UNORM";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_R10G10B10_XR_BIAS_A2_UNORM"] = 89] = "DXGI_FORMAT_R10G10B10_XR_BIAS_A2_UNORM";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_B8G8R8A8_TYPELESS"] = 90] = "DXGI_FORMAT_B8G8R8A8_TYPELESS";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_B8G8R8A8_UNORM_SRGB"] = 91] = "DXGI_FORMAT_B8G8R8A8_UNORM_SRGB";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_B8G8R8X8_TYPELESS"] = 92] = "DXGI_FORMAT_B8G8R8X8_TYPELESS";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_B8G8R8X8_UNORM_SRGB"] = 93] = "DXGI_FORMAT_B8G8R8X8_UNORM_SRGB";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_BC6H_TYPELESS"] = 94] = "DXGI_FORMAT_BC6H_TYPELESS";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_BC6H_UF16"] = 95] = "DXGI_FORMAT_BC6H_UF16";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_BC6H_SF16"] = 96] = "DXGI_FORMAT_BC6H_SF16";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_BC7_TYPELESS"] = 97] = "DXGI_FORMAT_BC7_TYPELESS";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_BC7_UNORM"] = 98] = "DXGI_FORMAT_BC7_UNORM";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_BC7_UNORM_SRGB"] = 99] = "DXGI_FORMAT_BC7_UNORM_SRGB";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_AYUV"] = 100] = "DXGI_FORMAT_AYUV";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_Y410"] = 101] = "DXGI_FORMAT_Y410";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_Y416"] = 102] = "DXGI_FORMAT_Y416";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_NV12"] = 103] = "DXGI_FORMAT_NV12";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_P010"] = 104] = "DXGI_FORMAT_P010";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_P016"] = 105] = "DXGI_FORMAT_P016";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_420_OPAQUE"] = 106] = "DXGI_FORMAT_420_OPAQUE";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_YUY2"] = 107] = "DXGI_FORMAT_YUY2";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_Y210"] = 108] = "DXGI_FORMAT_Y210";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_Y216"] = 109] = "DXGI_FORMAT_Y216";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_NV11"] = 110] = "DXGI_FORMAT_NV11";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_AI44"] = 111] = "DXGI_FORMAT_AI44";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_IA44"] = 112] = "DXGI_FORMAT_IA44";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_P8"] = 113] = "DXGI_FORMAT_P8";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_A8P8"] = 114] = "DXGI_FORMAT_A8P8";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_B4G4R4A4_UNORM"] = 115] = "DXGI_FORMAT_B4G4R4A4_UNORM";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_P208"] = 116] = "DXGI_FORMAT_P208";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_V208"] = 117] = "DXGI_FORMAT_V208";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_V408"] = 118] = "DXGI_FORMAT_V408";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_SAMPLER_FEEDBACK_MIN_MIP_OPAQUE"] = 119] = "DXGI_FORMAT_SAMPLER_FEEDBACK_MIN_MIP_OPAQUE";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_SAMPLER_FEEDBACK_MIP_REGION_USED_OPAQUE"] = 120] = "DXGI_FORMAT_SAMPLER_FEEDBACK_MIP_REGION_USED_OPAQUE";
  DXGI_FORMAT2[DXGI_FORMAT2["DXGI_FORMAT_FORCE_UINT"] = 121] = "DXGI_FORMAT_FORCE_UINT";
})(DXGI_FORMAT || (DXGI_FORMAT = {}));
var D3D10_RESOURCE_DIMENSION;
(function(D3D10_RESOURCE_DIMENSION2) {
  D3D10_RESOURCE_DIMENSION2[D3D10_RESOURCE_DIMENSION2["DDS_DIMENSION_TEXTURE1D"] = 2] = "DDS_DIMENSION_TEXTURE1D";
  D3D10_RESOURCE_DIMENSION2[D3D10_RESOURCE_DIMENSION2["DDS_DIMENSION_TEXTURE2D"] = 3] = "DDS_DIMENSION_TEXTURE2D";
  D3D10_RESOURCE_DIMENSION2[D3D10_RESOURCE_DIMENSION2["DDS_DIMENSION_TEXTURE3D"] = 6] = "DDS_DIMENSION_TEXTURE3D";
})(D3D10_RESOURCE_DIMENSION || (D3D10_RESOURCE_DIMENSION = {}));
var PF_FLAGS = 1;
var DDPF_ALPHA = 2;
var DDPF_FOURCC = 4;
var DDPF_RGB = 64;
var DDPF_YUV = 512;
var DDPF_LUMINANCE = 131072;
var FOURCC_DXT1 = 827611204;
var FOURCC_DXT3 = 861165636;
var FOURCC_DXT5 = 894720068;
var FOURCC_DX10 = 808540228;
var DDS_RESOURCE_MISC_TEXTURECUBE = 4;
var FOURCC_TO_FORMAT = (_a$1$1 = {}, _a$1$1[FOURCC_DXT1] = INTERNAL_FORMATS.COMPRESSED_RGBA_S3TC_DXT1_EXT, _a$1$1[FOURCC_DXT3] = INTERNAL_FORMATS.COMPRESSED_RGBA_S3TC_DXT3_EXT, _a$1$1[FOURCC_DXT5] = INTERNAL_FORMATS.COMPRESSED_RGBA_S3TC_DXT5_EXT, _a$1$1);
var DXGI_TO_FORMAT = (_b = {}, _b[DXGI_FORMAT.DXGI_FORMAT_BC1_TYPELESS] = INTERNAL_FORMATS.COMPRESSED_RGBA_S3TC_DXT1_EXT, _b[DXGI_FORMAT.DXGI_FORMAT_BC1_UNORM] = INTERNAL_FORMATS.COMPRESSED_RGBA_S3TC_DXT1_EXT, _b[DXGI_FORMAT.DXGI_FORMAT_BC2_TYPELESS] = INTERNAL_FORMATS.COMPRESSED_RGBA_S3TC_DXT3_EXT, _b[DXGI_FORMAT.DXGI_FORMAT_BC2_UNORM] = INTERNAL_FORMATS.COMPRESSED_RGBA_S3TC_DXT3_EXT, _b[DXGI_FORMAT.DXGI_FORMAT_BC3_TYPELESS] = INTERNAL_FORMATS.COMPRESSED_RGBA_S3TC_DXT5_EXT, _b[DXGI_FORMAT.DXGI_FORMAT_BC3_UNORM] = INTERNAL_FORMATS.COMPRESSED_RGBA_S3TC_DXT5_EXT, _b[DXGI_FORMAT.DXGI_FORMAT_BC1_UNORM_SRGB] = INTERNAL_FORMATS.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT, _b[DXGI_FORMAT.DXGI_FORMAT_BC2_UNORM_SRGB] = INTERNAL_FORMATS.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT, _b[DXGI_FORMAT.DXGI_FORMAT_BC3_UNORM_SRGB] = INTERNAL_FORMATS.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT, _b);
var DDSLoader = function() {
  function DDSLoader2() {
  }
  DDSLoader2.use = function(resource, next) {
    if (resource.extension === "dds" && resource.data) {
      try {
        Object.assign(resource, registerCompressedTextures(resource.name || resource.url, DDSLoader2.parse(resource.data), resource.metadata));
      } catch (err) {
        next(err);
        return;
      }
    }
    next();
  };
  DDSLoader2.parse = function(arrayBuffer) {
    var data = new Uint32Array(arrayBuffer);
    var magicWord = data[0];
    if (magicWord !== DDS_MAGIC) {
      throw new Error("Invalid DDS file magic word");
    }
    var header = new Uint32Array(arrayBuffer, 0, DDS_HEADER_SIZE / Uint32Array.BYTES_PER_ELEMENT);
    var height = header[DDS_FIELDS.HEIGHT];
    var width = header[DDS_FIELDS.WIDTH];
    var mipmapCount = header[DDS_FIELDS.MIPMAP_COUNT];
    var pixelFormat = new Uint32Array(arrayBuffer, DDS_FIELDS.PIXEL_FORMAT * Uint32Array.BYTES_PER_ELEMENT, DDS_HEADER_PF_SIZE / Uint32Array.BYTES_PER_ELEMENT);
    var formatFlags = pixelFormat[PF_FLAGS];
    if (formatFlags & DDPF_FOURCC) {
      var fourCC = pixelFormat[DDS_PF_FIELDS.FOURCC];
      if (fourCC !== FOURCC_DX10) {
        var internalFormat_1 = FOURCC_TO_FORMAT[fourCC];
        var dataOffset_1 = DDS_MAGIC_SIZE + DDS_HEADER_SIZE;
        var texData = new Uint8Array(arrayBuffer, dataOffset_1);
        var resource = new CompressedTextureResource(texData, {
          format: internalFormat_1,
          width,
          height,
          levels: mipmapCount
        });
        return [resource];
      }
      var dx10Offset = DDS_MAGIC_SIZE + DDS_HEADER_SIZE;
      var dx10Header = new Uint32Array(data.buffer, dx10Offset, DDS_HEADER_DX10_SIZE / Uint32Array.BYTES_PER_ELEMENT);
      var dxgiFormat = dx10Header[DDS_DX10_FIELDS.DXGI_FORMAT];
      var resourceDimension = dx10Header[DDS_DX10_FIELDS.RESOURCE_DIMENSION];
      var miscFlag = dx10Header[DDS_DX10_FIELDS.MISC_FLAG];
      var arraySize = dx10Header[DDS_DX10_FIELDS.ARRAY_SIZE];
      var internalFormat_2 = DXGI_TO_FORMAT[dxgiFormat];
      if (internalFormat_2 === void 0) {
        throw new Error("DDSLoader cannot parse texture data with DXGI format " + dxgiFormat);
      }
      if (miscFlag === DDS_RESOURCE_MISC_TEXTURECUBE) {
        throw new Error("DDSLoader does not support cubemap textures");
      }
      if (resourceDimension === D3D10_RESOURCE_DIMENSION.DDS_DIMENSION_TEXTURE3D) {
        throw new Error("DDSLoader does not supported 3D texture data");
      }
      var imageBuffers = new Array();
      var dataOffset = DDS_MAGIC_SIZE + DDS_HEADER_SIZE + DDS_HEADER_DX10_SIZE;
      if (arraySize === 1) {
        imageBuffers.push(new Uint8Array(arrayBuffer, dataOffset));
      } else {
        var pixelSize = INTERNAL_FORMAT_TO_BYTES_PER_PIXEL[internalFormat_2];
        var imageSize = 0;
        var levelWidth = width;
        var levelHeight = height;
        for (var i2 = 0; i2 < mipmapCount; i2++) {
          var alignedLevelWidth = Math.max(1, levelWidth + 3 & ~3);
          var alignedLevelHeight = Math.max(1, levelHeight + 3 & ~3);
          var levelSize = alignedLevelWidth * alignedLevelHeight * pixelSize;
          imageSize += levelSize;
          levelWidth = levelWidth >>> 1;
          levelHeight = levelHeight >>> 1;
        }
        var imageOffset = dataOffset;
        for (var i2 = 0; i2 < arraySize; i2++) {
          imageBuffers.push(new Uint8Array(arrayBuffer, imageOffset, imageSize));
          imageOffset += imageSize;
        }
      }
      return imageBuffers.map(function(buffer) {
        return new CompressedTextureResource(buffer, {
          format: internalFormat_2,
          width,
          height,
          levels: mipmapCount
        });
      });
    }
    if (formatFlags & DDPF_RGB) {
      throw new Error("DDSLoader does not support uncompressed texture data.");
    }
    if (formatFlags & DDPF_YUV) {
      throw new Error("DDSLoader does not supported YUV uncompressed texture data.");
    }
    if (formatFlags & DDPF_LUMINANCE) {
      throw new Error("DDSLoader does not support single-channel (lumninance) texture data!");
    }
    if (formatFlags & DDPF_ALPHA) {
      throw new Error("DDSLoader does not support single-channel (alpha) texture data!");
    }
    throw new Error("DDSLoader failed to load a texture file due to an unknown reason!");
  };
  return DDSLoader2;
}();
var _a$2, _b$1, _c;
LoaderResource.setExtensionXhrType("ktx", LoaderResource.XHR_RESPONSE_TYPE.BUFFER);
var FILE_IDENTIFIER = [171, 75, 84, 88, 32, 49, 49, 187, 13, 10, 26, 10];
var ENDIANNESS = 67305985;
var KTX_FIELDS = {
  FILE_IDENTIFIER: 0,
  ENDIANNESS: 12,
  GL_TYPE: 16,
  GL_TYPE_SIZE: 20,
  GL_FORMAT: 24,
  GL_INTERNAL_FORMAT: 28,
  GL_BASE_INTERNAL_FORMAT: 32,
  PIXEL_WIDTH: 36,
  PIXEL_HEIGHT: 40,
  PIXEL_DEPTH: 44,
  NUMBER_OF_ARRAY_ELEMENTS: 48,
  NUMBER_OF_FACES: 52,
  NUMBER_OF_MIPMAP_LEVELS: 56,
  BYTES_OF_KEY_VALUE_DATA: 60
};
var FILE_HEADER_SIZE = 64;
var TYPES_TO_BYTES_PER_COMPONENT = (_a$2 = {}, _a$2[TYPES$3.UNSIGNED_BYTE] = 1, _a$2[TYPES$3.UNSIGNED_SHORT] = 2, _a$2[TYPES$3.INT] = 4, _a$2[TYPES$3.UNSIGNED_INT] = 4, _a$2[TYPES$3.FLOAT] = 4, _a$2[TYPES$3.HALF_FLOAT] = 8, _a$2);
var FORMATS_TO_COMPONENTS = (_b$1 = {}, _b$1[FORMATS$3.RGBA] = 4, _b$1[FORMATS$3.RGB] = 3, _b$1[FORMATS$3.RG] = 2, _b$1[FORMATS$3.RED] = 1, _b$1[FORMATS$3.LUMINANCE] = 1, _b$1[FORMATS$3.LUMINANCE_ALPHA] = 2, _b$1[FORMATS$3.ALPHA] = 1, _b$1);
var TYPES_TO_BYTES_PER_PIXEL = (_c = {}, _c[TYPES$3.UNSIGNED_SHORT_4_4_4_4] = 2, _c[TYPES$3.UNSIGNED_SHORT_5_5_5_1] = 2, _c[TYPES$3.UNSIGNED_SHORT_5_6_5] = 2, _c);
var KTXLoader = function() {
  function KTXLoader2() {
  }
  KTXLoader2.use = function(resource, next) {
    if (resource.extension === "ktx" && resource.data) {
      try {
        var url_1 = resource.name || resource.url;
        var _a3 = KTXLoader2.parse(url_1, resource.data), compressed = _a3.compressed, uncompressed = _a3.uncompressed;
        if (compressed) {
          Object.assign(resource, registerCompressedTextures(url_1, compressed, resource.metadata));
        } else if (uncompressed) {
          var textures_1 = {};
          uncompressed.forEach(function(image, i2) {
            var texture = new Texture(new BaseTexture(image.resource, {
              mipmap: MIPMAP_MODES$3.OFF,
              alphaMode: ALPHA_MODES$3.NO_PREMULTIPLIED_ALPHA,
              type: image.type,
              format: image.format
            }));
            var cacheID = url_1 + "-" + (i2 + 1);
            BaseTexture.addToCache(texture.baseTexture, cacheID);
            Texture.addToCache(texture, cacheID);
            if (i2 === 0) {
              textures_1[url_1] = texture;
              BaseTexture.addToCache(texture.baseTexture, url_1);
              Texture.addToCache(texture, url_1);
            }
            textures_1[cacheID] = texture;
          });
          Object.assign(resource, { textures: textures_1 });
        }
      } catch (err) {
        next(err);
        return;
      }
    }
    next();
  };
  KTXLoader2.parse = function(url2, arrayBuffer) {
    var dataView = new DataView(arrayBuffer);
    if (!KTXLoader2.validate(url2, dataView)) {
      return null;
    }
    var littleEndian = dataView.getUint32(KTX_FIELDS.ENDIANNESS, true) === ENDIANNESS;
    var glType = dataView.getUint32(KTX_FIELDS.GL_TYPE, littleEndian);
    var glFormat = dataView.getUint32(KTX_FIELDS.GL_FORMAT, littleEndian);
    var glInternalFormat = dataView.getUint32(KTX_FIELDS.GL_INTERNAL_FORMAT, littleEndian);
    var pixelWidth = dataView.getUint32(KTX_FIELDS.PIXEL_WIDTH, littleEndian);
    var pixelHeight = dataView.getUint32(KTX_FIELDS.PIXEL_HEIGHT, littleEndian) || 1;
    var pixelDepth = dataView.getUint32(KTX_FIELDS.PIXEL_DEPTH, littleEndian) || 1;
    var numberOfArrayElements = dataView.getUint32(KTX_FIELDS.NUMBER_OF_ARRAY_ELEMENTS, littleEndian) || 1;
    var numberOfFaces = dataView.getUint32(KTX_FIELDS.NUMBER_OF_FACES, littleEndian);
    var numberOfMipmapLevels = dataView.getUint32(KTX_FIELDS.NUMBER_OF_MIPMAP_LEVELS, littleEndian);
    var bytesOfKeyValueData = dataView.getUint32(KTX_FIELDS.BYTES_OF_KEY_VALUE_DATA, littleEndian);
    if (pixelHeight === 0 || pixelDepth !== 1) {
      throw new Error("Only 2D textures are supported");
    }
    if (numberOfFaces !== 1) {
      throw new Error("CubeTextures are not supported by KTXLoader yet!");
    }
    if (numberOfArrayElements !== 1) {
      throw new Error("WebGL does not support array textures");
    }
    var blockWidth = 4;
    var blockHeight = 4;
    var alignedWidth = pixelWidth + 3 & ~3;
    var alignedHeight = pixelHeight + 3 & ~3;
    var imageBuffers = new Array(numberOfArrayElements);
    var imagePixels = pixelWidth * pixelHeight;
    if (glType === 0) {
      imagePixels = alignedWidth * alignedHeight;
    }
    var imagePixelByteSize;
    if (glType !== 0) {
      if (TYPES_TO_BYTES_PER_COMPONENT[glType]) {
        imagePixelByteSize = TYPES_TO_BYTES_PER_COMPONENT[glType] * FORMATS_TO_COMPONENTS[glFormat];
      } else {
        imagePixelByteSize = TYPES_TO_BYTES_PER_PIXEL[glType];
      }
    } else {
      imagePixelByteSize = INTERNAL_FORMAT_TO_BYTES_PER_PIXEL[glInternalFormat];
    }
    if (imagePixelByteSize === void 0) {
      throw new Error("Unable to resolve the pixel format stored in the *.ktx file!");
    }
    var imageByteSize = imagePixels * imagePixelByteSize;
    var mipByteSize = imageByteSize;
    var mipWidth = pixelWidth;
    var mipHeight = pixelHeight;
    var alignedMipWidth = alignedWidth;
    var alignedMipHeight = alignedHeight;
    var imageOffset = FILE_HEADER_SIZE + bytesOfKeyValueData;
    for (var mipmapLevel = 0; mipmapLevel < numberOfMipmapLevels; mipmapLevel++) {
      var imageSize = dataView.getUint32(imageOffset, littleEndian);
      var elementOffset = imageOffset + 4;
      for (var arrayElement = 0; arrayElement < numberOfArrayElements; arrayElement++) {
        var mips = imageBuffers[arrayElement];
        if (!mips) {
          mips = imageBuffers[arrayElement] = new Array(numberOfMipmapLevels);
        }
        mips[mipmapLevel] = {
          levelID: mipmapLevel,
          levelWidth: numberOfMipmapLevels > 1 || glType !== 0 ? mipWidth : alignedMipWidth,
          levelHeight: numberOfMipmapLevels > 1 || glType !== 0 ? mipHeight : alignedMipHeight,
          levelBuffer: new Uint8Array(arrayBuffer, elementOffset, mipByteSize)
        };
        elementOffset += mipByteSize;
      }
      imageOffset += imageSize + 4;
      imageOffset = imageOffset % 4 !== 0 ? imageOffset + 4 - imageOffset % 4 : imageOffset;
      mipWidth = mipWidth >> 1 || 1;
      mipHeight = mipHeight >> 1 || 1;
      alignedMipWidth = mipWidth + blockWidth - 1 & ~(blockWidth - 1);
      alignedMipHeight = mipHeight + blockHeight - 1 & ~(blockHeight - 1);
      mipByteSize = alignedMipWidth * alignedMipHeight * imagePixelByteSize;
    }
    if (glType !== 0) {
      return {
        uncompressed: imageBuffers.map(function(levelBuffers) {
          var buffer = levelBuffers[0].levelBuffer;
          var convertToInt = false;
          if (glType === TYPES$3.FLOAT) {
            buffer = new Float32Array(levelBuffers[0].levelBuffer.buffer, levelBuffers[0].levelBuffer.byteOffset, levelBuffers[0].levelBuffer.byteLength / 4);
          } else if (glType === TYPES$3.UNSIGNED_INT) {
            convertToInt = true;
            buffer = new Uint32Array(levelBuffers[0].levelBuffer.buffer, levelBuffers[0].levelBuffer.byteOffset, levelBuffers[0].levelBuffer.byteLength / 4);
          } else if (glType === TYPES$3.INT) {
            convertToInt = true;
            buffer = new Int32Array(levelBuffers[0].levelBuffer.buffer, levelBuffers[0].levelBuffer.byteOffset, levelBuffers[0].levelBuffer.byteLength / 4);
          }
          return {
            resource: new BufferResource(buffer, {
              width: levelBuffers[0].levelWidth,
              height: levelBuffers[0].levelHeight
            }),
            type: glType,
            format: convertToInt ? KTXLoader2.convertFormatToInteger(glFormat) : glFormat
          };
        })
      };
    }
    return {
      compressed: imageBuffers.map(function(levelBuffers) {
        return new CompressedTextureResource(null, {
          format: glInternalFormat,
          width: pixelWidth,
          height: pixelHeight,
          levels: numberOfMipmapLevels,
          levelBuffers
        });
      })
    };
  };
  KTXLoader2.validate = function(url2, dataView) {
    for (var i2 = 0; i2 < FILE_IDENTIFIER.length; i2++) {
      if (dataView.getUint8(i2) !== FILE_IDENTIFIER[i2]) {
        console.error(url2 + " is not a valid *.ktx file!");
        return false;
      }
    }
    return true;
  };
  KTXLoader2.convertFormatToInteger = function(format2) {
    switch (format2) {
      case FORMATS$3.RGBA:
        return FORMATS$3.RGBA_INTEGER;
      case FORMATS$3.RGB:
        return FORMATS$3.RGB_INTEGER;
      case FORMATS$3.RG:
        return FORMATS$3.RG_INTEGER;
      case FORMATS$3.RED:
        return FORMATS$3.RED_INTEGER;
      default:
        return format2;
    }
  };
  return KTXLoader2;
}();
/*!
 * @pixi/particle-container - v6.3.0
 * Compiled Wed, 23 Mar 2022 18:58:56 UTC
 *
 * @pixi/particle-container is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
/*! *****************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */
var extendStatics$m = function(d2, b2) {
  extendStatics$m = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {
    d3.__proto__ = b3;
  } || function(d3, b3) {
    for (var p2 in b3) {
      if (b3.hasOwnProperty(p2)) {
        d3[p2] = b3[p2];
      }
    }
  };
  return extendStatics$m(d2, b2);
};
function __extends$m(d2, b2) {
  extendStatics$m(d2, b2);
  function __() {
    this.constructor = d2;
  }
  d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
}
(function(_super) {
  __extends$m(ParticleContainer, _super);
  function ParticleContainer(maxSize, properties, batchSize, autoResize) {
    if (maxSize === void 0) {
      maxSize = 1500;
    }
    if (batchSize === void 0) {
      batchSize = 16384;
    }
    if (autoResize === void 0) {
      autoResize = false;
    }
    var _this = _super.call(this) || this;
    var maxBatchSize = 16384;
    if (batchSize > maxBatchSize) {
      batchSize = maxBatchSize;
    }
    _this._properties = [false, true, false, false, false];
    _this._maxSize = maxSize;
    _this._batchSize = batchSize;
    _this._buffers = null;
    _this._bufferUpdateIDs = [];
    _this._updateID = 0;
    _this.interactiveChildren = false;
    _this.blendMode = BLEND_MODES$3.NORMAL;
    _this.autoResize = autoResize;
    _this.roundPixels = true;
    _this.baseTexture = null;
    _this.setProperties(properties);
    _this._tint = 0;
    _this.tintRgb = new Float32Array(4);
    _this.tint = 16777215;
    return _this;
  }
  ParticleContainer.prototype.setProperties = function(properties) {
    if (properties) {
      this._properties[0] = "vertices" in properties || "scale" in properties ? !!properties.vertices || !!properties.scale : this._properties[0];
      this._properties[1] = "position" in properties ? !!properties.position : this._properties[1];
      this._properties[2] = "rotation" in properties ? !!properties.rotation : this._properties[2];
      this._properties[3] = "uvs" in properties ? !!properties.uvs : this._properties[3];
      this._properties[4] = "tint" in properties || "alpha" in properties ? !!properties.tint || !!properties.alpha : this._properties[4];
    }
  };
  ParticleContainer.prototype.updateTransform = function() {
    this.displayObjectUpdateTransform();
  };
  Object.defineProperty(ParticleContainer.prototype, "tint", {
    get: function() {
      return this._tint;
    },
    set: function(value) {
      this._tint = value;
      hex2rgb(value, this.tintRgb);
    },
    enumerable: false,
    configurable: true
  });
  ParticleContainer.prototype.render = function(renderer) {
    var _this = this;
    if (!this.visible || this.worldAlpha <= 0 || !this.children.length || !this.renderable) {
      return;
    }
    if (!this.baseTexture) {
      this.baseTexture = this.children[0]._texture.baseTexture;
      if (!this.baseTexture.valid) {
        this.baseTexture.once("update", function() {
          return _this.onChildrenChange(0);
        });
      }
    }
    renderer.batch.setObjectRenderer(renderer.plugins.particle);
    renderer.plugins.particle.render(this);
  };
  ParticleContainer.prototype.onChildrenChange = function(smallestChildIndex) {
    var bufferIndex = Math.floor(smallestChildIndex / this._batchSize);
    while (this._bufferUpdateIDs.length < bufferIndex) {
      this._bufferUpdateIDs.push(0);
    }
    this._bufferUpdateIDs[bufferIndex] = ++this._updateID;
  };
  ParticleContainer.prototype.dispose = function() {
    if (this._buffers) {
      for (var i2 = 0; i2 < this._buffers.length; ++i2) {
        this._buffers[i2].destroy();
      }
      this._buffers = null;
    }
  };
  ParticleContainer.prototype.destroy = function(options) {
    _super.prototype.destroy.call(this, options);
    this.dispose();
    this._properties = null;
    this._buffers = null;
    this._bufferUpdateIDs = null;
  };
  return ParticleContainer;
})(Container);
var ParticleBuffer = function() {
  function ParticleBuffer2(properties, dynamicPropertyFlags, size) {
    this.geometry = new Geometry();
    this.indexBuffer = null;
    this.size = size;
    this.dynamicProperties = [];
    this.staticProperties = [];
    for (var i2 = 0; i2 < properties.length; ++i2) {
      var property = properties[i2];
      property = {
        attributeName: property.attributeName,
        size: property.size,
        uploadFunction: property.uploadFunction,
        type: property.type || TYPES$3.FLOAT,
        offset: property.offset
      };
      if (dynamicPropertyFlags[i2]) {
        this.dynamicProperties.push(property);
      } else {
        this.staticProperties.push(property);
      }
    }
    this.staticStride = 0;
    this.staticBuffer = null;
    this.staticData = null;
    this.staticDataUint32 = null;
    this.dynamicStride = 0;
    this.dynamicBuffer = null;
    this.dynamicData = null;
    this.dynamicDataUint32 = null;
    this._updateID = 0;
    this.initBuffers();
  }
  ParticleBuffer2.prototype.initBuffers = function() {
    var geometry = this.geometry;
    var dynamicOffset = 0;
    this.indexBuffer = new Buffer$1(createIndicesForQuads(this.size), true, true);
    geometry.addIndex(this.indexBuffer);
    this.dynamicStride = 0;
    for (var i2 = 0; i2 < this.dynamicProperties.length; ++i2) {
      var property = this.dynamicProperties[i2];
      property.offset = dynamicOffset;
      dynamicOffset += property.size;
      this.dynamicStride += property.size;
    }
    var dynBuffer = new ArrayBuffer(this.size * this.dynamicStride * 4 * 4);
    this.dynamicData = new Float32Array(dynBuffer);
    this.dynamicDataUint32 = new Uint32Array(dynBuffer);
    this.dynamicBuffer = new Buffer$1(this.dynamicData, false, false);
    var staticOffset = 0;
    this.staticStride = 0;
    for (var i2 = 0; i2 < this.staticProperties.length; ++i2) {
      var property = this.staticProperties[i2];
      property.offset = staticOffset;
      staticOffset += property.size;
      this.staticStride += property.size;
    }
    var statBuffer = new ArrayBuffer(this.size * this.staticStride * 4 * 4);
    this.staticData = new Float32Array(statBuffer);
    this.staticDataUint32 = new Uint32Array(statBuffer);
    this.staticBuffer = new Buffer$1(this.staticData, true, false);
    for (var i2 = 0; i2 < this.dynamicProperties.length; ++i2) {
      var property = this.dynamicProperties[i2];
      geometry.addAttribute(property.attributeName, this.dynamicBuffer, 0, property.type === TYPES$3.UNSIGNED_BYTE, property.type, this.dynamicStride * 4, property.offset * 4);
    }
    for (var i2 = 0; i2 < this.staticProperties.length; ++i2) {
      var property = this.staticProperties[i2];
      geometry.addAttribute(property.attributeName, this.staticBuffer, 0, property.type === TYPES$3.UNSIGNED_BYTE, property.type, this.staticStride * 4, property.offset * 4);
    }
  };
  ParticleBuffer2.prototype.uploadDynamic = function(children, startIndex, amount) {
    for (var i2 = 0; i2 < this.dynamicProperties.length; i2++) {
      var property = this.dynamicProperties[i2];
      property.uploadFunction(children, startIndex, amount, property.type === TYPES$3.UNSIGNED_BYTE ? this.dynamicDataUint32 : this.dynamicData, this.dynamicStride, property.offset);
    }
    this.dynamicBuffer._updateID++;
  };
  ParticleBuffer2.prototype.uploadStatic = function(children, startIndex, amount) {
    for (var i2 = 0; i2 < this.staticProperties.length; i2++) {
      var property = this.staticProperties[i2];
      property.uploadFunction(children, startIndex, amount, property.type === TYPES$3.UNSIGNED_BYTE ? this.staticDataUint32 : this.staticData, this.staticStride, property.offset);
    }
    this.staticBuffer._updateID++;
  };
  ParticleBuffer2.prototype.destroy = function() {
    this.indexBuffer = null;
    this.dynamicProperties = null;
    this.dynamicBuffer = null;
    this.dynamicData = null;
    this.dynamicDataUint32 = null;
    this.staticProperties = null;
    this.staticBuffer = null;
    this.staticData = null;
    this.staticDataUint32 = null;
    this.geometry.destroy();
  };
  return ParticleBuffer2;
}();
var fragment$6 = "varying vec2 vTextureCoord;\nvarying vec4 vColor;\n\nuniform sampler2D uSampler;\n\nvoid main(void){\n    vec4 color = texture2D(uSampler, vTextureCoord) * vColor;\n    gl_FragColor = color;\n}";
var vertex$3 = "attribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\nattribute vec4 aColor;\n\nattribute vec2 aPositionCoord;\nattribute float aRotation;\n\nuniform mat3 translationMatrix;\nuniform vec4 uColor;\n\nvarying vec2 vTextureCoord;\nvarying vec4 vColor;\n\nvoid main(void){\n    float x = (aVertexPosition.x) * cos(aRotation) - (aVertexPosition.y) * sin(aRotation);\n    float y = (aVertexPosition.x) * sin(aRotation) + (aVertexPosition.y) * cos(aRotation);\n\n    vec2 v = vec2(x, y);\n    v = v + aPositionCoord;\n\n    gl_Position = vec4((translationMatrix * vec3(v, 1.0)).xy, 0.0, 1.0);\n\n    vTextureCoord = aTextureCoord;\n    vColor = aColor * uColor;\n}\n";
var ParticleRenderer = function(_super) {
  __extends$m(ParticleRenderer2, _super);
  function ParticleRenderer2(renderer) {
    var _this = _super.call(this, renderer) || this;
    _this.shader = null;
    _this.properties = null;
    _this.tempMatrix = new Matrix();
    _this.properties = [
      {
        attributeName: "aVertexPosition",
        size: 2,
        uploadFunction: _this.uploadVertices,
        offset: 0
      },
      {
        attributeName: "aPositionCoord",
        size: 2,
        uploadFunction: _this.uploadPosition,
        offset: 0
      },
      {
        attributeName: "aRotation",
        size: 1,
        uploadFunction: _this.uploadRotation,
        offset: 0
      },
      {
        attributeName: "aTextureCoord",
        size: 2,
        uploadFunction: _this.uploadUvs,
        offset: 0
      },
      {
        attributeName: "aColor",
        size: 1,
        type: TYPES$3.UNSIGNED_BYTE,
        uploadFunction: _this.uploadTint,
        offset: 0
      }
    ];
    _this.shader = Shader.from(vertex$3, fragment$6, {});
    _this.state = State.for2d();
    return _this;
  }
  ParticleRenderer2.prototype.render = function(container) {
    var children = container.children;
    var maxSize = container._maxSize;
    var batchSize = container._batchSize;
    var renderer = this.renderer;
    var totalChildren = children.length;
    if (totalChildren === 0) {
      return;
    } else if (totalChildren > maxSize && !container.autoResize) {
      totalChildren = maxSize;
    }
    var buffers = container._buffers;
    if (!buffers) {
      buffers = container._buffers = this.generateBuffers(container);
    }
    var baseTexture = children[0]._texture.baseTexture;
    this.state.blendMode = correctBlendMode(container.blendMode, baseTexture.alphaMode);
    renderer.state.set(this.state);
    var gl = renderer.gl;
    var m2 = container.worldTransform.copyTo(this.tempMatrix);
    m2.prepend(renderer.globalUniforms.uniforms.projectionMatrix);
    this.shader.uniforms.translationMatrix = m2.toArray(true);
    this.shader.uniforms.uColor = premultiplyRgba(container.tintRgb, container.worldAlpha, this.shader.uniforms.uColor, baseTexture.alphaMode);
    this.shader.uniforms.uSampler = baseTexture;
    this.renderer.shader.bind(this.shader);
    var updateStatic = false;
    for (var i2 = 0, j2 = 0; i2 < totalChildren; i2 += batchSize, j2 += 1) {
      var amount = totalChildren - i2;
      if (amount > batchSize) {
        amount = batchSize;
      }
      if (j2 >= buffers.length) {
        buffers.push(this._generateOneMoreBuffer(container));
      }
      var buffer = buffers[j2];
      buffer.uploadDynamic(children, i2, amount);
      var bid = container._bufferUpdateIDs[j2] || 0;
      updateStatic = updateStatic || buffer._updateID < bid;
      if (updateStatic) {
        buffer._updateID = container._updateID;
        buffer.uploadStatic(children, i2, amount);
      }
      renderer.geometry.bind(buffer.geometry);
      gl.drawElements(gl.TRIANGLES, amount * 6, gl.UNSIGNED_SHORT, 0);
    }
  };
  ParticleRenderer2.prototype.generateBuffers = function(container) {
    var buffers = [];
    var size = container._maxSize;
    var batchSize = container._batchSize;
    var dynamicPropertyFlags = container._properties;
    for (var i2 = 0; i2 < size; i2 += batchSize) {
      buffers.push(new ParticleBuffer(this.properties, dynamicPropertyFlags, batchSize));
    }
    return buffers;
  };
  ParticleRenderer2.prototype._generateOneMoreBuffer = function(container) {
    var batchSize = container._batchSize;
    var dynamicPropertyFlags = container._properties;
    return new ParticleBuffer(this.properties, dynamicPropertyFlags, batchSize);
  };
  ParticleRenderer2.prototype.uploadVertices = function(children, startIndex, amount, array, stride, offset) {
    var w0 = 0;
    var w1 = 0;
    var h0 = 0;
    var h1 = 0;
    for (var i2 = 0; i2 < amount; ++i2) {
      var sprite = children[startIndex + i2];
      var texture = sprite._texture;
      var sx = sprite.scale.x;
      var sy = sprite.scale.y;
      var trim2 = texture.trim;
      var orig = texture.orig;
      if (trim2) {
        w1 = trim2.x - sprite.anchor.x * orig.width;
        w0 = w1 + trim2.width;
        h1 = trim2.y - sprite.anchor.y * orig.height;
        h0 = h1 + trim2.height;
      } else {
        w0 = orig.width * (1 - sprite.anchor.x);
        w1 = orig.width * -sprite.anchor.x;
        h0 = orig.height * (1 - sprite.anchor.y);
        h1 = orig.height * -sprite.anchor.y;
      }
      array[offset] = w1 * sx;
      array[offset + 1] = h1 * sy;
      array[offset + stride] = w0 * sx;
      array[offset + stride + 1] = h1 * sy;
      array[offset + stride * 2] = w0 * sx;
      array[offset + stride * 2 + 1] = h0 * sy;
      array[offset + stride * 3] = w1 * sx;
      array[offset + stride * 3 + 1] = h0 * sy;
      offset += stride * 4;
    }
  };
  ParticleRenderer2.prototype.uploadPosition = function(children, startIndex, amount, array, stride, offset) {
    for (var i2 = 0; i2 < amount; i2++) {
      var spritePosition = children[startIndex + i2].position;
      array[offset] = spritePosition.x;
      array[offset + 1] = spritePosition.y;
      array[offset + stride] = spritePosition.x;
      array[offset + stride + 1] = spritePosition.y;
      array[offset + stride * 2] = spritePosition.x;
      array[offset + stride * 2 + 1] = spritePosition.y;
      array[offset + stride * 3] = spritePosition.x;
      array[offset + stride * 3 + 1] = spritePosition.y;
      offset += stride * 4;
    }
  };
  ParticleRenderer2.prototype.uploadRotation = function(children, startIndex, amount, array, stride, offset) {
    for (var i2 = 0; i2 < amount; i2++) {
      var spriteRotation = children[startIndex + i2].rotation;
      array[offset] = spriteRotation;
      array[offset + stride] = spriteRotation;
      array[offset + stride * 2] = spriteRotation;
      array[offset + stride * 3] = spriteRotation;
      offset += stride * 4;
    }
  };
  ParticleRenderer2.prototype.uploadUvs = function(children, startIndex, amount, array, stride, offset) {
    for (var i2 = 0; i2 < amount; ++i2) {
      var textureUvs = children[startIndex + i2]._texture._uvs;
      if (textureUvs) {
        array[offset] = textureUvs.x0;
        array[offset + 1] = textureUvs.y0;
        array[offset + stride] = textureUvs.x1;
        array[offset + stride + 1] = textureUvs.y1;
        array[offset + stride * 2] = textureUvs.x2;
        array[offset + stride * 2 + 1] = textureUvs.y2;
        array[offset + stride * 3] = textureUvs.x3;
        array[offset + stride * 3 + 1] = textureUvs.y3;
        offset += stride * 4;
      } else {
        array[offset] = 0;
        array[offset + 1] = 0;
        array[offset + stride] = 0;
        array[offset + stride + 1] = 0;
        array[offset + stride * 2] = 0;
        array[offset + stride * 2 + 1] = 0;
        array[offset + stride * 3] = 0;
        array[offset + stride * 3 + 1] = 0;
        offset += stride * 4;
      }
    }
  };
  ParticleRenderer2.prototype.uploadTint = function(children, startIndex, amount, array, stride, offset) {
    for (var i2 = 0; i2 < amount; ++i2) {
      var sprite = children[startIndex + i2];
      var premultiplied = sprite._texture.baseTexture.alphaMode > 0;
      var alpha = sprite.alpha;
      var argb = alpha < 1 && premultiplied ? premultiplyTint(sprite._tintRGB, alpha) : sprite._tintRGB + (alpha * 255 << 24);
      array[offset] = argb;
      array[offset + stride] = argb;
      array[offset + stride * 2] = argb;
      array[offset + stride * 3] = argb;
      offset += stride * 4;
    }
  };
  ParticleRenderer2.prototype.destroy = function() {
    _super.prototype.destroy.call(this);
    if (this.shader) {
      this.shader.destroy();
      this.shader = null;
    }
    this.tempMatrix = null;
  };
  return ParticleRenderer2;
}(ObjectRenderer);
/*!
 * @pixi/graphics - v6.3.0
 * Compiled Wed, 23 Mar 2022 18:58:56 UTC
 *
 * @pixi/graphics is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
var LINE_JOIN;
(function(LINE_JOIN2) {
  LINE_JOIN2["MITER"] = "miter";
  LINE_JOIN2["BEVEL"] = "bevel";
  LINE_JOIN2["ROUND"] = "round";
})(LINE_JOIN || (LINE_JOIN = {}));
var LINE_CAP;
(function(LINE_CAP2) {
  LINE_CAP2["BUTT"] = "butt";
  LINE_CAP2["ROUND"] = "round";
  LINE_CAP2["SQUARE"] = "square";
})(LINE_CAP || (LINE_CAP = {}));
var GRAPHICS_CURVES = {
  adaptive: true,
  maxLength: 10,
  minSegments: 8,
  maxSegments: 2048,
  epsilon: 1e-4,
  _segmentsCount: function(length2, defaultSegments) {
    if (defaultSegments === void 0) {
      defaultSegments = 20;
    }
    if (!this.adaptive || !length2 || isNaN(length2)) {
      return defaultSegments;
    }
    var result = Math.ceil(length2 / this.maxLength);
    if (result < this.minSegments) {
      result = this.minSegments;
    } else if (result > this.maxSegments) {
      result = this.maxSegments;
    }
    return result;
  }
};
var FillStyle = function() {
  function FillStyle2() {
    this.color = 16777215;
    this.alpha = 1;
    this.texture = Texture.WHITE;
    this.matrix = null;
    this.visible = false;
    this.reset();
  }
  FillStyle2.prototype.clone = function() {
    var obj = new FillStyle2();
    obj.color = this.color;
    obj.alpha = this.alpha;
    obj.texture = this.texture;
    obj.matrix = this.matrix;
    obj.visible = this.visible;
    return obj;
  };
  FillStyle2.prototype.reset = function() {
    this.color = 16777215;
    this.alpha = 1;
    this.texture = Texture.WHITE;
    this.matrix = null;
    this.visible = false;
  };
  FillStyle2.prototype.destroy = function() {
    this.texture = null;
    this.matrix = null;
  };
  return FillStyle2;
}();
/*! *****************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */
var extendStatics$l = function(d2, b2) {
  extendStatics$l = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {
    d3.__proto__ = b3;
  } || function(d3, b3) {
    for (var p2 in b3) {
      if (b3.hasOwnProperty(p2)) {
        d3[p2] = b3[p2];
      }
    }
  };
  return extendStatics$l(d2, b2);
};
function __extends$l(d2, b2) {
  extendStatics$l(d2, b2);
  function __() {
    this.constructor = d2;
  }
  d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
}
function fixOrientation(points, hole) {
  var _a3, _b3;
  if (hole === void 0) {
    hole = false;
  }
  var m2 = points.length;
  if (m2 < 6) {
    return;
  }
  var area2 = 0;
  for (var i2 = 0, x1 = points[m2 - 2], y1 = points[m2 - 1]; i2 < m2; i2 += 2) {
    var x2 = points[i2];
    var y2 = points[i2 + 1];
    area2 += (x2 - x1) * (y2 + y1);
    x1 = x2;
    y1 = y2;
  }
  if (!hole && area2 > 0 || hole && area2 <= 0) {
    var n = m2 / 2;
    for (var i2 = n + n % 2; i2 < m2; i2 += 2) {
      var i1 = m2 - i2 - 2;
      var i22 = m2 - i2 - 1;
      var i3 = i2;
      var i4 = i2 + 1;
      _a3 = [points[i3], points[i1]], points[i1] = _a3[0], points[i3] = _a3[1];
      _b3 = [points[i4], points[i22]], points[i22] = _b3[0], points[i4] = _b3[1];
    }
  }
}
var buildPoly = {
  build: function(graphicsData) {
    graphicsData.points = graphicsData.shape.points.slice();
  },
  triangulate: function(graphicsData, graphicsGeometry) {
    var points = graphicsData.points;
    var holes = graphicsData.holes;
    var verts = graphicsGeometry.points;
    var indices2 = graphicsGeometry.indices;
    if (points.length >= 6) {
      fixOrientation(points, false);
      var holeArray = [];
      for (var i2 = 0; i2 < holes.length; i2++) {
        var hole = holes[i2];
        fixOrientation(hole.points, true);
        holeArray.push(points.length / 2);
        points = points.concat(hole.points);
      }
      var triangles = earcut$1(points, holeArray, 2);
      if (!triangles) {
        return;
      }
      var vertPos = verts.length / 2;
      for (var i2 = 0; i2 < triangles.length; i2 += 3) {
        indices2.push(triangles[i2] + vertPos);
        indices2.push(triangles[i2 + 1] + vertPos);
        indices2.push(triangles[i2 + 2] + vertPos);
      }
      for (var i2 = 0; i2 < points.length; i2++) {
        verts.push(points[i2]);
      }
    }
  }
};
var buildCircle = {
  build: function(graphicsData) {
    var points = graphicsData.points;
    var x2;
    var y2;
    var dx;
    var dy;
    var rx;
    var ry;
    if (graphicsData.type === SHAPES.CIRC) {
      var circle = graphicsData.shape;
      x2 = circle.x;
      y2 = circle.y;
      rx = ry = circle.radius;
      dx = dy = 0;
    } else if (graphicsData.type === SHAPES.ELIP) {
      var ellipse = graphicsData.shape;
      x2 = ellipse.x;
      y2 = ellipse.y;
      rx = ellipse.width;
      ry = ellipse.height;
      dx = dy = 0;
    } else {
      var roundedRect = graphicsData.shape;
      var halfWidth = roundedRect.width / 2;
      var halfHeight = roundedRect.height / 2;
      x2 = roundedRect.x + halfWidth;
      y2 = roundedRect.y + halfHeight;
      rx = ry = Math.max(0, Math.min(roundedRect.radius, Math.min(halfWidth, halfHeight)));
      dx = halfWidth - rx;
      dy = halfHeight - ry;
    }
    var n = Math.ceil(2.3 * Math.sqrt(rx + ry));
    var m2 = n * 8 + (dx ? 4 : 0) + (dy ? 4 : 0);
    points.length = m2;
    if (m2 === 0) {
      return;
    }
    if (n === 0) {
      points.length = 8;
      points[0] = points[6] = x2 + dx;
      points[1] = points[3] = y2 + dy;
      points[2] = points[4] = x2 - dx;
      points[5] = points[7] = y2 - dy;
      return;
    }
    var j1 = 0;
    var j2 = n * 4 + (dx ? 2 : 0) + 2;
    var j3 = j2;
    var j4 = m2;
    {
      var x0 = dx + rx;
      var y0 = dy;
      var x1 = x2 + x0;
      var x22 = x2 - x0;
      var y1 = y2 + y0;
      points[j1++] = x1;
      points[j1++] = y1;
      points[--j2] = y1;
      points[--j2] = x22;
      if (dy) {
        var y22 = y2 - y0;
        points[j3++] = x22;
        points[j3++] = y22;
        points[--j4] = y22;
        points[--j4] = x1;
      }
    }
    for (var i2 = 1; i2 < n; i2++) {
      var a2 = Math.PI / 2 * (i2 / n);
      var x0 = dx + Math.cos(a2) * rx;
      var y0 = dy + Math.sin(a2) * ry;
      var x1 = x2 + x0;
      var x22 = x2 - x0;
      var y1 = y2 + y0;
      var y22 = y2 - y0;
      points[j1++] = x1;
      points[j1++] = y1;
      points[--j2] = y1;
      points[--j2] = x22;
      points[j3++] = x22;
      points[j3++] = y22;
      points[--j4] = y22;
      points[--j4] = x1;
    }
    {
      var x0 = dx;
      var y0 = dy + ry;
      var x1 = x2 + x0;
      var x22 = x2 - x0;
      var y1 = y2 + y0;
      var y22 = y2 - y0;
      points[j1++] = x1;
      points[j1++] = y1;
      points[--j4] = y22;
      points[--j4] = x1;
      if (dx) {
        points[j1++] = x22;
        points[j1++] = y1;
        points[--j4] = y22;
        points[--j4] = x22;
      }
    }
  },
  triangulate: function(graphicsData, graphicsGeometry) {
    var points = graphicsData.points;
    var verts = graphicsGeometry.points;
    var indices2 = graphicsGeometry.indices;
    var vertPos = verts.length / 2;
    var center = vertPos;
    var x2;
    var y2;
    if (graphicsData.type !== SHAPES.RREC) {
      var circle = graphicsData.shape;
      x2 = circle.x;
      y2 = circle.y;
    } else {
      var roundedRect = graphicsData.shape;
      x2 = roundedRect.x + roundedRect.width / 2;
      y2 = roundedRect.y + roundedRect.height / 2;
    }
    var matrix = graphicsData.matrix;
    verts.push(graphicsData.matrix ? matrix.a * x2 + matrix.c * y2 + matrix.tx : x2, graphicsData.matrix ? matrix.b * x2 + matrix.d * y2 + matrix.ty : y2);
    vertPos++;
    verts.push(points[0], points[1]);
    for (var i2 = 2; i2 < points.length; i2 += 2) {
      verts.push(points[i2], points[i2 + 1]);
      indices2.push(vertPos++, center, vertPos);
    }
    indices2.push(center + 1, center, vertPos);
  }
};
var buildRectangle = {
  build: function(graphicsData) {
    var rectData = graphicsData.shape;
    var x2 = rectData.x;
    var y2 = rectData.y;
    var width = rectData.width;
    var height = rectData.height;
    var points = graphicsData.points;
    points.length = 0;
    points.push(x2, y2, x2 + width, y2, x2 + width, y2 + height, x2, y2 + height);
  },
  triangulate: function(graphicsData, graphicsGeometry) {
    var points = graphicsData.points;
    var verts = graphicsGeometry.points;
    var vertPos = verts.length / 2;
    verts.push(points[0], points[1], points[2], points[3], points[6], points[7], points[4], points[5]);
    graphicsGeometry.indices.push(vertPos, vertPos + 1, vertPos + 2, vertPos + 1, vertPos + 2, vertPos + 3);
  }
};
function getPt(n1, n2, perc) {
  var diff2 = n2 - n1;
  return n1 + diff2 * perc;
}
function quadraticBezierCurve(fromX, fromY, cpX, cpY, toX, toY, out) {
  if (out === void 0) {
    out = [];
  }
  var n = 20;
  var points = out;
  var xa = 0;
  var ya = 0;
  var xb = 0;
  var yb = 0;
  var x2 = 0;
  var y2 = 0;
  for (var i2 = 0, j2 = 0; i2 <= n; ++i2) {
    j2 = i2 / n;
    xa = getPt(fromX, cpX, j2);
    ya = getPt(fromY, cpY, j2);
    xb = getPt(cpX, toX, j2);
    yb = getPt(cpY, toY, j2);
    x2 = getPt(xa, xb, j2);
    y2 = getPt(ya, yb, j2);
    if (i2 === 0 && points[points.length - 2] === x2 && points[points.length - 1] === y2) {
      continue;
    }
    points.push(x2, y2);
  }
  return points;
}
var buildRoundedRectangle = {
  build: function(graphicsData) {
    if (Graphics.nextRoundedRectBehavior) {
      buildCircle.build(graphicsData);
      return;
    }
    var rrectData = graphicsData.shape;
    var points = graphicsData.points;
    var x2 = rrectData.x;
    var y2 = rrectData.y;
    var width = rrectData.width;
    var height = rrectData.height;
    var radius = Math.max(0, Math.min(rrectData.radius, Math.min(width, height) / 2));
    points.length = 0;
    if (!radius) {
      points.push(x2, y2, x2 + width, y2, x2 + width, y2 + height, x2, y2 + height);
    } else {
      quadraticBezierCurve(x2, y2 + radius, x2, y2, x2 + radius, y2, points);
      quadraticBezierCurve(x2 + width - radius, y2, x2 + width, y2, x2 + width, y2 + radius, points);
      quadraticBezierCurve(x2 + width, y2 + height - radius, x2 + width, y2 + height, x2 + width - radius, y2 + height, points);
      quadraticBezierCurve(x2 + radius, y2 + height, x2, y2 + height, x2, y2 + height - radius, points);
    }
  },
  triangulate: function(graphicsData, graphicsGeometry) {
    if (Graphics.nextRoundedRectBehavior) {
      buildCircle.triangulate(graphicsData, graphicsGeometry);
      return;
    }
    var points = graphicsData.points;
    var verts = graphicsGeometry.points;
    var indices2 = graphicsGeometry.indices;
    var vecPos = verts.length / 2;
    var triangles = earcut$1(points, null, 2);
    for (var i2 = 0, j2 = triangles.length; i2 < j2; i2 += 3) {
      indices2.push(triangles[i2] + vecPos);
      indices2.push(triangles[i2 + 1] + vecPos);
      indices2.push(triangles[i2 + 2] + vecPos);
    }
    for (var i2 = 0, j2 = points.length; i2 < j2; i2++) {
      verts.push(points[i2], points[++i2]);
    }
  }
};
function square(x2, y2, nx, ny, innerWeight, outerWeight, clockwise, verts) {
  var ix = x2 - nx * innerWeight;
  var iy = y2 - ny * innerWeight;
  var ox = x2 + nx * outerWeight;
  var oy = y2 + ny * outerWeight;
  var exx;
  var eyy;
  if (clockwise) {
    exx = ny;
    eyy = -nx;
  } else {
    exx = -ny;
    eyy = nx;
  }
  var eix = ix + exx;
  var eiy = iy + eyy;
  var eox = ox + exx;
  var eoy = oy + eyy;
  verts.push(eix, eiy);
  verts.push(eox, eoy);
  return 2;
}
function round(cx, cy, sx, sy, ex, ey, verts, clockwise) {
  var cx2p0x = sx - cx;
  var cy2p0y = sy - cy;
  var angle0 = Math.atan2(cx2p0x, cy2p0y);
  var angle1 = Math.atan2(ex - cx, ey - cy);
  if (clockwise && angle0 < angle1) {
    angle0 += Math.PI * 2;
  } else if (!clockwise && angle0 > angle1) {
    angle1 += Math.PI * 2;
  }
  var startAngle = angle0;
  var angleDiff = angle1 - angle0;
  var absAngleDiff = Math.abs(angleDiff);
  var radius = Math.sqrt(cx2p0x * cx2p0x + cy2p0y * cy2p0y);
  var segCount = (15 * absAngleDiff * Math.sqrt(radius) / Math.PI >> 0) + 1;
  var angleInc = angleDiff / segCount;
  startAngle += angleInc;
  if (clockwise) {
    verts.push(cx, cy);
    verts.push(sx, sy);
    for (var i2 = 1, angle = startAngle; i2 < segCount; i2++, angle += angleInc) {
      verts.push(cx, cy);
      verts.push(cx + Math.sin(angle) * radius, cy + Math.cos(angle) * radius);
    }
    verts.push(cx, cy);
    verts.push(ex, ey);
  } else {
    verts.push(sx, sy);
    verts.push(cx, cy);
    for (var i2 = 1, angle = startAngle; i2 < segCount; i2++, angle += angleInc) {
      verts.push(cx + Math.sin(angle) * radius, cy + Math.cos(angle) * radius);
      verts.push(cx, cy);
    }
    verts.push(ex, ey);
    verts.push(cx, cy);
  }
  return segCount * 2;
}
function buildNonNativeLine(graphicsData, graphicsGeometry) {
  var shape = graphicsData.shape;
  var points = graphicsData.points || shape.points.slice();
  var eps = graphicsGeometry.closePointEps;
  if (points.length === 0) {
    return;
  }
  var style = graphicsData.lineStyle;
  var firstPoint = new Point(points[0], points[1]);
  var lastPoint = new Point(points[points.length - 2], points[points.length - 1]);
  var closedShape = shape.type !== SHAPES.POLY || shape.closeStroke;
  var closedPath = Math.abs(firstPoint.x - lastPoint.x) < eps && Math.abs(firstPoint.y - lastPoint.y) < eps;
  if (closedShape) {
    points = points.slice();
    if (closedPath) {
      points.pop();
      points.pop();
      lastPoint.set(points[points.length - 2], points[points.length - 1]);
    }
    var midPointX = (firstPoint.x + lastPoint.x) * 0.5;
    var midPointY = (lastPoint.y + firstPoint.y) * 0.5;
    points.unshift(midPointX, midPointY);
    points.push(midPointX, midPointY);
  }
  var verts = graphicsGeometry.points;
  var length2 = points.length / 2;
  var indexCount = points.length;
  var indexStart = verts.length / 2;
  var width = style.width / 2;
  var widthSquared = width * width;
  var miterLimitSquared = style.miterLimit * style.miterLimit;
  var x0 = points[0];
  var y0 = points[1];
  var x1 = points[2];
  var y1 = points[3];
  var x2 = 0;
  var y2 = 0;
  var perpx = -(y0 - y1);
  var perpy = x0 - x1;
  var perp1x = 0;
  var perp1y = 0;
  var dist = Math.sqrt(perpx * perpx + perpy * perpy);
  perpx /= dist;
  perpy /= dist;
  perpx *= width;
  perpy *= width;
  var ratio = style.alignment;
  var innerWeight = (1 - ratio) * 2;
  var outerWeight = ratio * 2;
  if (!closedShape) {
    if (style.cap === LINE_CAP.ROUND) {
      indexCount += round(x0 - perpx * (innerWeight - outerWeight) * 0.5, y0 - perpy * (innerWeight - outerWeight) * 0.5, x0 - perpx * innerWeight, y0 - perpy * innerWeight, x0 + perpx * outerWeight, y0 + perpy * outerWeight, verts, true) + 2;
    } else if (style.cap === LINE_CAP.SQUARE) {
      indexCount += square(x0, y0, perpx, perpy, innerWeight, outerWeight, true, verts);
    }
  }
  verts.push(x0 - perpx * innerWeight, y0 - perpy * innerWeight);
  verts.push(x0 + perpx * outerWeight, y0 + perpy * outerWeight);
  for (var i2 = 1; i2 < length2 - 1; ++i2) {
    x0 = points[(i2 - 1) * 2];
    y0 = points[(i2 - 1) * 2 + 1];
    x1 = points[i2 * 2];
    y1 = points[i2 * 2 + 1];
    x2 = points[(i2 + 1) * 2];
    y2 = points[(i2 + 1) * 2 + 1];
    perpx = -(y0 - y1);
    perpy = x0 - x1;
    dist = Math.sqrt(perpx * perpx + perpy * perpy);
    perpx /= dist;
    perpy /= dist;
    perpx *= width;
    perpy *= width;
    perp1x = -(y1 - y2);
    perp1y = x1 - x2;
    dist = Math.sqrt(perp1x * perp1x + perp1y * perp1y);
    perp1x /= dist;
    perp1y /= dist;
    perp1x *= width;
    perp1y *= width;
    var dx0 = x1 - x0;
    var dy0 = y0 - y1;
    var dx1 = x1 - x2;
    var dy1 = y2 - y1;
    var cross = dy0 * dx1 - dy1 * dx0;
    var clockwise = cross < 0;
    if (Math.abs(cross) < 0.1) {
      verts.push(x1 - perpx * innerWeight, y1 - perpy * innerWeight);
      verts.push(x1 + perpx * outerWeight, y1 + perpy * outerWeight);
      continue;
    }
    var c1 = (-perpx + x0) * (-perpy + y1) - (-perpx + x1) * (-perpy + y0);
    var c2 = (-perp1x + x2) * (-perp1y + y1) - (-perp1x + x1) * (-perp1y + y2);
    var px = (dx0 * c2 - dx1 * c1) / cross;
    var py = (dy1 * c1 - dy0 * c2) / cross;
    var pdist = (px - x1) * (px - x1) + (py - y1) * (py - y1);
    var imx = x1 + (px - x1) * innerWeight;
    var imy = y1 + (py - y1) * innerWeight;
    var omx = x1 - (px - x1) * outerWeight;
    var omy = y1 - (py - y1) * outerWeight;
    var smallerInsideSegmentSq = Math.min(dx0 * dx0 + dy0 * dy0, dx1 * dx1 + dy1 * dy1);
    var insideWeight = clockwise ? innerWeight : outerWeight;
    var smallerInsideDiagonalSq = smallerInsideSegmentSq + insideWeight * insideWeight * widthSquared;
    var insideMiterOk = pdist <= smallerInsideDiagonalSq;
    if (insideMiterOk) {
      if (style.join === LINE_JOIN.BEVEL || pdist / widthSquared > miterLimitSquared) {
        if (clockwise) {
          verts.push(imx, imy);
          verts.push(x1 + perpx * outerWeight, y1 + perpy * outerWeight);
          verts.push(imx, imy);
          verts.push(x1 + perp1x * outerWeight, y1 + perp1y * outerWeight);
        } else {
          verts.push(x1 - perpx * innerWeight, y1 - perpy * innerWeight);
          verts.push(omx, omy);
          verts.push(x1 - perp1x * innerWeight, y1 - perp1y * innerWeight);
          verts.push(omx, omy);
        }
        indexCount += 2;
      } else if (style.join === LINE_JOIN.ROUND) {
        if (clockwise) {
          verts.push(imx, imy);
          verts.push(x1 + perpx * outerWeight, y1 + perpy * outerWeight);
          indexCount += round(x1, y1, x1 + perpx * outerWeight, y1 + perpy * outerWeight, x1 + perp1x * outerWeight, y1 + perp1y * outerWeight, verts, true) + 4;
          verts.push(imx, imy);
          verts.push(x1 + perp1x * outerWeight, y1 + perp1y * outerWeight);
        } else {
          verts.push(x1 - perpx * innerWeight, y1 - perpy * innerWeight);
          verts.push(omx, omy);
          indexCount += round(x1, y1, x1 - perpx * innerWeight, y1 - perpy * innerWeight, x1 - perp1x * innerWeight, y1 - perp1y * innerWeight, verts, false) + 4;
          verts.push(x1 - perp1x * innerWeight, y1 - perp1y * innerWeight);
          verts.push(omx, omy);
        }
      } else {
        verts.push(imx, imy);
        verts.push(omx, omy);
      }
    } else {
      verts.push(x1 - perpx * innerWeight, y1 - perpy * innerWeight);
      verts.push(x1 + perpx * outerWeight, y1 + perpy * outerWeight);
      if (style.join === LINE_JOIN.BEVEL || pdist / widthSquared > miterLimitSquared)
        ;
      else if (style.join === LINE_JOIN.ROUND) {
        if (clockwise) {
          indexCount += round(x1, y1, x1 + perpx * outerWeight, y1 + perpy * outerWeight, x1 + perp1x * outerWeight, y1 + perp1y * outerWeight, verts, true) + 2;
        } else {
          indexCount += round(x1, y1, x1 - perpx * innerWeight, y1 - perpy * innerWeight, x1 - perp1x * innerWeight, y1 - perp1y * innerWeight, verts, false) + 2;
        }
      } else {
        if (clockwise) {
          verts.push(omx, omy);
          verts.push(omx, omy);
        } else {
          verts.push(imx, imy);
          verts.push(imx, imy);
        }
        indexCount += 2;
      }
      verts.push(x1 - perp1x * innerWeight, y1 - perp1y * innerWeight);
      verts.push(x1 + perp1x * outerWeight, y1 + perp1y * outerWeight);
      indexCount += 2;
    }
  }
  x0 = points[(length2 - 2) * 2];
  y0 = points[(length2 - 2) * 2 + 1];
  x1 = points[(length2 - 1) * 2];
  y1 = points[(length2 - 1) * 2 + 1];
  perpx = -(y0 - y1);
  perpy = x0 - x1;
  dist = Math.sqrt(perpx * perpx + perpy * perpy);
  perpx /= dist;
  perpy /= dist;
  perpx *= width;
  perpy *= width;
  verts.push(x1 - perpx * innerWeight, y1 - perpy * innerWeight);
  verts.push(x1 + perpx * outerWeight, y1 + perpy * outerWeight);
  if (!closedShape) {
    if (style.cap === LINE_CAP.ROUND) {
      indexCount += round(x1 - perpx * (innerWeight - outerWeight) * 0.5, y1 - perpy * (innerWeight - outerWeight) * 0.5, x1 - perpx * innerWeight, y1 - perpy * innerWeight, x1 + perpx * outerWeight, y1 + perpy * outerWeight, verts, false) + 2;
    } else if (style.cap === LINE_CAP.SQUARE) {
      indexCount += square(x1, y1, perpx, perpy, innerWeight, outerWeight, false, verts);
    }
  }
  var indices2 = graphicsGeometry.indices;
  var eps2 = GRAPHICS_CURVES.epsilon * GRAPHICS_CURVES.epsilon;
  for (var i2 = indexStart; i2 < indexCount + indexStart - 2; ++i2) {
    x0 = verts[i2 * 2];
    y0 = verts[i2 * 2 + 1];
    x1 = verts[(i2 + 1) * 2];
    y1 = verts[(i2 + 1) * 2 + 1];
    x2 = verts[(i2 + 2) * 2];
    y2 = verts[(i2 + 2) * 2 + 1];
    if (Math.abs(x0 * (y1 - y2) + x1 * (y2 - y0) + x2 * (y0 - y1)) < eps2) {
      continue;
    }
    indices2.push(i2, i2 + 1, i2 + 2);
  }
}
function buildNativeLine(graphicsData, graphicsGeometry) {
  var i2 = 0;
  var shape = graphicsData.shape;
  var points = graphicsData.points || shape.points;
  var closedShape = shape.type !== SHAPES.POLY || shape.closeStroke;
  if (points.length === 0) {
    return;
  }
  var verts = graphicsGeometry.points;
  var indices2 = graphicsGeometry.indices;
  var length2 = points.length / 2;
  var startIndex = verts.length / 2;
  var currentIndex = startIndex;
  verts.push(points[0], points[1]);
  for (i2 = 1; i2 < length2; i2++) {
    verts.push(points[i2 * 2], points[i2 * 2 + 1]);
    indices2.push(currentIndex, currentIndex + 1);
    currentIndex++;
  }
  if (closedShape) {
    indices2.push(currentIndex, startIndex);
  }
}
function buildLine(graphicsData, graphicsGeometry) {
  if (graphicsData.lineStyle.native) {
    buildNativeLine(graphicsData, graphicsGeometry);
  } else {
    buildNonNativeLine(graphicsData, graphicsGeometry);
  }
}
var ArcUtils = function() {
  function ArcUtils2() {
  }
  ArcUtils2.curveTo = function(x1, y1, x2, y2, radius, points) {
    var fromX = points[points.length - 2];
    var fromY = points[points.length - 1];
    var a1 = fromY - y1;
    var b1 = fromX - x1;
    var a2 = y2 - y1;
    var b2 = x2 - x1;
    var mm = Math.abs(a1 * b2 - b1 * a2);
    if (mm < 1e-8 || radius === 0) {
      if (points[points.length - 2] !== x1 || points[points.length - 1] !== y1) {
        points.push(x1, y1);
      }
      return null;
    }
    var dd = a1 * a1 + b1 * b1;
    var cc = a2 * a2 + b2 * b2;
    var tt = a1 * a2 + b1 * b2;
    var k1 = radius * Math.sqrt(dd) / mm;
    var k2 = radius * Math.sqrt(cc) / mm;
    var j1 = k1 * tt / dd;
    var j2 = k2 * tt / cc;
    var cx = k1 * b2 + k2 * b1;
    var cy = k1 * a2 + k2 * a1;
    var px = b1 * (k2 + j1);
    var py = a1 * (k2 + j1);
    var qx = b2 * (k1 + j2);
    var qy = a2 * (k1 + j2);
    var startAngle = Math.atan2(py - cy, px - cx);
    var endAngle = Math.atan2(qy - cy, qx - cx);
    return {
      cx: cx + x1,
      cy: cy + y1,
      radius,
      startAngle,
      endAngle,
      anticlockwise: b1 * a2 > b2 * a1
    };
  };
  ArcUtils2.arc = function(_startX, _startY, cx, cy, radius, startAngle, endAngle, _anticlockwise, points) {
    var sweep = endAngle - startAngle;
    var n = GRAPHICS_CURVES._segmentsCount(Math.abs(sweep) * radius, Math.ceil(Math.abs(sweep) / PI_2) * 40);
    var theta = sweep / (n * 2);
    var theta2 = theta * 2;
    var cTheta = Math.cos(theta);
    var sTheta = Math.sin(theta);
    var segMinus = n - 1;
    var remainder = segMinus % 1 / segMinus;
    for (var i2 = 0; i2 <= segMinus; ++i2) {
      var real = i2 + remainder * i2;
      var angle = theta + startAngle + theta2 * real;
      var c2 = Math.cos(angle);
      var s2 = -Math.sin(angle);
      points.push((cTheta * c2 + sTheta * s2) * radius + cx, (cTheta * -s2 + sTheta * c2) * radius + cy);
    }
  };
  return ArcUtils2;
}();
var BezierUtils = function() {
  function BezierUtils2() {
  }
  BezierUtils2.curveLength = function(fromX, fromY, cpX, cpY, cpX2, cpY2, toX, toY) {
    var n = 10;
    var result = 0;
    var t = 0;
    var t2 = 0;
    var t3 = 0;
    var nt = 0;
    var nt2 = 0;
    var nt3 = 0;
    var x2 = 0;
    var y2 = 0;
    var dx = 0;
    var dy = 0;
    var prevX = fromX;
    var prevY = fromY;
    for (var i2 = 1; i2 <= n; ++i2) {
      t = i2 / n;
      t2 = t * t;
      t3 = t2 * t;
      nt = 1 - t;
      nt2 = nt * nt;
      nt3 = nt2 * nt;
      x2 = nt3 * fromX + 3 * nt2 * t * cpX + 3 * nt * t2 * cpX2 + t3 * toX;
      y2 = nt3 * fromY + 3 * nt2 * t * cpY + 3 * nt * t2 * cpY2 + t3 * toY;
      dx = prevX - x2;
      dy = prevY - y2;
      prevX = x2;
      prevY = y2;
      result += Math.sqrt(dx * dx + dy * dy);
    }
    return result;
  };
  BezierUtils2.curveTo = function(cpX, cpY, cpX2, cpY2, toX, toY, points) {
    var fromX = points[points.length - 2];
    var fromY = points[points.length - 1];
    points.length -= 2;
    var n = GRAPHICS_CURVES._segmentsCount(BezierUtils2.curveLength(fromX, fromY, cpX, cpY, cpX2, cpY2, toX, toY));
    var dt = 0;
    var dt2 = 0;
    var dt3 = 0;
    var t2 = 0;
    var t3 = 0;
    points.push(fromX, fromY);
    for (var i2 = 1, j2 = 0; i2 <= n; ++i2) {
      j2 = i2 / n;
      dt = 1 - j2;
      dt2 = dt * dt;
      dt3 = dt2 * dt;
      t2 = j2 * j2;
      t3 = t2 * j2;
      points.push(dt3 * fromX + 3 * dt2 * j2 * cpX + 3 * dt * t2 * cpX2 + t3 * toX, dt3 * fromY + 3 * dt2 * j2 * cpY + 3 * dt * t2 * cpY2 + t3 * toY);
    }
  };
  return BezierUtils2;
}();
var QuadraticUtils = function() {
  function QuadraticUtils2() {
  }
  QuadraticUtils2.curveLength = function(fromX, fromY, cpX, cpY, toX, toY) {
    var ax = fromX - 2 * cpX + toX;
    var ay = fromY - 2 * cpY + toY;
    var bx = 2 * cpX - 2 * fromX;
    var by = 2 * cpY - 2 * fromY;
    var a2 = 4 * (ax * ax + ay * ay);
    var b2 = 4 * (ax * bx + ay * by);
    var c2 = bx * bx + by * by;
    var s2 = 2 * Math.sqrt(a2 + b2 + c2);
    var a22 = Math.sqrt(a2);
    var a32 = 2 * a2 * a22;
    var c22 = 2 * Math.sqrt(c2);
    var ba = b2 / a22;
    return (a32 * s2 + a22 * b2 * (s2 - c22) + (4 * c2 * a2 - b2 * b2) * Math.log((2 * a22 + ba + s2) / (ba + c22))) / (4 * a32);
  };
  QuadraticUtils2.curveTo = function(cpX, cpY, toX, toY, points) {
    var fromX = points[points.length - 2];
    var fromY = points[points.length - 1];
    var n = GRAPHICS_CURVES._segmentsCount(QuadraticUtils2.curveLength(fromX, fromY, cpX, cpY, toX, toY));
    var xa = 0;
    var ya = 0;
    for (var i2 = 1; i2 <= n; ++i2) {
      var j2 = i2 / n;
      xa = fromX + (cpX - fromX) * j2;
      ya = fromY + (cpY - fromY) * j2;
      points.push(xa + (cpX + (toX - cpX) * j2 - xa) * j2, ya + (cpY + (toY - cpY) * j2 - ya) * j2);
    }
  };
  return QuadraticUtils2;
}();
var BatchPart = function() {
  function BatchPart2() {
    this.reset();
  }
  BatchPart2.prototype.begin = function(style, startIndex, attribStart) {
    this.reset();
    this.style = style;
    this.start = startIndex;
    this.attribStart = attribStart;
  };
  BatchPart2.prototype.end = function(endIndex, endAttrib) {
    this.attribSize = endAttrib - this.attribStart;
    this.size = endIndex - this.start;
  };
  BatchPart2.prototype.reset = function() {
    this.style = null;
    this.size = 0;
    this.start = 0;
    this.attribStart = 0;
    this.attribSize = 0;
  };
  return BatchPart2;
}();
var _a;
var FILL_COMMANDS = (_a = {}, _a[SHAPES.POLY] = buildPoly, _a[SHAPES.CIRC] = buildCircle, _a[SHAPES.ELIP] = buildCircle, _a[SHAPES.RECT] = buildRectangle, _a[SHAPES.RREC] = buildRoundedRectangle, _a);
var BATCH_POOL = [];
var DRAW_CALL_POOL = [];
var GraphicsData = function() {
  function GraphicsData2(shape, fillStyle, lineStyle, matrix) {
    if (fillStyle === void 0) {
      fillStyle = null;
    }
    if (lineStyle === void 0) {
      lineStyle = null;
    }
    if (matrix === void 0) {
      matrix = null;
    }
    this.points = [];
    this.holes = [];
    this.shape = shape;
    this.lineStyle = lineStyle;
    this.fillStyle = fillStyle;
    this.matrix = matrix;
    this.type = shape.type;
  }
  GraphicsData2.prototype.clone = function() {
    return new GraphicsData2(this.shape, this.fillStyle, this.lineStyle, this.matrix);
  };
  GraphicsData2.prototype.destroy = function() {
    this.shape = null;
    this.holes.length = 0;
    this.holes = null;
    this.points.length = 0;
    this.points = null;
    this.lineStyle = null;
    this.fillStyle = null;
  };
  return GraphicsData2;
}();
var tmpPoint = new Point();
var tmpBounds = new Bounds();
var GraphicsGeometry = function(_super) {
  __extends$l(GraphicsGeometry2, _super);
  function GraphicsGeometry2() {
    var _this = _super.call(this) || this;
    _this.closePointEps = 1e-4;
    _this.boundsPadding = 0;
    _this.uvsFloat32 = null;
    _this.indicesUint16 = null;
    _this.batchable = false;
    _this.points = [];
    _this.colors = [];
    _this.uvs = [];
    _this.indices = [];
    _this.textureIds = [];
    _this.graphicsData = [];
    _this.drawCalls = [];
    _this.batchDirty = -1;
    _this.batches = [];
    _this.dirty = 0;
    _this.cacheDirty = -1;
    _this.clearDirty = 0;
    _this.shapeIndex = 0;
    _this._bounds = new Bounds();
    _this.boundsDirty = -1;
    return _this;
  }
  Object.defineProperty(GraphicsGeometry2.prototype, "bounds", {
    get: function() {
      if (this.boundsDirty !== this.dirty) {
        this.boundsDirty = this.dirty;
        this.calculateBounds();
      }
      return this._bounds;
    },
    enumerable: false,
    configurable: true
  });
  GraphicsGeometry2.prototype.invalidate = function() {
    this.boundsDirty = -1;
    this.dirty++;
    this.batchDirty++;
    this.shapeIndex = 0;
    this.points.length = 0;
    this.colors.length = 0;
    this.uvs.length = 0;
    this.indices.length = 0;
    this.textureIds.length = 0;
    for (var i2 = 0; i2 < this.drawCalls.length; i2++) {
      this.drawCalls[i2].texArray.clear();
      DRAW_CALL_POOL.push(this.drawCalls[i2]);
    }
    this.drawCalls.length = 0;
    for (var i2 = 0; i2 < this.batches.length; i2++) {
      var batchPart = this.batches[i2];
      batchPart.reset();
      BATCH_POOL.push(batchPart);
    }
    this.batches.length = 0;
  };
  GraphicsGeometry2.prototype.clear = function() {
    if (this.graphicsData.length > 0) {
      this.invalidate();
      this.clearDirty++;
      this.graphicsData.length = 0;
    }
    return this;
  };
  GraphicsGeometry2.prototype.drawShape = function(shape, fillStyle, lineStyle, matrix) {
    if (fillStyle === void 0) {
      fillStyle = null;
    }
    if (lineStyle === void 0) {
      lineStyle = null;
    }
    if (matrix === void 0) {
      matrix = null;
    }
    var data = new GraphicsData(shape, fillStyle, lineStyle, matrix);
    this.graphicsData.push(data);
    this.dirty++;
    return this;
  };
  GraphicsGeometry2.prototype.drawHole = function(shape, matrix) {
    if (matrix === void 0) {
      matrix = null;
    }
    if (!this.graphicsData.length) {
      return null;
    }
    var data = new GraphicsData(shape, null, null, matrix);
    var lastShape = this.graphicsData[this.graphicsData.length - 1];
    data.lineStyle = lastShape.lineStyle;
    lastShape.holes.push(data);
    this.dirty++;
    return this;
  };
  GraphicsGeometry2.prototype.destroy = function() {
    _super.prototype.destroy.call(this);
    for (var i2 = 0; i2 < this.graphicsData.length; ++i2) {
      this.graphicsData[i2].destroy();
    }
    this.points.length = 0;
    this.points = null;
    this.colors.length = 0;
    this.colors = null;
    this.uvs.length = 0;
    this.uvs = null;
    this.indices.length = 0;
    this.indices = null;
    this.indexBuffer.destroy();
    this.indexBuffer = null;
    this.graphicsData.length = 0;
    this.graphicsData = null;
    this.drawCalls.length = 0;
    this.drawCalls = null;
    this.batches.length = 0;
    this.batches = null;
    this._bounds = null;
  };
  GraphicsGeometry2.prototype.containsPoint = function(point) {
    var graphicsData = this.graphicsData;
    for (var i2 = 0; i2 < graphicsData.length; ++i2) {
      var data = graphicsData[i2];
      if (!data.fillStyle.visible) {
        continue;
      }
      if (data.shape) {
        if (data.matrix) {
          data.matrix.applyInverse(point, tmpPoint);
        } else {
          tmpPoint.copyFrom(point);
        }
        if (data.shape.contains(tmpPoint.x, tmpPoint.y)) {
          var hitHole = false;
          if (data.holes) {
            for (var i_1 = 0; i_1 < data.holes.length; i_1++) {
              var hole = data.holes[i_1];
              if (hole.shape.contains(tmpPoint.x, tmpPoint.y)) {
                hitHole = true;
                break;
              }
            }
          }
          if (!hitHole) {
            return true;
          }
        }
      }
    }
    return false;
  };
  GraphicsGeometry2.prototype.updateBatches = function(allow32Indices) {
    if (!this.graphicsData.length) {
      this.batchable = true;
      return;
    }
    if (!this.validateBatching()) {
      return;
    }
    this.cacheDirty = this.dirty;
    var uvs = this.uvs;
    var graphicsData = this.graphicsData;
    var batchPart = null;
    var currentStyle = null;
    if (this.batches.length > 0) {
      batchPart = this.batches[this.batches.length - 1];
      currentStyle = batchPart.style;
    }
    for (var i2 = this.shapeIndex; i2 < graphicsData.length; i2++) {
      this.shapeIndex++;
      var data = graphicsData[i2];
      var fillStyle = data.fillStyle;
      var lineStyle = data.lineStyle;
      var command = FILL_COMMANDS[data.type];
      command.build(data);
      if (data.matrix) {
        this.transformPoints(data.points, data.matrix);
      }
      if (fillStyle.visible || lineStyle.visible) {
        this.processHoles(data.holes);
      }
      for (var j2 = 0; j2 < 2; j2++) {
        var style = j2 === 0 ? fillStyle : lineStyle;
        if (!style.visible) {
          continue;
        }
        var nextTexture = style.texture.baseTexture;
        var index_1 = this.indices.length;
        var attribIndex = this.points.length / 2;
        nextTexture.wrapMode = WRAP_MODES$3.REPEAT;
        if (j2 === 0) {
          this.processFill(data);
        } else {
          this.processLine(data);
        }
        var size = this.points.length / 2 - attribIndex;
        if (size === 0) {
          continue;
        }
        if (batchPart && !this._compareStyles(currentStyle, style)) {
          batchPart.end(index_1, attribIndex);
          batchPart = null;
        }
        if (!batchPart) {
          batchPart = BATCH_POOL.pop() || new BatchPart();
          batchPart.begin(style, index_1, attribIndex);
          this.batches.push(batchPart);
          currentStyle = style;
        }
        this.addUvs(this.points, uvs, style.texture, attribIndex, size, style.matrix);
      }
    }
    var index = this.indices.length;
    var attrib = this.points.length / 2;
    if (batchPart) {
      batchPart.end(index, attrib);
    }
    if (this.batches.length === 0) {
      this.batchable = true;
      return;
    }
    if (this.indicesUint16 && this.indices.length === this.indicesUint16.length) {
      this.indicesUint16.set(this.indices);
    } else {
      var need32 = attrib > 65535 && allow32Indices;
      this.indicesUint16 = need32 ? new Uint32Array(this.indices) : new Uint16Array(this.indices);
    }
    this.batchable = this.isBatchable();
    if (this.batchable) {
      this.packBatches();
    } else {
      this.buildDrawCalls();
    }
  };
  GraphicsGeometry2.prototype._compareStyles = function(styleA, styleB) {
    if (!styleA || !styleB) {
      return false;
    }
    if (styleA.texture.baseTexture !== styleB.texture.baseTexture) {
      return false;
    }
    if (styleA.color + styleA.alpha !== styleB.color + styleB.alpha) {
      return false;
    }
    if (!!styleA.native !== !!styleB.native) {
      return false;
    }
    return true;
  };
  GraphicsGeometry2.prototype.validateBatching = function() {
    if (this.dirty === this.cacheDirty || !this.graphicsData.length) {
      return false;
    }
    for (var i2 = 0, l2 = this.graphicsData.length; i2 < l2; i2++) {
      var data = this.graphicsData[i2];
      var fill = data.fillStyle;
      var line = data.lineStyle;
      if (fill && !fill.texture.baseTexture.valid) {
        return false;
      }
      if (line && !line.texture.baseTexture.valid) {
        return false;
      }
    }
    return true;
  };
  GraphicsGeometry2.prototype.packBatches = function() {
    this.batchDirty++;
    this.uvsFloat32 = new Float32Array(this.uvs);
    var batches = this.batches;
    for (var i2 = 0, l2 = batches.length; i2 < l2; i2++) {
      var batch = batches[i2];
      for (var j2 = 0; j2 < batch.size; j2++) {
        var index = batch.start + j2;
        this.indicesUint16[index] = this.indicesUint16[index] - batch.attribStart;
      }
    }
  };
  GraphicsGeometry2.prototype.isBatchable = function() {
    if (this.points.length > 65535 * 2) {
      return false;
    }
    var batches = this.batches;
    for (var i2 = 0; i2 < batches.length; i2++) {
      if (batches[i2].style.native) {
        return false;
      }
    }
    return this.points.length < GraphicsGeometry2.BATCHABLE_SIZE * 2;
  };
  GraphicsGeometry2.prototype.buildDrawCalls = function() {
    var TICK = ++BaseTexture._globalBatch;
    for (var i2 = 0; i2 < this.drawCalls.length; i2++) {
      this.drawCalls[i2].texArray.clear();
      DRAW_CALL_POOL.push(this.drawCalls[i2]);
    }
    this.drawCalls.length = 0;
    var colors = this.colors;
    var textureIds = this.textureIds;
    var currentGroup = DRAW_CALL_POOL.pop();
    if (!currentGroup) {
      currentGroup = new BatchDrawCall();
      currentGroup.texArray = new BatchTextureArray();
    }
    currentGroup.texArray.count = 0;
    currentGroup.start = 0;
    currentGroup.size = 0;
    currentGroup.type = DRAW_MODES$3.TRIANGLES;
    var textureCount = 0;
    var currentTexture = null;
    var textureId = 0;
    var native = false;
    var drawMode = DRAW_MODES$3.TRIANGLES;
    var index = 0;
    this.drawCalls.push(currentGroup);
    for (var i2 = 0; i2 < this.batches.length; i2++) {
      var data = this.batches[i2];
      var MAX_TEXTURES = 8;
      var style = data.style;
      var nextTexture = style.texture.baseTexture;
      if (native !== !!style.native) {
        native = !!style.native;
        drawMode = native ? DRAW_MODES$3.LINES : DRAW_MODES$3.TRIANGLES;
        currentTexture = null;
        textureCount = MAX_TEXTURES;
        TICK++;
      }
      if (currentTexture !== nextTexture) {
        currentTexture = nextTexture;
        if (nextTexture._batchEnabled !== TICK) {
          if (textureCount === MAX_TEXTURES) {
            TICK++;
            textureCount = 0;
            if (currentGroup.size > 0) {
              currentGroup = DRAW_CALL_POOL.pop();
              if (!currentGroup) {
                currentGroup = new BatchDrawCall();
                currentGroup.texArray = new BatchTextureArray();
              }
              this.drawCalls.push(currentGroup);
            }
            currentGroup.start = index;
            currentGroup.size = 0;
            currentGroup.texArray.count = 0;
            currentGroup.type = drawMode;
          }
          nextTexture.touched = 1;
          nextTexture._batchEnabled = TICK;
          nextTexture._batchLocation = textureCount;
          nextTexture.wrapMode = WRAP_MODES$3.REPEAT;
          currentGroup.texArray.elements[currentGroup.texArray.count++] = nextTexture;
          textureCount++;
        }
      }
      currentGroup.size += data.size;
      index += data.size;
      textureId = nextTexture._batchLocation;
      this.addColors(colors, style.color, style.alpha, data.attribSize, data.attribStart);
      this.addTextureIds(textureIds, textureId, data.attribSize, data.attribStart);
    }
    BaseTexture._globalBatch = TICK;
    this.packAttributes();
  };
  GraphicsGeometry2.prototype.packAttributes = function() {
    var verts = this.points;
    var uvs = this.uvs;
    var colors = this.colors;
    var textureIds = this.textureIds;
    var glPoints = new ArrayBuffer(verts.length * 3 * 4);
    var f32 = new Float32Array(glPoints);
    var u32 = new Uint32Array(glPoints);
    var p2 = 0;
    for (var i2 = 0; i2 < verts.length / 2; i2++) {
      f32[p2++] = verts[i2 * 2];
      f32[p2++] = verts[i2 * 2 + 1];
      f32[p2++] = uvs[i2 * 2];
      f32[p2++] = uvs[i2 * 2 + 1];
      u32[p2++] = colors[i2];
      f32[p2++] = textureIds[i2];
    }
    this._buffer.update(glPoints);
    this._indexBuffer.update(this.indicesUint16);
  };
  GraphicsGeometry2.prototype.processFill = function(data) {
    if (data.holes.length) {
      buildPoly.triangulate(data, this);
    } else {
      var command = FILL_COMMANDS[data.type];
      command.triangulate(data, this);
    }
  };
  GraphicsGeometry2.prototype.processLine = function(data) {
    buildLine(data, this);
    for (var i2 = 0; i2 < data.holes.length; i2++) {
      buildLine(data.holes[i2], this);
    }
  };
  GraphicsGeometry2.prototype.processHoles = function(holes) {
    for (var i2 = 0; i2 < holes.length; i2++) {
      var hole = holes[i2];
      var command = FILL_COMMANDS[hole.type];
      command.build(hole);
      if (hole.matrix) {
        this.transformPoints(hole.points, hole.matrix);
      }
    }
  };
  GraphicsGeometry2.prototype.calculateBounds = function() {
    var bounds = this._bounds;
    var sequenceBounds = tmpBounds;
    var curMatrix = Matrix.IDENTITY;
    this._bounds.clear();
    sequenceBounds.clear();
    for (var i2 = 0; i2 < this.graphicsData.length; i2++) {
      var data = this.graphicsData[i2];
      var shape = data.shape;
      var type = data.type;
      var lineStyle = data.lineStyle;
      var nextMatrix = data.matrix || Matrix.IDENTITY;
      var lineWidth = 0;
      if (lineStyle && lineStyle.visible) {
        lineWidth = lineStyle.width * Math.max(0, lineStyle.alignment);
      }
      if (curMatrix !== nextMatrix) {
        if (!sequenceBounds.isEmpty()) {
          bounds.addBoundsMatrix(sequenceBounds, curMatrix);
          sequenceBounds.clear();
        }
        curMatrix = nextMatrix;
      }
      if (type === SHAPES.RECT || type === SHAPES.RREC) {
        var rect = shape;
        sequenceBounds.addFramePad(rect.x, rect.y, rect.x + rect.width, rect.y + rect.height, lineWidth, lineWidth);
      } else if (type === SHAPES.CIRC) {
        var circle = shape;
        sequenceBounds.addFramePad(circle.x, circle.y, circle.x, circle.y, circle.radius + lineWidth, circle.radius + lineWidth);
      } else if (type === SHAPES.ELIP) {
        var ellipse = shape;
        sequenceBounds.addFramePad(ellipse.x, ellipse.y, ellipse.x, ellipse.y, ellipse.width + lineWidth, ellipse.height + lineWidth);
      } else {
        var poly = shape;
        bounds.addVerticesMatrix(curMatrix, poly.points, 0, poly.points.length, lineWidth, lineWidth);
      }
    }
    if (!sequenceBounds.isEmpty()) {
      bounds.addBoundsMatrix(sequenceBounds, curMatrix);
    }
    bounds.pad(this.boundsPadding, this.boundsPadding);
  };
  GraphicsGeometry2.prototype.transformPoints = function(points, matrix) {
    for (var i2 = 0; i2 < points.length / 2; i2++) {
      var x2 = points[i2 * 2];
      var y2 = points[i2 * 2 + 1];
      points[i2 * 2] = matrix.a * x2 + matrix.c * y2 + matrix.tx;
      points[i2 * 2 + 1] = matrix.b * x2 + matrix.d * y2 + matrix.ty;
    }
  };
  GraphicsGeometry2.prototype.addColors = function(colors, color, alpha, size, offset) {
    if (offset === void 0) {
      offset = 0;
    }
    var rgb = (color >> 16) + (color & 65280) + ((color & 255) << 16);
    var rgba = premultiplyTint(rgb, alpha);
    colors.length = Math.max(colors.length, offset + size);
    for (var i2 = 0; i2 < size; i2++) {
      colors[offset + i2] = rgba;
    }
  };
  GraphicsGeometry2.prototype.addTextureIds = function(textureIds, id, size, offset) {
    if (offset === void 0) {
      offset = 0;
    }
    textureIds.length = Math.max(textureIds.length, offset + size);
    for (var i2 = 0; i2 < size; i2++) {
      textureIds[offset + i2] = id;
    }
  };
  GraphicsGeometry2.prototype.addUvs = function(verts, uvs, texture, start, size, matrix) {
    if (matrix === void 0) {
      matrix = null;
    }
    var index = 0;
    var uvsStart = uvs.length;
    var frame = texture.frame;
    while (index < size) {
      var x2 = verts[(start + index) * 2];
      var y2 = verts[(start + index) * 2 + 1];
      if (matrix) {
        var nx = matrix.a * x2 + matrix.c * y2 + matrix.tx;
        y2 = matrix.b * x2 + matrix.d * y2 + matrix.ty;
        x2 = nx;
      }
      index++;
      uvs.push(x2 / frame.width, y2 / frame.height);
    }
    var baseTexture = texture.baseTexture;
    if (frame.width < baseTexture.width || frame.height < baseTexture.height) {
      this.adjustUvs(uvs, texture, uvsStart, size);
    }
  };
  GraphicsGeometry2.prototype.adjustUvs = function(uvs, texture, start, size) {
    var baseTexture = texture.baseTexture;
    var eps = 1e-6;
    var finish = start + size * 2;
    var frame = texture.frame;
    var scaleX = frame.width / baseTexture.width;
    var scaleY = frame.height / baseTexture.height;
    var offsetX = frame.x / frame.width;
    var offsetY = frame.y / frame.height;
    var minX = Math.floor(uvs[start] + eps);
    var minY = Math.floor(uvs[start + 1] + eps);
    for (var i2 = start + 2; i2 < finish; i2 += 2) {
      minX = Math.min(minX, Math.floor(uvs[i2] + eps));
      minY = Math.min(minY, Math.floor(uvs[i2 + 1] + eps));
    }
    offsetX -= minX;
    offsetY -= minY;
    for (var i2 = start; i2 < finish; i2 += 2) {
      uvs[i2] = (uvs[i2] + offsetX) * scaleX;
      uvs[i2 + 1] = (uvs[i2 + 1] + offsetY) * scaleY;
    }
  };
  GraphicsGeometry2.BATCHABLE_SIZE = 100;
  return GraphicsGeometry2;
}(BatchGeometry);
var LineStyle = function(_super) {
  __extends$l(LineStyle2, _super);
  function LineStyle2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.width = 0;
    _this.alignment = 0.5;
    _this.native = false;
    _this.cap = LINE_CAP.BUTT;
    _this.join = LINE_JOIN.MITER;
    _this.miterLimit = 10;
    return _this;
  }
  LineStyle2.prototype.clone = function() {
    var obj = new LineStyle2();
    obj.color = this.color;
    obj.alpha = this.alpha;
    obj.texture = this.texture;
    obj.matrix = this.matrix;
    obj.visible = this.visible;
    obj.width = this.width;
    obj.alignment = this.alignment;
    obj.native = this.native;
    obj.cap = this.cap;
    obj.join = this.join;
    obj.miterLimit = this.miterLimit;
    return obj;
  };
  LineStyle2.prototype.reset = function() {
    _super.prototype.reset.call(this);
    this.color = 0;
    this.alignment = 0.5;
    this.width = 0;
    this.native = false;
  };
  return LineStyle2;
}(FillStyle);
var temp = new Float32Array(3);
var DEFAULT_SHADERS = {};
var Graphics = function(_super) {
  __extends$l(Graphics2, _super);
  function Graphics2(geometry) {
    if (geometry === void 0) {
      geometry = null;
    }
    var _this = _super.call(this) || this;
    _this.shader = null;
    _this.pluginName = "batch";
    _this.currentPath = null;
    _this.batches = [];
    _this.batchTint = -1;
    _this.batchDirty = -1;
    _this.vertexData = null;
    _this._fillStyle = new FillStyle();
    _this._lineStyle = new LineStyle();
    _this._matrix = null;
    _this._holeMode = false;
    _this.state = State.for2d();
    _this._geometry = geometry || new GraphicsGeometry();
    _this._geometry.refCount++;
    _this._transformID = -1;
    _this.tint = 16777215;
    _this.blendMode = BLEND_MODES$3.NORMAL;
    return _this;
  }
  Object.defineProperty(Graphics2.prototype, "geometry", {
    get: function() {
      return this._geometry;
    },
    enumerable: false,
    configurable: true
  });
  Graphics2.prototype.clone = function() {
    this.finishPoly();
    return new Graphics2(this._geometry);
  };
  Object.defineProperty(Graphics2.prototype, "blendMode", {
    get: function() {
      return this.state.blendMode;
    },
    set: function(value) {
      this.state.blendMode = value;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Graphics2.prototype, "tint", {
    get: function() {
      return this._tint;
    },
    set: function(value) {
      this._tint = value;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Graphics2.prototype, "fill", {
    get: function() {
      return this._fillStyle;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Graphics2.prototype, "line", {
    get: function() {
      return this._lineStyle;
    },
    enumerable: false,
    configurable: true
  });
  Graphics2.prototype.lineStyle = function(options, color, alpha, alignment, native) {
    if (options === void 0) {
      options = null;
    }
    if (color === void 0) {
      color = 0;
    }
    if (alpha === void 0) {
      alpha = 1;
    }
    if (alignment === void 0) {
      alignment = 0.5;
    }
    if (native === void 0) {
      native = false;
    }
    if (typeof options === "number") {
      options = { width: options, color, alpha, alignment, native };
    }
    return this.lineTextureStyle(options);
  };
  Graphics2.prototype.lineTextureStyle = function(options) {
    options = Object.assign({
      width: 0,
      texture: Texture.WHITE,
      color: options && options.texture ? 16777215 : 0,
      alpha: 1,
      matrix: null,
      alignment: 0.5,
      native: false,
      cap: LINE_CAP.BUTT,
      join: LINE_JOIN.MITER,
      miterLimit: 10
    }, options);
    if (this.currentPath) {
      this.startPoly();
    }
    var visible = options.width > 0 && options.alpha > 0;
    if (!visible) {
      this._lineStyle.reset();
    } else {
      if (options.matrix) {
        options.matrix = options.matrix.clone();
        options.matrix.invert();
      }
      Object.assign(this._lineStyle, { visible }, options);
    }
    return this;
  };
  Graphics2.prototype.startPoly = function() {
    if (this.currentPath) {
      var points = this.currentPath.points;
      var len = this.currentPath.points.length;
      if (len > 2) {
        this.drawShape(this.currentPath);
        this.currentPath = new Polygon();
        this.currentPath.closeStroke = false;
        this.currentPath.points.push(points[len - 2], points[len - 1]);
      }
    } else {
      this.currentPath = new Polygon();
      this.currentPath.closeStroke = false;
    }
  };
  Graphics2.prototype.finishPoly = function() {
    if (this.currentPath) {
      if (this.currentPath.points.length > 2) {
        this.drawShape(this.currentPath);
        this.currentPath = null;
      } else {
        this.currentPath.points.length = 0;
      }
    }
  };
  Graphics2.prototype.moveTo = function(x2, y2) {
    this.startPoly();
    this.currentPath.points[0] = x2;
    this.currentPath.points[1] = y2;
    return this;
  };
  Graphics2.prototype.lineTo = function(x2, y2) {
    if (!this.currentPath) {
      this.moveTo(0, 0);
    }
    var points = this.currentPath.points;
    var fromX = points[points.length - 2];
    var fromY = points[points.length - 1];
    if (fromX !== x2 || fromY !== y2) {
      points.push(x2, y2);
    }
    return this;
  };
  Graphics2.prototype._initCurve = function(x2, y2) {
    if (x2 === void 0) {
      x2 = 0;
    }
    if (y2 === void 0) {
      y2 = 0;
    }
    if (this.currentPath) {
      if (this.currentPath.points.length === 0) {
        this.currentPath.points = [x2, y2];
      }
    } else {
      this.moveTo(x2, y2);
    }
  };
  Graphics2.prototype.quadraticCurveTo = function(cpX, cpY, toX, toY) {
    this._initCurve();
    var points = this.currentPath.points;
    if (points.length === 0) {
      this.moveTo(0, 0);
    }
    QuadraticUtils.curveTo(cpX, cpY, toX, toY, points);
    return this;
  };
  Graphics2.prototype.bezierCurveTo = function(cpX, cpY, cpX2, cpY2, toX, toY) {
    this._initCurve();
    BezierUtils.curveTo(cpX, cpY, cpX2, cpY2, toX, toY, this.currentPath.points);
    return this;
  };
  Graphics2.prototype.arcTo = function(x1, y1, x2, y2, radius) {
    this._initCurve(x1, y1);
    var points = this.currentPath.points;
    var result = ArcUtils.curveTo(x1, y1, x2, y2, radius, points);
    if (result) {
      var cx = result.cx, cy = result.cy, radius_1 = result.radius, startAngle = result.startAngle, endAngle = result.endAngle, anticlockwise = result.anticlockwise;
      this.arc(cx, cy, radius_1, startAngle, endAngle, anticlockwise);
    }
    return this;
  };
  Graphics2.prototype.arc = function(cx, cy, radius, startAngle, endAngle, anticlockwise) {
    if (anticlockwise === void 0) {
      anticlockwise = false;
    }
    if (startAngle === endAngle) {
      return this;
    }
    if (!anticlockwise && endAngle <= startAngle) {
      endAngle += PI_2;
    } else if (anticlockwise && startAngle <= endAngle) {
      startAngle += PI_2;
    }
    var sweep = endAngle - startAngle;
    if (sweep === 0) {
      return this;
    }
    var startX = cx + Math.cos(startAngle) * radius;
    var startY = cy + Math.sin(startAngle) * radius;
    var eps = this._geometry.closePointEps;
    var points = this.currentPath ? this.currentPath.points : null;
    if (points) {
      var xDiff = Math.abs(points[points.length - 2] - startX);
      var yDiff = Math.abs(points[points.length - 1] - startY);
      if (xDiff < eps && yDiff < eps)
        ;
      else {
        points.push(startX, startY);
      }
    } else {
      this.moveTo(startX, startY);
      points = this.currentPath.points;
    }
    ArcUtils.arc(startX, startY, cx, cy, radius, startAngle, endAngle, anticlockwise, points);
    return this;
  };
  Graphics2.prototype.beginFill = function(color, alpha) {
    if (color === void 0) {
      color = 0;
    }
    if (alpha === void 0) {
      alpha = 1;
    }
    return this.beginTextureFill({ texture: Texture.WHITE, color, alpha });
  };
  Graphics2.prototype.beginTextureFill = function(options) {
    options = Object.assign({
      texture: Texture.WHITE,
      color: 16777215,
      alpha: 1,
      matrix: null
    }, options);
    if (this.currentPath) {
      this.startPoly();
    }
    var visible = options.alpha > 0;
    if (!visible) {
      this._fillStyle.reset();
    } else {
      if (options.matrix) {
        options.matrix = options.matrix.clone();
        options.matrix.invert();
      }
      Object.assign(this._fillStyle, { visible }, options);
    }
    return this;
  };
  Graphics2.prototype.endFill = function() {
    this.finishPoly();
    this._fillStyle.reset();
    return this;
  };
  Graphics2.prototype.drawRect = function(x2, y2, width, height) {
    return this.drawShape(new Rectangle(x2, y2, width, height));
  };
  Graphics2.prototype.drawRoundedRect = function(x2, y2, width, height, radius) {
    return this.drawShape(new RoundedRectangle(x2, y2, width, height, radius));
  };
  Graphics2.prototype.drawCircle = function(x2, y2, radius) {
    return this.drawShape(new Circle(x2, y2, radius));
  };
  Graphics2.prototype.drawEllipse = function(x2, y2, width, height) {
    return this.drawShape(new Ellipse(x2, y2, width, height));
  };
  Graphics2.prototype.drawPolygon = function() {
    var arguments$1 = arguments;
    var path = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      path[_i] = arguments$1[_i];
    }
    var points;
    var closeStroke = true;
    var poly = path[0];
    if (poly.points) {
      closeStroke = poly.closeStroke;
      points = poly.points;
    } else if (Array.isArray(path[0])) {
      points = path[0];
    } else {
      points = path;
    }
    var shape = new Polygon(points);
    shape.closeStroke = closeStroke;
    this.drawShape(shape);
    return this;
  };
  Graphics2.prototype.drawShape = function(shape) {
    if (!this._holeMode) {
      this._geometry.drawShape(shape, this._fillStyle.clone(), this._lineStyle.clone(), this._matrix);
    } else {
      this._geometry.drawHole(shape, this._matrix);
    }
    return this;
  };
  Graphics2.prototype.clear = function() {
    this._geometry.clear();
    this._lineStyle.reset();
    this._fillStyle.reset();
    this._boundsID++;
    this._matrix = null;
    this._holeMode = false;
    this.currentPath = null;
    return this;
  };
  Graphics2.prototype.isFastRect = function() {
    var data = this._geometry.graphicsData;
    return data.length === 1 && data[0].shape.type === SHAPES.RECT && !data[0].matrix && !data[0].holes.length && !(data[0].lineStyle.visible && data[0].lineStyle.width);
  };
  Graphics2.prototype._render = function(renderer) {
    this.finishPoly();
    var geometry = this._geometry;
    var hasuint32 = renderer.context.supports.uint32Indices;
    geometry.updateBatches(hasuint32);
    if (geometry.batchable) {
      if (this.batchDirty !== geometry.batchDirty) {
        this._populateBatches();
      }
      this._renderBatched(renderer);
    } else {
      renderer.batch.flush();
      this._renderDirect(renderer);
    }
  };
  Graphics2.prototype._populateBatches = function() {
    var geometry = this._geometry;
    var blendMode = this.blendMode;
    var len = geometry.batches.length;
    this.batchTint = -1;
    this._transformID = -1;
    this.batchDirty = geometry.batchDirty;
    this.batches.length = len;
    this.vertexData = new Float32Array(geometry.points);
    for (var i2 = 0; i2 < len; i2++) {
      var gI = geometry.batches[i2];
      var color = gI.style.color;
      var vertexData = new Float32Array(this.vertexData.buffer, gI.attribStart * 4 * 2, gI.attribSize * 2);
      var uvs = new Float32Array(geometry.uvsFloat32.buffer, gI.attribStart * 4 * 2, gI.attribSize * 2);
      var indices2 = new Uint16Array(geometry.indicesUint16.buffer, gI.start * 2, gI.size);
      var batch = {
        vertexData,
        blendMode,
        indices: indices2,
        uvs,
        _batchRGB: hex2rgb(color),
        _tintRGB: color,
        _texture: gI.style.texture,
        alpha: gI.style.alpha,
        worldAlpha: 1
      };
      this.batches[i2] = batch;
    }
  };
  Graphics2.prototype._renderBatched = function(renderer) {
    if (!this.batches.length) {
      return;
    }
    renderer.batch.setObjectRenderer(renderer.plugins[this.pluginName]);
    this.calculateVertices();
    this.calculateTints();
    for (var i2 = 0, l2 = this.batches.length; i2 < l2; i2++) {
      var batch = this.batches[i2];
      batch.worldAlpha = this.worldAlpha * batch.alpha;
      renderer.plugins[this.pluginName].render(batch);
    }
  };
  Graphics2.prototype._renderDirect = function(renderer) {
    var shader = this._resolveDirectShader(renderer);
    var geometry = this._geometry;
    var tint = this.tint;
    var worldAlpha = this.worldAlpha;
    var uniforms = shader.uniforms;
    var drawCalls = geometry.drawCalls;
    uniforms.translationMatrix = this.transform.worldTransform;
    uniforms.tint[0] = (tint >> 16 & 255) / 255 * worldAlpha;
    uniforms.tint[1] = (tint >> 8 & 255) / 255 * worldAlpha;
    uniforms.tint[2] = (tint & 255) / 255 * worldAlpha;
    uniforms.tint[3] = worldAlpha;
    renderer.shader.bind(shader);
    renderer.geometry.bind(geometry, shader);
    renderer.state.set(this.state);
    for (var i2 = 0, l2 = drawCalls.length; i2 < l2; i2++) {
      this._renderDrawCallDirect(renderer, geometry.drawCalls[i2]);
    }
  };
  Graphics2.prototype._renderDrawCallDirect = function(renderer, drawCall) {
    var texArray = drawCall.texArray, type = drawCall.type, size = drawCall.size, start = drawCall.start;
    var groupTextureCount = texArray.count;
    for (var j2 = 0; j2 < groupTextureCount; j2++) {
      renderer.texture.bind(texArray.elements[j2], j2);
    }
    renderer.geometry.draw(type, size, start);
  };
  Graphics2.prototype._resolveDirectShader = function(renderer) {
    var shader = this.shader;
    var pluginName = this.pluginName;
    if (!shader) {
      if (!DEFAULT_SHADERS[pluginName]) {
        var MAX_TEXTURES = renderer.plugins.batch.MAX_TEXTURES;
        var sampleValues = new Int32Array(MAX_TEXTURES);
        for (var i2 = 0; i2 < MAX_TEXTURES; i2++) {
          sampleValues[i2] = i2;
        }
        var uniforms = {
          tint: new Float32Array([1, 1, 1, 1]),
          translationMatrix: new Matrix(),
          default: UniformGroup.from({ uSamplers: sampleValues }, true)
        };
        var program = renderer.plugins[pluginName]._shader.program;
        DEFAULT_SHADERS[pluginName] = new Shader(program, uniforms);
      }
      shader = DEFAULT_SHADERS[pluginName];
    }
    return shader;
  };
  Graphics2.prototype._calculateBounds = function() {
    this.finishPoly();
    var geometry = this._geometry;
    if (!geometry.graphicsData.length) {
      return;
    }
    var _a3 = geometry.bounds, minX = _a3.minX, minY = _a3.minY, maxX = _a3.maxX, maxY = _a3.maxY;
    this._bounds.addFrame(this.transform, minX, minY, maxX, maxY);
  };
  Graphics2.prototype.containsPoint = function(point) {
    this.worldTransform.applyInverse(point, Graphics2._TEMP_POINT);
    return this._geometry.containsPoint(Graphics2._TEMP_POINT);
  };
  Graphics2.prototype.calculateTints = function() {
    if (this.batchTint !== this.tint) {
      this.batchTint = this.tint;
      var tintRGB = hex2rgb(this.tint, temp);
      for (var i2 = 0; i2 < this.batches.length; i2++) {
        var batch = this.batches[i2];
        var batchTint = batch._batchRGB;
        var r2 = tintRGB[0] * batchTint[0] * 255;
        var g2 = tintRGB[1] * batchTint[1] * 255;
        var b2 = tintRGB[2] * batchTint[2] * 255;
        var color = (r2 << 16) + (g2 << 8) + (b2 | 0);
        batch._tintRGB = (color >> 16) + (color & 65280) + ((color & 255) << 16);
      }
    }
  };
  Graphics2.prototype.calculateVertices = function() {
    var wtID = this.transform._worldID;
    if (this._transformID === wtID) {
      return;
    }
    this._transformID = wtID;
    var wt = this.transform.worldTransform;
    var a2 = wt.a;
    var b2 = wt.b;
    var c2 = wt.c;
    var d2 = wt.d;
    var tx = wt.tx;
    var ty = wt.ty;
    var data = this._geometry.points;
    var vertexData = this.vertexData;
    var count = 0;
    for (var i2 = 0; i2 < data.length; i2 += 2) {
      var x2 = data[i2];
      var y2 = data[i2 + 1];
      vertexData[count++] = a2 * x2 + c2 * y2 + tx;
      vertexData[count++] = d2 * y2 + b2 * x2 + ty;
    }
  };
  Graphics2.prototype.closePath = function() {
    var currentPath = this.currentPath;
    if (currentPath) {
      currentPath.closeStroke = true;
      this.finishPoly();
    }
    return this;
  };
  Graphics2.prototype.setMatrix = function(matrix) {
    this._matrix = matrix;
    return this;
  };
  Graphics2.prototype.beginHole = function() {
    this.finishPoly();
    this._holeMode = true;
    return this;
  };
  Graphics2.prototype.endHole = function() {
    this.finishPoly();
    this._holeMode = false;
    return this;
  };
  Graphics2.prototype.destroy = function(options) {
    this._geometry.refCount--;
    if (this._geometry.refCount === 0) {
      this._geometry.dispose();
    }
    this._matrix = null;
    this.currentPath = null;
    this._lineStyle.destroy();
    this._lineStyle = null;
    this._fillStyle.destroy();
    this._fillStyle = null;
    this._geometry = null;
    this.shader = null;
    this.vertexData = null;
    this.batches.length = 0;
    this.batches = null;
    _super.prototype.destroy.call(this, options);
  };
  Graphics2.nextRoundedRectBehavior = false;
  Graphics2._TEMP_POINT = new Point();
  return Graphics2;
}(Container);
/*!
 * @pixi/sprite - v6.3.0
 * Compiled Wed, 23 Mar 2022 18:58:56 UTC
 *
 * @pixi/sprite is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
/*! *****************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */
var extendStatics$k = function(d2, b2) {
  extendStatics$k = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {
    d3.__proto__ = b3;
  } || function(d3, b3) {
    for (var p2 in b3) {
      if (b3.hasOwnProperty(p2)) {
        d3[p2] = b3[p2];
      }
    }
  };
  return extendStatics$k(d2, b2);
};
function __extends$k(d2, b2) {
  extendStatics$k(d2, b2);
  function __() {
    this.constructor = d2;
  }
  d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
}
var tempPoint$2 = new Point();
var indices = new Uint16Array([0, 1, 2, 0, 2, 3]);
var Sprite = function(_super) {
  __extends$k(Sprite2, _super);
  function Sprite2(texture) {
    var _this = _super.call(this) || this;
    _this._anchor = new ObservablePoint(_this._onAnchorUpdate, _this, texture ? texture.defaultAnchor.x : 0, texture ? texture.defaultAnchor.y : 0);
    _this._texture = null;
    _this._width = 0;
    _this._height = 0;
    _this._tint = null;
    _this._tintRGB = null;
    _this.tint = 16777215;
    _this.blendMode = BLEND_MODES$3.NORMAL;
    _this._cachedTint = 16777215;
    _this.uvs = null;
    _this.texture = texture || Texture.EMPTY;
    _this.vertexData = new Float32Array(8);
    _this.vertexTrimmedData = null;
    _this._transformID = -1;
    _this._textureID = -1;
    _this._transformTrimmedID = -1;
    _this._textureTrimmedID = -1;
    _this.indices = indices;
    _this.pluginName = "batch";
    _this.isSprite = true;
    _this._roundPixels = settings.ROUND_PIXELS;
    return _this;
  }
  Sprite2.prototype._onTextureUpdate = function() {
    this._textureID = -1;
    this._textureTrimmedID = -1;
    this._cachedTint = 16777215;
    if (this._width) {
      this.scale.x = sign(this.scale.x) * this._width / this._texture.orig.width;
    }
    if (this._height) {
      this.scale.y = sign(this.scale.y) * this._height / this._texture.orig.height;
    }
  };
  Sprite2.prototype._onAnchorUpdate = function() {
    this._transformID = -1;
    this._transformTrimmedID = -1;
  };
  Sprite2.prototype.calculateVertices = function() {
    var texture = this._texture;
    if (this._transformID === this.transform._worldID && this._textureID === texture._updateID) {
      return;
    }
    if (this._textureID !== texture._updateID) {
      this.uvs = this._texture._uvs.uvsFloat32;
    }
    this._transformID = this.transform._worldID;
    this._textureID = texture._updateID;
    var wt = this.transform.worldTransform;
    var a2 = wt.a;
    var b2 = wt.b;
    var c2 = wt.c;
    var d2 = wt.d;
    var tx = wt.tx;
    var ty = wt.ty;
    var vertexData = this.vertexData;
    var trim2 = texture.trim;
    var orig = texture.orig;
    var anchor = this._anchor;
    var w0 = 0;
    var w1 = 0;
    var h0 = 0;
    var h1 = 0;
    if (trim2) {
      w1 = trim2.x - anchor._x * orig.width;
      w0 = w1 + trim2.width;
      h1 = trim2.y - anchor._y * orig.height;
      h0 = h1 + trim2.height;
    } else {
      w1 = -anchor._x * orig.width;
      w0 = w1 + orig.width;
      h1 = -anchor._y * orig.height;
      h0 = h1 + orig.height;
    }
    vertexData[0] = a2 * w1 + c2 * h1 + tx;
    vertexData[1] = d2 * h1 + b2 * w1 + ty;
    vertexData[2] = a2 * w0 + c2 * h1 + tx;
    vertexData[3] = d2 * h1 + b2 * w0 + ty;
    vertexData[4] = a2 * w0 + c2 * h0 + tx;
    vertexData[5] = d2 * h0 + b2 * w0 + ty;
    vertexData[6] = a2 * w1 + c2 * h0 + tx;
    vertexData[7] = d2 * h0 + b2 * w1 + ty;
    if (this._roundPixels) {
      var resolution = settings.RESOLUTION;
      for (var i2 = 0; i2 < vertexData.length; ++i2) {
        vertexData[i2] = Math.round((vertexData[i2] * resolution | 0) / resolution);
      }
    }
  };
  Sprite2.prototype.calculateTrimmedVertices = function() {
    if (!this.vertexTrimmedData) {
      this.vertexTrimmedData = new Float32Array(8);
    } else if (this._transformTrimmedID === this.transform._worldID && this._textureTrimmedID === this._texture._updateID) {
      return;
    }
    this._transformTrimmedID = this.transform._worldID;
    this._textureTrimmedID = this._texture._updateID;
    var texture = this._texture;
    var vertexData = this.vertexTrimmedData;
    var orig = texture.orig;
    var anchor = this._anchor;
    var wt = this.transform.worldTransform;
    var a2 = wt.a;
    var b2 = wt.b;
    var c2 = wt.c;
    var d2 = wt.d;
    var tx = wt.tx;
    var ty = wt.ty;
    var w1 = -anchor._x * orig.width;
    var w0 = w1 + orig.width;
    var h1 = -anchor._y * orig.height;
    var h0 = h1 + orig.height;
    vertexData[0] = a2 * w1 + c2 * h1 + tx;
    vertexData[1] = d2 * h1 + b2 * w1 + ty;
    vertexData[2] = a2 * w0 + c2 * h1 + tx;
    vertexData[3] = d2 * h1 + b2 * w0 + ty;
    vertexData[4] = a2 * w0 + c2 * h0 + tx;
    vertexData[5] = d2 * h0 + b2 * w0 + ty;
    vertexData[6] = a2 * w1 + c2 * h0 + tx;
    vertexData[7] = d2 * h0 + b2 * w1 + ty;
  };
  Sprite2.prototype._render = function(renderer) {
    this.calculateVertices();
    renderer.batch.setObjectRenderer(renderer.plugins[this.pluginName]);
    renderer.plugins[this.pluginName].render(this);
  };
  Sprite2.prototype._calculateBounds = function() {
    var trim2 = this._texture.trim;
    var orig = this._texture.orig;
    if (!trim2 || trim2.width === orig.width && trim2.height === orig.height) {
      this.calculateVertices();
      this._bounds.addQuad(this.vertexData);
    } else {
      this.calculateTrimmedVertices();
      this._bounds.addQuad(this.vertexTrimmedData);
    }
  };
  Sprite2.prototype.getLocalBounds = function(rect) {
    if (this.children.length === 0) {
      if (!this._localBounds) {
        this._localBounds = new Bounds();
      }
      this._localBounds.minX = this._texture.orig.width * -this._anchor._x;
      this._localBounds.minY = this._texture.orig.height * -this._anchor._y;
      this._localBounds.maxX = this._texture.orig.width * (1 - this._anchor._x);
      this._localBounds.maxY = this._texture.orig.height * (1 - this._anchor._y);
      if (!rect) {
        if (!this._localBoundsRect) {
          this._localBoundsRect = new Rectangle();
        }
        rect = this._localBoundsRect;
      }
      return this._localBounds.getRectangle(rect);
    }
    return _super.prototype.getLocalBounds.call(this, rect);
  };
  Sprite2.prototype.containsPoint = function(point) {
    this.worldTransform.applyInverse(point, tempPoint$2);
    var width = this._texture.orig.width;
    var height = this._texture.orig.height;
    var x1 = -width * this.anchor.x;
    var y1 = 0;
    if (tempPoint$2.x >= x1 && tempPoint$2.x < x1 + width) {
      y1 = -height * this.anchor.y;
      if (tempPoint$2.y >= y1 && tempPoint$2.y < y1 + height) {
        return true;
      }
    }
    return false;
  };
  Sprite2.prototype.destroy = function(options) {
    _super.prototype.destroy.call(this, options);
    this._texture.off("update", this._onTextureUpdate, this);
    this._anchor = null;
    var destroyTexture = typeof options === "boolean" ? options : options && options.texture;
    if (destroyTexture) {
      var destroyBaseTexture = typeof options === "boolean" ? options : options && options.baseTexture;
      this._texture.destroy(!!destroyBaseTexture);
    }
    this._texture = null;
  };
  Sprite2.from = function(source, options) {
    var texture = source instanceof Texture ? source : Texture.from(source, options);
    return new Sprite2(texture);
  };
  Object.defineProperty(Sprite2.prototype, "roundPixels", {
    get: function() {
      return this._roundPixels;
    },
    set: function(value) {
      if (this._roundPixels !== value) {
        this._transformID = -1;
      }
      this._roundPixels = value;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Sprite2.prototype, "width", {
    get: function() {
      return Math.abs(this.scale.x) * this._texture.orig.width;
    },
    set: function(value) {
      var s2 = sign(this.scale.x) || 1;
      this.scale.x = s2 * value / this._texture.orig.width;
      this._width = value;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Sprite2.prototype, "height", {
    get: function() {
      return Math.abs(this.scale.y) * this._texture.orig.height;
    },
    set: function(value) {
      var s2 = sign(this.scale.y) || 1;
      this.scale.y = s2 * value / this._texture.orig.height;
      this._height = value;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Sprite2.prototype, "anchor", {
    get: function() {
      return this._anchor;
    },
    set: function(value) {
      this._anchor.copyFrom(value);
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Sprite2.prototype, "tint", {
    get: function() {
      return this._tint;
    },
    set: function(value) {
      this._tint = value;
      this._tintRGB = (value >> 16) + (value & 65280) + ((value & 255) << 16);
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Sprite2.prototype, "texture", {
    get: function() {
      return this._texture;
    },
    set: function(value) {
      if (this._texture === value) {
        return;
      }
      if (this._texture) {
        this._texture.off("update", this._onTextureUpdate, this);
      }
      this._texture = value || Texture.EMPTY;
      this._cachedTint = 16777215;
      this._textureID = -1;
      this._textureTrimmedID = -1;
      if (value) {
        if (value.baseTexture.valid) {
          this._onTextureUpdate();
        } else {
          value.once("update", this._onTextureUpdate, this);
        }
      }
    },
    enumerable: false,
    configurable: true
  });
  return Sprite2;
}(Container);
/*!
 * @pixi/text - v6.3.0
 * Compiled Wed, 23 Mar 2022 18:58:56 UTC
 *
 * @pixi/text is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
/*! *****************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */
var extendStatics$j = function(d2, b2) {
  extendStatics$j = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {
    d3.__proto__ = b3;
  } || function(d3, b3) {
    for (var p2 in b3) {
      if (b3.hasOwnProperty(p2)) {
        d3[p2] = b3[p2];
      }
    }
  };
  return extendStatics$j(d2, b2);
};
function __extends$j(d2, b2) {
  extendStatics$j(d2, b2);
  function __() {
    this.constructor = d2;
  }
  d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
}
var TEXT_GRADIENT;
(function(TEXT_GRADIENT2) {
  TEXT_GRADIENT2[TEXT_GRADIENT2["LINEAR_VERTICAL"] = 0] = "LINEAR_VERTICAL";
  TEXT_GRADIENT2[TEXT_GRADIENT2["LINEAR_HORIZONTAL"] = 1] = "LINEAR_HORIZONTAL";
})(TEXT_GRADIENT || (TEXT_GRADIENT = {}));
var defaultStyle = {
  align: "left",
  breakWords: false,
  dropShadow: false,
  dropShadowAlpha: 1,
  dropShadowAngle: Math.PI / 6,
  dropShadowBlur: 0,
  dropShadowColor: "black",
  dropShadowDistance: 5,
  fill: "black",
  fillGradientType: TEXT_GRADIENT.LINEAR_VERTICAL,
  fillGradientStops: [],
  fontFamily: "Arial",
  fontSize: 26,
  fontStyle: "normal",
  fontVariant: "normal",
  fontWeight: "normal",
  letterSpacing: 0,
  lineHeight: 0,
  lineJoin: "miter",
  miterLimit: 10,
  padding: 0,
  stroke: "black",
  strokeThickness: 0,
  textBaseline: "alphabetic",
  trim: false,
  whiteSpace: "pre",
  wordWrap: false,
  wordWrapWidth: 100,
  leading: 0
};
var genericFontFamilies = [
  "serif",
  "sans-serif",
  "monospace",
  "cursive",
  "fantasy",
  "system-ui"
];
var TextStyle = function() {
  function TextStyle2(style) {
    this.styleID = 0;
    this.reset();
    deepCopyProperties(this, style, style);
  }
  TextStyle2.prototype.clone = function() {
    var clonedProperties = {};
    deepCopyProperties(clonedProperties, this, defaultStyle);
    return new TextStyle2(clonedProperties);
  };
  TextStyle2.prototype.reset = function() {
    deepCopyProperties(this, defaultStyle, defaultStyle);
  };
  Object.defineProperty(TextStyle2.prototype, "align", {
    get: function() {
      return this._align;
    },
    set: function(align) {
      if (this._align !== align) {
        this._align = align;
        this.styleID++;
      }
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(TextStyle2.prototype, "breakWords", {
    get: function() {
      return this._breakWords;
    },
    set: function(breakWords) {
      if (this._breakWords !== breakWords) {
        this._breakWords = breakWords;
        this.styleID++;
      }
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(TextStyle2.prototype, "dropShadow", {
    get: function() {
      return this._dropShadow;
    },
    set: function(dropShadow) {
      if (this._dropShadow !== dropShadow) {
        this._dropShadow = dropShadow;
        this.styleID++;
      }
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(TextStyle2.prototype, "dropShadowAlpha", {
    get: function() {
      return this._dropShadowAlpha;
    },
    set: function(dropShadowAlpha) {
      if (this._dropShadowAlpha !== dropShadowAlpha) {
        this._dropShadowAlpha = dropShadowAlpha;
        this.styleID++;
      }
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(TextStyle2.prototype, "dropShadowAngle", {
    get: function() {
      return this._dropShadowAngle;
    },
    set: function(dropShadowAngle) {
      if (this._dropShadowAngle !== dropShadowAngle) {
        this._dropShadowAngle = dropShadowAngle;
        this.styleID++;
      }
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(TextStyle2.prototype, "dropShadowBlur", {
    get: function() {
      return this._dropShadowBlur;
    },
    set: function(dropShadowBlur) {
      if (this._dropShadowBlur !== dropShadowBlur) {
        this._dropShadowBlur = dropShadowBlur;
        this.styleID++;
      }
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(TextStyle2.prototype, "dropShadowColor", {
    get: function() {
      return this._dropShadowColor;
    },
    set: function(dropShadowColor) {
      var outputColor = getColor(dropShadowColor);
      if (this._dropShadowColor !== outputColor) {
        this._dropShadowColor = outputColor;
        this.styleID++;
      }
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(TextStyle2.prototype, "dropShadowDistance", {
    get: function() {
      return this._dropShadowDistance;
    },
    set: function(dropShadowDistance) {
      if (this._dropShadowDistance !== dropShadowDistance) {
        this._dropShadowDistance = dropShadowDistance;
        this.styleID++;
      }
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(TextStyle2.prototype, "fill", {
    get: function() {
      return this._fill;
    },
    set: function(fill) {
      var outputColor = getColor(fill);
      if (this._fill !== outputColor) {
        this._fill = outputColor;
        this.styleID++;
      }
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(TextStyle2.prototype, "fillGradientType", {
    get: function() {
      return this._fillGradientType;
    },
    set: function(fillGradientType) {
      if (this._fillGradientType !== fillGradientType) {
        this._fillGradientType = fillGradientType;
        this.styleID++;
      }
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(TextStyle2.prototype, "fillGradientStops", {
    get: function() {
      return this._fillGradientStops;
    },
    set: function(fillGradientStops) {
      if (!areArraysEqual(this._fillGradientStops, fillGradientStops)) {
        this._fillGradientStops = fillGradientStops;
        this.styleID++;
      }
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(TextStyle2.prototype, "fontFamily", {
    get: function() {
      return this._fontFamily;
    },
    set: function(fontFamily) {
      if (this.fontFamily !== fontFamily) {
        this._fontFamily = fontFamily;
        this.styleID++;
      }
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(TextStyle2.prototype, "fontSize", {
    get: function() {
      return this._fontSize;
    },
    set: function(fontSize) {
      if (this._fontSize !== fontSize) {
        this._fontSize = fontSize;
        this.styleID++;
      }
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(TextStyle2.prototype, "fontStyle", {
    get: function() {
      return this._fontStyle;
    },
    set: function(fontStyle) {
      if (this._fontStyle !== fontStyle) {
        this._fontStyle = fontStyle;
        this.styleID++;
      }
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(TextStyle2.prototype, "fontVariant", {
    get: function() {
      return this._fontVariant;
    },
    set: function(fontVariant) {
      if (this._fontVariant !== fontVariant) {
        this._fontVariant = fontVariant;
        this.styleID++;
      }
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(TextStyle2.prototype, "fontWeight", {
    get: function() {
      return this._fontWeight;
    },
    set: function(fontWeight) {
      if (this._fontWeight !== fontWeight) {
        this._fontWeight = fontWeight;
        this.styleID++;
      }
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(TextStyle2.prototype, "letterSpacing", {
    get: function() {
      return this._letterSpacing;
    },
    set: function(letterSpacing) {
      if (this._letterSpacing !== letterSpacing) {
        this._letterSpacing = letterSpacing;
        this.styleID++;
      }
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(TextStyle2.prototype, "lineHeight", {
    get: function() {
      return this._lineHeight;
    },
    set: function(lineHeight) {
      if (this._lineHeight !== lineHeight) {
        this._lineHeight = lineHeight;
        this.styleID++;
      }
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(TextStyle2.prototype, "leading", {
    get: function() {
      return this._leading;
    },
    set: function(leading) {
      if (this._leading !== leading) {
        this._leading = leading;
        this.styleID++;
      }
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(TextStyle2.prototype, "lineJoin", {
    get: function() {
      return this._lineJoin;
    },
    set: function(lineJoin) {
      if (this._lineJoin !== lineJoin) {
        this._lineJoin = lineJoin;
        this.styleID++;
      }
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(TextStyle2.prototype, "miterLimit", {
    get: function() {
      return this._miterLimit;
    },
    set: function(miterLimit) {
      if (this._miterLimit !== miterLimit) {
        this._miterLimit = miterLimit;
        this.styleID++;
      }
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(TextStyle2.prototype, "padding", {
    get: function() {
      return this._padding;
    },
    set: function(padding) {
      if (this._padding !== padding) {
        this._padding = padding;
        this.styleID++;
      }
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(TextStyle2.prototype, "stroke", {
    get: function() {
      return this._stroke;
    },
    set: function(stroke) {
      var outputColor = getColor(stroke);
      if (this._stroke !== outputColor) {
        this._stroke = outputColor;
        this.styleID++;
      }
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(TextStyle2.prototype, "strokeThickness", {
    get: function() {
      return this._strokeThickness;
    },
    set: function(strokeThickness) {
      if (this._strokeThickness !== strokeThickness) {
        this._strokeThickness = strokeThickness;
        this.styleID++;
      }
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(TextStyle2.prototype, "textBaseline", {
    get: function() {
      return this._textBaseline;
    },
    set: function(textBaseline) {
      if (this._textBaseline !== textBaseline) {
        this._textBaseline = textBaseline;
        this.styleID++;
      }
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(TextStyle2.prototype, "trim", {
    get: function() {
      return this._trim;
    },
    set: function(trim2) {
      if (this._trim !== trim2) {
        this._trim = trim2;
        this.styleID++;
      }
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(TextStyle2.prototype, "whiteSpace", {
    get: function() {
      return this._whiteSpace;
    },
    set: function(whiteSpace) {
      if (this._whiteSpace !== whiteSpace) {
        this._whiteSpace = whiteSpace;
        this.styleID++;
      }
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(TextStyle2.prototype, "wordWrap", {
    get: function() {
      return this._wordWrap;
    },
    set: function(wordWrap) {
      if (this._wordWrap !== wordWrap) {
        this._wordWrap = wordWrap;
        this.styleID++;
      }
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(TextStyle2.prototype, "wordWrapWidth", {
    get: function() {
      return this._wordWrapWidth;
    },
    set: function(wordWrapWidth) {
      if (this._wordWrapWidth !== wordWrapWidth) {
        this._wordWrapWidth = wordWrapWidth;
        this.styleID++;
      }
    },
    enumerable: false,
    configurable: true
  });
  TextStyle2.prototype.toFontString = function() {
    var fontSizeString = typeof this.fontSize === "number" ? this.fontSize + "px" : this.fontSize;
    var fontFamilies = this.fontFamily;
    if (!Array.isArray(this.fontFamily)) {
      fontFamilies = this.fontFamily.split(",");
    }
    for (var i2 = fontFamilies.length - 1; i2 >= 0; i2--) {
      var fontFamily = fontFamilies[i2].trim();
      if (!/([\"\'])[^\'\"]+\1/.test(fontFamily) && genericFontFamilies.indexOf(fontFamily) < 0) {
        fontFamily = '"' + fontFamily + '"';
      }
      fontFamilies[i2] = fontFamily;
    }
    return this.fontStyle + " " + this.fontVariant + " " + this.fontWeight + " " + fontSizeString + " " + fontFamilies.join(",");
  };
  return TextStyle2;
}();
function getSingleColor(color) {
  if (typeof color === "number") {
    return hex2string(color);
  } else if (typeof color === "string") {
    if (color.indexOf("0x") === 0) {
      color = color.replace("0x", "#");
    }
  }
  return color;
}
function getColor(color) {
  if (!Array.isArray(color)) {
    return getSingleColor(color);
  } else {
    for (var i2 = 0; i2 < color.length; ++i2) {
      color[i2] = getSingleColor(color[i2]);
    }
    return color;
  }
}
function areArraysEqual(array1, array2) {
  if (!Array.isArray(array1) || !Array.isArray(array2)) {
    return false;
  }
  if (array1.length !== array2.length) {
    return false;
  }
  for (var i2 = 0; i2 < array1.length; ++i2) {
    if (array1[i2] !== array2[i2]) {
      return false;
    }
  }
  return true;
}
function deepCopyProperties(target, source, propertyObj) {
  for (var prop in propertyObj) {
    if (Array.isArray(source[prop])) {
      target[prop] = source[prop].slice();
    } else {
      target[prop] = source[prop];
    }
  }
}
var TextMetrics = function() {
  function TextMetrics2(text2, style, width, height, lines, lineWidths, lineHeight, maxLineWidth, fontProperties) {
    this.text = text2;
    this.style = style;
    this.width = width;
    this.height = height;
    this.lines = lines;
    this.lineWidths = lineWidths;
    this.lineHeight = lineHeight;
    this.maxLineWidth = maxLineWidth;
    this.fontProperties = fontProperties;
  }
  TextMetrics2.measureText = function(text2, style, wordWrap, canvas2) {
    if (canvas2 === void 0) {
      canvas2 = TextMetrics2._canvas;
    }
    wordWrap = wordWrap === void 0 || wordWrap === null ? style.wordWrap : wordWrap;
    var font = style.toFontString();
    var fontProperties = TextMetrics2.measureFont(font);
    if (fontProperties.fontSize === 0) {
      fontProperties.fontSize = style.fontSize;
      fontProperties.ascent = style.fontSize;
    }
    var context2 = canvas2.getContext("2d");
    context2.font = font;
    var outputText = wordWrap ? TextMetrics2.wordWrap(text2, style, canvas2) : text2;
    var lines = outputText.split(/(?:\r\n|\r|\n)/);
    var lineWidths = new Array(lines.length);
    var maxLineWidth = 0;
    for (var i2 = 0; i2 < lines.length; i2++) {
      var lineWidth = context2.measureText(lines[i2]).width + (lines[i2].length - 1) * style.letterSpacing;
      lineWidths[i2] = lineWidth;
      maxLineWidth = Math.max(maxLineWidth, lineWidth);
    }
    var width = maxLineWidth + style.strokeThickness;
    if (style.dropShadow) {
      width += style.dropShadowDistance;
    }
    var lineHeight = style.lineHeight || fontProperties.fontSize + style.strokeThickness;
    var height = Math.max(lineHeight, fontProperties.fontSize + style.strokeThickness) + (lines.length - 1) * (lineHeight + style.leading);
    if (style.dropShadow) {
      height += style.dropShadowDistance;
    }
    return new TextMetrics2(text2, style, width, height, lines, lineWidths, lineHeight + style.leading, maxLineWidth, fontProperties);
  };
  TextMetrics2.wordWrap = function(text2, style, canvas2) {
    if (canvas2 === void 0) {
      canvas2 = TextMetrics2._canvas;
    }
    var context2 = canvas2.getContext("2d");
    var width = 0;
    var line = "";
    var lines = "";
    var cache2 = /* @__PURE__ */ Object.create(null);
    var letterSpacing = style.letterSpacing, whiteSpace = style.whiteSpace;
    var collapseSpaces = TextMetrics2.collapseSpaces(whiteSpace);
    var collapseNewlines = TextMetrics2.collapseNewlines(whiteSpace);
    var canPrependSpaces = !collapseSpaces;
    var wordWrapWidth = style.wordWrapWidth + letterSpacing;
    var tokens = TextMetrics2.tokenize(text2);
    for (var i2 = 0; i2 < tokens.length; i2++) {
      var token = tokens[i2];
      if (TextMetrics2.isNewline(token)) {
        if (!collapseNewlines) {
          lines += TextMetrics2.addLine(line);
          canPrependSpaces = !collapseSpaces;
          line = "";
          width = 0;
          continue;
        }
        token = " ";
      }
      if (collapseSpaces) {
        var currIsBreakingSpace = TextMetrics2.isBreakingSpace(token);
        var lastIsBreakingSpace = TextMetrics2.isBreakingSpace(line[line.length - 1]);
        if (currIsBreakingSpace && lastIsBreakingSpace) {
          continue;
        }
      }
      var tokenWidth = TextMetrics2.getFromCache(token, letterSpacing, cache2, context2);
      if (tokenWidth > wordWrapWidth) {
        if (line !== "") {
          lines += TextMetrics2.addLine(line);
          line = "";
          width = 0;
        }
        if (TextMetrics2.canBreakWords(token, style.breakWords)) {
          var characters = TextMetrics2.wordWrapSplit(token);
          for (var j2 = 0; j2 < characters.length; j2++) {
            var char = characters[j2];
            var k = 1;
            while (characters[j2 + k]) {
              var nextChar = characters[j2 + k];
              var lastChar = char[char.length - 1];
              if (!TextMetrics2.canBreakChars(lastChar, nextChar, token, j2, style.breakWords)) {
                char += nextChar;
              } else {
                break;
              }
              k++;
            }
            j2 += char.length - 1;
            var characterWidth = TextMetrics2.getFromCache(char, letterSpacing, cache2, context2);
            if (characterWidth + width > wordWrapWidth) {
              lines += TextMetrics2.addLine(line);
              canPrependSpaces = false;
              line = "";
              width = 0;
            }
            line += char;
            width += characterWidth;
          }
        } else {
          if (line.length > 0) {
            lines += TextMetrics2.addLine(line);
            line = "";
            width = 0;
          }
          var isLastToken = i2 === tokens.length - 1;
          lines += TextMetrics2.addLine(token, !isLastToken);
          canPrependSpaces = false;
          line = "";
          width = 0;
        }
      } else {
        if (tokenWidth + width > wordWrapWidth) {
          canPrependSpaces = false;
          lines += TextMetrics2.addLine(line);
          line = "";
          width = 0;
        }
        if (line.length > 0 || !TextMetrics2.isBreakingSpace(token) || canPrependSpaces) {
          line += token;
          width += tokenWidth;
        }
      }
    }
    lines += TextMetrics2.addLine(line, false);
    return lines;
  };
  TextMetrics2.addLine = function(line, newLine) {
    if (newLine === void 0) {
      newLine = true;
    }
    line = TextMetrics2.trimRight(line);
    line = newLine ? line + "\n" : line;
    return line;
  };
  TextMetrics2.getFromCache = function(key, letterSpacing, cache2, context2) {
    var width = cache2[key];
    if (typeof width !== "number") {
      var spacing = key.length * letterSpacing;
      width = context2.measureText(key).width + spacing;
      cache2[key] = width;
    }
    return width;
  };
  TextMetrics2.collapseSpaces = function(whiteSpace) {
    return whiteSpace === "normal" || whiteSpace === "pre-line";
  };
  TextMetrics2.collapseNewlines = function(whiteSpace) {
    return whiteSpace === "normal";
  };
  TextMetrics2.trimRight = function(text2) {
    if (typeof text2 !== "string") {
      return "";
    }
    for (var i2 = text2.length - 1; i2 >= 0; i2--) {
      var char = text2[i2];
      if (!TextMetrics2.isBreakingSpace(char)) {
        break;
      }
      text2 = text2.slice(0, -1);
    }
    return text2;
  };
  TextMetrics2.isNewline = function(char) {
    if (typeof char !== "string") {
      return false;
    }
    return TextMetrics2._newlines.indexOf(char.charCodeAt(0)) >= 0;
  };
  TextMetrics2.isBreakingSpace = function(char, _nextChar) {
    if (typeof char !== "string") {
      return false;
    }
    return TextMetrics2._breakingSpaces.indexOf(char.charCodeAt(0)) >= 0;
  };
  TextMetrics2.tokenize = function(text2) {
    var tokens = [];
    var token = "";
    if (typeof text2 !== "string") {
      return tokens;
    }
    for (var i2 = 0; i2 < text2.length; i2++) {
      var char = text2[i2];
      var nextChar = text2[i2 + 1];
      if (TextMetrics2.isBreakingSpace(char, nextChar) || TextMetrics2.isNewline(char)) {
        if (token !== "") {
          tokens.push(token);
          token = "";
        }
        tokens.push(char);
        continue;
      }
      token += char;
    }
    if (token !== "") {
      tokens.push(token);
    }
    return tokens;
  };
  TextMetrics2.canBreakWords = function(_token, breakWords) {
    return breakWords;
  };
  TextMetrics2.canBreakChars = function(_char, _nextChar, _token, _index, _breakWords) {
    return true;
  };
  TextMetrics2.wordWrapSplit = function(token) {
    return token.split("");
  };
  TextMetrics2.measureFont = function(font) {
    if (TextMetrics2._fonts[font]) {
      return TextMetrics2._fonts[font];
    }
    var properties = {
      ascent: 0,
      descent: 0,
      fontSize: 0
    };
    var canvas2 = TextMetrics2._canvas;
    var context2 = TextMetrics2._context;
    context2.font = font;
    var metricsString = TextMetrics2.METRICS_STRING + TextMetrics2.BASELINE_SYMBOL;
    var width = Math.ceil(context2.measureText(metricsString).width);
    var baseline = Math.ceil(context2.measureText(TextMetrics2.BASELINE_SYMBOL).width);
    var height = Math.ceil(TextMetrics2.HEIGHT_MULTIPLIER * baseline);
    baseline = baseline * TextMetrics2.BASELINE_MULTIPLIER | 0;
    canvas2.width = width;
    canvas2.height = height;
    context2.fillStyle = "#f00";
    context2.fillRect(0, 0, width, height);
    context2.font = font;
    context2.textBaseline = "alphabetic";
    context2.fillStyle = "#000";
    context2.fillText(metricsString, 0, baseline);
    var imagedata = context2.getImageData(0, 0, width, height).data;
    var pixels = imagedata.length;
    var line = width * 4;
    var i2 = 0;
    var idx = 0;
    var stop = false;
    for (i2 = 0; i2 < baseline; ++i2) {
      for (var j2 = 0; j2 < line; j2 += 4) {
        if (imagedata[idx + j2] !== 255) {
          stop = true;
          break;
        }
      }
      if (!stop) {
        idx += line;
      } else {
        break;
      }
    }
    properties.ascent = baseline - i2;
    idx = pixels - line;
    stop = false;
    for (i2 = height; i2 > baseline; --i2) {
      for (var j2 = 0; j2 < line; j2 += 4) {
        if (imagedata[idx + j2] !== 255) {
          stop = true;
          break;
        }
      }
      if (!stop) {
        idx -= line;
      } else {
        break;
      }
    }
    properties.descent = i2 - baseline;
    properties.fontSize = properties.ascent + properties.descent;
    TextMetrics2._fonts[font] = properties;
    return properties;
  };
  TextMetrics2.clearMetrics = function(font) {
    if (font === void 0) {
      font = "";
    }
    if (font) {
      delete TextMetrics2._fonts[font];
    } else {
      TextMetrics2._fonts = {};
    }
  };
  return TextMetrics2;
}();
var canvas = function() {
  try {
    var c2 = new OffscreenCanvas(0, 0);
    var context2 = c2.getContext("2d");
    if (context2 && context2.measureText) {
      return c2;
    }
    return document.createElement("canvas");
  } catch (ex) {
    return document.createElement("canvas");
  }
}();
canvas.width = canvas.height = 10;
TextMetrics._canvas = canvas;
TextMetrics._context = canvas.getContext("2d");
TextMetrics._fonts = {};
TextMetrics.METRICS_STRING = "|\xC9q\xC5";
TextMetrics.BASELINE_SYMBOL = "M";
TextMetrics.BASELINE_MULTIPLIER = 1.4;
TextMetrics.HEIGHT_MULTIPLIER = 2;
TextMetrics._newlines = [
  10,
  13
];
TextMetrics._breakingSpaces = [
  9,
  32,
  8192,
  8193,
  8194,
  8195,
  8196,
  8197,
  8198,
  8200,
  8201,
  8202,
  8287,
  12288
];
var defaultDestroyOptions = {
  texture: true,
  children: false,
  baseTexture: true
};
var Text = function(_super) {
  __extends$j(Text2, _super);
  function Text2(text2, style, canvas2) {
    var _this = this;
    var ownCanvas = false;
    if (!canvas2) {
      canvas2 = document.createElement("canvas");
      ownCanvas = true;
    }
    canvas2.width = 3;
    canvas2.height = 3;
    var texture = Texture.from(canvas2);
    texture.orig = new Rectangle();
    texture.trim = new Rectangle();
    _this = _super.call(this, texture) || this;
    _this._ownCanvas = ownCanvas;
    _this.canvas = canvas2;
    _this.context = _this.canvas.getContext("2d");
    _this._resolution = settings.RESOLUTION;
    _this._autoResolution = true;
    _this._text = null;
    _this._style = null;
    _this._styleListener = null;
    _this._font = "";
    _this.text = text2;
    _this.style = style;
    _this.localStyleID = -1;
    return _this;
  }
  Text2.prototype.updateText = function(respectDirty) {
    var style = this._style;
    if (this.localStyleID !== style.styleID) {
      this.dirty = true;
      this.localStyleID = style.styleID;
    }
    if (!this.dirty && respectDirty) {
      return;
    }
    this._font = this._style.toFontString();
    var context2 = this.context;
    var measured = TextMetrics.measureText(this._text || " ", this._style, this._style.wordWrap, this.canvas);
    var width = measured.width;
    var height = measured.height;
    var lines = measured.lines;
    var lineHeight = measured.lineHeight;
    var lineWidths = measured.lineWidths;
    var maxLineWidth = measured.maxLineWidth;
    var fontProperties = measured.fontProperties;
    this.canvas.width = Math.ceil(Math.ceil(Math.max(1, width) + style.padding * 2) * this._resolution);
    this.canvas.height = Math.ceil(Math.ceil(Math.max(1, height) + style.padding * 2) * this._resolution);
    context2.scale(this._resolution, this._resolution);
    context2.clearRect(0, 0, this.canvas.width, this.canvas.height);
    context2.font = this._font;
    context2.lineWidth = style.strokeThickness;
    context2.textBaseline = style.textBaseline;
    context2.lineJoin = style.lineJoin;
    context2.miterLimit = style.miterLimit;
    var linePositionX;
    var linePositionY;
    var passesCount = style.dropShadow ? 2 : 1;
    for (var i2 = 0; i2 < passesCount; ++i2) {
      var isShadowPass = style.dropShadow && i2 === 0;
      var dsOffsetText = isShadowPass ? Math.ceil(Math.max(1, height) + style.padding * 2) : 0;
      var dsOffsetShadow = dsOffsetText * this._resolution;
      if (isShadowPass) {
        context2.fillStyle = "black";
        context2.strokeStyle = "black";
        var dropShadowColor = style.dropShadowColor;
        var rgb = hex2rgb(typeof dropShadowColor === "number" ? dropShadowColor : string2hex(dropShadowColor));
        var dropShadowBlur = style.dropShadowBlur * this._resolution;
        var dropShadowDistance = style.dropShadowDistance * this._resolution;
        context2.shadowColor = "rgba(" + rgb[0] * 255 + "," + rgb[1] * 255 + "," + rgb[2] * 255 + "," + style.dropShadowAlpha + ")";
        context2.shadowBlur = dropShadowBlur;
        context2.shadowOffsetX = Math.cos(style.dropShadowAngle) * dropShadowDistance;
        context2.shadowOffsetY = Math.sin(style.dropShadowAngle) * dropShadowDistance + dsOffsetShadow;
      } else {
        context2.fillStyle = this._generateFillStyle(style, lines, measured);
        context2.strokeStyle = style.stroke;
        context2.shadowColor = "black";
        context2.shadowBlur = 0;
        context2.shadowOffsetX = 0;
        context2.shadowOffsetY = 0;
      }
      var linePositionYShift = (lineHeight - fontProperties.fontSize) / 2;
      if (!Text2.nextLineHeightBehavior || lineHeight - fontProperties.fontSize < 0) {
        linePositionYShift = 0;
      }
      for (var i_1 = 0; i_1 < lines.length; i_1++) {
        linePositionX = style.strokeThickness / 2;
        linePositionY = style.strokeThickness / 2 + i_1 * lineHeight + fontProperties.ascent + linePositionYShift;
        if (style.align === "right") {
          linePositionX += maxLineWidth - lineWidths[i_1];
        } else if (style.align === "center") {
          linePositionX += (maxLineWidth - lineWidths[i_1]) / 2;
        }
        if (style.stroke && style.strokeThickness) {
          this.drawLetterSpacing(lines[i_1], linePositionX + style.padding, linePositionY + style.padding - dsOffsetText, true);
        }
        if (style.fill) {
          this.drawLetterSpacing(lines[i_1], linePositionX + style.padding, linePositionY + style.padding - dsOffsetText);
        }
      }
    }
    this.updateTexture();
  };
  Text2.prototype.drawLetterSpacing = function(text2, x2, y2, isStroke) {
    if (isStroke === void 0) {
      isStroke = false;
    }
    var style = this._style;
    var letterSpacing = style.letterSpacing;
    var supportLetterSpacing = Text2.experimentalLetterSpacing && ("letterSpacing" in CanvasRenderingContext2D.prototype || "textLetterSpacing" in CanvasRenderingContext2D.prototype);
    if (letterSpacing === 0 || supportLetterSpacing) {
      if (supportLetterSpacing) {
        this.context.letterSpacing = letterSpacing;
        this.context.textLetterSpacing = letterSpacing;
      }
      if (isStroke) {
        this.context.strokeText(text2, x2, y2);
      } else {
        this.context.fillText(text2, x2, y2);
      }
      return;
    }
    var currentPosition = x2;
    var stringArray = Array.from ? Array.from(text2) : text2.split("");
    var previousWidth = this.context.measureText(text2).width;
    var currentWidth = 0;
    for (var i2 = 0; i2 < stringArray.length; ++i2) {
      var currentChar = stringArray[i2];
      if (isStroke) {
        this.context.strokeText(currentChar, currentPosition, y2);
      } else {
        this.context.fillText(currentChar, currentPosition, y2);
      }
      var textStr = "";
      for (var j2 = i2 + 1; j2 < stringArray.length; ++j2) {
        textStr += stringArray[j2];
      }
      currentWidth = this.context.measureText(textStr).width;
      currentPosition += previousWidth - currentWidth + letterSpacing;
      previousWidth = currentWidth;
    }
  };
  Text2.prototype.updateTexture = function() {
    var canvas2 = this.canvas;
    if (this._style.trim) {
      var trimmed = trimCanvas(canvas2);
      if (trimmed.data) {
        canvas2.width = trimmed.width;
        canvas2.height = trimmed.height;
        this.context.putImageData(trimmed.data, 0, 0);
      }
    }
    var texture = this._texture;
    var style = this._style;
    var padding = style.trim ? 0 : style.padding;
    var baseTexture = texture.baseTexture;
    texture.trim.width = texture._frame.width = canvas2.width / this._resolution;
    texture.trim.height = texture._frame.height = canvas2.height / this._resolution;
    texture.trim.x = -padding;
    texture.trim.y = -padding;
    texture.orig.width = texture._frame.width - padding * 2;
    texture.orig.height = texture._frame.height - padding * 2;
    this._onTextureUpdate();
    baseTexture.setRealSize(canvas2.width, canvas2.height, this._resolution);
    texture.updateUvs();
    this._recursivePostUpdateTransform();
    this.dirty = false;
  };
  Text2.prototype._render = function(renderer) {
    if (this._autoResolution && this._resolution !== renderer.resolution) {
      this._resolution = renderer.resolution;
      this.dirty = true;
    }
    this.updateText(true);
    _super.prototype._render.call(this, renderer);
  };
  Text2.prototype.getLocalBounds = function(rect) {
    this.updateText(true);
    return _super.prototype.getLocalBounds.call(this, rect);
  };
  Text2.prototype._calculateBounds = function() {
    this.updateText(true);
    this.calculateVertices();
    this._bounds.addQuad(this.vertexData);
  };
  Text2.prototype._generateFillStyle = function(style, lines, metrics) {
    var fillStyle = style.fill;
    if (!Array.isArray(fillStyle)) {
      return fillStyle;
    } else if (fillStyle.length === 1) {
      return fillStyle[0];
    }
    var gradient;
    var dropShadowCorrection = style.dropShadow ? style.dropShadowDistance : 0;
    var padding = style.padding || 0;
    var width = this.canvas.width / this._resolution - dropShadowCorrection - padding * 2;
    var height = this.canvas.height / this._resolution - dropShadowCorrection - padding * 2;
    var fill = fillStyle.slice();
    var fillGradientStops = style.fillGradientStops.slice();
    if (!fillGradientStops.length) {
      var lengthPlus1 = fill.length + 1;
      for (var i2 = 1; i2 < lengthPlus1; ++i2) {
        fillGradientStops.push(i2 / lengthPlus1);
      }
    }
    fill.unshift(fillStyle[0]);
    fillGradientStops.unshift(0);
    fill.push(fillStyle[fillStyle.length - 1]);
    fillGradientStops.push(1);
    if (style.fillGradientType === TEXT_GRADIENT.LINEAR_VERTICAL) {
      gradient = this.context.createLinearGradient(width / 2, padding, width / 2, height + padding);
      var textHeight = metrics.fontProperties.fontSize + style.strokeThickness;
      for (var i2 = 0; i2 < lines.length; i2++) {
        var lastLineBottom = metrics.lineHeight * (i2 - 1) + textHeight;
        var thisLineTop = metrics.lineHeight * i2;
        var thisLineGradientStart = thisLineTop;
        if (i2 > 0 && lastLineBottom > thisLineTop) {
          thisLineGradientStart = (thisLineTop + lastLineBottom) / 2;
        }
        var thisLineBottom = thisLineTop + textHeight;
        var nextLineTop = metrics.lineHeight * (i2 + 1);
        var thisLineGradientEnd = thisLineBottom;
        if (i2 + 1 < lines.length && nextLineTop < thisLineBottom) {
          thisLineGradientEnd = (thisLineBottom + nextLineTop) / 2;
        }
        var gradStopLineHeight = (thisLineGradientEnd - thisLineGradientStart) / height;
        for (var j2 = 0; j2 < fill.length; j2++) {
          var lineStop = 0;
          if (typeof fillGradientStops[j2] === "number") {
            lineStop = fillGradientStops[j2];
          } else {
            lineStop = j2 / fill.length;
          }
          var globalStop = Math.min(1, Math.max(0, thisLineGradientStart / height + lineStop * gradStopLineHeight));
          globalStop = Number(globalStop.toFixed(5));
          gradient.addColorStop(globalStop, fill[j2]);
        }
      }
    } else {
      gradient = this.context.createLinearGradient(padding, height / 2, width + padding, height / 2);
      var totalIterations = fill.length + 1;
      var currentIteration = 1;
      for (var i2 = 0; i2 < fill.length; i2++) {
        var stop = void 0;
        if (typeof fillGradientStops[i2] === "number") {
          stop = fillGradientStops[i2];
        } else {
          stop = currentIteration / totalIterations;
        }
        gradient.addColorStop(stop, fill[i2]);
        currentIteration++;
      }
    }
    return gradient;
  };
  Text2.prototype.destroy = function(options) {
    if (typeof options === "boolean") {
      options = { children: options };
    }
    options = Object.assign({}, defaultDestroyOptions, options);
    _super.prototype.destroy.call(this, options);
    if (this._ownCanvas) {
      this.canvas.height = this.canvas.width = 0;
    }
    this.context = null;
    this.canvas = null;
    this._style = null;
  };
  Object.defineProperty(Text2.prototype, "width", {
    get: function() {
      this.updateText(true);
      return Math.abs(this.scale.x) * this._texture.orig.width;
    },
    set: function(value) {
      this.updateText(true);
      var s2 = sign(this.scale.x) || 1;
      this.scale.x = s2 * value / this._texture.orig.width;
      this._width = value;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Text2.prototype, "height", {
    get: function() {
      this.updateText(true);
      return Math.abs(this.scale.y) * this._texture.orig.height;
    },
    set: function(value) {
      this.updateText(true);
      var s2 = sign(this.scale.y) || 1;
      this.scale.y = s2 * value / this._texture.orig.height;
      this._height = value;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Text2.prototype, "style", {
    get: function() {
      return this._style;
    },
    set: function(style) {
      style = style || {};
      if (style instanceof TextStyle) {
        this._style = style;
      } else {
        this._style = new TextStyle(style);
      }
      this.localStyleID = -1;
      this.dirty = true;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Text2.prototype, "text", {
    get: function() {
      return this._text;
    },
    set: function(text2) {
      text2 = String(text2 === null || text2 === void 0 ? "" : text2);
      if (this._text === text2) {
        return;
      }
      this._text = text2;
      this.dirty = true;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Text2.prototype, "resolution", {
    get: function() {
      return this._resolution;
    },
    set: function(value) {
      this._autoResolution = false;
      if (this._resolution === value) {
        return;
      }
      this._resolution = value;
      this.dirty = true;
    },
    enumerable: false,
    configurable: true
  });
  Text2.nextLineHeightBehavior = false;
  Text2.experimentalLetterSpacing = false;
  return Text2;
}(Sprite);
/*!
 * @pixi/prepare - v6.3.0
 * Compiled Wed, 23 Mar 2022 18:58:56 UTC
 *
 * @pixi/prepare is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
settings.UPLOADS_PER_FRAME = 4;
/*! *****************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */
var extendStatics$i = function(d2, b2) {
  extendStatics$i = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {
    d3.__proto__ = b3;
  } || function(d3, b3) {
    for (var p2 in b3) {
      if (b3.hasOwnProperty(p2)) {
        d3[p2] = b3[p2];
      }
    }
  };
  return extendStatics$i(d2, b2);
};
function __extends$i(d2, b2) {
  extendStatics$i(d2, b2);
  function __() {
    this.constructor = d2;
  }
  d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
}
var CountLimiter = function() {
  function CountLimiter2(maxItemsPerFrame) {
    this.maxItemsPerFrame = maxItemsPerFrame;
    this.itemsLeft = 0;
  }
  CountLimiter2.prototype.beginFrame = function() {
    this.itemsLeft = this.maxItemsPerFrame;
  };
  CountLimiter2.prototype.allowedToUpload = function() {
    return this.itemsLeft-- > 0;
  };
  return CountLimiter2;
}();
function findMultipleBaseTextures(item, queue) {
  var result = false;
  if (item && item._textures && item._textures.length) {
    for (var i2 = 0; i2 < item._textures.length; i2++) {
      if (item._textures[i2] instanceof Texture) {
        var baseTexture = item._textures[i2].baseTexture;
        if (queue.indexOf(baseTexture) === -1) {
          queue.push(baseTexture);
          result = true;
        }
      }
    }
  }
  return result;
}
function findBaseTexture(item, queue) {
  if (item.baseTexture instanceof BaseTexture) {
    var texture = item.baseTexture;
    if (queue.indexOf(texture) === -1) {
      queue.push(texture);
    }
    return true;
  }
  return false;
}
function findTexture(item, queue) {
  if (item._texture && item._texture instanceof Texture) {
    var texture = item._texture.baseTexture;
    if (queue.indexOf(texture) === -1) {
      queue.push(texture);
    }
    return true;
  }
  return false;
}
function drawText(_helper, item) {
  if (item instanceof Text) {
    item.updateText(true);
    return true;
  }
  return false;
}
function calculateTextStyle(_helper, item) {
  if (item instanceof TextStyle) {
    var font = item.toFontString();
    TextMetrics.measureFont(font);
    return true;
  }
  return false;
}
function findText(item, queue) {
  if (item instanceof Text) {
    if (queue.indexOf(item.style) === -1) {
      queue.push(item.style);
    }
    if (queue.indexOf(item) === -1) {
      queue.push(item);
    }
    var texture = item._texture.baseTexture;
    if (queue.indexOf(texture) === -1) {
      queue.push(texture);
    }
    return true;
  }
  return false;
}
function findTextStyle(item, queue) {
  if (item instanceof TextStyle) {
    if (queue.indexOf(item) === -1) {
      queue.push(item);
    }
    return true;
  }
  return false;
}
var BasePrepare = function() {
  function BasePrepare2(renderer) {
    var _this = this;
    this.limiter = new CountLimiter(settings.UPLOADS_PER_FRAME);
    this.renderer = renderer;
    this.uploadHookHelper = null;
    this.queue = [];
    this.addHooks = [];
    this.uploadHooks = [];
    this.completes = [];
    this.ticking = false;
    this.delayedTick = function() {
      if (!_this.queue) {
        return;
      }
      _this.prepareItems();
    };
    this.registerFindHook(findText);
    this.registerFindHook(findTextStyle);
    this.registerFindHook(findMultipleBaseTextures);
    this.registerFindHook(findBaseTexture);
    this.registerFindHook(findTexture);
    this.registerUploadHook(drawText);
    this.registerUploadHook(calculateTextStyle);
  }
  BasePrepare2.prototype.upload = function(item, done) {
    if (typeof item === "function") {
      done = item;
      item = null;
    }
    if (item) {
      this.add(item);
    }
    if (this.queue.length) {
      if (done) {
        this.completes.push(done);
      }
      if (!this.ticking) {
        this.ticking = true;
        Ticker.system.addOnce(this.tick, this, UPDATE_PRIORITY.UTILITY);
      }
    } else if (done) {
      done();
    }
  };
  BasePrepare2.prototype.tick = function() {
    setTimeout(this.delayedTick, 0);
  };
  BasePrepare2.prototype.prepareItems = function() {
    this.limiter.beginFrame();
    while (this.queue.length && this.limiter.allowedToUpload()) {
      var item = this.queue[0];
      var uploaded = false;
      if (item && !item._destroyed) {
        for (var i2 = 0, len = this.uploadHooks.length; i2 < len; i2++) {
          if (this.uploadHooks[i2](this.uploadHookHelper, item)) {
            this.queue.shift();
            uploaded = true;
            break;
          }
        }
      }
      if (!uploaded) {
        this.queue.shift();
      }
    }
    if (!this.queue.length) {
      this.ticking = false;
      var completes = this.completes.slice(0);
      this.completes.length = 0;
      for (var i2 = 0, len = completes.length; i2 < len; i2++) {
        completes[i2]();
      }
    } else {
      Ticker.system.addOnce(this.tick, this, UPDATE_PRIORITY.UTILITY);
    }
  };
  BasePrepare2.prototype.registerFindHook = function(addHook) {
    if (addHook) {
      this.addHooks.push(addHook);
    }
    return this;
  };
  BasePrepare2.prototype.registerUploadHook = function(uploadHook) {
    if (uploadHook) {
      this.uploadHooks.push(uploadHook);
    }
    return this;
  };
  BasePrepare2.prototype.add = function(item) {
    for (var i2 = 0, len = this.addHooks.length; i2 < len; i2++) {
      if (this.addHooks[i2](item, this.queue)) {
        break;
      }
    }
    if (item instanceof Container) {
      for (var i2 = item.children.length - 1; i2 >= 0; i2--) {
        this.add(item.children[i2]);
      }
    }
    return this;
  };
  BasePrepare2.prototype.destroy = function() {
    if (this.ticking) {
      Ticker.system.remove(this.tick, this);
    }
    this.ticking = false;
    this.addHooks = null;
    this.uploadHooks = null;
    this.renderer = null;
    this.completes = null;
    this.queue = null;
    this.limiter = null;
    this.uploadHookHelper = null;
  };
  return BasePrepare2;
}();
function uploadBaseTextures(renderer, item) {
  if (item instanceof BaseTexture) {
    if (!item._glTextures[renderer.CONTEXT_UID]) {
      renderer.texture.bind(item);
    }
    return true;
  }
  return false;
}
function uploadGraphics(renderer, item) {
  if (!(item instanceof Graphics)) {
    return false;
  }
  var geometry = item.geometry;
  item.finishPoly();
  geometry.updateBatches();
  var batches = geometry.batches;
  for (var i2 = 0; i2 < batches.length; i2++) {
    var texture = batches[i2].style.texture;
    if (texture) {
      uploadBaseTextures(renderer, texture.baseTexture);
    }
  }
  if (!geometry.batchable) {
    renderer.geometry.bind(geometry, item._resolveDirectShader(renderer));
  }
  return true;
}
function findGraphics(item, queue) {
  if (item instanceof Graphics) {
    queue.push(item);
    return true;
  }
  return false;
}
var Prepare = function(_super) {
  __extends$i(Prepare2, _super);
  function Prepare2(renderer) {
    var _this = _super.call(this, renderer) || this;
    _this.uploadHookHelper = _this.renderer;
    _this.registerFindHook(findGraphics);
    _this.registerUploadHook(uploadBaseTextures);
    _this.registerUploadHook(uploadGraphics);
    return _this;
  }
  return Prepare2;
}(BasePrepare);
/*!
 * @pixi/spritesheet - v6.3.0
 * Compiled Wed, 23 Mar 2022 18:58:56 UTC
 *
 * @pixi/spritesheet is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
var Spritesheet = function() {
  function Spritesheet2(texture, data, resolutionFilename) {
    if (resolutionFilename === void 0) {
      resolutionFilename = null;
    }
    this._texture = texture instanceof Texture ? texture : null;
    this.baseTexture = texture instanceof BaseTexture ? texture : this._texture.baseTexture;
    this.textures = {};
    this.animations = {};
    this.data = data;
    var resource = this.baseTexture.resource;
    this.resolution = this._updateResolution(resolutionFilename || (resource ? resource.url : null));
    this._frames = this.data.frames;
    this._frameKeys = Object.keys(this._frames);
    this._batchIndex = 0;
    this._callback = null;
  }
  Spritesheet2.prototype._updateResolution = function(resolutionFilename) {
    if (resolutionFilename === void 0) {
      resolutionFilename = null;
    }
    var scale = this.data.meta.scale;
    var resolution = getResolutionOfUrl(resolutionFilename, null);
    if (resolution === null) {
      resolution = scale !== void 0 ? parseFloat(scale) : 1;
    }
    if (resolution !== 1) {
      this.baseTexture.setResolution(resolution);
    }
    return resolution;
  };
  Spritesheet2.prototype.parse = function(callback) {
    this._batchIndex = 0;
    this._callback = callback;
    if (this._frameKeys.length <= Spritesheet2.BATCH_SIZE) {
      this._processFrames(0);
      this._processAnimations();
      this._parseComplete();
    } else {
      this._nextBatch();
    }
  };
  Spritesheet2.prototype._processFrames = function(initialFrameIndex) {
    var frameIndex = initialFrameIndex;
    var maxFrames = Spritesheet2.BATCH_SIZE;
    while (frameIndex - initialFrameIndex < maxFrames && frameIndex < this._frameKeys.length) {
      var i2 = this._frameKeys[frameIndex];
      var data = this._frames[i2];
      var rect = data.frame;
      if (rect) {
        var frame = null;
        var trim2 = null;
        var sourceSize = data.trimmed !== false && data.sourceSize ? data.sourceSize : data.frame;
        var orig = new Rectangle(0, 0, Math.floor(sourceSize.w) / this.resolution, Math.floor(sourceSize.h) / this.resolution);
        if (data.rotated) {
          frame = new Rectangle(Math.floor(rect.x) / this.resolution, Math.floor(rect.y) / this.resolution, Math.floor(rect.h) / this.resolution, Math.floor(rect.w) / this.resolution);
        } else {
          frame = new Rectangle(Math.floor(rect.x) / this.resolution, Math.floor(rect.y) / this.resolution, Math.floor(rect.w) / this.resolution, Math.floor(rect.h) / this.resolution);
        }
        if (data.trimmed !== false && data.spriteSourceSize) {
          trim2 = new Rectangle(Math.floor(data.spriteSourceSize.x) / this.resolution, Math.floor(data.spriteSourceSize.y) / this.resolution, Math.floor(rect.w) / this.resolution, Math.floor(rect.h) / this.resolution);
        }
        this.textures[i2] = new Texture(this.baseTexture, frame, orig, trim2, data.rotated ? 2 : 0, data.anchor);
        Texture.addToCache(this.textures[i2], i2);
      }
      frameIndex++;
    }
  };
  Spritesheet2.prototype._processAnimations = function() {
    var animations = this.data.animations || {};
    for (var animName in animations) {
      this.animations[animName] = [];
      for (var i2 = 0; i2 < animations[animName].length; i2++) {
        var frameName = animations[animName][i2];
        this.animations[animName].push(this.textures[frameName]);
      }
    }
  };
  Spritesheet2.prototype._parseComplete = function() {
    var callback = this._callback;
    this._callback = null;
    this._batchIndex = 0;
    callback.call(this, this.textures);
  };
  Spritesheet2.prototype._nextBatch = function() {
    var _this = this;
    this._processFrames(this._batchIndex * Spritesheet2.BATCH_SIZE);
    this._batchIndex++;
    setTimeout(function() {
      if (_this._batchIndex * Spritesheet2.BATCH_SIZE < _this._frameKeys.length) {
        _this._nextBatch();
      } else {
        _this._processAnimations();
        _this._parseComplete();
      }
    }, 0);
  };
  Spritesheet2.prototype.destroy = function(destroyBase) {
    var _a3;
    if (destroyBase === void 0) {
      destroyBase = false;
    }
    for (var i2 in this.textures) {
      this.textures[i2].destroy();
    }
    this._frames = null;
    this._frameKeys = null;
    this.data = null;
    this.textures = null;
    if (destroyBase) {
      (_a3 = this._texture) === null || _a3 === void 0 ? void 0 : _a3.destroy();
      this.baseTexture.destroy();
    }
    this._texture = null;
    this.baseTexture = null;
  };
  Spritesheet2.BATCH_SIZE = 1e3;
  return Spritesheet2;
}();
var SpritesheetLoader = function() {
  function SpritesheetLoader2() {
  }
  SpritesheetLoader2.use = function(resource, next) {
    var _a3, _b3;
    var loader = this;
    var imageResourceName = resource.name + "_image";
    if (!resource.data || resource.type !== LoaderResource.TYPE.JSON || !resource.data.frames || loader.resources[imageResourceName]) {
      next();
      return;
    }
    var multiPacks = (_b3 = (_a3 = resource.data) === null || _a3 === void 0 ? void 0 : _a3.meta) === null || _b3 === void 0 ? void 0 : _b3.related_multi_packs;
    if (Array.isArray(multiPacks)) {
      var _loop_12 = function(item2) {
        if (typeof item2 !== "string") {
          return "continue";
        }
        var itemName = item2.replace(".json", "");
        var itemUrl = url.resolve(resource.url.replace(loader.baseUrl, ""), item2);
        if (loader.resources[itemName] || Object.values(loader.resources).some(function(r2) {
          return url.format(url.parse(r2.url)) === itemUrl;
        })) {
          return "continue";
        }
        var options = {
          crossOrigin: resource.crossOrigin,
          loadType: LoaderResource.LOAD_TYPE.XHR,
          xhrType: LoaderResource.XHR_RESPONSE_TYPE.JSON,
          parentResource: resource,
          metadata: resource.metadata
        };
        loader.add(itemName, itemUrl, options);
      };
      for (var _i = 0, multiPacks_1 = multiPacks; _i < multiPacks_1.length; _i++) {
        var item = multiPacks_1[_i];
        _loop_12(item);
      }
    }
    var loadOptions = {
      crossOrigin: resource.crossOrigin,
      metadata: resource.metadata.imageMetadata,
      parentResource: resource
    };
    var resourcePath = SpritesheetLoader2.getResourcePath(resource, loader.baseUrl);
    loader.add(imageResourceName, resourcePath, loadOptions, function onImageLoad(res) {
      if (res.error) {
        next(res.error);
        return;
      }
      var spritesheet = new Spritesheet(res.texture, resource.data, resource.url);
      spritesheet.parse(function() {
        resource.spritesheet = spritesheet;
        resource.textures = spritesheet.textures;
        next();
      });
    });
  };
  SpritesheetLoader2.getResourcePath = function(resource, baseUrl) {
    if (resource.isDataUrl) {
      return resource.data.meta.image;
    }
    return url.resolve(resource.url.replace(baseUrl, ""), resource.data.meta.image);
  };
  return SpritesheetLoader2;
}();
/*!
 * @pixi/sprite-tiling - v6.3.0
 * Compiled Wed, 23 Mar 2022 18:58:56 UTC
 *
 * @pixi/sprite-tiling is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
/*! *****************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */
var extendStatics$h = function(d2, b2) {
  extendStatics$h = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {
    d3.__proto__ = b3;
  } || function(d3, b3) {
    for (var p2 in b3) {
      if (b3.hasOwnProperty(p2)) {
        d3[p2] = b3[p2];
      }
    }
  };
  return extendStatics$h(d2, b2);
};
function __extends$h(d2, b2) {
  extendStatics$h(d2, b2);
  function __() {
    this.constructor = d2;
  }
  d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
}
var tempPoint$1 = new Point();
(function(_super) {
  __extends$h(TilingSprite, _super);
  function TilingSprite(texture, width, height) {
    if (width === void 0) {
      width = 100;
    }
    if (height === void 0) {
      height = 100;
    }
    var _this = _super.call(this, texture) || this;
    _this.tileTransform = new Transform();
    _this._width = width;
    _this._height = height;
    _this.uvMatrix = _this.texture.uvMatrix || new TextureMatrix(texture);
    _this.pluginName = "tilingSprite";
    _this.uvRespectAnchor = false;
    return _this;
  }
  Object.defineProperty(TilingSprite.prototype, "clampMargin", {
    get: function() {
      return this.uvMatrix.clampMargin;
    },
    set: function(value) {
      this.uvMatrix.clampMargin = value;
      this.uvMatrix.update(true);
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(TilingSprite.prototype, "tileScale", {
    get: function() {
      return this.tileTransform.scale;
    },
    set: function(value) {
      this.tileTransform.scale.copyFrom(value);
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(TilingSprite.prototype, "tilePosition", {
    get: function() {
      return this.tileTransform.position;
    },
    set: function(value) {
      this.tileTransform.position.copyFrom(value);
    },
    enumerable: false,
    configurable: true
  });
  TilingSprite.prototype._onTextureUpdate = function() {
    if (this.uvMatrix) {
      this.uvMatrix.texture = this._texture;
    }
    this._cachedTint = 16777215;
  };
  TilingSprite.prototype._render = function(renderer) {
    var texture = this._texture;
    if (!texture || !texture.valid) {
      return;
    }
    this.tileTransform.updateLocalTransform();
    this.uvMatrix.update();
    renderer.batch.setObjectRenderer(renderer.plugins[this.pluginName]);
    renderer.plugins[this.pluginName].render(this);
  };
  TilingSprite.prototype._calculateBounds = function() {
    var minX = this._width * -this._anchor._x;
    var minY = this._height * -this._anchor._y;
    var maxX = this._width * (1 - this._anchor._x);
    var maxY = this._height * (1 - this._anchor._y);
    this._bounds.addFrame(this.transform, minX, minY, maxX, maxY);
  };
  TilingSprite.prototype.getLocalBounds = function(rect) {
    if (this.children.length === 0) {
      this._bounds.minX = this._width * -this._anchor._x;
      this._bounds.minY = this._height * -this._anchor._y;
      this._bounds.maxX = this._width * (1 - this._anchor._x);
      this._bounds.maxY = this._height * (1 - this._anchor._y);
      if (!rect) {
        if (!this._localBoundsRect) {
          this._localBoundsRect = new Rectangle();
        }
        rect = this._localBoundsRect;
      }
      return this._bounds.getRectangle(rect);
    }
    return _super.prototype.getLocalBounds.call(this, rect);
  };
  TilingSprite.prototype.containsPoint = function(point) {
    this.worldTransform.applyInverse(point, tempPoint$1);
    var width = this._width;
    var height = this._height;
    var x1 = -width * this.anchor._x;
    if (tempPoint$1.x >= x1 && tempPoint$1.x < x1 + width) {
      var y1 = -height * this.anchor._y;
      if (tempPoint$1.y >= y1 && tempPoint$1.y < y1 + height) {
        return true;
      }
    }
    return false;
  };
  TilingSprite.prototype.destroy = function(options) {
    _super.prototype.destroy.call(this, options);
    this.tileTransform = null;
    this.uvMatrix = null;
  };
  TilingSprite.from = function(source, options) {
    var texture = source instanceof Texture ? source : Texture.from(source, options);
    return new TilingSprite(texture, options.width, options.height);
  };
  Object.defineProperty(TilingSprite.prototype, "width", {
    get: function() {
      return this._width;
    },
    set: function(value) {
      this._width = value;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(TilingSprite.prototype, "height", {
    get: function() {
      return this._height;
    },
    set: function(value) {
      this._height = value;
    },
    enumerable: false,
    configurable: true
  });
  return TilingSprite;
})(Sprite);
var fragmentSimpleSrc = "#version 100\n#define SHADER_NAME Tiling-Sprite-Simple-100\n\nprecision lowp float;\n\nvarying vec2 vTextureCoord;\n\nuniform sampler2D uSampler;\nuniform vec4 uColor;\n\nvoid main(void)\n{\n    vec4 texSample = texture2D(uSampler, vTextureCoord);\n    gl_FragColor = texSample * uColor;\n}\n";
var gl1VertexSrc = "#version 100\n#define SHADER_NAME Tiling-Sprite-100\n\nprecision lowp float;\n\nattribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\nuniform mat3 translationMatrix;\nuniform mat3 uTransform;\n\nvarying vec2 vTextureCoord;\n\nvoid main(void)\n{\n    gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n\n    vTextureCoord = (uTransform * vec3(aTextureCoord, 1.0)).xy;\n}\n";
var gl1FragmentSrc = "#version 100\n#ifdef GL_EXT_shader_texture_lod\n    #extension GL_EXT_shader_texture_lod : enable\n#endif\n#define SHADER_NAME Tiling-Sprite-100\n\nprecision lowp float;\n\nvarying vec2 vTextureCoord;\n\nuniform sampler2D uSampler;\nuniform vec4 uColor;\nuniform mat3 uMapCoord;\nuniform vec4 uClampFrame;\nuniform vec2 uClampOffset;\n\nvoid main(void)\n{\n    vec2 coord = vTextureCoord + ceil(uClampOffset - vTextureCoord);\n    coord = (uMapCoord * vec3(coord, 1.0)).xy;\n    vec2 unclamped = coord;\n    coord = clamp(coord, uClampFrame.xy, uClampFrame.zw);\n\n    #ifdef GL_EXT_shader_texture_lod\n        vec4 texSample = unclamped == coord\n            ? texture2D(uSampler, coord) \n            : texture2DLodEXT(uSampler, coord, 0);\n    #else\n        vec4 texSample = texture2D(uSampler, coord);\n    #endif\n\n    gl_FragColor = texSample * uColor;\n}\n";
var gl2VertexSrc = "#version 300 es\n#define SHADER_NAME Tiling-Sprite-300\n\nprecision lowp float;\n\nin vec2 aVertexPosition;\nin vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\nuniform mat3 translationMatrix;\nuniform mat3 uTransform;\n\nout vec2 vTextureCoord;\n\nvoid main(void)\n{\n    gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n\n    vTextureCoord = (uTransform * vec3(aTextureCoord, 1.0)).xy;\n}\n";
var gl2FragmentSrc = "#version 300 es\n#define SHADER_NAME Tiling-Sprite-100\n\nprecision lowp float;\n\nin vec2 vTextureCoord;\n\nout vec4 fragmentColor;\n\nuniform sampler2D uSampler;\nuniform vec4 uColor;\nuniform mat3 uMapCoord;\nuniform vec4 uClampFrame;\nuniform vec2 uClampOffset;\n\nvoid main(void)\n{\n    vec2 coord = vTextureCoord + ceil(uClampOffset - vTextureCoord);\n    coord = (uMapCoord * vec3(coord, 1.0)).xy;\n    vec2 unclamped = coord;\n    coord = clamp(coord, uClampFrame.xy, uClampFrame.zw);\n\n    vec4 texSample = texture(uSampler, coord, unclamped == coord ? 0.0f : -32.0f);// lod-bias very negative to force lod 0\n\n    fragmentColor = texSample * uColor;\n}\n";
var tempMat = new Matrix();
var TilingSpriteRenderer = function(_super) {
  __extends$h(TilingSpriteRenderer2, _super);
  function TilingSpriteRenderer2(renderer) {
    var _this = _super.call(this, renderer) || this;
    renderer.runners.contextChange.add(_this);
    _this.quad = new QuadUv();
    _this.state = State.for2d();
    return _this;
  }
  TilingSpriteRenderer2.prototype.contextChange = function() {
    var renderer = this.renderer;
    var uniforms = { globals: renderer.globalUniforms };
    this.simpleShader = Shader.from(gl1VertexSrc, fragmentSimpleSrc, uniforms);
    this.shader = renderer.context.webGLVersion > 1 ? Shader.from(gl2VertexSrc, gl2FragmentSrc, uniforms) : Shader.from(gl1VertexSrc, gl1FragmentSrc, uniforms);
  };
  TilingSpriteRenderer2.prototype.render = function(ts) {
    var renderer = this.renderer;
    var quad = this.quad;
    var vertices = quad.vertices;
    vertices[0] = vertices[6] = ts._width * -ts.anchor.x;
    vertices[1] = vertices[3] = ts._height * -ts.anchor.y;
    vertices[2] = vertices[4] = ts._width * (1 - ts.anchor.x);
    vertices[5] = vertices[7] = ts._height * (1 - ts.anchor.y);
    var anchorX = ts.uvRespectAnchor ? ts.anchor.x : 0;
    var anchorY = ts.uvRespectAnchor ? ts.anchor.y : 0;
    vertices = quad.uvs;
    vertices[0] = vertices[6] = -anchorX;
    vertices[1] = vertices[3] = -anchorY;
    vertices[2] = vertices[4] = 1 - anchorX;
    vertices[5] = vertices[7] = 1 - anchorY;
    quad.invalidate();
    var tex = ts._texture;
    var baseTex = tex.baseTexture;
    var lt = ts.tileTransform.localTransform;
    var uv = ts.uvMatrix;
    var isSimple = baseTex.isPowerOfTwo && tex.frame.width === baseTex.width && tex.frame.height === baseTex.height;
    if (isSimple) {
      if (!baseTex._glTextures[renderer.CONTEXT_UID]) {
        if (baseTex.wrapMode === WRAP_MODES$3.CLAMP) {
          baseTex.wrapMode = WRAP_MODES$3.REPEAT;
        }
      } else {
        isSimple = baseTex.wrapMode !== WRAP_MODES$3.CLAMP;
      }
    }
    var shader = isSimple ? this.simpleShader : this.shader;
    var w2 = tex.width;
    var h2 = tex.height;
    var W = ts._width;
    var H = ts._height;
    tempMat.set(lt.a * w2 / W, lt.b * w2 / H, lt.c * h2 / W, lt.d * h2 / H, lt.tx / W, lt.ty / H);
    tempMat.invert();
    if (isSimple) {
      tempMat.prepend(uv.mapCoord);
    } else {
      shader.uniforms.uMapCoord = uv.mapCoord.toArray(true);
      shader.uniforms.uClampFrame = uv.uClampFrame;
      shader.uniforms.uClampOffset = uv.uClampOffset;
    }
    shader.uniforms.uTransform = tempMat.toArray(true);
    shader.uniforms.uColor = premultiplyTintToRgba(ts.tint, ts.worldAlpha, shader.uniforms.uColor, baseTex.alphaMode);
    shader.uniforms.translationMatrix = ts.transform.worldTransform.toArray(true);
    shader.uniforms.uSampler = tex;
    renderer.shader.bind(shader);
    renderer.geometry.bind(quad);
    this.state.blendMode = correctBlendMode(ts.blendMode, baseTex.alphaMode);
    renderer.state.set(this.state);
    renderer.geometry.draw(this.renderer.gl.TRIANGLES, 6, 0);
  };
  return TilingSpriteRenderer2;
}(ObjectRenderer);
/*!
 * @pixi/mesh - v6.3.0
 * Compiled Wed, 23 Mar 2022 18:58:56 UTC
 *
 * @pixi/mesh is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
/*! *****************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */
var extendStatics$g = function(d2, b2) {
  extendStatics$g = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {
    d3.__proto__ = b3;
  } || function(d3, b3) {
    for (var p2 in b3) {
      if (b3.hasOwnProperty(p2)) {
        d3[p2] = b3[p2];
      }
    }
  };
  return extendStatics$g(d2, b2);
};
function __extends$g(d2, b2) {
  extendStatics$g(d2, b2);
  function __() {
    this.constructor = d2;
  }
  d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
}
var MeshBatchUvs = function() {
  function MeshBatchUvs2(uvBuffer, uvMatrix) {
    this.uvBuffer = uvBuffer;
    this.uvMatrix = uvMatrix;
    this.data = null;
    this._bufferUpdateId = -1;
    this._textureUpdateId = -1;
    this._updateID = 0;
  }
  MeshBatchUvs2.prototype.update = function(forceUpdate) {
    if (!forceUpdate && this._bufferUpdateId === this.uvBuffer._updateID && this._textureUpdateId === this.uvMatrix._updateID) {
      return;
    }
    this._bufferUpdateId = this.uvBuffer._updateID;
    this._textureUpdateId = this.uvMatrix._updateID;
    var data = this.uvBuffer.data;
    if (!this.data || this.data.length !== data.length) {
      this.data = new Float32Array(data.length);
    }
    this.uvMatrix.multiplyUvs(data, this.data);
    this._updateID++;
  };
  return MeshBatchUvs2;
}();
var tempPoint = new Point();
var tempPolygon = new Polygon();
var Mesh = function(_super) {
  __extends$g(Mesh2, _super);
  function Mesh2(geometry, shader, state, drawMode) {
    if (drawMode === void 0) {
      drawMode = DRAW_MODES$3.TRIANGLES;
    }
    var _this = _super.call(this) || this;
    _this.geometry = geometry;
    _this.shader = shader;
    _this.state = state || State.for2d();
    _this.drawMode = drawMode;
    _this.start = 0;
    _this.size = 0;
    _this.uvs = null;
    _this.indices = null;
    _this.vertexData = new Float32Array(1);
    _this.vertexDirty = -1;
    _this._transformID = -1;
    _this._roundPixels = settings.ROUND_PIXELS;
    _this.batchUvs = null;
    return _this;
  }
  Object.defineProperty(Mesh2.prototype, "geometry", {
    get: function() {
      return this._geometry;
    },
    set: function(value) {
      if (this._geometry === value) {
        return;
      }
      if (this._geometry) {
        this._geometry.refCount--;
        if (this._geometry.refCount === 0) {
          this._geometry.dispose();
        }
      }
      this._geometry = value;
      if (this._geometry) {
        this._geometry.refCount++;
      }
      this.vertexDirty = -1;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Mesh2.prototype, "uvBuffer", {
    get: function() {
      return this.geometry.buffers[1];
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Mesh2.prototype, "verticesBuffer", {
    get: function() {
      return this.geometry.buffers[0];
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Mesh2.prototype, "material", {
    get: function() {
      return this.shader;
    },
    set: function(value) {
      this.shader = value;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Mesh2.prototype, "blendMode", {
    get: function() {
      return this.state.blendMode;
    },
    set: function(value) {
      this.state.blendMode = value;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Mesh2.prototype, "roundPixels", {
    get: function() {
      return this._roundPixels;
    },
    set: function(value) {
      if (this._roundPixels !== value) {
        this._transformID = -1;
      }
      this._roundPixels = value;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Mesh2.prototype, "tint", {
    get: function() {
      return "tint" in this.shader ? this.shader.tint : null;
    },
    set: function(value) {
      this.shader.tint = value;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Mesh2.prototype, "texture", {
    get: function() {
      return "texture" in this.shader ? this.shader.texture : null;
    },
    set: function(value) {
      this.shader.texture = value;
    },
    enumerable: false,
    configurable: true
  });
  Mesh2.prototype._render = function(renderer) {
    var vertices = this.geometry.buffers[0].data;
    var shader = this.shader;
    if (shader.batchable && this.drawMode === DRAW_MODES$3.TRIANGLES && vertices.length < Mesh2.BATCHABLE_SIZE * 2) {
      this._renderToBatch(renderer);
    } else {
      this._renderDefault(renderer);
    }
  };
  Mesh2.prototype._renderDefault = function(renderer) {
    var shader = this.shader;
    shader.alpha = this.worldAlpha;
    if (shader.update) {
      shader.update();
    }
    renderer.batch.flush();
    shader.uniforms.translationMatrix = this.transform.worldTransform.toArray(true);
    renderer.shader.bind(shader);
    renderer.state.set(this.state);
    renderer.geometry.bind(this.geometry, shader);
    renderer.geometry.draw(this.drawMode, this.size, this.start, this.geometry.instanceCount);
  };
  Mesh2.prototype._renderToBatch = function(renderer) {
    var geometry = this.geometry;
    var shader = this.shader;
    if (shader.uvMatrix) {
      shader.uvMatrix.update();
      this.calculateUvs();
    }
    this.calculateVertices();
    this.indices = geometry.indexBuffer.data;
    this._tintRGB = shader._tintRGB;
    this._texture = shader.texture;
    var pluginName = this.material.pluginName;
    renderer.batch.setObjectRenderer(renderer.plugins[pluginName]);
    renderer.plugins[pluginName].render(this);
  };
  Mesh2.prototype.calculateVertices = function() {
    var geometry = this.geometry;
    var verticesBuffer = geometry.buffers[0];
    var vertices = verticesBuffer.data;
    var vertexDirtyId = verticesBuffer._updateID;
    if (vertexDirtyId === this.vertexDirty && this._transformID === this.transform._worldID) {
      return;
    }
    this._transformID = this.transform._worldID;
    if (this.vertexData.length !== vertices.length) {
      this.vertexData = new Float32Array(vertices.length);
    }
    var wt = this.transform.worldTransform;
    var a2 = wt.a;
    var b2 = wt.b;
    var c2 = wt.c;
    var d2 = wt.d;
    var tx = wt.tx;
    var ty = wt.ty;
    var vertexData = this.vertexData;
    for (var i2 = 0; i2 < vertexData.length / 2; i2++) {
      var x2 = vertices[i2 * 2];
      var y2 = vertices[i2 * 2 + 1];
      vertexData[i2 * 2] = a2 * x2 + c2 * y2 + tx;
      vertexData[i2 * 2 + 1] = b2 * x2 + d2 * y2 + ty;
    }
    if (this._roundPixels) {
      var resolution = settings.RESOLUTION;
      for (var i2 = 0; i2 < vertexData.length; ++i2) {
        vertexData[i2] = Math.round((vertexData[i2] * resolution | 0) / resolution);
      }
    }
    this.vertexDirty = vertexDirtyId;
  };
  Mesh2.prototype.calculateUvs = function() {
    var geomUvs = this.geometry.buffers[1];
    var shader = this.shader;
    if (!shader.uvMatrix.isSimple) {
      if (!this.batchUvs) {
        this.batchUvs = new MeshBatchUvs(geomUvs, shader.uvMatrix);
      }
      this.batchUvs.update();
      this.uvs = this.batchUvs.data;
    } else {
      this.uvs = geomUvs.data;
    }
  };
  Mesh2.prototype._calculateBounds = function() {
    this.calculateVertices();
    this._bounds.addVertexData(this.vertexData, 0, this.vertexData.length);
  };
  Mesh2.prototype.containsPoint = function(point) {
    if (!this.getBounds().contains(point.x, point.y)) {
      return false;
    }
    this.worldTransform.applyInverse(point, tempPoint);
    var vertices = this.geometry.getBuffer("aVertexPosition").data;
    var points = tempPolygon.points;
    var indices2 = this.geometry.getIndex().data;
    var len = indices2.length;
    var step = this.drawMode === 4 ? 3 : 1;
    for (var i2 = 0; i2 + 2 < len; i2 += step) {
      var ind0 = indices2[i2] * 2;
      var ind1 = indices2[i2 + 1] * 2;
      var ind2 = indices2[i2 + 2] * 2;
      points[0] = vertices[ind0];
      points[1] = vertices[ind0 + 1];
      points[2] = vertices[ind1];
      points[3] = vertices[ind1 + 1];
      points[4] = vertices[ind2];
      points[5] = vertices[ind2 + 1];
      if (tempPolygon.contains(tempPoint.x, tempPoint.y)) {
        return true;
      }
    }
    return false;
  };
  Mesh2.prototype.destroy = function(options) {
    _super.prototype.destroy.call(this, options);
    if (this._cachedTexture) {
      this._cachedTexture.destroy();
      this._cachedTexture = null;
    }
    this.geometry = null;
    this.shader = null;
    this.state = null;
    this.uvs = null;
    this.indices = null;
    this.vertexData = null;
  };
  Mesh2.BATCHABLE_SIZE = 100;
  return Mesh2;
}(Container);
var fragment$5 = "varying vec2 vTextureCoord;\nuniform vec4 uColor;\n\nuniform sampler2D uSampler;\n\nvoid main(void)\n{\n    gl_FragColor = texture2D(uSampler, vTextureCoord) * uColor;\n}\n";
var vertex$2 = "attribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\nuniform mat3 translationMatrix;\nuniform mat3 uTextureMatrix;\n\nvarying vec2 vTextureCoord;\n\nvoid main(void)\n{\n    gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n\n    vTextureCoord = (uTextureMatrix * vec3(aTextureCoord, 1.0)).xy;\n}\n";
var MeshMaterial = function(_super) {
  __extends$g(MeshMaterial2, _super);
  function MeshMaterial2(uSampler, options) {
    var _this = this;
    var uniforms = {
      uSampler,
      alpha: 1,
      uTextureMatrix: Matrix.IDENTITY,
      uColor: new Float32Array([1, 1, 1, 1])
    };
    options = Object.assign({
      tint: 16777215,
      alpha: 1,
      pluginName: "batch"
    }, options);
    if (options.uniforms) {
      Object.assign(uniforms, options.uniforms);
    }
    _this = _super.call(this, options.program || Program.from(vertex$2, fragment$5), uniforms) || this;
    _this._colorDirty = false;
    _this.uvMatrix = new TextureMatrix(uSampler);
    _this.batchable = options.program === void 0;
    _this.pluginName = options.pluginName;
    _this.tint = options.tint;
    _this.alpha = options.alpha;
    return _this;
  }
  Object.defineProperty(MeshMaterial2.prototype, "texture", {
    get: function() {
      return this.uniforms.uSampler;
    },
    set: function(value) {
      if (this.uniforms.uSampler !== value) {
        this.uniforms.uSampler = value;
        this.uvMatrix.texture = value;
      }
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(MeshMaterial2.prototype, "alpha", {
    get: function() {
      return this._alpha;
    },
    set: function(value) {
      if (value === this._alpha) {
        return;
      }
      this._alpha = value;
      this._colorDirty = true;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(MeshMaterial2.prototype, "tint", {
    get: function() {
      return this._tint;
    },
    set: function(value) {
      if (value === this._tint) {
        return;
      }
      this._tint = value;
      this._tintRGB = (value >> 16) + (value & 65280) + ((value & 255) << 16);
      this._colorDirty = true;
    },
    enumerable: false,
    configurable: true
  });
  MeshMaterial2.prototype.update = function() {
    if (this._colorDirty) {
      this._colorDirty = false;
      var baseTexture = this.texture.baseTexture;
      premultiplyTintToRgba(this._tint, this._alpha, this.uniforms.uColor, baseTexture.alphaMode);
    }
    if (this.uvMatrix.update()) {
      this.uniforms.uTextureMatrix = this.uvMatrix.mapCoord;
    }
  };
  return MeshMaterial2;
}(Shader);
var MeshGeometry = function(_super) {
  __extends$g(MeshGeometry2, _super);
  function MeshGeometry2(vertices, uvs, index) {
    var _this = _super.call(this) || this;
    var verticesBuffer = new Buffer$1(vertices);
    var uvsBuffer = new Buffer$1(uvs, true);
    var indexBuffer = new Buffer$1(index, true, true);
    _this.addAttribute("aVertexPosition", verticesBuffer, 2, false, TYPES$3.FLOAT).addAttribute("aTextureCoord", uvsBuffer, 2, false, TYPES$3.FLOAT).addIndex(indexBuffer);
    _this._updateId = -1;
    return _this;
  }
  Object.defineProperty(MeshGeometry2.prototype, "vertexDirtyId", {
    get: function() {
      return this.buffers[0]._updateID;
    },
    enumerable: false,
    configurable: true
  });
  return MeshGeometry2;
}(Geometry);
/*!
 * @pixi/text-bitmap - v6.3.0
 * Compiled Wed, 23 Mar 2022 18:58:56 UTC
 *
 * @pixi/text-bitmap is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
/*! *****************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */
var extendStatics$f = function(d2, b2) {
  extendStatics$f = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {
    d3.__proto__ = b3;
  } || function(d3, b3) {
    for (var p2 in b3) {
      if (b3.hasOwnProperty(p2)) {
        d3[p2] = b3[p2];
      }
    }
  };
  return extendStatics$f(d2, b2);
};
function __extends$f(d2, b2) {
  extendStatics$f(d2, b2);
  function __() {
    this.constructor = d2;
  }
  d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
}
var BitmapFontData = function() {
  function BitmapFontData2() {
    this.info = [];
    this.common = [];
    this.page = [];
    this.char = [];
    this.kerning = [];
    this.distanceField = [];
  }
  return BitmapFontData2;
}();
var TextFormat = function() {
  function TextFormat2() {
  }
  TextFormat2.test = function(data) {
    return typeof data === "string" && data.indexOf("info face=") === 0;
  };
  TextFormat2.parse = function(txt) {
    var items = txt.match(/^[a-z]+\s+.+$/gm);
    var rawData = {
      info: [],
      common: [],
      page: [],
      char: [],
      chars: [],
      kerning: [],
      kernings: [],
      distanceField: []
    };
    for (var i2 in items) {
      var name2 = items[i2].match(/^[a-z]+/gm)[0];
      var attributeList = items[i2].match(/[a-zA-Z]+=([^\s"']+|"([^"]*)")/gm);
      var itemData = {};
      for (var i_1 in attributeList) {
        var split = attributeList[i_1].split("=");
        var key = split[0];
        var strValue = split[1].replace(/"/gm, "");
        var floatValue = parseFloat(strValue);
        var value = isNaN(floatValue) ? strValue : floatValue;
        itemData[key] = value;
      }
      rawData[name2].push(itemData);
    }
    var font = new BitmapFontData();
    rawData.info.forEach(function(info) {
      return font.info.push({
        face: info.face,
        size: parseInt(info.size, 10)
      });
    });
    rawData.common.forEach(function(common) {
      return font.common.push({
        lineHeight: parseInt(common.lineHeight, 10)
      });
    });
    rawData.page.forEach(function(page) {
      return font.page.push({
        id: parseInt(page.id, 10),
        file: page.file
      });
    });
    rawData.char.forEach(function(char) {
      return font.char.push({
        id: parseInt(char.id, 10),
        page: parseInt(char.page, 10),
        x: parseInt(char.x, 10),
        y: parseInt(char.y, 10),
        width: parseInt(char.width, 10),
        height: parseInt(char.height, 10),
        xoffset: parseInt(char.xoffset, 10),
        yoffset: parseInt(char.yoffset, 10),
        xadvance: parseInt(char.xadvance, 10)
      });
    });
    rawData.kerning.forEach(function(kerning) {
      return font.kerning.push({
        first: parseInt(kerning.first, 10),
        second: parseInt(kerning.second, 10),
        amount: parseInt(kerning.amount, 10)
      });
    });
    rawData.distanceField.forEach(function(df) {
      return font.distanceField.push({
        distanceRange: parseInt(df.distanceRange, 10),
        fieldType: df.fieldType
      });
    });
    return font;
  };
  return TextFormat2;
}();
var XMLFormat = function() {
  function XMLFormat2() {
  }
  XMLFormat2.test = function(data) {
    return data instanceof XMLDocument && data.getElementsByTagName("page").length && data.getElementsByTagName("info")[0].getAttribute("face") !== null;
  };
  XMLFormat2.parse = function(xml) {
    var data = new BitmapFontData();
    var info = xml.getElementsByTagName("info");
    var common = xml.getElementsByTagName("common");
    var page = xml.getElementsByTagName("page");
    var char = xml.getElementsByTagName("char");
    var kerning = xml.getElementsByTagName("kerning");
    var distanceField = xml.getElementsByTagName("distanceField");
    for (var i2 = 0; i2 < info.length; i2++) {
      data.info.push({
        face: info[i2].getAttribute("face"),
        size: parseInt(info[i2].getAttribute("size"), 10)
      });
    }
    for (var i2 = 0; i2 < common.length; i2++) {
      data.common.push({
        lineHeight: parseInt(common[i2].getAttribute("lineHeight"), 10)
      });
    }
    for (var i2 = 0; i2 < page.length; i2++) {
      data.page.push({
        id: parseInt(page[i2].getAttribute("id"), 10) || 0,
        file: page[i2].getAttribute("file")
      });
    }
    for (var i2 = 0; i2 < char.length; i2++) {
      var letter = char[i2];
      data.char.push({
        id: parseInt(letter.getAttribute("id"), 10),
        page: parseInt(letter.getAttribute("page"), 10) || 0,
        x: parseInt(letter.getAttribute("x"), 10),
        y: parseInt(letter.getAttribute("y"), 10),
        width: parseInt(letter.getAttribute("width"), 10),
        height: parseInt(letter.getAttribute("height"), 10),
        xoffset: parseInt(letter.getAttribute("xoffset"), 10),
        yoffset: parseInt(letter.getAttribute("yoffset"), 10),
        xadvance: parseInt(letter.getAttribute("xadvance"), 10)
      });
    }
    for (var i2 = 0; i2 < kerning.length; i2++) {
      data.kerning.push({
        first: parseInt(kerning[i2].getAttribute("first"), 10),
        second: parseInt(kerning[i2].getAttribute("second"), 10),
        amount: parseInt(kerning[i2].getAttribute("amount"), 10)
      });
    }
    for (var i2 = 0; i2 < distanceField.length; i2++) {
      data.distanceField.push({
        fieldType: distanceField[i2].getAttribute("fieldType"),
        distanceRange: parseInt(distanceField[i2].getAttribute("distanceRange"), 10)
      });
    }
    return data;
  };
  return XMLFormat2;
}();
var XMLStringFormat = function() {
  function XMLStringFormat2() {
  }
  XMLStringFormat2.test = function(data) {
    if (typeof data === "string" && data.indexOf("<font>") > -1) {
      var xml = new globalThis.DOMParser().parseFromString(data, "text/xml");
      return XMLFormat.test(xml);
    }
    return false;
  };
  XMLStringFormat2.parse = function(xmlTxt) {
    var xml = new globalThis.DOMParser().parseFromString(xmlTxt, "text/xml");
    return XMLFormat.parse(xml);
  };
  return XMLStringFormat2;
}();
var formats = [
  TextFormat,
  XMLFormat,
  XMLStringFormat
];
function autoDetectFormat(data) {
  for (var i2 = 0; i2 < formats.length; i2++) {
    if (formats[i2].test(data)) {
      return formats[i2];
    }
  }
  return null;
}
function generateFillStyle(canvas2, context2, style, resolution, lines, metrics) {
  var fillStyle = style.fill;
  if (!Array.isArray(fillStyle)) {
    return fillStyle;
  } else if (fillStyle.length === 1) {
    return fillStyle[0];
  }
  var gradient;
  var dropShadowCorrection = style.dropShadow ? style.dropShadowDistance : 0;
  var padding = style.padding || 0;
  var width = canvas2.width / resolution - dropShadowCorrection - padding * 2;
  var height = canvas2.height / resolution - dropShadowCorrection - padding * 2;
  var fill = fillStyle.slice();
  var fillGradientStops = style.fillGradientStops.slice();
  if (!fillGradientStops.length) {
    var lengthPlus1 = fill.length + 1;
    for (var i2 = 1; i2 < lengthPlus1; ++i2) {
      fillGradientStops.push(i2 / lengthPlus1);
    }
  }
  fill.unshift(fillStyle[0]);
  fillGradientStops.unshift(0);
  fill.push(fillStyle[fillStyle.length - 1]);
  fillGradientStops.push(1);
  if (style.fillGradientType === TEXT_GRADIENT.LINEAR_VERTICAL) {
    gradient = context2.createLinearGradient(width / 2, padding, width / 2, height + padding);
    var lastIterationStop = 0;
    var textHeight = metrics.fontProperties.fontSize + style.strokeThickness;
    var gradStopLineHeight = textHeight / height;
    for (var i2 = 0; i2 < lines.length; i2++) {
      var thisLineTop = metrics.lineHeight * i2;
      for (var j2 = 0; j2 < fill.length; j2++) {
        var lineStop = 0;
        if (typeof fillGradientStops[j2] === "number") {
          lineStop = fillGradientStops[j2];
        } else {
          lineStop = j2 / fill.length;
        }
        var globalStop = thisLineTop / height + lineStop * gradStopLineHeight;
        var clampedStop = Math.max(lastIterationStop, globalStop);
        clampedStop = Math.min(clampedStop, 1);
        gradient.addColorStop(clampedStop, fill[j2]);
        lastIterationStop = clampedStop;
      }
    }
  } else {
    gradient = context2.createLinearGradient(padding, height / 2, width + padding, height / 2);
    var totalIterations = fill.length + 1;
    var currentIteration = 1;
    for (var i2 = 0; i2 < fill.length; i2++) {
      var stop = void 0;
      if (typeof fillGradientStops[i2] === "number") {
        stop = fillGradientStops[i2];
      } else {
        stop = currentIteration / totalIterations;
      }
      gradient.addColorStop(stop, fill[i2]);
      currentIteration++;
    }
  }
  return gradient;
}
function drawGlyph(canvas2, context2, metrics, x2, y2, resolution, style) {
  var char = metrics.text;
  var fontProperties = metrics.fontProperties;
  context2.translate(x2, y2);
  context2.scale(resolution, resolution);
  var tx = style.strokeThickness / 2;
  var ty = -(style.strokeThickness / 2);
  context2.font = style.toFontString();
  context2.lineWidth = style.strokeThickness;
  context2.textBaseline = style.textBaseline;
  context2.lineJoin = style.lineJoin;
  context2.miterLimit = style.miterLimit;
  context2.fillStyle = generateFillStyle(canvas2, context2, style, resolution, [char], metrics);
  context2.strokeStyle = style.stroke;
  if (style.dropShadow) {
    var dropShadowColor = style.dropShadowColor;
    var rgb = hex2rgb(typeof dropShadowColor === "number" ? dropShadowColor : string2hex(dropShadowColor));
    var dropShadowBlur = style.dropShadowBlur * resolution;
    var dropShadowDistance = style.dropShadowDistance * resolution;
    context2.shadowColor = "rgba(" + rgb[0] * 255 + "," + rgb[1] * 255 + "," + rgb[2] * 255 + "," + style.dropShadowAlpha + ")";
    context2.shadowBlur = dropShadowBlur;
    context2.shadowOffsetX = Math.cos(style.dropShadowAngle) * dropShadowDistance;
    context2.shadowOffsetY = Math.sin(style.dropShadowAngle) * dropShadowDistance;
  } else {
    context2.shadowColor = "black";
    context2.shadowBlur = 0;
    context2.shadowOffsetX = 0;
    context2.shadowOffsetY = 0;
  }
  if (style.stroke && style.strokeThickness) {
    context2.strokeText(char, tx, ty + metrics.lineHeight - fontProperties.descent);
  }
  if (style.fill) {
    context2.fillText(char, tx, ty + metrics.lineHeight - fontProperties.descent);
  }
  context2.setTransform(1, 0, 0, 1, 0, 0);
  context2.fillStyle = "rgba(0, 0, 0, 0)";
}
function splitTextToCharacters(text2) {
  return Array.from ? Array.from(text2) : text2.split("");
}
function resolveCharacters(chars2) {
  if (typeof chars2 === "string") {
    chars2 = [chars2];
  }
  var result = [];
  for (var i2 = 0, j2 = chars2.length; i2 < j2; i2++) {
    var item = chars2[i2];
    if (Array.isArray(item)) {
      if (item.length !== 2) {
        throw new Error("[BitmapFont]: Invalid character range length, expecting 2 got " + item.length + ".");
      }
      var startCode = item[0].charCodeAt(0);
      var endCode = item[1].charCodeAt(0);
      if (endCode < startCode) {
        throw new Error("[BitmapFont]: Invalid character range.");
      }
      for (var i_1 = startCode, j_1 = endCode; i_1 <= j_1; i_1++) {
        result.push(String.fromCharCode(i_1));
      }
    } else {
      result.push.apply(result, splitTextToCharacters(item));
    }
  }
  if (result.length === 0) {
    throw new Error("[BitmapFont]: Empty set when resolving characters.");
  }
  return result;
}
function extractCharCode(str2) {
  return str2.codePointAt ? str2.codePointAt(0) : str2.charCodeAt(0);
}
var BitmapFont = function() {
  function BitmapFont2(data, textures, ownsTextures) {
    var _a3, _b3;
    var info = data.info[0];
    var common = data.common[0];
    var page = data.page[0];
    var distanceField = data.distanceField[0];
    var res = getResolutionOfUrl(page.file);
    var pageTextures = {};
    this._ownsTextures = ownsTextures;
    this.font = info.face;
    this.size = info.size;
    this.lineHeight = common.lineHeight / res;
    this.chars = {};
    this.pageTextures = pageTextures;
    for (var i2 = 0; i2 < data.page.length; i2++) {
      var _c3 = data.page[i2], id = _c3.id, file = _c3.file;
      pageTextures[id] = textures instanceof Array ? textures[i2] : textures[file];
      if ((distanceField === null || distanceField === void 0 ? void 0 : distanceField.fieldType) && distanceField.fieldType !== "none") {
        pageTextures[id].baseTexture.alphaMode = ALPHA_MODES$3.NO_PREMULTIPLIED_ALPHA;
      }
    }
    for (var i2 = 0; i2 < data.char.length; i2++) {
      var _d2 = data.char[i2], id = _d2.id, page_1 = _d2.page;
      var _e = data.char[i2], x2 = _e.x, y2 = _e.y, width = _e.width, height = _e.height, xoffset = _e.xoffset, yoffset = _e.yoffset, xadvance = _e.xadvance;
      x2 /= res;
      y2 /= res;
      width /= res;
      height /= res;
      xoffset /= res;
      yoffset /= res;
      xadvance /= res;
      var rect = new Rectangle(x2 + pageTextures[page_1].frame.x / res, y2 + pageTextures[page_1].frame.y / res, width, height);
      this.chars[id] = {
        xOffset: xoffset,
        yOffset: yoffset,
        xAdvance: xadvance,
        kerning: {},
        texture: new Texture(pageTextures[page_1].baseTexture, rect),
        page: page_1
      };
    }
    for (var i2 = 0; i2 < data.kerning.length; i2++) {
      var _f = data.kerning[i2], first = _f.first, second = _f.second, amount = _f.amount;
      first /= res;
      second /= res;
      amount /= res;
      if (this.chars[second]) {
        this.chars[second].kerning[first] = amount;
      }
    }
    this.distanceFieldRange = distanceField === null || distanceField === void 0 ? void 0 : distanceField.distanceRange;
    this.distanceFieldType = (_b3 = (_a3 = distanceField === null || distanceField === void 0 ? void 0 : distanceField.fieldType) === null || _a3 === void 0 ? void 0 : _a3.toLowerCase()) !== null && _b3 !== void 0 ? _b3 : "none";
  }
  BitmapFont2.prototype.destroy = function() {
    for (var id in this.chars) {
      this.chars[id].texture.destroy();
      this.chars[id].texture = null;
    }
    for (var id in this.pageTextures) {
      if (this._ownsTextures) {
        this.pageTextures[id].destroy(true);
      }
      this.pageTextures[id] = null;
    }
    this.chars = null;
    this.pageTextures = null;
  };
  BitmapFont2.install = function(data, textures, ownsTextures) {
    var fontData;
    if (data instanceof BitmapFontData) {
      fontData = data;
    } else {
      var format2 = autoDetectFormat(data);
      if (!format2) {
        throw new Error("Unrecognized data format for font.");
      }
      fontData = format2.parse(data);
    }
    if (textures instanceof Texture) {
      textures = [textures];
    }
    var font = new BitmapFont2(fontData, textures, ownsTextures);
    BitmapFont2.available[font.font] = font;
    return font;
  };
  BitmapFont2.uninstall = function(name2) {
    var font = BitmapFont2.available[name2];
    if (!font) {
      throw new Error("No font found named '" + name2 + "'");
    }
    font.destroy();
    delete BitmapFont2.available[name2];
  };
  BitmapFont2.from = function(name2, textStyle, options) {
    if (!name2) {
      throw new Error("[BitmapFont] Property `name` is required.");
    }
    var _a3 = Object.assign({}, BitmapFont2.defaultOptions, options), chars2 = _a3.chars, padding = _a3.padding, resolution = _a3.resolution, textureWidth = _a3.textureWidth, textureHeight = _a3.textureHeight;
    var charsList = resolveCharacters(chars2);
    var style = textStyle instanceof TextStyle ? textStyle : new TextStyle(textStyle);
    var lineWidth = textureWidth;
    var fontData = new BitmapFontData();
    fontData.info[0] = {
      face: style.fontFamily,
      size: style.fontSize
    };
    fontData.common[0] = {
      lineHeight: style.fontSize
    };
    var positionX = 0;
    var positionY = 0;
    var canvas2;
    var context2;
    var baseTexture;
    var maxCharHeight = 0;
    var textures = [];
    for (var i2 = 0; i2 < charsList.length; i2++) {
      if (!canvas2) {
        canvas2 = document.createElement("canvas");
        canvas2.width = textureWidth;
        canvas2.height = textureHeight;
        context2 = canvas2.getContext("2d");
        baseTexture = new BaseTexture(canvas2, { resolution });
        textures.push(new Texture(baseTexture));
        fontData.page.push({
          id: textures.length - 1,
          file: ""
        });
      }
      var metrics = TextMetrics.measureText(charsList[i2], style, false, canvas2);
      var width = metrics.width;
      var height = Math.ceil(metrics.height);
      var textureGlyphWidth = Math.ceil((style.fontStyle === "italic" ? 2 : 1) * width);
      if (positionY >= textureHeight - height * resolution) {
        if (positionY === 0) {
          throw new Error("[BitmapFont] textureHeight " + textureHeight + "px is " + ("too small for " + style.fontSize + "px fonts"));
        }
        --i2;
        canvas2 = null;
        context2 = null;
        baseTexture = null;
        positionY = 0;
        positionX = 0;
        maxCharHeight = 0;
        continue;
      }
      maxCharHeight = Math.max(height + metrics.fontProperties.descent, maxCharHeight);
      if (textureGlyphWidth * resolution + positionX >= lineWidth) {
        --i2;
        positionY += maxCharHeight * resolution;
        positionY = Math.ceil(positionY);
        positionX = 0;
        maxCharHeight = 0;
        continue;
      }
      drawGlyph(canvas2, context2, metrics, positionX, positionY, resolution, style);
      var id = extractCharCode(metrics.text);
      fontData.char.push({
        id,
        page: textures.length - 1,
        x: positionX / resolution,
        y: positionY / resolution,
        width: textureGlyphWidth,
        height,
        xoffset: 0,
        yoffset: 0,
        xadvance: Math.ceil(width - (style.dropShadow ? style.dropShadowDistance : 0) - (style.stroke ? style.strokeThickness : 0))
      });
      positionX += (textureGlyphWidth + 2 * padding) * resolution;
      positionX = Math.ceil(positionX);
    }
    for (var i2 = 0, len = charsList.length; i2 < len; i2++) {
      var first = charsList[i2];
      for (var j2 = 0; j2 < len; j2++) {
        var second = charsList[j2];
        var c1 = context2.measureText(first).width;
        var c2 = context2.measureText(second).width;
        var total = context2.measureText(first + second).width;
        var amount = total - (c1 + c2);
        if (amount) {
          fontData.kerning.push({
            first: extractCharCode(first),
            second: extractCharCode(second),
            amount
          });
        }
      }
    }
    var font = new BitmapFont2(fontData, textures, true);
    if (BitmapFont2.available[name2] !== void 0) {
      BitmapFont2.uninstall(name2);
    }
    BitmapFont2.available[name2] = font;
    return font;
  };
  BitmapFont2.ALPHA = [["a", "z"], ["A", "Z"], " "];
  BitmapFont2.NUMERIC = [["0", "9"]];
  BitmapFont2.ALPHANUMERIC = [["a", "z"], ["A", "Z"], ["0", "9"], " "];
  BitmapFont2.ASCII = [[" ", "~"]];
  BitmapFont2.defaultOptions = {
    resolution: 1,
    textureWidth: 512,
    textureHeight: 512,
    padding: 4,
    chars: BitmapFont2.ALPHANUMERIC
  };
  BitmapFont2.available = {};
  return BitmapFont2;
}();
var msdfFrag = "// Pixi texture info\r\nvarying vec2 vTextureCoord;\r\nuniform sampler2D uSampler;\r\n\r\n// Tint\r\nuniform vec4 uColor;\r\n\r\n// on 2D applications fwidth is screenScale / glyphAtlasScale * distanceFieldRange\r\nuniform float uFWidth;\r\n\r\nvoid main(void) {\r\n\r\n  // To stack MSDF and SDF we need a non-pre-multiplied-alpha texture.\r\n  vec4 texColor = texture2D(uSampler, vTextureCoord);\r\n\r\n  // MSDF\r\n  float median = texColor.r + texColor.g + texColor.b -\r\n                  min(texColor.r, min(texColor.g, texColor.b)) -\r\n                  max(texColor.r, max(texColor.g, texColor.b));\r\n  // SDF\r\n  median = min(median, texColor.a);\r\n\r\n  float screenPxDistance = uFWidth * (median - 0.5);\r\n  float alpha = clamp(screenPxDistance + 0.5, 0.0, 1.0);\r\n\r\n  // NPM Textures, NPM outputs\r\n  gl_FragColor = vec4(uColor.rgb, uColor.a * alpha);\r\n\r\n}\r\n";
var msdfVert = "// Mesh material default fragment\r\nattribute vec2 aVertexPosition;\r\nattribute vec2 aTextureCoord;\r\n\r\nuniform mat3 projectionMatrix;\r\nuniform mat3 translationMatrix;\r\nuniform mat3 uTextureMatrix;\r\n\r\nvarying vec2 vTextureCoord;\r\n\r\nvoid main(void)\r\n{\r\n    gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\r\n\r\n    vTextureCoord = (uTextureMatrix * vec3(aTextureCoord, 1.0)).xy;\r\n}\r\n";
var pageMeshDataDefaultPageMeshData = [];
var pageMeshDataMSDFPageMeshData = [];
var charRenderDataPool = [];
(function(_super) {
  __extends$f(BitmapText, _super);
  function BitmapText(text2, style) {
    if (style === void 0) {
      style = {};
    }
    var _this = _super.call(this) || this;
    _this._tint = 16777215;
    var _a3 = Object.assign({}, BitmapText.styleDefaults, style), align = _a3.align, tint = _a3.tint, maxWidth = _a3.maxWidth, letterSpacing = _a3.letterSpacing, fontName = _a3.fontName, fontSize = _a3.fontSize;
    if (!BitmapFont.available[fontName]) {
      throw new Error('Missing BitmapFont "' + fontName + '"');
    }
    _this._activePagesMeshData = [];
    _this._textWidth = 0;
    _this._textHeight = 0;
    _this._align = align;
    _this._tint = tint;
    _this._fontName = fontName;
    _this._fontSize = fontSize || BitmapFont.available[fontName].size;
    _this._text = text2;
    _this._maxWidth = maxWidth;
    _this._maxLineHeight = 0;
    _this._letterSpacing = letterSpacing;
    _this._anchor = new ObservablePoint(function() {
      _this.dirty = true;
    }, _this, 0, 0);
    _this._roundPixels = settings.ROUND_PIXELS;
    _this.dirty = true;
    _this._textureCache = {};
    return _this;
  }
  BitmapText.prototype.updateText = function() {
    var _a3;
    var data = BitmapFont.available[this._fontName];
    var scale = this._fontSize / data.size;
    var pos = new Point();
    var chars2 = [];
    var lineWidths = [];
    var lineSpaces = [];
    var text2 = this._text.replace(/(?:\r\n|\r)/g, "\n") || " ";
    var charsInput = splitTextToCharacters(text2);
    var maxWidth = this._maxWidth * data.size / this._fontSize;
    var pageMeshDataPool = data.distanceFieldType === "none" ? pageMeshDataDefaultPageMeshData : pageMeshDataMSDFPageMeshData;
    var prevCharCode = null;
    var lastLineWidth = 0;
    var maxLineWidth = 0;
    var line = 0;
    var lastBreakPos = -1;
    var lastBreakWidth = 0;
    var spacesRemoved = 0;
    var maxLineHeight = 0;
    var spaceCount = 0;
    for (var i2 = 0; i2 < charsInput.length; i2++) {
      var char = charsInput[i2];
      var charCode = extractCharCode(char);
      if (/(?:\s)/.test(char)) {
        lastBreakPos = i2;
        lastBreakWidth = lastLineWidth;
        spaceCount++;
      }
      if (char === "\r" || char === "\n") {
        lineWidths.push(lastLineWidth);
        lineSpaces.push(-1);
        maxLineWidth = Math.max(maxLineWidth, lastLineWidth);
        ++line;
        ++spacesRemoved;
        pos.x = 0;
        pos.y += data.lineHeight;
        prevCharCode = null;
        spaceCount = 0;
        continue;
      }
      var charData = data.chars[charCode];
      if (!charData) {
        continue;
      }
      if (prevCharCode && charData.kerning[prevCharCode]) {
        pos.x += charData.kerning[prevCharCode];
      }
      var charRenderData = charRenderDataPool.pop() || {
        texture: Texture.EMPTY,
        line: 0,
        charCode: 0,
        prevSpaces: 0,
        position: new Point()
      };
      charRenderData.texture = charData.texture;
      charRenderData.line = line;
      charRenderData.charCode = charCode;
      charRenderData.position.x = pos.x + charData.xOffset + this._letterSpacing / 2;
      charRenderData.position.y = pos.y + charData.yOffset;
      charRenderData.prevSpaces = spaceCount;
      chars2.push(charRenderData);
      lastLineWidth = charRenderData.position.x + Math.max(charData.xAdvance, charData.texture.orig.width);
      pos.x += charData.xAdvance + this._letterSpacing;
      maxLineHeight = Math.max(maxLineHeight, charData.yOffset + charData.texture.height);
      prevCharCode = charCode;
      if (lastBreakPos !== -1 && maxWidth > 0 && pos.x > maxWidth) {
        ++spacesRemoved;
        removeItems(chars2, 1 + lastBreakPos - spacesRemoved, 1 + i2 - lastBreakPos);
        i2 = lastBreakPos;
        lastBreakPos = -1;
        lineWidths.push(lastBreakWidth);
        lineSpaces.push(chars2.length > 0 ? chars2[chars2.length - 1].prevSpaces : 0);
        maxLineWidth = Math.max(maxLineWidth, lastBreakWidth);
        line++;
        pos.x = 0;
        pos.y += data.lineHeight;
        prevCharCode = null;
        spaceCount = 0;
      }
    }
    var lastChar = charsInput[charsInput.length - 1];
    if (lastChar !== "\r" && lastChar !== "\n") {
      if (/(?:\s)/.test(lastChar)) {
        lastLineWidth = lastBreakWidth;
      }
      lineWidths.push(lastLineWidth);
      maxLineWidth = Math.max(maxLineWidth, lastLineWidth);
      lineSpaces.push(-1);
    }
    var lineAlignOffsets = [];
    for (var i2 = 0; i2 <= line; i2++) {
      var alignOffset = 0;
      if (this._align === "right") {
        alignOffset = maxLineWidth - lineWidths[i2];
      } else if (this._align === "center") {
        alignOffset = (maxLineWidth - lineWidths[i2]) / 2;
      } else if (this._align === "justify") {
        alignOffset = lineSpaces[i2] < 0 ? 0 : (maxLineWidth - lineWidths[i2]) / lineSpaces[i2];
      }
      lineAlignOffsets.push(alignOffset);
    }
    var lenChars = chars2.length;
    var pagesMeshData = {};
    var newPagesMeshData = [];
    var activePagesMeshData = this._activePagesMeshData;
    for (var i2 = 0; i2 < activePagesMeshData.length; i2++) {
      pageMeshDataPool.push(activePagesMeshData[i2]);
    }
    for (var i2 = 0; i2 < lenChars; i2++) {
      var texture = chars2[i2].texture;
      var baseTextureUid = texture.baseTexture.uid;
      if (!pagesMeshData[baseTextureUid]) {
        var pageMeshData = pageMeshDataPool.pop();
        if (!pageMeshData) {
          var geometry = new MeshGeometry();
          var material = void 0;
          var meshBlendMode = void 0;
          if (data.distanceFieldType === "none") {
            material = new MeshMaterial(Texture.EMPTY);
            meshBlendMode = BLEND_MODES$3.NORMAL;
          } else {
            material = new MeshMaterial(Texture.EMPTY, { program: Program.from(msdfVert, msdfFrag), uniforms: { uFWidth: 0 } });
            meshBlendMode = BLEND_MODES$3.NORMAL_NPM;
          }
          var mesh = new Mesh(geometry, material);
          mesh.blendMode = meshBlendMode;
          pageMeshData = {
            index: 0,
            indexCount: 0,
            vertexCount: 0,
            uvsCount: 0,
            total: 0,
            mesh,
            vertices: null,
            uvs: null,
            indices: null
          };
        }
        pageMeshData.index = 0;
        pageMeshData.indexCount = 0;
        pageMeshData.vertexCount = 0;
        pageMeshData.uvsCount = 0;
        pageMeshData.total = 0;
        var _textureCache = this._textureCache;
        _textureCache[baseTextureUid] = _textureCache[baseTextureUid] || new Texture(texture.baseTexture);
        pageMeshData.mesh.texture = _textureCache[baseTextureUid];
        pageMeshData.mesh.tint = this._tint;
        newPagesMeshData.push(pageMeshData);
        pagesMeshData[baseTextureUid] = pageMeshData;
      }
      pagesMeshData[baseTextureUid].total++;
    }
    for (var i2 = 0; i2 < activePagesMeshData.length; i2++) {
      if (newPagesMeshData.indexOf(activePagesMeshData[i2]) === -1) {
        this.removeChild(activePagesMeshData[i2].mesh);
      }
    }
    for (var i2 = 0; i2 < newPagesMeshData.length; i2++) {
      if (newPagesMeshData[i2].mesh.parent !== this) {
        this.addChild(newPagesMeshData[i2].mesh);
      }
    }
    this._activePagesMeshData = newPagesMeshData;
    for (var i2 in pagesMeshData) {
      var pageMeshData = pagesMeshData[i2];
      var total = pageMeshData.total;
      if (!(((_a3 = pageMeshData.indices) === null || _a3 === void 0 ? void 0 : _a3.length) > 6 * total) || pageMeshData.vertices.length < Mesh.BATCHABLE_SIZE * 2) {
        pageMeshData.vertices = new Float32Array(4 * 2 * total);
        pageMeshData.uvs = new Float32Array(4 * 2 * total);
        pageMeshData.indices = new Uint16Array(6 * total);
      } else {
        var total_1 = pageMeshData.total;
        var vertices = pageMeshData.vertices;
        for (var i_1 = total_1 * 4 * 2; i_1 < vertices.length; i_1++) {
          vertices[i_1] = 0;
        }
      }
      pageMeshData.mesh.size = 6 * total;
    }
    for (var i2 = 0; i2 < lenChars; i2++) {
      var char = chars2[i2];
      var offset = char.position.x + lineAlignOffsets[char.line] * (this._align === "justify" ? char.prevSpaces : 1);
      if (this._roundPixels) {
        offset = Math.round(offset);
      }
      var xPos = offset * scale;
      var yPos = char.position.y * scale;
      var texture = char.texture;
      var pageMesh = pagesMeshData[texture.baseTexture.uid];
      var textureFrame = texture.frame;
      var textureUvs = texture._uvs;
      var index = pageMesh.index++;
      pageMesh.indices[index * 6 + 0] = 0 + index * 4;
      pageMesh.indices[index * 6 + 1] = 1 + index * 4;
      pageMesh.indices[index * 6 + 2] = 2 + index * 4;
      pageMesh.indices[index * 6 + 3] = 0 + index * 4;
      pageMesh.indices[index * 6 + 4] = 2 + index * 4;
      pageMesh.indices[index * 6 + 5] = 3 + index * 4;
      pageMesh.vertices[index * 8 + 0] = xPos;
      pageMesh.vertices[index * 8 + 1] = yPos;
      pageMesh.vertices[index * 8 + 2] = xPos + textureFrame.width * scale;
      pageMesh.vertices[index * 8 + 3] = yPos;
      pageMesh.vertices[index * 8 + 4] = xPos + textureFrame.width * scale;
      pageMesh.vertices[index * 8 + 5] = yPos + textureFrame.height * scale;
      pageMesh.vertices[index * 8 + 6] = xPos;
      pageMesh.vertices[index * 8 + 7] = yPos + textureFrame.height * scale;
      pageMesh.uvs[index * 8 + 0] = textureUvs.x0;
      pageMesh.uvs[index * 8 + 1] = textureUvs.y0;
      pageMesh.uvs[index * 8 + 2] = textureUvs.x1;
      pageMesh.uvs[index * 8 + 3] = textureUvs.y1;
      pageMesh.uvs[index * 8 + 4] = textureUvs.x2;
      pageMesh.uvs[index * 8 + 5] = textureUvs.y2;
      pageMesh.uvs[index * 8 + 6] = textureUvs.x3;
      pageMesh.uvs[index * 8 + 7] = textureUvs.y3;
    }
    this._textWidth = maxLineWidth * scale;
    this._textHeight = (pos.y + data.lineHeight) * scale;
    for (var i2 in pagesMeshData) {
      var pageMeshData = pagesMeshData[i2];
      if (this.anchor.x !== 0 || this.anchor.y !== 0) {
        var vertexCount = 0;
        var anchorOffsetX = this._textWidth * this.anchor.x;
        var anchorOffsetY = this._textHeight * this.anchor.y;
        for (var i_2 = 0; i_2 < pageMeshData.total; i_2++) {
          pageMeshData.vertices[vertexCount++] -= anchorOffsetX;
          pageMeshData.vertices[vertexCount++] -= anchorOffsetY;
          pageMeshData.vertices[vertexCount++] -= anchorOffsetX;
          pageMeshData.vertices[vertexCount++] -= anchorOffsetY;
          pageMeshData.vertices[vertexCount++] -= anchorOffsetX;
          pageMeshData.vertices[vertexCount++] -= anchorOffsetY;
          pageMeshData.vertices[vertexCount++] -= anchorOffsetX;
          pageMeshData.vertices[vertexCount++] -= anchorOffsetY;
        }
      }
      this._maxLineHeight = maxLineHeight * scale;
      var vertexBuffer = pageMeshData.mesh.geometry.getBuffer("aVertexPosition");
      var textureBuffer = pageMeshData.mesh.geometry.getBuffer("aTextureCoord");
      var indexBuffer = pageMeshData.mesh.geometry.getIndex();
      vertexBuffer.data = pageMeshData.vertices;
      textureBuffer.data = pageMeshData.uvs;
      indexBuffer.data = pageMeshData.indices;
      vertexBuffer.update();
      textureBuffer.update();
      indexBuffer.update();
    }
    for (var i2 = 0; i2 < chars2.length; i2++) {
      charRenderDataPool.push(chars2[i2]);
    }
  };
  BitmapText.prototype.updateTransform = function() {
    this.validate();
    this.containerUpdateTransform();
  };
  BitmapText.prototype._render = function(renderer) {
    var _a3 = BitmapFont.available[this._fontName], distanceFieldRange = _a3.distanceFieldRange, distanceFieldType = _a3.distanceFieldType, size = _a3.size;
    if (distanceFieldType !== "none") {
      var _b3 = this.worldTransform, a2 = _b3.a, b2 = _b3.b, c2 = _b3.c, d2 = _b3.d;
      var dx = Math.sqrt(a2 * a2 + b2 * b2);
      var dy = Math.sqrt(c2 * c2 + d2 * d2);
      var worldScale = (Math.abs(dx) + Math.abs(dy)) / 2;
      var fontScale = this._fontSize / size;
      for (var _i = 0, _c3 = this._activePagesMeshData; _i < _c3.length; _i++) {
        var mesh = _c3[_i];
        mesh.mesh.shader.uniforms.uFWidth = worldScale * distanceFieldRange * fontScale * renderer.resolution;
      }
    }
    _super.prototype._render.call(this, renderer);
  };
  BitmapText.prototype.getLocalBounds = function() {
    this.validate();
    return _super.prototype.getLocalBounds.call(this);
  };
  BitmapText.prototype.validate = function() {
    if (this.dirty) {
      this.updateText();
      this.dirty = false;
    }
  };
  Object.defineProperty(BitmapText.prototype, "tint", {
    get: function() {
      return this._tint;
    },
    set: function(value) {
      if (this._tint === value) {
        return;
      }
      this._tint = value;
      for (var i2 = 0; i2 < this._activePagesMeshData.length; i2++) {
        this._activePagesMeshData[i2].mesh.tint = value;
      }
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(BitmapText.prototype, "align", {
    get: function() {
      return this._align;
    },
    set: function(value) {
      if (this._align !== value) {
        this._align = value;
        this.dirty = true;
      }
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(BitmapText.prototype, "fontName", {
    get: function() {
      return this._fontName;
    },
    set: function(value) {
      if (!BitmapFont.available[value]) {
        throw new Error('Missing BitmapFont "' + value + '"');
      }
      if (this._fontName !== value) {
        this._fontName = value;
        this.dirty = true;
      }
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(BitmapText.prototype, "fontSize", {
    get: function() {
      return this._fontSize;
    },
    set: function(value) {
      if (this._fontSize !== value) {
        this._fontSize = value;
        this.dirty = true;
      }
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(BitmapText.prototype, "anchor", {
    get: function() {
      return this._anchor;
    },
    set: function(value) {
      if (typeof value === "number") {
        this._anchor.set(value);
      } else {
        this._anchor.copyFrom(value);
      }
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(BitmapText.prototype, "text", {
    get: function() {
      return this._text;
    },
    set: function(text2) {
      text2 = String(text2 === null || text2 === void 0 ? "" : text2);
      if (this._text === text2) {
        return;
      }
      this._text = text2;
      this.dirty = true;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(BitmapText.prototype, "maxWidth", {
    get: function() {
      return this._maxWidth;
    },
    set: function(value) {
      if (this._maxWidth === value) {
        return;
      }
      this._maxWidth = value;
      this.dirty = true;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(BitmapText.prototype, "maxLineHeight", {
    get: function() {
      this.validate();
      return this._maxLineHeight;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(BitmapText.prototype, "textWidth", {
    get: function() {
      this.validate();
      return this._textWidth;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(BitmapText.prototype, "letterSpacing", {
    get: function() {
      return this._letterSpacing;
    },
    set: function(value) {
      if (this._letterSpacing !== value) {
        this._letterSpacing = value;
        this.dirty = true;
      }
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(BitmapText.prototype, "roundPixels", {
    get: function() {
      return this._roundPixels;
    },
    set: function(value) {
      if (value !== this._roundPixels) {
        this._roundPixels = value;
        this.dirty = true;
      }
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(BitmapText.prototype, "textHeight", {
    get: function() {
      this.validate();
      return this._textHeight;
    },
    enumerable: false,
    configurable: true
  });
  BitmapText.prototype.destroy = function(options) {
    var _textureCache = this._textureCache;
    for (var id in _textureCache) {
      var texture = _textureCache[id];
      texture.destroy();
      delete _textureCache[id];
    }
    this._textureCache = null;
    _super.prototype.destroy.call(this, options);
  };
  BitmapText.styleDefaults = {
    align: "left",
    tint: 16777215,
    maxWidth: 0,
    letterSpacing: 0
  };
  return BitmapText;
})(Container);
var BitmapFontLoader = function() {
  function BitmapFontLoader2() {
  }
  BitmapFontLoader2.add = function() {
    LoaderResource.setExtensionXhrType("fnt", LoaderResource.XHR_RESPONSE_TYPE.TEXT);
  };
  BitmapFontLoader2.use = function(resource, next) {
    var format2 = autoDetectFormat(resource.data);
    if (!format2) {
      next();
      return;
    }
    var baseUrl = BitmapFontLoader2.getBaseUrl(this, resource);
    var data = format2.parse(resource.data);
    var textures = {};
    var completed = function(page) {
      textures[page.metadata.pageFile] = page.texture;
      if (Object.keys(textures).length === data.page.length) {
        resource.bitmapFont = BitmapFont.install(data, textures, true);
        next();
      }
    };
    for (var i2 = 0; i2 < data.page.length; ++i2) {
      var pageFile = data.page[i2].file;
      var url2 = baseUrl + pageFile;
      var exists = false;
      for (var name2 in this.resources) {
        var bitmapResource = this.resources[name2];
        if (bitmapResource.url === url2) {
          bitmapResource.metadata.pageFile = pageFile;
          if (bitmapResource.texture) {
            completed(bitmapResource);
          } else {
            bitmapResource.onAfterMiddleware.add(completed);
          }
          exists = true;
          break;
        }
      }
      if (!exists) {
        var options = {
          crossOrigin: resource.crossOrigin,
          loadType: LoaderResource.LOAD_TYPE.IMAGE,
          metadata: Object.assign({ pageFile }, resource.metadata.imageMetadata),
          parentResource: resource
        };
        this.add(url2, options, completed);
      }
    }
  };
  BitmapFontLoader2.getBaseUrl = function(loader, resource) {
    var resUrl = !resource.isDataUrl ? BitmapFontLoader2.dirname(resource.url) : "";
    if (resource.isDataUrl) {
      if (resUrl === ".") {
        resUrl = "";
      }
      if (loader.baseUrl && resUrl) {
        if (loader.baseUrl.charAt(loader.baseUrl.length - 1) === "/") {
          resUrl += "/";
        }
      }
    }
    resUrl = resUrl.replace(loader.baseUrl, "");
    if (resUrl && resUrl.charAt(resUrl.length - 1) !== "/") {
      resUrl += "/";
    }
    return resUrl;
  };
  BitmapFontLoader2.dirname = function(url2) {
    var dir = url2.replace(/\\/g, "/").replace(/\/$/, "").replace(/\/[^\/]*$/, "");
    if (dir === url2) {
      return ".";
    } else if (dir === "") {
      return "/";
    }
    return dir;
  };
  return BitmapFontLoader2;
}();
/*!
 * @pixi/filter-alpha - v6.3.0
 * Compiled Wed, 23 Mar 2022 18:58:56 UTC
 *
 * @pixi/filter-alpha is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
/*! *****************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */
var extendStatics$e = function(d2, b2) {
  extendStatics$e = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {
    d3.__proto__ = b3;
  } || function(d3, b3) {
    for (var p2 in b3) {
      if (b3.hasOwnProperty(p2)) {
        d3[p2] = b3[p2];
      }
    }
  };
  return extendStatics$e(d2, b2);
};
function __extends$e(d2, b2) {
  extendStatics$e(d2, b2);
  function __() {
    this.constructor = d2;
  }
  d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
}
var fragment$4 = "varying vec2 vTextureCoord;\n\nuniform sampler2D uSampler;\nuniform float uAlpha;\n\nvoid main(void)\n{\n   gl_FragColor = texture2D(uSampler, vTextureCoord) * uAlpha;\n}\n";
(function(_super) {
  __extends$e(AlphaFilter, _super);
  function AlphaFilter(alpha) {
    if (alpha === void 0) {
      alpha = 1;
    }
    var _this = _super.call(this, defaultVertex$2, fragment$4, { uAlpha: 1 }) || this;
    _this.alpha = alpha;
    return _this;
  }
  Object.defineProperty(AlphaFilter.prototype, "alpha", {
    get: function() {
      return this.uniforms.uAlpha;
    },
    set: function(value) {
      this.uniforms.uAlpha = value;
    },
    enumerable: false,
    configurable: true
  });
  return AlphaFilter;
})(Filter);
/*!
 * @pixi/filter-blur - v6.3.0
 * Compiled Wed, 23 Mar 2022 18:58:56 UTC
 *
 * @pixi/filter-blur is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
/*! *****************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */
var extendStatics$d = function(d2, b2) {
  extendStatics$d = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {
    d3.__proto__ = b3;
  } || function(d3, b3) {
    for (var p2 in b3) {
      if (b3.hasOwnProperty(p2)) {
        d3[p2] = b3[p2];
      }
    }
  };
  return extendStatics$d(d2, b2);
};
function __extends$d(d2, b2) {
  extendStatics$d(d2, b2);
  function __() {
    this.constructor = d2;
  }
  d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
}
var vertTemplate = "\n    attribute vec2 aVertexPosition;\n\n    uniform mat3 projectionMatrix;\n\n    uniform float strength;\n\n    varying vec2 vBlurTexCoords[%size%];\n\n    uniform vec4 inputSize;\n    uniform vec4 outputFrame;\n\n    vec4 filterVertexPosition( void )\n    {\n        vec2 position = aVertexPosition * max(outputFrame.zw, vec2(0.)) + outputFrame.xy;\n\n        return vec4((projectionMatrix * vec3(position, 1.0)).xy, 0.0, 1.0);\n    }\n\n    vec2 filterTextureCoord( void )\n    {\n        return aVertexPosition * (outputFrame.zw * inputSize.zw);\n    }\n\n    void main(void)\n    {\n        gl_Position = filterVertexPosition();\n\n        vec2 textureCoord = filterTextureCoord();\n        %blur%\n    }";
function generateBlurVertSource(kernelSize, x2) {
  var halfLength = Math.ceil(kernelSize / 2);
  var vertSource = vertTemplate;
  var blurLoop = "";
  var template;
  if (x2) {
    template = "vBlurTexCoords[%index%] =  textureCoord + vec2(%sampleIndex% * strength, 0.0);";
  } else {
    template = "vBlurTexCoords[%index%] =  textureCoord + vec2(0.0, %sampleIndex% * strength);";
  }
  for (var i2 = 0; i2 < kernelSize; i2++) {
    var blur = template.replace("%index%", i2.toString());
    blur = blur.replace("%sampleIndex%", i2 - (halfLength - 1) + ".0");
    blurLoop += blur;
    blurLoop += "\n";
  }
  vertSource = vertSource.replace("%blur%", blurLoop);
  vertSource = vertSource.replace("%size%", kernelSize.toString());
  return vertSource;
}
var GAUSSIAN_VALUES = {
  5: [0.153388, 0.221461, 0.250301],
  7: [0.071303, 0.131514, 0.189879, 0.214607],
  9: [0.028532, 0.067234, 0.124009, 0.179044, 0.20236],
  11: [93e-4, 0.028002, 0.065984, 0.121703, 0.175713, 0.198596],
  13: [2406e-6, 9255e-6, 0.027867, 0.065666, 0.121117, 0.174868, 0.197641],
  15: [489e-6, 2403e-6, 9246e-6, 0.02784, 0.065602, 0.120999, 0.174697, 0.197448]
};
var fragTemplate = [
  "varying vec2 vBlurTexCoords[%size%];",
  "uniform sampler2D uSampler;",
  "void main(void)",
  "{",
  "    gl_FragColor = vec4(0.0);",
  "    %blur%",
  "}"
].join("\n");
function generateBlurFragSource(kernelSize) {
  var kernel = GAUSSIAN_VALUES[kernelSize];
  var halfLength = kernel.length;
  var fragSource = fragTemplate;
  var blurLoop = "";
  var template = "gl_FragColor += texture2D(uSampler, vBlurTexCoords[%index%]) * %value%;";
  var value;
  for (var i2 = 0; i2 < kernelSize; i2++) {
    var blur = template.replace("%index%", i2.toString());
    value = i2;
    if (i2 >= halfLength) {
      value = kernelSize - i2 - 1;
    }
    blur = blur.replace("%value%", kernel[value].toString());
    blurLoop += blur;
    blurLoop += "\n";
  }
  fragSource = fragSource.replace("%blur%", blurLoop);
  fragSource = fragSource.replace("%size%", kernelSize.toString());
  return fragSource;
}
/*!
 * @pixi/constants - v6.3.0
 * Compiled Wed, 23 Mar 2022 18:58:56 UTC
 *
 * @pixi/constants is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
var ENV$1;
(function(ENV2) {
  ENV2[ENV2["WEBGL_LEGACY"] = 0] = "WEBGL_LEGACY";
  ENV2[ENV2["WEBGL"] = 1] = "WEBGL";
  ENV2[ENV2["WEBGL2"] = 2] = "WEBGL2";
})(ENV$1 || (ENV$1 = {}));
var RENDERER_TYPE$1;
(function(RENDERER_TYPE2) {
  RENDERER_TYPE2[RENDERER_TYPE2["UNKNOWN"] = 0] = "UNKNOWN";
  RENDERER_TYPE2[RENDERER_TYPE2["WEBGL"] = 1] = "WEBGL";
  RENDERER_TYPE2[RENDERER_TYPE2["CANVAS"] = 2] = "CANVAS";
})(RENDERER_TYPE$1 || (RENDERER_TYPE$1 = {}));
var BUFFER_BITS$1;
(function(BUFFER_BITS2) {
  BUFFER_BITS2[BUFFER_BITS2["COLOR"] = 16384] = "COLOR";
  BUFFER_BITS2[BUFFER_BITS2["DEPTH"] = 256] = "DEPTH";
  BUFFER_BITS2[BUFFER_BITS2["STENCIL"] = 1024] = "STENCIL";
})(BUFFER_BITS$1 || (BUFFER_BITS$1 = {}));
var BLEND_MODES$1;
(function(BLEND_MODES2) {
  BLEND_MODES2[BLEND_MODES2["NORMAL"] = 0] = "NORMAL";
  BLEND_MODES2[BLEND_MODES2["ADD"] = 1] = "ADD";
  BLEND_MODES2[BLEND_MODES2["MULTIPLY"] = 2] = "MULTIPLY";
  BLEND_MODES2[BLEND_MODES2["SCREEN"] = 3] = "SCREEN";
  BLEND_MODES2[BLEND_MODES2["OVERLAY"] = 4] = "OVERLAY";
  BLEND_MODES2[BLEND_MODES2["DARKEN"] = 5] = "DARKEN";
  BLEND_MODES2[BLEND_MODES2["LIGHTEN"] = 6] = "LIGHTEN";
  BLEND_MODES2[BLEND_MODES2["COLOR_DODGE"] = 7] = "COLOR_DODGE";
  BLEND_MODES2[BLEND_MODES2["COLOR_BURN"] = 8] = "COLOR_BURN";
  BLEND_MODES2[BLEND_MODES2["HARD_LIGHT"] = 9] = "HARD_LIGHT";
  BLEND_MODES2[BLEND_MODES2["SOFT_LIGHT"] = 10] = "SOFT_LIGHT";
  BLEND_MODES2[BLEND_MODES2["DIFFERENCE"] = 11] = "DIFFERENCE";
  BLEND_MODES2[BLEND_MODES2["EXCLUSION"] = 12] = "EXCLUSION";
  BLEND_MODES2[BLEND_MODES2["HUE"] = 13] = "HUE";
  BLEND_MODES2[BLEND_MODES2["SATURATION"] = 14] = "SATURATION";
  BLEND_MODES2[BLEND_MODES2["COLOR"] = 15] = "COLOR";
  BLEND_MODES2[BLEND_MODES2["LUMINOSITY"] = 16] = "LUMINOSITY";
  BLEND_MODES2[BLEND_MODES2["NORMAL_NPM"] = 17] = "NORMAL_NPM";
  BLEND_MODES2[BLEND_MODES2["ADD_NPM"] = 18] = "ADD_NPM";
  BLEND_MODES2[BLEND_MODES2["SCREEN_NPM"] = 19] = "SCREEN_NPM";
  BLEND_MODES2[BLEND_MODES2["NONE"] = 20] = "NONE";
  BLEND_MODES2[BLEND_MODES2["SRC_OVER"] = 0] = "SRC_OVER";
  BLEND_MODES2[BLEND_MODES2["SRC_IN"] = 21] = "SRC_IN";
  BLEND_MODES2[BLEND_MODES2["SRC_OUT"] = 22] = "SRC_OUT";
  BLEND_MODES2[BLEND_MODES2["SRC_ATOP"] = 23] = "SRC_ATOP";
  BLEND_MODES2[BLEND_MODES2["DST_OVER"] = 24] = "DST_OVER";
  BLEND_MODES2[BLEND_MODES2["DST_IN"] = 25] = "DST_IN";
  BLEND_MODES2[BLEND_MODES2["DST_OUT"] = 26] = "DST_OUT";
  BLEND_MODES2[BLEND_MODES2["DST_ATOP"] = 27] = "DST_ATOP";
  BLEND_MODES2[BLEND_MODES2["ERASE"] = 26] = "ERASE";
  BLEND_MODES2[BLEND_MODES2["SUBTRACT"] = 28] = "SUBTRACT";
  BLEND_MODES2[BLEND_MODES2["XOR"] = 29] = "XOR";
})(BLEND_MODES$1 || (BLEND_MODES$1 = {}));
var DRAW_MODES$1;
(function(DRAW_MODES2) {
  DRAW_MODES2[DRAW_MODES2["POINTS"] = 0] = "POINTS";
  DRAW_MODES2[DRAW_MODES2["LINES"] = 1] = "LINES";
  DRAW_MODES2[DRAW_MODES2["LINE_LOOP"] = 2] = "LINE_LOOP";
  DRAW_MODES2[DRAW_MODES2["LINE_STRIP"] = 3] = "LINE_STRIP";
  DRAW_MODES2[DRAW_MODES2["TRIANGLES"] = 4] = "TRIANGLES";
  DRAW_MODES2[DRAW_MODES2["TRIANGLE_STRIP"] = 5] = "TRIANGLE_STRIP";
  DRAW_MODES2[DRAW_MODES2["TRIANGLE_FAN"] = 6] = "TRIANGLE_FAN";
})(DRAW_MODES$1 || (DRAW_MODES$1 = {}));
var FORMATS$1;
(function(FORMATS2) {
  FORMATS2[FORMATS2["RGBA"] = 6408] = "RGBA";
  FORMATS2[FORMATS2["RGB"] = 6407] = "RGB";
  FORMATS2[FORMATS2["RG"] = 33319] = "RG";
  FORMATS2[FORMATS2["RED"] = 6403] = "RED";
  FORMATS2[FORMATS2["RGBA_INTEGER"] = 36249] = "RGBA_INTEGER";
  FORMATS2[FORMATS2["RGB_INTEGER"] = 36248] = "RGB_INTEGER";
  FORMATS2[FORMATS2["RG_INTEGER"] = 33320] = "RG_INTEGER";
  FORMATS2[FORMATS2["RED_INTEGER"] = 36244] = "RED_INTEGER";
  FORMATS2[FORMATS2["ALPHA"] = 6406] = "ALPHA";
  FORMATS2[FORMATS2["LUMINANCE"] = 6409] = "LUMINANCE";
  FORMATS2[FORMATS2["LUMINANCE_ALPHA"] = 6410] = "LUMINANCE_ALPHA";
  FORMATS2[FORMATS2["DEPTH_COMPONENT"] = 6402] = "DEPTH_COMPONENT";
  FORMATS2[FORMATS2["DEPTH_STENCIL"] = 34041] = "DEPTH_STENCIL";
})(FORMATS$1 || (FORMATS$1 = {}));
var TARGETS$1;
(function(TARGETS2) {
  TARGETS2[TARGETS2["TEXTURE_2D"] = 3553] = "TEXTURE_2D";
  TARGETS2[TARGETS2["TEXTURE_CUBE_MAP"] = 34067] = "TEXTURE_CUBE_MAP";
  TARGETS2[TARGETS2["TEXTURE_2D_ARRAY"] = 35866] = "TEXTURE_2D_ARRAY";
  TARGETS2[TARGETS2["TEXTURE_CUBE_MAP_POSITIVE_X"] = 34069] = "TEXTURE_CUBE_MAP_POSITIVE_X";
  TARGETS2[TARGETS2["TEXTURE_CUBE_MAP_NEGATIVE_X"] = 34070] = "TEXTURE_CUBE_MAP_NEGATIVE_X";
  TARGETS2[TARGETS2["TEXTURE_CUBE_MAP_POSITIVE_Y"] = 34071] = "TEXTURE_CUBE_MAP_POSITIVE_Y";
  TARGETS2[TARGETS2["TEXTURE_CUBE_MAP_NEGATIVE_Y"] = 34072] = "TEXTURE_CUBE_MAP_NEGATIVE_Y";
  TARGETS2[TARGETS2["TEXTURE_CUBE_MAP_POSITIVE_Z"] = 34073] = "TEXTURE_CUBE_MAP_POSITIVE_Z";
  TARGETS2[TARGETS2["TEXTURE_CUBE_MAP_NEGATIVE_Z"] = 34074] = "TEXTURE_CUBE_MAP_NEGATIVE_Z";
})(TARGETS$1 || (TARGETS$1 = {}));
var TYPES$1;
(function(TYPES2) {
  TYPES2[TYPES2["UNSIGNED_BYTE"] = 5121] = "UNSIGNED_BYTE";
  TYPES2[TYPES2["UNSIGNED_SHORT"] = 5123] = "UNSIGNED_SHORT";
  TYPES2[TYPES2["UNSIGNED_SHORT_5_6_5"] = 33635] = "UNSIGNED_SHORT_5_6_5";
  TYPES2[TYPES2["UNSIGNED_SHORT_4_4_4_4"] = 32819] = "UNSIGNED_SHORT_4_4_4_4";
  TYPES2[TYPES2["UNSIGNED_SHORT_5_5_5_1"] = 32820] = "UNSIGNED_SHORT_5_5_5_1";
  TYPES2[TYPES2["UNSIGNED_INT"] = 5125] = "UNSIGNED_INT";
  TYPES2[TYPES2["UNSIGNED_INT_10F_11F_11F_REV"] = 35899] = "UNSIGNED_INT_10F_11F_11F_REV";
  TYPES2[TYPES2["UNSIGNED_INT_2_10_10_10_REV"] = 33640] = "UNSIGNED_INT_2_10_10_10_REV";
  TYPES2[TYPES2["UNSIGNED_INT_24_8"] = 34042] = "UNSIGNED_INT_24_8";
  TYPES2[TYPES2["UNSIGNED_INT_5_9_9_9_REV"] = 35902] = "UNSIGNED_INT_5_9_9_9_REV";
  TYPES2[TYPES2["BYTE"] = 5120] = "BYTE";
  TYPES2[TYPES2["SHORT"] = 5122] = "SHORT";
  TYPES2[TYPES2["INT"] = 5124] = "INT";
  TYPES2[TYPES2["FLOAT"] = 5126] = "FLOAT";
  TYPES2[TYPES2["FLOAT_32_UNSIGNED_INT_24_8_REV"] = 36269] = "FLOAT_32_UNSIGNED_INT_24_8_REV";
  TYPES2[TYPES2["HALF_FLOAT"] = 36193] = "HALF_FLOAT";
})(TYPES$1 || (TYPES$1 = {}));
var SAMPLER_TYPES$1;
(function(SAMPLER_TYPES2) {
  SAMPLER_TYPES2[SAMPLER_TYPES2["FLOAT"] = 0] = "FLOAT";
  SAMPLER_TYPES2[SAMPLER_TYPES2["INT"] = 1] = "INT";
  SAMPLER_TYPES2[SAMPLER_TYPES2["UINT"] = 2] = "UINT";
})(SAMPLER_TYPES$1 || (SAMPLER_TYPES$1 = {}));
var SCALE_MODES$1;
(function(SCALE_MODES2) {
  SCALE_MODES2[SCALE_MODES2["NEAREST"] = 0] = "NEAREST";
  SCALE_MODES2[SCALE_MODES2["LINEAR"] = 1] = "LINEAR";
})(SCALE_MODES$1 || (SCALE_MODES$1 = {}));
var WRAP_MODES$1;
(function(WRAP_MODES2) {
  WRAP_MODES2[WRAP_MODES2["CLAMP"] = 33071] = "CLAMP";
  WRAP_MODES2[WRAP_MODES2["REPEAT"] = 10497] = "REPEAT";
  WRAP_MODES2[WRAP_MODES2["MIRRORED_REPEAT"] = 33648] = "MIRRORED_REPEAT";
})(WRAP_MODES$1 || (WRAP_MODES$1 = {}));
var MIPMAP_MODES$1;
(function(MIPMAP_MODES2) {
  MIPMAP_MODES2[MIPMAP_MODES2["OFF"] = 0] = "OFF";
  MIPMAP_MODES2[MIPMAP_MODES2["POW2"] = 1] = "POW2";
  MIPMAP_MODES2[MIPMAP_MODES2["ON"] = 2] = "ON";
  MIPMAP_MODES2[MIPMAP_MODES2["ON_MANUAL"] = 3] = "ON_MANUAL";
})(MIPMAP_MODES$1 || (MIPMAP_MODES$1 = {}));
var ALPHA_MODES$1;
(function(ALPHA_MODES2) {
  ALPHA_MODES2[ALPHA_MODES2["NPM"] = 0] = "NPM";
  ALPHA_MODES2[ALPHA_MODES2["UNPACK"] = 1] = "UNPACK";
  ALPHA_MODES2[ALPHA_MODES2["PMA"] = 2] = "PMA";
  ALPHA_MODES2[ALPHA_MODES2["NO_PREMULTIPLIED_ALPHA"] = 0] = "NO_PREMULTIPLIED_ALPHA";
  ALPHA_MODES2[ALPHA_MODES2["PREMULTIPLY_ON_UPLOAD"] = 1] = "PREMULTIPLY_ON_UPLOAD";
  ALPHA_MODES2[ALPHA_MODES2["PREMULTIPLY_ALPHA"] = 2] = "PREMULTIPLY_ALPHA";
  ALPHA_MODES2[ALPHA_MODES2["PREMULTIPLIED_ALPHA"] = 2] = "PREMULTIPLIED_ALPHA";
})(ALPHA_MODES$1 || (ALPHA_MODES$1 = {}));
var CLEAR_MODES$1;
(function(CLEAR_MODES2) {
  CLEAR_MODES2[CLEAR_MODES2["NO"] = 0] = "NO";
  CLEAR_MODES2[CLEAR_MODES2["YES"] = 1] = "YES";
  CLEAR_MODES2[CLEAR_MODES2["AUTO"] = 2] = "AUTO";
  CLEAR_MODES2[CLEAR_MODES2["BLEND"] = 0] = "BLEND";
  CLEAR_MODES2[CLEAR_MODES2["CLEAR"] = 1] = "CLEAR";
  CLEAR_MODES2[CLEAR_MODES2["BLIT"] = 2] = "BLIT";
})(CLEAR_MODES$1 || (CLEAR_MODES$1 = {}));
var GC_MODES$1;
(function(GC_MODES2) {
  GC_MODES2[GC_MODES2["AUTO"] = 0] = "AUTO";
  GC_MODES2[GC_MODES2["MANUAL"] = 1] = "MANUAL";
})(GC_MODES$1 || (GC_MODES$1 = {}));
var PRECISION$1;
(function(PRECISION2) {
  PRECISION2["LOW"] = "lowp";
  PRECISION2["MEDIUM"] = "mediump";
  PRECISION2["HIGH"] = "highp";
})(PRECISION$1 || (PRECISION$1 = {}));
var MASK_TYPES$1;
(function(MASK_TYPES2) {
  MASK_TYPES2[MASK_TYPES2["NONE"] = 0] = "NONE";
  MASK_TYPES2[MASK_TYPES2["SCISSOR"] = 1] = "SCISSOR";
  MASK_TYPES2[MASK_TYPES2["STENCIL"] = 2] = "STENCIL";
  MASK_TYPES2[MASK_TYPES2["SPRITE"] = 3] = "SPRITE";
})(MASK_TYPES$1 || (MASK_TYPES$1 = {}));
var MSAA_QUALITY$1;
(function(MSAA_QUALITY2) {
  MSAA_QUALITY2[MSAA_QUALITY2["NONE"] = 0] = "NONE";
  MSAA_QUALITY2[MSAA_QUALITY2["LOW"] = 2] = "LOW";
  MSAA_QUALITY2[MSAA_QUALITY2["MEDIUM"] = 4] = "MEDIUM";
  MSAA_QUALITY2[MSAA_QUALITY2["HIGH"] = 8] = "HIGH";
})(MSAA_QUALITY$1 || (MSAA_QUALITY$1 = {}));
var BUFFER_TYPE$1;
(function(BUFFER_TYPE2) {
  BUFFER_TYPE2[BUFFER_TYPE2["ELEMENT_ARRAY_BUFFER"] = 34963] = "ELEMENT_ARRAY_BUFFER";
  BUFFER_TYPE2[BUFFER_TYPE2["ARRAY_BUFFER"] = 34962] = "ARRAY_BUFFER";
  BUFFER_TYPE2[BUFFER_TYPE2["UNIFORM_BUFFER"] = 35345] = "UNIFORM_BUFFER";
})(BUFFER_TYPE$1 || (BUFFER_TYPE$1 = {}));
var BlurFilterPass = function(_super) {
  __extends$d(BlurFilterPass2, _super);
  function BlurFilterPass2(horizontal, strength, quality, resolution, kernelSize) {
    if (strength === void 0) {
      strength = 8;
    }
    if (quality === void 0) {
      quality = 4;
    }
    if (resolution === void 0) {
      resolution = settings.FILTER_RESOLUTION;
    }
    if (kernelSize === void 0) {
      kernelSize = 5;
    }
    var _this = this;
    var vertSrc = generateBlurVertSource(kernelSize, horizontal);
    var fragSrc = generateBlurFragSource(kernelSize);
    _this = _super.call(this, vertSrc, fragSrc) || this;
    _this.horizontal = horizontal;
    _this.resolution = resolution;
    _this._quality = 0;
    _this.quality = quality;
    _this.blur = strength;
    return _this;
  }
  BlurFilterPass2.prototype.apply = function(filterManager, input, output, clearMode) {
    if (output) {
      if (this.horizontal) {
        this.uniforms.strength = 1 / output.width * (output.width / input.width);
      } else {
        this.uniforms.strength = 1 / output.height * (output.height / input.height);
      }
    } else {
      if (this.horizontal) {
        this.uniforms.strength = 1 / filterManager.renderer.width * (filterManager.renderer.width / input.width);
      } else {
        this.uniforms.strength = 1 / filterManager.renderer.height * (filterManager.renderer.height / input.height);
      }
    }
    this.uniforms.strength *= this.strength;
    this.uniforms.strength /= this.passes;
    if (this.passes === 1) {
      filterManager.applyFilter(this, input, output, clearMode);
    } else {
      var renderTarget = filterManager.getFilterTexture();
      var renderer = filterManager.renderer;
      var flip = input;
      var flop = renderTarget;
      this.state.blend = false;
      filterManager.applyFilter(this, flip, flop, CLEAR_MODES$1.CLEAR);
      for (var i2 = 1; i2 < this.passes - 1; i2++) {
        filterManager.bindAndClear(flip, CLEAR_MODES$1.BLIT);
        this.uniforms.uSampler = flop;
        var temp2 = flop;
        flop = flip;
        flip = temp2;
        renderer.shader.bind(this);
        renderer.geometry.draw(5);
      }
      this.state.blend = true;
      filterManager.applyFilter(this, flop, output, clearMode);
      filterManager.returnFilterTexture(renderTarget);
    }
  };
  Object.defineProperty(BlurFilterPass2.prototype, "blur", {
    get: function() {
      return this.strength;
    },
    set: function(value) {
      this.padding = 1 + Math.abs(value) * 2;
      this.strength = value;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(BlurFilterPass2.prototype, "quality", {
    get: function() {
      return this._quality;
    },
    set: function(value) {
      this._quality = value;
      this.passes = value;
    },
    enumerable: false,
    configurable: true
  });
  return BlurFilterPass2;
}(Filter);
(function(_super) {
  __extends$d(BlurFilter, _super);
  function BlurFilter(strength, quality, resolution, kernelSize) {
    if (strength === void 0) {
      strength = 8;
    }
    if (quality === void 0) {
      quality = 4;
    }
    if (resolution === void 0) {
      resolution = settings.FILTER_RESOLUTION;
    }
    if (kernelSize === void 0) {
      kernelSize = 5;
    }
    var _this = _super.call(this) || this;
    _this.blurXFilter = new BlurFilterPass(true, strength, quality, resolution, kernelSize);
    _this.blurYFilter = new BlurFilterPass(false, strength, quality, resolution, kernelSize);
    _this.resolution = resolution;
    _this.quality = quality;
    _this.blur = strength;
    _this.repeatEdgePixels = false;
    return _this;
  }
  BlurFilter.prototype.apply = function(filterManager, input, output, clearMode) {
    var xStrength = Math.abs(this.blurXFilter.strength);
    var yStrength = Math.abs(this.blurYFilter.strength);
    if (xStrength && yStrength) {
      var renderTarget = filterManager.getFilterTexture();
      this.blurXFilter.apply(filterManager, input, renderTarget, CLEAR_MODES$1.CLEAR);
      this.blurYFilter.apply(filterManager, renderTarget, output, clearMode);
      filterManager.returnFilterTexture(renderTarget);
    } else if (yStrength) {
      this.blurYFilter.apply(filterManager, input, output, clearMode);
    } else {
      this.blurXFilter.apply(filterManager, input, output, clearMode);
    }
  };
  BlurFilter.prototype.updatePadding = function() {
    if (this._repeatEdgePixels) {
      this.padding = 0;
    } else {
      this.padding = Math.max(Math.abs(this.blurXFilter.strength), Math.abs(this.blurYFilter.strength)) * 2;
    }
  };
  Object.defineProperty(BlurFilter.prototype, "blur", {
    get: function() {
      return this.blurXFilter.blur;
    },
    set: function(value) {
      this.blurXFilter.blur = this.blurYFilter.blur = value;
      this.updatePadding();
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(BlurFilter.prototype, "quality", {
    get: function() {
      return this.blurXFilter.quality;
    },
    set: function(value) {
      this.blurXFilter.quality = this.blurYFilter.quality = value;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(BlurFilter.prototype, "blurX", {
    get: function() {
      return this.blurXFilter.blur;
    },
    set: function(value) {
      this.blurXFilter.blur = value;
      this.updatePadding();
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(BlurFilter.prototype, "blurY", {
    get: function() {
      return this.blurYFilter.blur;
    },
    set: function(value) {
      this.blurYFilter.blur = value;
      this.updatePadding();
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(BlurFilter.prototype, "blendMode", {
    get: function() {
      return this.blurYFilter.blendMode;
    },
    set: function(value) {
      this.blurYFilter.blendMode = value;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(BlurFilter.prototype, "repeatEdgePixels", {
    get: function() {
      return this._repeatEdgePixels;
    },
    set: function(value) {
      this._repeatEdgePixels = value;
      this.updatePadding();
    },
    enumerable: false,
    configurable: true
  });
  return BlurFilter;
})(Filter);
/*!
 * @pixi/filter-color-matrix - v6.3.0
 * Compiled Wed, 23 Mar 2022 18:58:56 UTC
 *
 * @pixi/filter-color-matrix is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
/*! *****************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */
var extendStatics$c = function(d2, b2) {
  extendStatics$c = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {
    d3.__proto__ = b3;
  } || function(d3, b3) {
    for (var p2 in b3) {
      if (b3.hasOwnProperty(p2)) {
        d3[p2] = b3[p2];
      }
    }
  };
  return extendStatics$c(d2, b2);
};
function __extends$c(d2, b2) {
  extendStatics$c(d2, b2);
  function __() {
    this.constructor = d2;
  }
  d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
}
var fragment$3 = "varying vec2 vTextureCoord;\nuniform sampler2D uSampler;\nuniform float m[20];\nuniform float uAlpha;\n\nvoid main(void)\n{\n    vec4 c = texture2D(uSampler, vTextureCoord);\n\n    if (uAlpha == 0.0) {\n        gl_FragColor = c;\n        return;\n    }\n\n    // Un-premultiply alpha before applying the color matrix. See issue #3539.\n    if (c.a > 0.0) {\n      c.rgb /= c.a;\n    }\n\n    vec4 result;\n\n    result.r = (m[0] * c.r);\n        result.r += (m[1] * c.g);\n        result.r += (m[2] * c.b);\n        result.r += (m[3] * c.a);\n        result.r += m[4];\n\n    result.g = (m[5] * c.r);\n        result.g += (m[6] * c.g);\n        result.g += (m[7] * c.b);\n        result.g += (m[8] * c.a);\n        result.g += m[9];\n\n    result.b = (m[10] * c.r);\n       result.b += (m[11] * c.g);\n       result.b += (m[12] * c.b);\n       result.b += (m[13] * c.a);\n       result.b += m[14];\n\n    result.a = (m[15] * c.r);\n       result.a += (m[16] * c.g);\n       result.a += (m[17] * c.b);\n       result.a += (m[18] * c.a);\n       result.a += m[19];\n\n    vec3 rgb = mix(c.rgb, result.rgb, uAlpha);\n\n    // Premultiply alpha again.\n    rgb *= result.a;\n\n    gl_FragColor = vec4(rgb, result.a);\n}\n";
var ColorMatrixFilter = function(_super) {
  __extends$c(ColorMatrixFilter2, _super);
  function ColorMatrixFilter2() {
    var _this = this;
    var uniforms = {
      m: new Float32Array([
        1,
        0,
        0,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        0,
        0,
        1,
        0
      ]),
      uAlpha: 1
    };
    _this = _super.call(this, defaultFilterVertex, fragment$3, uniforms) || this;
    _this.alpha = 1;
    return _this;
  }
  ColorMatrixFilter2.prototype._loadMatrix = function(matrix, multiply3) {
    if (multiply3 === void 0) {
      multiply3 = false;
    }
    var newMatrix = matrix;
    if (multiply3) {
      this._multiply(newMatrix, this.uniforms.m, matrix);
      newMatrix = this._colorMatrix(newMatrix);
    }
    this.uniforms.m = newMatrix;
  };
  ColorMatrixFilter2.prototype._multiply = function(out, a2, b2) {
    out[0] = a2[0] * b2[0] + a2[1] * b2[5] + a2[2] * b2[10] + a2[3] * b2[15];
    out[1] = a2[0] * b2[1] + a2[1] * b2[6] + a2[2] * b2[11] + a2[3] * b2[16];
    out[2] = a2[0] * b2[2] + a2[1] * b2[7] + a2[2] * b2[12] + a2[3] * b2[17];
    out[3] = a2[0] * b2[3] + a2[1] * b2[8] + a2[2] * b2[13] + a2[3] * b2[18];
    out[4] = a2[0] * b2[4] + a2[1] * b2[9] + a2[2] * b2[14] + a2[3] * b2[19] + a2[4];
    out[5] = a2[5] * b2[0] + a2[6] * b2[5] + a2[7] * b2[10] + a2[8] * b2[15];
    out[6] = a2[5] * b2[1] + a2[6] * b2[6] + a2[7] * b2[11] + a2[8] * b2[16];
    out[7] = a2[5] * b2[2] + a2[6] * b2[7] + a2[7] * b2[12] + a2[8] * b2[17];
    out[8] = a2[5] * b2[3] + a2[6] * b2[8] + a2[7] * b2[13] + a2[8] * b2[18];
    out[9] = a2[5] * b2[4] + a2[6] * b2[9] + a2[7] * b2[14] + a2[8] * b2[19] + a2[9];
    out[10] = a2[10] * b2[0] + a2[11] * b2[5] + a2[12] * b2[10] + a2[13] * b2[15];
    out[11] = a2[10] * b2[1] + a2[11] * b2[6] + a2[12] * b2[11] + a2[13] * b2[16];
    out[12] = a2[10] * b2[2] + a2[11] * b2[7] + a2[12] * b2[12] + a2[13] * b2[17];
    out[13] = a2[10] * b2[3] + a2[11] * b2[8] + a2[12] * b2[13] + a2[13] * b2[18];
    out[14] = a2[10] * b2[4] + a2[11] * b2[9] + a2[12] * b2[14] + a2[13] * b2[19] + a2[14];
    out[15] = a2[15] * b2[0] + a2[16] * b2[5] + a2[17] * b2[10] + a2[18] * b2[15];
    out[16] = a2[15] * b2[1] + a2[16] * b2[6] + a2[17] * b2[11] + a2[18] * b2[16];
    out[17] = a2[15] * b2[2] + a2[16] * b2[7] + a2[17] * b2[12] + a2[18] * b2[17];
    out[18] = a2[15] * b2[3] + a2[16] * b2[8] + a2[17] * b2[13] + a2[18] * b2[18];
    out[19] = a2[15] * b2[4] + a2[16] * b2[9] + a2[17] * b2[14] + a2[18] * b2[19] + a2[19];
    return out;
  };
  ColorMatrixFilter2.prototype._colorMatrix = function(matrix) {
    var m2 = new Float32Array(matrix);
    m2[4] /= 255;
    m2[9] /= 255;
    m2[14] /= 255;
    m2[19] /= 255;
    return m2;
  };
  ColorMatrixFilter2.prototype.brightness = function(b2, multiply3) {
    var matrix = [
      b2,
      0,
      0,
      0,
      0,
      0,
      b2,
      0,
      0,
      0,
      0,
      0,
      b2,
      0,
      0,
      0,
      0,
      0,
      1,
      0
    ];
    this._loadMatrix(matrix, multiply3);
  };
  ColorMatrixFilter2.prototype.tint = function(color, multiply3) {
    var r2 = color >> 16 & 255;
    var g2 = color >> 8 & 255;
    var b2 = color & 255;
    var matrix = [
      r2 / 255,
      0,
      0,
      0,
      0,
      0,
      g2 / 255,
      0,
      0,
      0,
      0,
      0,
      b2 / 255,
      0,
      0,
      0,
      0,
      0,
      1,
      0
    ];
    this._loadMatrix(matrix, multiply3);
  };
  ColorMatrixFilter2.prototype.greyscale = function(scale, multiply3) {
    var matrix = [
      scale,
      scale,
      scale,
      0,
      0,
      scale,
      scale,
      scale,
      0,
      0,
      scale,
      scale,
      scale,
      0,
      0,
      0,
      0,
      0,
      1,
      0
    ];
    this._loadMatrix(matrix, multiply3);
  };
  ColorMatrixFilter2.prototype.blackAndWhite = function(multiply3) {
    var matrix = [
      0.3,
      0.6,
      0.1,
      0,
      0,
      0.3,
      0.6,
      0.1,
      0,
      0,
      0.3,
      0.6,
      0.1,
      0,
      0,
      0,
      0,
      0,
      1,
      0
    ];
    this._loadMatrix(matrix, multiply3);
  };
  ColorMatrixFilter2.prototype.hue = function(rotation, multiply3) {
    rotation = (rotation || 0) / 180 * Math.PI;
    var cosR = Math.cos(rotation);
    var sinR = Math.sin(rotation);
    var sqrt = Math.sqrt;
    var w2 = 1 / 3;
    var sqrW = sqrt(w2);
    var a00 = cosR + (1 - cosR) * w2;
    var a01 = w2 * (1 - cosR) - sqrW * sinR;
    var a02 = w2 * (1 - cosR) + sqrW * sinR;
    var a10 = w2 * (1 - cosR) + sqrW * sinR;
    var a11 = cosR + w2 * (1 - cosR);
    var a12 = w2 * (1 - cosR) - sqrW * sinR;
    var a20 = w2 * (1 - cosR) - sqrW * sinR;
    var a21 = w2 * (1 - cosR) + sqrW * sinR;
    var a22 = cosR + w2 * (1 - cosR);
    var matrix = [
      a00,
      a01,
      a02,
      0,
      0,
      a10,
      a11,
      a12,
      0,
      0,
      a20,
      a21,
      a22,
      0,
      0,
      0,
      0,
      0,
      1,
      0
    ];
    this._loadMatrix(matrix, multiply3);
  };
  ColorMatrixFilter2.prototype.contrast = function(amount, multiply3) {
    var v2 = (amount || 0) + 1;
    var o = -0.5 * (v2 - 1);
    var matrix = [
      v2,
      0,
      0,
      0,
      o,
      0,
      v2,
      0,
      0,
      o,
      0,
      0,
      v2,
      0,
      o,
      0,
      0,
      0,
      1,
      0
    ];
    this._loadMatrix(matrix, multiply3);
  };
  ColorMatrixFilter2.prototype.saturate = function(amount, multiply3) {
    if (amount === void 0) {
      amount = 0;
    }
    var x2 = amount * 2 / 3 + 1;
    var y2 = (x2 - 1) * -0.5;
    var matrix = [
      x2,
      y2,
      y2,
      0,
      0,
      y2,
      x2,
      y2,
      0,
      0,
      y2,
      y2,
      x2,
      0,
      0,
      0,
      0,
      0,
      1,
      0
    ];
    this._loadMatrix(matrix, multiply3);
  };
  ColorMatrixFilter2.prototype.desaturate = function() {
    this.saturate(-1);
  };
  ColorMatrixFilter2.prototype.negative = function(multiply3) {
    var matrix = [
      -1,
      0,
      0,
      1,
      0,
      0,
      -1,
      0,
      1,
      0,
      0,
      0,
      -1,
      1,
      0,
      0,
      0,
      0,
      1,
      0
    ];
    this._loadMatrix(matrix, multiply3);
  };
  ColorMatrixFilter2.prototype.sepia = function(multiply3) {
    var matrix = [
      0.393,
      0.7689999,
      0.18899999,
      0,
      0,
      0.349,
      0.6859999,
      0.16799999,
      0,
      0,
      0.272,
      0.5339999,
      0.13099999,
      0,
      0,
      0,
      0,
      0,
      1,
      0
    ];
    this._loadMatrix(matrix, multiply3);
  };
  ColorMatrixFilter2.prototype.technicolor = function(multiply3) {
    var matrix = [
      1.9125277891456083,
      -0.8545344976951645,
      -0.09155508482755585,
      0,
      11.793603434377337,
      -0.3087833385928097,
      1.7658908555458428,
      -0.10601743074722245,
      0,
      -70.35205161461398,
      -0.231103377548616,
      -0.7501899197440212,
      1.847597816108189,
      0,
      30.950940869491138,
      0,
      0,
      0,
      1,
      0
    ];
    this._loadMatrix(matrix, multiply3);
  };
  ColorMatrixFilter2.prototype.polaroid = function(multiply3) {
    var matrix = [
      1.438,
      -0.062,
      -0.062,
      0,
      0,
      -0.122,
      1.378,
      -0.122,
      0,
      0,
      -0.016,
      -0.016,
      1.483,
      0,
      0,
      0,
      0,
      0,
      1,
      0
    ];
    this._loadMatrix(matrix, multiply3);
  };
  ColorMatrixFilter2.prototype.toBGR = function(multiply3) {
    var matrix = [
      0,
      0,
      1,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      1,
      0
    ];
    this._loadMatrix(matrix, multiply3);
  };
  ColorMatrixFilter2.prototype.kodachrome = function(multiply3) {
    var matrix = [
      1.1285582396593525,
      -0.3967382283601348,
      -0.03992559172921793,
      0,
      63.72958762196502,
      -0.16404339962244616,
      1.0835251566291304,
      -0.05498805115633132,
      0,
      24.732407896706203,
      -0.16786010706155763,
      -0.5603416277695248,
      1.6014850761964943,
      0,
      35.62982807460946,
      0,
      0,
      0,
      1,
      0
    ];
    this._loadMatrix(matrix, multiply3);
  };
  ColorMatrixFilter2.prototype.browni = function(multiply3) {
    var matrix = [
      0.5997023498159715,
      0.34553243048391263,
      -0.2708298674538042,
      0,
      47.43192855600873,
      -0.037703249837783157,
      0.8609577587992641,
      0.15059552388459913,
      0,
      -36.96841498319127,
      0.24113635128153335,
      -0.07441037908422492,
      0.44972182064877153,
      0,
      -7.562075277591283,
      0,
      0,
      0,
      1,
      0
    ];
    this._loadMatrix(matrix, multiply3);
  };
  ColorMatrixFilter2.prototype.vintage = function(multiply3) {
    var matrix = [
      0.6279345635605994,
      0.3202183420819367,
      -0.03965408211312453,
      0,
      9.651285835294123,
      0.02578397704808868,
      0.6441188644374771,
      0.03259127616149294,
      0,
      7.462829176470591,
      0.0466055556782719,
      -0.0851232987247891,
      0.5241648018700465,
      0,
      5.159190588235296,
      0,
      0,
      0,
      1,
      0
    ];
    this._loadMatrix(matrix, multiply3);
  };
  ColorMatrixFilter2.prototype.colorTone = function(desaturation, toned, lightColor, darkColor, multiply3) {
    desaturation = desaturation || 0.2;
    toned = toned || 0.15;
    lightColor = lightColor || 16770432;
    darkColor = darkColor || 3375104;
    var lR = (lightColor >> 16 & 255) / 255;
    var lG = (lightColor >> 8 & 255) / 255;
    var lB = (lightColor & 255) / 255;
    var dR = (darkColor >> 16 & 255) / 255;
    var dG = (darkColor >> 8 & 255) / 255;
    var dB = (darkColor & 255) / 255;
    var matrix = [
      0.3,
      0.59,
      0.11,
      0,
      0,
      lR,
      lG,
      lB,
      desaturation,
      0,
      dR,
      dG,
      dB,
      toned,
      0,
      lR - dR,
      lG - dG,
      lB - dB,
      0,
      0
    ];
    this._loadMatrix(matrix, multiply3);
  };
  ColorMatrixFilter2.prototype.night = function(intensity, multiply3) {
    intensity = intensity || 0.1;
    var matrix = [
      intensity * -2,
      -intensity,
      0,
      0,
      0,
      -intensity,
      0,
      intensity,
      0,
      0,
      0,
      intensity,
      intensity * 2,
      0,
      0,
      0,
      0,
      0,
      1,
      0
    ];
    this._loadMatrix(matrix, multiply3);
  };
  ColorMatrixFilter2.prototype.predator = function(amount, multiply3) {
    var matrix = [
      11.224130630493164 * amount,
      -4.794486999511719 * amount,
      -2.8746118545532227 * amount,
      0 * amount,
      0.40342438220977783 * amount,
      -3.6330697536468506 * amount,
      9.193157196044922 * amount,
      -2.951810836791992 * amount,
      0 * amount,
      -1.316135048866272 * amount,
      -3.2184197902679443 * amount,
      -4.2375030517578125 * amount,
      7.476448059082031 * amount,
      0 * amount,
      0.8044459223747253 * amount,
      0,
      0,
      0,
      1,
      0
    ];
    this._loadMatrix(matrix, multiply3);
  };
  ColorMatrixFilter2.prototype.lsd = function(multiply3) {
    var matrix = [
      2,
      -0.4,
      0.5,
      0,
      0,
      -0.5,
      2,
      -0.4,
      0,
      0,
      -0.4,
      -0.5,
      3,
      0,
      0,
      0,
      0,
      0,
      1,
      0
    ];
    this._loadMatrix(matrix, multiply3);
  };
  ColorMatrixFilter2.prototype.reset = function() {
    var matrix = [
      1,
      0,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      1,
      0
    ];
    this._loadMatrix(matrix, false);
  };
  Object.defineProperty(ColorMatrixFilter2.prototype, "matrix", {
    get: function() {
      return this.uniforms.m;
    },
    set: function(value) {
      this.uniforms.m = value;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(ColorMatrixFilter2.prototype, "alpha", {
    get: function() {
      return this.uniforms.uAlpha;
    },
    set: function(value) {
      this.uniforms.uAlpha = value;
    },
    enumerable: false,
    configurable: true
  });
  return ColorMatrixFilter2;
}(Filter);
ColorMatrixFilter.prototype.grayscale = ColorMatrixFilter.prototype.greyscale;
/*!
 * @pixi/filter-displacement - v6.3.0
 * Compiled Wed, 23 Mar 2022 18:58:56 UTC
 *
 * @pixi/filter-displacement is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
/*! *****************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */
var extendStatics$b = function(d2, b2) {
  extendStatics$b = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {
    d3.__proto__ = b3;
  } || function(d3, b3) {
    for (var p2 in b3) {
      if (b3.hasOwnProperty(p2)) {
        d3[p2] = b3[p2];
      }
    }
  };
  return extendStatics$b(d2, b2);
};
function __extends$b(d2, b2) {
  extendStatics$b(d2, b2);
  function __() {
    this.constructor = d2;
  }
  d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
}
var fragment$2 = "varying vec2 vFilterCoord;\nvarying vec2 vTextureCoord;\n\nuniform vec2 scale;\nuniform mat2 rotation;\nuniform sampler2D uSampler;\nuniform sampler2D mapSampler;\n\nuniform highp vec4 inputSize;\nuniform vec4 inputClamp;\n\nvoid main(void)\n{\n  vec4 map =  texture2D(mapSampler, vFilterCoord);\n\n  map -= 0.5;\n  map.xy = scale * inputSize.zw * (rotation * map.xy);\n\n  gl_FragColor = texture2D(uSampler, clamp(vec2(vTextureCoord.x + map.x, vTextureCoord.y + map.y), inputClamp.xy, inputClamp.zw));\n}\n";
var vertex$1 = "attribute vec2 aVertexPosition;\n\nuniform mat3 projectionMatrix;\nuniform mat3 filterMatrix;\n\nvarying vec2 vTextureCoord;\nvarying vec2 vFilterCoord;\n\nuniform vec4 inputSize;\nuniform vec4 outputFrame;\n\nvec4 filterVertexPosition( void )\n{\n    vec2 position = aVertexPosition * max(outputFrame.zw, vec2(0.)) + outputFrame.xy;\n\n    return vec4((projectionMatrix * vec3(position, 1.0)).xy, 0.0, 1.0);\n}\n\nvec2 filterTextureCoord( void )\n{\n    return aVertexPosition * (outputFrame.zw * inputSize.zw);\n}\n\nvoid main(void)\n{\n	gl_Position = filterVertexPosition();\n	vTextureCoord = filterTextureCoord();\n	vFilterCoord = ( filterMatrix * vec3( vTextureCoord, 1.0)  ).xy;\n}\n";
(function(_super) {
  __extends$b(DisplacementFilter, _super);
  function DisplacementFilter(sprite, scale) {
    var _this = this;
    var maskMatrix = new Matrix();
    sprite.renderable = false;
    _this = _super.call(this, vertex$1, fragment$2, {
      mapSampler: sprite._texture,
      filterMatrix: maskMatrix,
      scale: { x: 1, y: 1 },
      rotation: new Float32Array([1, 0, 0, 1])
    }) || this;
    _this.maskSprite = sprite;
    _this.maskMatrix = maskMatrix;
    if (scale === null || scale === void 0) {
      scale = 20;
    }
    _this.scale = new Point(scale, scale);
    return _this;
  }
  DisplacementFilter.prototype.apply = function(filterManager, input, output, clearMode) {
    this.uniforms.filterMatrix = filterManager.calculateSpriteMatrix(this.maskMatrix, this.maskSprite);
    this.uniforms.scale.x = this.scale.x;
    this.uniforms.scale.y = this.scale.y;
    var wt = this.maskSprite.worldTransform;
    var lenX = Math.sqrt(wt.a * wt.a + wt.b * wt.b);
    var lenY = Math.sqrt(wt.c * wt.c + wt.d * wt.d);
    if (lenX !== 0 && lenY !== 0) {
      this.uniforms.rotation[0] = wt.a / lenX;
      this.uniforms.rotation[1] = wt.b / lenX;
      this.uniforms.rotation[2] = wt.c / lenY;
      this.uniforms.rotation[3] = wt.d / lenY;
    }
    filterManager.applyFilter(this, input, output, clearMode);
  };
  Object.defineProperty(DisplacementFilter.prototype, "map", {
    get: function() {
      return this.uniforms.mapSampler;
    },
    set: function(value) {
      this.uniforms.mapSampler = value;
    },
    enumerable: false,
    configurable: true
  });
  return DisplacementFilter;
})(Filter);
/*!
 * @pixi/filter-fxaa - v6.3.0
 * Compiled Wed, 23 Mar 2022 18:58:56 UTC
 *
 * @pixi/filter-fxaa is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
/*! *****************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */
var extendStatics$a = function(d2, b2) {
  extendStatics$a = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {
    d3.__proto__ = b3;
  } || function(d3, b3) {
    for (var p2 in b3) {
      if (b3.hasOwnProperty(p2)) {
        d3[p2] = b3[p2];
      }
    }
  };
  return extendStatics$a(d2, b2);
};
function __extends$a(d2, b2) {
  extendStatics$a(d2, b2);
  function __() {
    this.constructor = d2;
  }
  d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
}
var vertex = "\nattribute vec2 aVertexPosition;\n\nuniform mat3 projectionMatrix;\n\nvarying vec2 v_rgbNW;\nvarying vec2 v_rgbNE;\nvarying vec2 v_rgbSW;\nvarying vec2 v_rgbSE;\nvarying vec2 v_rgbM;\n\nvarying vec2 vFragCoord;\n\nuniform vec4 inputSize;\nuniform vec4 outputFrame;\n\nvec4 filterVertexPosition( void )\n{\n    vec2 position = aVertexPosition * max(outputFrame.zw, vec2(0.)) + outputFrame.xy;\n\n    return vec4((projectionMatrix * vec3(position, 1.0)).xy, 0.0, 1.0);\n}\n\nvoid texcoords(vec2 fragCoord, vec2 inverseVP,\n               out vec2 v_rgbNW, out vec2 v_rgbNE,\n               out vec2 v_rgbSW, out vec2 v_rgbSE,\n               out vec2 v_rgbM) {\n    v_rgbNW = (fragCoord + vec2(-1.0, -1.0)) * inverseVP;\n    v_rgbNE = (fragCoord + vec2(1.0, -1.0)) * inverseVP;\n    v_rgbSW = (fragCoord + vec2(-1.0, 1.0)) * inverseVP;\n    v_rgbSE = (fragCoord + vec2(1.0, 1.0)) * inverseVP;\n    v_rgbM = vec2(fragCoord * inverseVP);\n}\n\nvoid main(void) {\n\n   gl_Position = filterVertexPosition();\n\n   vFragCoord = aVertexPosition * outputFrame.zw;\n\n   texcoords(vFragCoord, inputSize.zw, v_rgbNW, v_rgbNE, v_rgbSW, v_rgbSE, v_rgbM);\n}\n";
var fragment$1 = `varying vec2 v_rgbNW;
varying vec2 v_rgbNE;
varying vec2 v_rgbSW;
varying vec2 v_rgbSE;
varying vec2 v_rgbM;

varying vec2 vFragCoord;
uniform sampler2D uSampler;
uniform highp vec4 inputSize;


/**
 Basic FXAA implementation based on the code on geeks3d.com with the
 modification that the texture2DLod stuff was removed since it's
 unsupported by WebGL.

 --

 From:
 https://github.com/mitsuhiko/webgl-meincraft

 Copyright (c) 2011 by Armin Ronacher.

 Some rights reserved.

 Redistribution and use in source and binary forms, with or without
 modification, are permitted provided that the following conditions are
 met:

 * Redistributions of source code must retain the above copyright
 notice, this list of conditions and the following disclaimer.

 * Redistributions in binary form must reproduce the above
 copyright notice, this list of conditions and the following
 disclaimer in the documentation and/or other materials provided
 with the distribution.

 * The names of the contributors may not be used to endorse or
 promote products derived from this software without specific
 prior written permission.

 THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#ifndef FXAA_REDUCE_MIN
#define FXAA_REDUCE_MIN   (1.0/ 128.0)
#endif
#ifndef FXAA_REDUCE_MUL
#define FXAA_REDUCE_MUL   (1.0 / 8.0)
#endif
#ifndef FXAA_SPAN_MAX
#define FXAA_SPAN_MAX     8.0
#endif

//optimized version for mobile, where dependent
//texture reads can be a bottleneck
vec4 fxaa(sampler2D tex, vec2 fragCoord, vec2 inverseVP,
          vec2 v_rgbNW, vec2 v_rgbNE,
          vec2 v_rgbSW, vec2 v_rgbSE,
          vec2 v_rgbM) {
    vec4 color;
    vec3 rgbNW = texture2D(tex, v_rgbNW).xyz;
    vec3 rgbNE = texture2D(tex, v_rgbNE).xyz;
    vec3 rgbSW = texture2D(tex, v_rgbSW).xyz;
    vec3 rgbSE = texture2D(tex, v_rgbSE).xyz;
    vec4 texColor = texture2D(tex, v_rgbM);
    vec3 rgbM  = texColor.xyz;
    vec3 luma = vec3(0.299, 0.587, 0.114);
    float lumaNW = dot(rgbNW, luma);
    float lumaNE = dot(rgbNE, luma);
    float lumaSW = dot(rgbSW, luma);
    float lumaSE = dot(rgbSE, luma);
    float lumaM  = dot(rgbM,  luma);
    float lumaMin = min(lumaM, min(min(lumaNW, lumaNE), min(lumaSW, lumaSE)));
    float lumaMax = max(lumaM, max(max(lumaNW, lumaNE), max(lumaSW, lumaSE)));

    mediump vec2 dir;
    dir.x = -((lumaNW + lumaNE) - (lumaSW + lumaSE));
    dir.y =  ((lumaNW + lumaSW) - (lumaNE + lumaSE));

    float dirReduce = max((lumaNW + lumaNE + lumaSW + lumaSE) *
                          (0.25 * FXAA_REDUCE_MUL), FXAA_REDUCE_MIN);

    float rcpDirMin = 1.0 / (min(abs(dir.x), abs(dir.y)) + dirReduce);
    dir = min(vec2(FXAA_SPAN_MAX, FXAA_SPAN_MAX),
              max(vec2(-FXAA_SPAN_MAX, -FXAA_SPAN_MAX),
                  dir * rcpDirMin)) * inverseVP;

    vec3 rgbA = 0.5 * (
                       texture2D(tex, fragCoord * inverseVP + dir * (1.0 / 3.0 - 0.5)).xyz +
                       texture2D(tex, fragCoord * inverseVP + dir * (2.0 / 3.0 - 0.5)).xyz);
    vec3 rgbB = rgbA * 0.5 + 0.25 * (
                                     texture2D(tex, fragCoord * inverseVP + dir * -0.5).xyz +
                                     texture2D(tex, fragCoord * inverseVP + dir * 0.5).xyz);

    float lumaB = dot(rgbB, luma);
    if ((lumaB < lumaMin) || (lumaB > lumaMax))
        color = vec4(rgbA, texColor.a);
    else
        color = vec4(rgbB, texColor.a);
    return color;
}

void main() {

      vec4 color;

      color = fxaa(uSampler, vFragCoord, inputSize.zw, v_rgbNW, v_rgbNE, v_rgbSW, v_rgbSE, v_rgbM);

      gl_FragColor = color;
}
`;
(function(_super) {
  __extends$a(FXAAFilter, _super);
  function FXAAFilter() {
    return _super.call(this, vertex, fragment$1) || this;
  }
  return FXAAFilter;
})(Filter);
/*!
 * @pixi/filter-noise - v6.3.0
 * Compiled Wed, 23 Mar 2022 18:58:56 UTC
 *
 * @pixi/filter-noise is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
/*! *****************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */
var extendStatics$9 = function(d2, b2) {
  extendStatics$9 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {
    d3.__proto__ = b3;
  } || function(d3, b3) {
    for (var p2 in b3) {
      if (b3.hasOwnProperty(p2)) {
        d3[p2] = b3[p2];
      }
    }
  };
  return extendStatics$9(d2, b2);
};
function __extends$9(d2, b2) {
  extendStatics$9(d2, b2);
  function __() {
    this.constructor = d2;
  }
  d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
}
var fragment = "precision highp float;\n\nvarying vec2 vTextureCoord;\nvarying vec4 vColor;\n\nuniform float uNoise;\nuniform float uSeed;\nuniform sampler2D uSampler;\n\nfloat rand(vec2 co)\n{\n    return fract(sin(dot(co.xy, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nvoid main()\n{\n    vec4 color = texture2D(uSampler, vTextureCoord);\n    float randomValue = rand(gl_FragCoord.xy * uSeed);\n    float diff = (randomValue - 0.5) * uNoise;\n\n    // Un-premultiply alpha before applying the color matrix. See issue #3539.\n    if (color.a > 0.0) {\n        color.rgb /= color.a;\n    }\n\n    color.r += diff;\n    color.g += diff;\n    color.b += diff;\n\n    // Premultiply alpha again.\n    color.rgb *= color.a;\n\n    gl_FragColor = color;\n}\n";
(function(_super) {
  __extends$9(NoiseFilter, _super);
  function NoiseFilter(noise, seed2) {
    if (noise === void 0) {
      noise = 0.5;
    }
    if (seed2 === void 0) {
      seed2 = Math.random();
    }
    var _this = _super.call(this, defaultFilterVertex, fragment, {
      uNoise: 0,
      uSeed: 0
    }) || this;
    _this.noise = noise;
    _this.seed = seed2;
    return _this;
  }
  Object.defineProperty(NoiseFilter.prototype, "noise", {
    get: function() {
      return this.uniforms.uNoise;
    },
    set: function(value) {
      this.uniforms.uNoise = value;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(NoiseFilter.prototype, "seed", {
    get: function() {
      return this.uniforms.uSeed;
    },
    set: function(value) {
      this.uniforms.uSeed = value;
    },
    enumerable: false,
    configurable: true
  });
  return NoiseFilter;
})(Filter);
/*!
 * @pixi/mixin-cache-as-bitmap - v6.3.0
 * Compiled Wed, 23 Mar 2022 18:58:56 UTC
 *
 * @pixi/mixin-cache-as-bitmap is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
/*!
 * @pixi/constants - v6.3.0
 * Compiled Wed, 23 Mar 2022 18:58:56 UTC
 *
 * @pixi/constants is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
var ENV;
(function(ENV2) {
  ENV2[ENV2["WEBGL_LEGACY"] = 0] = "WEBGL_LEGACY";
  ENV2[ENV2["WEBGL"] = 1] = "WEBGL";
  ENV2[ENV2["WEBGL2"] = 2] = "WEBGL2";
})(ENV || (ENV = {}));
var RENDERER_TYPE;
(function(RENDERER_TYPE2) {
  RENDERER_TYPE2[RENDERER_TYPE2["UNKNOWN"] = 0] = "UNKNOWN";
  RENDERER_TYPE2[RENDERER_TYPE2["WEBGL"] = 1] = "WEBGL";
  RENDERER_TYPE2[RENDERER_TYPE2["CANVAS"] = 2] = "CANVAS";
})(RENDERER_TYPE || (RENDERER_TYPE = {}));
var BUFFER_BITS;
(function(BUFFER_BITS2) {
  BUFFER_BITS2[BUFFER_BITS2["COLOR"] = 16384] = "COLOR";
  BUFFER_BITS2[BUFFER_BITS2["DEPTH"] = 256] = "DEPTH";
  BUFFER_BITS2[BUFFER_BITS2["STENCIL"] = 1024] = "STENCIL";
})(BUFFER_BITS || (BUFFER_BITS = {}));
var BLEND_MODES;
(function(BLEND_MODES2) {
  BLEND_MODES2[BLEND_MODES2["NORMAL"] = 0] = "NORMAL";
  BLEND_MODES2[BLEND_MODES2["ADD"] = 1] = "ADD";
  BLEND_MODES2[BLEND_MODES2["MULTIPLY"] = 2] = "MULTIPLY";
  BLEND_MODES2[BLEND_MODES2["SCREEN"] = 3] = "SCREEN";
  BLEND_MODES2[BLEND_MODES2["OVERLAY"] = 4] = "OVERLAY";
  BLEND_MODES2[BLEND_MODES2["DARKEN"] = 5] = "DARKEN";
  BLEND_MODES2[BLEND_MODES2["LIGHTEN"] = 6] = "LIGHTEN";
  BLEND_MODES2[BLEND_MODES2["COLOR_DODGE"] = 7] = "COLOR_DODGE";
  BLEND_MODES2[BLEND_MODES2["COLOR_BURN"] = 8] = "COLOR_BURN";
  BLEND_MODES2[BLEND_MODES2["HARD_LIGHT"] = 9] = "HARD_LIGHT";
  BLEND_MODES2[BLEND_MODES2["SOFT_LIGHT"] = 10] = "SOFT_LIGHT";
  BLEND_MODES2[BLEND_MODES2["DIFFERENCE"] = 11] = "DIFFERENCE";
  BLEND_MODES2[BLEND_MODES2["EXCLUSION"] = 12] = "EXCLUSION";
  BLEND_MODES2[BLEND_MODES2["HUE"] = 13] = "HUE";
  BLEND_MODES2[BLEND_MODES2["SATURATION"] = 14] = "SATURATION";
  BLEND_MODES2[BLEND_MODES2["COLOR"] = 15] = "COLOR";
  BLEND_MODES2[BLEND_MODES2["LUMINOSITY"] = 16] = "LUMINOSITY";
  BLEND_MODES2[BLEND_MODES2["NORMAL_NPM"] = 17] = "NORMAL_NPM";
  BLEND_MODES2[BLEND_MODES2["ADD_NPM"] = 18] = "ADD_NPM";
  BLEND_MODES2[BLEND_MODES2["SCREEN_NPM"] = 19] = "SCREEN_NPM";
  BLEND_MODES2[BLEND_MODES2["NONE"] = 20] = "NONE";
  BLEND_MODES2[BLEND_MODES2["SRC_OVER"] = 0] = "SRC_OVER";
  BLEND_MODES2[BLEND_MODES2["SRC_IN"] = 21] = "SRC_IN";
  BLEND_MODES2[BLEND_MODES2["SRC_OUT"] = 22] = "SRC_OUT";
  BLEND_MODES2[BLEND_MODES2["SRC_ATOP"] = 23] = "SRC_ATOP";
  BLEND_MODES2[BLEND_MODES2["DST_OVER"] = 24] = "DST_OVER";
  BLEND_MODES2[BLEND_MODES2["DST_IN"] = 25] = "DST_IN";
  BLEND_MODES2[BLEND_MODES2["DST_OUT"] = 26] = "DST_OUT";
  BLEND_MODES2[BLEND_MODES2["DST_ATOP"] = 27] = "DST_ATOP";
  BLEND_MODES2[BLEND_MODES2["ERASE"] = 26] = "ERASE";
  BLEND_MODES2[BLEND_MODES2["SUBTRACT"] = 28] = "SUBTRACT";
  BLEND_MODES2[BLEND_MODES2["XOR"] = 29] = "XOR";
})(BLEND_MODES || (BLEND_MODES = {}));
var DRAW_MODES;
(function(DRAW_MODES2) {
  DRAW_MODES2[DRAW_MODES2["POINTS"] = 0] = "POINTS";
  DRAW_MODES2[DRAW_MODES2["LINES"] = 1] = "LINES";
  DRAW_MODES2[DRAW_MODES2["LINE_LOOP"] = 2] = "LINE_LOOP";
  DRAW_MODES2[DRAW_MODES2["LINE_STRIP"] = 3] = "LINE_STRIP";
  DRAW_MODES2[DRAW_MODES2["TRIANGLES"] = 4] = "TRIANGLES";
  DRAW_MODES2[DRAW_MODES2["TRIANGLE_STRIP"] = 5] = "TRIANGLE_STRIP";
  DRAW_MODES2[DRAW_MODES2["TRIANGLE_FAN"] = 6] = "TRIANGLE_FAN";
})(DRAW_MODES || (DRAW_MODES = {}));
var FORMATS;
(function(FORMATS2) {
  FORMATS2[FORMATS2["RGBA"] = 6408] = "RGBA";
  FORMATS2[FORMATS2["RGB"] = 6407] = "RGB";
  FORMATS2[FORMATS2["RG"] = 33319] = "RG";
  FORMATS2[FORMATS2["RED"] = 6403] = "RED";
  FORMATS2[FORMATS2["RGBA_INTEGER"] = 36249] = "RGBA_INTEGER";
  FORMATS2[FORMATS2["RGB_INTEGER"] = 36248] = "RGB_INTEGER";
  FORMATS2[FORMATS2["RG_INTEGER"] = 33320] = "RG_INTEGER";
  FORMATS2[FORMATS2["RED_INTEGER"] = 36244] = "RED_INTEGER";
  FORMATS2[FORMATS2["ALPHA"] = 6406] = "ALPHA";
  FORMATS2[FORMATS2["LUMINANCE"] = 6409] = "LUMINANCE";
  FORMATS2[FORMATS2["LUMINANCE_ALPHA"] = 6410] = "LUMINANCE_ALPHA";
  FORMATS2[FORMATS2["DEPTH_COMPONENT"] = 6402] = "DEPTH_COMPONENT";
  FORMATS2[FORMATS2["DEPTH_STENCIL"] = 34041] = "DEPTH_STENCIL";
})(FORMATS || (FORMATS = {}));
var TARGETS;
(function(TARGETS2) {
  TARGETS2[TARGETS2["TEXTURE_2D"] = 3553] = "TEXTURE_2D";
  TARGETS2[TARGETS2["TEXTURE_CUBE_MAP"] = 34067] = "TEXTURE_CUBE_MAP";
  TARGETS2[TARGETS2["TEXTURE_2D_ARRAY"] = 35866] = "TEXTURE_2D_ARRAY";
  TARGETS2[TARGETS2["TEXTURE_CUBE_MAP_POSITIVE_X"] = 34069] = "TEXTURE_CUBE_MAP_POSITIVE_X";
  TARGETS2[TARGETS2["TEXTURE_CUBE_MAP_NEGATIVE_X"] = 34070] = "TEXTURE_CUBE_MAP_NEGATIVE_X";
  TARGETS2[TARGETS2["TEXTURE_CUBE_MAP_POSITIVE_Y"] = 34071] = "TEXTURE_CUBE_MAP_POSITIVE_Y";
  TARGETS2[TARGETS2["TEXTURE_CUBE_MAP_NEGATIVE_Y"] = 34072] = "TEXTURE_CUBE_MAP_NEGATIVE_Y";
  TARGETS2[TARGETS2["TEXTURE_CUBE_MAP_POSITIVE_Z"] = 34073] = "TEXTURE_CUBE_MAP_POSITIVE_Z";
  TARGETS2[TARGETS2["TEXTURE_CUBE_MAP_NEGATIVE_Z"] = 34074] = "TEXTURE_CUBE_MAP_NEGATIVE_Z";
})(TARGETS || (TARGETS = {}));
var TYPES;
(function(TYPES2) {
  TYPES2[TYPES2["UNSIGNED_BYTE"] = 5121] = "UNSIGNED_BYTE";
  TYPES2[TYPES2["UNSIGNED_SHORT"] = 5123] = "UNSIGNED_SHORT";
  TYPES2[TYPES2["UNSIGNED_SHORT_5_6_5"] = 33635] = "UNSIGNED_SHORT_5_6_5";
  TYPES2[TYPES2["UNSIGNED_SHORT_4_4_4_4"] = 32819] = "UNSIGNED_SHORT_4_4_4_4";
  TYPES2[TYPES2["UNSIGNED_SHORT_5_5_5_1"] = 32820] = "UNSIGNED_SHORT_5_5_5_1";
  TYPES2[TYPES2["UNSIGNED_INT"] = 5125] = "UNSIGNED_INT";
  TYPES2[TYPES2["UNSIGNED_INT_10F_11F_11F_REV"] = 35899] = "UNSIGNED_INT_10F_11F_11F_REV";
  TYPES2[TYPES2["UNSIGNED_INT_2_10_10_10_REV"] = 33640] = "UNSIGNED_INT_2_10_10_10_REV";
  TYPES2[TYPES2["UNSIGNED_INT_24_8"] = 34042] = "UNSIGNED_INT_24_8";
  TYPES2[TYPES2["UNSIGNED_INT_5_9_9_9_REV"] = 35902] = "UNSIGNED_INT_5_9_9_9_REV";
  TYPES2[TYPES2["BYTE"] = 5120] = "BYTE";
  TYPES2[TYPES2["SHORT"] = 5122] = "SHORT";
  TYPES2[TYPES2["INT"] = 5124] = "INT";
  TYPES2[TYPES2["FLOAT"] = 5126] = "FLOAT";
  TYPES2[TYPES2["FLOAT_32_UNSIGNED_INT_24_8_REV"] = 36269] = "FLOAT_32_UNSIGNED_INT_24_8_REV";
  TYPES2[TYPES2["HALF_FLOAT"] = 36193] = "HALF_FLOAT";
})(TYPES || (TYPES = {}));
var SAMPLER_TYPES;
(function(SAMPLER_TYPES2) {
  SAMPLER_TYPES2[SAMPLER_TYPES2["FLOAT"] = 0] = "FLOAT";
  SAMPLER_TYPES2[SAMPLER_TYPES2["INT"] = 1] = "INT";
  SAMPLER_TYPES2[SAMPLER_TYPES2["UINT"] = 2] = "UINT";
})(SAMPLER_TYPES || (SAMPLER_TYPES = {}));
var SCALE_MODES;
(function(SCALE_MODES2) {
  SCALE_MODES2[SCALE_MODES2["NEAREST"] = 0] = "NEAREST";
  SCALE_MODES2[SCALE_MODES2["LINEAR"] = 1] = "LINEAR";
})(SCALE_MODES || (SCALE_MODES = {}));
var WRAP_MODES;
(function(WRAP_MODES2) {
  WRAP_MODES2[WRAP_MODES2["CLAMP"] = 33071] = "CLAMP";
  WRAP_MODES2[WRAP_MODES2["REPEAT"] = 10497] = "REPEAT";
  WRAP_MODES2[WRAP_MODES2["MIRRORED_REPEAT"] = 33648] = "MIRRORED_REPEAT";
})(WRAP_MODES || (WRAP_MODES = {}));
var MIPMAP_MODES;
(function(MIPMAP_MODES2) {
  MIPMAP_MODES2[MIPMAP_MODES2["OFF"] = 0] = "OFF";
  MIPMAP_MODES2[MIPMAP_MODES2["POW2"] = 1] = "POW2";
  MIPMAP_MODES2[MIPMAP_MODES2["ON"] = 2] = "ON";
  MIPMAP_MODES2[MIPMAP_MODES2["ON_MANUAL"] = 3] = "ON_MANUAL";
})(MIPMAP_MODES || (MIPMAP_MODES = {}));
var ALPHA_MODES;
(function(ALPHA_MODES2) {
  ALPHA_MODES2[ALPHA_MODES2["NPM"] = 0] = "NPM";
  ALPHA_MODES2[ALPHA_MODES2["UNPACK"] = 1] = "UNPACK";
  ALPHA_MODES2[ALPHA_MODES2["PMA"] = 2] = "PMA";
  ALPHA_MODES2[ALPHA_MODES2["NO_PREMULTIPLIED_ALPHA"] = 0] = "NO_PREMULTIPLIED_ALPHA";
  ALPHA_MODES2[ALPHA_MODES2["PREMULTIPLY_ON_UPLOAD"] = 1] = "PREMULTIPLY_ON_UPLOAD";
  ALPHA_MODES2[ALPHA_MODES2["PREMULTIPLY_ALPHA"] = 2] = "PREMULTIPLY_ALPHA";
  ALPHA_MODES2[ALPHA_MODES2["PREMULTIPLIED_ALPHA"] = 2] = "PREMULTIPLIED_ALPHA";
})(ALPHA_MODES || (ALPHA_MODES = {}));
var CLEAR_MODES;
(function(CLEAR_MODES2) {
  CLEAR_MODES2[CLEAR_MODES2["NO"] = 0] = "NO";
  CLEAR_MODES2[CLEAR_MODES2["YES"] = 1] = "YES";
  CLEAR_MODES2[CLEAR_MODES2["AUTO"] = 2] = "AUTO";
  CLEAR_MODES2[CLEAR_MODES2["BLEND"] = 0] = "BLEND";
  CLEAR_MODES2[CLEAR_MODES2["CLEAR"] = 1] = "CLEAR";
  CLEAR_MODES2[CLEAR_MODES2["BLIT"] = 2] = "BLIT";
})(CLEAR_MODES || (CLEAR_MODES = {}));
var GC_MODES;
(function(GC_MODES2) {
  GC_MODES2[GC_MODES2["AUTO"] = 0] = "AUTO";
  GC_MODES2[GC_MODES2["MANUAL"] = 1] = "MANUAL";
})(GC_MODES || (GC_MODES = {}));
var PRECISION;
(function(PRECISION2) {
  PRECISION2["LOW"] = "lowp";
  PRECISION2["MEDIUM"] = "mediump";
  PRECISION2["HIGH"] = "highp";
})(PRECISION || (PRECISION = {}));
var MASK_TYPES;
(function(MASK_TYPES2) {
  MASK_TYPES2[MASK_TYPES2["NONE"] = 0] = "NONE";
  MASK_TYPES2[MASK_TYPES2["SCISSOR"] = 1] = "SCISSOR";
  MASK_TYPES2[MASK_TYPES2["STENCIL"] = 2] = "STENCIL";
  MASK_TYPES2[MASK_TYPES2["SPRITE"] = 3] = "SPRITE";
})(MASK_TYPES || (MASK_TYPES = {}));
var MSAA_QUALITY;
(function(MSAA_QUALITY2) {
  MSAA_QUALITY2[MSAA_QUALITY2["NONE"] = 0] = "NONE";
  MSAA_QUALITY2[MSAA_QUALITY2["LOW"] = 2] = "LOW";
  MSAA_QUALITY2[MSAA_QUALITY2["MEDIUM"] = 4] = "MEDIUM";
  MSAA_QUALITY2[MSAA_QUALITY2["HIGH"] = 8] = "HIGH";
})(MSAA_QUALITY || (MSAA_QUALITY = {}));
var BUFFER_TYPE;
(function(BUFFER_TYPE2) {
  BUFFER_TYPE2[BUFFER_TYPE2["ELEMENT_ARRAY_BUFFER"] = 34963] = "ELEMENT_ARRAY_BUFFER";
  BUFFER_TYPE2[BUFFER_TYPE2["ARRAY_BUFFER"] = 34962] = "ARRAY_BUFFER";
  BUFFER_TYPE2[BUFFER_TYPE2["UNIFORM_BUFFER"] = 35345] = "UNIFORM_BUFFER";
})(BUFFER_TYPE || (BUFFER_TYPE = {}));
var _tempMatrix = new Matrix();
DisplayObject.prototype._cacheAsBitmap = false;
DisplayObject.prototype._cacheData = null;
DisplayObject.prototype._cacheAsBitmapResolution = null;
DisplayObject.prototype._cacheAsBitmapMultisample = MSAA_QUALITY.NONE;
var CacheData = function() {
  function CacheData2() {
    this.textureCacheId = null;
    this.originalRender = null;
    this.originalRenderCanvas = null;
    this.originalCalculateBounds = null;
    this.originalGetLocalBounds = null;
    this.originalUpdateTransform = null;
    this.originalDestroy = null;
    this.originalMask = null;
    this.originalFilterArea = null;
    this.originalContainsPoint = null;
    this.sprite = null;
  }
  return CacheData2;
}();
Object.defineProperties(DisplayObject.prototype, {
  cacheAsBitmapResolution: {
    get: function() {
      return this._cacheAsBitmapResolution;
    },
    set: function(resolution) {
      if (resolution === this._cacheAsBitmapResolution) {
        return;
      }
      this._cacheAsBitmapResolution = resolution;
      if (this.cacheAsBitmap) {
        this.cacheAsBitmap = false;
        this.cacheAsBitmap = true;
      }
    }
  },
  cacheAsBitmapMultisample: {
    get: function() {
      return this._cacheAsBitmapMultisample;
    },
    set: function(multisample) {
      if (multisample === this._cacheAsBitmapMultisample) {
        return;
      }
      this._cacheAsBitmapMultisample = multisample;
      if (this.cacheAsBitmap) {
        this.cacheAsBitmap = false;
        this.cacheAsBitmap = true;
      }
    }
  },
  cacheAsBitmap: {
    get: function() {
      return this._cacheAsBitmap;
    },
    set: function(value) {
      if (this._cacheAsBitmap === value) {
        return;
      }
      this._cacheAsBitmap = value;
      var data;
      if (value) {
        if (!this._cacheData) {
          this._cacheData = new CacheData();
        }
        data = this._cacheData;
        data.originalRender = this.render;
        data.originalRenderCanvas = this.renderCanvas;
        data.originalUpdateTransform = this.updateTransform;
        data.originalCalculateBounds = this.calculateBounds;
        data.originalGetLocalBounds = this.getLocalBounds;
        data.originalDestroy = this.destroy;
        data.originalContainsPoint = this.containsPoint;
        data.originalMask = this._mask;
        data.originalFilterArea = this.filterArea;
        this.render = this._renderCached;
        this.renderCanvas = this._renderCachedCanvas;
        this.destroy = this._cacheAsBitmapDestroy;
      } else {
        data = this._cacheData;
        if (data.sprite) {
          this._destroyCachedDisplayObject();
        }
        this.render = data.originalRender;
        this.renderCanvas = data.originalRenderCanvas;
        this.calculateBounds = data.originalCalculateBounds;
        this.getLocalBounds = data.originalGetLocalBounds;
        this.destroy = data.originalDestroy;
        this.updateTransform = data.originalUpdateTransform;
        this.containsPoint = data.originalContainsPoint;
        this._mask = data.originalMask;
        this.filterArea = data.originalFilterArea;
      }
    }
  }
});
DisplayObject.prototype._renderCached = function _renderCached(renderer) {
  if (!this.visible || this.worldAlpha <= 0 || !this.renderable) {
    return;
  }
  this._initCachedDisplayObject(renderer);
  this._cacheData.sprite.transform._worldID = this.transform._worldID;
  this._cacheData.sprite.worldAlpha = this.worldAlpha;
  this._cacheData.sprite._render(renderer);
};
DisplayObject.prototype._initCachedDisplayObject = function _initCachedDisplayObject(renderer) {
  var _a3;
  if (this._cacheData && this._cacheData.sprite) {
    return;
  }
  var cacheAlpha = this.alpha;
  this.alpha = 1;
  renderer.batch.flush();
  var bounds = this.getLocalBounds(null, true).clone();
  if (this.filters && this.filters.length) {
    var padding = this.filters[0].padding;
    bounds.pad(padding);
  }
  bounds.ceil(settings.RESOLUTION);
  var cachedRenderTexture = renderer.renderTexture.current;
  var cachedSourceFrame = renderer.renderTexture.sourceFrame.clone();
  var cachedDestinationFrame = renderer.renderTexture.destinationFrame.clone();
  var cachedProjectionTransform = renderer.projection.transform;
  var renderTexture = RenderTexture.create({
    width: bounds.width,
    height: bounds.height,
    resolution: this.cacheAsBitmapResolution || renderer.resolution,
    multisample: (_a3 = this.cacheAsBitmapMultisample) !== null && _a3 !== void 0 ? _a3 : renderer.multisample
  });
  var textureCacheId = "cacheAsBitmap_" + uid();
  this._cacheData.textureCacheId = textureCacheId;
  BaseTexture.addToCache(renderTexture.baseTexture, textureCacheId);
  Texture.addToCache(renderTexture, textureCacheId);
  var m2 = this.transform.localTransform.copyTo(_tempMatrix).invert().translate(-bounds.x, -bounds.y);
  this.render = this._cacheData.originalRender;
  renderer.render(this, { renderTexture, clear: true, transform: m2, skipUpdateTransform: false });
  renderer.framebuffer.blit();
  renderer.projection.transform = cachedProjectionTransform;
  renderer.renderTexture.bind(cachedRenderTexture, cachedSourceFrame, cachedDestinationFrame);
  this.render = this._renderCached;
  this.updateTransform = this.displayObjectUpdateTransform;
  this.calculateBounds = this._calculateCachedBounds;
  this.getLocalBounds = this._getCachedLocalBounds;
  this._mask = null;
  this.filterArea = null;
  this.alpha = cacheAlpha;
  var cachedSprite = new Sprite(renderTexture);
  cachedSprite.transform.worldTransform = this.transform.worldTransform;
  cachedSprite.anchor.x = -(bounds.x / bounds.width);
  cachedSprite.anchor.y = -(bounds.y / bounds.height);
  cachedSprite.alpha = cacheAlpha;
  cachedSprite._bounds = this._bounds;
  this._cacheData.sprite = cachedSprite;
  this.transform._parentID = -1;
  if (!this.parent) {
    this.enableTempParent();
    this.updateTransform();
    this.disableTempParent(null);
  } else {
    this.updateTransform();
  }
  this.containsPoint = cachedSprite.containsPoint.bind(cachedSprite);
};
DisplayObject.prototype._renderCachedCanvas = function _renderCachedCanvas(renderer) {
  if (!this.visible || this.worldAlpha <= 0 || !this.renderable) {
    return;
  }
  this._initCachedDisplayObjectCanvas(renderer);
  this._cacheData.sprite.worldAlpha = this.worldAlpha;
  this._cacheData.sprite._renderCanvas(renderer);
};
DisplayObject.prototype._initCachedDisplayObjectCanvas = function _initCachedDisplayObjectCanvas(renderer) {
  if (this._cacheData && this._cacheData.sprite) {
    return;
  }
  var bounds = this.getLocalBounds(null, true);
  var cacheAlpha = this.alpha;
  this.alpha = 1;
  var cachedRenderTarget = renderer.context;
  var cachedProjectionTransform = renderer._projTransform;
  bounds.ceil(settings.RESOLUTION);
  var renderTexture = RenderTexture.create({ width: bounds.width, height: bounds.height });
  var textureCacheId = "cacheAsBitmap_" + uid();
  this._cacheData.textureCacheId = textureCacheId;
  BaseTexture.addToCache(renderTexture.baseTexture, textureCacheId);
  Texture.addToCache(renderTexture, textureCacheId);
  var m2 = _tempMatrix;
  this.transform.localTransform.copyTo(m2);
  m2.invert();
  m2.tx -= bounds.x;
  m2.ty -= bounds.y;
  this.renderCanvas = this._cacheData.originalRenderCanvas;
  renderer.render(this, { renderTexture, clear: true, transform: m2, skipUpdateTransform: false });
  renderer.context = cachedRenderTarget;
  renderer._projTransform = cachedProjectionTransform;
  this.renderCanvas = this._renderCachedCanvas;
  this.updateTransform = this.displayObjectUpdateTransform;
  this.calculateBounds = this._calculateCachedBounds;
  this.getLocalBounds = this._getCachedLocalBounds;
  this._mask = null;
  this.filterArea = null;
  this.alpha = cacheAlpha;
  var cachedSprite = new Sprite(renderTexture);
  cachedSprite.transform.worldTransform = this.transform.worldTransform;
  cachedSprite.anchor.x = -(bounds.x / bounds.width);
  cachedSprite.anchor.y = -(bounds.y / bounds.height);
  cachedSprite.alpha = cacheAlpha;
  cachedSprite._bounds = this._bounds;
  this._cacheData.sprite = cachedSprite;
  this.transform._parentID = -1;
  if (!this.parent) {
    this.parent = renderer._tempDisplayObjectParent;
    this.updateTransform();
    this.parent = null;
  } else {
    this.updateTransform();
  }
  this.containsPoint = cachedSprite.containsPoint.bind(cachedSprite);
};
DisplayObject.prototype._calculateCachedBounds = function _calculateCachedBounds() {
  this._bounds.clear();
  this._cacheData.sprite.transform._worldID = this.transform._worldID;
  this._cacheData.sprite._calculateBounds();
  this._bounds.updateID = this._boundsID;
};
DisplayObject.prototype._getCachedLocalBounds = function _getCachedLocalBounds() {
  return this._cacheData.sprite.getLocalBounds(null);
};
DisplayObject.prototype._destroyCachedDisplayObject = function _destroyCachedDisplayObject() {
  this._cacheData.sprite._texture.destroy(true);
  this._cacheData.sprite = null;
  BaseTexture.removeFromCache(this._cacheData.textureCacheId);
  Texture.removeFromCache(this._cacheData.textureCacheId);
  this._cacheData.textureCacheId = null;
};
DisplayObject.prototype._cacheAsBitmapDestroy = function _cacheAsBitmapDestroy(options) {
  this.cacheAsBitmap = false;
  this.destroy(options);
};
/*!
 * @pixi/mixin-get-child-by-name - v6.3.0
 * Compiled Wed, 23 Mar 2022 18:58:56 UTC
 *
 * @pixi/mixin-get-child-by-name is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
DisplayObject.prototype.name = null;
Container.prototype.getChildByName = function getChildByName(name2, deep) {
  for (var i2 = 0, j2 = this.children.length; i2 < j2; i2++) {
    if (this.children[i2].name === name2) {
      return this.children[i2];
    }
  }
  if (deep) {
    for (var i2 = 0, j2 = this.children.length; i2 < j2; i2++) {
      var child = this.children[i2];
      if (!child.getChildByName) {
        continue;
      }
      var target = this.children[i2].getChildByName(name2, true);
      if (target) {
        return target;
      }
    }
  }
  return null;
};
/*!
 * @pixi/mixin-get-global-position - v6.3.0
 * Compiled Wed, 23 Mar 2022 18:58:56 UTC
 *
 * @pixi/mixin-get-global-position is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
DisplayObject.prototype.getGlobalPosition = function getGlobalPosition(point, skipUpdate) {
  if (point === void 0) {
    point = new Point();
  }
  if (skipUpdate === void 0) {
    skipUpdate = false;
  }
  if (this.parent) {
    this.parent.toGlobal(this.position, point, skipUpdate);
  } else {
    point.x = this.position.x;
    point.y = this.position.y;
  }
  return point;
};
/*!
 * @pixi/mesh-extras - v6.3.0
 * Compiled Wed, 23 Mar 2022 18:58:56 UTC
 *
 * @pixi/mesh-extras is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
/*! *****************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */
var extendStatics$8 = function(d2, b2) {
  extendStatics$8 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {
    d3.__proto__ = b3;
  } || function(d3, b3) {
    for (var p2 in b3) {
      if (b3.hasOwnProperty(p2)) {
        d3[p2] = b3[p2];
      }
    }
  };
  return extendStatics$8(d2, b2);
};
function __extends$8(d2, b2) {
  extendStatics$8(d2, b2);
  function __() {
    this.constructor = d2;
  }
  d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
}
var PlaneGeometry = function(_super) {
  __extends$8(PlaneGeometry2, _super);
  function PlaneGeometry2(width, height, segWidth, segHeight) {
    if (width === void 0) {
      width = 100;
    }
    if (height === void 0) {
      height = 100;
    }
    if (segWidth === void 0) {
      segWidth = 10;
    }
    if (segHeight === void 0) {
      segHeight = 10;
    }
    var _this = _super.call(this) || this;
    _this.segWidth = segWidth;
    _this.segHeight = segHeight;
    _this.width = width;
    _this.height = height;
    _this.build();
    return _this;
  }
  PlaneGeometry2.prototype.build = function() {
    var total = this.segWidth * this.segHeight;
    var verts = [];
    var uvs = [];
    var indices2 = [];
    var segmentsX = this.segWidth - 1;
    var segmentsY = this.segHeight - 1;
    var sizeX = this.width / segmentsX;
    var sizeY = this.height / segmentsY;
    for (var i2 = 0; i2 < total; i2++) {
      var x2 = i2 % this.segWidth;
      var y2 = i2 / this.segWidth | 0;
      verts.push(x2 * sizeX, y2 * sizeY);
      uvs.push(x2 / segmentsX, y2 / segmentsY);
    }
    var totalSub = segmentsX * segmentsY;
    for (var i2 = 0; i2 < totalSub; i2++) {
      var xpos = i2 % segmentsX;
      var ypos = i2 / segmentsX | 0;
      var value = ypos * this.segWidth + xpos;
      var value2 = ypos * this.segWidth + xpos + 1;
      var value3 = (ypos + 1) * this.segWidth + xpos;
      var value4 = (ypos + 1) * this.segWidth + xpos + 1;
      indices2.push(value, value2, value3, value2, value4, value3);
    }
    this.buffers[0].data = new Float32Array(verts);
    this.buffers[1].data = new Float32Array(uvs);
    this.indexBuffer.data = new Uint16Array(indices2);
    this.buffers[0].update();
    this.buffers[1].update();
    this.indexBuffer.update();
  };
  return PlaneGeometry2;
}(MeshGeometry);
var RopeGeometry = function(_super) {
  __extends$8(RopeGeometry2, _super);
  function RopeGeometry2(width, points, textureScale) {
    if (width === void 0) {
      width = 200;
    }
    if (textureScale === void 0) {
      textureScale = 0;
    }
    var _this = _super.call(this, new Float32Array(points.length * 4), new Float32Array(points.length * 4), new Uint16Array((points.length - 1) * 6)) || this;
    _this.points = points;
    _this._width = width;
    _this.textureScale = textureScale;
    _this.build();
    return _this;
  }
  Object.defineProperty(RopeGeometry2.prototype, "width", {
    get: function() {
      return this._width;
    },
    enumerable: false,
    configurable: true
  });
  RopeGeometry2.prototype.build = function() {
    var points = this.points;
    if (!points) {
      return;
    }
    var vertexBuffer = this.getBuffer("aVertexPosition");
    var uvBuffer = this.getBuffer("aTextureCoord");
    var indexBuffer = this.getIndex();
    if (points.length < 1) {
      return;
    }
    if (vertexBuffer.data.length / 4 !== points.length) {
      vertexBuffer.data = new Float32Array(points.length * 4);
      uvBuffer.data = new Float32Array(points.length * 4);
      indexBuffer.data = new Uint16Array((points.length - 1) * 6);
    }
    var uvs = uvBuffer.data;
    var indices2 = indexBuffer.data;
    uvs[0] = 0;
    uvs[1] = 0;
    uvs[2] = 0;
    uvs[3] = 1;
    var amount = 0;
    var prev2 = points[0];
    var textureWidth = this._width * this.textureScale;
    var total = points.length;
    for (var i2 = 0; i2 < total; i2++) {
      var index = i2 * 4;
      if (this.textureScale > 0) {
        var dx = prev2.x - points[i2].x;
        var dy = prev2.y - points[i2].y;
        var distance = Math.sqrt(dx * dx + dy * dy);
        prev2 = points[i2];
        amount += distance / textureWidth;
      } else {
        amount = i2 / (total - 1);
      }
      uvs[index] = amount;
      uvs[index + 1] = 0;
      uvs[index + 2] = amount;
      uvs[index + 3] = 1;
    }
    var indexCount = 0;
    for (var i2 = 0; i2 < total - 1; i2++) {
      var index = i2 * 2;
      indices2[indexCount++] = index;
      indices2[indexCount++] = index + 1;
      indices2[indexCount++] = index + 2;
      indices2[indexCount++] = index + 2;
      indices2[indexCount++] = index + 1;
      indices2[indexCount++] = index + 3;
    }
    uvBuffer.update();
    indexBuffer.update();
    this.updateVertices();
  };
  RopeGeometry2.prototype.updateVertices = function() {
    var points = this.points;
    if (points.length < 1) {
      return;
    }
    var lastPoint = points[0];
    var nextPoint;
    var perpX = 0;
    var perpY = 0;
    var vertices = this.buffers[0].data;
    var total = points.length;
    for (var i2 = 0; i2 < total; i2++) {
      var point = points[i2];
      var index = i2 * 4;
      if (i2 < points.length - 1) {
        nextPoint = points[i2 + 1];
      } else {
        nextPoint = point;
      }
      perpY = -(nextPoint.x - lastPoint.x);
      perpX = nextPoint.y - lastPoint.y;
      var perpLength = Math.sqrt(perpX * perpX + perpY * perpY);
      var num = this.textureScale > 0 ? this.textureScale * this._width / 2 : this._width / 2;
      perpX /= perpLength;
      perpY /= perpLength;
      perpX *= num;
      perpY *= num;
      vertices[index] = point.x + perpX;
      vertices[index + 1] = point.y + perpY;
      vertices[index + 2] = point.x - perpX;
      vertices[index + 3] = point.y - perpY;
      lastPoint = point;
    }
    this.buffers[0].update();
  };
  RopeGeometry2.prototype.update = function() {
    if (this.textureScale > 0) {
      this.build();
    } else {
      this.updateVertices();
    }
  };
  return RopeGeometry2;
}(MeshGeometry);
(function(_super) {
  __extends$8(SimpleRope, _super);
  function SimpleRope(texture, points, textureScale) {
    if (textureScale === void 0) {
      textureScale = 0;
    }
    var _this = this;
    var ropeGeometry = new RopeGeometry(texture.height, points, textureScale);
    var meshMaterial = new MeshMaterial(texture);
    if (textureScale > 0) {
      texture.baseTexture.wrapMode = WRAP_MODES$3.REPEAT;
    }
    _this = _super.call(this, ropeGeometry, meshMaterial) || this;
    _this.autoUpdate = true;
    return _this;
  }
  SimpleRope.prototype._render = function(renderer) {
    var geometry = this.geometry;
    if (this.autoUpdate || geometry._width !== this.shader.texture.height) {
      geometry._width = this.shader.texture.height;
      geometry.update();
    }
    _super.prototype._render.call(this, renderer);
  };
  return SimpleRope;
})(Mesh);
var SimplePlane = function(_super) {
  __extends$8(SimplePlane2, _super);
  function SimplePlane2(texture, verticesX, verticesY) {
    var _this = this;
    var planeGeometry = new PlaneGeometry(texture.width, texture.height, verticesX, verticesY);
    var meshMaterial = new MeshMaterial(Texture.WHITE);
    _this = _super.call(this, planeGeometry, meshMaterial) || this;
    _this.texture = texture;
    _this.autoResize = true;
    return _this;
  }
  SimplePlane2.prototype.textureUpdated = function() {
    this._textureID = this.shader.texture._updateID;
    var geometry = this.geometry;
    var _a3 = this.shader.texture, width = _a3.width, height = _a3.height;
    if (this.autoResize && (geometry.width !== width || geometry.height !== height)) {
      geometry.width = this.shader.texture.width;
      geometry.height = this.shader.texture.height;
      geometry.build();
    }
  };
  Object.defineProperty(SimplePlane2.prototype, "texture", {
    get: function() {
      return this.shader.texture;
    },
    set: function(value) {
      if (this.shader.texture === value) {
        return;
      }
      this.shader.texture = value;
      this._textureID = -1;
      if (value.baseTexture.valid) {
        this.textureUpdated();
      } else {
        value.once("update", this.textureUpdated, this);
      }
    },
    enumerable: false,
    configurable: true
  });
  SimplePlane2.prototype._render = function(renderer) {
    if (this._textureID !== this.shader.texture._updateID) {
      this.textureUpdated();
    }
    _super.prototype._render.call(this, renderer);
  };
  SimplePlane2.prototype.destroy = function(options) {
    this.shader.texture.off("update", this.textureUpdated, this);
    _super.prototype.destroy.call(this, options);
  };
  return SimplePlane2;
}(Mesh);
(function(_super) {
  __extends$8(SimpleMesh, _super);
  function SimpleMesh(texture, vertices, uvs, indices2, drawMode) {
    if (texture === void 0) {
      texture = Texture.EMPTY;
    }
    var _this = this;
    var geometry = new MeshGeometry(vertices, uvs, indices2);
    geometry.getBuffer("aVertexPosition").static = false;
    var meshMaterial = new MeshMaterial(texture);
    _this = _super.call(this, geometry, meshMaterial, null, drawMode) || this;
    _this.autoUpdate = true;
    return _this;
  }
  Object.defineProperty(SimpleMesh.prototype, "vertices", {
    get: function() {
      return this.geometry.getBuffer("aVertexPosition").data;
    },
    set: function(value) {
      this.geometry.getBuffer("aVertexPosition").data = value;
    },
    enumerable: false,
    configurable: true
  });
  SimpleMesh.prototype._render = function(renderer) {
    if (this.autoUpdate) {
      this.geometry.getBuffer("aVertexPosition").update();
    }
    _super.prototype._render.call(this, renderer);
  };
  return SimpleMesh;
})(Mesh);
var DEFAULT_BORDER_SIZE = 10;
(function(_super) {
  __extends$8(NineSlicePlane, _super);
  function NineSlicePlane(texture, leftWidth, topHeight, rightWidth, bottomHeight) {
    if (leftWidth === void 0) {
      leftWidth = DEFAULT_BORDER_SIZE;
    }
    if (topHeight === void 0) {
      topHeight = DEFAULT_BORDER_SIZE;
    }
    if (rightWidth === void 0) {
      rightWidth = DEFAULT_BORDER_SIZE;
    }
    if (bottomHeight === void 0) {
      bottomHeight = DEFAULT_BORDER_SIZE;
    }
    var _this = _super.call(this, Texture.WHITE, 4, 4) || this;
    _this._origWidth = texture.orig.width;
    _this._origHeight = texture.orig.height;
    _this._width = _this._origWidth;
    _this._height = _this._origHeight;
    _this._leftWidth = leftWidth;
    _this._rightWidth = rightWidth;
    _this._topHeight = topHeight;
    _this._bottomHeight = bottomHeight;
    _this.texture = texture;
    return _this;
  }
  NineSlicePlane.prototype.textureUpdated = function() {
    this._textureID = this.shader.texture._updateID;
    this._refresh();
  };
  Object.defineProperty(NineSlicePlane.prototype, "vertices", {
    get: function() {
      return this.geometry.getBuffer("aVertexPosition").data;
    },
    set: function(value) {
      this.geometry.getBuffer("aVertexPosition").data = value;
    },
    enumerable: false,
    configurable: true
  });
  NineSlicePlane.prototype.updateHorizontalVertices = function() {
    var vertices = this.vertices;
    var scale = this._getMinScale();
    vertices[9] = vertices[11] = vertices[13] = vertices[15] = this._topHeight * scale;
    vertices[17] = vertices[19] = vertices[21] = vertices[23] = this._height - this._bottomHeight * scale;
    vertices[25] = vertices[27] = vertices[29] = vertices[31] = this._height;
  };
  NineSlicePlane.prototype.updateVerticalVertices = function() {
    var vertices = this.vertices;
    var scale = this._getMinScale();
    vertices[2] = vertices[10] = vertices[18] = vertices[26] = this._leftWidth * scale;
    vertices[4] = vertices[12] = vertices[20] = vertices[28] = this._width - this._rightWidth * scale;
    vertices[6] = vertices[14] = vertices[22] = vertices[30] = this._width;
  };
  NineSlicePlane.prototype._getMinScale = function() {
    var w2 = this._leftWidth + this._rightWidth;
    var scaleW = this._width > w2 ? 1 : this._width / w2;
    var h2 = this._topHeight + this._bottomHeight;
    var scaleH = this._height > h2 ? 1 : this._height / h2;
    var scale = Math.min(scaleW, scaleH);
    return scale;
  };
  Object.defineProperty(NineSlicePlane.prototype, "width", {
    get: function() {
      return this._width;
    },
    set: function(value) {
      this._width = value;
      this._refresh();
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(NineSlicePlane.prototype, "height", {
    get: function() {
      return this._height;
    },
    set: function(value) {
      this._height = value;
      this._refresh();
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(NineSlicePlane.prototype, "leftWidth", {
    get: function() {
      return this._leftWidth;
    },
    set: function(value) {
      this._leftWidth = value;
      this._refresh();
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(NineSlicePlane.prototype, "rightWidth", {
    get: function() {
      return this._rightWidth;
    },
    set: function(value) {
      this._rightWidth = value;
      this._refresh();
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(NineSlicePlane.prototype, "topHeight", {
    get: function() {
      return this._topHeight;
    },
    set: function(value) {
      this._topHeight = value;
      this._refresh();
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(NineSlicePlane.prototype, "bottomHeight", {
    get: function() {
      return this._bottomHeight;
    },
    set: function(value) {
      this._bottomHeight = value;
      this._refresh();
    },
    enumerable: false,
    configurable: true
  });
  NineSlicePlane.prototype._refresh = function() {
    var texture = this.texture;
    var uvs = this.geometry.buffers[1].data;
    this._origWidth = texture.orig.width;
    this._origHeight = texture.orig.height;
    var _uvw = 1 / this._origWidth;
    var _uvh = 1 / this._origHeight;
    uvs[0] = uvs[8] = uvs[16] = uvs[24] = 0;
    uvs[1] = uvs[3] = uvs[5] = uvs[7] = 0;
    uvs[6] = uvs[14] = uvs[22] = uvs[30] = 1;
    uvs[25] = uvs[27] = uvs[29] = uvs[31] = 1;
    uvs[2] = uvs[10] = uvs[18] = uvs[26] = _uvw * this._leftWidth;
    uvs[4] = uvs[12] = uvs[20] = uvs[28] = 1 - _uvw * this._rightWidth;
    uvs[9] = uvs[11] = uvs[13] = uvs[15] = _uvh * this._topHeight;
    uvs[17] = uvs[19] = uvs[21] = uvs[23] = 1 - _uvh * this._bottomHeight;
    this.updateHorizontalVertices();
    this.updateVerticalVertices();
    this.geometry.buffers[0].update();
    this.geometry.buffers[1].update();
  };
  return NineSlicePlane;
})(SimplePlane);
/*!
 * @pixi/sprite-animated - v6.3.0
 * Compiled Wed, 23 Mar 2022 18:58:56 UTC
 *
 * @pixi/sprite-animated is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
/*! *****************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */
var extendStatics$7 = function(d2, b2) {
  extendStatics$7 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {
    d3.__proto__ = b3;
  } || function(d3, b3) {
    for (var p2 in b3) {
      if (b3.hasOwnProperty(p2)) {
        d3[p2] = b3[p2];
      }
    }
  };
  return extendStatics$7(d2, b2);
};
function __extends$7(d2, b2) {
  extendStatics$7(d2, b2);
  function __() {
    this.constructor = d2;
  }
  d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
}
var AnimatedSprite = function(_super) {
  __extends$7(AnimatedSprite2, _super);
  function AnimatedSprite2(textures, autoUpdate) {
    if (autoUpdate === void 0) {
      autoUpdate = true;
    }
    var _this = _super.call(this, textures[0] instanceof Texture ? textures[0] : textures[0].texture) || this;
    _this._textures = null;
    _this._durations = null;
    _this._autoUpdate = autoUpdate;
    _this._isConnectedToTicker = false;
    _this.animationSpeed = 1;
    _this.loop = true;
    _this.updateAnchor = false;
    _this.onComplete = null;
    _this.onFrameChange = null;
    _this.onLoop = null;
    _this._currentTime = 0;
    _this._playing = false;
    _this._previousFrame = null;
    _this.textures = textures;
    return _this;
  }
  AnimatedSprite2.prototype.stop = function() {
    if (!this._playing) {
      return;
    }
    this._playing = false;
    if (this._autoUpdate && this._isConnectedToTicker) {
      Ticker.shared.remove(this.update, this);
      this._isConnectedToTicker = false;
    }
  };
  AnimatedSprite2.prototype.play = function() {
    if (this._playing) {
      return;
    }
    this._playing = true;
    if (this._autoUpdate && !this._isConnectedToTicker) {
      Ticker.shared.add(this.update, this, UPDATE_PRIORITY.HIGH);
      this._isConnectedToTicker = true;
    }
  };
  AnimatedSprite2.prototype.gotoAndStop = function(frameNumber) {
    this.stop();
    var previousFrame = this.currentFrame;
    this._currentTime = frameNumber;
    if (previousFrame !== this.currentFrame) {
      this.updateTexture();
    }
  };
  AnimatedSprite2.prototype.gotoAndPlay = function(frameNumber) {
    var previousFrame = this.currentFrame;
    this._currentTime = frameNumber;
    if (previousFrame !== this.currentFrame) {
      this.updateTexture();
    }
    this.play();
  };
  AnimatedSprite2.prototype.update = function(deltaTime) {
    if (!this._playing) {
      return;
    }
    var elapsed = this.animationSpeed * deltaTime;
    var previousFrame = this.currentFrame;
    if (this._durations !== null) {
      var lag = this._currentTime % 1 * this._durations[this.currentFrame];
      lag += elapsed / 60 * 1e3;
      while (lag < 0) {
        this._currentTime--;
        lag += this._durations[this.currentFrame];
      }
      var sign2 = Math.sign(this.animationSpeed * deltaTime);
      this._currentTime = Math.floor(this._currentTime);
      while (lag >= this._durations[this.currentFrame]) {
        lag -= this._durations[this.currentFrame] * sign2;
        this._currentTime += sign2;
      }
      this._currentTime += lag / this._durations[this.currentFrame];
    } else {
      this._currentTime += elapsed;
    }
    if (this._currentTime < 0 && !this.loop) {
      this.gotoAndStop(0);
      if (this.onComplete) {
        this.onComplete();
      }
    } else if (this._currentTime >= this._textures.length && !this.loop) {
      this.gotoAndStop(this._textures.length - 1);
      if (this.onComplete) {
        this.onComplete();
      }
    } else if (previousFrame !== this.currentFrame) {
      if (this.loop && this.onLoop) {
        if (this.animationSpeed > 0 && this.currentFrame < previousFrame) {
          this.onLoop();
        } else if (this.animationSpeed < 0 && this.currentFrame > previousFrame) {
          this.onLoop();
        }
      }
      this.updateTexture();
    }
  };
  AnimatedSprite2.prototype.updateTexture = function() {
    var currentFrame = this.currentFrame;
    if (this._previousFrame === currentFrame) {
      return;
    }
    this._previousFrame = currentFrame;
    this._texture = this._textures[currentFrame];
    this._textureID = -1;
    this._textureTrimmedID = -1;
    this._cachedTint = 16777215;
    this.uvs = this._texture._uvs.uvsFloat32;
    if (this.updateAnchor) {
      this._anchor.copyFrom(this._texture.defaultAnchor);
    }
    if (this.onFrameChange) {
      this.onFrameChange(this.currentFrame);
    }
  };
  AnimatedSprite2.prototype.destroy = function(options) {
    this.stop();
    _super.prototype.destroy.call(this, options);
    this.onComplete = null;
    this.onFrameChange = null;
    this.onLoop = null;
  };
  AnimatedSprite2.fromFrames = function(frames) {
    var textures = [];
    for (var i2 = 0; i2 < frames.length; ++i2) {
      textures.push(Texture.from(frames[i2]));
    }
    return new AnimatedSprite2(textures);
  };
  AnimatedSprite2.fromImages = function(images) {
    var textures = [];
    for (var i2 = 0; i2 < images.length; ++i2) {
      textures.push(Texture.from(images[i2]));
    }
    return new AnimatedSprite2(textures);
  };
  Object.defineProperty(AnimatedSprite2.prototype, "totalFrames", {
    get: function() {
      return this._textures.length;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(AnimatedSprite2.prototype, "textures", {
    get: function() {
      return this._textures;
    },
    set: function(value) {
      if (value[0] instanceof Texture) {
        this._textures = value;
        this._durations = null;
      } else {
        this._textures = [];
        this._durations = [];
        for (var i2 = 0; i2 < value.length; i2++) {
          this._textures.push(value[i2].texture);
          this._durations.push(value[i2].time);
        }
      }
      this._previousFrame = null;
      this.gotoAndStop(0);
      this.updateTexture();
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(AnimatedSprite2.prototype, "currentFrame", {
    get: function() {
      var currentFrame = Math.floor(this._currentTime) % this._textures.length;
      if (currentFrame < 0) {
        currentFrame += this._textures.length;
      }
      return currentFrame;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(AnimatedSprite2.prototype, "playing", {
    get: function() {
      return this._playing;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(AnimatedSprite2.prototype, "autoUpdate", {
    get: function() {
      return this._autoUpdate;
    },
    set: function(value) {
      if (value !== this._autoUpdate) {
        this._autoUpdate = value;
        if (!this._autoUpdate && this._isConnectedToTicker) {
          Ticker.shared.remove(this.update, this);
          this._isConnectedToTicker = false;
        } else if (this._autoUpdate && !this._isConnectedToTicker && this._playing) {
          Ticker.shared.add(this.update, this);
          this._isConnectedToTicker = true;
        }
      }
    },
    enumerable: false,
    configurable: true
  });
  return AnimatedSprite2;
}(Sprite);
/*!
 * pixi.js - v6.3.0
 * Compiled Wed, 23 Mar 2022 18:58:56 UTC
 *
 * pixi.js is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
Renderer.registerPlugin("accessibility", AccessibilityManager);
Renderer.registerPlugin("extract", Extract);
Renderer.registerPlugin("interaction", InteractionManager);
Renderer.registerPlugin("particle", ParticleRenderer);
Renderer.registerPlugin("prepare", Prepare);
Renderer.registerPlugin("batch", BatchRenderer);
Renderer.registerPlugin("tilingSprite", TilingSpriteRenderer);
Loader.registerPlugin(BitmapFontLoader);
Loader.registerPlugin(CompressedTextureLoader);
Loader.registerPlugin(DDSLoader);
Loader.registerPlugin(KTXLoader);
Loader.registerPlugin(SpritesheetLoader);
Application.registerPlugin(TickerPlugin);
Application.registerPlugin(AppLoaderPlugin);
const _SoundMng = class {
  constructor(cfg, hTag, val, main2, sys) {
    __privateAdd2(this, _volume);
    __privateAdd2(this, _getVol);
    __privateAdd2(this, _fadeoutbgm);
    __privateAdd2(this, _fadeoutse);
    __privateAdd2(this, _fadebgm);
    __privateAdd2(this, _fadese);
    __privateAdd2(this, _playbgm);
    __privateAdd2(this, _playse);
    __privateAdd2(this, _playseSub);
    __privateAdd2(this, _stop_allse);
    __privateAdd2(this, _stopbgm);
    __privateAdd2(this, _stopse);
    __privateAdd2(this, _wb);
    __privateAdd2(this, _wf);
    __privateAdd2(this, _stopfadese);
    __privateAdd2(this, _wl);
    __privateAdd2(this, _ws);
    __privateAdd2(this, _xchgbuf);
    __privateAdd2(this, _addLoopPlay);
    __privateAdd2(this, _delLoopPlay);
    __privateAdd2(this, _hSndBuf, {});
    __privateAdd2(this, _hLP, {});
    __privateAdd2(this, _evtMng2, void 0);
    __privateAdd2(this, _initVol, () => {
      I.volumeAll = Number(this.val.getVal("sys:sn.sound.global_volume", 1));
      __privateSet2(this, _initVol, () => {
      });
    });
    this.cfg = cfg;
    this.val = val;
    this.main = main2;
    this.sys = sys;
    hTag.volume = (o) => __privateMethod2(this, _volume, volume_fn).call(this, o);
    hTag.fadebgm = (o) => __privateMethod2(this, _fadebgm, fadebgm_fn).call(this, o);
    hTag.fadeoutbgm = (o) => __privateMethod2(this, _fadeoutbgm, fadeoutbgm_fn).call(this, o);
    hTag.fadeoutse = (o) => __privateMethod2(this, _fadeoutse, fadeoutse_fn).call(this, o);
    hTag.fadese = (o) => __privateMethod2(this, _fadese, fadese_fn).call(this, o);
    hTag.playbgm = (o) => __privateMethod2(this, _playbgm, playbgm_fn).call(this, o);
    hTag.playse = (o) => __privateMethod2(this, _playse, playse_fn).call(this, o);
    hTag.stop_allse = () => __privateMethod2(this, _stop_allse, stop_allse_fn).call(this);
    hTag.stopbgm = (o) => __privateMethod2(this, _stopbgm, stopbgm_fn).call(this, o);
    hTag.stopse = (o) => __privateMethod2(this, _stopse, stopse_fn).call(this, o);
    hTag.wb = (o) => __privateMethod2(this, _wb, wb_fn).call(this, o);
    hTag.wf = (o) => __privateMethod2(this, _wf, wf_fn).call(this, o);
    hTag.stopfadese = (o) => __privateMethod2(this, _stopfadese, stopfadese_fn).call(this, o);
    hTag.wl = (o) => __privateMethod2(this, _wl, wl_fn).call(this, o);
    hTag.ws = (o) => __privateMethod2(this, _ws, ws_fn).call(this, o);
    hTag.xchgbuf = (o) => __privateMethod2(this, _xchgbuf, xchgbuf_fn).call(this, o);
    this.val.setVal_Nochk("save", "const.sn.loopPlaying", "{}");
    val.setVal_Nochk("tmp", "const.sn.sound.codecs", JSON.stringify(G.supported));
  }
  setEvtMng(evtMng) {
    __privateSet2(this, _evtMng2, evtMng);
  }
  setNoticeChgVolume(setGlbVol, setMovVol) {
    this.val.defValTrg("sys:sn.sound.global_volume", (_name, val) => setGlbVol(I.volumeAll = Number(val)));
    this.val.defValTrg("sys:sn.sound.movie_volume", (_name, val) => setMovVol(Number(val)));
    this.val.setVal_Nochk("sys", "sn.sound.global_volume", this.val.getVal("sys:sn.sound.global_volume", 1));
    this.val.setVal_Nochk("sys", "sn.sound.movie_volume", this.val.getVal("sys:sn.sound.movie_volume", 1));
  }
  clearCache() {
    I.removeAll();
  }
  loadAheadSnd(hArg) {
    [hArg.clickse, hArg.enterse, hArg.leavese].forEach((fn) => {
      if (!fn || I.exists(fn))
        return;
      __privateMethod2(this, _playseSub, playseSub_fn).call(this, "", fn, { preload: true, autoPlay: false });
    });
  }
  playLoopFromSaveObj() {
    const lp = String(this.val.getVal("save:const.sn.loopPlaying", "{}"));
    this.val.flush();
    if (lp === "{}") {
      __privateMethod2(this, _stop_allse, stop_allse_fn).call(this);
      return;
    }
    const aFnc = [];
    __privateSet2(this, _hLP, JSON.parse(lp));
    for (const buf in __privateGet2(this, _hLP)) {
      const nm = "save:const.sn.sound." + buf + ".";
      const hArg = {
        fn: String(this.val.getVal(nm + "fn")),
        buf,
        join: false,
        loop: true,
        volume: Number(this.val.getVal(nm + "volume")),
        start_ms: Number(this.val.getVal(nm + "start_ms")),
        end_ms: Number(this.val.getVal(nm + "end_ms")),
        ret_ms: Number(this.val.getVal(nm + "ret_ms"))
      };
      aFnc.push(() => {
        if (hArg.buf === "BGM")
          __privateMethod2(this, _playbgm, playbgm_fn).call(this, hArg);
        else
          __privateMethod2(this, _playse, playse_fn).call(this, hArg);
      });
    }
    __privateMethod2(this, _stop_allse, stop_allse_fn).call(this);
    aFnc.forEach((f2) => f2());
  }
};
let SoundMng = _SoundMng;
_hSndBuf = new WeakMap();
_hLP = new WeakMap();
_evtMng2 = new WeakMap();
_volume = new WeakSet();
volume_fn = function(hArg) {
  const { buf = "SE" } = hArg;
  const bvn = "const.sn.sound." + buf + ".volume";
  const arg_vol = __privateMethod2(this, _getVol, getVol_fn).call(this, hArg, 1);
  if (Number(this.val.getVal("sys:" + bvn)) === arg_vol)
    return false;
  this.val.setVal_Nochk("sys", bvn, arg_vol);
  this.val.flush();
  hArg.time = 0;
  hArg.volume = Number(this.val.getVal("save:" + bvn));
  return __privateMethod2(this, _fadese, fadese_fn).call(this, hArg);
};
_getVol = new WeakSet();
getVol_fn = function(hArg, def) {
  const vol = argChk_Num(hArg, "volume", def);
  if (vol < 0)
    return 0;
  if (vol > 1)
    return 1;
  return vol;
};
_fadeoutbgm = new WeakSet();
fadeoutbgm_fn = function(hArg) {
  hArg.volume = 0;
  return __privateMethod2(this, _fadebgm, fadebgm_fn).call(this, hArg);
};
_fadeoutse = new WeakSet();
fadeoutse_fn = function(hArg) {
  hArg.volume = 0;
  return __privateMethod2(this, _fadese, fadese_fn).call(this, hArg);
};
_fadebgm = new WeakSet();
fadebgm_fn = function(hArg) {
  hArg.buf = "BGM";
  return __privateMethod2(this, _fadese, fadese_fn).call(this, hArg);
};
_fadese = new WeakSet();
fadese_fn = function(hArg) {
  __privateMethod2(this, _stopfadese, stopfadese_fn).call(this, hArg);
  const { buf = "SE" } = hArg;
  const oSb = __privateGet2(this, _hSndBuf)[buf];
  if (!(oSb == null ? void 0 : oSb.playing()) || !oSb.snd)
    return false;
  const bvn = "const.sn.sound." + buf + ".volume";
  const savevol = __privateMethod2(this, _getVol, getVol_fn).call(this, hArg, NaN);
  this.val.setVal_Nochk("save", bvn, savevol);
  const vol = savevol * Number(this.val.getVal("sys:" + bvn, 1));
  const stop = argChk_Boolean(hArg, "stop", savevol === 0);
  if (stop) {
    __privateMethod2(this, _delLoopPlay, delLoopPlay_fn).call(this, buf);
    this.val.setVal_Nochk("save", "const.sn.sound." + buf + ".fn", "");
  }
  this.val.flush();
  const time = argChk_Num(hArg, "time", NaN);
  const delay = argChk_Num(hArg, "delay", 0);
  if (time === 0 && delay === 0 || this.val.getVal("tmp:sn.skip.enabled") || __privateGet2(this, _evtMng2).isSkippingByKeyDown()) {
    oSb.snd.volume = vol;
    if (stop)
      __privateMethod2(this, _stopse, stopse_fn).call(this, hArg);
    return false;
  }
  const repeat = argChk_Num(hArg, "repeat", 1);
  oSb.twFade = new Tween({ v: oSb.snd.volume }).to({ v: vol }, time).delay(delay).easing(CmnTween.ease(hArg.ease)).repeat(repeat === 0 ? Infinity : repeat - 1).yoyo(argChk_Boolean(hArg, "yoyo", false)).onUpdate((o) => {
    if (oSb.playing())
      oSb.snd.volume = o.v;
  }).onComplete(() => {
    const oSb2 = __privateGet2(this, _hSndBuf)[hArg.buf = oSb.now_buf];
    if (!(oSb2 == null ? void 0 : oSb2.twFade))
      return;
    delete oSb2.twFade;
    if (stop)
      __privateMethod2(this, _stopse, stopse_fn).call(this, hArg);
    if (oSb2.resumeFade)
      this.main.resume();
  }).start();
  return false;
};
_playbgm = new WeakSet();
playbgm_fn = function(hArg) {
  hArg.buf = "BGM";
  hArg.canskip = false;
  argChk_Boolean(hArg, "loop", true);
  return __privateMethod2(this, _playse, playse_fn).call(this, hArg);
};
_MAX_END_MS = new WeakMap();
_playse = new WeakSet();
playse_fn = function(hArg) {
  const { buf = "SE", fn } = hArg;
  __privateMethod2(this, _stopse, stopse_fn).call(this, { buf });
  if (!fn)
    throw `[playse] fn\u306F\u5FC5\u9808\u3067\u3059 buf:${buf}`;
  if (argChk_Boolean(hArg, "canskip", true) && __privateGet2(this, _evtMng2).isSkippingByKeyDown())
    return false;
  const loop = argChk_Boolean(hArg, "loop", false);
  __privateMethod2(this, _addLoopPlay, addLoopPlay_fn).call(this, buf, loop);
  const nm = "const.sn.sound." + buf + ".";
  this.val.setVal_Nochk("save", nm + "fn", fn);
  const savevol = __privateMethod2(this, _getVol, getVol_fn).call(this, hArg, 1);
  this.val.setVal_Nochk("save", nm + "volume", savevol);
  const vol = savevol * Number(this.val.getVal("sys:" + nm + "volume", 1));
  const start_ms = argChk_Num(hArg, "start_ms", 0);
  const end_ms = argChk_Num(hArg, "end_ms", __privateGet2(_SoundMng, _MAX_END_MS));
  const ret_ms = argChk_Num(hArg, "ret_ms", 0);
  if (start_ms < 0)
    throw `[playse] start_ms:${start_ms} \u304C\u8CA0\u306E\u5024\u3067\u3059`;
  if (ret_ms < 0)
    throw `[playse] ret_ms:${ret_ms} \u304C\u8CA0\u306E\u5024\u3067\u3059`;
  if (end_ms > 0) {
    if (start_ms >= end_ms)
      throw `[playse] start_ms:${start_ms} >= end_ms:${end_ms} \u306F\u7570\u5E38\u5024\u3067\u3059`;
    if (ret_ms >= end_ms)
      throw `[playse] ret_ms:${ret_ms} >= end_ms:${end_ms} \u306F\u7570\u5E38\u5024\u3067\u3059`;
  }
  this.val.setVal_Nochk("save", nm + "start_ms", start_ms);
  this.val.setVal_Nochk("save", nm + "end_ms", end_ms);
  this.val.setVal_Nochk("save", nm + "ret_ms", ret_ms);
  this.val.flush();
  const snd = I.find(fn);
  const oSb = __privateGet2(this, _hSndBuf)[buf] = {
    now_buf: buf,
    snd,
    loop,
    start_ms,
    end_ms,
    ret_ms,
    resume: false,
    playing: () => true,
    onend: () => {
      const oSb2 = __privateGet2(this, _hSndBuf)[hArg.buf = oSb.now_buf];
      if (!oSb2)
        return;
      delete __privateGet2(this, _hSndBuf)[hArg.buf];
      oSb2.playing = () => false;
      __privateMethod2(this, _stopfadese, stopfadese_fn).call(this, hArg);
      if (oSb2.resume)
        this.main.resume();
    }
  };
  const o = {
    loop,
    volume: vol,
    speed: argChk_Num(hArg, "speed", 1),
    sprites: {},
    loaded: (e, snd2) => {
      if (e) {
        this.main.errScript(`Sound \u30ED\u30FC\u30C9\u5931\u6557\u3067\u3059a fn:${fn} ${e}`, false);
        return;
      }
      if (!snd2)
        return;
      const oSb2 = __privateGet2(this, _hSndBuf)[oSb.now_buf];
      if (oSb2)
        oSb2.snd = snd2;
    }
  };
  let sp_nm = "";
  if (start_ms > 0 || end_ms < __privateGet2(_SoundMng, _MAX_END_MS)) {
    sp_nm = `${fn};${start_ms};${end_ms};${ret_ms}`;
    const os = o.sprites[sp_nm] = {
      start: start_ms / 1e3,
      end: end_ms / 1e3
    };
    o.preload = true;
    const old = o.loaded;
    o.loaded = (e, snd2) => {
      if (e) {
        this.main.errScript(`Sound \u30ED\u30FC\u30C9\u5931\u6557\u3067\u3059b fn:${fn} ${e}`, false);
        return;
      }
      if (!snd2)
        return;
      const d2 = snd2.duration;
      old == null ? void 0 : old(e, snd2);
      if (os.end < 0) {
        os.end += d2;
        snd2.removeSprites(sp_nm);
        snd2.addSprites(sp_nm, os);
        if (os.start >= os.end)
          throw `[playse] start_ms:${start_ms} >= end_ms:${end_ms}(${os.end * 1e3}) \u306F\u7570\u5E38\u5024\u3067\u3059`;
        if (ret_ms >= os.end * 1e3)
          throw `[playse] ret_ms:${ret_ms} >= end_ms:${end_ms}(${os.end * 1e3}) \u306F\u7570\u5E38\u5024\u3067\u3059`;
      }
      if (os.start >= d2)
        throw `[playse] start_ms:${start_ms} >= \u97F3\u58F0\u30D5\u30A1\u30A4\u30EB\u518D\u751F\u6642\u9593:${d2} \u306F\u7570\u5E38\u5024\u3067\u3059`;
      if (end_ms !== __privateGet2(_SoundMng, _MAX_END_MS) && os.end >= d2)
        throw `[playse] end_ms:${end_ms} >= \u97F3\u58F0\u30D5\u30A1\u30A4\u30EB\u518D\u751F\u6642\u9593:${d2} \u306F\u7570\u5E38\u5024\u3067\u3059`;
      snd2.play(sp_nm, o.complete);
    };
  } else
    o.autoPlay = true;
  if (!loop)
    o.complete = () => {
      var _a3;
      return (_a3 = __privateGet2(this, _hSndBuf)[oSb.now_buf]) == null ? void 0 : _a3.onend();
    };
  else if (ret_ms !== 0) {
    o.loop = false;
    o.complete = (snd2) => {
      const d2 = snd2.duration;
      const sp_nm2 = `${fn};loop2;${end_ms};${ret_ms}`;
      const o2 = {
        preload: true,
        loop: true,
        volume: vol,
        speed: o.speed,
        sprites: {},
        loaded: (_2, snd22) => {
          if (!snd22)
            return;
          const oSb2 = __privateGet2(this, _hSndBuf)[oSb.now_buf];
          if (oSb2)
            oSb2.snd = snd22;
          snd22.play(sp_nm2);
        }
      };
      const o2s = o2.sprites[sp_nm2] = {
        start: ret_ms / 1e3,
        end: end_ms / 1e3
      };
      if (o2s.end < 0) {
        o2s.end += d2;
        snd2.removeSprites(sp_nm2);
        snd2.addSprites(sp_nm2, o2s);
      }
      if (o2s.start >= d2)
        throw `[playse] ret_ms:${ret_ms} >= \u97F3\u58F0\u30D5\u30A1\u30A4\u30EB\u518D\u751F\u6642\u9593:${d2} \u306F\u7570\u5E38\u5024\u3067\u3059`;
      __privateMethod2(this, _playseSub, playseSub_fn).call(this, buf, fn, o2);
    };
  }
  __privateGet2(this, _initVol).call(this);
  if (snd) {
    snd.volume = vol;
    if (sp_nm)
      __privateMethod2(this, _playseSub, playseSub_fn).call(this, buf, fn, o);
    else if (snd.isPlayable) {
      const ab = snd.options.source;
      if (!(ab instanceof ArrayBuffer) || ab.byteLength === 0)
        snd.play(o);
      else
        oSb.snd = A.from(__spreadProps(__spreadValues({}, o), {
          url: snd.options.url,
          source: ab
        }));
    }
    return false;
  }
  const join = argChk_Boolean(hArg, "join", true);
  if (join) {
    const old = o.loaded;
    o.loaded = (e, snd2) => {
      old == null ? void 0 : old(e, snd2);
      this.main.resume();
    };
  }
  __privateMethod2(this, _playseSub, playseSub_fn).call(this, buf, fn, o);
  return join;
};
_playseSub = new WeakSet();
playseSub_fn = function(buf, fn, o) {
  const url2 = this.cfg.searchPath(fn, Config.EXT_SOUND);
  if (url2.slice(-4) !== ".bin") {
    o.url = url2;
    const snd = A.from(o);
    if (buf)
      __privateGet2(this, _hSndBuf)[buf].snd = snd;
    if (!o.loop)
      I.add(fn, snd);
    return;
  }
  new Loader().add({ name: fn, url: url2, xhrType: LoaderResource.XHR_RESPONSE_TYPE.BUFFER }).use((res, next) => {
    this.sys.dec(res.extension, res.data).then((r2) => {
      res.data = r2;
      next == null ? void 0 : next();
    }).catch((e) => this.main.errScript(`Sound \u30ED\u30FC\u30C9\u5931\u6557\u3067\u3059 fn:${res.name} ${e}`, false));
  }).load((_ldr, hRes) => {
    var _a3;
    o.source = (_a3 = hRes[fn]) == null ? void 0 : _a3.data;
    const snd = A.from(o);
    if (buf)
      __privateGet2(this, _hSndBuf)[buf].snd = snd;
    if (!o.loop)
      I.add(fn, snd);
  });
};
_initVol = new WeakMap();
_stop_allse = new WeakSet();
stop_allse_fn = function() {
  for (const buf in __privateGet2(this, _hSndBuf))
    __privateMethod2(this, _stopse, stopse_fn).call(this, { buf });
  __privateSet2(this, _hSndBuf, {});
  I.stopAll();
  return false;
};
_stopbgm = new WeakSet();
stopbgm_fn = function(hArg) {
  hArg.buf = "BGM";
  return __privateMethod2(this, _stopse, stopse_fn).call(this, hArg);
};
_stopse = new WeakSet();
stopse_fn = function(hArg) {
  var _a3;
  const { buf = "SE" } = hArg;
  __privateMethod2(this, _delLoopPlay, delLoopPlay_fn).call(this, buf);
  const oSb = __privateGet2(this, _hSndBuf)[buf];
  if (oSb) {
    (_a3 = oSb.snd) == null ? void 0 : _a3.stop();
    oSb.onend();
  }
  return false;
};
_wb = new WeakSet();
wb_fn = function(hArg) {
  hArg.buf = "BGM";
  return __privateMethod2(this, _wf, wf_fn).call(this, hArg);
};
_wf = new WeakSet();
wf_fn = function(hArg) {
  const { buf = "SE" } = hArg;
  const oSb = __privateGet2(this, _hSndBuf)[buf];
  if (!(oSb == null ? void 0 : oSb.twFade) || !oSb.playing())
    return false;
  return oSb.resumeFade = __privateGet2(this, _evtMng2).waitEvent(() => __privateMethod2(this, _stopfadese, stopfadese_fn).call(this, hArg), argChk_Boolean(hArg, "canskip", true), argChk_Boolean(hArg, "global", false));
};
_stopfadese = new WeakSet();
stopfadese_fn = function(hArg) {
  var _a3, _b3;
  const { buf = "SE" } = hArg;
  (_b3 = (_a3 = __privateGet2(this, _hSndBuf)[buf]) == null ? void 0 : _a3.twFade) == null ? void 0 : _b3.stop().end();
  return false;
};
_wl = new WeakSet();
wl_fn = function(hArg) {
  hArg.buf = "BGM";
  return __privateMethod2(this, _ws, ws_fn).call(this, hArg);
};
_ws = new WeakSet();
ws_fn = function(hArg) {
  const { buf = "SE" } = hArg;
  const oSb = __privateGet2(this, _hSndBuf)[buf];
  if (!(oSb == null ? void 0 : oSb.playing()) || oSb.loop)
    return false;
  return oSb.resume = __privateGet2(this, _evtMng2).waitEvent(() => {
    hArg.buf = oSb.now_buf;
    __privateMethod2(this, _stopse, stopse_fn).call(this, hArg);
    const oSb2 = __privateGet2(this, _hSndBuf)[hArg.buf];
    if (!(oSb2 == null ? void 0 : oSb2.playing()) || oSb2.loop)
      return;
    oSb2.onend();
  }, argChk_Boolean(hArg, "canskip", false), argChk_Boolean(hArg, "global", false));
};
_xchgbuf = new WeakSet();
xchgbuf_fn = function(hArg) {
  const { buf: buf1 = "SE", buf2 = "SE" } = hArg;
  if (buf1 === buf2)
    return false;
  const sb1 = __privateGet2(this, _hSndBuf)[buf1];
  if (sb1)
    sb1.now_buf = buf2;
  const sb2 = __privateGet2(this, _hSndBuf)[buf2];
  if (sb2)
    sb2.now_buf = buf1;
  [__privateGet2(this, _hSndBuf)[buf1], __privateGet2(this, _hSndBuf)[buf2]] = [sb2, sb1];
  const n1 = "const.sn.sound." + buf1 + ".";
  const v1 = Number(this.val.getVal("save:" + n1 + "volume"));
  const f1 = Number(this.val.getVal("save:" + n1 + "fn"));
  const n2 = "const.sn.sound." + buf2 + ".";
  const v2 = Number(this.val.getVal("save:" + n2 + "volume"));
  const f2 = Number(this.val.getVal("save:" + n2 + "fn"));
  this.val.setVal_Nochk("save", n1 + "volume", v2);
  this.val.setVal_Nochk("save", n2 + "volume", v1);
  this.val.setVal_Nochk("save", n1 + "fn", f2);
  this.val.setVal_Nochk("save", n2 + "fn", f1);
  if (buf1 in __privateGet2(this, _hLP) === buf2 in __privateGet2(this, _hLP)) {
    if (buf1 in __privateGet2(this, _hLP)) {
      delete __privateGet2(this, _hLP)[buf1];
      __privateGet2(this, _hLP)[buf2] = 0;
    } else {
      delete __privateGet2(this, _hLP)[buf2];
      __privateGet2(this, _hLP)[buf1] = 0;
    }
    this.val.setVal_Nochk("save", "const.sn.loopPlaying", JSON.stringify(__privateGet2(this, _hLP)));
  }
  this.val.flush();
  return false;
};
_addLoopPlay = new WeakSet();
addLoopPlay_fn = function(buf, is_loop) {
  if (!is_loop) {
    __privateMethod2(this, _delLoopPlay, delLoopPlay_fn).call(this, buf);
    return;
  }
  __privateGet2(this, _hLP)[buf] = 0;
  this.val.setVal_Nochk("save", "const.sn.loopPlaying", JSON.stringify(__privateGet2(this, _hLP)));
  this.val.flush();
};
_delLoopPlay = new WeakSet();
delLoopPlay_fn = function(buf) {
  delete __privateGet2(this, _hLP)[buf];
  this.val.setVal_Nochk("save", "const.sn.loopPlaying", JSON.stringify(__privateGet2(this, _hLP)));
  this.val.flush();
};
__privateAdd2(SoundMng, _MAX_END_MS, 999e3);
const _Pages = class {
  constructor(layer, cls_, fore, back, hArg, sys, val, ret) {
    __privateAdd2(this, _pg, void 0);
    this.cls_ = cls_;
    this.lay = (hArg2) => this.getPage(hArg2).lay(hArg2);
    this.getPage = (hArg2) => _Pages.argChk_page(hArg2, "fore") !== "back" ? __privateGet2(this, _pg).fore : __privateGet2(this, _pg).back;
    const fncF = sys.hFactoryCls[cls_];
    if (!fncF)
      throw `\u5C5E\u6027 class\u3010${cls_}\u3011\u304C\u4E0D\u6B63\u3067\u3059`;
    __privateSet2(this, _pg, { fore: fncF(), back: fncF() });
    __privateGet2(this, _pg).fore.layname = __privateGet2(this, _pg).back.layname = layer;
    const nm = hArg[":id_tag"] = `layer:${layer} cls:${cls_}`;
    __privateGet2(this, _pg).fore.name = `${nm} page:A`;
    __privateGet2(this, _pg).back.name = `${nm} page:B`;
    fore.addChild(this.fore.spLay);
    back.addChild(this.back.spLay);
    argChk_Boolean(hArg, "visible", true);
    argChk_Boolean(hArg, "visible", true);
    ret.isWait = this.fore.lay(hArg) || this.back.lay(hArg);
    const valnm = `const.sn.lay.${layer}`;
    val.setVal_Nochk("tmp", valnm, true);
    val.defTmp(valnm + ".fore.alpha", () => __privateGet2(this, _pg).fore.alpha);
    val.defTmp(valnm + ".back.alpha", () => __privateGet2(this, _pg).back.alpha);
    val.defTmp(valnm + ".fore.height", () => __privateGet2(this, _pg).fore.height);
    val.defTmp(valnm + ".back.height", () => __privateGet2(this, _pg).back.height);
    val.defTmp(valnm + ".fore.visible", () => __privateGet2(this, _pg).fore.spLay.visible);
    val.defTmp(valnm + ".back.visible", () => __privateGet2(this, _pg).back.spLay.visible);
    val.defTmp(valnm + ".fore.width", () => __privateGet2(this, _pg).fore.width);
    val.defTmp(valnm + ".back.width", () => __privateGet2(this, _pg).back.width);
    val.defTmp(valnm + ".fore.x", () => __privateGet2(this, _pg).fore.x);
    val.defTmp(valnm + ".back.x", () => __privateGet2(this, _pg).back.x);
    val.defTmp(valnm + ".fore.y", () => __privateGet2(this, _pg).fore.y);
    val.defTmp(valnm + ".back.y", () => __privateGet2(this, _pg).back.y);
  }
  destroy() {
    __privateGet2(this, _pg).fore.destroy();
    __privateGet2(this, _pg).back.destroy();
  }
  static argChk_page(hash2, def) {
    var _a3;
    const v2 = (_a3 = hash2.page) != null ? _a3 : def;
    if (v2 === "fore")
      return hash2.page = v2;
    if (v2 === "back")
      return hash2.page = v2;
    throw Error("\u5C5E\u6027 page\u3010" + v2 + "\u3011\u304C\u4E0D\u6B63\u3067\u3059");
  }
  get cls() {
    return this.cls_;
  }
  get fore() {
    return __privateGet2(this, _pg).fore;
  }
  get back() {
    return __privateGet2(this, _pg).back;
  }
  transPage(aPrm) {
    [__privateGet2(this, _pg).back, __privateGet2(this, _pg).fore] = [__privateGet2(this, _pg).fore, __privateGet2(this, _pg).back];
    __privateGet2(this, _pg).back.copy(__privateGet2(this, _pg).fore, aPrm);
  }
};
let Pages = _Pages;
_pg = new WeakMap();
const _Layer = class {
  constructor() {
    this.layname = "";
    this.name_ = "";
    this.spLay = new Sprite(Texture.EMPTY);
  }
  set name(nm) {
    this.name_ = nm;
  }
  get name() {
    return this.name_;
  }
  get alpha() {
    return this.spLay.alpha;
  }
  set alpha(v2) {
    this.spLay.alpha = v2;
  }
  get height() {
    return this.spLay.height;
  }
  get rotation() {
    return this.spLay.angle;
  }
  set rotation(v2) {
    this.spLay.angle = v2;
  }
  get scale_x() {
    return this.spLay.scale.x;
  }
  set scale_x(v2) {
    this.spLay.scale.x = v2;
  }
  get scale_y() {
    return this.spLay.scale.y;
  }
  set scale_y(v2) {
    this.spLay.scale.y = v2;
  }
  get width() {
    return this.spLay.width;
  }
  get x() {
    return this.spLay.x;
  }
  set x(v2) {
    this.spLay.x = v2;
  }
  get y() {
    return this.spLay.y;
  }
  set y(v2) {
    this.spLay.y = v2;
  }
  destroy() {
  }
  lay(hArg) {
    if ("alpha" in hArg)
      this.spLay.alpha = argChk_Num(hArg, "alpha", 1);
    _Layer.setBlendmode(this.spLay, hArg);
    if ("pivot_x" in hArg || "pivot_y" in hArg)
      this.spLay.pivot.set(argChk_Num(hArg, "pivot_x", this.spLay.pivot.x), argChk_Num(hArg, "pivot_y", this.spLay.pivot.y));
    if ("rotation" in hArg)
      this.spLay.angle = argChk_Num(hArg, "rotation", 0);
    if ("scale_x" in hArg || "scale_y" in hArg)
      this.spLay.scale.set(argChk_Num(hArg, "scale_x", this.spLay.scale.x), argChk_Num(hArg, "scale_y", this.spLay.scale.y));
    if ("visible" in hArg)
      this.spLay.visible = argChk_Boolean(hArg, "visible", true);
    return false;
  }
  static setBlendmode(cnt, hArg) {
    const { blendmode } = hArg;
    if (!blendmode)
      return;
    const bmn = _Layer.getBlendmodeNum(blendmode);
    const sp = cnt;
    if (sp)
      sp.blendMode = bmn;
    cnt.children.forEach((c2) => {
      const cSp = c2;
      if (cSp)
        cSp.blendMode = bmn;
    });
  }
  static getBlendmodeNum(bm_name) {
    if (!bm_name)
      return BLEND_MODES$3.NORMAL;
    const bmn = __privateGet2(_Layer, _hBlendmode)[bm_name];
    if (bmn !== void 0)
      return bmn;
    throw `${bm_name} \u306F\u30B5\u30DD\u30FC\u30C8\u3055\u308C\u306A\u3044 blendmode \u3067\u3059`;
  }
  get containMovement() {
    return false;
  }
  renderStart() {
  }
  renderEnd() {
  }
  clearLay(hArg) {
    this.spLay.alpha = 1;
    this.spLay.blendMode = BLEND_MODES$3.NORMAL;
    this.spLay.pivot.set(0, 0);
    this.spLay.angle = 0;
    this.spLay.scale.set(1, 1);
    if (argChk_Boolean(hArg, "filter", false))
      this.spLay.filters = [];
  }
  copy(fromLayer, aPrm) {
    const org_name = this.name_;
    this.playback(fromLayer.record(), aPrm);
    this.name = org_name;
  }
  record() {
    return {
      name: this.name_,
      idx: this.spLay.parent.getChildIndex(this.spLay),
      alpha: this.spLay.alpha,
      blendMode: this.spLay.blendMode,
      rotation: this.spLay.angle,
      scale_x: this.spLay.scale.x,
      scale_y: this.spLay.scale.y,
      pivot_x: this.spLay.pivot.x,
      pivot_y: this.spLay.pivot.y,
      x: this.spLay.x,
      y: this.spLay.y,
      visible: this.spLay.visible
    };
  }
  playback(hLay, _aPrm) {
    this.name = hLay.name;
    this.clearLay({ filter: "true" });
    this.spLay.alpha = hLay.alpha;
    this.spLay.blendMode = hLay.blendMode;
    this.spLay.angle = hLay.rotation;
    this.spLay.scale.set(hLay.scale_x, hLay.scale_y);
    this.spLay.pivot.set(hLay.pivot_x, hLay.pivot_y);
    this.spLay.position.set(hLay.x, hLay.y);
    this.spLay.visible = hLay.visible;
  }
  snapshot(rnd, re2) {
    rnd.render(this.spLay, { clear: false });
    re2();
  }
  snapshot_end() {
  }
  makeDesignCast(_gdc) {
  }
  makeDesignCastChildren(_gdc) {
  }
  showDesignCast() {
  }
  showDesignCastChildren() {
  }
  cvsResize() {
  }
  cvsResizeChildren() {
  }
  dump() {
    return ` "idx":${this.spLay.parent.getChildIndex(this.spLay)}, "visible":"${this.spLay.visible}", "left":${this.spLay.x}, "top":${this.spLay.y}, "alpha":${this.spLay.alpha}, "rotation":${this.spLay.angle}, "name":"${this.name_}", "scale_x":${this.spLay.scale.x}, "scale_y":${this.spLay.scale.y}`;
  }
  static setXY(base, hArg, ret, isGrp = false, isButton = false) {
    if (hArg.pos) {
      _Layer.setXYByPos(base, hArg.pos, ret);
      return;
    }
    const rct_base = base.getBounds();
    const r_absclX = ret.scale.x < 0 ? -ret.scale.x : ret.scale.x;
    const b_width = r_absclX === 1 ? rct_base.width : rct_base.width * r_absclX;
    const r_absclY = ret.scale.y < 0 ? -ret.scale.y : ret.scale.y;
    const b_height = r_absclY === 1 ? rct_base.height : rct_base.height * r_absclY;
    let x2 = ret.x;
    if ("left" in hArg) {
      x2 = argChk_Num(hArg, "left", 0);
      if (x2 > -1 && x2 < 1)
        x2 *= CmnLib.stageW;
    } else if ("center" in hArg) {
      x2 = argChk_Num(hArg, "center", 0);
      if (x2 > -1 && x2 < 1)
        x2 *= CmnLib.stageW;
      x2 = x2 - (isButton ? b_width / 3 : b_width) / 2;
    } else if ("right" in hArg) {
      x2 = argChk_Num(hArg, "right", 0);
      if (x2 > -1 && x2 < 1)
        x2 *= CmnLib.stageW;
      x2 = x2 - (isButton ? b_width / 3 : b_width);
    } else if ("s_right" in hArg) {
      x2 = argChk_Num(hArg, "s_right", 0);
      if (x2 > -1 && x2 < 1)
        x2 *= CmnLib.stageW;
      x2 = CmnLib.stageW - x2 - (isButton ? b_width / 3 : b_width);
    }
    ret.x = int(ret.scale.x < 0 ? x2 + (isButton ? b_width / 3 : b_width) : x2);
    let y2 = ret.y;
    if ("top" in hArg) {
      y2 = argChk_Num(hArg, "top", 0);
      if (y2 > -1 && y2 < 1)
        y2 *= CmnLib.stageH;
    } else if ("middle" in hArg) {
      y2 = argChk_Num(hArg, "middle", 0);
      if (y2 > -1 && y2 < 1)
        y2 *= CmnLib.stageH;
      y2 = y2 - b_height / 2;
    } else if ("bottom" in hArg) {
      y2 = argChk_Num(hArg, "bottom", 0);
      if (y2 > -1 && y2 < 1)
        y2 *= CmnLib.stageH;
      y2 = y2 - b_height;
    } else if ("s_bottom" in hArg) {
      y2 = argChk_Num(hArg, "s_bottom", 0);
      if (y2 > -1 && y2 < 1)
        y2 *= CmnLib.stageH;
      y2 = CmnLib.stageH - y2 - b_height;
    }
    ret.y = int(ret.scale.y < 0 ? y2 + b_height : y2);
    if (isGrp) {
      if (!("left" in hArg) && !("center" in hArg) && !("right" in hArg) && !("s_right" in hArg) && !("top" in hArg) && !("middle" in hArg) && !("bottom" in hArg) && !("s_bottom" in hArg)) {
        _Layer.setXYByPos(base, "c", ret);
      }
    }
  }
  static setXYByPos(base, pos, ret) {
    if (pos === "stay")
      return;
    if (base === void 0)
      throw "setXYByPos base === undefined";
    if (ret === void 0)
      throw "setXYByPos result === undefined";
    const rct_base = base.getBounds();
    const r_absclX = ret.scale.x < 0 ? -ret.scale.x : ret.scale.x;
    const b_width = r_absclX === 1 ? rct_base.width : rct_base.width * r_absclX;
    const r_absclY = ret.scale.y < 0 ? -ret.scale.y : ret.scale.y;
    const b_height = r_absclY === 1 ? rct_base.height : rct_base.height * r_absclY;
    let c2 = 0;
    if (!pos || pos === "c") {
      c2 = CmnLib.stageW * 0.5;
    } else if (pos === "r") {
      c2 = CmnLib.stageW - b_width * 0.5;
    } else if (pos === "l") {
      c2 = b_width * 0.5;
    } else {
      c2 = int(pos);
    }
    ret.x = int(c2 - b_width * 0.5);
    ret.y = CmnLib.stageH - b_height;
    if (ret.scale.x < 0)
      ret.x += b_width;
    if (ret.scale.y < 0)
      ret.y += b_height;
  }
  static setXYCenter(dsp) {
    const rct = dsp.getBounds();
    dsp.x = (CmnLib.stageW - rct.width) * 0.5;
    dsp.y = (CmnLib.stageH - rct.height) * 0.5;
  }
};
let Layer = _Layer;
_hBlendmode = new WeakMap();
__privateAdd2(Layer, _hBlendmode, {
  "normal": BLEND_MODES$3.NORMAL,
  "add": BLEND_MODES$3.ADD,
  "multiply": BLEND_MODES$3.MULTIPLY,
  "screen": BLEND_MODES$3.SCREEN
});
class EventListenerCtn {
  constructor() {
    __privateAdd2(this, _vctEvt, []);
  }
  add(ed, type, fnc, ctx = {}) {
    if (ed instanceof BaseTexture) {
      switch (type) {
        case "loaded":
        case "update":
        case "error":
        case "dispose":
          ed.on(type, fnc, ctx);
          __privateGet2(this, _vctEvt).push(() => ed.off(type, fnc, ctx));
          break;
      }
      return;
    }
    if (ed instanceof EventEmitter$3) {
      ed.on(type, fnc, ctx);
      __privateGet2(this, _vctEvt).push(() => ed.off(type, fnc, ctx));
      return;
    }
    ed.addEventListener(type, fnc, ctx);
    __privateGet2(this, _vctEvt).push(() => {
      var _a3;
      return ed.removeEventListener(type, fnc, { capture: (_a3 = ctx.capture) != null ? _a3 : false });
    });
  }
  clear() {
    __privateGet2(this, _vctEvt).forEach((f2) => f2());
    __privateSet2(this, _vctEvt, []);
  }
}
_vctEvt = new WeakMap();
function prefixNames(prefix2) {
  var classNames = [];
  for (var _i = 1; _i < arguments.length; _i++) {
    classNames[_i - 1] = arguments[_i];
  }
  return classNames.map(function(className) {
    return className.split(" ").map(function(name2) {
      return name2 ? "" + prefix2 + name2 : "";
    }).join(" ");
  }).join(" ");
}
function prefixCSS(prefix2, css) {
  return css.replace(/([^}{]*){/gm, function(_2, selector) {
    return selector.replace(/\.([^{,\s\d.]+)/g, "." + prefix2 + "$1") + "{";
  });
}
function ref(target, name2) {
  return function(e) {
    e && (target[name2] = e);
  };
}
function refs(target, name2, i2) {
  return function(e) {
    e && (target[name2][i2] = e);
  };
}
function Properties(properties, action) {
  return function(component) {
    var prototype = component.prototype;
    properties.forEach(function(property) {
      action(prototype, property);
    });
  };
}
function withMethods(methods, duplicate) {
  if (duplicate === void 0) {
    duplicate = {};
  }
  return function(prototype, propertyName) {
    methods.forEach(function(name2) {
      var methodName = duplicate[name2] || name2;
      if (methodName in prototype) {
        return;
      }
      prototype[methodName] = function() {
        var _a3;
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          args[_i] = arguments[_i];
        }
        var result = (_a3 = this[propertyName])[name2].apply(_a3, args);
        if (result === this[propertyName]) {
          return this;
        } else {
          return result;
        }
      };
    });
  };
}
var PolyMap = /* @__PURE__ */ function() {
  function PolyMap2() {
    this.keys = [];
    this.values = [];
  }
  var __proto = PolyMap2.prototype;
  __proto.get = function(key) {
    return this.values[this.keys.indexOf(key)];
  };
  __proto.set = function(key, value) {
    var keys = this.keys;
    var values = this.values;
    var prevIndex = keys.indexOf(key);
    var index = prevIndex === -1 ? keys.length : prevIndex;
    keys[index] = key;
    values[index] = value;
  };
  return PolyMap2;
}();
var HashMap = /* @__PURE__ */ function() {
  function HashMap2() {
    this.object = {};
  }
  var __proto = HashMap2.prototype;
  __proto.get = function(key) {
    return this.object[key];
  };
  __proto.set = function(key, value) {
    this.object[key] = value;
  };
  return HashMap2;
}();
var SUPPORT_MAP = typeof Map === "function";
var Link = /* @__PURE__ */ function() {
  function Link2() {
  }
  var __proto = Link2.prototype;
  __proto.connect = function(prevLink, nextLink) {
    this.prev = prevLink;
    this.next = nextLink;
    prevLink && (prevLink.next = this);
    nextLink && (nextLink.prev = this);
  };
  __proto.disconnect = function() {
    var prevLink = this.prev;
    var nextLink = this.next;
    prevLink && (prevLink.next = nextLink);
    nextLink && (nextLink.prev = prevLink);
  };
  __proto.getIndex = function() {
    var link = this;
    var index = -1;
    while (link) {
      link = link.prev;
      ++index;
    }
    return index;
  };
  return Link2;
}();
function orderChanged(changed, fixed) {
  var fromLinks = [];
  var toLinks = [];
  changed.forEach(function(_a3) {
    var from = _a3[0], to = _a3[1];
    var link = new Link();
    fromLinks[from] = link;
    toLinks[to] = link;
  });
  fromLinks.forEach(function(link, i2) {
    link.connect(fromLinks[i2 - 1]);
  });
  return changed.filter(function(_2, i2) {
    return !fixed[i2];
  }).map(function(_a3, i2) {
    var from = _a3[0], to = _a3[1];
    if (from === to) {
      return [0, 0];
    }
    var fromLink = fromLinks[from];
    var toLink = toLinks[to - 1];
    var fromIndex = fromLink.getIndex();
    fromLink.disconnect();
    if (!toLink) {
      fromLink.connect(void 0, fromLinks[0]);
    } else {
      fromLink.connect(toLink, toLink.next);
    }
    var toIndex = fromLink.getIndex();
    return [fromIndex, toIndex];
  });
}
var Result = /* @__PURE__ */ function() {
  function Result2(prevList, list, added, removed, changed, maintained, changedBeforeAdded, fixed) {
    this.prevList = prevList;
    this.list = list;
    this.added = added;
    this.removed = removed;
    this.changed = changed;
    this.maintained = maintained;
    this.changedBeforeAdded = changedBeforeAdded;
    this.fixed = fixed;
  }
  var __proto = Result2.prototype;
  Object.defineProperty(__proto, "ordered", {
    get: function() {
      if (!this.cacheOrdered) {
        this.caculateOrdered();
      }
      return this.cacheOrdered;
    },
    enumerable: true,
    configurable: true
  });
  Object.defineProperty(__proto, "pureChanged", {
    get: function() {
      if (!this.cachePureChanged) {
        this.caculateOrdered();
      }
      return this.cachePureChanged;
    },
    enumerable: true,
    configurable: true
  });
  __proto.caculateOrdered = function() {
    var ordered = orderChanged(this.changedBeforeAdded, this.fixed);
    var changed = this.changed;
    var pureChanged = [];
    this.cacheOrdered = ordered.filter(function(_a3, i2) {
      var from = _a3[0], to = _a3[1];
      var _b3 = changed[i2], fromBefore = _b3[0], toBefore = _b3[1];
      if (from !== to) {
        pureChanged.push([fromBefore, toBefore]);
        return true;
      }
    });
    this.cachePureChanged = pureChanged;
  };
  return Result2;
}();
function diff$1(prevList, list, findKeyCallback2) {
  var mapClass = SUPPORT_MAP ? Map : findKeyCallback2 ? HashMap : PolyMap;
  var callback = findKeyCallback2 || function(e) {
    return e;
  };
  var added = [];
  var removed = [];
  var maintained = [];
  var prevKeys = prevList.map(callback);
  var keys = list.map(callback);
  var prevKeyMap = new mapClass();
  var keyMap = new mapClass();
  var changedBeforeAdded = [];
  var fixed = [];
  var removedMap = {};
  var changed = [];
  var addedCount = 0;
  var removedCount = 0;
  prevKeys.forEach(function(key, prevListIndex) {
    prevKeyMap.set(key, prevListIndex);
  });
  keys.forEach(function(key, listIndex) {
    keyMap.set(key, listIndex);
  });
  prevKeys.forEach(function(key, prevListIndex) {
    var listIndex = keyMap.get(key);
    if (typeof listIndex === "undefined") {
      ++removedCount;
      removed.push(prevListIndex);
    } else {
      removedMap[listIndex] = removedCount;
    }
  });
  keys.forEach(function(key, listIndex) {
    var prevListIndex = prevKeyMap.get(key);
    if (typeof prevListIndex === "undefined") {
      added.push(listIndex);
      ++addedCount;
    } else {
      maintained.push([prevListIndex, listIndex]);
      removedCount = removedMap[listIndex] || 0;
      changedBeforeAdded.push([prevListIndex - removedCount, listIndex - addedCount]);
      fixed.push(listIndex === prevListIndex);
      if (prevListIndex !== listIndex) {
        changed.push([prevListIndex, listIndex]);
      }
    }
  });
  removed.reverse();
  return new Result(prevList, list, added, removed, changed, maintained, changedBeforeAdded, fixed);
}
var ListDiffer = /* @__PURE__ */ function() {
  function ListDiffer2(list, findKeyCallback2) {
    if (list === void 0) {
      list = [];
    }
    this.findKeyCallback = findKeyCallback2;
    this.list = [].slice.call(list);
  }
  var __proto = ListDiffer2.prototype;
  __proto.update = function(list) {
    var newData = [].slice.call(list);
    var result = diff$1(this.list, newData, this.findKeyCallback);
    this.list = newData;
    return result;
  };
  return ListDiffer2;
}();
var FUNCTION = "function";
var OBJECT = "object";
var STRING = "string";
var NUMBER = "number";
var UNDEFINED = "undefined";
var IS_WINDOW = typeof window !== UNDEFINED;
var OPEN_CLOSED_CHARACTERS = [{
  open: "(",
  close: ")"
}, {
  open: '"',
  close: '"'
}, {
  open: "'",
  close: "'"
}, {
  open: '\\"',
  close: '\\"'
}, {
  open: "\\'",
  close: "\\'"
}];
var TINY_NUM$1 = 1e-7;
var DEFAULT_UNIT_PRESETS = {
  "cm": function(pos) {
    return pos * 96 / 2.54;
  },
  "mm": function(pos) {
    return pos * 96 / 254;
  },
  "in": function(pos) {
    return pos * 96;
  },
  "pt": function(pos) {
    return pos * 96 / 72;
  },
  "pc": function(pos) {
    return pos * 96 / 6;
  },
  "%": function(pos, size) {
    return pos * size / 100;
  },
  "vw": function(pos, size) {
    if (size === void 0) {
      size = window.innerWidth;
    }
    return pos / 100 * size;
  },
  "vh": function(pos, size) {
    if (size === void 0) {
      size = window.innerHeight;
    }
    return pos / 100 * size;
  },
  "vmax": function(pos, size) {
    if (size === void 0) {
      size = Math.max(window.innerWidth, window.innerHeight);
    }
    return pos / 100 * size;
  },
  "vmin": function(pos, size) {
    if (size === void 0) {
      size = Math.min(window.innerWidth, window.innerHeight);
    }
    return pos / 100 * size;
  }
};
function dot(a1, a2, b1, b2) {
  return (a1 * b2 + a2 * b1) / (b1 + b2);
}
function isUndefined(value) {
  return typeof value === UNDEFINED;
}
function isObject$2(value) {
  return value && typeof value === OBJECT;
}
function isArray(value) {
  return Array.isArray(value);
}
function isString(value) {
  return typeof value === STRING;
}
function isNumber(value) {
  return typeof value === NUMBER;
}
function isFunction$2(value) {
  return typeof value === FUNCTION;
}
function isEqualSeparator(character, separator) {
  var isCharacterSpace = character === "" || character == " ";
  var isSeparatorSpace = separator === "" || separator == " ";
  return isSeparatorSpace && isCharacterSpace || character === separator;
}
function findOpen(openCharacter, texts, index, length2, openCloseCharacters) {
  var isIgnore = findIgnore(openCharacter, texts, index);
  if (!isIgnore) {
    return findClose(openCharacter, texts, index + 1, length2, openCloseCharacters);
  }
  return index;
}
function findIgnore(character, texts, index) {
  if (!character.ignore) {
    return null;
  }
  var otherText = texts.slice(Math.max(index - 3, 0), index + 3).join("");
  return new RegExp(character.ignore).exec(otherText);
}
function findClose(closeCharacter, texts, index, length2, openCloseCharacters) {
  var _loop_12 = function(i3) {
    var character = texts[i3].trim();
    if (character === closeCharacter.close && !findIgnore(closeCharacter, texts, i3)) {
      return {
        value: i3
      };
    }
    var nextIndex = i3;
    var openCharacter = find$1(openCloseCharacters, function(_a3) {
      var open = _a3.open;
      return open === character;
    });
    if (openCharacter) {
      nextIndex = findOpen(openCharacter, texts, i3, length2, openCloseCharacters);
    }
    if (nextIndex === -1) {
      return out_i_1 = i3, "break";
    }
    i3 = nextIndex;
    out_i_1 = i3;
  };
  var out_i_1;
  for (var i2 = index; i2 < length2; ++i2) {
    var state_1 = _loop_12(i2);
    i2 = out_i_1;
    if (typeof state_1 === "object")
      return state_1.value;
    if (state_1 === "break")
      break;
  }
  return -1;
}
function splitText(text2, splitOptions) {
  var _a3 = isString(splitOptions) ? {
    separator: splitOptions
  } : splitOptions, _b3 = _a3.separator, separator = _b3 === void 0 ? "," : _b3, isSeparateFirst = _a3.isSeparateFirst, isSeparateOnlyOpenClose = _a3.isSeparateOnlyOpenClose, _c3 = _a3.isSeparateOpenClose, isSeparateOpenClose = _c3 === void 0 ? isSeparateOnlyOpenClose : _c3, _d2 = _a3.openCloseCharacters, openCloseCharacters = _d2 === void 0 ? OPEN_CLOSED_CHARACTERS : _d2;
  var openClosedText = openCloseCharacters.map(function(_a4) {
    var open = _a4.open, close = _a4.close;
    if (open === close) {
      return open;
    }
    return open + "|" + close;
  }).join("|");
  var regexText = "(\\s*" + separator + "\\s*|" + openClosedText + "|\\s+)";
  var regex = new RegExp(regexText, "g");
  var texts = text2.split(regex).filter(Boolean);
  var length2 = texts.length;
  var values = [];
  var tempValues = [];
  function resetTemp() {
    if (tempValues.length) {
      values.push(tempValues.join(""));
      tempValues = [];
      return true;
    }
    return false;
  }
  var _loop_22 = function(i3) {
    var character = texts[i3].trim();
    var nextIndex = i3;
    var openCharacter = find$1(openCloseCharacters, function(_a4) {
      var open = _a4.open;
      return open === character;
    });
    var closeCharacter = find$1(openCloseCharacters, function(_a4) {
      var close = _a4.close;
      return close === character;
    });
    if (openCharacter) {
      nextIndex = findOpen(openCharacter, texts, i3, length2, openCloseCharacters);
      if (nextIndex !== -1 && isSeparateOpenClose) {
        if (resetTemp() && isSeparateFirst) {
          return out_i_2 = i3, "break";
        }
        values.push(texts.slice(i3, nextIndex + 1).join(""));
        i3 = nextIndex;
        if (isSeparateFirst) {
          return out_i_2 = i3, "break";
        }
        return out_i_2 = i3, "continue";
      }
    } else if (closeCharacter && !findIgnore(closeCharacter, texts, i3)) {
      throw new Error("invalid format: " + closeCharacter.close);
    } else if (isEqualSeparator(character, separator) && !isSeparateOnlyOpenClose) {
      resetTemp();
      if (isSeparateFirst) {
        return out_i_2 = i3, "break";
      }
      return out_i_2 = i3, "continue";
    }
    if (nextIndex === -1) {
      nextIndex = length2 - 1;
    }
    tempValues.push(texts.slice(i3, nextIndex + 1).join(""));
    i3 = nextIndex;
    out_i_2 = i3;
  };
  var out_i_2;
  for (var i2 = 0; i2 < length2; ++i2) {
    var state_2 = _loop_22(i2);
    i2 = out_i_2;
    if (state_2 === "break")
      break;
  }
  if (tempValues.length) {
    values.push(tempValues.join(""));
  }
  return values;
}
function splitSpace(text2) {
  return splitText(text2, "");
}
function splitComma(text2) {
  return splitText(text2, ",");
}
function splitBracket(text2) {
  var matches = /([^(]*)\(([\s\S]*)\)([\s\S]*)/g.exec(text2);
  if (!matches || matches.length < 4) {
    return {};
  } else {
    return {
      prefix: matches[1],
      value: matches[2],
      suffix: matches[3]
    };
  }
}
function splitUnit(text2) {
  var matches = /^([^\d|e|\-|\+]*)((?:\d|\.|-|e-|e\+)+)(\S*)$/g.exec(text2);
  if (!matches) {
    return {
      prefix: "",
      unit: "",
      value: NaN
    };
  }
  var prefix2 = matches[1];
  var value = matches[2];
  var unit = matches[3];
  return {
    prefix: prefix2,
    unit,
    value: parseFloat(value)
  };
}
function camelize(str2) {
  return str2.replace(/[\s-_]([a-z])/g, function(all2, letter) {
    return letter.toUpperCase();
  });
}
function decamelize(str2, separator) {
  if (separator === void 0) {
    separator = "-";
  }
  return str2.replace(/([a-z])([A-Z])/g, function(all2, letter, letter2) {
    return "" + letter + separator + letter2.toLowerCase();
  });
}
function now() {
  return Date.now ? Date.now() : new Date().getTime();
}
function findIndex(arr, callback, defaultIndex) {
  if (defaultIndex === void 0) {
    defaultIndex = -1;
  }
  var length2 = arr.length;
  for (var i2 = 0; i2 < length2; ++i2) {
    if (callback(arr[i2], i2, arr)) {
      return i2;
    }
  }
  return defaultIndex;
}
function find$1(arr, callback, defalutValue) {
  var index = findIndex(arr, callback);
  return index > -1 ? arr[index] : defalutValue;
}
var requestAnimationFrame$1 = /* @__PURE__ */ function() {
  var firstTime = now();
  var raf = IS_WINDOW && (window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.msRequestAnimationFrame);
  return raf ? raf.bind(window) : function(callback) {
    var currTime = now();
    var id = window.setTimeout(function() {
      callback(currTime - firstTime);
    }, 1e3 / 60);
    return id;
  };
}();
var cancelAnimationFrame$1 = /* @__PURE__ */ function() {
  var caf = IS_WINDOW && (window.cancelAnimationFrame || window.webkitCancelAnimationFrame || window.mozCancelAnimationFrame || window.msCancelAnimationFrame);
  return caf ? caf.bind(window) : function(handle2) {
    clearTimeout(handle2);
  };
}();
function getKeys(obj) {
  if (Object.keys) {
    return Object.keys(obj);
  }
  var keys = [];
  for (var name2 in keys) {
    keys.push(name2);
  }
  return keys;
}
function convertUnitSize(pos, size) {
  var _a3 = splitUnit(pos), value = _a3.value, unit = _a3.unit;
  if (isObject$2(size)) {
    var sizeFunction = size[unit];
    if (sizeFunction) {
      if (isFunction$2(sizeFunction)) {
        return sizeFunction(value);
      } else if (DEFAULT_UNIT_PRESETS[unit]) {
        return DEFAULT_UNIT_PRESETS[unit](value, sizeFunction);
      }
    }
  } else if (unit === "%") {
    return value * size / 100;
  }
  if (DEFAULT_UNIT_PRESETS[unit]) {
    return DEFAULT_UNIT_PRESETS[unit](value);
  }
  return value;
}
function between(value, min, max) {
  return Math.max(min, Math.min(value, max));
}
function checkBoundSize(targetSize, compareSize, isMax) {
  return [[throttle(compareSize[0], TINY_NUM$1), throttle(compareSize[0] * targetSize[1] / targetSize[0], TINY_NUM$1)], [throttle(compareSize[1] * targetSize[0] / targetSize[1], TINY_NUM$1), throttle(compareSize[1], TINY_NUM$1)]].filter(function(size) {
    return size.every(function(value, i2) {
      return isMax ? value <= compareSize[i2] : value >= compareSize[i2];
    });
  })[0] || targetSize;
}
function calculateBoundSize(size, minSize, maxSize, keepRatio) {
  if (!keepRatio) {
    return size.map(function(value, i2) {
      return between(value, minSize[i2], maxSize[i2]);
    });
  }
  var width = size[0], height = size[1];
  var _a3 = checkBoundSize(size, minSize, false), minWidth = _a3[0], minHeight = _a3[1];
  var _b3 = checkBoundSize(size, maxSize, true), maxWidth = _b3[0], maxHeight = _b3[1];
  if (width < minWidth || height < minHeight) {
    width = minWidth;
    height = minHeight;
  } else if (width > maxWidth || height > maxHeight) {
    width = maxWidth;
    height = maxHeight;
  }
  return [width, height];
}
function sum(nums) {
  var length2 = nums.length;
  var total = 0;
  for (var i2 = length2 - 1; i2 >= 0; --i2) {
    total += nums[i2];
  }
  return total;
}
function average(nums) {
  var length2 = nums.length;
  var total = 0;
  for (var i2 = length2 - 1; i2 >= 0; --i2) {
    total += nums[i2];
  }
  return length2 ? total / length2 : 0;
}
function getRad$1(pos1, pos2) {
  var distX = pos2[0] - pos1[0];
  var distY = pos2[1] - pos1[1];
  var rad = Math.atan2(distY, distX);
  return rad >= 0 ? rad : rad + Math.PI * 2;
}
function getCenterPoint(points) {
  return [0, 1].map(function(i2) {
    return average(points.map(function(pos) {
      return pos[i2];
    }));
  });
}
function getShapeDirection(points) {
  var center = getCenterPoint(points);
  var pos1Rad = getRad$1(center, points[0]);
  var pos2Rad = getRad$1(center, points[1]);
  return pos1Rad < pos2Rad && pos2Rad - pos1Rad < Math.PI || pos1Rad > pos2Rad && pos2Rad - pos1Rad < -Math.PI ? 1 : -1;
}
function getDist$2(a2, b2) {
  return Math.sqrt(Math.pow((b2 ? b2[0] : 0) - a2[0], 2) + Math.pow((b2 ? b2[1] : 0) - a2[1], 2));
}
function throttle(num, unit) {
  if (!unit) {
    return num;
  }
  return Math.round(num / unit) * unit;
}
function throttleArray(nums, unit) {
  nums.forEach(function(_2, i2) {
    nums[i2] = throttle(nums[i2], unit);
  });
  return nums;
}
function hasClass(element, className) {
  if (element.classList) {
    return element.classList.contains(className);
  }
  return !!element.className.match(new RegExp("(\\s|^)" + className + "(\\s|$)"));
}
function addClass(element, className) {
  if (element.classList) {
    element.classList.add(className);
  } else {
    element.className += " " + className;
  }
}
function removeClass(element, className) {
  if (element.classList) {
    element.classList.remove(className);
  } else {
    var reg = new RegExp("(\\s|^)" + className + "(\\s|$)");
    element.className = element.className.replace(reg, " ");
  }
}
function addEvent(el, type, listener, options) {
  el.addEventListener(type, listener, options);
}
function removeEvent(el, type, listener, options) {
  el.removeEventListener(type, listener, options);
}
/*! *****************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */
var extendStatics$6 = function(d2, b2) {
  extendStatics$6 = Object.setPrototypeOf || {
    __proto__: []
  } instanceof Array && function(d3, b3) {
    d3.__proto__ = b3;
  } || function(d3, b3) {
    for (var p2 in b3)
      if (b3.hasOwnProperty(p2))
        d3[p2] = b3[p2];
  };
  return extendStatics$6(d2, b2);
};
function __extends$6(d2, b2) {
  extendStatics$6(d2, b2);
  function __() {
    this.constructor = d2;
  }
  d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
}
var __assign$7 = function() {
  __assign$7 = Object.assign || function __assign2(t) {
    for (var s2, i2 = 1, n = arguments.length; i2 < n; i2++) {
      s2 = arguments[i2];
      for (var p2 in s2)
        if (Object.prototype.hasOwnProperty.call(s2, p2))
          t[p2] = s2[p2];
    }
    return t;
  };
  return __assign$7.apply(this, arguments);
};
function __rest$2(s2, e) {
  var t = {};
  for (var p2 in s2)
    if (Object.prototype.hasOwnProperty.call(s2, p2) && e.indexOf(p2) < 0)
      t[p2] = s2[p2];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s2); i2 < p2.length; i2++) {
      if (e.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i2]))
        t[p2[i2]] = s2[p2[i2]];
    }
  return t;
}
function __spreadArrays$3() {
  for (var s2 = 0, i2 = 0, il = arguments.length; i2 < il; i2++)
    s2 += arguments[i2].length;
  for (var r2 = Array(s2), k = 0, i2 = 0; i2 < il; i2++)
    for (var a2 = arguments[i2], j2 = 0, jl = a2.length; j2 < jl; j2++, k++)
      r2[k] = a2[j2];
  return r2;
}
function isDiff(a2, b2) {
  if (a2 === b2) {
    return false;
  }
  for (var i2 in a2) {
    if (!(i2 in b2)) {
      return true;
    }
  }
  for (var i2 in b2) {
    if (a2[i2] !== b2[i2]) {
      return true;
    }
  }
  return false;
}
function diffObject(a2, b2) {
  var keys1 = Object.keys(a2);
  var keys2 = Object.keys(b2);
  var result = diff$1(keys1, keys2, function(key) {
    return key;
  });
  var added = {};
  var removed = {};
  var changed = {};
  result.added.forEach(function(index) {
    var name2 = keys2[index];
    added[name2] = b2[name2];
  });
  result.removed.forEach(function(index) {
    var name2 = keys1[index];
    removed[name2] = a2[name2];
  });
  result.maintained.forEach(function(_a3) {
    var index = _a3[0];
    var name2 = keys1[index];
    var values = [a2[name2], b2[name2]];
    if (a2[name2] !== b2[name2]) {
      changed[name2] = values;
    }
  });
  return {
    added,
    removed,
    changed
  };
}
function executeHooks(hooks) {
  hooks.forEach(function(hook) {
    hook();
  });
}
function fillKeys(keys) {
  var index = 0;
  return keys.map(function(key) {
    return key == null ? "$compat" + ++index : "" + key;
  });
}
function createProvider(el, key, index, container) {
  if (isString(el) || isNumber(el)) {
    return new TextProvider("text_" + el, key, index, container, null, {});
  }
  var providerClass = typeof el.type === "string" ? ElementProvider : el.type.prototype.render ? ComponentProvider : FunctionProvider;
  return new providerClass(el.type, key, index, container, el.ref, el.props);
}
function flat$1(arr) {
  var arr2 = [];
  arr.forEach(function(el) {
    arr2 = arr2.concat(isArray(el) ? flat$1(el) : el);
  });
  return arr2;
}
function getAttributes(props) {
  var className = props.className, otherProps = __rest$2(props, ["className"]);
  if (className != null) {
    otherProps.class = className;
  }
  delete otherProps.style;
  delete otherProps.children;
  return otherProps;
}
function fillProps(props, defaultProps) {
  if (!defaultProps) {
    return props;
  }
  for (var name2 in defaultProps) {
    if (isUndefined(props[name2])) {
      props[name2] = defaultProps[name2];
    }
  }
  return props;
}
function createElement(type, props) {
  var children = [];
  for (var _i = 2; _i < arguments.length; _i++) {
    children[_i - 2] = arguments[_i];
  }
  var _a3 = props || {}, key = _a3.key, ref2 = _a3.ref, otherProps = __rest$2(_a3, ["key", "ref"]);
  return {
    type,
    key,
    ref: ref2,
    props: __assign$7(__assign$7({}, otherProps), {
      children: flat$1(children).filter(function(child) {
        return child != null && child !== false;
      })
    })
  };
}
var Provider = /* @__PURE__ */ function() {
  function Provider2(type, key, index, container, ref2, props) {
    if (props === void 0) {
      props = {};
    }
    this.type = type;
    this.key = key;
    this.index = index;
    this.container = container;
    this.ref = ref2;
    this.props = props;
    this._providers = [];
  }
  var __proto = Provider2.prototype;
  __proto._should = function(nextProps, nextState) {
    return true;
  };
  __proto._update = function(hooks, nextElement, nextState, isForceUpdate) {
    if (this.base && !isString(nextElement) && !isForceUpdate && !this._should(nextElement.props, nextState)) {
      return false;
    }
    this.original = nextElement;
    this._setState(nextState);
    var prevProps = this.props;
    if (!isString(nextElement)) {
      this.props = nextElement.props;
      this.ref = nextElement.ref;
    }
    this._render(hooks, this.base ? prevProps : {}, nextState);
    return true;
  };
  __proto._mounted = function() {
    var ref2 = this.ref;
    ref2 && ref2(this.base);
  };
  __proto._setState = function(nextstate) {
    return;
  };
  __proto._updated = function() {
    var ref2 = this.ref;
    ref2 && ref2(this.base);
  };
  __proto._destroy = function() {
    var ref2 = this.ref;
    ref2 && ref2(null);
  };
  return Provider2;
}();
function diffAttributes(attrs1, attrs2, el) {
  var _a3 = diffObject(attrs1, attrs2), added = _a3.added, removed = _a3.removed, changed = _a3.changed;
  for (var name2 in added) {
    el.setAttribute(name2, added[name2]);
  }
  for (var name2 in changed) {
    el.setAttribute(name2, changed[name2][1]);
  }
  for (var name2 in removed) {
    el.removeAttribute(name2);
  }
}
function diffEvents(events1, events2, provier) {
  var _a3 = diffObject(events1, events2), added = _a3.added, removed = _a3.removed, changed = _a3.changed;
  for (var name2 in removed) {
    provier.removeEventListener(name2);
  }
  for (var name2 in added) {
    provier.addEventListener(name2, added[name2]);
  }
  for (var name2 in changed) {
    provier.removeEventListener(name2);
    provier.addEventListener(name2, changed[name2][1]);
  }
  for (var name2 in removed) {
    provier.removeEventListener(name2);
  }
}
function diffStyle(style1, style2, el) {
  var style = el.style;
  var _a3 = diffObject(style1, style2), added = _a3.added, removed = _a3.removed, changed = _a3.changed;
  for (var beforeName in added) {
    var name2 = decamelize(beforeName, "-");
    if (style.setProperty) {
      style.setProperty(name2, added[beforeName]);
    } else {
      style[name2] = added[beforeName];
    }
  }
  for (var beforeName in changed) {
    var name2 = decamelize(beforeName, "-");
    if (style.setProperty) {
      style.setProperty(name2, changed[beforeName][1]);
    } else {
      style[name2] = changed[beforeName][1];
    }
  }
  for (var beforeName in removed) {
    var name2 = decamelize(beforeName, "-");
    if (style.removeProperty) {
      style.removeProperty(name2);
    } else {
      style[name2] = "";
    }
  }
}
function splitProps(props) {
  var attributes = {};
  var events = {};
  for (var name2 in props) {
    if (name2.indexOf("on") === 0) {
      events[name2.replace("on", "").toLowerCase()] = props[name2];
    } else {
      attributes[name2] = props[name2];
    }
  }
  return {
    attributes,
    events
  };
}
var TextProvider = /* @__PURE__ */ function(_super) {
  __extends$6(TextProvider2, _super);
  function TextProvider2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  var __proto = TextProvider2.prototype;
  __proto._render = function(hooks) {
    var _this = this;
    var isMount = !this.base;
    if (isMount) {
      this.base = document.createTextNode(this.type.replace("text_", ""));
    }
    hooks.push(function() {
      if (isMount) {
        _this._mounted();
      } else {
        _this._updated();
      }
    });
    return true;
  };
  __proto._unmount = function() {
    this.base.parentNode.removeChild(this.base);
  };
  return TextProvider2;
}(Provider);
var ElementProvider = /* @__PURE__ */ function(_super) {
  __extends$6(ElementProvider2, _super);
  function ElementProvider2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.events = {};
    _this._isSVG = false;
    return _this;
  }
  var __proto = ElementProvider2.prototype;
  __proto.addEventListener = function(name2, callback) {
    var events = this.events;
    events[name2] = function(e) {
      e.nativeEvent = e;
      callback(e);
    };
    this.base.addEventListener(name2, events[name2]);
  };
  __proto.removeEventListener = function(name2) {
    var events = this.events;
    this.base.removeEventListener(name2, events[name2]);
    delete events[name2];
  };
  __proto._should = function(nextProps) {
    return isDiff(this.props, nextProps);
  };
  __proto._render = function(hooks, prevProps) {
    var _this = this;
    var isMount = !this.base;
    if (isMount) {
      var isSVG = this._hasSVG();
      this._isSVG = isSVG;
      var element = this.props.portalContainer;
      if (!element) {
        var type = this.type;
        if (isSVG) {
          element = document.createElementNS("http://www.w3.org/2000/svg", type);
        } else {
          element = document.createElement(type);
        }
      }
      this.base = element;
    }
    renderProviders(this, this._providers, this.props.children, hooks, null);
    var base = this.base;
    var _a3 = splitProps(prevProps), prevAttributes = _a3.attributes, prevEvents = _a3.events;
    var _b3 = splitProps(this.props), nextAttributes = _b3.attributes, nextEvents = _b3.events;
    diffAttributes(getAttributes(prevAttributes), getAttributes(nextAttributes), base);
    diffEvents(prevEvents, nextEvents, this);
    diffStyle(prevProps.style || {}, this.props.style || {}, base);
    hooks.push(function() {
      if (isMount) {
        _this._mounted();
      } else {
        _this._updated();
      }
    });
    return true;
  };
  __proto._unmount = function() {
    var events = this.events;
    var base = this.base;
    for (var name2 in events) {
      base.removeEventListener(name2, events[name2]);
    }
    this._providers.forEach(function(provider) {
      provider._unmount();
    });
    this.events = {};
    if (!this.props.portalContainer) {
      base.parentNode.removeChild(base);
    }
  };
  __proto._hasSVG = function() {
    if (this._isSVG || this.type === "svg") {
      return true;
    }
    var containerNode = findContainerNode(this.container);
    return containerNode && "ownerSVGElement" in containerNode;
  };
  return ElementProvider2;
}(Provider);
function findContainerNode(provider) {
  if (!provider) {
    return null;
  }
  var base = provider.base;
  if (base instanceof Node) {
    return base;
  }
  return findContainerNode(provider.container);
}
function findDOMNode(comp) {
  if (!comp) {
    return null;
  }
  if (comp instanceof Node) {
    return comp;
  }
  var providers = comp.$_provider._providers;
  if (!providers.length) {
    return null;
  }
  return findDOMNode(providers[0].base);
}
var FunctionProvider = /* @__PURE__ */ function(_super) {
  __extends$6(FunctionProvider2, _super);
  function FunctionProvider2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  var __proto = FunctionProvider2.prototype;
  __proto._render = function(hooks) {
    var template = this.type(this.props);
    renderProviders(this, this._providers, template ? [template] : [], hooks);
    return true;
  };
  __proto._unmount = function() {
    this._providers.forEach(function(provider) {
      provider._unmount();
    });
  };
  return FunctionProvider2;
}(Provider);
var ContainerProvider = /* @__PURE__ */ function(_super) {
  __extends$6(ContainerProvider2, _super);
  function ContainerProvider2(base) {
    var _this = _super.call(this, "container", "container", 0, null) || this;
    _this.base = base;
    return _this;
  }
  var __proto = ContainerProvider2.prototype;
  __proto._render = function() {
    return true;
  };
  __proto._unmount = function() {
    return;
  };
  return ContainerProvider2;
}(Provider);
var ComponentProvider = /* @__PURE__ */ function(_super) {
  __extends$6(ComponentProvider2, _super);
  function ComponentProvider2(type, key, index, container, ref2, props) {
    if (props === void 0) {
      props = {};
    }
    return _super.call(this, type, key, index, container, ref2, fillProps(props, type.defaultProps)) || this;
  }
  var __proto = ComponentProvider2.prototype;
  __proto._should = function(nextProps, nextState) {
    return this.base.shouldComponentUpdate(fillProps(nextProps, this.type.defaultProps), nextState || this.base.state);
  };
  __proto._render = function(hooks, prevProps, nextState) {
    var _this = this;
    this.props = fillProps(this.props, this.type.defaultProps);
    var isMount = !this.base;
    if (isMount) {
      this.base = new this.type(this.props);
      this.base.$_provider = this;
    } else {
      this.base.props = this.props;
    }
    var base = this.base;
    var prevState = base.state;
    var template = base.render();
    if (template && template.props && !template.props.children.length) {
      template.props.children = this.props.children;
    }
    renderProviders(this, this._providers, template ? [template] : [], hooks, nextState, null);
    hooks.push(function() {
      if (isMount) {
        _this._mounted();
        base.componentDidMount();
      } else {
        _this._updated();
        base.componentDidUpdate(prevProps, prevState);
      }
    });
  };
  __proto._setState = function(nextState) {
    var base = this.base;
    if (!base || !nextState) {
      return;
    }
    base.state = nextState;
  };
  __proto._unmount = function() {
    this._providers.forEach(function(provider) {
      provider._unmount();
    });
    clearTimeout(this.base.$_timer);
    this.base.componentWillUnmount();
  };
  return ComponentProvider2;
}(Provider);
var Component = /* @__PURE__ */ function() {
  function Component2(props) {
    if (props === void 0) {
      props = {};
    }
    this.props = props;
    this.state = {};
    this.$_timer = 0;
    this.$_state = {};
  }
  var __proto = Component2.prototype;
  __proto.shouldComponentUpdate = function(props, state) {
    return true;
  };
  __proto.render = function() {
    return null;
  };
  __proto.setState = function(state, callback, isForceUpdate) {
    var _this = this;
    if (!this.$_timer) {
      this.$_state = {};
    }
    clearTimeout(this.$_timer);
    this.$_timer = 0;
    this.$_state = __assign$7(__assign$7({}, this.$_state), state);
    if (!isForceUpdate) {
      this.$_timer = setTimeout(function() {
        _this.$_timer = 0;
        _this.$_setState(callback, isForceUpdate);
      });
    } else {
      this.$_setState(callback, isForceUpdate);
    }
    return;
  };
  __proto.forceUpdate = function(callback) {
    this.setState({}, callback, true);
  };
  __proto.componentDidMount = function() {
  };
  __proto.componentDidUpdate = function(prevProps, prevState) {
  };
  __proto.componentWillUnmount = function() {
  };
  __proto.$_setState = function(callback, isForceUpdate) {
    var hooks = [];
    var provider = this.$_provider;
    var isUpdate = renderProviders(provider.container, [provider], [provider.original], hooks, __assign$7(__assign$7({}, this.state), this.$_state), isForceUpdate);
    if (isUpdate) {
      if (callback) {
        hooks.push(callback);
      }
      executeHooks(hooks);
    }
  };
  return Component2;
}();
var PureComponent = /* @__PURE__ */ function(_super) {
  __extends$6(PureComponent2, _super);
  function PureComponent2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  var __proto = PureComponent2.prototype;
  __proto.shouldComponentUpdate = function(props, state) {
    return isDiff(this.props, props) || isDiff(this.state, state);
  };
  return PureComponent2;
}(Component);
var _Portal = /* @__PURE__ */ function(_super) {
  __extends$6(_Portal2, _super);
  function _Portal2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  var __proto = _Portal2.prototype;
  __proto.componentDidMount = function() {
    var _a3 = this.props, element = _a3.element, container = _a3.container;
    this._portalProvider = new ContainerProvider(container);
    renderProvider(element, container, this._portalProvider);
  };
  __proto.componentDidUpdate = function() {
    var _a3 = this.props, element = _a3.element, container = _a3.container;
    renderProvider(element, container, this._portalProvider);
  };
  __proto.componentWillUnmount = function() {
    var container = this.props.container;
    renderProvider(null, container, this._portalProvider);
    this._portalProvider = null;
  };
  return _Portal2;
}(PureComponent);
function updateProvider(provider, children, nextState) {
  var hooks = [];
  renderProviders(provider, provider._providers, children, hooks, nextState);
  executeHooks(hooks);
}
function getNextSibiling(provider, childProvider) {
  var childProviders = provider._providers;
  var length2 = childProviders.length;
  for (var i2 = childProvider.index + 1; i2 < length2; ++i2) {
    var el = findDOMNode(childProviders[i2].base);
    if (el) {
      return el;
    }
  }
  return null;
}
function diffProviders(containerProvider, providers, children) {
  var childrenKeys = children.map(function(p2) {
    return isString(p2) ? null : p2.key;
  });
  var keys1 = fillKeys(providers.map(function(p2) {
    return p2.key;
  }));
  var keys2 = fillKeys(childrenKeys);
  var result = diff$1(keys1, keys2, function(key) {
    return key;
  });
  result.removed.forEach(function(index) {
    providers.splice(index, 1)[0]._unmount();
  });
  result.ordered.forEach(function(_a3) {
    var from = _a3[0], to = _a3[1];
    var childrenProvider = providers.splice(from, 1)[0];
    providers.splice(to, 0, childrenProvider);
    var el = findDOMNode(childrenProvider.base);
    var next = findDOMNode(providers[to + 1] && providers[to + 1].base);
    if (el) {
      el.parentNode.insertBefore(el, next);
    }
  });
  result.added.forEach(function(index) {
    providers.splice(index, 0, createProvider(children[index], childrenKeys[index], index, containerProvider));
  });
  var changed = result.maintained.filter(function(_a3) {
    _a3[0];
    var to = _a3[1];
    var el = children[to];
    var childProvider = providers[to];
    var type = isString(el) ? "text_" + el : el.type;
    if (type !== childProvider.type) {
      childProvider._unmount();
      providers.splice(to, 1, createProvider(el, childrenKeys[to], to, containerProvider));
      return true;
    }
    childProvider.index = to;
    return false;
  });
  return __spreadArrays$3(result.added, changed.map(function(_a3) {
    _a3[0];
    var to = _a3[1];
    return to;
  }));
}
function renderProviders(containerProvider, providers, children, updatedHooks, nextState, isForceUpdate) {
  var result = diffProviders(containerProvider, providers, children);
  var updated = providers.filter(function(childProvider, i2) {
    return childProvider._update(updatedHooks, children[i2], nextState, isForceUpdate);
  });
  var containerNode = findContainerNode(containerProvider);
  if (containerNode) {
    result.reverse().forEach(function(index) {
      var childProvider = providers[index];
      var el = findDOMNode(childProvider.base);
      if (!el) {
        return;
      }
      if (containerNode !== el && !el.parentNode) {
        var nextElement = getNextSibiling(containerProvider, childProvider);
        containerNode.insertBefore(el, nextElement);
      }
    });
  }
  return updated.length > 0;
}
function renderProvider(element, container, provider) {
  if (provider === void 0) {
    provider = container.__REACT_COMPAT__;
  }
  var isProvider = !!provider;
  if (!provider) {
    provider = new ContainerProvider(container);
  }
  updateProvider(provider, element ? [element] : []);
  if (!isProvider) {
    container.__REACT_COMPAT__ = provider;
  }
  return provider;
}
function render(element, container, callback) {
  var provider = container.__REACT_COMPAT__;
  if (element && !provider) {
    container.innerHTML = "";
  }
  renderProvider(element, container, provider);
  callback && callback();
}
function createPortal(el, container) {
  return createElement(_Portal, {
    element: el,
    container
  });
}
var version = "simple-1.1.0";
function some(arr, callback) {
  var length2 = arr.length;
  for (var i2 = 0; i2 < length2; ++i2) {
    if (callback(arr[i2], i2)) {
      return true;
    }
  }
  return false;
}
function find(arr, callback) {
  var length2 = arr.length;
  for (var i2 = 0; i2 < length2; ++i2) {
    if (callback(arr[i2], i2)) {
      return arr[i2];
    }
  }
  return null;
}
function getUserAgent(agent2) {
  var userAgent = agent2;
  if (typeof userAgent === "undefined") {
    if (typeof navigator === "undefined" || !navigator) {
      return "";
    }
    userAgent = navigator.userAgent || "";
  }
  return userAgent.toLowerCase();
}
function execRegExp(pattern, text2) {
  try {
    return new RegExp(pattern, "g").exec(text2);
  } catch (e) {
    return null;
  }
}
function hasUserAgentData() {
  if (typeof navigator === "undefined" || !navigator || !navigator.userAgentData) {
    return false;
  }
  var userAgentData = navigator.userAgentData;
  var brands = userAgentData.brands || userAgentData.uaList;
  return !!(brands && brands.length);
}
function findVersion(versionTest, userAgent) {
  var result = execRegExp("(" + versionTest + ")((?:\\/|\\s|:)([0-9|\\.|_]+))", userAgent);
  return result ? result[3] : "";
}
function convertVersion(text2) {
  return text2.replace(/_/g, ".");
}
function findPreset(presets, userAgent) {
  var userPreset = null;
  var version2 = "-1";
  some(presets, function(preset) {
    var result = execRegExp("(" + preset.test + ")((?:\\/|\\s|:)([0-9|\\.|_]+))?", userAgent);
    if (!result || preset.brand) {
      return false;
    }
    userPreset = preset;
    version2 = result[3] || "-1";
    if (preset.versionAlias) {
      version2 = preset.versionAlias;
    } else if (preset.versionTest) {
      version2 = findVersion(preset.versionTest.toLowerCase(), userAgent) || version2;
    }
    version2 = convertVersion(version2);
    return true;
  });
  return {
    preset: userPreset,
    version: version2
  };
}
function findPresetBrand(presets, brands) {
  var brandInfo = {
    brand: "",
    version: "-1"
  };
  some(presets, function(preset) {
    var result = findBrand(brands, preset);
    if (!result) {
      return false;
    }
    brandInfo.brand = preset.id;
    brandInfo.version = preset.versionAlias || result.version;
    return brandInfo.version !== "-1";
  });
  return brandInfo;
}
function findBrand(brands, preset) {
  return find(brands, function(_a3) {
    var brand = _a3.brand;
    return execRegExp("" + preset.test, brand.toLowerCase());
  });
}
var BROWSER_PRESETS = [{
  test: "phantomjs",
  id: "phantomjs"
}, {
  test: "whale",
  id: "whale"
}, {
  test: "edgios|edge|edg",
  id: "edge"
}, {
  test: "msie|trident|windows phone",
  id: "ie",
  versionTest: "iemobile|msie|rv"
}, {
  test: "miuibrowser",
  id: "miui browser"
}, {
  test: "samsungbrowser",
  id: "samsung internet"
}, {
  test: "samsung",
  id: "samsung internet",
  versionTest: "version"
}, {
  test: "chrome|crios",
  id: "chrome"
}, {
  test: "firefox|fxios",
  id: "firefox"
}, {
  test: "android",
  id: "android browser",
  versionTest: "version"
}, {
  test: "safari|iphone|ipad|ipod",
  id: "safari",
  versionTest: "version"
}];
var CHROMIUM_PRESETS = [{
  test: "(?=.*applewebkit/(53[0-7]|5[0-2]|[0-4]))(?=.*\\schrome)",
  id: "chrome",
  versionTest: "chrome"
}, {
  test: "chromium",
  id: "chrome"
}, {
  test: "whale",
  id: "chrome",
  versionAlias: "-1",
  brand: true
}];
var WEBKIT_PRESETS = [{
  test: "applewebkit",
  id: "webkit",
  versionTest: "applewebkit|safari"
}];
var WEBVIEW_PRESETS = [{
  test: "(?=(iphone|ipad))(?!(.*version))",
  id: "webview"
}, {
  test: "(?=(android|iphone|ipad))(?=.*(naver|daum|; wv))",
  id: "webview"
}, {
  test: "webview",
  id: "webview"
}];
var OS_PRESETS = [{
  test: "windows phone",
  id: "windows phone"
}, {
  test: "windows 2000",
  id: "window",
  versionAlias: "5.0"
}, {
  test: "windows nt",
  id: "window"
}, {
  test: "win32|windows",
  id: "window"
}, {
  test: "iphone|ipad|ipod",
  id: "ios",
  versionTest: "iphone os|cpu os"
}, {
  test: "macos|macintel|mac os x",
  id: "mac"
}, {
  test: "android|linux armv81",
  id: "android"
}, {
  test: "tizen",
  id: "tizen"
}, {
  test: "webos|web0s",
  id: "webos"
}];
function parseUserAgentData(osData) {
  var userAgentData = navigator.userAgentData;
  var brands = (userAgentData.uaList || userAgentData.brands).slice();
  var isMobile2 = userAgentData.mobile || false;
  var firstBrand = brands[0];
  var platform2 = (osData && osData.platform || userAgentData.platform || navigator.platform).toLowerCase();
  var browser = {
    name: firstBrand.brand,
    version: firstBrand.version,
    majorVersion: -1,
    webkit: false,
    webkitVersion: "-1",
    chromium: false,
    chromiumVersion: "-1",
    webview: !!findPresetBrand(WEBVIEW_PRESETS, brands).brand
  };
  var os = {
    name: "unknown",
    version: "-1",
    majorVersion: -1
  };
  browser.webkit = !browser.chromium && some(WEBKIT_PRESETS, function(preset) {
    return findBrand(brands, preset);
  });
  var chromiumBrand = findPresetBrand(CHROMIUM_PRESETS, brands);
  browser.chromium = !!chromiumBrand.brand;
  browser.chromiumVersion = chromiumBrand.version;
  if (!browser.chromium) {
    var webkitBrand = findPresetBrand(WEBKIT_PRESETS, brands);
    browser.webkit = !!webkitBrand.brand;
    browser.webkitVersion = webkitBrand.version;
  }
  var platfomResult = find(OS_PRESETS, function(preset) {
    return new RegExp("" + preset.test, "g").exec(platform2);
  });
  os.name = platfomResult ? platfomResult.id : "";
  if (osData) {
    os.version = osData.platformVersion;
  }
  var browserBrand = findPresetBrand(BROWSER_PRESETS, brands);
  if (browserBrand.brand) {
    browser.name = browserBrand.brand;
    browser.version = osData ? osData.uaFullVersion : browserBrand.version;
  }
  if (browser.webkit) {
    os.name = isMobile2 ? "ios" : "mac";
  }
  if (os.name === "ios" && browser.webview) {
    browser.version = "-1";
  }
  os.version = convertVersion(os.version);
  browser.version = convertVersion(browser.version);
  os.majorVersion = parseInt(os.version, 10);
  browser.majorVersion = parseInt(browser.version, 10);
  return {
    browser,
    os,
    isMobile: isMobile2,
    isHints: true
  };
}
function parseUserAgent(userAgent) {
  var nextAgent = getUserAgent(userAgent);
  var isMobile2 = !!/mobi/g.exec(nextAgent);
  var browser = {
    name: "unknown",
    version: "-1",
    majorVersion: -1,
    webview: !!findPreset(WEBVIEW_PRESETS, nextAgent).preset,
    chromium: false,
    chromiumVersion: "-1",
    webkit: false,
    webkitVersion: "-1"
  };
  var os = {
    name: "unknown",
    version: "-1",
    majorVersion: -1
  };
  var _a3 = findPreset(BROWSER_PRESETS, nextAgent), browserPreset = _a3.preset, browserVersion = _a3.version;
  var _b3 = findPreset(OS_PRESETS, nextAgent), osPreset = _b3.preset, osVersion = _b3.version;
  var chromiumPreset = findPreset(CHROMIUM_PRESETS, nextAgent);
  browser.chromium = !!chromiumPreset.preset;
  browser.chromiumVersion = chromiumPreset.version;
  if (!browser.chromium) {
    var webkitPreset = findPreset(WEBKIT_PRESETS, nextAgent);
    browser.webkit = !!webkitPreset.preset;
    browser.webkitVersion = webkitPreset.version;
  }
  if (osPreset) {
    os.name = osPreset.id;
    os.version = osVersion;
    os.majorVersion = parseInt(osVersion, 10);
  }
  if (browserPreset) {
    browser.name = browserPreset.id;
    browser.version = browserVersion;
    if (browser.webview && os.name === "ios" && browser.name !== "safari") {
      browser.webview = false;
    }
  }
  browser.majorVersion = parseInt(browser.version, 10);
  return {
    browser,
    os,
    isMobile: isMobile2,
    isHints: false
  };
}
function agent$1(userAgent) {
  if (typeof userAgent === "undefined" && hasUserAgentData()) {
    return parseUserAgentData();
  } else {
    return parseUserAgent(userAgent);
  }
}
function add(matrix, inverseMatrix, startIndex, fromIndex, n, k) {
  for (var i2 = 0; i2 < n; ++i2) {
    var x2 = startIndex + i2 * n;
    var fromX = fromIndex + i2 * n;
    matrix[x2] += matrix[fromX] * k;
    inverseMatrix[x2] += inverseMatrix[fromX] * k;
  }
}
function swap(matrix, inverseMatrix, startIndex, fromIndex, n) {
  for (var i2 = 0; i2 < n; ++i2) {
    var x2 = startIndex + i2 * n;
    var fromX = fromIndex + i2 * n;
    var v2 = matrix[x2];
    var iv = inverseMatrix[x2];
    matrix[x2] = matrix[fromX];
    matrix[fromX] = v2;
    inverseMatrix[x2] = inverseMatrix[fromX];
    inverseMatrix[fromX] = iv;
  }
}
function divide(matrix, inverseMatrix, startIndex, n, k) {
  for (var i2 = 0; i2 < n; ++i2) {
    var x2 = startIndex + i2 * n;
    matrix[x2] /= k;
    inverseMatrix[x2] /= k;
  }
}
function ignoreDimension(matrix, m2, n) {
  if (n === void 0) {
    n = Math.sqrt(matrix.length);
  }
  var newMatrix = matrix.slice();
  for (var i2 = 0; i2 < n; ++i2) {
    newMatrix[i2 * n + m2 - 1] = 0;
    newMatrix[(m2 - 1) * n + i2] = 0;
  }
  newMatrix[(m2 - 1) * (n + 1)] = 1;
  return newMatrix;
}
function invert(matrix, n) {
  if (n === void 0) {
    n = Math.sqrt(matrix.length);
  }
  var newMatrix = matrix.slice();
  var inverseMatrix = createIdentityMatrix(n);
  for (var i2 = 0; i2 < n; ++i2) {
    var identityIndex = n * i2 + i2;
    if (!throttle(newMatrix[identityIndex], TINY_NUM$1)) {
      for (var j2 = i2 + 1; j2 < n; ++j2) {
        if (newMatrix[n * i2 + j2]) {
          swap(newMatrix, inverseMatrix, i2, j2, n);
          break;
        }
      }
    }
    if (!throttle(newMatrix[identityIndex], TINY_NUM$1)) {
      return [];
    }
    divide(newMatrix, inverseMatrix, i2, n, newMatrix[identityIndex]);
    for (var j2 = 0; j2 < n; ++j2) {
      var targetStartIndex = j2;
      var targetIndex = j2 + i2 * n;
      var target = newMatrix[targetIndex];
      if (!throttle(target, TINY_NUM$1) || i2 === j2) {
        continue;
      }
      add(newMatrix, inverseMatrix, targetStartIndex, i2, n, -target);
    }
  }
  return inverseMatrix;
}
function transpose(matrix, n) {
  if (n === void 0) {
    n = Math.sqrt(matrix.length);
  }
  var newMatrix = [];
  for (var i2 = 0; i2 < n; ++i2) {
    for (var j2 = 0; j2 < n; ++j2) {
      newMatrix[j2 * n + i2] = matrix[n * i2 + j2];
    }
  }
  return newMatrix;
}
function getOrigin(matrix, n) {
  if (n === void 0) {
    n = Math.sqrt(matrix.length);
  }
  var originMatrix = [];
  var w2 = matrix[n * n - 1];
  for (var i2 = 0; i2 < n - 1; ++i2) {
    originMatrix[i2] = matrix[n * (n - 1) + i2] / w2;
  }
  originMatrix[n - 1] = 0;
  return originMatrix;
}
function fromTranslation(pos, n) {
  var newMatrix = createIdentityMatrix(n);
  for (var i2 = 0; i2 < n - 1; ++i2) {
    newMatrix[n * (n - 1) + i2] = pos[i2] || 0;
  }
  return newMatrix;
}
function convertPositionMatrix(matrix, n) {
  var newMatrix = matrix.slice();
  for (var i2 = matrix.length; i2 < n - 1; ++i2) {
    newMatrix[i2] = 0;
  }
  newMatrix[n - 1] = 1;
  return newMatrix;
}
function convertDimension(matrix, n, m2) {
  if (n === void 0) {
    n = Math.sqrt(matrix.length);
  }
  if (n === m2) {
    return matrix;
  }
  var newMatrix = createIdentityMatrix(m2);
  var length2 = Math.min(n, m2);
  for (var i2 = 0; i2 < length2 - 1; ++i2) {
    for (var j2 = 0; j2 < length2 - 1; ++j2) {
      newMatrix[i2 * m2 + j2] = matrix[i2 * n + j2];
    }
    newMatrix[(i2 + 1) * m2 - 1] = matrix[(i2 + 1) * n - 1];
    newMatrix[(m2 - 1) * m2 + i2] = matrix[(n - 1) * n + i2];
  }
  newMatrix[m2 * m2 - 1] = matrix[n * n - 1];
  return newMatrix;
}
function multiplies(n) {
  var matrixes = [];
  for (var _i = 1; _i < arguments.length; _i++) {
    matrixes[_i - 1] = arguments[_i];
  }
  var m2 = createIdentityMatrix(n);
  matrixes.forEach(function(matrix) {
    m2 = multiply(m2, matrix, n);
  });
  return m2;
}
function multiply(matrix, matrix2, n) {
  if (n === void 0) {
    n = Math.sqrt(matrix.length);
  }
  var newMatrix = [];
  var m2 = matrix.length / n;
  var k = matrix2.length / m2;
  if (!m2) {
    return matrix2;
  } else if (!k) {
    return matrix;
  }
  for (var i2 = 0; i2 < n; ++i2) {
    for (var j2 = 0; j2 < k; ++j2) {
      newMatrix[j2 * n + i2] = 0;
      for (var l2 = 0; l2 < m2; ++l2) {
        newMatrix[j2 * n + i2] += matrix[l2 * n + i2] * matrix2[j2 * m2 + l2];
      }
    }
  }
  return newMatrix;
}
function plus(pos1, pos2) {
  var length2 = Math.min(pos1.length, pos2.length);
  var nextPos = pos1.slice();
  for (var i2 = 0; i2 < length2; ++i2) {
    nextPos[i2] = nextPos[i2] + pos2[i2];
  }
  return nextPos;
}
function minus(pos1, pos2) {
  var length2 = Math.min(pos1.length, pos2.length);
  var nextPos = pos1.slice();
  for (var i2 = 0; i2 < length2; ++i2) {
    nextPos[i2] = nextPos[i2] - pos2[i2];
  }
  return nextPos;
}
function convertCSStoMatrix(a2, is2d) {
  if (is2d === void 0) {
    is2d = a2.length === 6;
  }
  if (is2d) {
    return [a2[0], a2[1], 0, a2[2], a2[3], 0, a2[4], a2[5], 1];
  }
  return a2;
}
function convertMatrixtoCSS(a2, is2d) {
  if (is2d === void 0) {
    is2d = a2.length === 9;
  }
  if (is2d) {
    return [a2[0], a2[1], a2[3], a2[4], a2[6], a2[7]];
  }
  return a2;
}
function calculate(matrix, matrix2, n) {
  if (n === void 0) {
    n = matrix2.length;
  }
  var result = multiply(matrix, matrix2, n);
  var k = result[n - 1];
  return result.map(function(v2) {
    return v2 / k;
  });
}
function rotateX3d(matrix, rad) {
  return multiply(matrix, [1, 0, 0, 0, 0, Math.cos(rad), Math.sin(rad), 0, 0, -Math.sin(rad), Math.cos(rad), 0, 0, 0, 0, 1], 4);
}
function rotateY3d(matrix, rad) {
  return multiply(matrix, [Math.cos(rad), 0, -Math.sin(rad), 0, 0, 1, 0, 0, Math.sin(rad), 0, Math.cos(rad), 0, 0, 0, 0, 1], 4);
}
function rotateZ3d(matrix, rad) {
  return multiply(matrix, createRotateMatrix(rad, 4));
}
function scale3d(matrix, _a3) {
  var _b3 = _a3[0], sx = _b3 === void 0 ? 1 : _b3, _c3 = _a3[1], sy = _c3 === void 0 ? 1 : _c3, _d2 = _a3[2], sz = _d2 === void 0 ? 1 : _d2;
  return multiply(matrix, [sx, 0, 0, 0, 0, sy, 0, 0, 0, 0, sz, 0, 0, 0, 0, 1], 4);
}
function rotate(pos, rad) {
  return calculate(createRotateMatrix(rad, 3), convertPositionMatrix(pos, 3));
}
function translate3d(matrix, _a3) {
  var _b3 = _a3[0], tx = _b3 === void 0 ? 0 : _b3, _c3 = _a3[1], ty = _c3 === void 0 ? 0 : _c3, _d2 = _a3[2], tz = _d2 === void 0 ? 0 : _d2;
  return multiply(matrix, [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, tx, ty, tz, 1], 4);
}
function matrix3d(matrix1, matrix2) {
  return multiply(matrix1, matrix2, 4);
}
function createRotateMatrix(rad, n) {
  var cos = Math.cos(rad);
  var sin = Math.sin(rad);
  var m2 = createIdentityMatrix(n);
  m2[0] = cos;
  m2[1] = sin;
  m2[n] = -sin;
  m2[n + 1] = cos;
  return m2;
}
function createIdentityMatrix(n) {
  var length2 = n * n;
  var matrix = [];
  for (var i2 = 0; i2 < length2; ++i2) {
    matrix[i2] = i2 % (n + 1) ? 0 : 1;
  }
  return matrix;
}
function createScaleMatrix(scale, n) {
  var m2 = createIdentityMatrix(n);
  var length2 = Math.min(scale.length, n - 1);
  for (var i2 = 0; i2 < length2; ++i2) {
    m2[(n + 1) * i2] = scale[i2];
  }
  return m2;
}
function createOriginMatrix(origin, n) {
  var m2 = createIdentityMatrix(n);
  var length2 = Math.min(origin.length, n - 1);
  for (var i2 = 0; i2 < length2; ++i2) {
    m2[n * (n - 1) + i2] = origin[i2];
  }
  return m2;
}
function createWarpMatrix(pos0, pos1, pos2, pos3, nextPos0, nextPos1, nextPos2, nextPos3) {
  var x0 = pos0[0], y0 = pos0[1];
  var x1 = pos1[0], y1 = pos1[1];
  var x2 = pos2[0], y2 = pos2[1];
  var x3 = pos3[0], y3 = pos3[1];
  var u0 = nextPos0[0], v0 = nextPos0[1];
  var u1 = nextPos1[0], v1 = nextPos1[1];
  var u2 = nextPos2[0], v2 = nextPos2[1];
  var u3 = nextPos3[0], v3 = nextPos3[1];
  var matrix = [x0, 0, x1, 0, x2, 0, x3, 0, y0, 0, y1, 0, y2, 0, y3, 0, 1, 0, 1, 0, 1, 0, 1, 0, 0, x0, 0, x1, 0, x2, 0, x3, 0, y0, 0, y1, 0, y2, 0, y3, 0, 1, 0, 1, 0, 1, 0, 1, -u0 * x0, -v0 * x0, -u1 * x1, -v1 * x1, -u2 * x2, -v2 * x2, -u3 * x3, -v3 * x3, -u0 * y0, -v0 * y0, -u1 * y1, -v1 * y1, -u2 * y2, -v2 * y2, -u3 * y3, -v3 * y3];
  var inverseMatrix = invert(matrix, 8);
  if (!inverseMatrix.length) {
    return [];
  }
  var h2 = multiply(inverseMatrix, [u0, v0, u1, v1, u2, v2, u3, v3], 8);
  h2[8] = 1;
  return convertDimension(transpose(h2), 3, 4);
}
function createMatrix() {
  return [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
}
function parseMat(transform) {
  return toMat(parse(transform));
}
function calculateMatrixDist(matrix, pos) {
  var res = calculate(matrix, [pos[0], pos[1] || 0, pos[2] || 0, 1], 4);
  var w2 = res[3] || 1;
  return [res[0] / w2, res[1] / w2, res[2] / w2];
}
function toMat(matrixInfos) {
  var target = createMatrix();
  matrixInfos.forEach(function(info) {
    var matrixFunction = info.matrixFunction, functionValue = info.functionValue;
    if (!matrixFunction) {
      return;
    }
    target = matrixFunction(target, functionValue);
  });
  return target;
}
function parse(transform) {
  var transforms = isArray(transform) ? transform : splitSpace(transform);
  return transforms.map(function(t) {
    var _a3 = splitBracket(t), name2 = _a3.prefix, value = _a3.value;
    var matrixFunction = null;
    var functionName = name2;
    var functionValue = "";
    if (name2 === "translate" || name2 === "translateX" || name2 === "translate3d") {
      var _b3 = splitComma(value).map(function(v2) {
        return parseFloat(v2);
      }), posX = _b3[0], _c3 = _b3[1], posY = _c3 === void 0 ? 0 : _c3, _d2 = _b3[2], posZ = _d2 === void 0 ? 0 : _d2;
      matrixFunction = translate3d;
      functionValue = [posX, posY, posZ];
    } else if (name2 === "translateY") {
      var posY = parseFloat(value);
      matrixFunction = translate3d;
      functionValue = [0, posY, 0];
    } else if (name2 === "translateZ") {
      var posZ = parseFloat(value);
      matrixFunction = translate3d;
      functionValue = [0, 0, posZ];
    } else if (name2 === "scale" || name2 === "scale3d") {
      var _e = splitComma(value).map(function(v2) {
        return parseFloat(v2);
      }), sx = _e[0], _f = _e[1], sy = _f === void 0 ? sx : _f, _g = _e[2], sz = _g === void 0 ? 1 : _g;
      matrixFunction = scale3d;
      functionValue = [sx, sy, sz];
    } else if (name2 === "scaleX") {
      var sx = parseFloat(value);
      matrixFunction = scale3d;
      functionValue = [sx, 1, 1];
    } else if (name2 === "scaleY") {
      var sy = parseFloat(value);
      matrixFunction = scale3d;
      functionValue = [1, sy, 1];
    } else if (name2 === "scaleZ") {
      var sz = parseFloat(value);
      matrixFunction = scale3d;
      functionValue = [1, 1, sz];
    } else if (name2 === "rotate" || name2 === "rotateZ" || name2 === "rotateX" || name2 === "rotateY") {
      var _h = splitUnit(value), unit = _h.unit, unitValue = _h.value;
      var rad = unit === "rad" ? unitValue : unitValue * Math.PI / 180;
      if (name2 === "rotate" || name2 === "rotateZ") {
        functionName = "rotateZ";
        matrixFunction = rotateZ3d;
      } else if (name2 === "rotateX") {
        matrixFunction = rotateX3d;
      } else if (name2 === "rotateY") {
        matrixFunction = rotateY3d;
      }
      functionValue = rad;
    } else if (name2 === "matrix3d") {
      matrixFunction = matrix3d;
      functionValue = splitComma(value).map(function(v2) {
        return parseFloat(v2);
      });
    } else if (name2 === "matrix") {
      var m2 = splitComma(value).map(function(v2) {
        return parseFloat(v2);
      });
      matrixFunction = matrix3d;
      functionValue = [m2[0], m2[1], 0, 0, m2[2], m2[3], 0, 0, 0, 0, 1, 0, m2[4], m2[5], 0, 1];
    } else {
      functionName = "";
    }
    return {
      name: name2,
      functionName,
      value,
      matrixFunction,
      functionValue
    };
  });
}
/*! *****************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */
var extendStatics$5 = function(d2, b2) {
  extendStatics$5 = Object.setPrototypeOf || {
    __proto__: []
  } instanceof Array && function(d3, b3) {
    d3.__proto__ = b3;
  } || function(d3, b3) {
    for (var p2 in b3)
      if (b3.hasOwnProperty(p2))
        d3[p2] = b3[p2];
  };
  return extendStatics$5(d2, b2);
};
function __extends$5(d2, b2) {
  extendStatics$5(d2, b2);
  function __() {
    this.constructor = d2;
  }
  d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
}
var findKeyCallback = typeof Map === "function" ? void 0 : function() {
  var childrenCount = 0;
  return function(el) {
    return el.__DIFF_KEY__ || (el.__DIFF_KEY__ = ++childrenCount);
  };
}();
var ChildrenDiffer = /* @__PURE__ */ function(_super) {
  __extends$5(ChildrenDiffer2, _super);
  function ChildrenDiffer2(list) {
    if (list === void 0) {
      list = [];
    }
    return _super.call(this, list, findKeyCallback) || this;
  }
  return ChildrenDiffer2;
}(ListDiffer);
function diff(prevList, list) {
  return diff$1(prevList, list, findKeyCallback);
}
var ChildrenDiffer$1 = ChildrenDiffer;
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
function __spreadArrays$2() {
  for (var s2 = 0, i2 = 0, il = arguments.length; i2 < il; i2++)
    s2 += arguments[i2].length;
  for (var r2 = Array(s2), k = 0, i2 = 0; i2 < il; i2++)
    for (var a2 = arguments[i2], j2 = 0, jl = a2.length; j2 < jl; j2++, k++)
      r2[k] = a2[j2];
  return r2;
}
function getAreaSize(points) {
  if (points.length < 3) {
    return 0;
  }
  return Math.abs(sum(points.map(function(point, i2) {
    var nextPoint = points[i2 + 1] || points[0];
    return point[0] * nextPoint[1] - nextPoint[0] * point[1];
  }))) / 2;
}
function fitPoints(points, rect) {
  var width = rect.width, height = rect.height, left = rect.left, top = rect.top;
  var _a3 = getMinMaxs(points), minX = _a3.minX, minY = _a3.minY, maxX = _a3.maxX, maxY = _a3.maxY;
  var ratioX = width / (maxX - minX);
  var ratioY = height / (maxY - minY);
  return points.map(function(point) {
    return [left + (point[0] - minX) * ratioX, top + (point[1] - minY) * ratioY];
  });
}
function getMinMaxs(points) {
  var xs = points.map(function(point) {
    return point[0];
  });
  var ys = points.map(function(point) {
    return point[1];
  });
  return {
    minX: Math.min.apply(Math, xs),
    minY: Math.min.apply(Math, ys),
    maxX: Math.max.apply(Math, xs),
    maxY: Math.max.apply(Math, ys)
  };
}
function isInside(pos, points, excludeLine) {
  var x2 = pos[0], y2 = pos[1];
  var _a3 = getMinMaxs(points), minX = _a3.minX, minY = _a3.minY, maxX = _a3.maxX, maxY = _a3.maxY;
  var xLine = [[minX, y2], [maxX, y2]];
  var yLine = [[x2, minY], [x2, maxY]];
  var xLinearConstants = getLinearConstants(xLine[0], xLine[1]);
  var yLinearConstants = getLinearConstants(yLine[0], yLine[1]);
  var lines = convertLines(points);
  var intersectionXPoints = [];
  var intersectionYPoints = [];
  lines.forEach(function(line) {
    var linearConstants = getLinearConstants(line[0], line[1]);
    var xPoints = getPointsOnLines(getIntersectionPointsByConstants(xLinearConstants, linearConstants), [xLine, line]);
    var yPoints = getPointsOnLines(getIntersectionPointsByConstants(yLinearConstants, linearConstants), [yLine, line]);
    if (xPoints.length === 1 ? line[0][1] !== y2 : true) {
      intersectionXPoints.push.apply(intersectionXPoints, xPoints);
    }
    if (yPoints.length === 1 ? line[0][0] !== x2 : true) {
      intersectionYPoints.push.apply(intersectionYPoints, yPoints);
    }
    if (!linearConstants[0]) {
      intersectionXPoints.push.apply(intersectionXPoints, xPoints);
    }
    if (!linearConstants[1]) {
      intersectionYPoints.push.apply(intersectionYPoints, yPoints);
    }
  });
  if (!excludeLine) {
    if (findIndex(intersectionXPoints, function(p2) {
      return p2[0] === x2;
    }) > -1 || findIndex(intersectionYPoints, function(p2) {
      return p2[1] === y2;
    }) > -1) {
      return true;
    }
  }
  if (intersectionXPoints.filter(function(p2) {
    return p2[0] > x2;
  }).length % 2 && intersectionYPoints.filter(function(p2) {
    return p2[1] > y2;
  }).length % 2) {
    return true;
  }
  return false;
}
function getLinearConstants(point1, point2) {
  var x1 = point1[0], y1 = point1[1];
  var x2 = point2[0], y2 = point2[1];
  if (x1 === x2 && y1 === y2) {
    return [0, 0, 0];
  }
  if (x1 === x2) {
    return [1, 0, -x1];
  } else if (y1 === y2) {
    return [0, 1, -y1];
  } else {
    var a_1 = (x2 - x1) / (y1 - y2);
    var b_1 = -x1 - a_1 * y1;
    return [1, a_1, b_1];
  }
}
function getIntersectionPointsByConstants(linearConstants1, linearConstants2) {
  var a1 = linearConstants1[0], b1 = linearConstants1[1], c1 = linearConstants1[2];
  var a2 = linearConstants2[0], b2 = linearConstants2[1], c2 = linearConstants2[2];
  var isZeroA = a1 === 0 && a2 === 0;
  var isZeroB = b1 === 0 && b2 === 0;
  if (isZeroA && isZeroB) {
    return [];
  } else if (isZeroA) {
    var y1 = -c1 / b1;
    var y2 = -c2 / b2;
    if (y1 !== y2) {
      return [];
    } else {
      return [[-Infinity, y1], [Infinity, y1]];
    }
  } else if (isZeroB) {
    var x1 = -c1 / a1;
    var x2 = -c2 / a2;
    if (x1 !== x2) {
      return [];
    } else {
      return [[x1, -Infinity], [x1, Infinity]];
    }
  } else if (a1 === 0) {
    var y3 = -c1 / b1;
    var x3 = -(b2 * y3 + c2) / a2;
    return [[x3, y3]];
  } else if (a2 === 0) {
    var y3 = -c2 / b2;
    var x3 = -(b1 * y3 + c1) / a1;
    return [[x3, y3]];
  } else if (b1 === 0) {
    var x3 = -c1 / a1;
    var y3 = -(a2 * x3 + c2) / b2;
    return [[x3, y3]];
  } else if (b2 === 0) {
    var x3 = -c2 / a2;
    var y3 = -(a1 * x3 + c1) / b1;
    return [[x3, y3]];
  } else {
    var x3 = (b1 * c2 - b2 * c1) / (b2 * a1 - b1 * a2);
    var y3 = -(a1 * x3 + c1) / b1;
    return [[x3, y3]];
  }
}
function getPointsOnLines(points, lines) {
  var minMaxs = lines.map(function(line) {
    return [0, 1].map(function(order) {
      return [Math.min(line[0][order], line[1][order]), Math.max(line[0][order], line[1][order])];
    });
  });
  if (points.length === 2) {
    var _a3 = points[0], x2 = _a3[0], y2 = _a3[1];
    if (x2 === points[1][0]) {
      var top = Math.max.apply(Math, minMaxs.map(function(minMax) {
        return minMax[1][0];
      }));
      var bottom = Math.min.apply(Math, minMaxs.map(function(minMax) {
        return minMax[1][1];
      }));
      if (top > bottom) {
        return [];
      }
      return [[x2, top], [x2, bottom]];
    } else if (y2 === points[1][1]) {
      var left = Math.max.apply(Math, minMaxs.map(function(minMax) {
        return minMax[0][0];
      }));
      var right = Math.min.apply(Math, minMaxs.map(function(minMax) {
        return minMax[0][1];
      }));
      if (left > right) {
        return [];
      }
      return [[left, y2], [right, y2]];
    }
  }
  return points.filter(function(point) {
    return minMaxs.every(function(minMax) {
      return minMax[0][0] <= point[0] && point[0] <= minMax[0][1] && minMax[1][0] <= point[1] && point[1] <= minMax[1][1];
    });
  });
}
function convertLines(points) {
  return __spreadArrays$2(points.slice(1), [points[0]]).map(function(point, i2) {
    return [points[i2], point];
  });
}
function getOverlapPoints(points1, points2) {
  var targetPoints1 = points1.slice();
  var targetPoints2 = points2.slice();
  if (getShapeDirection(targetPoints1) === -1) {
    targetPoints1.reverse();
  }
  if (getShapeDirection(targetPoints2) === -1) {
    targetPoints2.reverse();
  }
  var lines1 = convertLines(targetPoints1);
  var lines2 = convertLines(targetPoints2);
  var linearConstantss1 = lines1.map(function(line1) {
    return getLinearConstants(line1[0], line1[1]);
  });
  var linearConstantss2 = lines2.map(function(line2) {
    return getLinearConstants(line2[0], line2[1]);
  });
  var overlapInfos = [];
  linearConstantss1.forEach(function(linearConstants1, i2) {
    var line1 = lines1[i2];
    var linePointInfos = [];
    linearConstantss2.forEach(function(linearConstants2, j2) {
      var intersectionPoints = getIntersectionPointsByConstants(linearConstants1, linearConstants2);
      var points = getPointsOnLines(intersectionPoints, [line1, lines2[j2]]);
      linePointInfos.push.apply(linePointInfos, points.map(function(pos) {
        return {
          index1: i2,
          index2: j2,
          pos
        };
      }));
    });
    linePointInfos.sort(function(a2, b2) {
      return getDist$2(line1[0], a2.pos) - getDist$2(line1[0], b2.pos);
    });
    overlapInfos.push.apply(overlapInfos, linePointInfos);
    if (isInside(line1[1], targetPoints2)) {
      overlapInfos.push({
        index1: i2,
        index2: -1,
        pos: line1[1]
      });
    }
  });
  lines2.forEach(function(line2, i2) {
    if (isInside(line2[1], targetPoints1)) {
      var isNext_1 = false;
      var index = findIndex(overlapInfos, function(_a3) {
        var index2 = _a3.index2;
        if (index2 === i2) {
          isNext_1 = true;
          return false;
        }
        if (isNext_1) {
          return true;
        }
        return false;
      });
      if (index === -1) {
        isNext_1 = false;
        index = findIndex(overlapInfos, function(_a3) {
          var index1 = _a3.index1, index2 = _a3.index2;
          if (index1 === -1 && index2 + 1 === i2) {
            isNext_1 = true;
            return false;
          }
          if (isNext_1) {
            return true;
          }
          return false;
        });
      }
      if (index === -1) {
        overlapInfos.push({
          index1: -1,
          index2: i2,
          pos: line2[1]
        });
      } else {
        overlapInfos.splice(index, 0, {
          index1: -1,
          index2: i2,
          pos: line2[1]
        });
      }
    }
  });
  var overlapPoints = overlapInfos.map(function(_a3) {
    var pos = _a3.pos;
    return pos;
  });
  var pointMap = {};
  return overlapPoints.filter(function(point) {
    var key = point[0] + "x" + point[1];
    if (pointMap[key]) {
      return false;
    }
    pointMap[key] = true;
    return true;
  });
}
function getOverlapSize(points1, points2) {
  var points = getOverlapPoints(points1, points2);
  return getAreaSize(points);
}
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var __assign$6 = function() {
  __assign$6 = Object.assign || function __assign2(t) {
    for (var s2, i2 = 1, n = arguments.length; i2 < n; i2++) {
      s2 = arguments[i2];
      for (var p2 in s2)
        if (Object.prototype.hasOwnProperty.call(s2, p2))
          t[p2] = s2[p2];
    }
    return t;
  };
  return __assign$6.apply(this, arguments);
};
function __spreadArrays$1() {
  for (var s2 = 0, i2 = 0, il = arguments.length; i2 < il; i2++)
    s2 += arguments[i2].length;
  for (var r2 = Array(s2), k = 0, i2 = 0; i2 < il; i2++)
    for (var a2 = arguments[i2], j2 = 0, jl = a2.length; j2 < jl; j2++, k++)
      r2[k] = a2[j2];
  return r2;
}
var EventEmitter$1 = /* @__PURE__ */ function() {
  function EventEmitter2() {
    this._events = {};
  }
  var __proto = EventEmitter2.prototype;
  __proto.on = function(eventName, listener) {
    if (isObject$2(eventName)) {
      for (var name2 in eventName) {
        this.on(name2, eventName[name2]);
      }
    } else {
      this._addEvent(eventName, listener, {});
    }
    return this;
  };
  __proto.off = function(eventName, listener) {
    if (!eventName) {
      this._events = {};
    } else if (isObject$2(eventName)) {
      for (var name2 in eventName) {
        this.off(name2);
      }
    } else if (!listener) {
      this._events[eventName] = [];
    } else {
      var events = this._events[eventName];
      if (events) {
        var index = findIndex(events, function(e) {
          return e.listener === listener;
        });
        if (index > -1) {
          events.splice(index, 1);
        }
      }
    }
    return this;
  };
  __proto.once = function(eventName, listener) {
    var _this = this;
    if (listener) {
      this._addEvent(eventName, listener, {
        once: true
      });
    }
    return new Promise(function(resolve2) {
      _this._addEvent(eventName, resolve2, {
        once: true
      });
    });
  };
  __proto.emit = function(eventName, param) {
    var _this = this;
    if (param === void 0) {
      param = {};
    }
    var events = this._events[eventName];
    if (!eventName || !events) {
      return true;
    }
    var isStop = false;
    param.eventType = eventName;
    param.stop = function() {
      isStop = true;
    };
    param.currentTarget = this;
    __spreadArrays$1(events).forEach(function(info) {
      info.listener(param);
      if (info.once) {
        _this.off(eventName, info.listener);
      }
    });
    return !isStop;
  };
  __proto.trigger = function(eventName, param) {
    if (param === void 0) {
      param = {};
    }
    return this.emit(eventName, param);
  };
  __proto._addEvent = function(eventName, listener, options) {
    var events = this._events;
    events[eventName] = events[eventName] || [];
    var listeners = events[eventName];
    listeners.push(__assign$6({
      listener
    }, options));
  };
  return EventEmitter2;
}();
var EventEmitter$2 = EventEmitter$1;
/*! *****************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */
var extendStatics$4 = function(d2, b2) {
  extendStatics$4 = Object.setPrototypeOf || {
    __proto__: []
  } instanceof Array && function(d3, b3) {
    d3.__proto__ = b3;
  } || function(d3, b3) {
    for (var p2 in b3)
      if (b3.hasOwnProperty(p2))
        d3[p2] = b3[p2];
  };
  return extendStatics$4(d2, b2);
};
function __extends$4(d2, b2) {
  extendStatics$4(d2, b2);
  function __() {
    this.constructor = d2;
  }
  d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
}
var __assign$5 = function() {
  __assign$5 = Object.assign || function __assign2(t) {
    for (var s2, i2 = 1, n = arguments.length; i2 < n; i2++) {
      s2 = arguments[i2];
      for (var p2 in s2)
        if (Object.prototype.hasOwnProperty.call(s2, p2))
          t[p2] = s2[p2];
    }
    return t;
  };
  return __assign$5.apply(this, arguments);
};
function getDefaultScrollPosition$1(e) {
  var container = e.container;
  if (container === document.body) {
    return [container.scrollLeft || document.documentElement.scrollLeft, container.scrollTop || document.documentElement.scrollTop];
  }
  return [container.scrollLeft, container.scrollTop];
}
var DragScroll = /* @__PURE__ */ function(_super) {
  __extends$4(DragScroll2, _super);
  function DragScroll2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this._startRect = null;
    _this._startPos = [];
    _this._prevTime = 0;
    _this._timer = 0;
    _this._prevScrollPos = [0, 0];
    _this._isWait = false;
    return _this;
  }
  var __proto = DragScroll2.prototype;
  __proto.dragStart = function(e, options) {
    var container = options.container;
    var top = 0;
    var left = 0;
    var width = 0;
    var height = 0;
    if (container === document.body) {
      width = window.innerWidth;
      height = window.innerHeight;
    } else {
      var rect = container.getBoundingClientRect();
      top = rect.top;
      left = rect.left;
      width = rect.width;
      height = rect.height;
    }
    this._startPos = [e.clientX, e.clientY];
    this._startRect = {
      top,
      left,
      width,
      height
    };
    this._prevScrollPos = this._getScrollPosition([0, 0], options);
  };
  __proto.drag = function(e, options) {
    var clientX = e.clientX, clientY = e.clientY;
    var _a3 = options.threshold, threshold2 = _a3 === void 0 ? 0 : _a3;
    var _b3 = this, _startRect = _b3._startRect, _startPos = _b3._startPos;
    var direction = [0, 0];
    if (_startRect.top > clientY - threshold2) {
      if (_startPos[1] > _startRect.top || clientY < _startPos[1]) {
        direction[1] = -1;
      }
    } else if (_startRect.top + _startRect.height < clientY + threshold2) {
      if (_startPos[1] < _startRect.top + _startRect.height || clientY > _startPos[1]) {
        direction[1] = 1;
      }
    }
    if (_startRect.left > clientX - threshold2) {
      if (_startPos[0] > _startRect.left || clientX < _startPos[0]) {
        direction[0] = -1;
      }
    } else if (_startRect.left + _startRect.width < clientX + threshold2) {
      if (_startPos[0] < _startRect.left + _startRect.width || clientX > _startPos[0]) {
        direction[0] = 1;
      }
    }
    clearTimeout(this._timer);
    if (!direction[0] && !direction[1]) {
      return false;
    }
    return this._continueDrag(__assign$5(__assign$5({}, options), {
      direction,
      inputEvent: e,
      isDrag: true
    }));
  };
  __proto.checkScroll = function(options) {
    var _this = this;
    if (this._isWait) {
      return false;
    }
    var _a3 = options.prevScrollPos, prevScrollPos = _a3 === void 0 ? this._prevScrollPos : _a3, direction = options.direction, _b3 = options.throttleTime, throttleTime = _b3 === void 0 ? 0 : _b3, inputEvent = options.inputEvent, isDrag = options.isDrag;
    var nextScrollPos = this._getScrollPosition(direction || [0, 0], options);
    var offsetX = nextScrollPos[0] - prevScrollPos[0];
    var offsetY = nextScrollPos[1] - prevScrollPos[1];
    var nextDirection = direction || [offsetX ? Math.abs(offsetX) / offsetX : 0, offsetY ? Math.abs(offsetY) / offsetY : 0];
    this._prevScrollPos = nextScrollPos;
    if (!offsetX && !offsetY) {
      return false;
    }
    this.trigger("move", {
      offsetX: nextDirection[0] ? offsetX : 0,
      offsetY: nextDirection[1] ? offsetY : 0,
      inputEvent
    });
    if (throttleTime && isDrag) {
      this._timer = window.setTimeout(function() {
        _this._continueDrag(options);
      }, throttleTime);
    }
    return true;
  };
  __proto.dragEnd = function() {
    clearTimeout(this._timer);
  };
  __proto._getScrollPosition = function(direction, options) {
    var container = options.container, _a3 = options.getScrollPosition, getScrollPosition = _a3 === void 0 ? getDefaultScrollPosition$1 : _a3;
    return getScrollPosition({
      container,
      direction
    });
  };
  __proto._continueDrag = function(options) {
    var _this = this;
    var container = options.container, direction = options.direction, throttleTime = options.throttleTime, useScroll = options.useScroll, isDrag = options.isDrag, inputEvent = options.inputEvent;
    if (isDrag && this._isWait) {
      return;
    }
    var nowTime = now();
    var distTime = Math.max(throttleTime + this._prevTime - nowTime, 0);
    if (distTime > 0) {
      this._timer = window.setTimeout(function() {
        _this._continueDrag(options);
      }, distTime);
      return false;
    }
    this._prevTime = nowTime;
    var prevScrollPos = this._getScrollPosition(direction, options);
    this._prevScrollPos = prevScrollPos;
    if (isDrag) {
      this._isWait = true;
    }
    this.trigger("scroll", {
      container,
      direction,
      inputEvent
    });
    this._isWait = false;
    return useScroll || this.checkScroll(__assign$5(__assign$5({}, options), {
      prevScrollPos,
      direction,
      inputEvent
    }));
  };
  return DragScroll2;
}(EventEmitter$2);
var DragScroll$1 = DragScroll;
/*! *****************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */
var extendStatics$3 = function(d2, b2) {
  extendStatics$3 = Object.setPrototypeOf || {
    __proto__: []
  } instanceof Array && function(d3, b3) {
    d3.__proto__ = b3;
  } || function(d3, b3) {
    for (var p2 in b3)
      if (b3.hasOwnProperty(p2))
        d3[p2] = b3[p2];
  };
  return extendStatics$3(d2, b2);
};
function __extends$3(d2, b2) {
  extendStatics$3(d2, b2);
  function __() {
    this.constructor = d2;
  }
  d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
}
var __assign$4 = function() {
  __assign$4 = Object.assign || function __assign2(t) {
    for (var s2, i2 = 1, n = arguments.length; i2 < n; i2++) {
      s2 = arguments[i2];
      for (var p2 in s2)
        if (Object.prototype.hasOwnProperty.call(s2, p2))
          t[p2] = s2[p2];
    }
    return t;
  };
  return __assign$4.apply(this, arguments);
};
function getRad(pos1, pos2) {
  var distX = pos2[0] - pos1[0];
  var distY = pos2[1] - pos1[1];
  var rad = Math.atan2(distY, distX);
  return rad >= 0 ? rad : rad + Math.PI * 2;
}
function getRotatiion(touches) {
  return getRad([touches[0].clientX, touches[0].clientY], [touches[1].clientX, touches[1].clientY]) / Math.PI * 180;
}
function isMultiTouch(e) {
  return e.touches && e.touches.length >= 2;
}
function getEventClients(e) {
  if (e.touches) {
    return getClients(e.touches);
  } else {
    return [getClient(e)];
  }
}
function getPosition(clients, prevClients, startClients) {
  var length2 = startClients.length;
  var _a3 = getAverageClient(clients, length2), clientX = _a3.clientX, clientY = _a3.clientY, originalClientX = _a3.originalClientX, originalClientY = _a3.originalClientY;
  var _b3 = getAverageClient(prevClients, length2), prevX = _b3.clientX, prevY = _b3.clientY;
  var _c3 = getAverageClient(startClients, length2), startX = _c3.clientX, startY = _c3.clientY;
  var deltaX = clientX - prevX;
  var deltaY = clientY - prevY;
  var distX = clientX - startX;
  var distY = clientY - startY;
  return {
    clientX: originalClientX,
    clientY: originalClientY,
    deltaX,
    deltaY,
    distX,
    distY
  };
}
function getDist$1(clients) {
  return Math.sqrt(Math.pow(clients[0].clientX - clients[1].clientX, 2) + Math.pow(clients[0].clientY - clients[1].clientY, 2));
}
function getClients(touches) {
  var length2 = Math.min(touches.length, 2);
  var clients = [];
  for (var i2 = 0; i2 < length2; ++i2) {
    clients.push(getClient(touches[i2]));
  }
  return clients;
}
function getClient(e) {
  return {
    clientX: e.clientX,
    clientY: e.clientY
  };
}
function getAverageClient(clients, length2) {
  if (length2 === void 0) {
    length2 = clients.length;
  }
  var sumClient = {
    clientX: 0,
    clientY: 0,
    originalClientX: 0,
    originalClientY: 0
  };
  for (var i2 = 0; i2 < length2; ++i2) {
    var client = clients[i2];
    sumClient.originalClientX += "originalClientX" in client ? client.originalClientX : client.clientX;
    sumClient.originalClientY += "originalClientY" in client ? client.originalClientY : client.clientY;
    sumClient.clientX += client.clientX;
    sumClient.clientY += client.clientY;
  }
  if (!length2) {
    return sumClient;
  }
  return {
    clientX: sumClient.clientX / length2,
    clientY: sumClient.clientY / length2,
    originalClientX: sumClient.originalClientX / length2,
    originalClientY: sumClient.originalClientY / length2
  };
}
var ClientStore = /* @__PURE__ */ function() {
  function ClientStore2(clients) {
    this.prevClients = [];
    this.startClients = [];
    this.movement = 0;
    this.length = 0;
    this.startClients = clients;
    this.prevClients = clients;
    this.length = clients.length;
  }
  var __proto = ClientStore2.prototype;
  __proto.getAngle = function(clients) {
    if (clients === void 0) {
      clients = this.prevClients;
    }
    return getRotatiion(clients);
  };
  __proto.getRotation = function(clients) {
    if (clients === void 0) {
      clients = this.prevClients;
    }
    return getRotatiion(clients) - getRotatiion(this.startClients);
  };
  __proto.getPosition = function(clients, isAdd) {
    if (clients === void 0) {
      clients = this.prevClients;
    }
    var position = getPosition(clients || this.prevClients, this.prevClients, this.startClients);
    var deltaX = position.deltaX, deltaY = position.deltaY;
    this.movement += Math.sqrt(deltaX * deltaX + deltaY * deltaY);
    this.prevClients = clients;
    return position;
  };
  __proto.getPositions = function(clients) {
    if (clients === void 0) {
      clients = this.prevClients;
    }
    var prevClients = this.prevClients;
    return this.startClients.map(function(startClient, i2) {
      return getPosition([clients[i2]], [prevClients[i2]], [startClient]);
    });
  };
  __proto.getMovement = function(clients) {
    var movement = this.movement;
    if (!clients) {
      return movement;
    }
    var currentClient = getAverageClient(clients, this.length);
    var prevClient = getAverageClient(this.prevClients, this.length);
    var deltaX = currentClient.clientX - prevClient.clientX;
    var deltaY = currentClient.clientY - prevClient.clientY;
    return Math.sqrt(deltaX * deltaX + deltaY * deltaY) + movement;
  };
  __proto.getDistance = function(clients) {
    if (clients === void 0) {
      clients = this.prevClients;
    }
    return getDist$1(clients);
  };
  __proto.getScale = function(clients) {
    if (clients === void 0) {
      clients = this.prevClients;
    }
    return getDist$1(clients) / getDist$1(this.startClients);
  };
  __proto.move = function(deltaX, deltaY) {
    this.startClients.forEach(function(client) {
      client.clientX -= deltaX;
      client.clientY -= deltaY;
    });
  };
  return ClientStore2;
}();
var INPUT_TAGNAMES = ["textarea", "input"];
var Gesto = /* @__PURE__ */ function(_super) {
  __extends$3(Gesto2, _super);
  function Gesto2(targets, options) {
    if (options === void 0) {
      options = {};
    }
    var _this = _super.call(this) || this;
    _this.options = {};
    _this.flag = false;
    _this.pinchFlag = false;
    _this.datas = {};
    _this.isDrag = false;
    _this.isPinch = false;
    _this.isMouse = false;
    _this.isTouch = false;
    _this.clientStores = [];
    _this.targets = [];
    _this.prevTime = 0;
    _this.doubleFlag = false;
    _this._dragFlag = false;
    _this.onDragStart = function(e, isTrusted) {
      if (isTrusted === void 0) {
        isTrusted = true;
      }
      if (!_this.flag && e.cancelable === false) {
        return;
      }
      var _a4 = _this.options, container2 = _a4.container, pinchOutside = _a4.pinchOutside, preventRightClick = _a4.preventRightClick, preventDefault = _a4.preventDefault, checkInput = _a4.checkInput;
      var isTouch = _this.isTouch;
      var isDragStart = !_this.flag;
      if (isDragStart) {
        var activeElement = document.activeElement;
        var target = e.target;
        var tagName = target.tagName.toLowerCase();
        var hasInput = INPUT_TAGNAMES.indexOf(tagName) > -1;
        var hasContentEditable = target.isContentEditable;
        if (hasInput || hasContentEditable) {
          if (checkInput || activeElement === target) {
            return false;
          }
          if (activeElement && hasContentEditable && activeElement.isContentEditable && activeElement.contains(target)) {
            return false;
          }
        } else if ((preventDefault || e.type === "touchstart") && activeElement) {
          var activeTagName = activeElement.tagName;
          if (activeElement.isContentEditable || INPUT_TAGNAMES.indexOf(activeTagName) > -1) {
            activeElement.blur();
          }
        }
        _this.clientStores = [new ClientStore(getEventClients(e))];
        _this.flag = true;
        _this.isDrag = false;
        _this._dragFlag = true;
        _this.datas = {};
        if (preventRightClick && (e.which === 3 || e.button === 2)) {
          _this.initDrag();
          return false;
        }
        _this.doubleFlag = now() - _this.prevTime < 200;
        var result = _this.emit("dragStart", __assign$4({
          datas: _this.datas,
          inputEvent: e,
          isTrusted,
          isDouble: _this.doubleFlag
        }, _this.getCurrentStore().getPosition(), {
          preventDefault: function() {
            e.preventDefault();
          },
          preventDrag: function() {
            _this._dragFlag = false;
          }
        }));
        if (result === false) {
          _this.initDrag();
        }
        _this.flag && preventDefault && e.preventDefault();
      }
      if (!_this.flag) {
        return false;
      }
      var timer = 0;
      if (isDragStart && isTouch && pinchOutside) {
        timer = setTimeout(function() {
          addEvent(container2, "touchstart", _this.onDragStart, {
            passive: false
          });
        });
      }
      if (!isDragStart && isTouch && pinchOutside) {
        removeEvent(container2, "touchstart", _this.onDragStart);
      }
      if (_this.flag && isMultiTouch(e)) {
        clearTimeout(timer);
        if (isDragStart && e.touches.length !== e.changedTouches.length) {
          return;
        }
        if (!_this.pinchFlag) {
          _this.onPinchStart(e);
        }
      }
    };
    _this.onDrag = function(e, isScroll) {
      if (!_this.flag) {
        return;
      }
      var clients = getEventClients(e);
      var result = _this.moveClients(clients, e, false);
      if (_this._dragFlag) {
        if (_this.pinchFlag || result.deltaX || result.deltaY) {
          var dragResult = _this.emit("drag", __assign$4({}, result, {
            isScroll: !!isScroll,
            inputEvent: e
          }));
          if (dragResult === false) {
            _this.stop();
            return;
          }
        }
        if (_this.pinchFlag) {
          _this.onPinch(e, clients);
        }
      }
      _this.getCurrentStore().getPosition(clients, true);
    };
    _this.onDragEnd = function(e) {
      if (!_this.flag) {
        return;
      }
      var _a4 = _this.options, pinchOutside = _a4.pinchOutside, container2 = _a4.container;
      if (_this.isTouch && pinchOutside) {
        removeEvent(container2, "touchstart", _this.onDragStart);
      }
      _this.flag = false;
      var position = _this._getPosition();
      var currentTime = now();
      var isDouble = !_this.isDrag && _this.doubleFlag;
      _this.prevTime = _this.isDrag || isDouble ? 0 : currentTime;
      _this.emit("dragEnd", __assign$4({
        datas: _this.datas,
        isDouble,
        isDrag: _this.isDrag,
        isClick: !_this.isDrag,
        inputEvent: e
      }, position));
      if (_this.pinchFlag) {
        _this.onPinchEnd(e);
      }
      _this.clientStores = [];
    };
    _this.onBlur = function() {
      _this.onDragEnd();
    };
    var elements = [].concat(targets);
    _this.options = __assign$4({
      checkInput: false,
      container: elements.length > 1 ? window : elements[0],
      preventRightClick: true,
      preventDefault: true,
      checkWindowBlur: false,
      pinchThreshold: 0,
      events: ["touch", "mouse"]
    }, options);
    var _a3 = _this.options, container = _a3.container, events = _a3.events, checkWindowBlur = _a3.checkWindowBlur;
    _this.isTouch = events.indexOf("touch") > -1;
    _this.isMouse = events.indexOf("mouse") > -1;
    _this.targets = elements;
    if (_this.isMouse) {
      elements.forEach(function(el) {
        addEvent(el, "mousedown", _this.onDragStart);
      });
      addEvent(container, "mousemove", _this.onDrag);
      addEvent(container, "mouseup", _this.onDragEnd);
      addEvent(container, "contextmenu", _this.onDragEnd);
    }
    if (checkWindowBlur) {
      addEvent(window, "blur", _this.onBlur);
    }
    if (_this.isTouch) {
      var passive_1 = {
        passive: false
      };
      elements.forEach(function(el) {
        addEvent(el, "touchstart", _this.onDragStart, passive_1);
      });
      addEvent(container, "touchmove", _this.onDrag, passive_1);
      addEvent(container, "touchend", _this.onDragEnd, passive_1);
      addEvent(container, "touchcancel", _this.onDragEnd, passive_1);
    }
    return _this;
  }
  var __proto = Gesto2.prototype;
  __proto.stop = function() {
    this.isDrag = false;
    this.flag = false;
    this.clientStores = [];
    this.datas = {};
  };
  __proto.getMovement = function(clients) {
    return this.getCurrentStore().getMovement(clients) + this.clientStores.slice(1).reduce(function(prev2, cur) {
      return prev2 + cur.movement;
    }, 0);
  };
  __proto.isDragging = function() {
    return this.isDrag;
  };
  __proto.isFlag = function() {
    return this.flag;
  };
  __proto.isPinchFlag = function() {
    return this.pinchFlag;
  };
  __proto.isDoubleFlag = function() {
    return this.doubleFlag;
  };
  __proto.isPinching = function() {
    return this.isPinch;
  };
  __proto.scrollBy = function(deltaX, deltaY, e, isCallDrag) {
    if (isCallDrag === void 0) {
      isCallDrag = true;
    }
    if (!this.flag) {
      return;
    }
    this.clientStores[0].move(deltaX, deltaY);
    isCallDrag && this.onDrag(e, true);
  };
  __proto.move = function(_a3, inputEvent) {
    var deltaX = _a3[0], deltaY = _a3[1];
    var store = this.getCurrentStore();
    var nextClients = store.prevClients;
    return this.moveClients(nextClients.map(function(_a4) {
      var clientX = _a4.clientX, clientY = _a4.clientY;
      return {
        clientX: clientX + deltaX,
        clientY: clientY + deltaY,
        originalClientX: clientX,
        originalClientY: clientY
      };
    }), inputEvent, true);
  };
  __proto.triggerDragStart = function(e) {
    this.onDragStart(e, false);
  };
  __proto.setEventDatas = function(datas) {
    var currentDatas = this.datas;
    for (var name2 in datas) {
      currentDatas[name2] = datas[name2];
    }
    return this;
  };
  __proto.getCurrentEvent = function(inputEvent) {
    return __assign$4({
      datas: this.datas
    }, this._getPosition(), {
      movement: this.getMovement(),
      isDrag: this.isDrag,
      isPinch: this.isPinch,
      isScroll: false,
      inputEvent
    });
  };
  __proto.getEventDatas = function() {
    return this.datas;
  };
  __proto.unset = function() {
    var _this = this;
    var targets = this.targets;
    var container = this.options.container;
    this.off();
    removeEvent(window, "blur", this.onBlur);
    if (this.isMouse) {
      targets.forEach(function(target) {
        removeEvent(target, "mousedown", _this.onDragStart);
      });
      removeEvent(container, "mousemove", this.onDrag);
      removeEvent(container, "mouseup", this.onDragEnd);
      removeEvent(container, "contextmenu", this.onDragEnd);
    }
    if (this.isTouch) {
      targets.forEach(function(target) {
        removeEvent(target, "touchstart", _this.onDragStart);
      });
      removeEvent(container, "touchstart", this.onDragStart);
      removeEvent(container, "touchmove", this.onDrag);
      removeEvent(container, "touchend", this.onDragEnd);
      removeEvent(container, "touchcancel", this.onDragEnd);
    }
  };
  __proto.onPinchStart = function(e) {
    var pinchThreshold = this.options.pinchThreshold;
    if (this.isDrag && this.getMovement() > pinchThreshold) {
      return;
    }
    var store = new ClientStore(getEventClients(e));
    this.pinchFlag = true;
    this.clientStores.splice(0, 0, store);
    var result = this.emit("pinchStart", __assign$4({
      datas: this.datas,
      angle: store.getAngle(),
      touches: this.getCurrentStore().getPositions()
    }, store.getPosition(), {
      inputEvent: e
    }));
    if (result === false) {
      this.pinchFlag = false;
    }
  };
  __proto.onPinch = function(e, clients) {
    if (!this.flag || !this.pinchFlag || clients.length < 2) {
      return;
    }
    var store = this.getCurrentStore();
    this.isPinch = true;
    this.emit("pinch", __assign$4({
      datas: this.datas,
      movement: this.getMovement(clients),
      angle: store.getAngle(clients),
      rotation: store.getRotation(clients),
      touches: store.getPositions(clients),
      scale: store.getScale(clients),
      distance: store.getDistance(clients)
    }, store.getPosition(clients), {
      inputEvent: e
    }));
  };
  __proto.onPinchEnd = function(e) {
    if (!this.pinchFlag) {
      return;
    }
    var isPinch = this.isPinch;
    this.isPinch = false;
    this.pinchFlag = false;
    var store = this.getCurrentStore();
    this.emit("pinchEnd", __assign$4({
      datas: this.datas,
      isPinch,
      touches: store.getPositions()
    }, store.getPosition(), {
      inputEvent: e
    }));
    this.isPinch = false;
    this.pinchFlag = false;
  };
  __proto.initDrag = function() {
    this.clientStores = [];
    this.pinchFlag = false;
    this.doubleFlag = false;
    this.prevTime = 0;
    this.flag = false;
  };
  __proto.getCurrentStore = function() {
    return this.clientStores[0];
  };
  __proto.moveClients = function(clients, inputEvent, isAdd) {
    var position = this._getPosition(clients, isAdd);
    if (position.deltaX || position.deltaY) {
      this.isDrag = true;
    }
    return __assign$4({
      datas: this.datas
    }, position, {
      movement: this.getMovement(clients),
      isDrag: this.isDrag,
      isPinch: this.isPinch,
      isScroll: false,
      inputEvent
    });
  };
  __proto._getPosition = function(clients, isAdd) {
    var store = this.getCurrentStore();
    var position = store.getPosition(clients, isAdd);
    var _a3 = this.clientStores.slice(1).reduce(function(prev2, cur) {
      var storePosition = cur.getPosition();
      prev2.distX += storePosition.distX;
      prev2.distY += storePosition.distY;
      return prev2;
    }, position), distX = _a3.distX, distY = _a3.distY;
    return __assign$4({}, position, {
      distX,
      distY
    });
  };
  return Gesto2;
}(EventEmitter$2);
var Gesto$1 = Gesto;
function hash(str2) {
  var hash2 = 5381, i2 = str2.length;
  while (i2) {
    hash2 = hash2 * 33 ^ str2.charCodeAt(--i2);
  }
  return hash2 >>> 0;
}
var stringHash = hash;
function getHash(str2) {
  return stringHash(str2).toString(36);
}
function getShadowRoot(parentElement) {
  if (parentElement && parentElement.getRootNode) {
    var rootNode = parentElement.getRootNode();
    if (rootNode.nodeType === 11) {
      return rootNode;
    }
  }
  return;
}
function replaceStyle(className, css, options) {
  if (options.original) {
    return css;
  }
  return css.replace(/([^};{\s}][^};{]*|^\s*){/mg, function(_2, selector) {
    var trimmedSelector = selector.trim();
    return (trimmedSelector ? splitComma(trimmedSelector) : [""]).map(function(subSelector) {
      var trimmedSubSelector = subSelector.trim();
      if (trimmedSubSelector.indexOf("@") === 0) {
        return trimmedSubSelector;
      } else if (trimmedSubSelector.indexOf(":global") > -1) {
        return trimmedSubSelector.replace(/\:global/g, "");
      } else if (trimmedSubSelector.indexOf(":host") > -1) {
        return "" + trimmedSubSelector.replace(/\:host/g, "." + className);
      } else if (trimmedSubSelector) {
        return "." + className + " " + trimmedSubSelector;
      } else {
        return "." + className;
      }
    }).join(", ") + " {";
  });
}
function injectStyle(className, css, options, shadowRoot) {
  var style = document.createElement("style");
  style.setAttribute("type", "text/css");
  style.setAttribute("data-styled-id", className);
  if (options.nonce) {
    style.setAttribute("nonce", options.nonce);
  }
  style.innerHTML = replaceStyle(className, css, options);
  (shadowRoot || document.head || document.body).appendChild(style);
  return style;
}
function styled$1(css) {
  var injectClassName = "rCS" + getHash(css);
  var injectCount = 0;
  var injectElement;
  return {
    className: injectClassName,
    inject: function(el, options) {
      if (options === void 0) {
        options = {};
      }
      var shadowRoot = getShadowRoot(el);
      var firstMount = injectCount === 0;
      var styleElement;
      if (shadowRoot || firstMount) {
        styleElement = injectStyle(injectClassName, css, options, shadowRoot);
      }
      if (firstMount) {
        injectElement = styleElement;
      }
      if (!shadowRoot) {
        ++injectCount;
      }
      return {
        destroy: function() {
          if (shadowRoot) {
            el.removeChild(styleElement);
            styleElement = null;
          } else {
            if (injectCount > 0) {
              --injectCount;
            }
            if (injectCount === 0 && injectElement) {
              injectElement.parentNode.removeChild(injectElement);
              injectElement = null;
            }
          }
        }
      };
    }
  };
}
/*! *****************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */
var extendStatics$2 = function(d2, b2) {
  extendStatics$2 = Object.setPrototypeOf || {
    __proto__: []
  } instanceof Array && function(d3, b3) {
    d3.__proto__ = b3;
  } || function(d3, b3) {
    for (var p2 in b3)
      if (b3.hasOwnProperty(p2))
        d3[p2] = b3[p2];
  };
  return extendStatics$2(d2, b2);
};
function __extends$2(d2, b2) {
  extendStatics$2(d2, b2);
  function __() {
    this.constructor = d2;
  }
  d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
}
var __assign$3 = function() {
  __assign$3 = Object.assign || function __assign2(t) {
    for (var s2, i2 = 1, n = arguments.length; i2 < n; i2++) {
      s2 = arguments[i2];
      for (var p2 in s2)
        if (Object.prototype.hasOwnProperty.call(s2, p2))
          t[p2] = s2[p2];
    }
    return t;
  };
  return __assign$3.apply(this, arguments);
};
function __rest$1(s2, e) {
  var t = {};
  for (var p2 in s2)
    if (Object.prototype.hasOwnProperty.call(s2, p2) && e.indexOf(p2) < 0)
      t[p2] = s2[p2];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s2); i2 < p2.length; i2++) {
      if (e.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i2]))
        t[p2[i2]] = s2[p2[i2]];
    }
  return t;
}
var StyledElement = /* @__PURE__ */ function(_super) {
  __extends$2(StyledElement2, _super);
  function StyledElement2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.injectResult = null;
    _this.tag = "div";
    return _this;
  }
  var __proto = StyledElement2.prototype;
  __proto.render = function() {
    var _a3 = this.props, _b3 = _a3.className, className = _b3 === void 0 ? "" : _b3;
    _a3.cspNonce;
    var portalContainer = _a3.portalContainer, attributes = __rest$1(_a3, ["className", "cspNonce", "portalContainer"]);
    var cssId = this.injector.className;
    var Tag = this.tag;
    var portalAttributes = {};
    if (version.indexOf("simple") > -1 && portalContainer) {
      portalAttributes = {
        portalContainer
      };
    }
    return createElement(Tag, __assign$3({
      "ref": ref(this, "element"),
      "data-styled-id": cssId,
      "className": className + " " + cssId
    }, portalAttributes, attributes));
  };
  __proto.componentDidMount = function() {
    this.injectResult = this.injector.inject(this.element, {
      nonce: this.props.cspNonce
    });
  };
  __proto.componentWillUnmount = function() {
    this.injectResult.destroy();
    this.injectResult = null;
  };
  __proto.getElement = function() {
    return this.element;
  };
  return StyledElement2;
}(Component);
function styled(tag, css) {
  var injector = styled$1(css);
  return /* @__PURE__ */ function(_super) {
    __extends$2(Styled, _super);
    function Styled() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.injector = injector;
      _this.tag = tag;
      return _this;
    }
    return Styled;
  }(StyledElement);
}
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var extendStatics$1 = function(d2, b2) {
  extendStatics$1 = Object.setPrototypeOf || {
    __proto__: []
  } instanceof Array && function(d3, b3) {
    d3.__proto__ = b3;
  } || function(d3, b3) {
    for (var p2 in b3)
      if (Object.prototype.hasOwnProperty.call(b3, p2))
        d3[p2] = b3[p2];
  };
  return extendStatics$1(d2, b2);
};
function __extends$1(d2, b2) {
  if (typeof b2 !== "function" && b2 !== null)
    throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
  extendStatics$1(d2, b2);
  function __() {
    this.constructor = d2;
  }
  d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
}
var __assign$2 = function() {
  __assign$2 = Object.assign || function __assign2(t) {
    for (var s2, i2 = 1, n = arguments.length; i2 < n; i2++) {
      s2 = arguments[i2];
      for (var p2 in s2)
        if (Object.prototype.hasOwnProperty.call(s2, p2))
          t[p2] = s2[p2];
    }
    return t;
  };
  return __assign$2.apply(this, arguments);
};
function __rest(s2, e) {
  var t = {};
  for (var p2 in s2)
    if (Object.prototype.hasOwnProperty.call(s2, p2) && e.indexOf(p2) < 0)
      t[p2] = s2[p2];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s2); i2 < p2.length; i2++) {
      if (e.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i2]))
        t[p2[i2]] = s2[p2[i2]];
    }
  return t;
}
function __decorate$1(decorators, target, key, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d2;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r2 = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i2 = decorators.length - 1; i2 >= 0; i2--)
      if (d2 = decorators[i2])
        r2 = (c2 < 3 ? d2(r2) : c2 > 3 ? d2(target, key, r2) : d2(target, key)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key, r2), r2;
}
function __spreadArray(to, from, pack) {
  if (pack || arguments.length === 2)
    for (var i2 = 0, l2 = from.length, ar; i2 < l2; i2++) {
      if (ar || !(i2 in from)) {
        if (!ar)
          ar = Array.prototype.slice.call(from, 0, i2);
        ar[i2] = from[i2];
      }
    }
  return to.concat(ar || Array.prototype.slice.call(from));
}
function makeAble(name2, able) {
  var _a3;
  return __assign$2({
    events: {},
    props: (_a3 = {}, _a3[name2] = Boolean, _a3),
    name: name2
  }, able);
}
function getSVGCursor(scale, degree) {
  return 'data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="' + 32 * scale + 'px" height="' + 32 * scale + 'px" viewBox="0 0 32 32" ><path d="M 16,5 L 12,10 L 14.5,10 L 14.5,22 L 12,22 L 16,27 L 20,22 L 17.5,22 L 17.5,10 L 20, 10 L 16,5 Z" stroke-linejoin="round" stroke-width="1.2" fill="black" stroke="white" style="transform:rotate(' + degree + 'deg);transform-origin: 16px 16px"></path></svg>';
}
function getCursorCSS(degree) {
  var x1 = getSVGCursor(1, degree);
  var degree45 = Math.round(degree / 45) * 45 % 180;
  var defaultCursor = "ns-resize";
  if (degree45 === 135) {
    defaultCursor = "nwse-resize";
  } else if (degree45 === 45) {
    defaultCursor = "nesw-resize";
  } else if (degree45 === 90) {
    defaultCursor = "ew-resize";
  }
  return "cursor:" + defaultCursor + ";cursor: url('" + x1 + "') 16 16, " + defaultCursor + ";";
}
var agent = agent$1();
var IS_WEBKIT = agent.browser.webkit;
var IS_WEBKIT605 = IS_WEBKIT && function() {
  var navi = typeof window === "undefined" ? {
    userAgent: ""
  } : window.navigator;
  var res = /applewebkit\/([^\s]+)/g.exec(navi.userAgent.toLowerCase());
  return res ? parseFloat(res[1]) < 605 : false;
}();
var PREFIX = "moveable-";
var MOVEABLE_CSS = "\n{\n	position: absolute;\n	width: 1px;\n	height: 1px;\n	left: 0;\n	top: 0;\n    z-index: 3000;\n    --moveable-color: #4af;\n    --zoom: 1;\n    --zoompx: 1px;\n    will-change: transform;\n}\n.control-box {\n    z-index: 0;\n}\n.line, .control {\n    position: absolute;\n	left: 0;\n    top: 0;\n    will-change: transform;\n}\n.control {\n	width: 14px;\n	height: 14px;\n	border-radius: 50%;\n	border: 2px solid #fff;\n	box-sizing: border-box;\n    background: #4af;\n    background: var(--moveable-color);\n	margin-top: -7px;\n    margin-left: -7px;\n    border: 2px solid #fff;\n    z-index: 10;\n}\n.padding {\n    position: absolute;\n    top: 0px;\n    left: 0px;\n    width: 100px;\n    height: 100px;\n    transform-origin: 0 0;\n}\n.line {\n	width: 1px;\n    height: 1px;\n    background: #4af;\n    background: var(--moveable-color);\n	transform-origin: 0px 50%;\n}\n.line.dashed {\n    box-sizing: border-box;\n    background: transparent;\n}\n.line.dashed.horizontal {\n    border-top: 1px dashed #4af;\n    border-top-color: #4af;\n    border-top-color: var(--moveable-color);\n}\n.line.dashed.vertical {\n    border-left: 1px dashed #4af;\n    border-left-color: #4af;\n    border-left-color: var(--moveable-color);\n}\n.line.vertical {\n    transform: translateX(-50%);\n}\n.line.horizontal {\n    transform: translateY(-50%);\n}\n.line.vertical.bold {\n    width: 2px;\n}\n.line.horizontal.bold {\n    height: 2px;\n}\n\n.control.origin {\n	border-color: #f55;\n	background: #fff;\n	width: 12px;\n	height: 12px;\n	margin-top: -6px;\n    margin-left: -6px;\n	pointer-events: none;\n}\n" + [0, 15, 30, 45, 60, 75, 90, 105, 120, 135, 150, 165].map(function(degree) {
  return '\n.direction[data-rotation="' + degree + '"] {\n	' + getCursorCSS(degree) + "\n}\n";
}).join("\n") + "\n.group {\n    z-index: -1;\n}\n.area {\n    position: absolute;\n}\n.area-pieces {\n    position: absolute;\n    top: 0;\n    left: 0;\n    display: none;\n}\n.area.avoid, .area.pass {\n    pointer-events: none;\n}\n.area.avoid+.area-pieces {\n    display: block;\n}\n.area-piece {\n    position: absolute;\n}\n\n" + (IS_WEBKIT605 ? ':global svg *:before {\n	content:"";\n	transform-origin: inherit;\n}' : "") + "\n";
var NEARBY_POS = [[0, 1, 2], [1, 0, 3], [2, 0, 3], [3, 1, 2]];
var FLOAT_POINT_NUM = 1e-4;
var TINY_NUM = 1e-7;
var MIN_SCALE = 1e-9;
var MAX_NUM = Math.pow(10, 10);
var MIN_NUM = -MAX_NUM;
var DIRECTIONS = ["n", "w", "s", "e", "nw", "ne", "sw", "se"];
var DIRECTION_INDEXES = {
  n: [0, 1],
  s: [2, 3],
  w: [2, 0],
  e: [1, 3],
  nw: [0],
  ne: [1],
  sw: [2],
  se: [3]
};
var DIRECTION_ROTATIONS = {
  n: 0,
  s: 180,
  w: 270,
  e: 90,
  nw: 315,
  ne: 45,
  sw: 225,
  se: 135
};
var MOVEABLE_METHODS = ["isMoveableElement", "updateRect", "updateTarget", "destroy", "dragStart", "isInside", "hitTest", "setState", "getRect", "request", "isDragging", "getManager", "forceUpdate"];
function multiply2(pos1, pos2) {
  return [pos1[0] * pos2[0], pos1[1] * pos2[1]];
}
function prefix() {
  var classNames = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    classNames[_i] = arguments[_i];
  }
  return prefixNames.apply(void 0, __spreadArray([PREFIX], classNames));
}
function getTransformMatrix(transform) {
  if (!transform || transform === "none") {
    return [1, 0, 0, 1, 0, 0];
  }
  if (isObject$2(transform)) {
    return transform;
  }
  var value = splitBracket(transform).value;
  return value.split(/s*,\s*/g).map(function(v2) {
    return parseFloat(v2);
  });
}
function getAbsoluteMatrix(matrix, n, origin) {
  return multiplies(n, createOriginMatrix(origin, n), matrix, createOriginMatrix(origin.map(function(a2) {
    return -a2;
  }), n));
}
function measureSVGSize(el, unit, isHorizontal) {
  if (unit === "%") {
    var viewBox = getSVGViewBox(el.ownerSVGElement);
    return viewBox[isHorizontal ? "width" : "height"] / 100;
  }
  return 1;
}
function getBeforeTransformOrigin(el) {
  var relativeOrigin = getTransformOrigin(getComputedStyle$1(el, ":before"));
  return relativeOrigin.map(function(o, i2) {
    var _a3 = splitUnit(o), value = _a3.value, unit = _a3.unit;
    return value * measureSVGSize(el, unit, i2 === 0);
  });
}
function getTransformOrigin(style) {
  var transformOrigin = style.transformOrigin;
  return transformOrigin ? transformOrigin.split(" ") : ["0", "0"];
}
function getOffsetInfo(el, lastParent, isParent) {
  var body = document.body;
  var target = !el || isParent ? el : el.parentElement;
  var isEnd = el === lastParent || target === lastParent;
  var position = "relative";
  while (target && target !== body) {
    if (lastParent === target) {
      isEnd = true;
    }
    var style = getComputedStyle$1(target);
    var transform = style.transform;
    position = style.position;
    if (target.tagName.toLowerCase() === "svg" || position !== "static" || transform && transform !== "none") {
      break;
    }
    target = target.parentElement;
    position = "relative";
  }
  return {
    isStatic: position === "static",
    isEnd: isEnd || !target || target === body,
    offsetParent: target || body
  };
}
function getOffsetPosInfo(el, container, style, isFixed) {
  var _a3;
  var tagName = el.tagName.toLowerCase();
  var offsetLeft = el.offsetLeft;
  var offsetTop = el.offsetTop;
  if (isFixed) {
    var containerClientRect = (container || document.documentElement).getBoundingClientRect();
    offsetLeft -= containerClientRect.left;
    offsetTop -= containerClientRect.top;
  }
  var isSVG = isUndefined(offsetLeft);
  var hasOffset = !isSVG;
  var origin;
  var targetOrigin;
  if (!hasOffset && tagName !== "svg") {
    origin = IS_WEBKIT605 ? getBeforeTransformOrigin(el) : getTransformOrigin(style).map(function(pos) {
      return parseFloat(pos);
    });
    targetOrigin = origin.slice();
    hasOffset = true;
    _a3 = getSVGGraphicsOffset(el, origin), offsetLeft = _a3[0], offsetTop = _a3[1], origin[0] = _a3[2], origin[1] = _a3[3];
  } else {
    origin = getTransformOrigin(style).map(function(pos) {
      return parseFloat(pos);
    });
    targetOrigin = origin.slice();
  }
  return {
    tagName,
    isSVG,
    hasOffset,
    offset: [offsetLeft || 0, offsetTop || 0],
    origin,
    targetOrigin
  };
}
function getBodyOffset(el, isSVG, style) {
  if (style === void 0) {
    style = getComputedStyle$1(el);
  }
  var bodyStyle = getComputedStyle$1(document.body);
  var bodyPosition = bodyStyle.position;
  if (!isSVG && (!bodyPosition || bodyPosition === "static")) {
    return [0, 0];
  }
  var marginLeft = parseInt(bodyStyle.marginLeft, 10);
  var marginTop = parseInt(bodyStyle.marginTop, 10);
  if (style.position === "absolute") {
    if (style.top !== "auto" || style.bottom !== "auto") {
      marginTop = 0;
    }
    if (style.left !== "auto" || style.right !== "auto") {
      marginLeft = 0;
    }
  }
  return [marginLeft, marginTop];
}
function convert3DMatrixes(matrixes) {
  matrixes.forEach(function(info) {
    var matrix = info.matrix;
    if (matrix) {
      info.matrix = convertDimension(matrix, 3, 4);
    }
  });
}
function getMatrixStackInfo(target, container, checkContainer) {
  var el = target;
  var matrixes = [];
  var requestEnd = !checkContainer && target === container;
  var isEnd = requestEnd;
  var is3d = false;
  var n = 3;
  var transformOrigin;
  var targetTransformOrigin;
  var targetMatrix;
  var offsetContainer = getOffsetInfo(container, container, true).offsetParent;
  while (el && !isEnd) {
    isEnd = requestEnd;
    var style = getComputedStyle$1(el);
    var position = style.position;
    var isFixed = position === "fixed";
    var matrix = convertCSStoMatrix(getTransformMatrix(style.transform));
    var length2 = matrix.length;
    if (!is3d && length2 === 16) {
      is3d = true;
      n = 4;
      convert3DMatrixes(matrixes);
      if (targetMatrix) {
        targetMatrix = convertDimension(targetMatrix, 3, 4);
      }
    }
    if (is3d && length2 === 9) {
      matrix = convertDimension(matrix, 3, 4);
    }
    var _a3 = getOffsetPosInfo(el, container, style, isFixed), tagName = _a3.tagName, hasOffset = _a3.hasOffset, isSVG = _a3.isSVG, origin = _a3.origin, targetOrigin = _a3.targetOrigin, offsetPos = _a3.offset;
    var offsetLeft = offsetPos[0], offsetTop = offsetPos[1];
    if (tagName === "svg" && targetMatrix) {
      matrixes.push({
        type: "target",
        target: el,
        matrix: getSVGMatrix(el, n)
      });
      matrixes.push({
        type: "offset",
        target: el,
        matrix: createIdentityMatrix(n)
      });
    } else if (tagName === "g" && target !== el) {
      offsetLeft = 0;
      offsetTop = 0;
    }
    var _b3 = getOffsetInfo(el, container), offsetParent = _b3.offsetParent, isOffsetEnd = _b3.isEnd, isStatic = _b3.isStatic;
    if (IS_WEBKIT && hasOffset && !isSVG && isStatic && (position === "relative" || position === "static")) {
      offsetLeft -= offsetParent.offsetLeft;
      offsetTop -= offsetParent.offsetTop;
      requestEnd = requestEnd || isOffsetEnd;
    }
    var parentClientLeft = 0;
    var parentClientTop = 0;
    if (hasOffset && offsetContainer !== offsetParent) {
      parentClientLeft = offsetParent.clientLeft;
      parentClientTop = offsetParent.clientTop;
    }
    if (hasOffset && offsetParent === document.body) {
      var margin = getBodyOffset(el, false, style);
      offsetLeft += margin[0];
      offsetTop += margin[1];
    }
    matrixes.push({
      type: "target",
      target: el,
      matrix: getAbsoluteMatrix(matrix, n, origin)
    });
    if (hasOffset) {
      matrixes.push({
        type: "offset",
        target: el,
        matrix: createOriginMatrix([offsetLeft - el.scrollLeft + parentClientLeft, offsetTop - el.scrollTop + parentClientTop], n)
      });
    } else {
      matrixes.push({
        type: "offset",
        target: el,
        origin
      });
    }
    if (!targetMatrix) {
      targetMatrix = matrix;
    }
    if (!transformOrigin) {
      transformOrigin = origin;
    }
    if (!targetTransformOrigin) {
      targetTransformOrigin = targetOrigin;
    }
    if (isEnd || isFixed) {
      break;
    } else {
      el = offsetParent;
      requestEnd = isOffsetEnd;
    }
    if (!checkContainer || el === document.body) {
      isEnd = requestEnd;
    }
  }
  if (!targetMatrix) {
    targetMatrix = createIdentityMatrix(n);
  }
  if (!transformOrigin) {
    transformOrigin = [0, 0];
  }
  if (!targetTransformOrigin) {
    targetTransformOrigin = [0, 0];
  }
  return {
    offsetContainer,
    matrixes,
    targetMatrix,
    transformOrigin,
    targetOrigin: targetTransformOrigin,
    is3d
  };
}
function calculateElementInfo(target, container, rootContainer, isAbsolute3d) {
  var _a3;
  if (rootContainer === void 0) {
    rootContainer = container;
  }
  var width = 0;
  var height = 0;
  var rotation = 0;
  var allResult = {};
  if (target) {
    var style = getComputedStyle$1(target);
    width = target.offsetWidth;
    height = target.offsetHeight;
    if (isUndefined(width)) {
      _a3 = getSize(target, style, true), width = _a3[0], height = _a3[1];
    }
  }
  if (target) {
    var result = calculateMatrixStack(target, container, rootContainer, isAbsolute3d);
    var position = calculateMoveablePosition(result.allMatrix, result.transformOrigin, width, height);
    allResult = __assign$2(__assign$2({}, result), position);
    var rotationPosition = calculateMoveablePosition(result.allMatrix, [50, 50], 100, 100);
    rotation = getRotationRad([rotationPosition.pos1, rotationPosition.pos2], rotationPosition.direction);
  }
  var n = isAbsolute3d ? 4 : 3;
  return __assign$2({
    width,
    height,
    rotation,
    rootMatrix: createIdentityMatrix(n),
    beforeMatrix: createIdentityMatrix(n),
    offsetMatrix: createIdentityMatrix(n),
    allMatrix: createIdentityMatrix(n),
    targetMatrix: createIdentityMatrix(n),
    targetTransform: "",
    transformOrigin: [0, 0],
    targetOrigin: [0, 0],
    is3d: !!isAbsolute3d,
    left: 0,
    top: 0,
    right: 0,
    bottom: 0,
    origin: [0, 0],
    pos1: [0, 0],
    pos2: [0, 0],
    pos3: [0, 0],
    pos4: [0, 0],
    direction: 1
  }, allResult);
}
function calculateMatrixStack(target, container, rootContainer, isAbsolute3d) {
  var _a3;
  if (rootContainer === void 0) {
    rootContainer = container;
  }
  var _b3 = getMatrixStackInfo(target, container), matrixes = _b3.matrixes, is3d = _b3.is3d, prevTargetMatrix = _b3.targetMatrix, transformOrigin = _b3.transformOrigin, targetOrigin = _b3.targetOrigin, offsetContainer = _b3.offsetContainer;
  var _c3 = getMatrixStackInfo(offsetContainer, rootContainer, true), rootMatrixes = _c3.matrixes, isRoot3d = _c3.is3d;
  var isNext3d = isAbsolute3d || isRoot3d || is3d;
  var n = isNext3d ? 4 : 3;
  var isSVGGraphicElement = target.tagName.toLowerCase() !== "svg" && "ownerSVGElement" in target;
  var targetMatrix = prevTargetMatrix;
  var allMatrix = createIdentityMatrix(n);
  var rootMatrix = createIdentityMatrix(n);
  var beforeMatrix = createIdentityMatrix(n);
  var offsetMatrix = createIdentityMatrix(n);
  var length2 = matrixes.length;
  rootMatrixes.reverse();
  matrixes.reverse();
  if (!is3d && isNext3d) {
    targetMatrix = convertDimension(targetMatrix, 3, 4);
    convert3DMatrixes(matrixes);
  }
  if (!isRoot3d && isNext3d) {
    convert3DMatrixes(rootMatrixes);
  }
  rootMatrixes.forEach(function(info) {
    rootMatrix = multiply(rootMatrix, info.matrix, n);
  });
  var originalRootContainer = rootContainer || document.body;
  var endContainer = ((_a3 = rootMatrixes[0]) === null || _a3 === void 0 ? void 0 : _a3.target) || getOffsetInfo(originalRootContainer, originalRootContainer, true).offsetParent;
  var rootMatrixBeforeOffset = rootMatrixes.slice(1).reduce(function(matrix, info) {
    return multiply(matrix, info.matrix, n);
  }, createIdentityMatrix(n));
  matrixes.forEach(function(info, i2) {
    if (length2 - 2 === i2) {
      beforeMatrix = allMatrix.slice();
    }
    if (length2 - 1 === i2) {
      offsetMatrix = allMatrix.slice();
    }
    if (!info.matrix) {
      var nextInfo = matrixes[i2 + 1];
      var offset = getSVGOffset(info, nextInfo, endContainer, n, multiply(rootMatrixBeforeOffset, allMatrix, n));
      info.matrix = createOriginMatrix(offset, n);
    }
    allMatrix = multiply(allMatrix, info.matrix, n);
  });
  var isMatrix3d = !isSVGGraphicElement && is3d;
  if (!targetMatrix) {
    targetMatrix = createIdentityMatrix(isMatrix3d ? 4 : 3);
  }
  var targetTransform = makeMatrixCSS(isSVGGraphicElement && targetMatrix.length === 16 ? convertDimension(targetMatrix, 4, 3) : targetMatrix, isMatrix3d);
  rootMatrix = ignoreDimension(rootMatrix, n, n);
  return {
    rootMatrix,
    beforeMatrix,
    offsetMatrix,
    allMatrix,
    targetMatrix,
    targetTransform,
    transformOrigin,
    targetOrigin,
    is3d: isNext3d
  };
}
function makeMatrixCSS(matrix, is3d) {
  if (is3d === void 0) {
    is3d = matrix.length > 9;
  }
  return (is3d ? "matrix3d" : "matrix") + "(" + convertMatrixtoCSS(matrix, !is3d).join(",") + ")";
}
function getSVGViewBox(el) {
  var clientWidth = el.clientWidth;
  var clientHeight = el.clientHeight;
  if (!el) {
    return {
      x: 0,
      y: 0,
      width: 0,
      height: 0,
      clientWidth,
      clientHeight
    };
  }
  var viewBox = el.viewBox;
  var baseVal = viewBox && viewBox.baseVal || {
    x: 0,
    y: 0,
    width: 0,
    height: 0
  };
  return {
    x: baseVal.x,
    y: baseVal.y,
    width: baseVal.width || clientWidth,
    height: baseVal.height || clientHeight,
    clientWidth,
    clientHeight
  };
}
function getSVGMatrix(el, n) {
  var _a3 = getSVGViewBox(el), viewBoxWidth = _a3.width, viewBoxHeight = _a3.height, clientWidth = _a3.clientWidth, clientHeight = _a3.clientHeight;
  var scaleX = clientWidth / viewBoxWidth;
  var scaleY = clientHeight / viewBoxHeight;
  var preserveAspectRatio = el.preserveAspectRatio.baseVal;
  var align = preserveAspectRatio.align;
  var meetOrSlice = preserveAspectRatio.meetOrSlice;
  var svgOrigin = [0, 0];
  var scale = [scaleX, scaleY];
  var translate = [0, 0];
  if (align !== 1) {
    var xAlign = (align - 2) % 3;
    var yAlign = Math.floor((align - 2) / 3);
    svgOrigin[0] = viewBoxWidth * xAlign / 2;
    svgOrigin[1] = viewBoxHeight * yAlign / 2;
    var scaleDimension = meetOrSlice === 2 ? Math.max(scaleY, scaleX) : Math.min(scaleX, scaleY);
    scale[0] = scaleDimension;
    scale[1] = scaleDimension;
    translate[0] = (clientWidth - viewBoxWidth) / 2 * xAlign;
    translate[1] = (clientHeight - viewBoxHeight) / 2 * yAlign;
  }
  var scaleMatrix2 = createScaleMatrix(scale, n);
  scaleMatrix2[n * (n - 1)] = translate[0], scaleMatrix2[n * (n - 1) + 1] = translate[1];
  return getAbsoluteMatrix(scaleMatrix2, n, svgOrigin);
}
function getSVGGraphicsOffset(el, origin) {
  if (!el.getBBox) {
    return [0, 0];
  }
  var bbox = el.getBBox();
  var viewBox = getSVGViewBox(el.ownerSVGElement);
  var left = bbox.x - viewBox.x;
  var top = bbox.y - viewBox.y;
  return [left, top, origin[0] - left, origin[1] - top];
}
function calculatePosition(matrix, pos, n) {
  return calculate(matrix, convertPositionMatrix(pos, n), n);
}
function calculatePoses(matrix, width, height, n) {
  return [[0, 0], [width, 0], [0, height], [width, height]].map(function(pos) {
    return calculatePosition(matrix, pos, n);
  });
}
function getRect(poses) {
  var posesX = poses.map(function(pos) {
    return pos[0];
  });
  var posesY = poses.map(function(pos) {
    return pos[1];
  });
  var left = Math.min.apply(Math, posesX);
  var top = Math.min.apply(Math, posesY);
  var right = Math.max.apply(Math, posesX);
  var bottom = Math.max.apply(Math, posesY);
  var rectWidth = right - left;
  var rectHeight = bottom - top;
  return {
    left,
    top,
    right,
    bottom,
    width: rectWidth,
    height: rectHeight
  };
}
function calculateRect(matrix, width, height, n) {
  var poses = calculatePoses(matrix, width, height, n);
  return getRect(poses);
}
function getSVGOffset(offsetInfo, targetInfo, container, n, beforeMatrix) {
  var _a3;
  var target = offsetInfo.target;
  var origin = offsetInfo.origin;
  var targetMatrix = targetInfo.matrix;
  var _b3 = getSize(target, void 0, true), width = _b3[0], height = _b3[1];
  var containerClientRect = container.getBoundingClientRect();
  var margin = [0, 0];
  if (container === document.body) {
    margin = getBodyOffset(target, true);
  }
  var rect = target.getBoundingClientRect();
  var rectLeft = rect.left - containerClientRect.left + container.scrollLeft - (container.clientLeft || 0) + margin[0];
  var rectTop = rect.top - containerClientRect.top + container.scrollTop - (container.clientTop || 0) + margin[1];
  var rectWidth = rect.width;
  var rectHeight = rect.height;
  var mat = multiplies(n, beforeMatrix, targetMatrix);
  var _c3 = calculateRect(mat, width, height, n), prevLeft = _c3.left, prevTop = _c3.top, prevWidth = _c3.width, prevHeight = _c3.height;
  var posOrigin = calculatePosition(mat, origin, n);
  var prevOrigin = minus(posOrigin, [prevLeft, prevTop]);
  var rectOrigin = [rectLeft + prevOrigin[0] * rectWidth / prevWidth, rectTop + prevOrigin[1] * rectHeight / prevHeight];
  var offset = [0, 0];
  var count = 0;
  while (++count < 10) {
    var inverseBeforeMatrix = invert(beforeMatrix, n);
    _a3 = minus(calculatePosition(inverseBeforeMatrix, rectOrigin, n), calculatePosition(inverseBeforeMatrix, posOrigin, n)), offset[0] = _a3[0], offset[1] = _a3[1];
    var mat2 = multiplies(n, beforeMatrix, createOriginMatrix(offset, n), targetMatrix);
    var _d2 = calculateRect(mat2, width, height, n), nextLeft = _d2.left, nextTop = _d2.top;
    var distLeft = nextLeft - rectLeft;
    var distTop = nextTop - rectTop;
    if (Math.abs(distLeft) < 2 && Math.abs(distTop) < 2) {
      break;
    }
    rectOrigin[0] -= distLeft;
    rectOrigin[1] -= distTop;
  }
  return offset.map(function(p2) {
    return Math.round(p2);
  });
}
function calculateMoveablePosition(matrix, origin, width, height) {
  var is3d = matrix.length === 16;
  var n = is3d ? 4 : 3;
  var poses = calculatePoses(matrix, width, height, n);
  var _a3 = poses[0], x1 = _a3[0], y1 = _a3[1], _b3 = poses[1], x2 = _b3[0], y2 = _b3[1], _c3 = poses[2], x3 = _c3[0], y3 = _c3[1], _d2 = poses[3], x4 = _d2[0], y4 = _d2[1];
  var _e = calculatePosition(matrix, origin, n), originX = _e[0], originY = _e[1];
  var left = Math.min(x1, x2, x3, x4);
  var top = Math.min(y1, y2, y3, y4);
  var right = Math.max(x1, x2, x3, x4);
  var bottom = Math.max(y1, y2, y3, y4);
  x1 = x1 - left || 0;
  x2 = x2 - left || 0;
  x3 = x3 - left || 0;
  x4 = x4 - left || 0;
  y1 = y1 - top || 0;
  y2 = y2 - top || 0;
  y3 = y3 - top || 0;
  y4 = y4 - top || 0;
  originX = originX - left || 0;
  originY = originY - top || 0;
  var direction = getShapeDirection(poses);
  return {
    left,
    top,
    right,
    bottom,
    origin: [originX, originY],
    pos1: [x1, y1],
    pos2: [x2, y2],
    pos3: [x3, y3],
    pos4: [x4, y4],
    direction
  };
}
function getDistSize(vec) {
  return Math.sqrt(vec[0] * vec[0] + vec[1] * vec[1]);
}
function getDiagonalSize(pos1, pos2) {
  return getDistSize([pos2[0] - pos1[0], pos2[1] - pos1[1]]);
}
function getLineStyle(pos1, pos2, zoom, rad) {
  if (zoom === void 0) {
    zoom = 1;
  }
  if (rad === void 0) {
    rad = getRad$1(pos1, pos2);
  }
  var width = getDiagonalSize(pos1, pos2);
  return {
    transform: "translateY(-50%) translate(" + pos1[0] + "px, " + pos1[1] + "px) rotate(" + rad + "rad) scaleY(" + zoom + ")",
    width: width + "px"
  };
}
function getControlTransform(rotation, zoom) {
  var poses = [];
  for (var _i = 2; _i < arguments.length; _i++) {
    poses[_i - 2] = arguments[_i];
  }
  var length2 = poses.length;
  var x2 = poses.reduce(function(prev2, pos) {
    return prev2 + pos[0];
  }, 0) / length2;
  var y2 = poses.reduce(function(prev2, pos) {
    return prev2 + pos[1];
  }, 0) / length2;
  return {
    transform: "translateZ(0px) translate(" + x2 + "px, " + y2 + "px) rotate(" + rotation + "rad) scale(" + zoom + ")"
  };
}
function getCSSSize(target) {
  var style = getComputedStyle$1(target);
  return [parseFloat(style.width), parseFloat(style.height)];
}
function getSize(target, style, isOffset, isBoxSizing) {
  if (style === void 0) {
    style = getComputedStyle$1(target);
  }
  if (isBoxSizing === void 0) {
    isBoxSizing = isOffset || style.boxSizing === "border-box";
  }
  var width = target.offsetWidth;
  var height = target.offsetHeight;
  var hasOffset = !isUndefined(width);
  if ((isOffset || isBoxSizing) && hasOffset) {
    return [width, height];
  }
  if (!hasOffset && target.tagName.toLowerCase() !== "svg") {
    var bbox = target.getBBox();
    return [bbox.width, bbox.height];
  }
  width = target.clientWidth;
  height = target.clientHeight;
  if (isOffset || isBoxSizing) {
    var borderLeft = parseFloat(style.borderLeftWidth) || 0;
    var borderRight = parseFloat(style.borderRightWidth) || 0;
    var borderTop = parseFloat(style.borderTopWidth) || 0;
    var borderBottom = parseFloat(style.borderBottomWidth) || 0;
    return [width + borderLeft + borderRight, height + borderTop + borderBottom];
  } else {
    var paddingLeft = parseFloat(style.paddingLeft) || 0;
    var paddingRight = parseFloat(style.paddingRight) || 0;
    var paddingTop = parseFloat(style.paddingTop) || 0;
    var paddingBottom = parseFloat(style.paddingBottom) || 0;
    return [width - paddingLeft - paddingRight, height - paddingTop - paddingBottom];
  }
}
function getRotationRad(poses, direction) {
  return getRad$1(direction > 0 ? poses[0] : poses[1], direction > 0 ? poses[1] : poses[0]);
}
function getTargetInfo(moveableElement, target, container, parentContainer, rootContainer) {
  var beforeDirection = 1;
  var beforeOrigin = [0, 0];
  var targetClientRect = resetClientRect();
  var containerClientRect = resetClientRect();
  var moveableClientRect = resetClientRect();
  var result = calculateElementInfo(target, container, rootContainer, false);
  if (target) {
    var n = result.is3d ? 4 : 3;
    var beforePosition = calculateMoveablePosition(result.offsetMatrix, plus(result.transformOrigin, getOrigin(result.targetMatrix, n)), result.width, result.height);
    beforeDirection = beforePosition.direction;
    beforeOrigin = plus(beforePosition.origin, [beforePosition.left - result.left, beforePosition.top - result.top]);
    targetClientRect = getClientRect(target);
    containerClientRect = getClientRect(getOffsetInfo(parentContainer, parentContainer, true).offsetParent || document.body, true);
    if (moveableElement) {
      moveableClientRect = getClientRect(moveableElement);
    }
  }
  return __assign$2({
    targetClientRect,
    containerClientRect,
    moveableClientRect,
    beforeDirection,
    beforeOrigin,
    originalBeforeOrigin: beforeOrigin,
    target
  }, result);
}
function resetClientRect() {
  return {
    left: 0,
    right: 0,
    top: 0,
    bottom: 0,
    width: 0,
    height: 0,
    clientLeft: 0,
    clientTop: 0,
    clientWidth: 0,
    clientHeight: 0,
    scrollWidth: 0,
    scrollHeight: 0
  };
}
function getClientRect(el, isExtends) {
  var left = 0;
  var top = 0;
  var width = 0;
  var height = 0;
  if (el === document.body || el === document.documentElement) {
    width = window.innerWidth;
    height = window.innerHeight;
    left = -(document.documentElement.scrollLeft || document.body.scrollLeft);
    top = -(document.documentElement.scrollTop || document.body.scrollTop);
  } else {
    var clientRect = el.getBoundingClientRect();
    left = clientRect.left;
    top = clientRect.top;
    width = clientRect.width;
    height = clientRect.height;
  }
  var rect = {
    left,
    right: left + width,
    top,
    bottom: top + height,
    width,
    height
  };
  if (isExtends) {
    rect.clientLeft = el.clientLeft;
    rect.clientTop = el.clientTop;
    rect.clientWidth = el.clientWidth;
    rect.clientHeight = el.clientHeight;
    rect.scrollWidth = el.scrollWidth;
    rect.scrollHeight = el.scrollHeight;
    rect.overflow = getComputedStyle$1(el).overflow !== "visible";
  }
  return rect;
}
function getDirection(target) {
  if (!target) {
    return;
  }
  var direciton = target.getAttribute("data-direction");
  if (!direciton) {
    return;
  }
  var dir = [0, 0];
  direciton.indexOf("w") > -1 && (dir[0] = -1);
  direciton.indexOf("e") > -1 && (dir[0] = 1);
  direciton.indexOf("n") > -1 && (dir[1] = -1);
  direciton.indexOf("s") > -1 && (dir[1] = 1);
  return dir;
}
function getAbsolutePoses(poses, dist) {
  return [plus(dist, poses[0]), plus(dist, poses[1]), plus(dist, poses[2]), plus(dist, poses[3])];
}
function getAbsolutePosesByState(_a3) {
  var left = _a3.left, top = _a3.top, pos1 = _a3.pos1, pos2 = _a3.pos2, pos3 = _a3.pos3, pos4 = _a3.pos4;
  return getAbsolutePoses([pos1, pos2, pos3, pos4], [left, top]);
}
function roundSign(num) {
  return Math.round(num % 1 === -0.5 ? num - 1 : num);
}
function unset(self2, name2) {
  var _a3;
  (_a3 = self2[name2]) === null || _a3 === void 0 ? void 0 : _a3.unset();
  self2[name2] = null;
}
function fillParams(moveable, e, params) {
  var datas = e.datas;
  if (!datas.datas) {
    datas.datas = {};
  }
  var nextParams = __assign$2(__assign$2({}, params), {
    target: moveable.state.target,
    clientX: e.clientX,
    clientY: e.clientY,
    inputEvent: e.inputEvent,
    currentTarget: moveable,
    moveable,
    datas: datas.datas
  });
  if (datas.isStartEvent) {
    datas.lastEvent = nextParams;
  } else {
    datas.isStartEvent = true;
  }
  return nextParams;
}
function fillEndParams(moveable, e, params) {
  var datas = e.datas;
  var isDrag = "isDrag" in params ? params.isDrag : e.isDrag;
  if (!datas.datas) {
    datas.datas = {};
  }
  return __assign$2(__assign$2({
    isDrag
  }, params), {
    moveable,
    target: moveable.state.target,
    clientX: e.clientX,
    clientY: e.clientY,
    inputEvent: e.inputEvent,
    currentTarget: moveable,
    lastEvent: datas.lastEvent,
    isDouble: e.isDouble,
    datas: datas.datas
  });
}
function triggerEvent(moveable, name2, params, isManager) {
  return moveable.triggerEvent(name2, params, isManager);
}
function getComputedStyle$1(el, pseudoElt) {
  return window.getComputedStyle(el, pseudoElt);
}
function filterAbles(ables, methods, triggerAblesSimultaneously) {
  var enabledAbles = {};
  var ableGroups = {};
  return ables.filter(function(able) {
    var name2 = able.name;
    if (enabledAbles[name2] || !methods.some(function(method) {
      return able[method];
    })) {
      return false;
    }
    if (!triggerAblesSimultaneously && able.ableGroup) {
      if (ableGroups[able.ableGroup]) {
        return false;
      }
      ableGroups[able.ableGroup] = true;
    }
    enabledAbles[name2] = true;
    return true;
  });
}
function equals(a1, a2) {
  return a1 === a2 || a1 == null && a2 == null;
}
function selectValue() {
  var values = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    values[_i] = arguments[_i];
  }
  var length2 = values.length - 1;
  for (var i2 = 0; i2 < length2; ++i2) {
    var value = values[i2];
    if (!isUndefined(value)) {
      return value;
    }
  }
  return values[length2];
}
function groupBy(arr, func) {
  var groups = [];
  var groupKeys = [];
  arr.forEach(function(el, index) {
    var groupKey = func(el, index, arr);
    var keyIndex = groupKeys.indexOf(groupKey);
    var group = groups[keyIndex] || [];
    if (keyIndex === -1) {
      groupKeys.push(groupKey);
      groups.push(group);
    }
    group.push(el);
  });
  return groups;
}
function groupByMap(arr, func) {
  var groups = [];
  var groupKeys = {};
  arr.forEach(function(el, index) {
    var groupKey = func(el, index, arr);
    var group = groupKeys[groupKey];
    if (!group) {
      group = [];
      groupKeys[groupKey] = group;
      groups.push(group);
    }
    group.push(el);
  });
  return groups;
}
function flat(arr) {
  return arr.reduce(function(prev2, cur) {
    return prev2.concat(cur);
  }, []);
}
function maxOffset() {
  var args = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    args[_i] = arguments[_i];
  }
  args.sort(function(a2, b2) {
    return Math.abs(b2) - Math.abs(a2);
  });
  return args[0];
}
function calculateInversePosition(matrix, pos, n) {
  return calculate(invert(matrix, n), convertPositionMatrix(pos, n), n);
}
function convertDragDist(state, e) {
  var _a3;
  var is3d = state.is3d, rootMatrix = state.rootMatrix;
  var n = is3d ? 4 : 3;
  _a3 = calculateInversePosition(rootMatrix, [e.distX, e.distY], n), e.distX = _a3[0], e.distY = _a3[1];
  return e;
}
function calculatePadding(matrix, pos, transformOrigin, origin, n) {
  return minus(calculatePosition(matrix, plus(transformOrigin, pos), n), origin);
}
function convertCSSSize(value, size, isRelative) {
  return isRelative ? value / size * 100 + "%" : value + "px";
}
function moveControlPos(controlPoses, index, dist, isRect) {
  var _a3 = controlPoses[index], direction = _a3.direction, sub = _a3.sub;
  var dists = controlPoses.map(function() {
    return [0, 0];
  });
  var directions = direction ? direction.split("") : [];
  if (isRect && index < 8) {
    var verticalDirection_1 = directions.filter(function(dir) {
      return dir === "w" || dir === "e";
    })[0];
    var horizontalDirection_1 = directions.filter(function(dir) {
      return dir === "n" || dir === "s";
    })[0];
    dists[index] = dist;
    controlPoses.forEach(function(controlPose, i2) {
      var controlDir = controlPose.direction;
      if (!controlDir) {
        return;
      }
      if (controlDir.indexOf(verticalDirection_1) > -1) {
        dists[i2][0] = dist[0];
      }
      if (controlDir.indexOf(horizontalDirection_1) > -1) {
        dists[i2][1] = dist[1];
      }
    });
    if (verticalDirection_1) {
      dists[1][0] = dist[0] / 2;
      dists[5][0] = dist[0] / 2;
    }
    if (horizontalDirection_1) {
      dists[3][1] = dist[1] / 2;
      dists[7][1] = dist[1] / 2;
    }
  } else if (direction && !sub) {
    directions.forEach(function(dir) {
      var isVertical = dir === "n" || dir === "s";
      controlPoses.forEach(function(controlPose, i2) {
        var dirDir = controlPose.direction, dirHorizontal = controlPose.horizontal, dirVertical = controlPose.vertical;
        if (!dirDir || dirDir.indexOf(dir) === -1) {
          return;
        }
        dists[i2] = [isVertical || !dirHorizontal ? 0 : dist[0], !isVertical || !dirVertical ? 0 : dist[1]];
      });
    });
  } else {
    dists[index] = dist;
  }
  return dists;
}
function getTinyDist(v2) {
  return Math.abs(v2) <= TINY_NUM ? 0 : v2;
}
function directionCondition(moveable, e) {
  if (e.isRequest) {
    if (e.requestAble === "resizable" || e.requestAble === "scalable") {
      return e.parentDirection;
    } else {
      return false;
    }
  }
  return hasClass(e.inputEvent.target, prefix("direction"));
}
function invertObject(obj) {
  var nextObj = {};
  for (var name2 in obj) {
    nextObj[obj[name2]] = name2;
  }
  return nextObj;
}
function getTransform(transforms, index) {
  var beforeFunctionTexts = transforms.slice(0, index < 0 ? void 0 : index);
  var beforeFunctionTexts2 = transforms.slice(0, index < 0 ? void 0 : index + 1);
  var targetFunctionText = transforms[index] || "";
  var afterFunctionTexts = index < 0 ? [] : transforms.slice(index);
  var afterFunctionTexts2 = index < 0 ? [] : transforms.slice(index + 1);
  var beforeFunctions = parse(beforeFunctionTexts);
  var beforeFunctions2 = parse(beforeFunctionTexts2);
  var targetFunctions = parse([targetFunctionText]);
  var afterFunctions = parse(afterFunctionTexts);
  var afterFunctions2 = parse(afterFunctionTexts2);
  var beforeFunctionMatrix = toMat(beforeFunctions);
  var beforeFunctionMatrix2 = toMat(beforeFunctions2);
  var afterFunctionMatrix = toMat(afterFunctions);
  var afterFunctionMatrix2 = toMat(afterFunctions2);
  var allFunctionMatrix = multiply(beforeFunctionMatrix, afterFunctionMatrix, 4);
  return {
    transforms,
    beforeFunctionMatrix,
    beforeFunctionMatrix2,
    targetFunctionMatrix: toMat(targetFunctions),
    afterFunctionMatrix,
    afterFunctionMatrix2,
    allFunctionMatrix,
    beforeFunctions,
    beforeFunctions2,
    targetFunction: targetFunctions[0],
    afterFunctions,
    afterFunctions2,
    beforeFunctionTexts,
    beforeFunctionTexts2,
    targetFunctionText,
    afterFunctionTexts,
    afterFunctionTexts2
  };
}
function isArrayFormat(arr) {
  if (!arr || !isObject$2(arr)) {
    return false;
  }
  return isArray(arr) || "length" in arr;
}
function getRefTarget(target, isSelector) {
  if (!target) {
    return null;
  }
  if (isString(target)) {
    if (isSelector) {
      return document.querySelector(target);
    }
    return target;
  }
  if (isFunction$2(target)) {
    return target();
  }
  if ("current" in target) {
    return target.current;
  }
  return target;
}
function getRefTargets(targets, isSelector) {
  if (!targets) {
    return [];
  }
  var userTargets = isArrayFormat(targets) ? [].slice.call(targets) : [targets];
  return userTargets.reduce(function(prev2, target) {
    if (isString(target) && isSelector) {
      return __spreadArray(__spreadArray([], prev2), [].slice.call(document.querySelectorAll(target)));
    }
    prev2.push(getRefTarget(target, isSelector));
    return prev2;
  }, []);
}
function getElementTargets(targets, selectorMap) {
  var elementTargets = [];
  targets.forEach(function(target) {
    if (!target) {
      return;
    }
    if (isString(target)) {
      if (selectorMap[target]) {
        elementTargets.push.apply(elementTargets, selectorMap[target]);
      }
      return;
    }
    elementTargets.push(target);
  });
  return elementTargets;
}
function getAbsoluteRotation(pos1, pos2, direction) {
  var deg = getRad$1(pos1, pos2) / Math.PI * 180;
  deg = direction >= 0 ? deg : 180 - deg;
  deg = deg >= 0 ? deg : 360 + deg;
  return deg;
}
function getDragDistByState(state, dist) {
  var rootMatrix = state.rootMatrix, is3d = state.is3d;
  var n = is3d ? 4 : 3;
  var inverseMatrix = invert(rootMatrix, n);
  if (!is3d) {
    inverseMatrix = convertDimension(inverseMatrix, 3, 4);
  }
  inverseMatrix[12] = 0;
  inverseMatrix[13] = 0;
  inverseMatrix[14] = 0;
  return calculateMatrixDist(inverseMatrix, dist);
}
var Pinchable = makeAble("pinchable", {
  events: {
    onPinchStart: "pinchStart",
    onPinch: "pinch",
    onPinchEnd: "pinchEnd",
    onPinchGroupStart: "pinchGroupStart",
    onPinchGroup: "pinchGroup",
    onPinchGroupEnd: "pinchGroupEnd"
  },
  dragStart: function() {
    return true;
  },
  pinchStart: function(moveable, e) {
    var datas = e.datas, targets = e.targets, angle = e.angle, originalDatas = e.originalDatas;
    var _a3 = moveable.props, pinchable = _a3.pinchable, ables = _a3.ables;
    if (!pinchable) {
      return false;
    }
    var eventName = "onPinch" + (targets ? "Group" : "") + "Start";
    var controlEventName = "drag" + (targets ? "Group" : "") + "ControlStart";
    var pinchAbles = (pinchable === true ? moveable.controlAbles : ables.filter(function(able) {
      return pinchable.indexOf(able.name) > -1;
    })).filter(function(able) {
      return able.canPinch && able[controlEventName];
    });
    var params = fillParams(moveable, e, {});
    if (targets) {
      params.targets = targets;
    }
    var result = triggerEvent(moveable, eventName, params);
    datas.isPinch = result !== false;
    datas.ables = pinchAbles;
    var isPinch = datas.isPinch;
    if (!isPinch) {
      return false;
    }
    pinchAbles.forEach(function(able) {
      originalDatas[able.name] = originalDatas[able.name] || {};
      if (!able[controlEventName]) {
        return;
      }
      var ableEvent = __assign$2(__assign$2({}, e), {
        datas: originalDatas[able.name],
        parentRotate: angle,
        isPinch: true
      });
      able[controlEventName](moveable, ableEvent);
    });
    moveable.state.snapRenderInfo = {
      request: e.isRequest,
      direction: [0, 0]
    };
    return isPinch;
  },
  pinch: function(moveable, e) {
    var datas = e.datas, pinchScale = e.scale, distance = e.distance, originalDatas = e.originalDatas, inputEvent = e.inputEvent, targets = e.targets, angle = e.angle;
    if (!datas.isPinch) {
      return;
    }
    var parentDistance = distance * (1 - 1 / pinchScale);
    var params = fillParams(moveable, e, {});
    if (targets) {
      params.targets = targets;
    }
    var eventName = "onPinch" + (targets ? "Group" : "");
    triggerEvent(moveable, eventName, params);
    var ables = datas.ables;
    var controlEventName = "drag" + (targets ? "Group" : "") + "Control";
    ables.forEach(function(able) {
      if (!able[controlEventName]) {
        return;
      }
      able[controlEventName](moveable, __assign$2(__assign$2({}, e), {
        datas: originalDatas[able.name],
        inputEvent,
        parentDistance,
        parentRotate: angle,
        isPinch: true
      }));
    });
    return params;
  },
  pinchEnd: function(moveable, e) {
    var datas = e.datas, isPinch = e.isPinch, inputEvent = e.inputEvent, targets = e.targets, originalDatas = e.originalDatas;
    if (!datas.isPinch) {
      return;
    }
    var eventName = "onPinch" + (targets ? "Group" : "") + "End";
    var params = fillEndParams(moveable, e, {
      isDrag: isPinch
    });
    if (targets) {
      params.targets = targets;
    }
    triggerEvent(moveable, eventName, params);
    var ables = datas.ables;
    var controlEventName = "drag" + (targets ? "Group" : "") + "ControlEnd";
    ables.forEach(function(able) {
      if (!able[controlEventName]) {
        return;
      }
      able[controlEventName](moveable, __assign$2(__assign$2({}, e), {
        isDrag: isPinch,
        datas: originalDatas[able.name],
        inputEvent,
        isPinch: true
      }));
    });
    return isPinch;
  },
  pinchGroupStart: function(moveable, e) {
    return this.pinchStart(moveable, __assign$2(__assign$2({}, e), {
      targets: moveable.props.targets
    }));
  },
  pinchGroup: function(moveable, e) {
    return this.pinch(moveable, __assign$2(__assign$2({}, e), {
      targets: moveable.props.targets
    }));
  },
  pinchGroupEnd: function(moveable, e) {
    return this.pinchEnd(moveable, __assign$2(__assign$2({}, e), {
      targets: moveable.props.targets
    }));
  }
});
function setCustomDrag(e, state, delta, isPinch, isConvert) {
  var result = state.gesto.move(delta, e.inputEvent);
  var datas = result.originalDatas || result.datas;
  var draggableDatas = datas.draggable || (datas.draggable = {});
  return __assign$2(__assign$2({}, isConvert ? convertDragDist(state, result) : result), {
    isDrag: true,
    isPinch: !!isPinch,
    parentEvent: true,
    datas: draggableDatas,
    originalDatas: e.originalDatas
  });
}
var CustomGesto = /* @__PURE__ */ function() {
  function CustomGesto2() {
    this.prevX = 0;
    this.prevY = 0;
    this.startX = 0;
    this.startY = 0;
    this.isDrag = false;
    this.isFlag = false;
    this.datas = {
      draggable: {}
    };
  }
  var __proto = CustomGesto2.prototype;
  __proto.dragStart = function(client, e) {
    this.isDrag = false;
    this.isFlag = false;
    var originalDatas = e.originalDatas;
    this.datas = originalDatas;
    if (!originalDatas.draggable) {
      originalDatas.draggable = {};
    }
    return __assign$2(__assign$2({}, this.move(client, e.inputEvent)), {
      type: "dragstart"
    });
  };
  __proto.drag = function(client, inputEvent) {
    return this.move([client[0] - this.prevX, client[1] - this.prevY], inputEvent);
  };
  __proto.move = function(delta, inputEvent) {
    var clientX;
    var clientY;
    if (!this.isFlag) {
      this.prevX = delta[0];
      this.prevY = delta[1];
      this.startX = delta[0];
      this.startY = delta[1];
      clientX = delta[0];
      clientY = delta[1];
      this.isFlag = true;
    } else {
      clientX = this.prevX + delta[0];
      clientY = this.prevY + delta[1];
      this.isDrag = true;
    }
    this.prevX = clientX;
    this.prevY = clientY;
    return {
      type: "drag",
      clientX,
      clientY,
      inputEvent,
      isDrag: this.isDrag,
      distX: clientX - this.startX,
      distY: clientY - this.startY,
      deltaX: delta[0],
      deltaY: delta[1],
      datas: this.datas.draggable,
      originalDatas: this.datas,
      parentEvent: true,
      parentGesto: this
    };
  };
  return CustomGesto2;
}();
function fillChildEvents(moveable, name2, e) {
  var datas = e.originalDatas;
  datas.groupable = datas.groupable || {};
  var groupableDatas = datas.groupable;
  groupableDatas.childDatas = groupableDatas.childDatas || [];
  var childDatas = groupableDatas.childDatas;
  return moveable.moveables.map(function(_2, i2) {
    childDatas[i2] = childDatas[i2] || {};
    childDatas[i2][name2] = childDatas[i2][name2] || {};
    return __assign$2(__assign$2({}, e), {
      datas: childDatas[i2][name2],
      originalDatas: childDatas[i2]
    });
  });
}
function triggerChildGesto(moveable, able, type, delta, e, isConvert) {
  var isStart = !!type.match(/Start$/g);
  var isEnd = !!type.match(/End$/g);
  var isPinch = e.isPinch;
  var datas = e.datas;
  var events = fillChildEvents(moveable, able.name, e);
  var moveables = moveable.moveables;
  var childs = events.map(function(ev, i2) {
    var childMoveable = moveables[i2];
    var childEvent = ev;
    if (isStart) {
      childEvent = new CustomGesto().dragStart(delta, ev);
    } else {
      if (!childMoveable.state.gesto) {
        childMoveable.state.gesto = datas.childGestos[i2];
      }
      childEvent = setCustomDrag(ev, childMoveable.state, delta, isPinch, isConvert);
    }
    var result = able[type](childMoveable, __assign$2(__assign$2({}, childEvent), {
      parentFlag: true
    }));
    if (isEnd) {
      childMoveable.state.gesto = null;
    }
    return result;
  });
  if (isStart) {
    datas.childGestos = moveables.map(function(child) {
      return child.state.gesto;
    });
  }
  return childs;
}
function triggerChildAbles(moveable, able, type, e, eachEvent, callback) {
  if (eachEvent === void 0) {
    eachEvent = function(_2, ev) {
      return ev;
    };
  }
  var isEnd = !!type.match(/End$/g);
  var events = fillChildEvents(moveable, able.name, e);
  var moveables = moveable.moveables;
  var childs = events.map(function(ev, i2) {
    var childMoveable = moveables[i2];
    var childEvent = ev;
    childEvent = eachEvent(childMoveable, ev);
    var result = able[type](childMoveable, __assign$2(__assign$2({}, childEvent), {
      parentFlag: true
    }));
    result && callback && callback(childMoveable, ev, result, i2);
    if (isEnd) {
      childMoveable.state.gesto = null;
    }
    return result;
  });
  return childs;
}
function calculatePointerDist(moveable, e) {
  var clientX = e.clientX, clientY = e.clientY, datas = e.datas;
  var _a3 = moveable.state, moveableClientRect = _a3.moveableClientRect, rootMatrix = _a3.rootMatrix, is3d = _a3.is3d, pos1 = _a3.pos1;
  var left = moveableClientRect.left, top = moveableClientRect.top;
  var n = is3d ? 4 : 3;
  var _b3 = minus(calculateInversePosition(rootMatrix, [clientX - left, clientY - top], n), pos1), posX = _b3[0], posY = _b3[1];
  var _c3 = getDragDist({
    datas,
    distX: posX,
    distY: posY
  }), distX = _c3[0], distY = _c3[1];
  return [distX, distY];
}
function setDragStart(moveable, _a3) {
  var datas = _a3.datas;
  var _b3 = moveable.state, allMatrix = _b3.allMatrix, beforeMatrix = _b3.beforeMatrix, is3d = _b3.is3d, left = _b3.left, top = _b3.top, origin = _b3.origin, offsetMatrix = _b3.offsetMatrix, targetMatrix = _b3.targetMatrix, transformOrigin = _b3.transformOrigin;
  var n = is3d ? 4 : 3;
  datas.is3d = is3d;
  datas.matrix = allMatrix;
  datas.targetMatrix = targetMatrix;
  datas.beforeMatrix = beforeMatrix;
  datas.offsetMatrix = offsetMatrix;
  datas.transformOrigin = transformOrigin;
  datas.inverseMatrix = invert(allMatrix, n);
  datas.inverseBeforeMatrix = invert(beforeMatrix, n);
  datas.absoluteOrigin = convertPositionMatrix(plus([left, top], origin), n);
  datas.startDragBeforeDist = calculate(datas.inverseBeforeMatrix, datas.absoluteOrigin, n);
  datas.startDragDist = calculate(datas.inverseMatrix, datas.absoluteOrigin, n);
}
function getTransformDirection(e) {
  return calculateMoveablePosition(e.datas.beforeTransform, [50, 50], 100, 100).direction;
}
function resolveTransformEvent(event, functionName) {
  var datas = event.datas, originalDatas = event.originalDatas.beforeRenderable;
  var index = datas.transformIndex;
  var nextTransforms = originalDatas.nextTransforms;
  var nextTransformAppendedIndexes = originalDatas.nextTransformAppendedIndexes;
  var nextIndex = 0;
  if (index === -1) {
    nextIndex = nextTransforms.length;
    datas.transformIndex = nextIndex;
  } else {
    nextIndex = index + nextTransformAppendedIndexes.filter(function(i2) {
      return i2 < index;
    }).length;
  }
  var result = getTransform(nextTransforms, nextIndex);
  var targetFunction = result.targetFunction;
  var matFunctionName = functionName === "rotate" ? "rotateZ" : functionName;
  datas.beforeFunctionTexts = result.beforeFunctionTexts;
  datas.afterFunctionTexts = result.afterFunctionTexts;
  datas.beforeTransform = result.beforeFunctionMatrix;
  datas.beforeTransform2 = result.beforeFunctionMatrix2;
  datas.targetTansform = result.targetFunctionMatrix;
  datas.afterTransform = result.afterFunctionMatrix;
  datas.afterTransform2 = result.afterFunctionMatrix2;
  datas.targetAllTransform = result.allFunctionMatrix;
  if (targetFunction.functionName === matFunctionName) {
    datas.afterFunctionTexts.splice(0, 1);
    datas.isAppendTransform = false;
  } else {
    datas.isAppendTransform = true;
    originalDatas.nextTransformAppendedIndexes = __spreadArray(__spreadArray([], nextTransformAppendedIndexes), [nextIndex]);
  }
}
function convertTransformFormat(datas, value, dist) {
  return datas.beforeFunctionTexts.join(" ") + " " + (datas.isAppendTransform ? dist : value) + " " + datas.afterFunctionTexts.join(" ");
}
function getTransformDist(_a3) {
  var datas = _a3.datas, distX = _a3.distX, distY = _a3.distY;
  var _b3 = getBeforeDragDist({
    datas,
    distX,
    distY
  }), bx = _b3[0], by = _b3[1];
  var res = getTransfromMatrix(datas, fromTranslation([bx, by], 4));
  return calculate(res, convertPositionMatrix([0, 0, 0], 4), 4);
}
function getTransfromMatrix(datas, targetMatrix, isAfter) {
  var beforeTransform = datas.beforeTransform, afterTransform = datas.afterTransform, beforeTransform2 = datas.beforeTransform2, afterTransform2 = datas.afterTransform2, targetAllTransform = datas.targetAllTransform;
  var nextTargetMatrix = isAfter ? multiply(targetAllTransform, targetMatrix, 4) : multiply(targetMatrix, targetAllTransform, 4);
  var res1 = multiply(invert(isAfter ? beforeTransform2 : beforeTransform, 4), nextTargetMatrix, 4);
  var afterTargetMatrix = multiply(res1, invert(isAfter ? afterTransform2 : afterTransform, 4), 4);
  return afterTargetMatrix;
}
function getBeforeDragDist(_a3) {
  var datas = _a3.datas, distX = _a3.distX, distY = _a3.distY;
  var inverseBeforeMatrix = datas.inverseBeforeMatrix, is3d = datas.is3d, startDragBeforeDist = datas.startDragBeforeDist, absoluteOrigin = datas.absoluteOrigin;
  var n = is3d ? 4 : 3;
  return minus(calculate(inverseBeforeMatrix, plus(absoluteOrigin, [distX, distY]), n), startDragBeforeDist);
}
function getDragDist(_a3, isBefore) {
  var datas = _a3.datas, distX = _a3.distX, distY = _a3.distY;
  var inverseBeforeMatrix = datas.inverseBeforeMatrix, inverseMatrix = datas.inverseMatrix, is3d = datas.is3d, startDragBeforeDist = datas.startDragBeforeDist, startDragDist = datas.startDragDist, absoluteOrigin = datas.absoluteOrigin;
  var n = is3d ? 4 : 3;
  return minus(calculate(isBefore ? inverseBeforeMatrix : inverseMatrix, plus(absoluteOrigin, [distX, distY]), n), isBefore ? startDragBeforeDist : startDragDist);
}
function getInverseDragDist(_a3, isBefore) {
  var datas = _a3.datas, distX = _a3.distX, distY = _a3.distY;
  var beforeMatrix = datas.beforeMatrix, matrix = datas.matrix, is3d = datas.is3d, startDragBeforeDist = datas.startDragBeforeDist, startDragDist = datas.startDragDist, absoluteOrigin = datas.absoluteOrigin;
  var n = is3d ? 4 : 3;
  return minus(calculate(isBefore ? beforeMatrix : matrix, plus(isBefore ? startDragBeforeDist : startDragDist, [distX, distY]), n), absoluteOrigin);
}
function calculateTransformOrigin(transformOrigin, width, height, prevWidth, prevHeight, prevOrigin) {
  if (prevWidth === void 0) {
    prevWidth = width;
  }
  if (prevHeight === void 0) {
    prevHeight = height;
  }
  if (prevOrigin === void 0) {
    prevOrigin = [0, 0];
  }
  if (!transformOrigin) {
    return prevOrigin;
  }
  return transformOrigin.map(function(pos, i2) {
    var _a3 = splitUnit(pos), value = _a3.value, unit = _a3.unit;
    var prevSize = i2 ? prevHeight : prevWidth;
    var size = i2 ? height : width;
    if (pos === "%" || isNaN(value)) {
      var measureRatio = prevSize ? prevOrigin[i2] / prevSize : 0;
      return size * measureRatio;
    } else if (unit !== "%") {
      return value;
    }
    return size * value / 100;
  });
}
function getPosIndexesByDirection(direction) {
  var indexes = [];
  if (direction[1] >= 0) {
    if (direction[0] >= 0) {
      indexes.push(3);
    }
    if (direction[0] <= 0) {
      indexes.push(2);
    }
  }
  if (direction[1] <= 0) {
    if (direction[0] >= 0) {
      indexes.push(1);
    }
    if (direction[0] <= 0) {
      indexes.push(0);
    }
  }
  return indexes;
}
function getPosesByDirection(poses, direction) {
  return getPosIndexesByDirection(direction).map(function(index) {
    return poses[index];
  });
}
function getPosByDirection(poses, direction) {
  var nextPoses = getPosesByDirection(poses, direction);
  return [average(nextPoses.map(function(pos) {
    return pos[0];
  })), average(nextPoses.map(function(pos) {
    return pos[1];
  }))];
}
function getPosByReverseDirection(poses, direction) {
  return getPosByDirection(poses, direction.map(function(dir) {
    return -dir;
  }));
}
function getDist(startPos, matrix, width, height, n, fixedDirection) {
  var poses = calculatePoses(matrix, width, height, n);
  var fixedPos = getPosByDirection(poses, fixedDirection);
  var distX = startPos[0] - fixedPos[0];
  var distY = startPos[1] - fixedPos[1];
  return [distX, distY];
}
function getNextMatrix(offsetMatrix, targetMatrix, origin, n) {
  return multiply(offsetMatrix, getAbsoluteMatrix(targetMatrix, n, origin), n);
}
function getNextTransformMatrix(state, datas, transform) {
  var transformOrigin = state.transformOrigin, offsetMatrix = state.offsetMatrix, is3d = state.is3d;
  var beforeTransform = datas.beforeTransform, afterTransform = datas.afterTransform;
  var n = is3d ? 4 : 3;
  var targetTransform = parseMat([transform]);
  return getNextMatrix(offsetMatrix, convertDimension(multiply(multiply(beforeTransform, targetTransform, 4), afterTransform, 4), 4, n), transformOrigin, n);
}
function scaleMatrix(state, scale) {
  var transformOrigin = state.transformOrigin, offsetMatrix = state.offsetMatrix, is3d = state.is3d, targetMatrix = state.targetMatrix;
  var n = is3d ? 4 : 3;
  return getNextMatrix(offsetMatrix, multiply(targetMatrix, createScaleMatrix(scale, n), n), transformOrigin, n);
}
function fillTransformStartEvent(e) {
  var originalDatas = e.originalDatas.beforeRenderable;
  return {
    setTransform: function(transform, index) {
      if (index === void 0) {
        index = -1;
      }
      originalDatas.startTransforms = isArray(transform) ? transform : splitSpace(transform);
      setTransformIndex(e, index);
    },
    setTransformIndex: function(index) {
      setTransformIndex(e, index);
    }
  };
}
function setDefaultTransformIndex(e, property) {
  var originalDatas = e.originalDatas.beforeRenderable;
  var startTransforms = originalDatas.startTransforms;
  setTransformIndex(e, findIndex(startTransforms, function(func) {
    return func.indexOf(property + "(") === 0;
  }));
}
function setTransformIndex(e, index) {
  var originalDatas = e.originalDatas.beforeRenderable;
  var datas = e.datas;
  datas.transformIndex = index;
  if (index === -1) {
    return;
  }
  var transform = originalDatas.startTransforms[index];
  if (!transform) {
    return;
  }
  var info = parse([transform]);
  datas.startValue = info[0].functionValue;
}
function fillOriginalTransform(e, transform) {
  var originalDatas = e.originalDatas.beforeRenderable;
  originalDatas.nextTransforms = splitSpace(transform);
}
function getNextTransformText(e) {
  var originalDatas = e.originalDatas.beforeRenderable;
  return originalDatas.nextTransforms.join(" ");
}
function fillTransformEvent(moveable, nextTransform, delta, isPinch, e) {
  fillOriginalTransform(e, nextTransform);
  return {
    transform: nextTransform,
    drag: Draggable.drag(moveable, setCustomDrag(e, moveable.state, delta, isPinch, false))
  };
}
function getTranslateDist(moveable, transform, fixedDirection, fixedPosition, datas) {
  var state = moveable.state;
  var left = state.left, top = state.top;
  var groupable = moveable.props.groupable;
  var nextMatrix = getNextTransformMatrix(moveable.state, datas, transform);
  var groupLeft = groupable ? left : 0;
  var groupTop = groupable ? top : 0;
  var nextFixedPosition = getDirectionOffset(moveable, fixedDirection, nextMatrix);
  var dist = minus(fixedPosition, nextFixedPosition);
  return minus(dist, [groupLeft, groupTop]);
}
function getScaleDist(moveable, scaleDist, fixedDirection, fixedPosition, datas) {
  return getTranslateDist(moveable, "scale(" + scaleDist.join(", ") + ")", fixedDirection, fixedPosition, datas);
}
function getOriginDirection(moveable) {
  var _a3 = moveable.state, width = _a3.width, height = _a3.height, transformOrigin = _a3.transformOrigin;
  return [-1 + transformOrigin[0] / (width / 2), -1 + transformOrigin[1] / (height / 2)];
}
function getDirectionOffset(moveable, direction, nextMatrix) {
  if (nextMatrix === void 0) {
    nextMatrix = moveable.state.allMatrix;
  }
  var _a3 = moveable.state, width = _a3.width, height = _a3.height, is3d = _a3.is3d;
  var n = is3d ? 4 : 3;
  var nextFixedOffset = [width / 2 * (1 + direction[0]), height / 2 * (1 + direction[1])];
  return calculatePosition(nextMatrix, nextFixedOffset, n);
}
function getRotateDist(moveable, rotateDist, fixedPosition, datas) {
  var fixedDirection = getOriginDirection(moveable);
  return getTranslateDist(moveable, "rotate(" + rotateDist + "deg)", fixedDirection, fixedPosition, datas);
}
function getResizeDist(moveable, width, height, fixedDirection, fixedPosition, transformOrigin) {
  var groupable = moveable.props.groupable;
  var _a3 = moveable.state, prevOrigin = _a3.transformOrigin, targetMatrix = _a3.targetMatrix, offsetMatrix = _a3.offsetMatrix, is3d = _a3.is3d, prevWidth = _a3.width, prevHeight = _a3.height, left = _a3.left, top = _a3.top;
  var n = is3d ? 4 : 3;
  var nextOrigin = calculateTransformOrigin(transformOrigin, width, height, prevWidth, prevHeight, prevOrigin);
  var groupLeft = groupable ? left : 0;
  var groupTop = groupable ? top : 0;
  var nextMatrix = getNextMatrix(offsetMatrix, targetMatrix, nextOrigin, n);
  var dist = getDist(fixedPosition, nextMatrix, width, height, n, fixedDirection);
  return minus(dist, [groupLeft, groupTop]);
}
function getAbsolutePosition(moveable, direction) {
  return getPosByDirection(getAbsolutePosesByState(moveable.state), direction);
}
var VERTICAL_NAMES = ["left", "right", "center"];
var HORIZONTAL_NAMES = ["top", "bottom", "middle"];
var VERTICAL_NAMES_MAP = {
  start: "left",
  end: "right",
  center: "center"
};
var HORIZONTAL_NAMES_MAP = {
  start: "top",
  end: "bottom",
  center: "middle"
};
function hasGuidelines(moveable, ableName) {
  var _a3 = moveable.props, snappable = _a3.snappable, bounds = _a3.bounds, innerBounds = _a3.innerBounds, verticalGuidelines = _a3.verticalGuidelines, horizontalGuidelines = _a3.horizontalGuidelines, snapGridWidth = _a3.snapGridWidth, snapGridHeight = _a3.snapGridHeight, _b3 = moveable.state, guidelines = _b3.guidelines, enableSnap = _b3.enableSnap;
  if (!snappable || !enableSnap || ableName && snappable !== true && snappable.indexOf(ableName) < 0) {
    return false;
  }
  if (snapGridWidth || snapGridHeight || bounds || innerBounds || guidelines && guidelines.length || verticalGuidelines && verticalGuidelines.length || horizontalGuidelines && horizontalGuidelines.length) {
    return true;
  }
  return false;
}
function getSnapDirections(snapDirections) {
  if (snapDirections === false) {
    return {};
  } else if (snapDirections === true || !snapDirections) {
    return {
      left: true,
      right: true,
      top: true,
      bottom: true
    };
  }
  return snapDirections;
}
function mapSnapDirectionPoses(snapDirections, snapPoses) {
  var nextSnapDirections = getSnapDirections(snapDirections);
  var nextSnapPoses = {};
  for (var name2 in nextSnapDirections) {
    if (name2 in snapPoses && nextSnapDirections[name2]) {
      nextSnapPoses[name2] = snapPoses[name2];
    }
  }
  return nextSnapPoses;
}
function splitSnapDirectionPoses(snapDirections, snapPoses) {
  var nextSnapPoses = mapSnapDirectionPoses(snapDirections, snapPoses);
  var horizontalNames = HORIZONTAL_NAMES.filter(function(name2) {
    return name2 in nextSnapPoses;
  });
  var verticalNames = VERTICAL_NAMES.filter(function(name2) {
    return name2 in nextSnapPoses;
  });
  return {
    horizontal: horizontalNames.map(function(name2) {
      return nextSnapPoses[name2];
    }),
    vertical: verticalNames.map(function(name2) {
      return nextSnapPoses[name2];
    })
  };
}
function getGapGuidelines(moveable, targetRect, snapThreshold) {
  var elementRects = moveable.state.elementRects;
  var gapGuidelines = [];
  [["vertical", VERTICAL_NAMES_MAP, HORIZONTAL_NAMES_MAP], ["horizontal", HORIZONTAL_NAMES_MAP, VERTICAL_NAMES_MAP]].forEach(function(_a3) {
    var type = _a3[0], mainNames = _a3[1], sideNames = _a3[2];
    var targetStart = targetRect[mainNames.start];
    var targetEnd = targetRect[mainNames.end];
    var targetCenter = targetRect[mainNames.center];
    var targetStart2 = targetRect[sideNames.start];
    var targetEnd2 = targetRect[sideNames.end];
    function getDist2(elementRect) {
      var rect = elementRect.rect;
      if (rect[mainNames.end] < targetStart + snapThreshold) {
        return targetStart - rect[mainNames.end];
      } else if (targetEnd - snapThreshold < rect[mainNames.start]) {
        return rect[mainNames.start] - targetEnd;
      } else {
        return -1;
      }
    }
    var nextElementRects = elementRects.filter(function(elementRect) {
      var rect = elementRect.rect;
      if (rect[sideNames.start] > targetEnd2 || rect[sideNames.end] < targetStart2) {
        return false;
      }
      return getDist2(elementRect) > 0;
    }).sort(function(a2, b2) {
      return getDist2(a2) - getDist2(b2);
    });
    var groups = [];
    nextElementRects.forEach(function(snapRect1) {
      nextElementRects.forEach(function(snapRect2) {
        if (snapRect1 === snapRect2) {
          return;
        }
        var rect1 = snapRect1.rect;
        var rect2 = snapRect2.rect;
        var rect1Start = rect1[sideNames.start];
        var rect1End = rect1[sideNames.end];
        var rect2Start = rect2[sideNames.start];
        var rect2End = rect2[sideNames.end];
        if (rect1Start > rect2End || rect2Start > rect1End) {
          return;
        }
        groups.push([snapRect1, snapRect2]);
      });
    });
    groups.forEach(function(_a4) {
      var snapRect1 = _a4[0], snapRect2 = _a4[1];
      var rect1 = snapRect1.rect;
      var rect2 = snapRect2.rect;
      var rect1Start = rect1[mainNames.start];
      var rect1End = rect1[mainNames.end];
      var rect2Start = rect2[mainNames.start];
      var rect2End = rect2[mainNames.end];
      var gap2 = 0;
      var pos = 0;
      var isStart = false;
      var isCenter = false;
      var isEnd = false;
      if (rect1End <= targetStart && targetEnd <= rect2Start) {
        isCenter = true;
        gap2 = (rect2Start - rect1End - (targetEnd - targetStart)) / 2;
        pos = rect1End + gap2 + (targetEnd - targetStart) / 2;
        if (Math.abs(pos - targetCenter) > snapThreshold) {
          return;
        }
      } else if (rect1End < rect2Start && rect2End < targetStart + snapThreshold) {
        isStart = true;
        gap2 = rect2Start - rect1End;
        pos = rect2End + gap2;
        if (Math.abs(pos - targetStart) > snapThreshold) {
          return;
        }
      } else if (rect1End < rect2Start && targetEnd - snapThreshold < rect1Start) {
        isEnd = true;
        gap2 = rect2Start - rect1End;
        pos = rect1Start - gap2;
        if (Math.abs(pos - targetEnd) > snapThreshold) {
          return;
        }
      } else {
        return;
      }
      if (!gap2) {
        return;
      }
      gapGuidelines.push({
        type,
        pos: type === "vertical" ? [pos, 0] : [0, pos],
        element: snapRect2.element,
        size: 0,
        className: snapRect2.className,
        isStart,
        isCenter,
        isEnd,
        gap: gap2,
        hide: true,
        gapRects: [snapRect1, snapRect2]
      });
    });
  });
  return gapGuidelines;
}
function getDefaultGuidelines(horizontalGuidelines, verticalGuidelines, width, height, clientLeft, clientTop, snapOffset) {
  if (clientLeft === void 0) {
    clientLeft = 0;
  }
  if (clientTop === void 0) {
    clientTop = 0;
  }
  if (snapOffset === void 0) {
    snapOffset = {
      left: 0,
      top: 0,
      right: 0,
      bottom: 0
    };
  }
  var guidelines = [];
  var snapOffsetLeft = snapOffset.left, snapOffsetTop = snapOffset.top, snapOffsetBottom = snapOffset.bottom, snapOffsetRight = snapOffset.right;
  var snapWidth = width + snapOffsetRight - snapOffsetLeft;
  var snapHeight = height + snapOffsetBottom - snapOffsetTop;
  horizontalGuidelines && horizontalGuidelines.forEach(function(pos) {
    guidelines.push({
      type: "horizontal",
      pos: [snapOffsetLeft, throttle(pos - clientTop + snapOffsetTop, 0.1)],
      size: snapWidth
    });
  });
  verticalGuidelines && verticalGuidelines.forEach(function(pos) {
    guidelines.push({
      type: "vertical",
      pos: [throttle(pos - clientLeft + snapOffsetLeft, 0.1), snapOffsetTop],
      size: snapHeight
    });
  });
  return guidelines;
}
function calculateContainerPos(rootMatrix, containerRect, n) {
  var clientPos = calculatePosition(rootMatrix, [containerRect.clientLeft, containerRect.clientTop], n);
  return [containerRect.left + clientPos[0], containerRect.top + clientPos[1]];
}
function getSnapElementRects(moveable, values) {
  if (!values.length) {
    return [];
  }
  var state = moveable.state;
  var containerClientRect = state.containerClientRect, _a3 = state.targetClientRect, clientTop = _a3.top, clientLeft = _a3.left, rootMatrix = state.rootMatrix, is3d = state.is3d;
  var n = is3d ? 4 : 3;
  var _b3 = calculateContainerPos(rootMatrix, containerClientRect, n), containerLeft = _b3[0], containerTop = _b3[1];
  var poses = getAbsolutePosesByState(state);
  var _c3 = getMinMaxs(poses), targetLeft = _c3.minX, targetTop = _c3.minY;
  var _d2 = minus([targetLeft, targetTop], calculateInversePosition(rootMatrix, [clientLeft - containerLeft, clientTop - containerTop], n)).map(function(pos) {
    return roundSign(pos);
  }), distLeft = _d2[0], distTop = _d2[1];
  return values.map(function(value) {
    var rect = value.element.getBoundingClientRect();
    var left = rect.left - containerLeft;
    var top = rect.top - containerTop;
    var bottom = top + rect.height;
    var right = left + rect.width;
    var _a4 = calculateInversePosition(rootMatrix, [left, top], n), elementLeft = _a4[0], elementTop = _a4[1];
    var _b4 = calculateInversePosition(rootMatrix, [right, bottom], n), elementRight = _b4[0], elementBottom = _b4[1];
    return __assign$2(__assign$2({}, value), {
      rect: {
        left: elementLeft + distLeft,
        right: elementRight + distLeft,
        top: elementTop + distTop,
        bottom: elementBottom + distTop,
        center: (elementLeft + elementRight) / 2 + distLeft,
        middle: (elementTop + elementBottom) / 2 + distTop
      }
    });
  });
}
function getElementGuidelines(moveable) {
  var state = moveable.state;
  var _a3 = moveable.props.elementGuidelines, elementGuidelines = _a3 === void 0 ? [] : _a3;
  if (!elementGuidelines.length) {
    state.elementRects = [];
    return [];
  }
  var prevValues = (state.elementRects || []).filter(function(snapRect) {
    return !snapRect.refresh;
  });
  var nextElementGuidelines = elementGuidelines.map(function(el) {
    if (isObject$2(el) && "element" in el) {
      return el;
    }
    return {
      element: getRefTarget(el, true)
    };
  }).filter(function(value) {
    return value.element;
  });
  var _b3 = diff(prevValues.map(function(v2) {
    return v2.element;
  }), nextElementGuidelines.map(function(v2) {
    return v2.element;
  })), maintained = _b3.maintained, added = _b3.added;
  var nextValues = [];
  maintained.forEach(function(_a4) {
    var prevIndex = _a4[0], nextIndex = _a4[1];
    nextValues[nextIndex] = prevValues[prevIndex];
  });
  getSnapElementRects(moveable, added.map(function(index) {
    return nextElementGuidelines[index];
  })).map(function(rect, i2) {
    nextValues[added[i2]] = rect;
  });
  state.elementRects = nextValues;
  var elementSnapDirections = getSnapDirections(moveable.props.elementSnapDirections);
  var nextGuidelines = [];
  nextValues.forEach(function(snapRect) {
    var element = snapRect.element, _a4 = snapRect.top, topValue = _a4 === void 0 ? elementSnapDirections.top : _a4, _b4 = snapRect.left, leftValue = _b4 === void 0 ? elementSnapDirections.left : _b4, _c3 = snapRect.right, rightValue = _c3 === void 0 ? elementSnapDirections.right : _c3, _d2 = snapRect.bottom, bottomValue = _d2 === void 0 ? elementSnapDirections.bottom : _d2, _e = snapRect.center, centerValue = _e === void 0 ? elementSnapDirections.center : _e, _f = snapRect.middle, middleValue = _f === void 0 ? elementSnapDirections.middle : _f, className = snapRect.className, rect = snapRect.rect;
    var _g = splitSnapDirectionPoses({
      top: topValue,
      right: rightValue,
      left: leftValue,
      bottom: bottomValue,
      center: centerValue,
      middle: middleValue
    }, rect), horizontal = _g.horizontal, vertical = _g.vertical;
    var rectTop = rect.top;
    var rectLeft = rect.left;
    var width = rect.right - rectLeft;
    var height = rect.bottom - rectTop;
    var sizes = [width, height];
    vertical.forEach(function(pos) {
      nextGuidelines.push({
        type: "vertical",
        element,
        pos: [throttle(pos, 0.1), rectTop],
        size: height,
        sizes,
        className,
        elementRect: snapRect
      });
    });
    horizontal.forEach(function(pos) {
      nextGuidelines.push({
        type: "horizontal",
        element,
        pos: [rectLeft, throttle(pos, 0.1)],
        size: width,
        sizes,
        className,
        elementRect: snapRect
      });
    });
  });
  return nextGuidelines;
}
function getTotalGuidelines(moveable) {
  var _a3 = moveable.state, snapOffset = _a3.snapOffset, _b3 = _a3.containerClientRect, overflow = _b3.overflow, containerHeight = _b3.scrollHeight, containerWidth = _b3.scrollWidth, containerClientHeight = _b3.clientHeight, containerClientWidth = _b3.clientWidth, clientLeft = _b3.clientLeft, clientTop = _b3.clientTop;
  var _c3 = moveable.props, _d2 = _c3.snapGap, snapGap = _d2 === void 0 ? true : _d2, verticalGuidelines = _c3.verticalGuidelines, horizontalGuidelines = _c3.horizontalGuidelines, _e = _c3.snapThreshold, snapThreshold = _e === void 0 ? 5 : _e, _f = _c3.snapGridWidth, snapGridWidth = _f === void 0 ? 0 : _f, _g = _c3.snapGridHeight, snapGridHeight = _g === void 0 ? 0 : _g;
  var elementGuidelines = getElementGuidelines(moveable);
  var totalGuidelines = __spreadArray([], elementGuidelines);
  if (snapGap) {
    var _h = getRect(getAbsolutePosesByState(moveable.state)), top = _h.top, left = _h.left, bottom = _h.bottom, right = _h.right;
    totalGuidelines.push.apply(totalGuidelines, getGapGuidelines(moveable, {
      top,
      left,
      bottom,
      right,
      center: (left + right) / 2,
      middle: (top + bottom) / 2
    }, snapThreshold));
  }
  totalGuidelines.push.apply(totalGuidelines, getGridGuidelines(snapGridWidth, snapGridHeight, overflow ? containerWidth : containerClientWidth, overflow ? containerHeight : containerClientHeight, clientLeft, clientTop));
  totalGuidelines.push.apply(totalGuidelines, getDefaultGuidelines(horizontalGuidelines || false, verticalGuidelines || false, overflow ? containerWidth : containerClientWidth, overflow ? containerHeight : containerClientHeight, clientLeft, clientTop, snapOffset));
  return totalGuidelines;
}
function getGridGuidelines(snapGridWidth, snapGridHeight, containerWidth, containerHeight, clientLeft, clientTop) {
  if (clientLeft === void 0) {
    clientLeft = 0;
  }
  if (clientTop === void 0) {
    clientTop = 0;
  }
  var guidelines = [];
  if (snapGridHeight) {
    for (var pos = 0; pos <= containerHeight; pos += snapGridHeight) {
      guidelines.push({
        type: "horizontal",
        pos: [0, throttle(pos - clientTop, 0.1)],
        size: containerWidth,
        hide: true
      });
    }
  }
  if (snapGridWidth) {
    for (var pos = 0; pos <= containerWidth; pos += snapGridWidth) {
      guidelines.push({
        type: "vertical",
        pos: [throttle(pos - clientLeft, 0.1), 0],
        size: containerHeight,
        hide: true
      });
    }
  }
  return guidelines;
}
function checkMoveableSnapPoses(moveable, posesX, posesY, customSnapThreshold) {
  var props = moveable.props;
  var snapThreshold = selectValue(customSnapThreshold, props.snapThreshold, 5);
  return checkSnapPoses(moveable.state.guidelines, posesX, posesY, snapThreshold);
}
function checkSnapPoses(guidelines, posesX, posesY, snapThreshold) {
  return {
    vertical: checkSnap(guidelines, "vertical", posesX, snapThreshold),
    horizontal: checkSnap(guidelines, "horizontal", posesY, snapThreshold)
  };
}
function checkSnapKeepRatio(moveable, startPos, endPos) {
  var endX = endPos[0], endY = endPos[1];
  var startX = startPos[0], startY = startPos[1];
  var _a3 = minus(endPos, startPos), dx = _a3[0], dy = _a3[1];
  var isBottom = dy > 0;
  var isRight = dx > 0;
  dx = getTinyDist(dx);
  dy = getTinyDist(dy);
  var verticalInfo = {
    isSnap: false,
    offset: 0,
    pos: 0
  };
  var horizontalInfo = {
    isSnap: false,
    offset: 0,
    pos: 0
  };
  if (dx === 0 && dy === 0) {
    return {
      vertical: verticalInfo,
      horizontal: horizontalInfo
    };
  }
  var _b3 = checkMoveableSnapPoses(moveable, dx ? [endX] : [], dy ? [endY] : []), verticalSnapInfo = _b3.vertical, horizontalSnapInfo = _b3.horizontal;
  verticalSnapInfo.posInfos.filter(function(_a4) {
    var pos = _a4.pos;
    return isRight ? pos >= startX : pos <= startX;
  });
  horizontalSnapInfo.posInfos.filter(function(_a4) {
    var pos = _a4.pos;
    return isBottom ? pos >= startY : pos <= startY;
  });
  verticalSnapInfo.isSnap = verticalSnapInfo.posInfos.length > 0;
  horizontalSnapInfo.isSnap = horizontalSnapInfo.posInfos.length > 0;
  var _c3 = getNearestSnapGuidelineInfo(verticalSnapInfo), isVerticalSnap = _c3.isSnap, verticalGuideline = _c3.guideline;
  var _d2 = getNearestSnapGuidelineInfo(horizontalSnapInfo), isHorizontalSnap = _d2.isSnap, horizontalGuideline = _d2.guideline;
  var horizontalPos = isHorizontalSnap ? horizontalGuideline.pos[1] : 0;
  var verticalPos = isVerticalSnap ? verticalGuideline.pos[0] : 0;
  if (dx === 0) {
    if (isHorizontalSnap) {
      horizontalInfo.isSnap = true;
      horizontalInfo.pos = horizontalGuideline.pos[1];
      horizontalInfo.offset = endY - horizontalInfo.pos;
    }
  } else if (dy === 0) {
    if (isVerticalSnap) {
      verticalInfo.isSnap = true;
      verticalInfo.pos = verticalPos;
      verticalInfo.offset = endX - verticalPos;
    }
  } else {
    var a2 = dy / dx;
    var b2 = endPos[1] - a2 * endX;
    var y2 = 0;
    var x2 = 0;
    var isSnap = false;
    if (isVerticalSnap) {
      x2 = verticalPos;
      y2 = a2 * x2 + b2;
      isSnap = true;
    } else if (isHorizontalSnap) {
      y2 = horizontalPos;
      x2 = (y2 - b2) / a2;
      isSnap = true;
    }
    if (isSnap) {
      verticalInfo.isSnap = true;
      verticalInfo.pos = x2;
      verticalInfo.offset = endX - x2;
      horizontalInfo.isSnap = true;
      horizontalInfo.pos = y2;
      horizontalInfo.offset = endY - y2;
    }
  }
  return {
    vertical: verticalInfo,
    horizontal: horizontalInfo
  };
}
function checkSnaps(moveable, rect, customSnapThreshold) {
  var poses = splitSnapDirectionPoses(moveable.props.snapDirections, rect);
  return checkMoveableSnapPoses(moveable, poses.vertical, poses.horizontal, customSnapThreshold);
}
function getNearestSnapGuidelineInfo(snapInfo) {
  var isSnap = snapInfo.isSnap;
  if (!isSnap) {
    return {
      isSnap: false,
      offset: 0,
      dist: -1,
      pos: 0,
      guideline: null
    };
  }
  var posInfo = snapInfo.posInfos[0];
  var guidelineInfo = posInfo.guidelineInfos[0];
  var offset = guidelineInfo.offset;
  var dist = guidelineInfo.dist;
  var guideline = guidelineInfo.guideline;
  return {
    isSnap,
    offset,
    dist,
    pos: posInfo.pos,
    guideline
  };
}
function checkSnap(guidelines, targetType, targetPoses, snapThreshold) {
  if (!guidelines || !guidelines.length) {
    return {
      isSnap: false,
      index: -1,
      posInfos: []
    };
  }
  var isVertical = targetType === "vertical";
  var posType = isVertical ? 0 : 1;
  var snapPosInfos = targetPoses.map(function(targetPos, index) {
    var guidelineInfos = guidelines.map(function(guideline) {
      var pos = guideline.pos;
      var offset = targetPos - pos[posType];
      return {
        offset,
        dist: Math.abs(offset),
        guideline
      };
    }).filter(function(_a3) {
      var guideline = _a3.guideline, dist = _a3.dist;
      var type = guideline.type;
      if (type !== targetType || dist > snapThreshold) {
        return false;
      }
      return true;
    }).sort(function(a2, b2) {
      return a2.dist - b2.dist;
    });
    return {
      pos: targetPos,
      index,
      guidelineInfos
    };
  }).filter(function(snapPosInfo) {
    return snapPosInfo.guidelineInfos.length > 0;
  }).sort(function(a2, b2) {
    return a2.guidelineInfos[0].dist - b2.guidelineInfos[0].dist;
  });
  var isSnap = snapPosInfos.length > 0;
  return {
    isSnap,
    index: isSnap ? snapPosInfos[0].index : -1,
    posInfos: snapPosInfos
  };
}
function getSnapInfosByDirection(moveable, poses, snapDirection) {
  var nextPoses = [];
  if (snapDirection[0] && snapDirection[1]) {
    nextPoses = [snapDirection, [-snapDirection[0], snapDirection[1]], [snapDirection[0], -snapDirection[1]]].map(function(direction) {
      return getPosByDirection(poses, direction);
    });
  } else if (!snapDirection[0] && !snapDirection[1]) {
    var alignPoses = [poses[0], poses[1], poses[3], poses[2], poses[0]];
    for (var i2 = 0; i2 < 4; ++i2) {
      nextPoses.push(alignPoses[i2]);
      nextPoses.push([(alignPoses[i2][0] + alignPoses[i2 + 1][0]) / 2, (alignPoses[i2][1] + alignPoses[i2 + 1][1]) / 2]);
    }
  } else {
    if (moveable.props.keepRatio) {
      nextPoses = [[-1, -1], [-1, 1], [1, -1], [1, 1], snapDirection].map(function(dir) {
        return getPosByDirection(poses, dir);
      });
    } else {
      nextPoses = getPosesByDirection(poses, snapDirection);
      if (nextPoses.length > 1) {
        nextPoses.push([(nextPoses[0][0] + nextPoses[1][0]) / 2, (nextPoses[0][1] + nextPoses[1][1]) / 2]);
      }
    }
  }
  return checkMoveableSnapPoses(moveable, nextPoses.map(function(pos) {
    return pos[0];
  }), nextPoses.map(function(pos) {
    return pos[1];
  }), 1);
}
function checkSnapBoundPriority(a2, b2) {
  var aDist = Math.abs(a2.offset);
  var bDist = Math.abs(b2.offset);
  if (a2.isBound && b2.isBound) {
    return bDist - aDist;
  } else if (a2.isBound) {
    return -1;
  } else if (b2.isBound) {
    return 1;
  } else if (a2.isSnap && b2.isSnap) {
    return bDist - aDist;
  } else if (a2.isSnap) {
    return -1;
  } else if (b2.isSnap) {
    return 1;
  } else if (aDist < TINY_NUM) {
    return 1;
  } else if (bDist < TINY_NUM) {
    return -1;
  }
  return aDist - bDist;
}
function getNearOffsetInfo(offsets, index) {
  return offsets.slice().sort(function(a2, b2) {
    var aSign = a2.sign[index];
    var bSign = b2.sign[index];
    var aOffset = a2.offset[index];
    var bOffset = b2.offset[index];
    if (!aSign) {
      return 1;
    } else if (!bSign) {
      return -1;
    }
    return checkSnapBoundPriority({
      isBound: a2.isBound,
      isSnap: a2.isSnap,
      offset: aOffset
    }, {
      isBound: b2.isBound,
      isSnap: b2.isSnap,
      offset: bOffset
    });
  })[0];
}
function getCheckSnapDirections(direction, keepRatio) {
  var directions = [];
  var fixedDirection = [-direction[0], -direction[1]];
  if (direction[0] && direction[1]) {
    directions.push([fixedDirection, [direction[0], -direction[1]]], [fixedDirection, [-direction[0], direction[1]]]);
    if (keepRatio) {
      directions.push([fixedDirection, direction]);
    }
  } else if (direction[0]) {
    if (keepRatio) {
      directions.push([fixedDirection, [fixedDirection[0], -1]], [fixedDirection, [fixedDirection[0], 1]], [fixedDirection, [direction[0], -1]], [fixedDirection, direction], [fixedDirection, [direction[0], 1]]);
    } else {
      directions.push([[fixedDirection[0], -1], [direction[0], -1]], [[fixedDirection[0], 0], [direction[0], 0]], [[fixedDirection[0], 1], [direction[0], 1]]);
    }
  } else if (direction[1]) {
    if (keepRatio) {
      directions.push([fixedDirection, [-1, fixedDirection[1]]], [fixedDirection, [1, fixedDirection[1]]], [fixedDirection, [-1, direction[1]]], [fixedDirection, [1, direction[1]]], [fixedDirection, direction]);
    } else {
      directions.push([[-1, fixedDirection[1]], [-1, direction[1]]], [[0, fixedDirection[1]], [0, direction[1]]], [[1, fixedDirection[1]], [1, direction[1]]]);
    }
  } else {
    directions.push([fixedDirection, [1, 0]], [fixedDirection, [-1, 0]], [fixedDirection, [0, -1]], [fixedDirection, [0, 1]], [[1, 0], [1, -1]], [[1, 0], [1, 1]], [[0, 1], [1, 1]], [[0, 1], [-1, 1]], [[-1, 0], [-1, -1]], [[-1, 0], [-1, 1]], [[0, -1], [1, -1]], [[0, -1], [-1, -1]]);
  }
  return directions;
}
function isStartLine(dot2, line) {
  var cx = average([line[0][0], line[1][0]]);
  var cy = average([line[0][1], line[1][1]]);
  return {
    vertical: cx <= dot2[0],
    horizontal: cy <= dot2[1]
  };
}
function hitTestLine(dot2, _a3) {
  var pos1 = _a3[0], pos2 = _a3[1];
  var dx = pos2[0] - pos1[0];
  var dy = pos2[1] - pos1[1];
  if (Math.abs(dx) < TINY_NUM) {
    dx = 0;
  }
  if (Math.abs(dy) < TINY_NUM) {
    dy = 0;
  }
  var test1;
  var test2;
  if (!dx) {
    test1 = pos1[0];
    test2 = dot2[0];
  } else if (!dy) {
    test1 = pos1[1];
    test2 = dot2[1];
  } else {
    var a2 = dy / dx;
    test1 = a2 * (dot2[0] - pos1[0]) + pos1[1];
    test2 = dot2[1];
  }
  return test1 - test2;
}
function isSameStartLine(dots, line, error) {
  if (error === void 0) {
    error = TINY_NUM;
  }
  var centerSign = hitTestLine(dots[0], line) <= 0;
  return dots.slice(1).every(function(dot2) {
    var value = hitTestLine(dot2, line);
    var sign2 = value <= 0;
    return sign2 === centerSign || Math.abs(value) <= error;
  });
}
function checkInnerBoundDot(pos, start, end, isStart, threshold2) {
  if (threshold2 === void 0) {
    threshold2 = 0;
  }
  if (isStart && start - threshold2 <= pos || !isStart && pos <= end + threshold2) {
    return {
      isBound: true,
      offset: isStart ? start - pos : end - pos
    };
  }
  return {
    isBound: false,
    offset: 0
  };
}
function checkInnerBound(moveable, line, center) {
  var bounds = moveable.props.innerBounds;
  if (!bounds) {
    return {
      isAllBound: false,
      isBound: false,
      isVerticalBound: false,
      isHorizontalBound: false,
      offset: [0, 0]
    };
  }
  var left = bounds.left, top = bounds.top, width = bounds.width, height = bounds.height;
  var leftLine = [[left, top], [left, top + height]];
  var topLine = [[left, top], [left + width, top]];
  var rightLine = [[left + width, top], [left + width, top + height]];
  var bottomLine = [[left, top + height], [left + width, top + height]];
  var _a3 = isStartLine(center, line), isHorizontalStart = _a3.horizontal, isVerticalStart = _a3.vertical;
  if (isSameStartLine([center, [left, top], [left + width, top], [left, top + height], [left + width, top + height]], line)) {
    return {
      isAllBound: false,
      isBound: false,
      isVerticalBound: false,
      isHorizontalBound: false,
      offset: [0, 0]
    };
  }
  var topBoundInfo = checkLineBoundCollision(line, topLine, isVerticalStart);
  var bottomBoundInfo = checkLineBoundCollision(line, bottomLine, isVerticalStart);
  var leftBoundInfo = checkLineBoundCollision(line, leftLine, isHorizontalStart);
  var rightBoundInfo = checkLineBoundCollision(line, rightLine, isHorizontalStart);
  var isAllVerticalBound = topBoundInfo.isBound && bottomBoundInfo.isBound;
  var isVerticalBound = topBoundInfo.isBound || bottomBoundInfo.isBound;
  var isAllHorizontalBound = leftBoundInfo.isBound && rightBoundInfo.isBound;
  var isHorizontalBound = leftBoundInfo.isBound || rightBoundInfo.isBound;
  var verticalOffset = maxOffset(topBoundInfo.offset, bottomBoundInfo.offset);
  var horizontalOffset = maxOffset(leftBoundInfo.offset, rightBoundInfo.offset);
  var offset = [0, 0];
  var isBound = false;
  var isAllBound = false;
  if (Math.abs(horizontalOffset) < Math.abs(verticalOffset)) {
    offset = [verticalOffset, 0];
    isBound = isVerticalBound;
    isAllBound = isAllVerticalBound;
  } else {
    offset = [0, horizontalOffset];
    isBound = isHorizontalBound;
    isAllBound = isAllHorizontalBound;
  }
  return {
    isAllBound,
    isVerticalBound,
    isHorizontalBound,
    isBound,
    offset
  };
}
function checkLineBoundCollision(line, boundLine, isStart, threshold2, isRender) {
  var dot1 = line[0];
  var dot2 = line[1];
  var boundDot1 = boundLine[0];
  var boundDot2 = boundLine[1];
  var dy1 = getTinyDist(dot2[1] - dot1[1]);
  var dx1 = getTinyDist(dot2[0] - dot1[0]);
  var dy2 = getTinyDist(boundDot2[1] - boundDot1[1]);
  var dx2 = getTinyDist(boundDot2[0] - boundDot1[0]);
  if (!dx2) {
    if (isRender && !dy1) {
      return {
        isBound: false,
        offset: 0
      };
    } else if (dx1) {
      var y2 = dy1 / dx1 * (boundDot1[0] - dot1[0]) + dot1[1];
      return checkInnerBoundDot(y2, boundDot1[1], boundDot2[1], isStart, threshold2);
    } else {
      var offset = boundDot1[0] - dot1[0];
      var isBound = Math.abs(offset) <= (threshold2 || 0);
      return {
        isBound,
        offset: isBound ? offset : 0
      };
    }
  } else if (!dy2) {
    if (isRender && !dx1) {
      return {
        isBound: false,
        offset: 0
      };
    } else if (dy1) {
      var x2 = (boundDot1[1] - dot1[1]) / (dy1 / dx1) + dot1[0];
      return checkInnerBoundDot(x2, boundDot1[0], boundDot2[0], isStart, threshold2);
    } else {
      var offset = boundDot1[1] - dot1[1];
      var isBound = Math.abs(offset) <= (threshold2 || 0);
      return {
        isBound,
        offset: isBound ? offset : 0
      };
    }
  }
  return {
    isBound: false,
    offset: 0
  };
}
function getInnerBoundInfo(moveable, lines, center, datas) {
  return lines.map(function(_a3) {
    var multiple = _a3[0], pos1 = _a3[1], pos2 = _a3[2];
    var _b3 = checkInnerBound(moveable, [pos1, pos2], center), isBound = _b3.isBound, offset = _b3.offset, isVerticalBound = _b3.isVerticalBound, isHorizontalBound = _b3.isHorizontalBound;
    var sizeOffset = getDragDist({
      datas,
      distX: offset[0],
      distY: offset[1]
    }).map(function(size, i2) {
      return size * (multiple[i2] ? 2 / multiple[i2] : 0);
    });
    return {
      sign: multiple,
      isBound,
      isVerticalBound,
      isHorizontalBound,
      isSnap: false,
      offset: sizeOffset
    };
  });
}
function getInnerBoundDragInfo(moveable, poses, datas) {
  var _a3;
  var lines = getCheckInnerBoundLines(poses, [0, 0], false).map(function(_a4) {
    var sign2 = _a4[0], pos1 = _a4[1], pos2 = _a4[2];
    return [sign2.map(function(dir) {
      return Math.abs(dir) * 2;
    }), pos1, pos2];
  });
  var innerBoundInfo = getInnerBoundInfo(moveable, lines, getPosByDirection(poses, [0, 0]), datas);
  var widthOffsetInfo = getNearOffsetInfo(innerBoundInfo, 0);
  var heightOffsetInfo = getNearOffsetInfo(innerBoundInfo, 1);
  var verticalOffset = 0;
  var horizontalOffset = 0;
  var isVerticalBound = widthOffsetInfo.isVerticalBound || heightOffsetInfo.isVerticalBound;
  var isHorizontalBound = widthOffsetInfo.isHorizontalBound || heightOffsetInfo.isHorizontalBound;
  if (isVerticalBound || isHorizontalBound) {
    _a3 = getInverseDragDist({
      datas,
      distX: -widthOffsetInfo.offset[0],
      distY: -heightOffsetInfo.offset[1]
    }), verticalOffset = _a3[0], horizontalOffset = _a3[1];
  }
  return {
    vertical: {
      isBound: isVerticalBound,
      offset: verticalOffset
    },
    horizontal: {
      isBound: isHorizontalBound,
      offset: horizontalOffset
    }
  };
}
function getCheckSnapLineDirections(direction, keepRatio) {
  var lineDirections = [];
  var x2 = direction[0];
  var y2 = direction[1];
  if (x2 && y2) {
    lineDirections.push([[0, y2 * 2], direction, [-x2, y2]], [[x2 * 2, 0], direction, [x2, -y2]]);
  } else if (x2) {
    lineDirections.push([[x2 * 2, 0], [x2, 1], [x2, -1]]);
    if (keepRatio) {
      lineDirections.push([[0, -1], [x2, -1], [-x2, -1]], [[0, 1], [x2, 1], [-x2, 1]]);
    }
  } else if (y2) {
    lineDirections.push([[0, y2 * 2], [1, y2], [-1, y2]]);
    if (keepRatio) {
      lineDirections.push([[-1, 0], [-1, y2], [-1, -y2]], [[1, 0], [1, y2], [1, -y2]]);
    }
  } else {
    lineDirections.push([[-1, 0], [-1, -1], [-1, 1]], [[1, 0], [1, -1], [1, 1]], [[0, -1], [-1, -1], [1, -1]], [[0, 1], [-1, 1], [1, 1]]);
  }
  return lineDirections;
}
function getCheckInnerBoundLines(poses, direction, keepRatio) {
  return getCheckSnapLineDirections(direction, keepRatio).map(function(_a3) {
    var sign2 = _a3[0], dir1 = _a3[1], dir2 = _a3[2];
    return [sign2, getPosByDirection(poses, dir1), getPosByDirection(poses, dir2)];
  });
}
function isBoundRotate(relativePoses, boundDots, center, rad) {
  var nextPoses = rad ? relativePoses.map(function(pos) {
    return rotate(pos, rad);
  }) : relativePoses;
  var dots = __spreadArray([center], boundDots);
  return [[nextPoses[0], nextPoses[1]], [nextPoses[1], nextPoses[3]], [nextPoses[3], nextPoses[2]], [nextPoses[2], nextPoses[0]]].some(function(line) {
    return !isSameStartLine(dots, line);
  });
}
function getDistPointLine(_a3) {
  var pos1 = _a3[0], pos2 = _a3[1];
  var dx = pos2[0] - pos1[0];
  var dy = pos2[1] - pos1[1];
  if (!dx) {
    return Math.abs(pos1[0]);
  }
  if (!dy) {
    return Math.abs(pos1[1]);
  }
  var a2 = dy / dx;
  return Math.abs((-a2 * pos1[0] + pos1[1]) / Math.sqrt(Math.pow(a2, 2) + 1));
}
function solveReverseLine(_a3) {
  var pos1 = _a3[0], pos2 = _a3[1];
  var dx = pos2[0] - pos1[0];
  var dy = pos2[1] - pos1[1];
  if (!dx) {
    return [pos1[0], 0];
  }
  if (!dy) {
    return [0, pos1[1]];
  }
  var a2 = dy / dx;
  var b2 = -a2 * pos1[0] + pos1[1];
  return [-b2 / (a2 + 1 / a2), b2 / (a2 * a2 + 1)];
}
function checkRotateInnerBounds(moveable, prevPoses, nextPoses, origin, rotation) {
  var bounds = moveable.props.innerBounds;
  var rad = rotation * Math.PI / 180;
  if (!bounds) {
    return [];
  }
  var left = bounds.left, top = bounds.top, width = bounds.width, height = bounds.height;
  var relativeLeft = left - origin[0];
  var relativeRight = left + width - origin[0];
  var relativeTop = top - origin[1];
  var relativeBottom = top + height - origin[1];
  var dots = [[relativeLeft, relativeTop], [relativeRight, relativeTop], [relativeLeft, relativeBottom], [relativeRight, relativeBottom]];
  var center = getPosByDirection(nextPoses, [0, 0]);
  if (!isBoundRotate(nextPoses, dots, center, 0)) {
    return [];
  }
  var result = [];
  var dotInfos = dots.map(function(dot2) {
    return [getDistSize(dot2), getRad$1([0, 0], dot2)];
  });
  [[nextPoses[0], nextPoses[1]], [nextPoses[1], nextPoses[3]], [nextPoses[3], nextPoses[2]], [nextPoses[2], nextPoses[0]]].forEach(function(line) {
    var lineRad = getRad$1([0, 0], solveReverseLine(line));
    var lineDist = getDistPointLine(line);
    result.push.apply(result, dotInfos.filter(function(_a3) {
      var dotDist = _a3[0];
      return dotDist && lineDist <= dotDist;
    }).map(function(_a3) {
      var dotDist = _a3[0], dotRad = _a3[1];
      var distRad = Math.acos(dotDist ? lineDist / dotDist : 0);
      var nextRad1 = dotRad + distRad;
      var nextRad2 = dotRad - distRad;
      return [rad + nextRad1 - lineRad, rad + nextRad2 - lineRad];
    }).reduce(function(prev2, cur) {
      prev2.push.apply(prev2, cur);
      return prev2;
    }, []).filter(function(nextRad) {
      return !isBoundRotate(prevPoses, dots, center, nextRad);
    }).map(function(nextRad) {
      return throttle(nextRad * 180 / Math.PI, TINY_NUM);
    }));
  });
  return result;
}
function checkInnerBoundPoses(moveable) {
  var innerBounds = moveable.props.innerBounds;
  if (!innerBounds) {
    return {
      vertical: [],
      horizontal: []
    };
  }
  var _a3 = moveable.getRect(), pos1 = _a3.pos1, pos2 = _a3.pos2, pos3 = _a3.pos3, pos4 = _a3.pos4;
  var poses = [pos1, pos2, pos3, pos4];
  var center = getPosByDirection(poses, [0, 0]);
  var left = innerBounds.left, top = innerBounds.top, width = innerBounds.width, height = innerBounds.height;
  var leftLine = [[left, top], [left, top + height]];
  var topLine = [[left, top], [left + width, top]];
  var rightLine = [[left + width, top], [left + width, top + height]];
  var bottomLine = [[left, top + height], [left + width, top + height]];
  var lines = [[pos1, pos2], [pos2, pos4], [pos4, pos3], [pos3, pos1]];
  var horizontalPoses = [];
  var verticalPoses = [];
  var boundMap = {
    top: false,
    bottom: false,
    left: false,
    right: false
  };
  lines.forEach(function(line) {
    var _a4 = isStartLine(center, line), isHorizontalStart = _a4.horizontal, isVerticalStart = _a4.vertical;
    var topBoundInfo = checkLineBoundCollision(line, topLine, isVerticalStart, 1, true);
    var bottomBoundInfo = checkLineBoundCollision(line, bottomLine, isVerticalStart, 1, true);
    var leftBoundInfo = checkLineBoundCollision(line, leftLine, isHorizontalStart, 1, true);
    var rightBoundInfo = checkLineBoundCollision(line, rightLine, isHorizontalStart, 1, true);
    if (topBoundInfo.isBound && !boundMap.top) {
      horizontalPoses.push(top);
      boundMap.top = true;
    }
    if (bottomBoundInfo.isBound && !boundMap.bottom) {
      horizontalPoses.push(top + height);
      boundMap.bottom = true;
    }
    if (leftBoundInfo.isBound && !boundMap.left) {
      verticalPoses.push(left);
      boundMap.left = true;
    }
    if (rightBoundInfo.isBound && !boundMap.right) {
      verticalPoses.push(left + width);
      boundMap.right = true;
    }
  });
  return {
    horizontal: horizontalPoses,
    vertical: verticalPoses
  };
}
function checkBoundPoses(bounds, verticalPoses, horizontalPoses) {
  var _a3 = bounds || {}, _b3 = _a3.position, position = _b3 === void 0 ? "client" : _b3, _c3 = _a3.left, left = _c3 === void 0 ? -Infinity : _c3, _d2 = _a3.top, top = _d2 === void 0 ? -Infinity : _d2, _e = _a3.right, right = _e === void 0 ? Infinity : _e, _f = _a3.bottom, bottom = _f === void 0 ? Infinity : _f;
  var nextBounds = {
    position,
    left,
    top,
    right,
    bottom
  };
  return {
    vertical: checkBounds(nextBounds, verticalPoses, true),
    horizontal: checkBounds(nextBounds, horizontalPoses, false)
  };
}
function getBounds(moveable, externalBounds) {
  var _a3 = moveable.state, _b3 = _a3.containerClientRect, containerHeight = _b3.clientHeight, containerWidth = _b3.clientWidth, clientLeft = _b3.clientLeft, clientTop = _b3.clientTop, _c3 = _a3.snapOffset, snapOffsetLeft = _c3.left, snapOffsetTop = _c3.top, snapOffsetRight = _c3.right, snapOffsetBottom = _c3.bottom;
  var bounds = externalBounds || moveable.props.bounds || {};
  var position = bounds.position || "client";
  var isCSS = position === "css";
  var _d2 = bounds.left, left = _d2 === void 0 ? -Infinity : _d2, _e = bounds.top, top = _e === void 0 ? -Infinity : _e;
  var _f = bounds.right, right = _f === void 0 ? isCSS ? -Infinity : Infinity : _f, _g = bounds.bottom, bottom = _g === void 0 ? isCSS ? -Infinity : Infinity : _g;
  if (isCSS) {
    right = containerWidth + snapOffsetRight - snapOffsetLeft - right;
    bottom = containerHeight + snapOffsetBottom - snapOffsetTop - bottom;
  }
  return {
    left: left + snapOffsetLeft - clientLeft,
    right: right + snapOffsetLeft - clientLeft,
    top: top + snapOffsetTop - clientTop,
    bottom: bottom + snapOffsetTop - clientTop
  };
}
function checkBoundKeepRatio(moveable, startPos, endPos) {
  var _a3 = getBounds(moveable), left = _a3.left, top = _a3.top, right = _a3.right, bottom = _a3.bottom;
  var endX = endPos[0], endY = endPos[1];
  var _b3 = minus(endPos, startPos), dx = _b3[0], dy = _b3[1];
  if (Math.abs(dx) < TINY_NUM) {
    dx = 0;
  }
  if (Math.abs(dy) < TINY_NUM) {
    dy = 0;
  }
  var isBottom = dy > 0;
  var isRight = dx > 0;
  var verticalInfo = {
    isBound: false,
    offset: 0,
    pos: 0
  };
  var horizontalInfo = {
    isBound: false,
    offset: 0,
    pos: 0
  };
  if (dx === 0 && dy === 0) {
    return {
      vertical: verticalInfo,
      horizontal: horizontalInfo
    };
  } else if (dx === 0) {
    if (isBottom) {
      if (bottom < endY) {
        horizontalInfo.pos = bottom;
        horizontalInfo.offset = endY - bottom;
      }
    } else {
      if (top > endY) {
        horizontalInfo.pos = top;
        horizontalInfo.offset = endY - top;
      }
    }
  } else if (dy === 0) {
    if (isRight) {
      if (right < endX) {
        verticalInfo.pos = right;
        verticalInfo.offset = endX - right;
      }
    } else {
      if (left > endX) {
        verticalInfo.pos = left;
        verticalInfo.offset = endX - left;
      }
    }
  } else {
    var a2 = dy / dx;
    var b2 = endPos[1] - a2 * endX;
    var y2 = 0;
    var x2 = 0;
    var isBound = false;
    if (isRight && right <= endX) {
      y2 = a2 * right + b2;
      x2 = right;
      isBound = true;
    } else if (!isRight && endX <= left) {
      y2 = a2 * left + b2;
      x2 = left;
      isBound = true;
    }
    if (isBound) {
      if (y2 < top || y2 > bottom) {
        isBound = false;
      }
    }
    if (!isBound) {
      if (isBottom && bottom <= endY) {
        y2 = bottom;
        x2 = (y2 - b2) / a2;
        isBound = true;
      } else if (!isBottom && endY <= top) {
        y2 = top;
        x2 = (y2 - b2) / a2;
        isBound = true;
      }
    }
    if (isBound) {
      verticalInfo.isBound = true;
      verticalInfo.pos = x2;
      verticalInfo.offset = endX - x2;
      horizontalInfo.isBound = true;
      horizontalInfo.pos = y2;
      horizontalInfo.offset = endY - y2;
    }
  }
  return {
    vertical: verticalInfo,
    horizontal: horizontalInfo
  };
}
function checkBounds(bounds, poses, isVertical) {
  var startBoundPos = bounds[isVertical ? "left" : "top"];
  var endBoundPos = bounds[isVertical ? "right" : "bottom"];
  var minPos = Math.min.apply(Math, poses);
  var maxPos = Math.max.apply(Math, poses);
  var boundInfos = [];
  if (startBoundPos + 1 > minPos) {
    boundInfos.push({
      isBound: true,
      offset: minPos - startBoundPos,
      pos: startBoundPos
    });
  }
  if (endBoundPos - 1 < maxPos) {
    boundInfos.push({
      isBound: true,
      offset: maxPos - endBoundPos,
      pos: endBoundPos
    });
  }
  if (!boundInfos.length) {
    boundInfos.push({
      isBound: false,
      offset: 0,
      pos: 0
    });
  }
  return boundInfos.sort(function(a2, b2) {
    return Math.abs(b2.offset) - Math.abs(a2.offset);
  });
}
function isBoundRotate$1(relativePoses, boundRect, rad) {
  var nextPoses = rad ? relativePoses.map(function(pos) {
    return rotate(pos, rad);
  }) : relativePoses;
  return nextPoses.some(function(pos) {
    return pos[0] < boundRect.left && Math.abs(pos[0] - boundRect.left) > 0.1 || pos[0] > boundRect.right && Math.abs(pos[0] - boundRect.right) > 0.1 || pos[1] < boundRect.top && Math.abs(pos[1] - boundRect.top) > 0.1 || pos[1] > boundRect.bottom && Math.abs(pos[1] - boundRect.bottom) > 0.1;
  });
}
function boundRotate(vec, boundPos, index) {
  var r2 = getDistSize(vec);
  var nextPos = Math.sqrt(r2 * r2 - boundPos * boundPos) || 0;
  return [nextPos, -nextPos].sort(function(a2, b2) {
    return Math.abs(a2 - vec[index ? 0 : 1]) - Math.abs(b2 - vec[index ? 0 : 1]);
  }).map(function(pos) {
    return getRad$1([0, 0], index ? [pos, boundPos] : [boundPos, pos]);
  });
}
function checkRotateBounds(moveable, prevPoses, nextPoses, origin, rotation) {
  if (!moveable.props.bounds) {
    return [];
  }
  var rad = rotation * Math.PI / 180;
  var _a3 = getBounds(moveable), left = _a3.left, top = _a3.top, right = _a3.right, bottom = _a3.bottom;
  var relativeLeft = left - origin[0];
  var relativeRight = right - origin[0];
  var relativeTop = top - origin[1];
  var relativeBottom = bottom - origin[1];
  var boundRect = {
    left: relativeLeft,
    top: relativeTop,
    right: relativeRight,
    bottom: relativeBottom
  };
  if (!isBoundRotate$1(nextPoses, boundRect, 0)) {
    return [];
  }
  var result = [];
  [[relativeLeft, 0], [relativeRight, 0], [relativeTop, 1], [relativeBottom, 1]].forEach(function(_a4) {
    var boundPos = _a4[0], index = _a4[1];
    nextPoses.forEach(function(nextPos) {
      var relativeRad1 = getRad$1([0, 0], nextPos);
      result.push.apply(result, boundRotate(nextPos, boundPos, index).map(function(relativeRad2) {
        return rad + relativeRad2 - relativeRad1;
      }).filter(function(nextRad) {
        return !isBoundRotate$1(prevPoses, boundRect, nextRad);
      }).map(function(nextRad) {
        return throttle(nextRad * 180 / Math.PI, TINY_NUM);
      }));
    });
  });
  return result;
}
function renderGuideline(info, React) {
  var _a3;
  var direction = info.direction, classNames = info.classNames, size = info.size, pos = info.pos, zoom = info.zoom, key = info.key;
  var isHorizontal = direction === "horizontal";
  var scaleType = isHorizontal ? "Y" : "X";
  return React.createElement("div", {
    key,
    className: classNames.join(" "),
    style: (_a3 = {}, _a3[isHorizontal ? "width" : "height"] = "" + size, _a3.transform = "translate(" + pos[0] + ", " + pos[1] + ") translate" + scaleType + "(-50%) scale" + scaleType + "(" + zoom + ")", _a3)
  });
}
function renderInnerGuideline(info, React) {
  return renderGuideline(__assign$2(__assign$2({}, info), {
    classNames: __spreadArray([prefix("line", "guideline", info.direction)], info.classNames).filter(function(className) {
      return className;
    }),
    size: info.size || info.sizeValue + "px",
    pos: info.pos || info.posValue.map(function(v2) {
      return throttle(v2, 0.1) + "px";
    })
  }), React);
}
function renderSnapPoses(moveable, direction, snapPoses, minPos, targetPos, size, index, React) {
  var zoom = moveable.props.zoom;
  return snapPoses.map(function(_a3, i2) {
    var type = _a3.type, pos = _a3.pos;
    var renderPos = [0, 0];
    renderPos[index] = minPos;
    renderPos[index ? 0 : 1] = -targetPos + pos;
    return renderInnerGuideline({
      key: direction + "TargetGuideline" + i2,
      classNames: [prefix("target", "bold", type)],
      posValue: renderPos,
      sizeValue: size,
      zoom,
      direction
    }, React);
  });
}
function renderGuidelines(moveable, type, guidelines, targetPos, targetRect, React) {
  var _a3 = moveable.props, zoom = _a3.zoom, isDisplayInnerSnapDigit = _a3.isDisplayInnerSnapDigit;
  var mainNames = type === "horizontal" ? VERTICAL_NAMES_MAP : HORIZONTAL_NAMES_MAP;
  var targetStart = targetRect[mainNames.start];
  var targetEnd = targetRect[mainNames.end];
  return guidelines.filter(function(_a4) {
    var hide = _a4.hide, elementRect = _a4.elementRect;
    if (hide) {
      return false;
    }
    if (isDisplayInnerSnapDigit && elementRect) {
      var rect = elementRect.rect;
      if (rect[mainNames.start] <= targetStart && targetEnd <= rect[mainNames.end]) {
        return false;
      }
    }
    return true;
  }).map(function(guideline, i2) {
    var pos = guideline.pos, size = guideline.size, element = guideline.element;
    var renderPos = [-targetPos[0] + pos[0], -targetPos[1] + pos[1]];
    return renderInnerGuideline({
      key: type + "-default-guideline-" + i2,
      classNames: element ? [prefix("bold")] : [],
      direction: type,
      posValue: renderPos,
      sizeValue: size,
      zoom
    }, React);
  });
}
function renderDigitLine(moveable, type, lineType, index, gap2, renderPos, className, React) {
  var _a3;
  var _b3 = moveable.props, _c3 = _b3.snapDigit, snapDigit = _c3 === void 0 ? 0 : _c3, _d2 = _b3.isDisplaySnapDigit, isDisplaySnapDigit = _d2 === void 0 ? true : _d2, _e = _b3.snapDistFormat, snapDistFormat = _e === void 0 ? function(v2) {
    return v2;
  } : _e, zoom = _b3.zoom;
  var scaleType = type === "horizontal" ? "X" : "Y";
  var sizeName = type === "vertical" ? "height" : "width";
  var absGap = Math.abs(gap2);
  var snapSize = isDisplaySnapDigit ? parseFloat(absGap.toFixed(snapDigit)) : 0;
  return React.createElement("div", {
    key: type + "-" + lineType + "-guideline-" + index,
    className: prefix("guideline-group", type),
    style: (_a3 = {
      left: renderPos[0] + "px",
      top: renderPos[1] + "px"
    }, _a3[sizeName] = absGap + "px", _a3)
  }, renderInnerGuideline({
    direction: type,
    classNames: [prefix(lineType), className],
    size: "100%",
    posValue: [0, 0],
    sizeValue: absGap,
    zoom
  }, React), React.createElement("div", {
    className: prefix("size-value", "gap"),
    style: {
      transform: "translate" + scaleType + "(-50%) scale(" + zoom + ")"
    }
  }, snapSize > 0 ? snapDistFormat(snapSize) : ""));
}
function groupByElementGuidelines(type, guidelines, targetRect, isDisplayInnerSnapDigit) {
  var index = type === "vertical" ? 0 : 1;
  var otherIndex = type === "vertical" ? 1 : 0;
  var names = index ? VERTICAL_NAMES_MAP : HORIZONTAL_NAMES_MAP;
  var targetStart = targetRect[names.start];
  var targetEnd = targetRect[names.end];
  return groupBy(guidelines, function(guideline) {
    return guideline.pos[index];
  }).map(function(nextGuidelines) {
    var start = [];
    var end = [];
    var inner = [];
    nextGuidelines.forEach(function(guideline) {
      var _a3, _b3;
      var element = guideline.element;
      var rect = guideline.elementRect.rect;
      if (rect[names.end] < targetStart) {
        start.push(guideline);
      } else if (targetEnd < rect[names.start]) {
        end.push(guideline);
      } else if (rect[names.start] <= targetStart && targetEnd <= rect[names.end] && isDisplayInnerSnapDigit) {
        var pos = guideline.pos;
        var elementRect1 = {
          element,
          rect: __assign$2(__assign$2({}, rect), (_a3 = {}, _a3[names.end] = rect[names.start], _a3))
        };
        var elementRect2 = {
          element,
          rect: __assign$2(__assign$2({}, rect), (_b3 = {}, _b3[names.start] = rect[names.end], _b3))
        };
        var nextPos1 = [0, 0];
        var nextPos2 = [0, 0];
        nextPos1[index] = pos[index];
        nextPos1[otherIndex] = pos[otherIndex];
        nextPos2[index] = pos[index];
        nextPos2[otherIndex] = pos[otherIndex] + guideline.size;
        start.push({
          type,
          pos: nextPos1,
          size: 0,
          elementRect: elementRect1
        });
        end.push({
          type,
          pos: nextPos2,
          size: 0,
          elementRect: elementRect2
        });
      }
    });
    start.sort(function(a2, b2) {
      return b2.pos[otherIndex] - a2.pos[otherIndex];
    });
    end.sort(function(a2, b2) {
      return a2.pos[otherIndex] - b2.pos[otherIndex];
    });
    return {
      total: nextGuidelines,
      start,
      end,
      inner
    };
  });
}
function renderDashedGuidelines(moveable, guidelines, targetPos, targetRect, React) {
  var isDisplayInnerSnapDigit = moveable.props.isDisplayInnerSnapDigit;
  var rendered = [];
  ["vertical", "horizontal"].forEach(function(type) {
    var nextGuidelines = guidelines.filter(function(guideline) {
      return guideline.type === type;
    });
    var index = type === "vertical" ? 1 : 0;
    var otherIndex = index ? 0 : 1;
    var groups = groupByElementGuidelines(type, nextGuidelines, targetRect, isDisplayInnerSnapDigit);
    var mainNames = index ? HORIZONTAL_NAMES_MAP : VERTICAL_NAMES_MAP;
    var sideNames = index ? VERTICAL_NAMES_MAP : HORIZONTAL_NAMES_MAP;
    var targetStart = targetRect[mainNames.start];
    var targetEnd = targetRect[mainNames.end];
    groups.forEach(function(_a3) {
      var total = _a3.total, start = _a3.start, end = _a3.end, inner = _a3.inner;
      var sidePos = targetPos[otherIndex] + total[0].pos[otherIndex] - targetRect[sideNames.start];
      var prevRect = targetRect;
      start.forEach(function(guideline) {
        var nextRect = guideline.elementRect.rect;
        var size = prevRect[mainNames.start] - nextRect[mainNames.end];
        if (size > 0) {
          var renderPos = [0, 0];
          renderPos[index] = targetPos[index] + prevRect[mainNames.start] - targetStart - size;
          renderPos[otherIndex] = sidePos;
          rendered.push(renderDigitLine(moveable, type, "dashed", rendered.length, size, renderPos, guideline.className, React));
        }
        prevRect = nextRect;
      });
      prevRect = targetRect;
      end.forEach(function(guideline) {
        var nextRect = guideline.elementRect.rect;
        var size = nextRect[mainNames.start] - prevRect[mainNames.end];
        if (size > 0) {
          var renderPos = [0, 0];
          renderPos[index] = targetPos[index] + prevRect[mainNames.end] - targetStart;
          renderPos[otherIndex] = sidePos;
          rendered.push(renderDigitLine(moveable, type, "dashed", rendered.length, size, renderPos, guideline.className, React));
        }
        prevRect = nextRect;
      });
      inner.forEach(function(guideline) {
        var nextRect = guideline.elementRect.rect;
        var size1 = targetStart - nextRect[mainNames.start];
        var size2 = nextRect[mainNames.end] - targetEnd;
        var renderPos1 = [0, 0];
        var renderPos2 = [0, 0];
        renderPos1[index] = targetPos[index] - size1;
        renderPos1[otherIndex] = sidePos;
        renderPos2[index] = targetPos[index] + targetEnd - targetStart;
        renderPos2[otherIndex] = sidePos;
        rendered.push(renderDigitLine(moveable, type, "dashed", rendered.length, size1, renderPos1, guideline.className, React));
        rendered.push(renderDigitLine(moveable, type, "dashed", rendered.length, size2, renderPos2, guideline.className, React));
      });
    });
  });
  return rendered;
}
function renderGapGuidelines(moveable, guidelines, targetPos, targetRect, React) {
  var rendered = [];
  ["horizontal", "vertical"].forEach(function(type) {
    var nextGuidelines = guidelines.filter(function(guideline) {
      return guideline.type === type;
    });
    var index = type === "vertical" ? 0 : 1;
    var otherIndex = index ? 0 : 1;
    var mainNames = index ? HORIZONTAL_NAMES_MAP : VERTICAL_NAMES_MAP;
    var sideNames = index ? VERTICAL_NAMES_MAP : HORIZONTAL_NAMES_MAP;
    var targetStart = targetRect[mainNames.start];
    var targetEnd = targetRect[mainNames.end];
    var targetSideStart = targetRect[sideNames.start];
    var targetSideEnd = targetRect[sideNames.end];
    nextGuidelines.forEach(function(_a3) {
      var gap2 = _a3.gap, gapRects = _a3.gapRects, className = _a3.className;
      var sideStartPos = Math.max.apply(Math, __spreadArray([targetSideStart], gapRects.map(function(_a4) {
        var rect = _a4.rect;
        return rect[sideNames.start];
      })));
      var sideEndPos = Math.min.apply(Math, __spreadArray([targetSideEnd], gapRects.map(function(_a4) {
        var rect = _a4.rect;
        return rect[sideNames.end];
      })));
      var sideCenterPos = (sideStartPos + sideEndPos) / 2;
      if (sideStartPos === sideEndPos || sideCenterPos === (targetSideStart + targetSideEnd) / 2) {
        return;
      }
      gapRects.forEach(function(_a4) {
        var rect = _a4.rect;
        var renderPos = [targetPos[0], targetPos[1]];
        if (rect[mainNames.end] < targetStart) {
          renderPos[index] += rect[mainNames.end] - targetStart;
        } else if (targetEnd < rect[mainNames.start]) {
          renderPos[index] += rect[mainNames.start] - targetStart - gap2;
        } else {
          return;
        }
        renderPos[otherIndex] += sideCenterPos - targetSideStart;
        rendered.push(renderDigitLine(moveable, index ? "vertical" : "horizontal", "gap", rendered.length, gap2, renderPos, className, React));
      });
    });
  });
  return rendered;
}
function solveEquation(pos1, pos2, snapOffset, isVertical) {
  var dx = pos2[0] - pos1[0];
  var dy = pos2[1] - pos1[1];
  if (Math.abs(dx) < TINY_NUM$1) {
    dx = 0;
  }
  if (Math.abs(dy) < TINY_NUM$1) {
    dy = 0;
  }
  if (!dx) {
    if (!isVertical) {
      return [0, snapOffset];
    }
    return [0, 0];
  }
  if (!dy) {
    if (isVertical) {
      return [snapOffset, 0];
    }
    return [0, 0];
  }
  var a2 = dy / dx;
  var b2 = pos1[1] - a2 * pos1[0];
  if (isVertical) {
    var y2 = a2 * (pos2[0] + snapOffset) + b2;
    return [snapOffset, y2 - pos2[1]];
  } else {
    var x2 = (pos2[1] + snapOffset - b2) / a2;
    return [x2 - pos2[0], snapOffset];
  }
}
function solveNextOffset(pos1, pos2, offset, isVertical, datas) {
  var sizeOffset = solveEquation(pos1, pos2, offset, isVertical);
  if (!sizeOffset) {
    return {
      isOutside: false,
      offset: [0, 0]
    };
  }
  var size = getDist$2(pos1, pos2);
  var dist1 = getDist$2(sizeOffset, pos1);
  var dist2 = getDist$2(sizeOffset, pos2);
  var isOutside = dist1 > size || dist2 > size;
  var _a3 = getDragDist({
    datas,
    distX: sizeOffset[0],
    distY: sizeOffset[1]
  }), widthOffset = _a3[0], heightOffset = _a3[1];
  return {
    offset: [widthOffset, heightOffset],
    isOutside
  };
}
function getSnapBound(boundInfo, snapInfo) {
  if (boundInfo.isBound) {
    return boundInfo.offset;
  } else if (snapInfo.isSnap) {
    return getNearestSnapGuidelineInfo(snapInfo).offset;
  }
  return 0;
}
function checkThrottleDragRotate(throttleDragRotate, _a3, _b3, _c3, _d2) {
  var distX = _a3[0], distY = _a3[1];
  var isVerticalBound = _b3[0], isHorizontalBound = _b3[1];
  var isVerticalSnap = _c3[0], isHorizontalSnap = _c3[1];
  var verticalOffset = _d2[0], horizontalOffset = _d2[1];
  var offsetX = -verticalOffset;
  var offsetY = -horizontalOffset;
  if (throttleDragRotate && distX && distY) {
    offsetX = 0;
    offsetY = 0;
    var adjustPoses = [];
    if (isVerticalBound && isHorizontalBound) {
      adjustPoses.push([0, horizontalOffset], [verticalOffset, 0]);
    } else if (isVerticalBound) {
      adjustPoses.push([verticalOffset, 0]);
    } else if (isHorizontalBound) {
      adjustPoses.push([0, horizontalOffset]);
    } else if (isVerticalSnap && isHorizontalSnap) {
      adjustPoses.push([0, horizontalOffset], [verticalOffset, 0]);
    } else if (isVerticalSnap) {
      adjustPoses.push([verticalOffset, 0]);
    } else if (isHorizontalSnap) {
      adjustPoses.push([0, horizontalOffset]);
    }
    if (adjustPoses.length) {
      adjustPoses.sort(function(a2, b2) {
        return getDistSize(minus([distX, distY], a2)) - getDistSize(minus([distX, distY], b2));
      });
      var adjustPos = adjustPoses[0];
      if (adjustPos[0] && Math.abs(distX) > TINY_NUM$1) {
        offsetX = -adjustPos[0];
        offsetY = distY * Math.abs(distX + offsetX) / Math.abs(distX) - distY;
      } else if (adjustPos[1] && Math.abs(distY) > TINY_NUM$1) {
        var prevDistY = distY;
        offsetY = -adjustPos[1];
        offsetX = distX * Math.abs(distY + offsetY) / Math.abs(prevDistY) - distX;
      }
      if (throttleDragRotate && isHorizontalBound && isVerticalBound) {
        if (Math.abs(offsetX) > TINY_NUM$1 && Math.abs(offsetX) < Math.abs(verticalOffset)) {
          var scale = Math.abs(verticalOffset) / Math.abs(offsetX);
          offsetX *= scale;
          offsetY *= scale;
        } else if (Math.abs(offsetY) > TINY_NUM$1 && Math.abs(offsetY) < Math.abs(horizontalOffset)) {
          var scale = Math.abs(horizontalOffset) / Math.abs(offsetY);
          offsetX *= scale;
          offsetY *= scale;
        } else {
          offsetX = maxOffset(-verticalOffset, offsetX);
          offsetY = maxOffset(-horizontalOffset, offsetY);
        }
      }
    }
  } else {
    offsetX = distX || isVerticalBound ? -verticalOffset : 0;
    offsetY = distY || isHorizontalBound ? -horizontalOffset : 0;
  }
  return [offsetX, offsetY];
}
function checkSnapBoundsDrag(moveable, distX, distY, throttleDragRotate, isRequest, datas) {
  if (!hasGuidelines(moveable, "draggable")) {
    return [{
      isSnap: false,
      isBound: false,
      offset: 0
    }, {
      isSnap: false,
      isBound: false,
      offset: 0
    }];
  }
  var poses = getAbsolutePoses(datas.absolutePoses, [distX, distY]);
  var _a3 = getRect(poses), left = _a3.left, right = _a3.right, top = _a3.top, bottom = _a3.bottom;
  var boundPoses = {
    horizontal: poses.map(function(pos) {
      return pos[1];
    }),
    vertical: poses.map(function(pos) {
      return pos[0];
    })
  };
  var snapDirections = getSnapDirections(moveable.props.snapDirections);
  var snapPoses = splitSnapDirectionPoses(snapDirections, {
    left,
    right,
    top,
    bottom,
    center: (left + right) / 2,
    middle: (top + bottom) / 2
  });
  var _b3 = checkMoveableSnapBounds(moveable, isRequest, snapPoses, boundPoses), verticalSnapBoundInfo = _b3.vertical, horizontalSnapBoundInfo = _b3.horizontal;
  var _c3 = getInnerBoundDragInfo(moveable, poses, datas), verticalInnerBoundInfo = _c3.vertical, horizontalInnerBoundInfo = _c3.horizontal;
  var isVerticalSnap = verticalSnapBoundInfo.isSnap;
  var isHorizontalSnap = horizontalSnapBoundInfo.isSnap;
  var isVerticalBound = verticalSnapBoundInfo.isBound || verticalInnerBoundInfo.isBound;
  var isHorizontalBound = horizontalSnapBoundInfo.isBound || horizontalInnerBoundInfo.isBound;
  var verticalOffset = maxOffset(verticalSnapBoundInfo.offset, verticalInnerBoundInfo.offset);
  var horizontalOffset = maxOffset(horizontalSnapBoundInfo.offset, horizontalInnerBoundInfo.offset);
  var _d2 = checkThrottleDragRotate(throttleDragRotate, [distX, distY], [isVerticalBound, isHorizontalBound], [isVerticalSnap, isHorizontalSnap], [verticalOffset, horizontalOffset]), offsetX = _d2[0], offsetY = _d2[1];
  return [{
    isBound: isVerticalBound,
    isSnap: isVerticalSnap,
    offset: offsetX
  }, {
    isBound: isHorizontalBound,
    isSnap: isHorizontalSnap,
    offset: offsetY
  }];
}
function checkMoveableSnapBounds(moveable, isRequest, poses, boundPoses) {
  if (boundPoses === void 0) {
    boundPoses = poses;
  }
  var _a3 = checkBoundPoses(getBounds(moveable), boundPoses.vertical, boundPoses.horizontal), horizontalBoundInfos = _a3.horizontal, verticalBoundInfos = _a3.vertical;
  var _b3 = isRequest ? {
    horizontal: {
      isSnap: false,
      index: -1
    },
    vertical: {
      isSnap: false,
      index: -1
    }
  } : checkMoveableSnapPoses(moveable, poses.vertical, poses.horizontal), horizontalSnapInfo = _b3.horizontal, verticalSnapInfo = _b3.vertical;
  var horizontalOffset = getSnapBound(horizontalBoundInfos[0], horizontalSnapInfo);
  var verticalOffset = getSnapBound(verticalBoundInfos[0], verticalSnapInfo);
  var horizontalDist = Math.abs(horizontalOffset);
  var verticalDist = Math.abs(verticalOffset);
  return {
    horizontal: {
      isBound: horizontalBoundInfos[0].isBound,
      isSnap: horizontalSnapInfo.isSnap,
      snapIndex: horizontalSnapInfo.index,
      offset: horizontalOffset,
      dist: horizontalDist,
      bounds: horizontalBoundInfos,
      snap: horizontalSnapInfo
    },
    vertical: {
      isBound: verticalBoundInfos[0].isBound,
      isSnap: verticalSnapInfo.isSnap,
      snapIndex: verticalSnapInfo.index,
      offset: verticalOffset,
      dist: verticalDist,
      bounds: verticalBoundInfos,
      snap: verticalSnapInfo
    }
  };
}
function checkSnapBounds(guideines, bounds, posesX, posesY, snapThreshold) {
  var _a3 = checkBoundPoses(bounds, posesX, posesY), horizontalBoundInfos = _a3.horizontal, verticalBoundInfos = _a3.vertical;
  var _b3 = checkSnapPoses(guideines, posesX, posesY, snapThreshold), horizontalSnapInfo = _b3.horizontal, verticalSnapInfo = _b3.vertical;
  var horizontalOffset = getSnapBound(horizontalBoundInfos[0], horizontalSnapInfo);
  var verticalOffset = getSnapBound(verticalBoundInfos[0], verticalSnapInfo);
  var horizontalDist = Math.abs(horizontalOffset);
  var verticalDist = Math.abs(verticalOffset);
  return {
    horizontal: {
      isBound: horizontalBoundInfos[0].isBound,
      isSnap: horizontalSnapInfo.isSnap,
      snapIndex: horizontalSnapInfo.index,
      offset: horizontalOffset,
      dist: horizontalDist,
      bounds: horizontalBoundInfos,
      snap: horizontalSnapInfo
    },
    vertical: {
      isBound: verticalBoundInfos[0].isBound,
      isSnap: verticalSnapInfo.isSnap,
      snapIndex: verticalSnapInfo.index,
      offset: verticalOffset,
      dist: verticalDist,
      bounds: verticalBoundInfos,
      snap: verticalSnapInfo
    }
  };
}
function checkSnapRightLine(startPos, endPos, snapBoundInfo, keepRatio) {
  var rad = getRad$1(startPos, endPos) / Math.PI * 180;
  var _a3 = snapBoundInfo.vertical, isVerticalBound = _a3.isBound, isVerticalSnap = _a3.isSnap, verticalDist = _a3.dist, _b3 = snapBoundInfo.horizontal, isHorizontalBound = _b3.isBound, isHorizontalSnap = _b3.isSnap, horizontalDist = _b3.dist;
  var rad180 = rad % 180;
  var isHorizontalLine = rad180 < 3 || rad180 > 177;
  var isVerticalLine = rad180 > 87 && rad180 < 93;
  if (horizontalDist < verticalDist) {
    if (isVerticalBound || isVerticalSnap && !isVerticalLine && (!keepRatio || !isHorizontalLine)) {
      return "vertical";
    }
  }
  if (isHorizontalBound || isHorizontalSnap && !isHorizontalLine && (!keepRatio || !isVerticalLine)) {
    return "horizontal";
  }
  return "";
}
function getSnapBoundInfo(moveable, poses, directions, keepRatio, isRequest, datas) {
  return directions.map(function(_a3) {
    var startDirection = _a3[0], endDirection = _a3[1];
    var otherStartPos = getPosByDirection(poses, startDirection);
    var otherEndPos = getPosByDirection(poses, endDirection);
    var snapBoundInfo = keepRatio ? checkSnapBoundsKeepRatio(moveable, otherStartPos, otherEndPos, isRequest) : checkMoveableSnapBounds(moveable, isRequest, {
      vertical: [otherEndPos[0]],
      horizontal: [otherEndPos[1]]
    });
    var _b3 = snapBoundInfo.horizontal, otherHorizontalOffset = _b3.offset, isOtherHorizontalBound = _b3.isBound, isOtherHorizontalSnap = _b3.isSnap, _c3 = snapBoundInfo.vertical, otherVerticalOffset = _c3.offset, isOtherVerticalBound = _c3.isBound, isOtherVerticalSnap = _c3.isSnap;
    var multiple = minus(endDirection, startDirection);
    if (!otherVerticalOffset && !otherHorizontalOffset) {
      return {
        isBound: isOtherVerticalBound || isOtherHorizontalBound,
        isSnap: isOtherVerticalSnap || isOtherHorizontalSnap,
        sign: multiple,
        offset: [0, 0]
      };
    }
    var snapLine = checkSnapRightLine(otherStartPos, otherEndPos, snapBoundInfo, keepRatio);
    if (!snapLine) {
      return {
        sign: multiple,
        isBound: false,
        isSnap: false,
        offset: [0, 0]
      };
    }
    var isVertical = snapLine === "vertical";
    var sizeOffset = solveNextOffset(otherStartPos, otherEndPos, -(isVertical ? otherVerticalOffset : otherHorizontalOffset), isVertical, datas).offset.map(function(size, i2) {
      return size * (multiple[i2] ? 2 / multiple[i2] : 0);
    });
    return {
      sign: multiple,
      isBound: isVertical ? isOtherVerticalBound : isOtherHorizontalBound,
      isSnap: isVertical ? isOtherVerticalSnap : isOtherHorizontalSnap,
      offset: sizeOffset
    };
  });
}
function getSnapBoundOffset(boundInfo, snapInfo) {
  if (boundInfo.isBound) {
    return boundInfo.offset;
  } else if (snapInfo.isSnap) {
    return snapInfo.offset;
  }
  return 0;
}
function checkSnapBoundsKeepRatio(moveable, startPos, endPos, isRequest) {
  var _a3 = checkBoundKeepRatio(moveable, startPos, endPos), horizontalBoundInfo = _a3.horizontal, verticalBoundInfo = _a3.vertical;
  var _b3 = isRequest ? {
    horizontal: {
      isSnap: false
    },
    vertical: {
      isSnap: false
    }
  } : checkSnapKeepRatio(moveable, startPos, endPos), horizontalSnapInfo = _b3.horizontal, verticalSnapInfo = _b3.vertical;
  var horizontalOffset = getSnapBoundOffset(horizontalBoundInfo, horizontalSnapInfo);
  var verticalOffset = getSnapBoundOffset(verticalBoundInfo, verticalSnapInfo);
  var horizontalDist = Math.abs(horizontalOffset);
  var verticalDist = Math.abs(verticalOffset);
  return {
    horizontal: {
      isBound: horizontalBoundInfo.isBound,
      isSnap: horizontalSnapInfo.isSnap,
      offset: horizontalOffset,
      dist: horizontalDist
    },
    vertical: {
      isBound: verticalBoundInfo.isBound,
      isSnap: verticalSnapInfo.isSnap,
      offset: verticalOffset,
      dist: verticalDist
    }
  };
}
function checkMaxBounds(moveable, poses, direction, fixedPosition, datas) {
  var fixedDirection = [-direction[0], -direction[1]];
  var _a3 = moveable.state, width = _a3.width, height = _a3.height;
  var bounds = moveable.props.bounds;
  var maxWidth = Infinity;
  var maxHeight = Infinity;
  if (bounds) {
    var directions = [[direction[0], -direction[1]], [-direction[0], direction[1]]];
    var _b3 = bounds.left, left_1 = _b3 === void 0 ? -Infinity : _b3, _c3 = bounds.top, top_1 = _c3 === void 0 ? -Infinity : _c3, _d2 = bounds.right, right_1 = _d2 === void 0 ? Infinity : _d2, _e = bounds.bottom, bottom_1 = _e === void 0 ? Infinity : _e;
    directions.forEach(function(otherDirection) {
      var isCheckVertical = otherDirection[0] !== fixedDirection[0];
      var isCheckHorizontal = otherDirection[1] !== fixedDirection[1];
      var otherPos = getPosByDirection(poses, otherDirection);
      var deg = getRad$1(fixedPosition, otherPos) * 360 / Math.PI;
      if (isCheckHorizontal) {
        var nextOtherPos = otherPos.slice();
        if (Math.abs(deg - 360) < 2 || Math.abs(deg - 180) < 2) {
          nextOtherPos[1] = fixedPosition[1];
        }
        var _a4 = solveNextOffset(fixedPosition, nextOtherPos, (fixedPosition[1] < otherPos[1] ? bottom_1 : top_1) - otherPos[1], false, datas), _b4 = _a4.offset, heightOffset = _b4[1], isHeightOutside = _a4.isOutside;
        if (!isNaN(heightOffset)) {
          maxHeight = height + (isHeightOutside ? 1 : -1) * Math.abs(heightOffset);
        }
      }
      if (isCheckVertical) {
        var nextOtherPos = otherPos.slice();
        if (Math.abs(deg - 90) < 2 || Math.abs(deg - 270) < 2) {
          nextOtherPos[0] = fixedPosition[0];
        }
        var _c4 = solveNextOffset(fixedPosition, nextOtherPos, (fixedPosition[0] < otherPos[0] ? right_1 : left_1) - otherPos[0], true, datas), widthOffset = _c4.offset[0], isWidthOutside = _c4.isOutside;
        if (!isNaN(widthOffset)) {
          maxWidth = width + (isWidthOutside ? 1 : -1) * Math.abs(widthOffset);
        }
      }
    });
  }
  return {
    maxWidth,
    maxHeight
  };
}
function snapStart(moveable) {
  var state = moveable.state;
  if (state.guidelines && state.guidelines.length) {
    return;
  }
  var container = moveable.state.container;
  var snapContainer = moveable.props.snapContainer || container;
  var containerClientRect = state.containerClientRect;
  var snapOffset = {
    left: 0,
    top: 0,
    bottom: 0,
    right: 0
  };
  if (container !== snapContainer) {
    var snapContainerTarget = getRefTarget(snapContainer, true);
    if (snapContainerTarget) {
      var snapContainerRect = getClientRect(snapContainerTarget);
      var offset1 = getDragDistByState(state, [snapContainerRect.left - containerClientRect.left, snapContainerRect.top - containerClientRect.top]);
      var offset2 = getDragDistByState(state, [snapContainerRect.right - containerClientRect.right, snapContainerRect.bottom - containerClientRect.bottom]);
      snapOffset.left = throttle(offset1[0], 0.1);
      snapOffset.top = throttle(offset1[1], 0.1);
      snapOffset.right = throttle(offset2[0], 0.1);
      snapOffset.bottom = throttle(offset2[1], 0.1);
    }
  }
  state.snapOffset = snapOffset;
  state.guidelines = getTotalGuidelines(moveable);
  state.enableSnap = true;
}
function getNextFixedPoses(matrix, width, height, fixedPos, direction, is3d) {
  var nextPoses = calculatePoses(matrix, width, height, is3d ? 4 : 3);
  var nextPos = getPosByReverseDirection(nextPoses, direction);
  return getAbsolutePoses(nextPoses, minus(fixedPos, nextPos));
}
function getSizeOffsetInfo(moveable, poses, direction, keepRatio, isRequest, datas) {
  var directions = getCheckSnapDirections(direction, keepRatio);
  var lines = getCheckInnerBoundLines(poses, direction, keepRatio);
  var offsets = __spreadArray(__spreadArray([], getSnapBoundInfo(moveable, poses, directions, keepRatio, isRequest, datas)), getInnerBoundInfo(moveable, lines, getPosByDirection(poses, [0, 0]), datas));
  var widthOffsetInfo = getNearOffsetInfo(offsets, 0);
  var heightOffsetInfo = getNearOffsetInfo(offsets, 1);
  return {
    width: {
      isBound: widthOffsetInfo.isBound,
      offset: widthOffsetInfo.offset[0]
    },
    height: {
      isBound: heightOffsetInfo.isBound,
      offset: heightOffsetInfo.offset[1]
    }
  };
}
function recheckSizeByTwoDirection(moveable, poses, width, height, maxWidth, maxHeight, direction, isRequest, datas) {
  var snapPos = getPosByDirection(poses, direction);
  var _a3 = checkMoveableSnapBounds(moveable, isRequest, {
    vertical: [snapPos[0]],
    horizontal: [snapPos[1]]
  }), horizontalOffset = _a3.horizontal.offset, verticalOffset = _a3.vertical.offset;
  if (verticalOffset || horizontalOffset) {
    var _b3 = getDragDist({
      datas,
      distX: -verticalOffset,
      distY: -horizontalOffset
    }), nextWidthOffset = _b3[0], nextHeightOffset = _b3[1];
    var nextWidth = Math.min(maxWidth || Infinity, width + direction[0] * nextWidthOffset);
    var nextHeight = Math.min(maxHeight || Infinity, height + direction[1] * nextHeightOffset);
    return [nextWidth - width, nextHeight - height];
  }
  return [0, 0];
}
function checkSizeDist(moveable, getNextPoses, width, height, direction, fixedPosition, isRequest, datas) {
  var poses = getAbsolutePosesByState(moveable.state);
  var keepRatio = moveable.props.keepRatio;
  var widthOffset = 0;
  var heightOffset = 0;
  for (var i2 = 0; i2 < 2; ++i2) {
    var nextPoses = getNextPoses(widthOffset, heightOffset);
    var _a3 = getSizeOffsetInfo(moveable, nextPoses, direction, keepRatio, isRequest, datas), widthOffsetInfo = _a3.width, heightOffsetInfo = _a3.height;
    var isWidthBound = widthOffsetInfo.isBound;
    var isHeightBound = heightOffsetInfo.isBound;
    var nextWidthOffset = widthOffsetInfo.offset;
    var nextHeightOffset = heightOffsetInfo.offset;
    if (i2 === 1) {
      if (!isWidthBound) {
        nextWidthOffset = 0;
      }
      if (!isHeightBound) {
        nextHeightOffset = 0;
      }
    }
    if (i2 === 0 && isRequest && !isWidthBound && !isHeightBound) {
      return [0, 0];
    }
    if (keepRatio) {
      var widthDist = Math.abs(nextWidthOffset) * (width ? 1 / width : 1);
      var heightDist = Math.abs(nextHeightOffset) * (height ? 1 / height : 1);
      var isGetWidthOffset = isWidthBound && isHeightBound ? widthDist < heightDist : isHeightBound || !isWidthBound && widthDist < heightDist;
      if (isGetWidthOffset) {
        nextWidthOffset = width * nextHeightOffset / height;
      } else {
        nextHeightOffset = height * nextWidthOffset / width;
      }
    }
    widthOffset += nextWidthOffset;
    heightOffset += nextHeightOffset;
  }
  if (direction[0] && direction[1]) {
    var _b3 = checkMaxBounds(moveable, poses, direction, fixedPosition, datas), maxWidth = _b3.maxWidth, maxHeight = _b3.maxHeight;
    var _c3 = recheckSizeByTwoDirection(moveable, getNextPoses(widthOffset, heightOffset).map(function(pos) {
      return pos.map(function(p2) {
        return throttle(p2, FLOAT_POINT_NUM);
      });
    }), width + widthOffset, height + heightOffset, maxWidth, maxHeight, direction, isRequest, datas), nextWidthOffset = _c3[0], nextHeightOffset = _c3[1];
    widthOffset += nextWidthOffset;
    heightOffset += nextHeightOffset;
  }
  return [widthOffset, heightOffset];
}
function checkSnapRotate(moveable, rect, origin, rotation) {
  if (!hasGuidelines(moveable, "rotatable")) {
    return rotation;
  }
  var pos1 = rect.pos1, pos2 = rect.pos2, pos3 = rect.pos3, pos4 = rect.pos4;
  var rad = rotation * Math.PI / 180;
  var prevPoses = [pos1, pos2, pos3, pos4].map(function(pos) {
    return minus(pos, origin);
  });
  var nextPoses = prevPoses.map(function(pos) {
    return rotate(pos, rad);
  });
  var result = __spreadArray(__spreadArray([], checkRotateBounds(moveable, prevPoses, nextPoses, origin, rotation)), checkRotateInnerBounds(moveable, prevPoses, nextPoses, origin, rotation));
  result.sort(function(a2, b2) {
    return Math.abs(a2 - rotation) - Math.abs(b2 - rotation);
  });
  if (result.length) {
    return result[0];
  } else {
    return rotation;
  }
}
function checkSnapResize(moveable, width, height, direction, fixedPosition, isRequest, datas) {
  if (!hasGuidelines(moveable, "resizable")) {
    return [0, 0];
  }
  var _a3 = moveable.state, allMatrix = _a3.allMatrix, is3d = _a3.is3d;
  return checkSizeDist(moveable, function(widthOffset, heightOffset) {
    return getNextFixedPoses(allMatrix, width + widthOffset, height + heightOffset, fixedPosition, direction, is3d);
  }, width, height, direction, fixedPosition, isRequest, datas);
}
function checkSnapScale(moveable, scale, direction, isRequest, datas) {
  var width = datas.width, height = datas.height, fixedPosition = datas.fixedPosition;
  if (!hasGuidelines(moveable, "scalable")) {
    return [0, 0];
  }
  var is3d = datas.is3d;
  var sizeDist = checkSizeDist(moveable, function(widthOffset, heightOffset) {
    return getNextFixedPoses(scaleMatrix(datas, plus(scale, [widthOffset / width, heightOffset / height])), width, height, fixedPosition, direction, is3d);
  }, width, height, direction, fixedPosition, isRequest, datas);
  return [sizeDist[0] / width, sizeDist[1] / height];
}
function startCheckSnapDrag(moveable, datas) {
  datas.absolutePoses = getAbsolutePosesByState(moveable.state);
}
function getSnapGuidelines(posInfos) {
  var guidelines = [];
  posInfos.forEach(function(posInfo) {
    posInfo.guidelineInfos.forEach(function(_a3) {
      var guideline = _a3.guideline;
      if (guidelines.indexOf(guideline) > -1) {
        return;
      }
      guidelines.push(guideline);
    });
  });
  return guidelines;
}
function addBoundGuidelines(moveable, verticalPoses, horizontalPoses, verticalSnapPoses, horizontalSnapPoses, externalBounds) {
  var _a3 = checkBoundPoses(getBounds(moveable, externalBounds), verticalPoses, horizontalPoses), verticalBoundInfos = _a3.vertical, horizontalBoundInfos = _a3.horizontal;
  verticalBoundInfos.forEach(function(info) {
    if (info.isBound) {
      verticalSnapPoses.push({
        type: "bounds",
        pos: info.pos
      });
    }
  });
  horizontalBoundInfos.forEach(function(info) {
    if (info.isBound) {
      horizontalSnapPoses.push({
        type: "bounds",
        pos: info.pos
      });
    }
  });
  var _b3 = checkInnerBoundPoses(moveable), verticalInnerBoundPoses = _b3.vertical, horizontalInnerBoundPoses = _b3.horizontal;
  verticalInnerBoundPoses.forEach(function(innerPos) {
    if (findIndex(verticalSnapPoses, function(_a4) {
      var type = _a4.type, pos = _a4.pos;
      return type === "bounds" && pos === innerPos;
    }) >= 0) {
      return;
    }
    verticalSnapPoses.push({
      type: "bounds",
      pos: innerPos
    });
  });
  horizontalInnerBoundPoses.forEach(function(innerPos) {
    if (findIndex(horizontalSnapPoses, function(_a4) {
      var type = _a4.type, pos = _a4.pos;
      return type === "bounds" && pos === innerPos;
    }) >= 0) {
      return;
    }
    horizontalSnapPoses.push({
      type: "bounds",
      pos: innerPos
    });
  });
}
var Snappable = {
  name: "snappable",
  dragRelation: "strong",
  props: {
    snappable: [Boolean, Array],
    snapContainer: Object,
    snapDirections: [Boolean, Object],
    elementSnapDirections: [Boolean, Object],
    snapGap: Boolean,
    snapGridWidth: Number,
    snapGridHeight: Number,
    isDisplaySnapDigit: Boolean,
    isDisplayInnerSnapDigit: Boolean,
    snapDigit: Number,
    snapThreshold: Number,
    horizontalGuidelines: Array,
    verticalGuidelines: Array,
    elementGuidelines: Array,
    bounds: Object,
    innerBounds: Object,
    snapDistFormat: Function
  },
  events: {
    onSnap: "snap"
  },
  css: [":host {\n    --bounds-color: #d66;\n}\n.guideline {\n    pointer-events: none;\n    z-index: 2;\n}\n.guideline.bounds {\n    background: #d66;\n    background: var(--bounds-color);\n}\n.guideline-group {\n    position: absolute;\n    top: 0;\n    left: 0;\n}\n.guideline-group .size-value {\n    position: absolute;\n    color: #f55;\n    font-size: 12px;\n    font-weight: bold;\n}\n.guideline-group.horizontal .size-value {\n    transform-origin: 50% 100%;\n    transform: translateX(-50%);\n    left: 50%;\n    bottom: 5px;\n}\n.guideline-group.vertical .size-value {\n    transform-origin: 0% 50%;\n    top: 50%;\n    transform: translateY(-50%);\n    left: 5px;\n}\n.guideline.gap {\n    background: #f55;\n}\n.size-value.gap {\n    color: #f55;\n}\n"],
  render: function(moveable, React) {
    var state = moveable.state;
    var targetTop = state.top, targetLeft = state.left, pos1 = state.pos1, pos2 = state.pos2, pos3 = state.pos3, pos4 = state.pos4, snapRenderInfo = state.snapRenderInfo;
    if (!snapRenderInfo || !hasGuidelines(moveable, "")) {
      return [];
    }
    state.guidelines = getTotalGuidelines(moveable);
    var minLeft = Math.min(pos1[0], pos2[0], pos3[0], pos4[0]);
    var minTop = Math.min(pos1[1], pos2[1], pos3[1], pos4[1]);
    var externalPoses = snapRenderInfo.externalPoses || [];
    var poses = getAbsolutePosesByState(moveable.state);
    var verticalSnapPoses = [];
    var horizontalSnapPoses = [];
    var verticalGuidelines = [];
    var horizontalGuidelines = [];
    var snapInfos = [];
    var _a3 = getRect(poses), width = _a3.width, height = _a3.height, top = _a3.top, left = _a3.left, bottom = _a3.bottom, right = _a3.right;
    var targetRect = {
      left,
      right,
      top,
      bottom,
      center: (left + right) / 2,
      middle: (top + bottom) / 2
    };
    var hasExternalPoses = externalPoses.length > 0;
    var externalRect = hasExternalPoses ? getRect(externalPoses) : {};
    if (!snapRenderInfo.request) {
      if (snapRenderInfo.direction) {
        snapInfos.push(getSnapInfosByDirection(moveable, poses, snapRenderInfo.direction));
      }
      if (snapRenderInfo.snap) {
        var rect = getRect(poses);
        if (snapRenderInfo.center) {
          rect.middle = (rect.top + rect.bottom) / 2;
          rect.center = (rect.left + rect.right) / 2;
        }
        snapInfos.push(checkSnaps(moveable, rect, 1));
      }
      if (hasExternalPoses) {
        if (snapRenderInfo.center) {
          externalRect.middle = (externalRect.top + externalRect.bottom) / 2;
          externalRect.center = (externalRect.left + externalRect.right) / 2;
        }
        snapInfos.push(checkSnaps(moveable, externalRect, 1));
      }
      snapInfos.forEach(function(snapInfo) {
        var verticalPosInfos = snapInfo.vertical.posInfos, horizontalPosInfos = snapInfo.horizontal.posInfos;
        verticalSnapPoses.push.apply(verticalSnapPoses, verticalPosInfos.filter(function(_a4) {
          var guidelineInfos = _a4.guidelineInfos;
          return guidelineInfos.some(function(_a5) {
            var guideline = _a5.guideline;
            return !guideline.hide;
          });
        }).map(function(posInfo) {
          return {
            type: "snap",
            pos: posInfo.pos
          };
        }));
        horizontalSnapPoses.push.apply(horizontalSnapPoses, horizontalPosInfos.filter(function(_a4) {
          var guidelineInfos = _a4.guidelineInfos;
          return guidelineInfos.some(function(_a5) {
            var guideline = _a5.guideline;
            return !guideline.hide;
          });
        }).map(function(posInfo) {
          return {
            type: "snap",
            pos: posInfo.pos
          };
        }));
        verticalGuidelines.push.apply(verticalGuidelines, getSnapGuidelines(verticalPosInfos));
        horizontalGuidelines.push.apply(horizontalGuidelines, getSnapGuidelines(horizontalPosInfos));
      });
    }
    addBoundGuidelines(moveable, [left, right], [top, bottom], verticalSnapPoses, horizontalSnapPoses);
    if (hasExternalPoses) {
      addBoundGuidelines(moveable, [externalRect.left, externalRect.right], [externalRect.top, externalRect.bottom], verticalSnapPoses, horizontalSnapPoses, snapRenderInfo.externalBounds);
    }
    var allGuidelines = __spreadArray(__spreadArray([], verticalGuidelines), horizontalGuidelines);
    var elementGuidelines = allGuidelines.filter(function(guideline) {
      return guideline.element && !guideline.gapRects;
    });
    var gapGuidelines = allGuidelines.filter(function(guideline) {
      return guideline.gapRects;
    });
    triggerEvent(moveable, "onSnap", {
      guidelines: allGuidelines.filter(function(_a4) {
        var element = _a4.element;
        return !element;
      }),
      elements: elementGuidelines,
      gaps: gapGuidelines
    }, true);
    return __spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray([], renderDashedGuidelines(moveable, elementGuidelines, [minLeft, minTop], targetRect, React)), renderGapGuidelines(moveable, gapGuidelines, [minLeft, minTop], targetRect, React)), renderGuidelines(moveable, "horizontal", horizontalGuidelines, [targetLeft, targetTop], targetRect, React)), renderGuidelines(moveable, "vertical", verticalGuidelines, [targetLeft, targetTop], targetRect, React)), renderSnapPoses(moveable, "horizontal", horizontalSnapPoses, minLeft, targetTop, width, 0, React)), renderSnapPoses(moveable, "vertical", verticalSnapPoses, minTop, targetLeft, height, 1, React));
  },
  dragStart: function(moveable, e) {
    moveable.state.snapRenderInfo = {
      request: e.isRequest,
      snap: true,
      center: true
    };
    snapStart(moveable);
  },
  drag: function(moveable) {
    var state = moveable.state;
    state.guidelines = getTotalGuidelines(moveable);
  },
  pinchStart: function(moveable) {
    this.unset(moveable);
  },
  dragEnd: function(moveable) {
    this.unset(moveable);
  },
  dragControlCondition: function(moveable, e) {
    if (directionCondition(moveable, e) || dragControlCondition(moveable, e)) {
      return true;
    }
    if (!e.isRequest && e.inputEvent) {
      return hasClass(e.inputEvent.target, prefix("snap-control"));
    }
  },
  dragControlStart: function(moveable) {
    moveable.state.snapRenderInfo = null;
    snapStart(moveable);
  },
  dragControl: function(moveable) {
    this.drag(moveable);
  },
  dragControlEnd: function(moveable) {
    this.unset(moveable);
  },
  dragGroupStart: function(moveable, e) {
    this.dragStart(moveable, e);
  },
  dragGroup: function(moveable) {
    this.drag(moveable);
  },
  dragGroupEnd: function(moveable) {
    this.unset(moveable);
  },
  dragGroupControlStart: function(moveable) {
    moveable.state.snapRenderInfo = null;
    snapStart(moveable);
  },
  dragGroupControl: function(moveable) {
    this.drag(moveable);
  },
  dragGroupControlEnd: function(moveable) {
    this.unset(moveable);
  },
  unset: function(moveable) {
    var state = moveable.state;
    state.enableSnap = false;
    state.guidelines = [];
    state.snapRenderInfo = null;
    state.elementRects = [];
  }
};
var Draggable = {
  name: "draggable",
  props: {
    draggable: Boolean,
    throttleDrag: Number,
    throttleDragRotate: Number,
    startDragRotate: Number,
    edgeDraggable: Boolean
  },
  events: {
    onDragStart: "dragStart",
    onDrag: "drag",
    onDragEnd: "dragEnd",
    onDragGroupStart: "dragGroupStart",
    onDragGroup: "dragGroup",
    onDragGroupEnd: "dragGroupEnd"
  },
  render: function(moveable, React) {
    var _a3 = moveable.props, throttleDragRotate = _a3.throttleDragRotate, zoom = _a3.zoom;
    var _b3 = moveable.state, dragInfo = _b3.dragInfo, beforeOrigin = _b3.beforeOrigin;
    if (!throttleDragRotate || !dragInfo) {
      return [];
    }
    var dist = dragInfo.dist;
    if (!dist[0] && !dist[1]) {
      return [];
    }
    var width = getDistSize(dist);
    var rad = getRad$1(dist, [0, 0]);
    return [React.createElement("div", {
      className: prefix("line", "horizontal", "dragline", "dashed"),
      key: "dragRotateGuideline",
      style: {
        width: width + "px",
        transform: "translate(" + beforeOrigin[0] + "px, " + beforeOrigin[1] + "px) rotate(" + rad + "rad) scaleY(" + zoom + ")"
      }
    })];
  },
  dragStart: function(moveable, e) {
    var datas = e.datas, parentEvent = e.parentEvent, parentGesto = e.parentGesto;
    var state = moveable.state;
    var target = state.target, gesto = state.gesto;
    if (gesto) {
      return false;
    }
    state.gesto = parentGesto || moveable.targetGesto;
    var style = getComputedStyle$1(target);
    datas.datas = {};
    datas.left = parseFloat(style.left || "") || 0;
    datas.top = parseFloat(style.top || "") || 0;
    datas.bottom = parseFloat(style.bottom || "") || 0;
    datas.right = parseFloat(style.right || "") || 0;
    datas.startValue = [0, 0];
    setDragStart(moveable, e);
    setDefaultTransformIndex(e, "translate");
    startCheckSnapDrag(moveable, datas);
    datas.prevDist = [0, 0];
    datas.prevBeforeDist = [0, 0];
    datas.isDrag = false;
    datas.deltaOffset = [0, 0];
    datas.distOffset = [0, 0];
    var params = fillParams(moveable, e, __assign$2({
      set: function(translate) {
        datas.startValue = translate;
      }
    }, fillTransformStartEvent(e)));
    var result = parentEvent || triggerEvent(moveable, "onDragStart", params);
    if (result !== false) {
      datas.isDrag = true;
      moveable.state.dragInfo = {
        startRect: moveable.getRect(),
        dist: [0, 0]
      };
    } else {
      state.gesto = null;
      datas.isPinch = false;
    }
    return datas.isDrag ? params : false;
  },
  drag: function(moveable, e) {
    if (!e) {
      return;
    }
    resolveTransformEvent(e, "translate");
    var datas = e.datas, parentEvent = e.parentEvent, parentFlag = e.parentFlag, isPinch = e.isPinch, isRequest = e.isRequest;
    var distX = e.distX, distY = e.distY;
    var isDrag = datas.isDrag, prevDist = datas.prevDist, prevBeforeDist = datas.prevBeforeDist, startValue = datas.startValue, distOffset = datas.distOffset;
    if (!isDrag) {
      return;
    }
    distX += distOffset[0];
    distY += distOffset[1];
    var props = moveable.props;
    var parentMoveable = props.parentMoveable;
    var throttleDrag = parentEvent ? 0 : props.throttleDrag || 0;
    var throttleDragRotate = parentEvent ? 0 : props.throttleDragRotate || 0;
    var isSnap = false;
    var dragRotateRad = 0;
    if (!parentEvent && throttleDragRotate > 0 && (distX || distY)) {
      var startDragRotate = props.startDragRotate || 0;
      var deg = throttle(startDragRotate + getRad$1([0, 0], [distX, distY]) * 180 / Math.PI, throttleDragRotate) - startDragRotate;
      var ry = distY * Math.abs(Math.cos((deg - 90) / 180 * Math.PI));
      var rx = distX * Math.abs(Math.cos(deg / 180 * Math.PI));
      var r2 = getDistSize([rx, ry]);
      dragRotateRad = deg * Math.PI / 180;
      distX = r2 * Math.cos(dragRotateRad);
      distY = r2 * Math.sin(dragRotateRad);
    }
    if (!isPinch && !parentEvent && !parentFlag && (!throttleDragRotate || distX || distY)) {
      var _a3 = checkSnapBoundsDrag(moveable, distX, distY, throttleDragRotate, isRequest, datas), verticalInfo = _a3[0], horizontalInfo = _a3[1];
      var isVerticalSnap = verticalInfo.isSnap, isVerticalBound = verticalInfo.isBound, verticalOffset = verticalInfo.offset;
      var isHorizontalSnap = horizontalInfo.isSnap, isHorizontalBound = horizontalInfo.isBound, horizontalOffset = horizontalInfo.offset;
      isSnap = isVerticalSnap || isHorizontalSnap || isVerticalBound || isHorizontalBound;
      distX += verticalOffset;
      distY += horizontalOffset;
    }
    var beforeTranslate = plus(getBeforeDragDist({
      datas,
      distX,
      distY
    }), startValue);
    var translate = plus(getTransformDist({
      datas,
      distX,
      distY
    }), startValue);
    if (!throttleDragRotate && !isSnap) {
      throttleArray(translate, throttleDrag);
      throttleArray(beforeTranslate, throttleDrag);
    }
    var beforeDist = minus(beforeTranslate, startValue);
    var dist = minus(translate, startValue);
    var delta = minus(dist, prevDist);
    var beforeDelta = minus(beforeDist, prevBeforeDist);
    datas.prevDist = dist;
    datas.prevBeforeDist = beforeDist;
    datas.passDelta = delta;
    datas.passDist = dist;
    var left = datas.left + beforeDist[0];
    var top = datas.top + beforeDist[1];
    var right = datas.right - beforeDist[0];
    var bottom = datas.bottom - beforeDist[1];
    var nextTransform = convertTransformFormat(datas, "translate(" + translate[0] + "px, " + translate[1] + "px)", "translate(" + dist[0] + "px, " + dist[1] + "px)");
    fillOriginalTransform(e, nextTransform);
    moveable.state.dragInfo.dist = parentEvent ? [0, 0] : dist;
    if (!parentEvent && !parentMoveable && delta.every(function(num) {
      return !num;
    }) && beforeDelta.some(function(num) {
      return !num;
    })) {
      return;
    }
    var _b3 = moveable.state, width = _b3.width, height = _b3.height;
    var params = fillParams(moveable, e, {
      transform: nextTransform,
      dist,
      delta,
      translate,
      beforeDist,
      beforeDelta,
      beforeTranslate,
      left,
      top,
      right,
      bottom,
      width,
      height,
      isPinch
    });
    !parentEvent && triggerEvent(moveable, "onDrag", params);
    return params;
  },
  dragAfter: function(moveable, e) {
    var datas = e.datas;
    var _a3 = e.datas, deltaOffset = _a3.deltaOffset, distOffset = _a3.distOffset;
    if (deltaOffset[0] || deltaOffset[1]) {
      datas.deltaOffset = [0, 0];
      distOffset[0] = deltaOffset[0];
      distOffset[1] = deltaOffset[1];
      return this.drag(moveable, e);
    }
    return false;
  },
  dragEnd: function(moveable, e) {
    var parentEvent = e.parentEvent, datas = e.datas;
    moveable.state.gesto = null;
    moveable.state.dragInfo = null;
    if (!datas.isDrag) {
      return;
    }
    datas.isDrag = false;
    var param = fillEndParams(moveable, e, {});
    !parentEvent && triggerEvent(moveable, "onDragEnd", param);
    return param;
  },
  dragGroupStart: function(moveable, e) {
    var datas = e.datas, clientX = e.clientX, clientY = e.clientY;
    var params = this.dragStart(moveable, e);
    if (!params) {
      return false;
    }
    var events = triggerChildGesto(moveable, this, "dragStart", [clientX || 0, clientY || 0], e, false);
    var nextParams = __assign$2(__assign$2({}, params), {
      targets: moveable.props.targets,
      events
    });
    var result = triggerEvent(moveable, "onDragGroupStart", nextParams);
    datas.isDrag = result !== false;
    return datas.isDrag ? params : false;
  },
  dragGroup: function(moveable, e) {
    var datas = e.datas;
    if (!datas.isDrag) {
      return;
    }
    var params = this.drag(moveable, e);
    var passDelta = e.datas.passDelta;
    var events = triggerChildGesto(moveable, this, "drag", passDelta, e, false);
    if (!params) {
      return;
    }
    var nextParams = __assign$2({
      targets: moveable.props.targets,
      events
    }, params);
    triggerEvent(moveable, "onDragGroup", nextParams);
    return nextParams;
  },
  dragGroupEnd: function(moveable, e) {
    var isDrag = e.isDrag, datas = e.datas;
    if (!datas.isDrag) {
      return;
    }
    this.dragEnd(moveable, e);
    var events = triggerChildGesto(moveable, this, "dragEnd", [0, 0], e, false);
    triggerEvent(moveable, "onDragGroupEnd", fillEndParams(moveable, e, {
      targets: moveable.props.targets,
      events
    }));
    return isDrag;
  },
  request: function(moveable) {
    var datas = {};
    var rect = moveable.getRect();
    var distX = 0;
    var distY = 0;
    return {
      isControl: false,
      requestStart: function() {
        return {
          datas
        };
      },
      request: function(e) {
        if ("x" in e) {
          distX = e.x - rect.left;
        } else if ("deltaX" in e) {
          distX += e.deltaX;
        }
        if ("y" in e) {
          distY = e.y - rect.top;
        } else if ("deltaY" in e) {
          distY += e.deltaY;
        }
        return {
          datas,
          distX,
          distY
        };
      },
      requestEnd: function() {
        return {
          datas,
          isDrag: true
        };
      }
    };
  },
  unset: function(moveable) {
    moveable.state.dragInfo = null;
  }
};
function renderDirectionControls(moveable, defaultDirections, React, additionalClassName) {
  if (additionalClassName === void 0) {
    additionalClassName = "";
  }
  var _a3 = moveable.state, renderPoses = _a3.renderPoses, rotationRad = _a3.rotation, direction = _a3.direction;
  var _b3 = moveable.props, _c3 = _b3.renderDirections, directions = _c3 === void 0 ? defaultDirections : _c3, zoom = _b3.zoom;
  var directionMap = {};
  if (!directions) {
    return [];
  }
  var sign2 = direction > 0 ? 1 : -1;
  var renderDirections = directions === true ? DIRECTIONS : directions;
  var degRotation = rotationRad / Math.PI * 180;
  renderDirections.forEach(function(dir) {
    directionMap[dir] = true;
  });
  return renderDirections.map(function(dir) {
    var indexes = DIRECTION_INDEXES[dir];
    if (!indexes || !directionMap[dir]) {
      return null;
    }
    var directionRotation = (throttle(degRotation, 15) + sign2 * DIRECTION_ROTATIONS[dir] + 720) % 180;
    return React.createElement("div", {
      className: prefix("control", "direction", dir, additionalClassName),
      "data-rotation": directionRotation,
      "data-direction": dir,
      key: "direction-" + dir,
      style: getControlTransform.apply(void 0, __spreadArray([rotationRad, zoom], indexes.map(function(index) {
        return renderPoses[index];
      })))
    });
  });
}
function renderLine(React, direction, pos1, pos2, zoom, key) {
  var classNames = [];
  for (var _i = 6; _i < arguments.length; _i++) {
    classNames[_i - 6] = arguments[_i];
  }
  var rad = getRad$1(pos1, pos2);
  var rotation = direction ? throttle(rad / Math.PI * 180, 15) % 180 : -1;
  return React.createElement("div", {
    key: "line" + key,
    className: prefix.apply(void 0, __spreadArray(["line", "direction", direction], classNames)),
    "data-rotation": rotation,
    "data-line-index": key,
    "data-direction": direction,
    style: getLineStyle(pos1, pos2, zoom, rad)
  });
}
function renderAllDirections(moveable, React) {
  return renderDirectionControls(moveable, DIRECTIONS, React);
}
function renderDiagonalDirections(moveable, React) {
  return renderDirectionControls(moveable, ["nw", "ne", "sw", "se"], React);
}
function setRotateStartInfo(moveable, datas, clientX, clientY, origin, rect) {
  var n = moveable.state.is3d ? 4 : 3;
  var nextOrigin = calculatePosition(moveable.state.rootMatrix, origin, n);
  var startAbsoluteOrigin = plus([rect.left, rect.top], nextOrigin);
  datas.startAbsoluteOrigin = startAbsoluteOrigin;
  datas.prevDeg = getRad$1(startAbsoluteOrigin, [clientX, clientY]) / Math.PI * 180;
  datas.prevSnapDeg = datas.prevDeg;
  datas.startDeg = datas.prevDeg;
  datas.loop = 0;
}
function getParentDeg(moveable, moveableRect, datas, parentDist, direction, startValue) {
  var prevDeg = datas.prevDeg;
  var dist = checkSnapRotate(moveable, moveableRect, datas.origin, parentDist);
  datas.prevDeg = dist;
  var delta = dist - prevDeg;
  return [delta, dist, startValue + dist];
}
function getDeg(moveable, moveableRect, datas, deg, direction, startValue, throttleRotate, isSnap) {
  var prevDeg = datas.prevDeg, prevSnapDeg = datas.prevSnapDeg, startDeg = datas.startDeg, prevLoop = datas.loop;
  if (prevDeg > deg && prevDeg > 270 && deg < 90) {
    ++datas.loop;
  } else if (prevDeg < deg && prevDeg < 90 && deg > 270) {
    --datas.loop;
  }
  var loop = datas.loop;
  var absolutePrevSnapDeg = prevLoop * 360 + prevSnapDeg - startDeg + startValue;
  var absoluteDeg = loop * 360 + deg - startDeg + startValue;
  datas.prevDeg = absoluteDeg - loop * 360 + startDeg - startValue;
  absoluteDeg = throttle(absoluteDeg, throttleRotate);
  var dist = direction * (absoluteDeg - startValue);
  if (isSnap) {
    dist = checkSnapRotate(moveable, moveableRect, datas.origin, dist);
    absoluteDeg = dist / direction + startValue;
  }
  datas.prevSnapDeg = absoluteDeg - loop * 360 + startDeg - startValue;
  var delta = direction * (absoluteDeg - absolutePrevSnapDeg);
  return [delta, dist, startValue + dist];
}
function getRotateInfo(moveable, moveableRect, datas, direction, clientX, clientY, startValue, throttleRotate) {
  return getDeg(moveable, moveableRect, datas, getRad$1(datas.startAbsoluteOrigin, [clientX, clientY]) / Math.PI * 180, direction, startValue, throttleRotate, true);
}
function getRotationPositions(rotationPosition, _a3, direction) {
  var pos1 = _a3[0], pos2 = _a3[1], pos3 = _a3[2], pos4 = _a3[3];
  if (rotationPosition === "none") {
    return;
  }
  var _b3 = (rotationPosition || "top").split("-"), dir1 = _b3[0], dir2 = _b3[1];
  var radPoses = [pos1, pos2];
  if (dir1 === "left") {
    radPoses = [pos3, pos1];
  } else if (dir1 === "right") {
    radPoses = [pos2, pos4];
  } else if (dir1 === "bottom") {
    radPoses = [pos4, pos3];
  }
  var pos = [(radPoses[0][0] + radPoses[1][0]) / 2, (radPoses[0][1] + radPoses[1][1]) / 2];
  var rad = getRotationRad(radPoses, direction);
  if (dir2) {
    var isStart = dir2 === "top" || dir2 === "left";
    var isReverse = dir1 === "bottom" || dir1 === "left";
    pos = radPoses[isStart && !isReverse || !isStart && isReverse ? 0 : 1];
  }
  return [pos, rad];
}
function dragControlCondition(moveable, e) {
  if (e.isRequest) {
    return e.requestAble === "rotatable";
  }
  var target = e.inputEvent.target;
  if (hasClass(target, prefix("rotation-control"))) {
    return true;
  }
  var rotationTarget = moveable.props.rotationTarget;
  if (rotationTarget) {
    return getRefTargets(rotationTarget, true).some(function(element) {
      if (!element) {
        return false;
      }
      return target === element || target.contains(element);
    });
  }
  return false;
}
var Rotatable = {
  name: "rotatable",
  canPinch: true,
  props: {
    rotatable: Boolean,
    rotationPosition: String,
    throttleRotate: Number,
    renderDirections: Object,
    rotationTarget: Object
  },
  events: {
    onRotateStart: "rotateStart",
    onRotate: "rotate",
    onRotateEnd: "rotateEnd",
    onRotateGroupStart: "rotateGroupStart",
    onRotateGroup: "rotateGroup",
    onRotateGroupEnd: "rotateGroupEnd"
  },
  css: [".rotation {\n            position: absolute;\n            height: 40px;\n            width: 1px;\n            transform-origin: 50% 100%;\n            height: calc(40px * var(--zoom));\n            top: auto;\n            left: 0;\n            bottom: 100%;\n            will-change: transform;\n        }\n        .rotation .rotation-line {\n            display: block;\n            width: 100%;\n            height: 100%;\n            transform-origin: 50% 50%;\n        }\n        .rotation .rotation-control {\n            border-color: #4af;\n            border-color: var(--moveable-color);\n            background:#fff;\n            cursor: alias;\n        }"],
  render: function(moveable, React) {
    var _a3 = moveable.props, rotatable = _a3.rotatable, rotationPosition = _a3.rotationPosition, zoom = _a3.zoom, renderDirections = _a3.renderDirections;
    var _b3 = moveable.state, renderPoses = _b3.renderPoses, direction = _b3.direction;
    if (!rotatable) {
      return null;
    }
    var positions = getRotationPositions(rotationPosition, renderPoses, direction);
    var jsxs = [];
    if (positions) {
      var pos = positions[0], rad = positions[1];
      jsxs.push(React.createElement("div", {
        key: "rotation",
        className: prefix("rotation"),
        style: {
          transform: "translate(-50%) translate(" + pos[0] + "px, " + pos[1] + "px) rotate(" + rad + "rad)"
        }
      }, React.createElement("div", {
        className: prefix("line rotation-line"),
        style: {
          transform: "scaleX(" + zoom + ")"
        }
      }), React.createElement("div", {
        className: prefix("control rotation-control"),
        style: {
          transform: "translate(0.5px) scale(" + zoom + ")"
        }
      })));
    }
    if (renderDirections) {
      jsxs.push.apply(jsxs, renderDirectionControls(moveable, [], React));
    }
    return jsxs;
  },
  dragControlCondition,
  dragControlStart: function(moveable, e) {
    var datas = e.datas, clientX = e.clientX, clientY = e.clientY, parentRotate = e.parentRotate, parentFlag = e.parentFlag, isPinch = e.isPinch, isRequest = e.isRequest;
    var _a3 = moveable.state, target = _a3.target, left = _a3.left, top = _a3.top, origin = _a3.origin, beforeOrigin = _a3.beforeOrigin, direction = _a3.direction, beforeDirection = _a3.beforeDirection, targetTransform = _a3.targetTransform, moveableClientRect = _a3.moveableClientRect;
    if (!isRequest && !target) {
      return false;
    }
    var rect = moveable.getRect();
    datas.rect = rect;
    datas.transform = targetTransform;
    datas.left = left;
    datas.top = top;
    datas.fixedPosition = getDirectionOffset(moveable, getOriginDirection(moveable));
    datas.absoluteInfo = {
      origin: rect.origin,
      startValue: rect.rotation
    };
    setRotateStartInfo(moveable, datas.absoluteInfo, clientX, clientY, origin, moveableClientRect);
    if (isRequest || isPinch || parentFlag) {
      var externalRotate = parentRotate || 0;
      datas.beforeInfo = {
        origin: rect.beforeOrigin,
        prevDeg: externalRotate,
        startDeg: externalRotate,
        prevSnapDeg: externalRotate,
        loop: 0
      };
      datas.afterInfo = {
        origin: rect.origin,
        prevDeg: externalRotate,
        startDeg: externalRotate,
        prevSnapDeg: externalRotate,
        loop: 0
      };
    } else {
      datas.beforeInfo = {
        origin: rect.beforeOrigin
      };
      datas.afterInfo = {
        origin: rect.origin
      };
      setRotateStartInfo(moveable, datas.beforeInfo, clientX, clientY, beforeOrigin, moveableClientRect);
      setRotateStartInfo(moveable, datas.afterInfo, clientX, clientY, origin, moveableClientRect);
    }
    datas.direction = direction;
    datas.beforeDirection = beforeDirection;
    datas.startValue = 0;
    datas.datas = {};
    setDefaultTransformIndex(e, "rotate");
    var params = fillParams(moveable, e, __assign$2(__assign$2({
      set: function(rotatation) {
        datas.startValue = rotatation * Math.PI / 180;
      }
    }, fillTransformStartEvent(e)), {
      dragStart: Draggable.dragStart(moveable, new CustomGesto().dragStart([0, 0], e))
    }));
    var result = triggerEvent(moveable, "onRotateStart", params);
    datas.isRotate = result !== false;
    moveable.state.snapRenderInfo = {
      request: e.isRequest
    };
    return datas.isRotate ? params : false;
  },
  dragControl: function(moveable, e) {
    var _a3, _b3, _c3, _d2, _e, _f, _g, _h, _j;
    var datas = e.datas, clientX = e.clientX, clientY = e.clientY, parentRotate = e.parentRotate, parentFlag = e.parentFlag, isPinch = e.isPinch, groupDelta = e.groupDelta;
    var beforeDirection = datas.beforeDirection, beforeInfo = datas.beforeInfo, afterInfo = datas.afterInfo, absoluteInfo = datas.absoluteInfo, isRotate = datas.isRotate, startValue = datas.startValue, rect = datas.rect;
    if (!isRotate) {
      return;
    }
    resolveTransformEvent(e, "rotate");
    var targetDirection = getTransformDirection(e);
    var direction = beforeDirection * targetDirection;
    var _k = moveable.props, _l2 = _k.throttleRotate, throttleRotate = _l2 === void 0 ? 0 : _l2, parentMoveable = _k.parentMoveable;
    var delta;
    var dist;
    var rotate2;
    var beforeDelta;
    var beforeDist;
    var beforeRotate;
    var absoluteDelta;
    var absoluteDist;
    var absoluteRotate;
    var startDeg = 180 / Math.PI * startValue;
    var absoluteStartDeg = absoluteInfo.startValue;
    if (!parentFlag && "parentDist" in e) {
      var parentDist = e.parentDist;
      _a3 = getParentDeg(moveable, rect, afterInfo, parentDist, direction, startDeg), delta = _a3[0], dist = _a3[1], rotate2 = _a3[2];
      _b3 = getParentDeg(moveable, rect, beforeInfo, parentDist, beforeDirection, startDeg), beforeDelta = _b3[0], beforeDist = _b3[1], beforeRotate = _b3[2];
      _c3 = getParentDeg(moveable, rect, absoluteInfo, parentDist, direction, absoluteStartDeg), absoluteDelta = _c3[0], absoluteDist = _c3[1], absoluteRotate = _c3[2];
    } else if (isPinch || parentFlag) {
      _d2 = getDeg(moveable, rect, afterInfo, parentRotate, direction, startDeg, throttleRotate), delta = _d2[0], dist = _d2[1], rotate2 = _d2[2];
      _e = getDeg(moveable, rect, beforeInfo, parentRotate, beforeDirection, startDeg, throttleRotate), beforeDelta = _e[0], beforeDist = _e[1], beforeRotate = _e[2];
      _f = getDeg(moveable, rect, absoluteInfo, parentRotate, direction, absoluteStartDeg, throttleRotate), absoluteDelta = _f[0], absoluteDist = _f[1], absoluteRotate = _f[2];
    } else {
      _g = getRotateInfo(moveable, rect, afterInfo, direction, clientX, clientY, startDeg, throttleRotate), delta = _g[0], dist = _g[1], rotate2 = _g[2];
      _h = getRotateInfo(moveable, rect, beforeInfo, beforeDirection, clientX, clientY, startDeg, throttleRotate), beforeDelta = _h[0], beforeDist = _h[1], beforeRotate = _h[2];
      _j = getRotateInfo(moveable, rect, absoluteInfo, direction, clientX, clientY, absoluteStartDeg, throttleRotate), absoluteDelta = _j[0], absoluteDist = _j[1], absoluteRotate = _j[2];
    }
    if (!absoluteDelta && !delta && !beforeDelta && !parentMoveable) {
      return;
    }
    var nextTransform = convertTransformFormat(datas, "rotate(" + rotate2 + "deg)", "rotate(" + dist + "deg)");
    var inverseDist = getRotateDist(moveable, dist, datas.fixedPosition, datas);
    var inverseDelta = minus(plus(groupDelta || [0, 0], inverseDist), datas.prevInverseDist || [0, 0]);
    datas.prevInverseDist = inverseDist;
    var params = fillParams(moveable, e, __assign$2({
      delta,
      dist,
      rotate: rotate2,
      beforeDist,
      beforeDelta,
      beforeRotate,
      absoluteDist,
      absoluteDelta,
      absoluteRotate,
      isPinch: !!isPinch
    }, fillTransformEvent(moveable, nextTransform, inverseDelta, isPinch, e)));
    triggerEvent(moveable, "onRotate", params);
    return params;
  },
  dragControlEnd: function(moveable, e) {
    var datas = e.datas;
    if (!datas.isRotate) {
      return;
    }
    datas.isRotate = false;
    var params = fillEndParams(moveable, e, {});
    triggerEvent(moveable, "onRotateEnd", params);
    return params;
  },
  dragGroupControlCondition: dragControlCondition,
  dragGroupControlStart: function(moveable, e) {
    var datas = e.datas;
    var _a3 = moveable.state, parentLeft = _a3.left, parentTop = _a3.top, parentBeforeOrigin = _a3.beforeOrigin;
    var params = this.dragControlStart(moveable, e);
    if (!params) {
      return false;
    }
    params.set(datas.beforeDirection * moveable.rotation);
    var events = triggerChildAbles(moveable, this, "dragControlStart", e, function(child, ev) {
      var _a4 = child.state, left = _a4.left, top = _a4.top, beforeOrigin = _a4.beforeOrigin;
      var childClient = plus(minus([left, top], [parentLeft, parentTop]), minus(beforeOrigin, parentBeforeOrigin));
      ev.datas.groupClient = childClient;
      return __assign$2(__assign$2({}, ev), {
        parentRotate: 0
      });
    });
    var nextParams = __assign$2(__assign$2({}, params), {
      targets: moveable.props.targets,
      events
    });
    var result = triggerEvent(moveable, "onRotateGroupStart", nextParams);
    datas.isRotate = result !== false;
    return datas.isRotate ? params : false;
  },
  dragGroupControl: function(moveable, e) {
    var datas = e.datas;
    if (!datas.isRotate) {
      return;
    }
    var params = this.dragControl(moveable, e);
    if (!params) {
      return;
    }
    var direction = datas.beforeDirection;
    var parentRotate = params.beforeDist;
    var deg = params.beforeDelta;
    var rad = deg / 180 * Math.PI;
    var events = triggerChildAbles(moveable, this, "dragControl", e, function(_2, ev) {
      var _a3 = ev.datas.groupClient, prevX = _a3[0], prevY = _a3[1];
      var _b3 = rotate([prevX, prevY], rad * direction), clientX = _b3[0], clientY = _b3[1];
      var delta = [clientX - prevX, clientY - prevY];
      ev.datas.groupClient = [clientX, clientY];
      return __assign$2(__assign$2({}, ev), {
        parentRotate,
        groupDelta: delta
      });
    });
    moveable.rotation = direction * params.beforeRotate;
    var nextParams = __assign$2({
      targets: moveable.props.targets,
      events,
      set: function(rotation) {
        moveable.rotation = rotation;
      }
    }, params);
    triggerEvent(moveable, "onRotateGroup", nextParams);
    return nextParams;
  },
  dragGroupControlEnd: function(moveable, e) {
    var isDrag = e.isDrag, datas = e.datas;
    if (!datas.isRotate) {
      return;
    }
    this.dragControlEnd(moveable, e);
    var events = triggerChildAbles(moveable, this, "dragControlEnd", e);
    var nextParams = fillEndParams(moveable, e, {
      targets: moveable.props.targets,
      events
    });
    triggerEvent(moveable, "onRotateGroupEnd", nextParams);
    return isDrag;
  },
  request: function(moveable) {
    var datas = {};
    var distRotate = 0;
    var startRotation = moveable.getRotation();
    return {
      isControl: true,
      requestStart: function() {
        return {
          datas
        };
      },
      request: function(e) {
        if ("deltaRotate" in e) {
          distRotate += e.deltaRotate;
        } else if ("rotate" in e) {
          distRotate = e.rotate - startRotation;
        }
        return {
          datas,
          parentDist: distRotate
        };
      },
      requestEnd: function() {
        return {
          datas,
          isDrag: true
        };
      }
    };
  }
};
var Resizable = {
  name: "resizable",
  ableGroup: "size",
  canPinch: true,
  props: {
    resizable: Boolean,
    throttleResize: Number,
    renderDirections: Array,
    keepRatio: Boolean
  },
  events: {
    onResizeStart: "resizeStart",
    onResize: "resize",
    onResizeEnd: "resizeEnd",
    onResizeGroupStart: "resizeGroupStart",
    onResizeGroup: "resizeGroup",
    onResizeGroupEnd: "resizeGroupEnd"
  },
  render: function(moveable, React) {
    var _a3 = moveable.props, resizable = _a3.resizable, edge = _a3.edge;
    if (resizable) {
      if (edge) {
        return renderDiagonalDirections(moveable, React);
      }
      return renderAllDirections(moveable, React);
    }
  },
  dragControlCondition: directionCondition,
  dragControlStart: function(moveable, e) {
    var _a3;
    var inputEvent = e.inputEvent, isPinch = e.isPinch, parentDirection = e.parentDirection, datas = e.datas, parentFlag = e.parentFlag;
    var direction = parentDirection || (isPinch ? [0, 0] : getDirection(inputEvent.target));
    var _b3 = moveable.state, target = _b3.target, width = _b3.width, height = _b3.height;
    if (!direction || !target) {
      return false;
    }
    !isPinch && setDragStart(moveable, e);
    datas.datas = {};
    datas.direction = direction;
    datas.startOffsetWidth = width;
    datas.startOffsetHeight = height;
    datas.prevWidth = 0;
    datas.prevHeight = 0;
    _a3 = getCSSSize(target), datas.startWidth = _a3[0], datas.startHeight = _a3[1];
    var padding = [Math.max(0, width - datas.startWidth), Math.max(0, height - datas.startHeight)];
    datas.minSize = padding;
    datas.maxSize = [Infinity, Infinity];
    if (!parentFlag) {
      var style = getComputedStyle$1(target);
      var position = style.position, minWidth = style.minWidth, minHeight = style.minHeight, maxWidth = style.maxWidth, maxHeight = style.maxHeight;
      var isParentElement = position === "static" || position === "relative";
      var container = isParentElement ? target.parentElement : target.offsetParent;
      var containerWidth = width;
      var containerHeight = height;
      if (container) {
        containerWidth = container.clientWidth;
        containerHeight = container.clientHeight;
        if (isParentElement) {
          var containerStyle = getComputedStyle$1(container);
          containerWidth -= parseFloat(containerStyle.paddingLeft) || 0;
          containerHeight -= parseFloat(containerStyle.paddingTop) || 0;
        }
      }
      datas.minSize = plus([convertUnitSize(minWidth, containerWidth) || 0, convertUnitSize(minHeight, containerHeight) || 0], padding);
      datas.maxSize = plus([convertUnitSize(maxWidth, containerWidth) || Infinity, convertUnitSize(maxHeight, containerHeight) || Infinity], padding);
    }
    var transformOrigin = moveable.props.transformOrigin || "% %";
    datas.transformOrigin = transformOrigin && isString(transformOrigin) ? transformOrigin.split(" ") : transformOrigin;
    datas.isWidth = !direction[0] && !direction[1] || direction[0] || !direction[1];
    function setRatio(ratio) {
      datas.ratio = ratio && isFinite(ratio) ? ratio : 0;
    }
    function setFixedDirection(fixedDirection) {
      datas.fixedDirection = fixedDirection;
      datas.fixedPosition = getAbsolutePosition(moveable, fixedDirection);
    }
    setRatio(width / height);
    setFixedDirection([-direction[0], -direction[1]]);
    var params = fillParams(moveable, e, {
      direction,
      set: function(_a4) {
        var startWidth = _a4[0], startHeight = _a4[1];
        datas.startWidth = startWidth;
        datas.startHeight = startHeight;
      },
      setMin: function(minSize) {
        datas.minSize = minSize;
      },
      setMax: function(maxSize) {
        datas.maxSize = [maxSize[0] || Infinity, maxSize[1] || Infinity];
      },
      setRatio,
      setFixedDirection,
      setOrigin: function(origin) {
        datas.transformOrigin = origin;
      },
      dragStart: Draggable.dragStart(moveable, new CustomGesto().dragStart([0, 0], e))
    });
    var result = triggerEvent(moveable, "onResizeStart", params);
    if (result !== false) {
      datas.isResize = true;
      moveable.state.snapRenderInfo = {
        request: e.isRequest,
        direction
      };
    }
    return datas.isResize ? params : false;
  },
  dragControl: function(moveable, e) {
    var _a3;
    var datas = e.datas, distX = e.distX, distY = e.distY, parentFlag = e.parentFlag, isPinch = e.isPinch, parentDistance = e.parentDistance, parentScale = e.parentScale, parentKeepRatio = e.parentKeepRatio, dragClient = e.dragClient, parentDist = e.parentDist, isRequest = e.isRequest;
    var isResize = datas.isResize, transformOrigin = datas.transformOrigin, fixedDirection = datas.fixedDirection, startWidth = datas.startWidth, startHeight = datas.startHeight, prevWidth = datas.prevWidth, prevHeight = datas.prevHeight, minSize = datas.minSize, maxSize = datas.maxSize, ratio = datas.ratio, isWidth = datas.isWidth, startOffsetWidth = datas.startOffsetWidth, startOffsetHeight = datas.startOffsetHeight;
    if (!isResize) {
      return;
    }
    var _b3 = moveable.props, _c3 = _b3.throttleResize, throttleResize = _c3 === void 0 ? 0 : _c3, parentMoveable = _b3.parentMoveable, _d2 = _b3.snapThreshold, snapThreshold = _d2 === void 0 ? 5 : _d2;
    var direction = datas.direction;
    var sizeDirection = direction;
    var distWidth = 0;
    var distHeight = 0;
    if (!direction[0] && !direction[1]) {
      sizeDirection = [1, 1];
    }
    var keepRatio = ratio && (moveable.props.keepRatio || parentKeepRatio);
    var fixedPosition = dragClient;
    if (!dragClient) {
      if (!parentFlag && isPinch) {
        fixedPosition = getAbsolutePosition(moveable, [0, 0]);
      } else {
        fixedPosition = datas.fixedPosition;
      }
    }
    if (parentDist) {
      distWidth = parentDist[0];
      distHeight = parentDist[1];
      if (keepRatio) {
        if (!distWidth) {
          distWidth = distHeight * ratio;
        } else if (!distHeight) {
          distHeight = distWidth / ratio;
        }
      }
    } else if (parentScale) {
      distWidth = (parentScale[0] - 1) * startOffsetWidth;
      distHeight = (parentScale[1] - 1) * startOffsetHeight;
    } else if (isPinch) {
      if (parentDistance) {
        distWidth = parentDistance;
        distHeight = parentDistance * startOffsetHeight / startOffsetWidth;
      }
    } else {
      var dist = getDragDist({
        datas,
        distX,
        distY
      });
      distWidth = sizeDirection[0] * dist[0];
      distHeight = sizeDirection[1] * dist[1];
      if (keepRatio && startOffsetWidth && startOffsetHeight) {
        var rad = getRad$1([0, 0], dist);
        var standardRad = getRad$1([0, 0], sizeDirection);
        var size = getDistSize([distWidth, distHeight]);
        var signSize = Math.cos(rad - standardRad) * size;
        if (!sizeDirection[0]) {
          distHeight = signSize;
          distWidth = distHeight / ratio;
        } else if (!sizeDirection[1]) {
          distWidth = signSize;
          distHeight = distWidth * ratio;
        } else {
          var startWidthSize = sizeDirection[0] * 2 * startOffsetWidth;
          var startHeightSize = sizeDirection[1] * 2 * startOffsetHeight;
          var distSize = getDistSize([startWidthSize + dist[0], startHeightSize + dist[1]]) - getDistSize([startWidthSize, startHeightSize]);
          var ratioRad = getRad$1([0, 0], [ratio, 1]);
          distWidth = Math.cos(ratioRad) * distSize;
          distHeight = Math.sin(ratioRad) * distSize;
        }
      } else if (!keepRatio) {
        var nextDirection = __spreadArray([], direction);
        if (!startOffsetWidth) {
          if (dist[0] < 0) {
            nextDirection[0] = -1;
          } else if (dist[0] > 0) {
            nextDirection[0] = 1;
          }
        }
        if (!startOffsetHeight) {
          if (dist[1] < 0) {
            nextDirection[1] = -1;
          } else if (dist[1] > 0) {
            nextDirection[1] = 1;
          }
        }
        direction = nextDirection;
        sizeDirection = nextDirection;
        distWidth = sizeDirection[0] * dist[0];
        distHeight = sizeDirection[1] * dist[1];
      }
    }
    var nextWidth = sizeDirection[0] || keepRatio ? Math.max(startOffsetWidth + distWidth, TINY_NUM) : startOffsetWidth;
    var nextHeight = sizeDirection[1] || keepRatio ? Math.max(startOffsetHeight + distHeight, TINY_NUM) : startOffsetHeight;
    if (keepRatio && startOffsetWidth && startOffsetHeight) {
      if (isWidth) {
        nextHeight = nextWidth / ratio;
      } else {
        nextWidth = nextHeight * ratio;
      }
    }
    var snapDist = [0, 0];
    if (!isPinch) {
      snapDist = checkSnapResize(moveable, nextWidth, nextHeight, direction, fixedPosition, isRequest, datas);
    }
    if (parentDist) {
      !parentDist[0] && (snapDist[0] = 0);
      !parentDist[1] && (snapDist[1] = 0);
    }
    if (keepRatio) {
      if (sizeDirection[0] && sizeDirection[1] && snapDist[0] && snapDist[1]) {
        if (Math.abs(snapDist[0]) > Math.abs(snapDist[1])) {
          snapDist[1] = 0;
        } else {
          snapDist[0] = 0;
        }
      }
      var isNoSnap = !snapDist[0] && !snapDist[1];
      if (isNoSnap) {
        if (isWidth) {
          nextWidth = throttle(nextWidth, throttleResize);
        } else {
          nextHeight = throttle(nextHeight, throttleResize);
        }
      }
      if (sizeDirection[0] && !sizeDirection[1] || snapDist[0] && !snapDist[1] || isNoSnap && isWidth) {
        nextWidth += snapDist[0];
        nextHeight = nextWidth / ratio;
      } else if (!sizeDirection[0] && sizeDirection[1] || !snapDist[0] && snapDist[1] || isNoSnap && !isWidth) {
        nextHeight += snapDist[1];
        nextWidth = nextHeight * ratio;
      }
    } else {
      if (startOffsetWidth + distWidth < -snapThreshold) {
        snapDist[0] = 0;
      }
      if (startOffsetWidth + distHeight < -snapThreshold) {
        snapDist[1] = 0;
      }
      nextWidth += snapDist[0];
      nextHeight += snapDist[1];
      if (!snapDist[0]) {
        nextWidth = throttle(nextWidth, throttleResize);
      }
      if (!snapDist[1]) {
        nextHeight = throttle(nextHeight, throttleResize);
      }
    }
    _a3 = calculateBoundSize([nextWidth, nextHeight], minSize, maxSize, keepRatio), nextWidth = _a3[0], nextHeight = _a3[1];
    nextWidth = Math.round(nextWidth);
    nextHeight = Math.round(nextHeight);
    distWidth = nextWidth - startOffsetWidth;
    distHeight = nextHeight - startOffsetHeight;
    var delta = [distWidth - prevWidth, distHeight - prevHeight];
    datas.prevWidth = distWidth;
    datas.prevHeight = distHeight;
    var inverseDelta = getResizeDist(moveable, nextWidth, nextHeight, fixedDirection, fixedPosition, transformOrigin);
    if (!parentMoveable && delta.every(function(num) {
      return !num;
    }) && inverseDelta.every(function(num) {
      return !num;
    })) {
      return;
    }
    var params = fillParams(moveable, e, {
      width: startWidth + distWidth,
      height: startHeight + distHeight,
      offsetWidth: nextWidth,
      offsetHeight: nextHeight,
      direction,
      dist: [distWidth, distHeight],
      delta,
      isPinch: !!isPinch,
      drag: Draggable.drag(moveable, setCustomDrag(e, moveable.state, inverseDelta, !!isPinch, false))
    });
    triggerEvent(moveable, "onResize", params);
    return params;
  },
  dragControlAfter: function(moveable, e) {
    var datas = e.datas;
    var isResize = datas.isResize, startOffsetWidth = datas.startOffsetWidth, startOffsetHeight = datas.startOffsetHeight, prevWidth = datas.prevWidth, prevHeight = datas.prevHeight;
    if (!isResize) {
      return;
    }
    var _a3 = moveable.state, width = _a3.width, height = _a3.height;
    var errorWidth = width - (startOffsetWidth + prevWidth);
    var errorHeight = height - (startOffsetHeight + prevHeight);
    var isErrorWidth = Math.abs(errorWidth) > 3;
    var isErrorHeight = Math.abs(errorHeight) > 3;
    if (isErrorWidth) {
      datas.startWidth += errorWidth;
      datas.startOffsetWidth += errorWidth;
      datas.prevWidth += errorWidth;
    }
    if (isErrorHeight) {
      datas.startHeight += errorHeight;
      datas.startOffsetHeight += errorHeight;
      datas.prevHeight += errorHeight;
    }
    if (isErrorWidth || isErrorHeight) {
      return this.dragControl(moveable, e);
    }
  },
  dragControlEnd: function(moveable, e) {
    var datas = e.datas;
    if (!datas.isResize) {
      return;
    }
    datas.isResize = false;
    var params = fillEndParams(moveable, e, {});
    triggerEvent(moveable, "onResizeEnd", params);
    return params;
  },
  dragGroupControlCondition: directionCondition,
  dragGroupControlStart: function(moveable, e) {
    var datas = e.datas;
    var params = this.dragControlStart(moveable, e);
    if (!params) {
      return false;
    }
    var originalEvents = fillChildEvents(moveable, "resizable", e);
    function setDist(child, ev) {
      var fixedDirection = datas.fixedDirection;
      var fixedPosition = datas.fixedPosition;
      var pos = getAbsolutePosition(child, fixedDirection);
      var _a3 = calculate(createRotateMatrix(-moveable.rotation / 180 * Math.PI, 3), [pos[0] - fixedPosition[0], pos[1] - fixedPosition[1], 1], 3), originalX = _a3[0], originalY = _a3[1];
      ev.datas.originalX = originalX;
      ev.datas.originalY = originalY;
      return ev;
    }
    var events = triggerChildAbles(moveable, this, "dragControlStart", e, function(child, ev) {
      return setDist(child, ev);
    });
    var nextParams = __assign$2(__assign$2({}, params), {
      targets: moveable.props.targets,
      events,
      setFixedDirection: function(fixedDirection) {
        params.setFixedDirection(fixedDirection);
        events.forEach(function(ev, i2) {
          ev.setFixedDirection(fixedDirection);
          setDist(moveable.moveables[i2], originalEvents[i2]);
        });
      }
    });
    var result = triggerEvent(moveable, "onResizeGroupStart", nextParams);
    datas.isResize = result !== false;
    return datas.isResize ? params : false;
  },
  dragGroupControl: function(moveable, e) {
    var datas = e.datas;
    if (!datas.isResize) {
      return;
    }
    var params = this.dragControl(moveable, e);
    if (!params) {
      return;
    }
    var offsetWidth = params.offsetWidth, offsetHeight = params.offsetHeight, dist = params.dist;
    var keepRatio = moveable.props.keepRatio;
    var parentScale = [offsetWidth / (offsetWidth - dist[0]), offsetHeight / (offsetHeight - dist[1])];
    var fixedPosition = datas.fixedPosition;
    var events = triggerChildAbles(moveable, this, "dragControl", e, function(_2, ev) {
      var _a3 = calculate(createRotateMatrix(moveable.rotation / 180 * Math.PI, 3), [ev.datas.originalX * parentScale[0], ev.datas.originalY * parentScale[1], 1], 3), clientX = _a3[0], clientY = _a3[1];
      return __assign$2(__assign$2({}, ev), {
        parentDist: null,
        parentScale,
        dragClient: plus(fixedPosition, [clientX, clientY]),
        parentKeepRatio: keepRatio
      });
    });
    var nextParams = __assign$2({
      targets: moveable.props.targets,
      events
    }, params);
    triggerEvent(moveable, "onResizeGroup", nextParams);
    return nextParams;
  },
  dragGroupControlEnd: function(moveable, e) {
    var isDrag = e.isDrag, datas = e.datas;
    if (!datas.isResize) {
      return;
    }
    this.dragControlEnd(moveable, e);
    var events = triggerChildAbles(moveable, this, "dragControlEnd", e);
    var nextParams = fillEndParams(moveable, e, {
      targets: moveable.props.targets,
      events
    });
    triggerEvent(moveable, "onResizeGroupEnd", nextParams);
    return isDrag;
  },
  request: function(moveable) {
    var datas = {};
    var distWidth = 0;
    var distHeight = 0;
    var rect = moveable.getRect();
    return {
      isControl: true,
      requestStart: function(e) {
        return {
          datas,
          parentDirection: e.direction || [1, 1]
        };
      },
      request: function(e) {
        if ("offsetWidth" in e) {
          distWidth = e.offsetWidth - rect.offsetWidth;
        } else if ("deltaWidth" in e) {
          distWidth += e.deltaWidth;
        }
        if ("offsetHeight" in e) {
          distHeight = e.offsetHeight - rect.offsetHeight;
        } else if ("deltaHeight" in e) {
          distHeight += e.deltaHeight;
        }
        return {
          datas,
          parentDist: [distWidth, distHeight]
        };
      },
      requestEnd: function() {
        return {
          datas,
          isDrag: true
        };
      }
    };
  }
};
var Scalable = {
  name: "scalable",
  ableGroup: "size",
  canPinch: true,
  props: {
    scalable: Boolean,
    throttleScale: Number,
    renderDirections: String,
    keepRatio: Boolean
  },
  events: {
    onScaleStart: "scaleStart",
    onScale: "scale",
    onScaleEnd: "scaleEnd",
    onScaleGroupStart: "scaleGroupStart",
    onScaleGroup: "scaleGroup",
    onScaleGroupEnd: "scaleGroupEnd"
  },
  render: function(moveable, React) {
    var _a3 = moveable.props, resizable = _a3.resizable, scalable = _a3.scalable, edge = _a3.edge;
    if (!resizable && scalable) {
      if (edge) {
        return renderDiagonalDirections(moveable, React);
      }
      return renderAllDirections(moveable, React);
    }
  },
  dragControlCondition: directionCondition,
  dragControlStart: function(moveable, e) {
    var datas = e.datas, isPinch = e.isPinch, inputEvent = e.inputEvent, parentDirection = e.parentDirection;
    var direction = parentDirection || (isPinch ? [0, 0] : getDirection(inputEvent.target));
    var _a3 = moveable.state, width = _a3.width, height = _a3.height, targetTransform = _a3.targetTransform, target = _a3.target, pos1 = _a3.pos1, pos2 = _a3.pos2, pos4 = _a3.pos4;
    if (!direction || !target) {
      return false;
    }
    if (!isPinch) {
      setDragStart(moveable, e);
    }
    datas.datas = {};
    datas.transform = targetTransform;
    datas.prevDist = [1, 1];
    datas.direction = direction;
    datas.width = width;
    datas.height = height;
    datas.startValue = [1, 1];
    var scaleWidth = getDist$2(pos1, pos2);
    var scaleHeight = getDist$2(pos2, pos4);
    var isWidth = !direction[0] && !direction[1] || direction[0] || !direction[1];
    datas.scaleWidth = scaleWidth;
    datas.scaleHeight = scaleHeight;
    datas.scaleXRatio = scaleWidth / width;
    datas.scaleYRatio = scaleHeight / height;
    setDefaultTransformIndex(e, "scale");
    datas.isWidth = isWidth;
    function setRatio(ratio) {
      datas.ratio = ratio && isFinite(ratio) ? ratio : 0;
    }
    function setFixedDirection(fixedDirection) {
      datas.fixedDirection = fixedDirection;
      datas.fixedPosition = getAbsolutePosition(moveable, fixedDirection);
    }
    setRatio(getDist$2(pos1, pos2) / getDist$2(pos2, pos4));
    setFixedDirection([-direction[0], -direction[1]]);
    var params = fillParams(moveable, e, __assign$2(__assign$2({
      direction,
      set: function(scale) {
        datas.startValue = scale;
      },
      setRatio,
      setFixedDirection
    }, fillTransformStartEvent(e)), {
      dragStart: Draggable.dragStart(moveable, new CustomGesto().dragStart([0, 0], e))
    }));
    var result = triggerEvent(moveable, "onScaleStart", params);
    if (result !== false) {
      datas.isScale = true;
      moveable.state.snapRenderInfo = {
        request: e.isRequest,
        direction
      };
    }
    return datas.isScale ? params : false;
  },
  dragControl: function(moveable, e) {
    resolveTransformEvent(e, "scale");
    var datas = e.datas, distX = e.distX, distY = e.distY, parentScale = e.parentScale, parentDistance = e.parentDistance, parentKeepRatio = e.parentKeepRatio, parentFlag = e.parentFlag, isPinch = e.isPinch, dragClient = e.dragClient, parentDist = e.parentDist, isRequest = e.isRequest;
    var prevDist = datas.prevDist, direction = datas.direction, width = datas.width, height = datas.height, isScale = datas.isScale, startValue = datas.startValue, isWidth = datas.isWidth, ratio = datas.ratio, fixedDirection = datas.fixedDirection, scaleXRatio = datas.scaleXRatio, scaleYRatio = datas.scaleYRatio;
    if (!isScale) {
      return false;
    }
    var _a3 = moveable.props, throttleScale = _a3.throttleScale, parentMoveable = _a3.parentMoveable;
    var sizeDirection = direction;
    if (!direction[0] && !direction[1]) {
      sizeDirection = [1, 1];
    }
    var keepRatio = ratio && (moveable.props.keepRatio || parentKeepRatio);
    var state = moveable.state;
    var scaleX = 1;
    var scaleY = 1;
    var fixedPosition = dragClient;
    if (!dragClient) {
      if (!parentFlag && isPinch) {
        fixedPosition = getAbsolutePosition(moveable, [0, 0]);
      } else {
        fixedPosition = datas.fixedPosition;
      }
    }
    if (parentDist) {
      scaleX = (width + parentDist[0]) / width;
      scaleY = (height + parentDist[1]) / height;
    } else if (parentScale) {
      scaleX = parentScale[0];
      scaleY = parentScale[1];
    } else if (isPinch) {
      if (parentDistance) {
        scaleX = (width + parentDistance) / width;
        scaleY = (height + parentDistance * height / width) / height;
      }
    } else {
      var dragDist = getDragDist({
        datas,
        distX,
        distY
      });
      var distScaleWidth = sizeDirection[0] * dragDist[0] * scaleXRatio;
      var distScaleHeight = sizeDirection[1] * dragDist[1] * scaleYRatio;
      if (keepRatio && width && height) {
        if (!sizeDirection[0]) {
          distScaleWidth = distScaleHeight * ratio;
        } else if (!sizeDirection[1]) {
          distScaleHeight = distScaleWidth / ratio;
        } else {
          var size = getDistSize([distScaleWidth, distScaleHeight]);
          var dragRad = getRad$1([0, 0], dragDist);
          var standardRad = getRad$1([0, 0], sizeDirection);
          var signSize = Math.cos(dragRad - standardRad) * size;
          var ratioRad = getRad$1([0, 0], [ratio, 1]);
          distScaleWidth = Math.cos(ratioRad) * signSize;
          distScaleHeight = Math.sin(ratioRad) * signSize;
        }
      }
      scaleX = (width + distScaleWidth / scaleXRatio) / width;
      scaleY = (height + distScaleHeight / scaleYRatio) / height;
    }
    scaleX = sizeDirection[0] || keepRatio ? scaleX * startValue[0] : startValue[0];
    scaleY = sizeDirection[1] || keepRatio ? scaleY * startValue[1] : startValue[1];
    if (scaleX === 0) {
      scaleX = (prevDist[0] > 0 ? 1 : -1) * MIN_SCALE;
    }
    if (scaleY === 0) {
      scaleY = (prevDist[1] > 0 ? 1 : -1) * MIN_SCALE;
    }
    var dist = [scaleX / startValue[0], scaleY / startValue[1]];
    var scale = [scaleX, scaleY];
    if (!isPinch && moveable.props.groupable) {
      var snapRenderInfo = state.snapRenderInfo || {};
      var stateDirection = snapRenderInfo.direction;
      if (isArray(stateDirection) && (stateDirection[0] || stateDirection[1])) {
        state.snapRenderInfo = {
          direction,
          request: e.isRequest
        };
      }
    }
    var snapDist = [0, 0];
    if (!isPinch) {
      snapDist = checkSnapScale(moveable, dist, direction, isRequest, datas);
    }
    if (keepRatio) {
      if (sizeDirection[0] && sizeDirection[1] && snapDist[0] && snapDist[1]) {
        if (Math.abs(snapDist[0] * width) > Math.abs(snapDist[1] * height)) {
          snapDist[1] = 0;
        } else {
          snapDist[0] = 0;
        }
      }
      var isNoSnap = !snapDist[0] && !snapDist[1];
      if (isNoSnap) {
        if (isWidth) {
          dist[0] = throttle(dist[0] * startValue[0], throttleScale) / startValue[0];
        } else {
          dist[1] = throttle(dist[1] * startValue[1], throttleScale) / startValue[1];
        }
      }
      if (sizeDirection[0] && !sizeDirection[1] || snapDist[0] && !snapDist[1] || isNoSnap && isWidth) {
        dist[0] += snapDist[0];
        var snapHeight = width * dist[0] * startValue[0] / ratio;
        dist[1] = snapHeight / height / startValue[1];
      } else if (!sizeDirection[0] && sizeDirection[1] || !snapDist[0] && snapDist[1] || isNoSnap && !isWidth) {
        dist[1] += snapDist[1];
        var snapWidth = height * dist[1] * startValue[1] * ratio;
        dist[0] = snapWidth / width / startValue[0];
      }
    } else {
      dist[0] += snapDist[0];
      dist[1] += snapDist[1];
      if (!snapDist[0]) {
        dist[0] = throttle(dist[0] * startValue[0], throttleScale) / startValue[0];
      }
      if (!snapDist[1]) {
        dist[1] = throttle(dist[1] * startValue[1], throttleScale) / startValue[1];
      }
    }
    if (dist[0] === 0) {
      dist[0] = (prevDist[0] > 0 ? 1 : -1) * MIN_SCALE;
    }
    if (dist[1] === 0) {
      dist[1] = (prevDist[1] > 0 ? 1 : -1) * MIN_SCALE;
    }
    var delta = [dist[0] / prevDist[0], dist[1] / prevDist[1]];
    scale = multiply2(dist, startValue);
    var inverseDist = getScaleDist(moveable, dist, fixedDirection, fixedPosition, datas);
    var inverseDelta = minus(inverseDist, datas.prevInverseDist || [0, 0]);
    datas.prevDist = dist;
    datas.prevInverseDist = inverseDist;
    if (scaleX === prevDist[0] && scaleY === prevDist[1] && inverseDelta.every(function(num) {
      return !num;
    }) && !parentMoveable) {
      return false;
    }
    var nextTransform = convertTransformFormat(datas, "scale(" + scale.join(", ") + ")", "scale(" + dist.join(", ") + ")");
    var params = fillParams(moveable, e, __assign$2({
      offsetWidth: width,
      offsetHeight: height,
      direction,
      scale,
      dist,
      delta,
      isPinch: !!isPinch
    }, fillTransformEvent(moveable, nextTransform, inverseDelta, isPinch, e)));
    triggerEvent(moveable, "onScale", params);
    return params;
  },
  dragControlEnd: function(moveable, e) {
    var datas = e.datas, isDrag = e.isDrag;
    if (!datas.isScale) {
      return false;
    }
    datas.isScale = false;
    triggerEvent(moveable, "onScaleEnd", fillEndParams(moveable, e, {}));
    return isDrag;
  },
  dragGroupControlCondition: directionCondition,
  dragGroupControlStart: function(moveable, e) {
    var datas = e.datas;
    var params = this.dragControlStart(moveable, e);
    if (!params) {
      return false;
    }
    var originalEvents = fillChildEvents(moveable, "resizable", e);
    function setDist(child, ev) {
      var fixedDirection = datas.fixedDirection;
      var fixedPosition = datas.fixedPosition;
      var pos = getAbsolutePosition(child, fixedDirection);
      var _a3 = calculate(createRotateMatrix(-moveable.rotation / 180 * Math.PI, 3), [pos[0] - fixedPosition[0], pos[1] - fixedPosition[1], 1], 3), originalX = _a3[0], originalY = _a3[1];
      ev.datas.originalX = originalX;
      ev.datas.originalY = originalY;
      return ev;
    }
    datas.moveableScale = moveable.scale;
    var events = triggerChildAbles(moveable, this, "dragControlStart", e, function(child, ev) {
      return setDist(child, ev);
    });
    var nextParams = __assign$2(__assign$2({}, params), {
      targets: moveable.props.targets,
      events,
      setFixedDirection: function(fixedDirection) {
        params.setFixedDirection(fixedDirection);
        events.forEach(function(ev, i2) {
          ev.setFixedDirection(fixedDirection);
          setDist(moveable.moveables[i2], originalEvents[i2]);
        });
      }
    });
    var result = triggerEvent(moveable, "onScaleGroupStart", nextParams);
    datas.isScale = result !== false;
    return datas.isScale ? nextParams : false;
  },
  dragGroupControl: function(moveable, e) {
    var datas = e.datas;
    if (!datas.isScale) {
      return;
    }
    var params = this.dragControl(moveable, e);
    if (!params) {
      return;
    }
    var moveableScale = datas.moveableScale;
    moveable.scale = [params.scale[0] * moveableScale[0], params.scale[1] * moveableScale[1]];
    var keepRatio = moveable.props.keepRatio;
    var dist = params.dist, scale = params.scale;
    var fixedPosition = datas.fixedPosition;
    var events = triggerChildAbles(moveable, this, "dragControl", e, function(_2, ev) {
      var _a3 = calculate(createRotateMatrix(moveable.rotation / 180 * Math.PI, 3), [ev.datas.originalX * dist[0], ev.datas.originalY * dist[1], 1], 3), clientX = _a3[0], clientY = _a3[1];
      return __assign$2(__assign$2({}, ev), {
        parentDist: null,
        parentScale: scale,
        parentKeepRatio: keepRatio,
        dragClient: plus(fixedPosition, [clientX, clientY])
      });
    });
    var nextParams = __assign$2({
      targets: moveable.props.targets,
      events
    }, params);
    triggerEvent(moveable, "onScaleGroup", nextParams);
    return nextParams;
  },
  dragGroupControlEnd: function(moveable, e) {
    var isDrag = e.isDrag, datas = e.datas;
    if (!datas.isScale) {
      return;
    }
    this.dragControlEnd(moveable, e);
    var events = triggerChildAbles(moveable, this, "dragControlEnd", e);
    var nextParams = fillEndParams(moveable, e, {
      targets: moveable.props.targets,
      events
    });
    triggerEvent(moveable, "onScaleGroupEnd", nextParams);
    return isDrag;
  },
  request: function() {
    var datas = {};
    var distWidth = 0;
    var distHeight = 0;
    return {
      isControl: true,
      requestStart: function(e) {
        return {
          datas,
          parentDirection: e.direction || [1, 1]
        };
      },
      request: function(e) {
        distWidth += e.deltaWidth;
        distHeight += e.deltaHeight;
        return {
          datas,
          parentDist: [distWidth, distHeight]
        };
      },
      requestEnd: function() {
        return {
          datas,
          isDrag: true
        };
      }
    };
  }
};
function getMiddleLinePos(pos1, pos2) {
  return pos1.map(function(pos, i2) {
    return dot(pos, pos2[i2], 1, 2);
  });
}
function getTriangleRad(pos1, pos2, pos3) {
  var rad1 = getRad$1(pos1, pos2);
  var rad2 = getRad$1(pos1, pos3);
  var rad = rad2 - rad1;
  return rad >= 0 ? rad : rad + 2 * Math.PI;
}
function isValidPos(poses1, poses2) {
  var rad1 = getTriangleRad(poses1[0], poses1[1], poses1[2]);
  var rad2 = getTriangleRad(poses2[0], poses2[1], poses2[2]);
  var pi = Math.PI;
  if (rad1 >= pi && rad2 <= pi || rad1 <= pi && rad2 >= pi) {
    return false;
  }
  return true;
}
var Warpable = {
  name: "warpable",
  ableGroup: "size",
  props: {
    warpable: Boolean,
    renderDirections: Array
  },
  events: {
    onWarpStart: "warpStart",
    onWarp: "warp",
    onWarpEnd: "warpEnd"
  },
  render: function(moveable, React) {
    var _a3 = moveable.props, resizable = _a3.resizable, scalable = _a3.scalable, warpable = _a3.warpable, zoom = _a3.zoom;
    if (resizable || scalable || !warpable) {
      return [];
    }
    var _b3 = moveable.state, pos1 = _b3.pos1, pos2 = _b3.pos2, pos3 = _b3.pos3, pos4 = _b3.pos4;
    var linePosFrom1 = getMiddleLinePos(pos1, pos2);
    var linePosFrom2 = getMiddleLinePos(pos2, pos1);
    var linePosFrom3 = getMiddleLinePos(pos1, pos3);
    var linePosFrom4 = getMiddleLinePos(pos3, pos1);
    var linePosTo1 = getMiddleLinePos(pos3, pos4);
    var linePosTo2 = getMiddleLinePos(pos4, pos3);
    var linePosTo3 = getMiddleLinePos(pos2, pos4);
    var linePosTo4 = getMiddleLinePos(pos4, pos2);
    return __spreadArray([React.createElement("div", {
      className: prefix("line"),
      key: "middeLine1",
      style: getLineStyle(linePosFrom1, linePosTo1, zoom)
    }), React.createElement("div", {
      className: prefix("line"),
      key: "middeLine2",
      style: getLineStyle(linePosFrom2, linePosTo2, zoom)
    }), React.createElement("div", {
      className: prefix("line"),
      key: "middeLine3",
      style: getLineStyle(linePosFrom3, linePosTo3, zoom)
    }), React.createElement("div", {
      className: prefix("line"),
      key: "middeLine4",
      style: getLineStyle(linePosFrom4, linePosTo4, zoom)
    })], renderAllDirections(moveable, React));
  },
  dragControlCondition: function(moveable, e) {
    if (e.isRequest) {
      return false;
    }
    return hasClass(e.inputEvent.target, prefix("direction"));
  },
  dragControlStart: function(moveable, e) {
    var datas = e.datas, inputEvent = e.inputEvent;
    var target = moveable.props.target;
    var inputTarget = inputEvent.target;
    var direction = getDirection(inputTarget);
    if (!direction || !target) {
      return false;
    }
    var state = moveable.state;
    var transformOrigin = state.transformOrigin, is3d = state.is3d, targetTransform = state.targetTransform, targetMatrix = state.targetMatrix, width = state.width, height = state.height, left = state.left, top = state.top;
    datas.datas = {};
    datas.targetTransform = targetTransform;
    datas.warpTargetMatrix = is3d ? targetMatrix : convertDimension(targetMatrix, 3, 4);
    datas.targetInverseMatrix = ignoreDimension(invert(datas.warpTargetMatrix, 4), 3, 4);
    datas.direction = direction;
    datas.left = left;
    datas.top = top;
    datas.poses = [[0, 0], [width, 0], [0, height], [width, height]].map(function(p2) {
      return minus(p2, transformOrigin);
    });
    datas.nextPoses = datas.poses.map(function(_a3) {
      var x2 = _a3[0], y2 = _a3[1];
      return calculate(datas.warpTargetMatrix, [x2, y2, 0, 1], 4);
    });
    datas.startValue = createIdentityMatrix(4);
    datas.prevMatrix = createIdentityMatrix(4);
    datas.absolutePoses = getAbsolutePosesByState(state);
    datas.posIndexes = getPosIndexesByDirection(direction);
    setDragStart(moveable, e);
    setDefaultTransformIndex(e, "matrix3d");
    state.snapRenderInfo = {
      request: e.isRequest,
      direction
    };
    var params = fillParams(moveable, e, __assign$2({
      set: function(matrix) {
        datas.startValue = matrix;
      }
    }, fillTransformStartEvent(e)));
    var result = triggerEvent(moveable, "onWarpStart", params);
    if (result !== false) {
      datas.isWarp = true;
    }
    return datas.isWarp;
  },
  dragControl: function(moveable, e) {
    var datas = e.datas, isRequest = e.isRequest;
    var distX = e.distX, distY = e.distY;
    var targetInverseMatrix = datas.targetInverseMatrix, prevMatrix = datas.prevMatrix, isWarp = datas.isWarp, startValue = datas.startValue, poses = datas.poses, posIndexes = datas.posIndexes, absolutePoses = datas.absolutePoses;
    if (!isWarp) {
      return false;
    }
    resolveTransformEvent(e, "matrix3d");
    if (hasGuidelines(moveable, "warpable")) {
      var selectedPoses = posIndexes.map(function(index) {
        return absolutePoses[index];
      });
      if (selectedPoses.length > 1) {
        selectedPoses.push([(selectedPoses[0][0] + selectedPoses[1][0]) / 2, (selectedPoses[0][1] + selectedPoses[1][1]) / 2]);
      }
      var _a3 = checkMoveableSnapBounds(moveable, isRequest, {
        horizontal: selectedPoses.map(function(pos) {
          return pos[1] + distY;
        }),
        vertical: selectedPoses.map(function(pos) {
          return pos[0] + distX;
        })
      }), horizontalSnapInfo = _a3.horizontal, verticalSnapInfo = _a3.vertical;
      distY -= horizontalSnapInfo.offset;
      distX -= verticalSnapInfo.offset;
    }
    var dist = getDragDist({
      datas,
      distX,
      distY
    }, true);
    var nextPoses = datas.nextPoses.slice();
    posIndexes.forEach(function(index) {
      nextPoses[index] = plus(nextPoses[index], dist);
    });
    if (!NEARBY_POS.every(function(nearByPoses) {
      return isValidPos(nearByPoses.map(function(i2) {
        return poses[i2];
      }), nearByPoses.map(function(i2) {
        return nextPoses[i2];
      }));
    })) {
      return false;
    }
    var h2 = createWarpMatrix(poses[0], poses[2], poses[1], poses[3], nextPoses[0], nextPoses[2], nextPoses[1], nextPoses[3]);
    if (!h2.length) {
      return false;
    }
    var afterMatrix = multiply(targetInverseMatrix, h2, 4);
    var matrix = getTransfromMatrix(datas, afterMatrix, true);
    var delta = multiply(invert(prevMatrix, 4), matrix, 4);
    datas.prevMatrix = matrix;
    var totalMatrix = multiply(startValue, matrix, 4);
    var nextTransform = convertTransformFormat(datas, "matrix3d(" + totalMatrix.join(", ") + ")", "matrix3d(" + matrix.join(", ") + ")");
    fillOriginalTransform(e, nextTransform);
    triggerEvent(moveable, "onWarp", fillParams(moveable, e, {
      delta,
      matrix: totalMatrix,
      dist: matrix,
      multiply,
      transform: nextTransform
    }));
    return true;
  },
  dragControlEnd: function(moveable, e) {
    var datas = e.datas, isDrag = e.isDrag;
    if (!datas.isWarp) {
      return false;
    }
    datas.isWarp = false;
    triggerEvent(moveable, "onWarpEnd", fillEndParams(moveable, e, {}));
    return isDrag;
  }
};
var AREA_PIECES = /* @__PURE__ */ prefix("area-pieces");
var AREA_PIECE = /* @__PURE__ */ prefix("area-piece");
var AVOID = /* @__PURE__ */ prefix("avoid");
function restoreStyle(moveable) {
  var el = moveable.areaElement;
  var _a3 = moveable.state, width = _a3.width, height = _a3.height;
  removeClass(el, AVOID);
  el.style.cssText += "left: 0px; top: 0px; width: " + width + "px; height: " + height + "px";
}
function renderPieces(React) {
  return React.createElement("div", {
    key: "area_pieces",
    className: AREA_PIECES
  }, React.createElement("div", {
    className: AREA_PIECE
  }), React.createElement("div", {
    className: AREA_PIECE
  }), React.createElement("div", {
    className: AREA_PIECE
  }), React.createElement("div", {
    className: AREA_PIECE
  }));
}
var DragArea = {
  name: "dragArea",
  props: {
    dragArea: Boolean,
    passDragArea: Boolean
  },
  events: {
    onClick: "click",
    onClickGroup: "clickGroup"
  },
  render: function(moveable, React) {
    var _a3 = moveable.props, target = _a3.target, dragArea = _a3.dragArea, groupable = _a3.groupable, passDragArea = _a3.passDragArea;
    var _b3 = moveable.state, width = _b3.width, height = _b3.height, renderPoses = _b3.renderPoses;
    var className = passDragArea ? prefix("area", "pass") : prefix("area");
    if (groupable) {
      return [React.createElement("div", {
        key: "area",
        ref: ref(moveable, "areaElement"),
        className
      }), renderPieces(React)];
    }
    if (!target || !dragArea) {
      return [];
    }
    var h2 = createWarpMatrix([0, 0], [width, 0], [0, height], [width, height], renderPoses[0], renderPoses[1], renderPoses[2], renderPoses[3]);
    var transform = h2.length ? makeMatrixCSS(h2, true) : "none";
    return [React.createElement("div", {
      key: "area",
      ref: ref(moveable, "areaElement"),
      className,
      style: {
        top: "0px",
        left: "0px",
        width: width + "px",
        height: height + "px",
        transformOrigin: "0 0",
        transform
      }
    }), renderPieces(React)];
  },
  dragStart: function(moveable, _a3) {
    var datas = _a3.datas, clientX = _a3.clientX, clientY = _a3.clientY, inputEvent = _a3.inputEvent;
    if (!inputEvent) {
      return false;
    }
    datas.isDragArea = false;
    var areaElement = moveable.areaElement;
    var state = moveable.state;
    var moveableClientRect = state.moveableClientRect, renderPoses = state.renderPoses, rootMatrix = state.rootMatrix, is3d = state.is3d;
    var left = moveableClientRect.left, top = moveableClientRect.top;
    var _b3 = getRect(renderPoses), relativeLeft = _b3.left, relativeTop = _b3.top, width = _b3.width, height = _b3.height;
    var n = is3d ? 4 : 3;
    var _c3 = calculateInversePosition(rootMatrix, [clientX - left, clientY - top], n), posX = _c3[0], posY = _c3[1];
    posX -= relativeLeft;
    posY -= relativeTop;
    var rects = [{
      left: relativeLeft,
      top: relativeTop,
      width,
      height: posY - 10
    }, {
      left: relativeLeft,
      top: relativeTop,
      width: posX - 10,
      height
    }, {
      left: relativeLeft,
      top: relativeTop + posY + 10,
      width,
      height: height - posY - 10
    }, {
      left: relativeLeft + posX + 10,
      top: relativeTop,
      width: width - posX - 10,
      height
    }];
    var children = [].slice.call(areaElement.nextElementSibling.children);
    rects.forEach(function(rect, i2) {
      children[i2].style.cssText = "left: " + rect.left + "px;top: " + rect.top + "px; width: " + rect.width + "px; height: " + rect.height + "px;";
    });
    addClass(areaElement, AVOID);
    state.disableNativeEvent = true;
    return;
  },
  drag: function(moveable, _a3) {
    var datas = _a3.datas, inputEvent = _a3.inputEvent;
    this.enableNativeEvent(moveable);
    if (!inputEvent) {
      return false;
    }
    if (!datas.isDragArea) {
      datas.isDragArea = true;
      restoreStyle(moveable);
    }
  },
  dragEnd: function(moveable, e) {
    this.enableNativeEvent(moveable);
    var inputEvent = e.inputEvent, datas = e.datas;
    if (!inputEvent) {
      return false;
    }
    if (!datas.isDragArea) {
      restoreStyle(moveable);
    }
  },
  dragGroupStart: function(moveable, e) {
    return this.dragStart(moveable, e);
  },
  dragGroup: function(moveable, e) {
    return this.drag(moveable, e);
  },
  dragGroupEnd: function(moveable, e) {
    return this.dragEnd(moveable, e);
  },
  unset: function(moveable) {
    restoreStyle(moveable);
    moveable.state.disableNativeEvent = false;
  },
  enableNativeEvent: function(moveable) {
    var state = moveable.state;
    if (state.disableNativeEvent) {
      requestAnimationFrame$1(function() {
        state.disableNativeEvent = false;
      });
    }
  }
};
var Origin = makeAble("origin", {
  render: function(moveable, React) {
    var zoom = moveable.props.zoom;
    var _a3 = moveable.state, beforeOrigin = _a3.beforeOrigin, rotation = _a3.rotation;
    return [React.createElement("div", {
      className: prefix("control", "origin"),
      style: getControlTransform(rotation, zoom, beforeOrigin),
      key: "beforeOrigin"
    })];
  }
});
function getDefaultScrollPosition(e) {
  var scrollContainer = e.scrollContainer;
  return [scrollContainer.scrollLeft, scrollContainer.scrollTop];
}
var Scrollable = {
  name: "scrollable",
  canPinch: true,
  props: {
    scrollable: Boolean,
    scrollContainer: Object,
    scrollThreshold: Number,
    getScrollPosition: Function
  },
  events: {
    onScroll: "scroll",
    onScrollGroup: "scrollGroup"
  },
  dragRelation: "strong",
  dragStart: function(moveable, e) {
    var props = moveable.props;
    var _a3 = props.scrollContainer, scrollContainer = _a3 === void 0 ? moveable.getContainer() : _a3;
    var dragScroll = new DragScroll$1();
    var scrollContainerElement = getRefTarget(scrollContainer, true);
    e.datas.dragScroll = dragScroll;
    var gestoName = e.isControl ? "controlGesto" : "targetGesto";
    var targets = e.targets;
    dragScroll.on("scroll", function(_a4) {
      var container = _a4.container, direction = _a4.direction;
      var params = fillParams(moveable, e, {
        scrollContainer: container,
        direction
      });
      var eventName = targets ? "onScrollGroup" : "onScroll";
      if (targets) {
        params.targets = targets;
      }
      triggerEvent(moveable, eventName, params);
    }).on("move", function(_a4) {
      var offsetX = _a4.offsetX, offsetY = _a4.offsetY;
      moveable[gestoName].scrollBy(offsetX, offsetY, e.inputEvent, false);
    });
    dragScroll.dragStart(e, {
      container: scrollContainerElement
    });
  },
  checkScroll: function(moveable, e) {
    var dragScroll = e.datas.dragScroll;
    if (!dragScroll) {
      return;
    }
    var _a3 = moveable.props, _b3 = _a3.scrollContainer, scrollContainer = _b3 === void 0 ? moveable.getContainer() : _b3, _c3 = _a3.scrollThreshold, scrollThreshold = _c3 === void 0 ? 0 : _c3, _d2 = _a3.getScrollPosition, getScrollPosition = _d2 === void 0 ? getDefaultScrollPosition : _d2;
    dragScroll.drag(e, {
      container: scrollContainer,
      threshold: scrollThreshold,
      getScrollPosition: function(ev) {
        return getScrollPosition({
          scrollContainer: ev.container,
          direction: ev.direction
        });
      }
    });
    return true;
  },
  drag: function(moveable, e) {
    return this.checkScroll(moveable, e);
  },
  dragEnd: function(moveable, e) {
    e.datas.dragScroll.dragEnd();
    e.datas.dragScroll = null;
  },
  dragControlStart: function(moveable, e) {
    return this.dragStart(moveable, __assign$2(__assign$2({}, e), {
      isControl: true
    }));
  },
  dragControl: function(moveable, e) {
    return this.drag(moveable, e);
  },
  dragControlEnd: function(moveable, e) {
    return this.dragEnd(moveable, e);
  },
  dragGroupStart: function(moveable, e) {
    return this.dragStart(moveable, __assign$2(__assign$2({}, e), {
      targets: moveable.props.targets
    }));
  },
  dragGroup: function(moveable, e) {
    return this.drag(moveable, __assign$2(__assign$2({}, e), {
      targets: moveable.props.targets
    }));
  },
  dragGroupEnd: function(moveable, e) {
    return this.dragEnd(moveable, __assign$2(__assign$2({}, e), {
      targets: moveable.props.targets
    }));
  },
  dragGroupControlStart: function(moveable, e) {
    return this.dragStart(moveable, __assign$2(__assign$2({}, e), {
      targets: moveable.props.targets,
      isControl: true
    }));
  },
  dragGroupContro: function(moveable, e) {
    return this.drag(moveable, __assign$2(__assign$2({}, e), {
      targets: moveable.props.targets
    }));
  },
  dragGroupControEnd: function(moveable, e) {
    return this.dragEnd(moveable, __assign$2(__assign$2({}, e), {
      targets: moveable.props.targets
    }));
  }
};
var Default = {
  name: "",
  props: {
    target: Object,
    dragTarget: Object,
    container: Object,
    portalContainer: Object,
    rootContainer: Object,
    useResizeObserver: Boolean,
    zoom: Number,
    transformOrigin: Array,
    edge: Boolean,
    ables: Array,
    className: String,
    pinchThreshold: Number,
    pinchOutside: Boolean,
    triggerAblesSimultaneously: Boolean,
    checkInput: Boolean,
    cspNonce: String,
    translateZ: Number,
    hideDefaultLines: Boolean,
    props: Object
  },
  events: {}
};
var Padding = makeAble("padding", {
  render: function(moveable, React) {
    var props = moveable.props;
    if (props.dragArea) {
      return [];
    }
    var padding = props.padding || {};
    var _a3 = padding.left, left = _a3 === void 0 ? 0 : _a3, _b3 = padding.top, top = _b3 === void 0 ? 0 : _b3, _c3 = padding.right, right = _c3 === void 0 ? 0 : _c3, _d2 = padding.bottom, bottom = _d2 === void 0 ? 0 : _d2;
    var _e = moveable.state, renderPoses = _e.renderPoses, pos1 = _e.pos1, pos2 = _e.pos2, pos3 = _e.pos3, pos4 = _e.pos4;
    var poses = [pos1, pos2, pos3, pos4];
    var paddingDirections = [];
    if (left > 0) {
      paddingDirections.push([0, 2]);
    }
    if (top > 0) {
      paddingDirections.push([0, 1]);
    }
    if (right > 0) {
      paddingDirections.push([1, 3]);
    }
    if (bottom > 0) {
      paddingDirections.push([2, 3]);
    }
    return paddingDirections.map(function(_a4, i2) {
      var dir1 = _a4[0], dir2 = _a4[1];
      var paddingPos1 = poses[dir1];
      var paddingPos2 = poses[dir2];
      var paddingPos3 = renderPoses[dir1];
      var paddingPos4 = renderPoses[dir2];
      var h2 = createWarpMatrix([0, 0], [100, 0], [0, 100], [100, 100], paddingPos1, paddingPos2, paddingPos3, paddingPos4);
      if (!h2.length) {
        return void 0;
      }
      return React.createElement("div", {
        key: "padding" + i2,
        className: prefix("padding"),
        style: {
          transform: makeMatrixCSS(h2, true)
        }
      });
    });
  }
});
var RADIUS_DIRECTIONS = ["nw", "ne", "se", "sw"];
function calculateRatio(values, size) {
  var sumSize = values[0] + values[1];
  var sumRatio = sumSize > size ? size / sumSize : 1;
  values[0] *= sumRatio;
  values[1] = size - values[1] * sumRatio;
  return values;
}
var HORIZONTAL_RADIUS_ORDER = [1, 2, 5, 6];
var VERTICAL_RADIUS_ORDER = [0, 3, 4, 7];
var HORIZONTAL_RADIUS_DIRECTIONS = [1, -1, -1, 1];
var VERTICAL_RADIUS_DIRECTIONS = [1, 1, -1, -1];
function getRadiusStyles(poses, controlPoses, isRelative, width, height, left, top, right, bottom) {
  if (left === void 0) {
    left = 0;
  }
  if (top === void 0) {
    top = 0;
  }
  if (right === void 0) {
    right = width;
  }
  if (bottom === void 0) {
    bottom = height;
  }
  var clipStyles = [];
  var isVertical = false;
  var raws = poses.map(function(pos, i2) {
    var _a3 = controlPoses[i2], horizontal = _a3.horizontal, vertical = _a3.vertical;
    if (vertical && !isVertical) {
      isVertical = true;
      clipStyles.push("/");
    }
    if (isVertical) {
      var rawPos = Math.max(0, vertical === 1 ? pos[1] - top : bottom - pos[1]);
      clipStyles.push(convertCSSSize(rawPos, height, isRelative));
      return rawPos;
    } else {
      var rawPos = Math.max(0, horizontal === 1 ? pos[0] - left : right - pos[0]);
      clipStyles.push(convertCSSSize(rawPos, width, isRelative));
      return rawPos;
    }
  });
  return {
    styles: clipStyles,
    raws
  };
}
function getRadiusRange(controlPoses) {
  var horizontalRange = [0, 0];
  var verticalRange = [0, 0];
  var length2 = controlPoses.length;
  for (var i2 = 0; i2 < length2; ++i2) {
    var clipPose = controlPoses[i2];
    if (!clipPose.sub) {
      continue;
    }
    if (clipPose.horizontal) {
      if (horizontalRange[1] === 0) {
        horizontalRange[0] = i2;
      }
      horizontalRange[1] = i2 - horizontalRange[0] + 1;
      verticalRange[0] = i2 + 1;
    }
    if (clipPose.vertical) {
      if (verticalRange[1] === 0) {
        verticalRange[0] = i2;
      }
      verticalRange[1] = i2 - verticalRange[0] + 1;
    }
  }
  return {
    horizontalRange,
    verticalRange
  };
}
function getRadiusValues(values, width, height, left, top, minCounts) {
  var _a3, _b3, _c3, _d2;
  if (minCounts === void 0) {
    minCounts = [0, 0];
  }
  var splitIndex = values.indexOf("/");
  var splitLength = (splitIndex > -1 ? values.slice(0, splitIndex) : values).length;
  var horizontalValues = values.slice(0, splitLength);
  var verticalValues = values.slice(splitLength + 1);
  var _e = horizontalValues[0], nwValue = _e === void 0 ? "0px" : _e, _f = horizontalValues[1], neValue = _f === void 0 ? nwValue : _f, _g = horizontalValues[2], seValue = _g === void 0 ? nwValue : _g, _h = horizontalValues[3], swValue = _h === void 0 ? neValue : _h;
  var _j = verticalValues[0], wnValue = _j === void 0 ? nwValue : _j, _k = verticalValues[1], enValue = _k === void 0 ? wnValue : _k, _l2 = verticalValues[2], esValue = _l2 === void 0 ? wnValue : _l2, _m = verticalValues[3], wsValue = _m === void 0 ? enValue : _m;
  var horizontalRawPoses = [nwValue, neValue, seValue, swValue].map(function(pos) {
    return convertUnitSize(pos, width);
  });
  var verticalRawPoses = [wnValue, enValue, esValue, wsValue].map(function(pos) {
    return convertUnitSize(pos, height);
  });
  var horizontalPoses = horizontalRawPoses.slice();
  var verticalPoses = verticalRawPoses.slice();
  _a3 = calculateRatio([horizontalPoses[0], horizontalPoses[1]], width), horizontalPoses[0] = _a3[0], horizontalPoses[1] = _a3[1];
  _b3 = calculateRatio([horizontalPoses[3], horizontalPoses[2]], width), horizontalPoses[3] = _b3[0], horizontalPoses[2] = _b3[1];
  _c3 = calculateRatio([verticalPoses[0], verticalPoses[3]], height), verticalPoses[0] = _c3[0], verticalPoses[3] = _c3[1];
  _d2 = calculateRatio([verticalPoses[1], verticalPoses[2]], height), verticalPoses[1] = _d2[0], verticalPoses[2] = _d2[1];
  var nextHorizontalPoses = horizontalPoses.slice(0, Math.max(minCounts[0], horizontalValues.length));
  var nextVerticalPoses = verticalPoses.slice(0, Math.max(minCounts[1], verticalValues.length));
  return __spreadArray(__spreadArray([], nextHorizontalPoses.map(function(pos, i2) {
    var direction = RADIUS_DIRECTIONS[i2];
    return {
      horizontal: HORIZONTAL_RADIUS_DIRECTIONS[i2],
      vertical: 0,
      pos: [left + pos, top + (VERTICAL_RADIUS_DIRECTIONS[i2] === -1 ? height : 0)],
      sub: true,
      raw: horizontalRawPoses[i2],
      direction
    };
  })), nextVerticalPoses.map(function(pos, i2) {
    var direction = RADIUS_DIRECTIONS[i2];
    return {
      horizontal: 0,
      vertical: VERTICAL_RADIUS_DIRECTIONS[i2],
      pos: [left + (HORIZONTAL_RADIUS_DIRECTIONS[i2] === -1 ? width : 0), top + pos],
      sub: true,
      raw: verticalRawPoses[i2],
      direction
    };
  }));
}
function removeRadiusPos(controlPoses, poses, index, startIndex, length2) {
  if (length2 === void 0) {
    length2 = poses.length;
  }
  var _a3 = getRadiusRange(controlPoses.slice(startIndex)), horizontalRange = _a3.horizontalRange, verticalRange = _a3.verticalRange;
  var radiuslIndex = index - startIndex;
  var deleteCount = 0;
  if (radiuslIndex === 0) {
    deleteCount = length2;
  } else if (radiuslIndex > 0 && radiuslIndex < horizontalRange[1]) {
    deleteCount = horizontalRange[1] - radiuslIndex;
  } else if (radiuslIndex >= verticalRange[0]) {
    deleteCount = verticalRange[0] + verticalRange[1] - radiuslIndex;
  } else {
    return;
  }
  controlPoses.splice(index, deleteCount);
  poses.splice(index, deleteCount);
}
function addRadiusPos(controlPoses, poses, startIndex, horizontalIndex, verticalIndex, distX, distY, right, bottom, left, top) {
  if (left === void 0) {
    left = 0;
  }
  if (top === void 0) {
    top = 0;
  }
  var _a3 = getRadiusRange(controlPoses.slice(startIndex)), horizontalRange = _a3.horizontalRange, verticalRange = _a3.verticalRange;
  if (horizontalIndex > -1) {
    var radiusX = HORIZONTAL_RADIUS_DIRECTIONS[horizontalIndex] === 1 ? distX - left : right - distX;
    for (var i2 = horizontalRange[1]; i2 <= horizontalIndex; ++i2) {
      var y2 = VERTICAL_RADIUS_DIRECTIONS[i2] === 1 ? top : bottom;
      var x2 = 0;
      if (horizontalIndex === i2) {
        x2 = distX;
      } else if (i2 === 0) {
        x2 = left + radiusX;
      } else if (HORIZONTAL_RADIUS_DIRECTIONS[i2] === -1) {
        x2 = right - (poses[startIndex][0] - left);
      }
      controlPoses.splice(startIndex + i2, 0, {
        horizontal: HORIZONTAL_RADIUS_DIRECTIONS[i2],
        vertical: 0,
        pos: [x2, y2]
      });
      poses.splice(startIndex + i2, 0, [x2, y2]);
      if (i2 === 0) {
        break;
      }
    }
  } else if (verticalIndex > -1) {
    var radiusY = VERTICAL_RADIUS_DIRECTIONS[verticalIndex] === 1 ? distY - top : bottom - distY;
    if (horizontalRange[1] === 0 && verticalRange[1] === 0) {
      var pos = [left + radiusY, top];
      controlPoses.push({
        horizontal: HORIZONTAL_RADIUS_DIRECTIONS[0],
        vertical: 0,
        pos
      });
      poses.push(pos);
    }
    var startVerticalIndex = verticalRange[0];
    for (var i2 = verticalRange[1]; i2 <= verticalIndex; ++i2) {
      var x2 = HORIZONTAL_RADIUS_DIRECTIONS[i2] === 1 ? left : right;
      var y2 = 0;
      if (verticalIndex === i2) {
        y2 = distY;
      } else if (i2 === 0) {
        y2 = top + radiusY;
      } else if (VERTICAL_RADIUS_DIRECTIONS[i2] === 1) {
        y2 = poses[startIndex + startVerticalIndex][1];
      } else if (VERTICAL_RADIUS_DIRECTIONS[i2] === -1) {
        y2 = bottom - (poses[startIndex + startVerticalIndex][1] - top);
      }
      controlPoses.push({
        horizontal: 0,
        vertical: VERTICAL_RADIUS_DIRECTIONS[i2],
        pos: [x2, y2]
      });
      poses.push([x2, y2]);
      if (i2 === 0) {
        break;
      }
    }
  }
}
function splitRadiusPoses(controlPoses, raws) {
  if (raws === void 0) {
    raws = controlPoses.map(function(pos) {
      return pos.raw;
    });
  }
  var horizontals = controlPoses.map(function(pos, i2) {
    return pos.horizontal ? raws[i2] : null;
  }).filter(function(pos) {
    return pos != null;
  });
  var verticals = controlPoses.map(function(pos, i2) {
    return pos.vertical ? raws[i2] : null;
  }).filter(function(pos) {
    return pos != null;
  });
  return {
    horizontals,
    verticals
  };
}
var CLIP_DIRECTIONS = [[0, -1, "n"], [1, 0, "e"]];
var CLIP_RECT_DIRECTIONS = [[-1, -1, "nw"], [0, -1, "n"], [1, -1, "ne"], [1, 0, "e"], [1, 1, "se"], [0, 1, "s"], [-1, 1, "sw"], [-1, 0, "w"]];
function getClipStyles(moveable, clipPath, poses) {
  var clipRelative = moveable.props.clipRelative;
  var _a3 = moveable.state, width = _a3.width, height = _a3.height;
  var _b3 = clipPath, clipType = _b3.type, clipPoses = _b3.poses;
  var isRect = clipType === "rect";
  var isCircle = clipType === "circle";
  if (clipType === "polygon") {
    return poses.map(function(pos) {
      return convertCSSSize(pos[0], width, clipRelative) + " " + convertCSSSize(pos[1], height, clipRelative);
    });
  } else if (isRect || clipType === "inset") {
    var top = poses[1][1];
    var right = poses[3][0];
    var left = poses[7][0];
    var bottom = poses[5][1];
    if (isRect) {
      return [top, right, bottom, left].map(function(pos) {
        return pos + "px";
      });
    }
    var clipStyles = [top, width - right, height - bottom, left].map(function(pos, i2) {
      return convertCSSSize(pos, i2 % 2 ? width : height, clipRelative);
    });
    if (poses.length > 8) {
      var _c3 = minus(poses[4], poses[0]), subWidth = _c3[0], subHeight = _c3[1];
      clipStyles.push.apply(clipStyles, __spreadArray(["round"], getRadiusStyles(poses.slice(8), clipPoses.slice(8), clipRelative, subWidth, subHeight, left, top, right, bottom).styles));
    }
    return clipStyles;
  } else if (isCircle || clipType === "ellipse") {
    var center = poses[0];
    var ry = convertCSSSize(Math.abs(poses[1][1] - center[1]), isCircle ? Math.sqrt((width * width + height * height) / 2) : height, clipRelative);
    var clipStyles = isCircle ? [ry] : [convertCSSSize(Math.abs(poses[2][0] - center[0]), width, clipRelative), ry];
    clipStyles.push("at", convertCSSSize(center[0], width, clipRelative), convertCSSSize(center[1], height, clipRelative));
    return clipStyles;
  }
}
function getRectPoses(top, right, bottom, left) {
  var xs = [left, (left + right) / 2, right];
  var ys = [top, (top + bottom) / 2, bottom];
  return CLIP_RECT_DIRECTIONS.map(function(_a3) {
    var dirx = _a3[0], diry = _a3[1], dir = _a3[2];
    var x2 = xs[dirx + 1];
    var y2 = ys[diry + 1];
    return {
      vertical: Math.abs(diry),
      horizontal: Math.abs(dirx),
      direction: dir,
      pos: [x2, y2]
    };
  });
}
function getClipPath(target, width, height, defaultClip, customClip) {
  var _a3, _b3, _c3, _d2, _e, _f, _g;
  var clipText = customClip;
  if (!clipText) {
    var style = getComputedStyle$1(target);
    var clipPath = style.clipPath;
    clipText = clipPath !== "none" ? clipPath : style.clip;
  }
  if (!clipText || clipText === "none" || clipText === "auto") {
    clipText = defaultClip;
    if (!clipText) {
      return;
    }
  }
  var _h = splitBracket(clipText), _j = _h.prefix, clipPrefix = _j === void 0 ? clipText : _j, _k = _h.value, value = _k === void 0 ? "" : _k;
  var isCircle = clipPrefix === "circle";
  var splitter = " ";
  if (clipPrefix === "polygon") {
    var values = splitComma(value || "0% 0%, 100% 0%, 100% 100%, 0% 100%");
    splitter = ",";
    var poses = values.map(function(pos) {
      var _a4 = pos.split(" "), xPos2 = _a4[0], yPos2 = _a4[1];
      return {
        vertical: 1,
        horizontal: 1,
        pos: [convertUnitSize(xPos2, width), convertUnitSize(yPos2, height)]
      };
    });
    return {
      type: clipPrefix,
      clipText,
      poses,
      splitter
    };
  } else if (isCircle || clipPrefix === "ellipse") {
    var xPos = "";
    var yPos = "";
    var radiusX_1 = 0;
    var radiusY_1 = 0;
    var values = splitSpace(value);
    if (isCircle) {
      var radius = "";
      _a3 = values[0], radius = _a3 === void 0 ? "50%" : _a3, _b3 = values[2], xPos = _b3 === void 0 ? "50%" : _b3, _c3 = values[3], yPos = _c3 === void 0 ? "50%" : _c3;
      radiusX_1 = convertUnitSize(radius, Math.sqrt((width * width + height * height) / 2));
      radiusY_1 = radiusX_1;
    } else {
      var xRadius = "";
      var yRadius = "";
      _d2 = values[0], xRadius = _d2 === void 0 ? "50%" : _d2, _e = values[1], yRadius = _e === void 0 ? "50%" : _e, _f = values[3], xPos = _f === void 0 ? "50%" : _f, _g = values[4], yPos = _g === void 0 ? "50%" : _g;
      radiusX_1 = convertUnitSize(xRadius, width);
      radiusY_1 = convertUnitSize(yRadius, height);
    }
    var centerPos_1 = [convertUnitSize(xPos, width), convertUnitSize(yPos, height)];
    var poses = __spreadArray([{
      vertical: 1,
      horizontal: 1,
      pos: centerPos_1,
      direction: "nesw"
    }], CLIP_DIRECTIONS.slice(0, isCircle ? 1 : 2).map(function(dir) {
      return {
        vertical: Math.abs(dir[1]),
        horizontal: dir[0],
        direction: dir[2],
        sub: true,
        pos: [centerPos_1[0] + dir[0] * radiusX_1, centerPos_1[1] + dir[1] * radiusY_1]
      };
    }));
    return {
      type: clipPrefix,
      clipText,
      radiusX: radiusX_1,
      radiusY: radiusY_1,
      left: centerPos_1[0] - radiusX_1,
      top: centerPos_1[1] - radiusY_1,
      poses,
      splitter
    };
  } else if (clipPrefix === "inset") {
    var values = splitSpace(value || "0 0 0 0");
    var roundIndex = values.indexOf("round");
    var rectLength = (roundIndex > -1 ? values.slice(0, roundIndex) : values).length;
    var radiusValues = values.slice(rectLength + 1);
    var _l2 = values.slice(0, rectLength), topValue = _l2[0], _m = _l2[1], rightValue = _m === void 0 ? topValue : _m, _o = _l2[2], bottomValue = _o === void 0 ? topValue : _o, _p2 = _l2[3], leftValue = _p2 === void 0 ? rightValue : _p2;
    var _q = [topValue, bottomValue].map(function(pos) {
      return convertUnitSize(pos, height);
    }), top = _q[0], bottom = _q[1];
    var _r2 = [leftValue, rightValue].map(function(pos) {
      return convertUnitSize(pos, width);
    }), left = _r2[0], right = _r2[1];
    var nextRight = width - right;
    var nextBottom = height - bottom;
    var radiusPoses = getRadiusValues(radiusValues, nextRight - left, nextBottom - top, left, top);
    var poses = __spreadArray(__spreadArray([], getRectPoses(top, nextRight, nextBottom, left)), radiusPoses);
    return {
      type: "inset",
      clipText,
      poses,
      top,
      left,
      right: nextRight,
      bottom: nextBottom,
      radius: radiusValues,
      splitter
    };
  } else if (clipPrefix === "rect") {
    var values = splitComma(value || "0px, " + width + "px, " + height + "px, 0px");
    splitter = ",";
    var _s = values.map(function(pos) {
      var posValue = splitUnit(pos).value;
      return posValue;
    }), top = _s[0], right = _s[1], bottom = _s[2], left = _s[3];
    var poses = getRectPoses(top, right, bottom, left);
    return {
      type: "rect",
      clipText,
      poses,
      top,
      right,
      bottom,
      left,
      values,
      splitter
    };
  }
  return;
}
function addClipPath(moveable, e) {
  var _a3 = calculatePointerDist(moveable, e), distX = _a3[0], distY = _a3[1];
  var _b3 = e.datas, clipPath = _b3.clipPath, index = _b3.index;
  var _c3 = clipPath, clipType = _c3.type, clipPoses = _c3.poses, splitter = _c3.splitter;
  var poses = clipPoses.map(function(pos) {
    return pos.pos;
  });
  if (clipType === "polygon") {
    poses.splice(index, 0, [distX, distY]);
  } else if (clipType === "inset") {
    var horizontalIndex = HORIZONTAL_RADIUS_ORDER.indexOf(index);
    var verticalIndex = VERTICAL_RADIUS_ORDER.indexOf(index);
    var length2 = clipPoses.length;
    addRadiusPos(clipPoses, poses, 8, horizontalIndex, verticalIndex, distX, distY, poses[4][0], poses[4][1], poses[0][0], poses[0][1]);
    if (length2 === clipPoses.length) {
      return;
    }
  } else {
    return;
  }
  var clipStyles = getClipStyles(moveable, clipPath, poses);
  triggerEvent(moveable, "onClip", fillParams(moveable, e, {
    clipEventType: "added",
    clipType,
    poses,
    clipStyles,
    clipStyle: clipType + "(" + clipStyles.join(splitter) + ")",
    distX: 0,
    distY: 0
  }));
}
function removeClipPath(moveable, e) {
  var _a3 = e.datas, clipPath = _a3.clipPath, index = _a3.index;
  var _b3 = clipPath, clipType = _b3.type, clipPoses = _b3.poses, splitter = _b3.splitter;
  var poses = clipPoses.map(function(pos) {
    return pos.pos;
  });
  var length2 = poses.length;
  if (clipType === "polygon") {
    clipPoses.splice(index, 1);
    poses.splice(index, 1);
  } else if (clipType === "inset") {
    if (index < 8) {
      return;
    }
    removeRadiusPos(clipPoses, poses, index, 8, length2);
    if (length2 === clipPoses.length) {
      return;
    }
  } else {
    return;
  }
  var clipStyles = getClipStyles(moveable, clipPath, poses);
  triggerEvent(moveable, "onClip", fillParams(moveable, e, {
    clipEventType: "removed",
    clipType,
    poses,
    clipStyles,
    clipStyle: clipType + "(" + clipStyles.join(splitter) + ")",
    distX: 0,
    distY: 0
  }));
}
var Clippable = {
  name: "clippable",
  props: {
    clippable: Boolean,
    defaultClipPath: String,
    customClipPath: String,
    clipRelative: Boolean,
    clipArea: Boolean,
    dragWithClip: Boolean,
    clipTargetBounds: Boolean,
    clipVerticalGuidelines: Array,
    clipHorizontalGuidelines: Array,
    clipSnapThreshold: Boolean
  },
  events: {
    onClipStart: "clipStart",
    onClip: "clip",
    onClipEnd: "clipEnd"
  },
  css: [".control.clip-control {\n    background: #6d6;\n    cursor: pointer;\n}\n.control.clip-control.clip-radius {\n    background: #d66;\n}\n.line.clip-line {\n    background: #6e6;\n    cursor: move;\n    z-index: 1;\n}\n.clip-area {\n    position: absolute;\n    top: 0;\n    left: 0;\n}\n.clip-ellipse {\n    position: absolute;\n    cursor: move;\n    border: 1px solid #6d6;\n    border: var(--zoompx) solid #6d6;\n    border-radius: 50%;\n    transform-origin: 0px 0px;\n}", ":host {\n    --bounds-color: #d66;\n}", ".guideline {\n    pointer-events: none;\n    z-index: 2;\n}", ".line.guideline.bounds {\n    background: #d66;\n    background: var(--bounds-color);\n}"],
  render: function(moveable, React) {
    var _a3 = moveable.props, customClipPath = _a3.customClipPath, defaultClipPath = _a3.defaultClipPath, clipArea = _a3.clipArea, zoom = _a3.zoom;
    var _b3 = moveable.state, target = _b3.target, width = _b3.width, height = _b3.height, allMatrix = _b3.allMatrix, is3d = _b3.is3d, left = _b3.left, top = _b3.top, pos1 = _b3.pos1, pos2 = _b3.pos2, pos3 = _b3.pos3, pos4 = _b3.pos4, clipPathState = _b3.clipPathState, snapBoundInfos = _b3.snapBoundInfos, rotationRad = _b3.rotation;
    if (!target) {
      return [];
    }
    var clipPath = getClipPath(target, width, height, defaultClipPath || "inset", clipPathState || customClipPath);
    if (!clipPath) {
      return [];
    }
    var n = is3d ? 4 : 3;
    var type = clipPath.type;
    var clipPoses = clipPath.poses;
    var poses = clipPoses.map(function(pos) {
      var calculatedPos = calculatePosition(allMatrix, pos.pos, n);
      return [calculatedPos[0] - left, calculatedPos[1] - top];
    });
    var controls = [];
    var lines = [];
    var isRect = type === "rect";
    var isInset = type === "inset";
    var isPolygon = type === "polygon";
    if (isRect || isInset || isPolygon) {
      var linePoses_1 = isInset ? poses.slice(0, 8) : poses;
      lines = linePoses_1.map(function(to, i3) {
        var from = i3 === 0 ? linePoses_1[linePoses_1.length - 1] : linePoses_1[i3 - 1];
        var rad2 = getRad$1(from, to);
        var dist = getDiagonalSize(from, to);
        return React.createElement("div", {
          key: "clipLine" + i3,
          className: prefix("line", "clip-line", "snap-control"),
          "data-clip-index": i3,
          style: {
            width: dist + "px",
            transform: "translate(" + from[0] + "px, " + from[1] + "px) rotate(" + rad2 + "rad) scaleY(" + zoom + ")"
          }
        });
      });
    }
    controls = poses.map(function(pos, i3) {
      return React.createElement("div", {
        key: "clipControl" + i3,
        className: prefix("control", "clip-control", "snap-control"),
        "data-clip-index": i3,
        style: {
          transform: "translate(" + pos[0] + "px, " + pos[1] + "px) rotate(" + rotationRad + "rad) scale(" + zoom + ")"
        }
      });
    });
    if (isInset) {
      controls.push.apply(controls, poses.slice(8).map(function(pos, i3) {
        return React.createElement("div", {
          key: "clipRadiusControl" + i3,
          className: prefix("control", "clip-control", "clip-radius", "snap-control"),
          "data-clip-index": 8 + i3,
          style: {
            transform: "translate(" + pos[0] + "px, " + pos[1] + "px) rotate(" + rotationRad + "rad) scale(" + zoom + ")"
          }
        });
      }));
    }
    if (type === "circle" || type === "ellipse") {
      var clipLeft = clipPath.left, clipTop = clipPath.top, radiusX = clipPath.radiusX, radiusY = clipPath.radiusY;
      var _c3 = minus(calculatePosition(allMatrix, [clipLeft, clipTop], n), calculatePosition(allMatrix, [0, 0], n)), distLeft = _c3[0], distTop = _c3[1];
      var ellipseClipPath = "none";
      if (!clipArea) {
        var piece = Math.max(10, radiusX / 5, radiusY / 5);
        var areaPoses = [];
        for (var i2 = 0; i2 <= piece; ++i2) {
          var rad = Math.PI * 2 / piece * i2;
          areaPoses.push([radiusX + (radiusX - zoom) * Math.cos(rad), radiusY + (radiusY - zoom) * Math.sin(rad)]);
        }
        areaPoses.push([radiusX, -2]);
        areaPoses.push([-2, -2]);
        areaPoses.push([-2, radiusY * 2 + 2]);
        areaPoses.push([radiusX * 2 + 2, radiusY * 2 + 2]);
        areaPoses.push([radiusX * 2 + 2, -2]);
        areaPoses.push([radiusX, -2]);
        ellipseClipPath = "polygon(" + areaPoses.map(function(pos) {
          return pos[0] + "px " + pos[1] + "px";
        }).join(", ") + ")";
      }
      controls.push(React.createElement("div", {
        key: "clipEllipse",
        className: prefix("clip-ellipse", "snap-control"),
        style: {
          width: radiusX * 2 + "px",
          height: radiusY * 2 + "px",
          clipPath: ellipseClipPath,
          transform: "translate(" + (-left + distLeft) + "px, " + (-top + distTop) + "px) " + makeMatrixCSS(allMatrix)
        }
      }));
    }
    if (clipArea) {
      var _d2 = getRect(__spreadArray([pos1, pos2, pos3, pos4], poses)), allWidth = _d2.width, allHeight = _d2.height, allLeft_1 = _d2.left, allTop_1 = _d2.top;
      if (isPolygon || isRect || isInset) {
        var areaPoses = isInset ? poses.slice(0, 8) : poses;
        controls.push(React.createElement("div", {
          key: "clipArea",
          className: prefix("clip-area", "snap-control"),
          style: {
            width: allWidth + "px",
            height: allHeight + "px",
            transform: "translate(" + allLeft_1 + "px, " + allTop_1 + "px)",
            clipPath: "polygon(" + areaPoses.map(function(pos) {
              return pos[0] - allLeft_1 + "px " + (pos[1] - allTop_1) + "px";
            }).join(", ") + ")"
          }
        }));
      }
    }
    if (snapBoundInfos) {
      ["vertical", "horizontal"].forEach(function(directionType) {
        var info = snapBoundInfos[directionType];
        var isHorizontal = directionType === "horizontal";
        if (info.isSnap) {
          lines.push.apply(lines, info.snap.posInfos.map(function(_a4, i3) {
            var pos = _a4.pos;
            var snapPos1 = minus(calculatePosition(allMatrix, isHorizontal ? [0, pos] : [pos, 0], n), [left, top]);
            var snapPos2 = minus(calculatePosition(allMatrix, isHorizontal ? [width, pos] : [pos, height], n), [left, top]);
            return renderLine(React, "", snapPos1, snapPos2, zoom, "clip" + directionType + "snap" + i3, "guideline");
          }));
        }
        if (info.isBound) {
          lines.push.apply(lines, info.bounds.map(function(_a4, i3) {
            var pos = _a4.pos;
            var snapPos1 = minus(calculatePosition(allMatrix, isHorizontal ? [0, pos] : [pos, 0], n), [left, top]);
            var snapPos2 = minus(calculatePosition(allMatrix, isHorizontal ? [width, pos] : [pos, height], n), [left, top]);
            return renderLine(React, "", snapPos1, snapPos2, zoom, "clip" + directionType + "bounds" + i3, "guideline", "bounds", "bold");
          }));
        }
      });
    }
    return __spreadArray(__spreadArray([], controls), lines);
  },
  dragControlCondition: function(moveable, e) {
    return e.inputEvent && (e.inputEvent.target.getAttribute("class") || "").indexOf("clip") > -1;
  },
  dragStart: function(moveable, e) {
    var props = moveable.props;
    var _a3 = props.dragWithClip, dragWithClip = _a3 === void 0 ? true : _a3;
    if (dragWithClip) {
      return false;
    }
    return this.dragControlStart(moveable, e);
  },
  drag: function(moveable, e) {
    return this.dragControl(moveable, e);
  },
  dragEnd: function(moveable, e) {
    return this.dragControlEnd(moveable, e);
  },
  dragControlStart: function(moveable, e) {
    var state = moveable.state;
    var _a3 = moveable.props, defaultClipPath = _a3.defaultClipPath, customClipPath = _a3.customClipPath;
    var target = state.target, width = state.width, height = state.height;
    var inputTarget = e.inputEvent ? e.inputEvent.target : null;
    var className = inputTarget && inputTarget.getAttribute("class") || "";
    var datas = e.datas;
    var clipPath = getClipPath(target, width, height, defaultClipPath || "inset", customClipPath);
    if (!clipPath) {
      return false;
    }
    var clipText = clipPath.clipText, type = clipPath.type, poses = clipPath.poses;
    var result = triggerEvent(moveable, "onClipStart", fillParams(moveable, e, {
      clipType: type,
      clipStyle: clipText,
      poses: poses.map(function(pos) {
        return pos.pos;
      })
    }));
    if (result === false) {
      datas.isClipStart = false;
      return false;
    }
    datas.isControl = className && className.indexOf("clip-control") > -1;
    datas.isLine = className.indexOf("clip-line") > -1;
    datas.isArea = className.indexOf("clip-area") > -1 || className.indexOf("clip-ellipse") > -1;
    datas.index = inputTarget ? parseInt(inputTarget.getAttribute("data-clip-index"), 10) : -1;
    datas.clipPath = clipPath;
    datas.isClipStart = true;
    state.clipPathState = clipText;
    setDragStart(moveable, e);
    return true;
  },
  dragControl: function(moveable, e) {
    var _a3;
    var datas = e.datas, originalDatas = e.originalDatas;
    if (!datas.isClipStart) {
      return false;
    }
    var _b3 = datas, isControl = _b3.isControl, isLine = _b3.isLine, isArea = _b3.isArea, index = _b3.index, clipPath = _b3.clipPath;
    if (!clipPath) {
      return false;
    }
    var _c3 = getDragDist(e), distX = _c3[0], distY = _c3[1];
    var props = moveable.props;
    var state = moveable.state;
    var width = state.width, height = state.height;
    var isDragWithTarget = !isArea && !isControl && !isLine;
    var clipType = clipPath.type, clipPoses = clipPath.poses, splitter = clipPath.splitter;
    var poses = clipPoses.map(function(pos) {
      return pos.pos;
    });
    if (isDragWithTarget) {
      distX = -distX;
      distY = -distY;
    }
    var isAll = !isControl || clipPoses[index].direction === "nesw";
    var isRect = clipType === "inset" || clipType === "rect";
    var dists = clipPoses.map(function() {
      return [0, 0];
    });
    if (isControl && !isAll) {
      var _d2 = clipPoses[index], horizontal = _d2.horizontal, vertical = _d2.vertical;
      var dist = [distX * Math.abs(horizontal), distY * Math.abs(vertical)];
      dists = moveControlPos(clipPoses, index, dist, isRect);
    } else if (isAll) {
      dists = poses.map(function() {
        return [distX, distY];
      });
    }
    var nextPoses = poses.map(function(pos, i3) {
      return plus(pos, dists[i3]);
    });
    var guidePoses = __spreadArray([], nextPoses);
    state.snapBoundInfos = null;
    var isCircle = clipPath.type === "circle";
    var isEllipse = clipPath.type === "ellipse";
    if (isCircle || isEllipse) {
      var guideRect = getRect(nextPoses);
      var ry = Math.abs(guideRect.bottom - guideRect.top);
      var rx = Math.abs(isEllipse ? guideRect.right - guideRect.left : ry);
      var bottom = nextPoses[0][1] + ry;
      var left = nextPoses[0][0] - rx;
      var right = nextPoses[0][0] + rx;
      if (isCircle) {
        guidePoses.push([right, guideRect.bottom]);
        dists.push([1, 0]);
      }
      guidePoses.push([guideRect.left, bottom]);
      dists.push([0, 1]);
      guidePoses.push([left, guideRect.bottom]);
      dists.push([1, 0]);
    }
    var guidelines = getDefaultGuidelines((props.clipHorizontalGuidelines || []).map(function(v2) {
      return convertUnitSize("" + v2, height);
    }), (props.clipVerticalGuidelines || []).map(function(v2) {
      return convertUnitSize("" + v2, width);
    }), width, height);
    var guideXPoses = [];
    var guideYPoses = [];
    if (isCircle || isEllipse) {
      guideXPoses = [guidePoses[4][0], guidePoses[2][0]];
      guideYPoses = [guidePoses[1][1], guidePoses[3][1]];
    } else if (isRect) {
      var rectPoses = [guidePoses[0], guidePoses[2], guidePoses[4], guidePoses[6]];
      var rectDists_1 = [dists[0], dists[2], dists[4], dists[6]];
      guideXPoses = rectPoses.filter(function(_2, i3) {
        return rectDists_1[i3][0];
      }).map(function(pos) {
        return pos[0];
      });
      guideYPoses = rectPoses.filter(function(_2, i3) {
        return rectDists_1[i3][1];
      }).map(function(pos) {
        return pos[1];
      });
    } else {
      guideXPoses = guidePoses.filter(function(_2, i3) {
        return dists[i3][0];
      }).map(function(pos) {
        return pos[0];
      });
      guideYPoses = guidePoses.filter(function(_2, i3) {
        return dists[i3][1];
      }).map(function(pos) {
        return pos[1];
      });
    }
    var boundDelta = [0, 0];
    var _loop_12 = function(i3) {
      var _e = checkSnapBounds(guidelines, props.clipTargetBounds && {
        left: 0,
        top: 0,
        right: width,
        bottom: height
      }, guideXPoses, guideYPoses, 5), horizontalSnapInfo = _e.horizontal, verticalSnapInfo = _e.vertical;
      var snapOffsetY = horizontalSnapInfo.offset;
      var snapOffsetX = verticalSnapInfo.offset;
      if (horizontalSnapInfo.isBound) {
        boundDelta[1] += snapOffsetY;
      }
      if (verticalSnapInfo.isBound) {
        boundDelta[0] += snapOffsetX;
      }
      if ((isEllipse || isCircle) && dists[0][0] === 0 && dists[0][1] === 0) {
        var guideRect2 = getRect(nextPoses);
        var cy = guideRect2.bottom - guideRect2.top;
        var cx = isEllipse ? guideRect2.right - guideRect2.left : cy;
        var distSnapX = verticalSnapInfo.isBound ? Math.abs(snapOffsetX) : verticalSnapInfo.snapIndex === 0 ? -snapOffsetX : snapOffsetX;
        var distSnapY = horizontalSnapInfo.isBound ? Math.abs(snapOffsetY) : horizontalSnapInfo.snapIndex === 0 ? -snapOffsetY : snapOffsetY;
        cx -= distSnapX;
        cy -= distSnapY;
        if (isCircle) {
          cy = checkSnapBoundPriority(verticalSnapInfo, horizontalSnapInfo) > 0 ? cy : cx;
          cx = cy;
        }
        var center = guidePoses[0];
        guidePoses[1][1] = center[1] - cy;
        guidePoses[2][0] = center[0] + cx;
        guidePoses[3][1] = center[1] + cy;
        guidePoses[4][0] = center[0] - cx;
      } else {
        guidePoses.forEach(function(pos, j2) {
          var dist2 = dists[j2];
          if (dist2[0]) {
            pos[0] -= snapOffsetX;
          }
          if (dist2[1]) {
            pos[1] -= snapOffsetY;
          }
        });
        return "break";
      }
    };
    for (var i2 = 0; i2 < 2; ++i2) {
      var state_1 = _loop_12();
      if (state_1 === "break")
        break;
    }
    var nextClipStyles = getClipStyles(moveable, clipPath, nextPoses);
    var clipStyle = clipType + "(" + nextClipStyles.join(splitter) + ")";
    state.clipPathState = clipStyle;
    if (isCircle || isEllipse) {
      guideXPoses = [guidePoses[4][0], guidePoses[2][0]];
      guideYPoses = [guidePoses[1][1], guidePoses[3][1]];
    } else if (isRect) {
      var rectPoses = [guidePoses[0], guidePoses[2], guidePoses[4], guidePoses[6]];
      guideXPoses = rectPoses.map(function(pos) {
        return pos[0];
      });
      guideYPoses = rectPoses.map(function(pos) {
        return pos[1];
      });
    } else {
      guideXPoses = guidePoses.map(function(pos) {
        return pos[0];
      });
      guideYPoses = guidePoses.map(function(pos) {
        return pos[1];
      });
    }
    state.snapBoundInfos = checkSnapBounds(guidelines, props.clipTargetBounds && {
      left: 0,
      top: 0,
      right: width,
      bottom: height
    }, guideXPoses, guideYPoses, 1);
    if (originalDatas.draggable) {
      var is3d = state.is3d, allMatrix = state.allMatrix;
      var n = is3d ? 4 : 3;
      _a3 = multiply(allMatrix, [boundDelta[0], boundDelta[1], 0, 0], n), boundDelta[0] = _a3[0], boundDelta[1] = _a3[1];
      originalDatas.draggable.deltaOffset = boundDelta;
    }
    triggerEvent(moveable, "onClip", fillParams(moveable, e, {
      clipEventType: "changed",
      clipType,
      poses: nextPoses,
      clipStyle,
      clipStyles: nextClipStyles,
      distX,
      distY
    }));
    return true;
  },
  dragControlEnd: function(moveable, e) {
    this.unset(moveable);
    var isDrag = e.isDrag, datas = e.datas, isDouble = e.isDouble;
    var isLine = datas.isLine, isClipStart = datas.isClipStart, isControl = datas.isControl;
    if (!isClipStart) {
      return false;
    }
    triggerEvent(moveable, "onClipEnd", fillEndParams(moveable, e, {}));
    if (isDouble) {
      if (isControl) {
        removeClipPath(moveable, e);
      } else if (isLine) {
        addClipPath(moveable, e);
      }
    }
    return isDouble || isDrag;
  },
  unset: function(moveable) {
    moveable.state.clipPathState = "";
    moveable.state.snapBoundInfos = null;
  }
};
var OriginDraggable = {
  name: "originDraggable",
  props: {
    originDraggable: Boolean,
    originRelative: Boolean
  },
  events: {
    onDragOriginStart: "dragOriginStart",
    onDragOrigin: "dragOrigin",
    onDragOriginEnd: "dragOriginEnd"
  },
  css: [":host[data-able-origindraggable] .control.origin {\n    pointer-events: auto;\n}"],
  dragControlCondition: function(_2, e) {
    if (e.isRequest) {
      return e.requestAble === "originDraggable";
    }
    return hasClass(e.inputEvent.target, prefix("origin"));
  },
  dragControlStart: function(moveable, e) {
    var datas = e.datas;
    setDragStart(moveable, e);
    var params = fillParams(moveable, e, {
      dragStart: Draggable.dragStart(moveable, new CustomGesto().dragStart([0, 0], e))
    });
    var result = triggerEvent(moveable, "onDragOriginStart", params);
    datas.startOrigin = moveable.state.transformOrigin;
    datas.startTargetOrigin = moveable.state.targetOrigin;
    datas.prevOrigin = [0, 0];
    datas.isDragOrigin = true;
    if (result === false) {
      datas.isDragOrigin = false;
      return false;
    }
    return params;
  },
  dragControl: function(moveable, e) {
    var datas = e.datas, isPinch = e.isPinch, isRequest = e.isRequest;
    if (!datas.isDragOrigin) {
      return false;
    }
    var _a3 = getDragDist(e), distX = _a3[0], distY = _a3[1];
    var state = moveable.state;
    var width = state.width, height = state.height, offsetMatrix = state.offsetMatrix, targetMatrix = state.targetMatrix, is3d = state.is3d;
    var _b3 = moveable.props.originRelative, originRelative = _b3 === void 0 ? true : _b3;
    var n = is3d ? 4 : 3;
    var dist = [distX, distY];
    if (isRequest) {
      var distOrigin = e.distOrigin;
      if (distOrigin[0] || distOrigin[1]) {
        dist = distOrigin;
      }
    }
    var origin = plus(datas.startOrigin, dist);
    var targetOrigin = plus(datas.startTargetOrigin, dist);
    var delta = minus(dist, datas.prevOrigin);
    var nextMatrix = getNextMatrix(offsetMatrix, targetMatrix, origin, n);
    var rect = moveable.getRect();
    var nextRect = getRect(calculatePoses(nextMatrix, width, height, n));
    var dragDelta = [rect.left - nextRect.left, rect.top - nextRect.top];
    datas.prevOrigin = dist;
    var transformOrigin = [convertCSSSize(targetOrigin[0], width, originRelative), convertCSSSize(targetOrigin[1], height, originRelative)].join(" ");
    var params = fillParams(moveable, e, {
      width,
      height,
      origin,
      dist,
      delta,
      transformOrigin,
      drag: Draggable.drag(moveable, setCustomDrag(e, moveable.state, dragDelta, !!isPinch, false))
    });
    triggerEvent(moveable, "onDragOrigin", params);
    return params;
  },
  dragControlEnd: function(moveable, e) {
    var datas = e.datas;
    if (!datas.isDragOrigin) {
      return false;
    }
    triggerEvent(moveable, "onDragOriginEnd", fillEndParams(moveable, e, {}));
    return true;
  },
  dragGroupControlCondition: function(moveable, e) {
    return this.dragControlCondition(moveable, e);
  },
  dragGroupControlStart: function(moveable, e) {
    var params = this.dragControlStart(moveable, e);
    if (!params) {
      return false;
    }
    return true;
  },
  dragGroupControl: function(moveable, e) {
    var params = this.dragControl(moveable, e);
    if (!params) {
      return false;
    }
    moveable.transformOrigin = params.transformOrigin;
    return true;
  },
  request: function(moveable) {
    var datas = {};
    var rect = moveable.getRect();
    var distX = 0;
    var distY = 0;
    var transformOrigin = rect.transformOrigin;
    var distOrigin = [0, 0];
    return {
      isControl: true,
      requestStart: function() {
        return {
          datas
        };
      },
      request: function(e) {
        if ("deltaOrigin" in e) {
          distOrigin[0] += e.deltaOrigin[0];
          distOrigin[1] += e.deltaOrigin[1];
        } else if ("origin" in e) {
          distOrigin[0] = e.origin[0] - transformOrigin[0];
          distOrigin[1] = e.origin[1] - transformOrigin[1];
        } else {
          if ("x" in e) {
            distX = e.x - rect.left;
          } else if ("deltaX" in e) {
            distX += e.deltaX;
          }
          if ("y" in e) {
            distY = e.y - rect.top;
          } else if ("deltaY" in e) {
            distY += e.deltaY;
          }
        }
        return {
          datas,
          distX,
          distY,
          distOrigin
        };
      },
      requestEnd: function() {
        return {
          datas,
          isDrag: true
        };
      }
    };
  }
};
function addBorderRadius(controlPoses, poses, lineIndex, distX, distY, width, height) {
  var _a3 = splitRadiusPoses(controlPoses), horizontals = _a3.horizontals, verticals = _a3.verticals;
  var horizontalsLength = horizontals.length;
  var verticalsLength = verticals.length;
  var horizontalIndex = -1;
  var verticalIndex = -1;
  if (lineIndex === 0) {
    if (horizontalsLength === 0) {
      horizontalIndex = 0;
    } else if (horizontalsLength === 1) {
      horizontalIndex = 1;
    }
  } else if (lineIndex === 3) {
    if (horizontalsLength <= 2) {
      horizontalIndex = 2;
    } else if (horizontalsLength <= 3) {
      horizontalIndex = 3;
    }
  }
  if (lineIndex === 2) {
    if (verticalsLength === 0) {
      verticalIndex = 0;
    } else if (verticalsLength < 4) {
      verticalIndex = 3;
    }
  } else if (lineIndex === 1) {
    if (verticalsLength <= 1) {
      verticalIndex = 1;
    } else if (verticalsLength <= 2) {
      verticalIndex = 2;
    }
  }
  addRadiusPos(controlPoses, poses, 0, horizontalIndex, verticalIndex, distX, distY, width, height);
}
function getBorderRadius(target, width, height, minCounts, state) {
  if (minCounts === void 0) {
    minCounts = [0, 0];
  }
  var borderRadius;
  var values = [];
  if (!state) {
    var style = getComputedStyle$1(target);
    borderRadius = style && style.borderRadius || "";
  } else {
    borderRadius = state;
  }
  if (!borderRadius || !state && borderRadius === "0px") {
    values = [];
  } else {
    values = splitSpace(borderRadius);
  }
  return getRadiusValues(values, width, height, 0, 0, minCounts);
}
function triggerRoundEvent(moveable, e, dist, delta, controlPoses, nextPoses) {
  var state = moveable.state;
  var width = state.width, height = state.height;
  var _a3 = getRadiusStyles(nextPoses, controlPoses, moveable.props.roundRelative, width, height), raws = _a3.raws, styles = _a3.styles;
  var _b3 = splitRadiusPoses(controlPoses, raws), horizontals = _b3.horizontals, verticals = _b3.verticals;
  var borderRadius = styles.join(" ");
  state.borderRadiusState = borderRadius;
  triggerEvent(moveable, "onRound", fillParams(moveable, e, {
    horizontals,
    verticals,
    borderRadius,
    width,
    height,
    delta,
    dist
  }));
}
var Roundable = {
  name: "roundable",
  props: {
    roundable: Boolean,
    roundRelative: Boolean,
    minRoundControls: Array,
    maxRoundControls: Array,
    roundClickable: Boolean
  },
  events: {
    onRoundStart: "roundStart",
    onRound: "round",
    onRoundEnd: "roundEnd"
  },
  css: [".control.border-radius {\n    background: #d66;\n    cursor: pointer;\n}", ":host[data-able-roundable] .line.direction {\n    cursor: pointer;\n}"],
  render: function(moveable, React) {
    var _a3 = moveable.state, target = _a3.target, width = _a3.width, height = _a3.height, allMatrix = _a3.allMatrix, is3d = _a3.is3d, left = _a3.left, top = _a3.top, borderRadiusState = _a3.borderRadiusState;
    var _b3 = moveable.props, _c3 = _b3.minRoundControls, minRoundControls = _c3 === void 0 ? [0, 0] : _c3, _d2 = _b3.maxRoundControls, maxRoundControls = _d2 === void 0 ? [4, 4] : _d2, zoom = _b3.zoom;
    if (!target) {
      return null;
    }
    var n = is3d ? 4 : 3;
    var radiusValues = getBorderRadius(target, width, height, minRoundControls, borderRadiusState);
    if (!radiusValues) {
      return null;
    }
    var verticalCount = 0;
    var horizontalCount = 0;
    return radiusValues.map(function(v2, i2) {
      horizontalCount += Math.abs(v2.horizontal);
      verticalCount += Math.abs(v2.vertical);
      var pos = minus(calculatePosition(allMatrix, v2.pos, n), [left, top]);
      var isDisplay = v2.vertical ? verticalCount <= maxRoundControls[1] : horizontalCount <= maxRoundControls[0];
      return React.createElement("div", {
        key: "borderRadiusControl" + i2,
        className: prefix("control", "border-radius"),
        "data-radius-index": i2,
        style: {
          display: isDisplay ? "block" : "none",
          transform: "translate(" + pos[0] + "px, " + pos[1] + "px) scale(" + zoom + ")"
        }
      });
    });
  },
  dragControlCondition: function(moveable, e) {
    if (!e.inputEvent || e.isRequest) {
      return false;
    }
    var className = e.inputEvent.target.getAttribute("class") || "";
    return className.indexOf("border-radius") > -1 || className.indexOf("moveable-line") > -1 && className.indexOf("moveable-direction") > -1;
  },
  dragControlStart: function(moveable, e) {
    var inputEvent = e.inputEvent, datas = e.datas;
    var inputTarget = inputEvent.target;
    var className = inputTarget.getAttribute("class") || "";
    var isControl = className.indexOf("border-radius") > -1;
    var isLine = className.indexOf("moveable-line") > -1 && className.indexOf("moveable-direction") > -1;
    var controlIndex = isControl ? parseInt(inputTarget.getAttribute("data-radius-index"), 10) : -1;
    var lineIndex = isLine ? parseInt(inputTarget.getAttribute("data-line-index"), 10) : -1;
    if (!isControl && !isLine) {
      return false;
    }
    var result = triggerEvent(moveable, "onRoundStart", fillParams(moveable, e, {}));
    if (result === false) {
      return false;
    }
    datas.lineIndex = lineIndex;
    datas.controlIndex = controlIndex;
    datas.isControl = isControl;
    datas.isLine = isLine;
    setDragStart(moveable, e);
    var _a3 = moveable.props, roundRelative = _a3.roundRelative, _b3 = _a3.minRoundControls, minRoundControls = _b3 === void 0 ? [0, 0] : _b3;
    var state = moveable.state;
    var target = state.target, width = state.width, height = state.height;
    datas.isRound = true;
    datas.prevDist = [0, 0];
    var controlPoses = getBorderRadius(target, width, height, minRoundControls) || [];
    datas.controlPoses = controlPoses;
    state.borderRadiusState = getRadiusStyles(controlPoses.map(function(pos) {
      return pos.pos;
    }), controlPoses, roundRelative, width, height).styles.join(" ");
    return true;
  },
  dragControl: function(moveable, e) {
    var datas = e.datas;
    if (!datas.isRound || !datas.isControl || !datas.controlPoses.length) {
      return false;
    }
    var index = datas.controlIndex;
    var controlPoses = datas.controlPoses;
    var _a3 = getDragDist(e), distX = _a3[0], distY = _a3[1];
    var dist = [distX, distY];
    var delta = minus(dist, datas.prevDist);
    var _b3 = moveable.props.maxRoundControls, maxRoundControls = _b3 === void 0 ? [4, 4] : _b3;
    var _c3 = moveable.state, width = _c3.width, height = _c3.height;
    var selectedControlPose = controlPoses[index];
    var selectedVertical = selectedControlPose.vertical;
    var selectedHorizontal = selectedControlPose.horizontal;
    var dists = controlPoses.map(function(pose) {
      var horizontal = pose.horizontal, vertical = pose.vertical;
      var poseDist = [horizontal * selectedHorizontal * dist[0], vertical * selectedVertical * dist[1]];
      if (horizontal) {
        if (maxRoundControls[0] === 1) {
          return poseDist;
        } else if (maxRoundControls[0] < 4 && horizontal !== selectedHorizontal) {
          return poseDist;
        }
      } else if (maxRoundControls[1] === 0) {
        poseDist[1] = vertical * selectedHorizontal * dist[0] / width * height;
        return poseDist;
      } else if (selectedVertical) {
        if (maxRoundControls[1] === 1) {
          return poseDist;
        } else if (maxRoundControls[1] < 4 && vertical !== selectedVertical) {
          return poseDist;
        }
      }
      return [0, 0];
    });
    dists[index] = dist;
    var nextPoses = controlPoses.map(function(pos, i2) {
      return plus(pos.pos, dists[i2]);
    });
    datas.prevDist = [distX, distY];
    triggerRoundEvent(moveable, e, dist, delta, controlPoses, nextPoses);
    return true;
  },
  dragControlEnd: function(moveable, e) {
    var state = moveable.state;
    state.borderRadiusState = "";
    var datas = e.datas, isDouble = e.isDouble;
    if (!datas.isRound) {
      return false;
    }
    var width = state.width, height = state.height;
    var isControl = datas.isControl, controlIndex = datas.controlIndex, isLine = datas.isLine, lineIndex = datas.lineIndex;
    var controlPoses = datas.controlPoses;
    var poses = controlPoses.map(function(pos) {
      return pos.pos;
    });
    var length2 = poses.length;
    var _a3 = moveable.props.roundClickable, roundClickable = _a3 === void 0 ? true : _a3;
    if (isDouble && roundClickable) {
      if (isControl) {
        removeRadiusPos(controlPoses, poses, controlIndex, 0);
      } else if (isLine) {
        var _b3 = calculatePointerDist(moveable, e), distX = _b3[0], distY = _b3[1];
        addBorderRadius(controlPoses, poses, lineIndex, distX, distY, width, height);
      }
      if (length2 !== controlPoses.length) {
        triggerRoundEvent(moveable, e, [0, 0], [0, 0], controlPoses, poses);
      }
    }
    triggerEvent(moveable, "onRoundEnd", fillEndParams(moveable, e, {}));
    state.borderRadiusState = "";
    return true;
  },
  unset: function(moveable) {
    moveable.state.borderRadiusState = "";
  }
};
function isIdentityMatrix(matrix, is3d) {
  var value = is3d ? "matrix3d(" + createIdentityMatrix(4) : "matrix(" + createIdentityMatrix(3) + ")";
  return matrix === value || matrix === "matrix(1,0,0,1,0,0)";
}
var BeforeRenderable = {
  isPinch: true,
  name: "beforeRenderable",
  props: {},
  events: {
    onBeforeRenderStart: "beforeRenderStart",
    onBeforeRender: "beforeRender",
    onBeforeRenderEnd: "beforeRenderEnd",
    onBeforeRenderGroupStart: "beforeRenderGroupStart",
    onBeforeRenderGroup: "beforeRenderGroup",
    onBeforeRenderGroupEnd: "beforeRenderGroupEnd"
  },
  dragRelation: "weak",
  setTransform: function(moveable, e) {
    var _a3 = moveable.state, is3d = _a3.is3d, target = _a3.target, targetMatrix = _a3.targetMatrix;
    var transform = target === null || target === void 0 ? void 0 : target.style.transform;
    var cssMatrix = is3d ? "matrix3d(" + targetMatrix.join(",") + ")" : "matrix(" + convertMatrixtoCSS(targetMatrix, true) + ")";
    var startTransform = !transform || transform === "none" ? cssMatrix : transform;
    e.datas.startTransforms = isIdentityMatrix(startTransform, is3d) ? [] : splitSpace(startTransform);
  },
  resetTransform: function(e) {
    e.datas.nextTransforms = e.datas.startTransforms;
    e.datas.nextTransformAppendedIndexes = [];
  },
  fillDragStartParams: function(moveable, e) {
    return fillParams(moveable, e, {
      setTransform: function(transform) {
        e.datas.startTransforms = isArray(transform) ? transform : splitSpace(transform);
      },
      isPinch: !!e.isPinch
    });
  },
  fillDragParams: function(moveable, e) {
    return fillParams(moveable, e, {
      isPinch: !!e.isPinch
    });
  },
  dragStart: function(moveable, e) {
    this.setTransform(moveable, e);
    triggerEvent(moveable, "onBeforeRenderStart", this.fillDragStartParams(moveable, e));
  },
  drag: function(moveable, e) {
    this.resetTransform(e);
    triggerEvent(moveable, "onBeforeRender", fillParams(moveable, e, {
      isPinch: !!e.isPinch
    }));
  },
  dragEnd: function(moveable, e) {
    triggerEvent(moveable, "onBeforeRenderEnd", fillParams(moveable, e, {
      isPinch: !!e.isPinch,
      isDrag: e.isDrag
    }));
  },
  dragGroupStart: function(moveable, e) {
    var _this = this;
    this.dragStart(moveable, e);
    var events = fillChildEvents(moveable, "beforeRenderable", e);
    var moveables = moveable.moveables;
    var params = events.map(function(childEvent, i2) {
      var childMoveable = moveables[i2];
      _this.setTransform(childMoveable, childEvent);
      return _this.fillDragStartParams(childMoveable, childEvent);
    });
    triggerEvent(moveable, "onBeforeRenderGroupStart", fillParams(moveable, e, {
      isPinch: !!e.isPinch,
      targets: moveable.props.targets,
      setTransform: function() {
      },
      events: params
    }));
  },
  dragGroup: function(moveable, e) {
    var _this = this;
    this.drag(moveable, e);
    var events = fillChildEvents(moveable, "beforeRenderable", e);
    var moveables = moveable.moveables;
    var params = events.map(function(childEvent, i2) {
      var childMoveable = moveables[i2];
      _this.resetTransform(childEvent);
      return _this.fillDragParams(childMoveable, childEvent);
    });
    triggerEvent(moveable, "onBeforeRenderGroup", fillParams(moveable, e, {
      isPinch: !!e.isPinch,
      targets: moveable.props.targets,
      events: params
    }));
  },
  dragGroupEnd: function(moveable, e) {
    this.dragEnd(moveable, e);
    triggerEvent(moveable, "onBeforeRenderGroupEnd", fillParams(moveable, e, {
      isPinch: !!e.isPinch,
      isDrag: e.isDrag,
      targets: moveable.props.targets
    }));
  },
  dragControlStart: function(moveable, e) {
    return this.dragStart(moveable, e);
  },
  dragControl: function(moveable, e) {
    return this.drag(moveable, e);
  },
  dragControlEnd: function(moveable, e) {
    return this.dragEnd(moveable, e);
  },
  dragGroupControlStart: function(moveable, e) {
    return this.dragGroupStart(moveable, e);
  },
  dragGroupControl: function(moveable, e) {
    return this.dragGroup(moveable, e);
  },
  dragGroupControlEnd: function(moveable, e) {
    return this.dragGroupEnd(moveable, e);
  }
};
var Renderable = {
  name: "renderable",
  props: {},
  events: {
    onRenderStart: "renderStart",
    onRender: "render",
    onRenderEnd: "renderEnd",
    onRenderGroupStart: "renderGroupStart",
    onRenderGroup: "renderGroup",
    onRenderGroupEnd: "renderGroupEnd"
  },
  dragRelation: "weak",
  dragStart: function(moveable, e) {
    triggerEvent(moveable, "onRenderStart", fillParams(moveable, e, {
      isPinch: !!e.isPinch
    }));
  },
  drag: function(moveable, e) {
    triggerEvent(moveable, "onRender", this.fillDragParams(moveable, e));
  },
  dragAfter: function(moveable, e) {
    if (e.resultCount) {
      return this.drag(moveable, e);
    }
  },
  dragEnd: function(moveable, e) {
    triggerEvent(moveable, "onRenderEnd", this.fillDragEndParams(moveable, e));
  },
  dragGroupStart: function(moveable, e) {
    triggerEvent(moveable, "onRenderGroupStart", fillParams(moveable, e, {
      isPinch: !!e.isPinch,
      targets: moveable.props.targets
    }));
  },
  dragGroup: function(moveable, e) {
    var _this = this;
    var events = fillChildEvents(moveable, "beforeRenderable", e);
    var moveables = moveable.moveables;
    var params = events.map(function(childEvent, i2) {
      var childMoveable = moveables[i2];
      return _this.fillDragParams(childMoveable, childEvent);
    });
    triggerEvent(moveable, "onRenderGroup", fillParams(moveable, e, {
      isPinch: !!e.isPinch,
      targets: moveable.props.targets,
      transform: getNextTransformText(e),
      events: params
    }));
  },
  dragGroupEnd: function(moveable, e) {
    var _this = this;
    var events = fillChildEvents(moveable, "beforeRenderable", e);
    var moveables = moveable.moveables;
    var params = events.map(function(childEvent, i2) {
      var childMoveable = moveables[i2];
      return _this.fillDragEndParams(childMoveable, childEvent);
    });
    triggerEvent(moveable, "onRenderGroupEnd", fillParams(moveable, e, {
      isPinch: !!e.isPinch,
      isDrag: e.isDrag,
      targets: moveable.props.targets,
      events: params
    }));
  },
  dragControlStart: function(moveable, e) {
    return this.dragStart(moveable, e);
  },
  dragControl: function(moveable, e) {
    return this.drag(moveable, e);
  },
  dragControlAfter: function(moveable, e) {
    return this.dragAfter(moveable, e);
  },
  dragControlEnd: function(moveable, e) {
    return this.dragEnd(moveable, e);
  },
  dragGroupControlStart: function(moveable, e) {
    return this.dragGroupStart(moveable, e);
  },
  dragGroupControl: function(moveable, e) {
    return this.dragGroup(moveable, e);
  },
  dragGroupControlEnd: function(moveable, e) {
    return this.dragGroupEnd(moveable, e);
  },
  fillDragParams: function(moveable, e) {
    return fillParams(moveable, e, {
      isPinch: !!e.isPinch,
      transform: getNextTransformText(e)
    });
  },
  fillDragEndParams: function(moveable, e) {
    return fillParams(moveable, e, {
      isPinch: !!e.isPinch,
      isDrag: e.isDrag
    });
  }
};
function triggerAble(moveable, ableType, eventOperation, eventAffix, eventType, e, requestInstant) {
  var isStart = eventType === "Start";
  var target = moveable.state.target;
  var isRequest = e.isRequest;
  if (!target || isStart && eventAffix.indexOf("Control") > -1 && !isRequest && moveable.areaElement === e.inputEvent.target) {
    return false;
  }
  var eventName = "" + eventOperation + eventAffix + eventType;
  var conditionName = "" + eventOperation + eventAffix + "Condition";
  var isEnd = eventType === "End";
  var isAfter = eventType === "After";
  var isFirstStart = isStart && (!moveable.targetGesto || !moveable.controlGesto || !moveable.targetGesto.isFlag() || !moveable.controlGesto.isFlag());
  if (isFirstStart) {
    moveable.updateRect(eventType, true, false);
  }
  if (eventType === "" && !isRequest) {
    convertDragDist(moveable.state, e);
  }
  var ables = __spreadArray([], moveable[ableType]);
  if (isRequest) {
    var requestAble_1 = e.requestAble;
    if (!ables.some(function(able) {
      return able.name === requestAble_1;
    })) {
      ables.push.apply(ables, moveable.props.ables.filter(function(able) {
        return able.name === requestAble_1;
      }));
    }
  }
  if (!ables.length) {
    return false;
  }
  var eventAbles = __spreadArray(__spreadArray([BeforeRenderable], ables), [Renderable]).filter(function(able) {
    return able[eventName];
  });
  var datas = e.datas;
  if (isFirstStart) {
    eventAbles.forEach(function(able) {
      able.unset && able.unset(moveable);
    });
  }
  var inputEvent = e.inputEvent;
  var inputTarget;
  if (isEnd && inputEvent) {
    inputTarget = document.elementFromPoint(e.clientX, e.clientY) || inputEvent.target;
  }
  var resultCount = 0;
  var results = eventAbles.filter(function(able) {
    var ableName = able.name;
    var nextDatas = datas[ableName] || (datas[ableName] = {});
    if (isStart) {
      nextDatas.isEventStart = !able[conditionName] || able[conditionName](moveable, e);
    }
    if (nextDatas.isEventStart) {
      var result = able[eventName](moveable, __assign$2(__assign$2({}, e), {
        resultCount,
        datas: nextDatas,
        originalDatas: datas,
        inputTarget
      }));
      if (isStart && result === false) {
        nextDatas.isEventStart = false;
      }
      resultCount += result ? 1 : 0;
      return result;
    }
    return false;
  });
  var isUpdate = results.length;
  var isForceEnd = false;
  if (isStart && eventAbles.length && !isUpdate) {
    isForceEnd = eventAbles.filter(function(able) {
      var ableName = able.name;
      var nextDatas = datas[ableName];
      if (nextDatas.isEventStart) {
        if (able.dragRelation === "strong") {
          nextDatas.isEventStart = false;
          return false;
        }
        return true;
      }
      return false;
    }).length === 0;
  }
  if (isEnd || isForceEnd) {
    moveable.state.gesto = null;
    if (moveable.moveables) {
      moveable.moveables.forEach(function(childMoveable) {
        childMoveable.state.gesto = null;
      });
    }
  }
  if (isFirstStart && isForceEnd) {
    eventAbles.forEach(function(able) {
      able.unset && able.unset(moveable);
    });
  }
  if (isStart && !isRequest && isUpdate) {
    e === null || e === void 0 ? void 0 : e.preventDefault();
  }
  if (moveable.isUnmounted || isForceEnd) {
    return false;
  }
  if (!isStart && isUpdate && !requestInstant || isEnd) {
    moveable.updateRect(isEnd ? eventType : "", true, false);
    moveable.forceUpdate();
  }
  if (!isStart && !isEnd && !isAfter && isUpdate && !requestInstant) {
    triggerAble(moveable, ableType, eventOperation, eventAffix, eventType + "After", e);
  }
  return true;
}
function getTargetAbleGesto(moveable, moveableTarget, eventAffix) {
  var controlBox = moveable.controlBox.getElement();
  var targets = [];
  targets.push(controlBox);
  if (!moveable.props.dragArea || moveable.props.dragTarget) {
    targets.push(moveableTarget);
  }
  var startFunc = function(e) {
    var eventTarget = e.inputEvent.target;
    var areaElement = moveable.areaElement;
    return eventTarget === areaElement || !moveable.isMoveableElement(eventTarget) && !moveable.controlBox.getElement().contains(eventTarget) || hasClass(eventTarget, "moveable-area") || hasClass(eventTarget, "moveable-padding");
  };
  return getAbleGesto(moveable, targets, "targetAbles", eventAffix, {
    dragStart: startFunc,
    pinchStart: startFunc
  });
}
function getAbleGesto(moveable, target, ableType, eventAffix, conditionFunctions) {
  if (conditionFunctions === void 0) {
    conditionFunctions = {};
  }
  var _a3 = moveable.props, pinchOutside = _a3.pinchOutside, pinchThreshold = _a3.pinchThreshold;
  var options = {
    preventDefault: false,
    container: window,
    pinchThreshold,
    pinchOutside
  };
  var gesto = new Gesto$1(target, options);
  ["drag", "pinch"].forEach(function(eventOperation) {
    ["Start", "", "End"].forEach(function(eventType) {
      gesto.on("" + eventOperation + eventType, function(e) {
        var eventName = e.eventType;
        if (conditionFunctions[eventName] && !conditionFunctions[eventName](e)) {
          e.stop();
          return;
        }
        var result = triggerAble(moveable, ableType, eventOperation, eventAffix, eventType, e);
        if (!result) {
          e.stop();
        }
      });
    });
  });
  return gesto;
}
var EventManager = /* @__PURE__ */ function() {
  function EventManager2(target, moveable, eventName) {
    var _this = this;
    this.target = target;
    this.moveable = moveable;
    this.eventName = eventName;
    this.ables = [];
    this.onEvent = function(e) {
      var eventName2 = _this.eventName;
      var moveable2 = _this.moveable;
      if (moveable2.state.disableNativeEvent) {
        return;
      }
      _this.ables.forEach(function(able) {
        able[eventName2](moveable2, {
          inputEvent: e
        });
      });
    };
    this.target.addEventListener(this.eventName.toLowerCase(), this.onEvent);
  }
  var __proto = EventManager2.prototype;
  __proto.setAbles = function(ables) {
    this.ables = ables;
  };
  __proto.destroy = function() {
    this.target.removeEventListener(this.eventName.toLowerCase(), this.onEvent);
    this.target = null;
    this.moveable = null;
  };
  return EventManager2;
}();
var MoveableManager$1 = /* @__PURE__ */ function(_super) {
  __extends$1(MoveableManager2, _super);
  function MoveableManager2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.state = __assign$2({
      container: null,
      gesto: null,
      renderPoses: [[0, 0], [0, 0], [0, 0], [0, 0]],
      disableNativeEvent: false
    }, getTargetInfo(null));
    _this.enabledAbles = [];
    _this.targetAbles = [];
    _this.controlAbles = [];
    _this.rotation = 0;
    _this.scale = [1, 1];
    _this.isUnmounted = false;
    _this.events = {
      "mouseEnter": null,
      "mouseLeave": null
    };
    _this._prevTarget = null;
    _this._prevDragArea = false;
    _this._observer = null;
    _this._observerId = 0;
    _this.onPreventClick = function(e) {
      e.stopPropagation();
      removeEvent(window, "click", _this.onPreventClick, true);
    };
    _this.checkUpdateRect = function() {
      if (_this.isDragging()) {
        return;
      }
      var parentMoveable = _this.props.parentMoveable;
      if (parentMoveable) {
        parentMoveable.checkUpdateRect();
        return;
      }
      cancelAnimationFrame$1(_this._observerId);
      _this._observerId = requestAnimationFrame$1(function() {
        if (_this.isDragging()) {
          return;
        }
        _this.updateRect();
      });
    };
    return _this;
  }
  var __proto = MoveableManager2.prototype;
  __proto.render = function() {
    var props = this.props;
    var state = this.state;
    var parentPosition = props.parentPosition, className = props.className, propsTarget = props.target, zoom = props.zoom, cspNonce = props.cspNonce, translateZ = props.translateZ, ControlBoxElement = props.cssStyled, portalContainer = props.portalContainer;
    this.checkUpdate();
    this.updateRenderPoses();
    var _a3 = parentPosition || {
      left: 0,
      top: 0
    }, parentLeft = _a3.left, parentTop = _a3.top;
    var left = state.left, top = state.top, stateTarget = state.target, direction = state.direction;
    var groupTargets = props.targets;
    var isDisplay = (groupTargets && groupTargets.length || propsTarget) && stateTarget;
    var isDragging = this.isDragging();
    var ableAttributes = {};
    this.getEnabledAbles().forEach(function(able) {
      ableAttributes["data-able-" + able.name.toLowerCase()] = true;
    });
    return createElement(ControlBoxElement, __assign$2({
      cspNonce,
      ref: ref(this, "controlBox"),
      className: prefix("control-box", direction === -1 ? "reverse" : "", isDragging ? "dragging" : "") + " " + className
    }, ableAttributes, {
      onClick: this.onPreventClick,
      portalContainer,
      style: {
        "position": "absolute",
        "display": isDisplay ? "block" : "none",
        "transform": "translate3d(" + (left - parentLeft) + "px, " + (top - parentTop) + "px, " + translateZ + ")",
        "--zoom": zoom,
        "--zoompx": zoom + "px"
      }
    }), this.renderAbles(), this._renderLines());
  };
  __proto.componentDidMount = function() {
    this.controlBox.getElement();
    var props = this.props;
    var parentMoveable = props.parentMoveable, container = props.container, wrapperMoveable = props.wrapperMoveable;
    this._updateTargets();
    this._updateNativeEvents();
    this._updateEvents();
    if (!container && !parentMoveable && !wrapperMoveable) {
      this.updateRect("", false, true);
    }
    this.updateCheckInput();
    this._updateObserver(this.props);
  };
  __proto.componentDidUpdate = function(prevProps) {
    this._updateNativeEvents();
    this._updateEvents();
    this._updateTargets();
    this.updateCheckInput();
    this._updateObserver(prevProps);
  };
  __proto.componentWillUnmount = function() {
    this.isUnmounted = true;
    unset(this, "targetGesto");
    unset(this, "controlGesto");
    var events = this.events;
    for (var name2 in events) {
      var manager = events[name2];
      manager && manager.destroy();
    }
  };
  __proto.getContainer = function() {
    var _a3 = this.props, parentMoveable = _a3.parentMoveable, wrapperMoveable = _a3.wrapperMoveable, container = _a3.container;
    return container || wrapperMoveable && wrapperMoveable.getContainer() || parentMoveable && parentMoveable.getContainer() || this.controlBox.getElement().parentElement;
  };
  __proto.isMoveableElement = function(target) {
    return target && (target.getAttribute("class") || "").indexOf(PREFIX) > -1;
  };
  __proto.dragStart = function(e) {
    if (this.targetGesto) {
      this.targetGesto.triggerDragStart(e);
    }
    return this;
  };
  __proto.hitTest = function(el) {
    var _a3 = this.state, target = _a3.target, pos1 = _a3.pos1, pos2 = _a3.pos2, pos3 = _a3.pos3, pos4 = _a3.pos4, targetClientRect = _a3.targetClientRect;
    if (!target) {
      return 0;
    }
    var rect;
    if (el instanceof Element) {
      var clientRect = el.getBoundingClientRect();
      rect = {
        left: clientRect.left,
        top: clientRect.top,
        width: clientRect.width,
        height: clientRect.height
      };
    } else {
      rect = __assign$2({
        width: 0,
        height: 0
      }, el);
    }
    var rectLeft = rect.left, rectTop = rect.top, rectWidth = rect.width, rectHeight = rect.height;
    var points = fitPoints([pos1, pos2, pos4, pos3], targetClientRect);
    var size = getOverlapSize(points, [[rectLeft, rectTop], [rectLeft + rectWidth, rectTop], [rectLeft + rectWidth, rectTop + rectHeight], [rectLeft, rectTop + rectHeight]]);
    var totalSize = getAreaSize(points);
    if (!size || !totalSize) {
      return 0;
    }
    return Math.min(100, size / totalSize * 100);
  };
  __proto.isInside = function(clientX, clientY) {
    var _a3 = this.state, target = _a3.target, pos1 = _a3.pos1, pos2 = _a3.pos2, pos3 = _a3.pos3, pos4 = _a3.pos4, targetClientRect = _a3.targetClientRect;
    if (!target) {
      return false;
    }
    return isInside([clientX, clientY], fitPoints([pos1, pos2, pos4, pos3], targetClientRect));
  };
  __proto.updateRect = function(type, isTarget, isSetState) {
    if (isSetState === void 0) {
      isSetState = true;
    }
    var props = this.props;
    var parentMoveable = props.parentMoveable;
    var state = this.state;
    var target = state.target || this.props.target;
    var container = this.getContainer();
    var rootContainer = parentMoveable ? parentMoveable.props.rootContainer : props.rootContainer;
    this.updateState(getTargetInfo(this.controlBox && this.controlBox.getElement(), target, container, container, rootContainer || container), parentMoveable ? false : isSetState);
  };
  __proto.isDragging = function() {
    return (this.targetGesto ? this.targetGesto.isFlag() : false) || (this.controlGesto ? this.controlGesto.isFlag() : false);
  };
  __proto.updateTarget = function(type) {
    this.updateRect(type, true);
  };
  __proto.getRect = function() {
    var state = this.state;
    var poses = getAbsolutePosesByState(this.state);
    var pos1 = poses[0], pos2 = poses[1], pos3 = poses[2], pos4 = poses[3];
    var rect = getRect(poses);
    var offsetWidth = state.width, offsetHeight = state.height;
    var width = rect.width, height = rect.height, left = rect.left, top = rect.top;
    var statePos = [state.left, state.top];
    var origin = plus(statePos, state.origin);
    var beforeOrigin = plus(statePos, state.beforeOrigin);
    var transformOrigin = state.transformOrigin;
    return {
      width,
      height,
      left,
      top,
      pos1,
      pos2,
      pos3,
      pos4,
      offsetWidth,
      offsetHeight,
      beforeOrigin,
      origin,
      transformOrigin,
      rotation: this.getRotation()
    };
  };
  __proto.getManager = function() {
    return this;
  };
  __proto.getRotation = function() {
    var _a3 = this.state, pos1 = _a3.pos1, pos2 = _a3.pos2, direction = _a3.direction;
    return getAbsoluteRotation(pos1, pos2, direction);
  };
  __proto.request = function(ableName, param, isInstant) {
    if (param === void 0) {
      param = {};
    }
    var _a3 = this.props, ables = _a3.ables, groupable = _a3.groupable;
    var requsetAble = ables.filter(function(able) {
      return able.name === ableName;
    })[0];
    if (this.isDragging() || !requsetAble || !requsetAble.request) {
      return {
        request: function() {
          return this;
        },
        requestEnd: function() {
          return this;
        }
      };
    }
    var self2 = this;
    var ableRequester = requsetAble.request(this);
    var requestInstant = isInstant || param.isInstant;
    var ableType = ableRequester.isControl ? "controlAbles" : "targetAbles";
    var eventAffix = (groupable ? "Group" : "") + (ableRequester.isControl ? "Control" : "");
    var requester = {
      request: function(ableParam) {
        triggerAble(self2, ableType, "drag", eventAffix, "", __assign$2(__assign$2({}, ableRequester.request(ableParam)), {
          requestAble: ableName,
          isRequest: true
        }), requestInstant);
        return this;
      },
      requestEnd: function() {
        triggerAble(self2, ableType, "drag", eventAffix, "End", __assign$2(__assign$2({}, ableRequester.requestEnd()), {
          requestAble: ableName,
          isRequest: true
        }), requestInstant);
        return this;
      }
    };
    triggerAble(self2, ableType, "drag", eventAffix, "Start", __assign$2(__assign$2({}, ableRequester.requestStart(param)), {
      requestAble: ableName,
      isRequest: true
    }), requestInstant);
    return requestInstant ? requester.request(param).requestEnd() : requester;
  };
  __proto.destroy = function() {
    this.componentWillUnmount();
  };
  __proto.updateRenderPoses = function() {
    var state = this.state;
    var props = this.props;
    var originalBeforeOrigin = state.originalBeforeOrigin, transformOrigin = state.transformOrigin, allMatrix = state.allMatrix, is3d = state.is3d, pos1 = state.pos1, pos2 = state.pos2, pos3 = state.pos3, pos4 = state.pos4, stateLeft = state.left, stateTop = state.top;
    var _a3 = props.padding || {}, _b3 = _a3.left, left = _b3 === void 0 ? 0 : _b3, _c3 = _a3.top, top = _c3 === void 0 ? 0 : _c3, _d2 = _a3.bottom, bottom = _d2 === void 0 ? 0 : _d2, _e = _a3.right, right = _e === void 0 ? 0 : _e;
    var n = is3d ? 4 : 3;
    var absoluteOrigin = props.groupable ? originalBeforeOrigin : plus(originalBeforeOrigin, [stateLeft, stateTop]);
    state.renderPoses = [plus(pos1, calculatePadding(allMatrix, [-left, -top], transformOrigin, absoluteOrigin, n)), plus(pos2, calculatePadding(allMatrix, [right, -top], transformOrigin, absoluteOrigin, n)), plus(pos3, calculatePadding(allMatrix, [-left, bottom], transformOrigin, absoluteOrigin, n)), plus(pos4, calculatePadding(allMatrix, [right, bottom], transformOrigin, absoluteOrigin, n))];
  };
  __proto.checkUpdate = function() {
    var _a3 = this.props, target = _a3.target, container = _a3.container, parentMoveable = _a3.parentMoveable;
    var _b3 = this.state, stateTarget = _b3.target, stateContainer = _b3.container;
    if (!stateTarget && !target) {
      return;
    }
    this.updateAbles();
    var isChanged = !equals(stateTarget, target) || !equals(stateContainer, container);
    if (!isChanged) {
      return;
    }
    var moveableContainer = container || this.controlBox;
    if (moveableContainer) {
      this.unsetAbles();
    }
    this.updateState({
      target,
      container
    });
    if (!parentMoveable && moveableContainer) {
      this.updateRect("End", false, false);
    }
  };
  __proto.triggerEvent = function(name2, e) {
    var callback = this.props[name2];
    return callback && callback(e);
  };
  __proto.useCSS = function(tag, css) {
    var customStyleMap = this.props.customStyledMap;
    var key = tag + css;
    if (!customStyleMap[key]) {
      customStyleMap[key] = styled(tag, css);
    }
    return customStyleMap[key];
  };
  __proto.unsetAbles = function() {
    var _this = this;
    this.targetAbles.forEach(function(able) {
      if (able.unset) {
        able.unset(_this);
      }
    });
  };
  __proto.updateAbles = function(ables, eventAffix) {
    if (ables === void 0) {
      ables = this.props.ables;
    }
    if (eventAffix === void 0) {
      eventAffix = "";
    }
    var props = this.props;
    var triggerAblesSimultaneously = props.triggerAblesSimultaneously;
    var enabledAbles = ables.filter(function(able) {
      return able && (able.always && props[able.name] !== false || props[able.name]);
    });
    var dragStart = "drag" + eventAffix + "Start";
    var pinchStart = "pinch" + eventAffix + "Start";
    var dragControlStart = "drag" + eventAffix + "ControlStart";
    var targetAbles = filterAbles(enabledAbles, [dragStart, pinchStart], triggerAblesSimultaneously);
    var controlAbles = filterAbles(enabledAbles, [dragControlStart], triggerAblesSimultaneously);
    this.enabledAbles = enabledAbles;
    this.targetAbles = targetAbles;
    this.controlAbles = controlAbles;
  };
  __proto.updateState = function(nextState, isSetState) {
    if (isSetState) {
      this.setState(nextState);
    } else {
      var state = this.state;
      for (var name2 in nextState) {
        state[name2] = nextState[name2];
      }
    }
  };
  __proto.getEnabledAbles = function() {
    var props = this.props;
    var ables = props.ables;
    return ables.filter(function(able) {
      return able && props[able.name];
    });
  };
  __proto.renderAbles = function() {
    var _this = this;
    var props = this.props;
    var triggerAblesSimultaneously = props.triggerAblesSimultaneously;
    var Renderer2 = {
      createElement
    };
    return groupByMap(flat(filterAbles(this.getEnabledAbles(), ["render"], triggerAblesSimultaneously).map(function(_a3) {
      var render2 = _a3.render;
      return render2(_this, Renderer2) || [];
    })).filter(function(el) {
      return el;
    }), function(_a3) {
      var key = _a3.key;
      return key;
    }).map(function(group) {
      return group[0];
    });
  };
  __proto.updateCheckInput = function() {
    this.targetGesto && (this.targetGesto.options.checkInput = this.props.checkInput);
  };
  __proto._updateObserver = function(prevProps) {
    var _a3;
    var props = this.props;
    var target = props.target;
    if (!window.ResizeObserver || !target || !props.useResizeObserver) {
      (_a3 = this._observer) === null || _a3 === void 0 ? void 0 : _a3.disconnect();
      return;
    }
    if (prevProps.target === target && this._observer) {
      return;
    }
    var observer = new ResizeObserver(this.checkUpdateRect);
    observer.observe(target, {
      box: "border-box"
    });
    this._observer = observer;
    return;
  };
  __proto._updateEvents = function() {
    var controlBoxElement = this.controlBox.getElement();
    var hasTargetAble = this.targetAbles.length;
    var hasControlAble = this.controlAbles.length;
    var props = this.props;
    var target = props.dragTarget || props.target;
    var isUnset = !hasTargetAble && this.targetGesto || this._isTargetChanged(true);
    if (isUnset) {
      unset(this, "targetGesto");
      this.updateState({
        gesto: null
      });
    }
    if (!hasControlAble) {
      unset(this, "controlGesto");
    }
    if (target && hasTargetAble && !this.targetGesto) {
      this.targetGesto = getTargetAbleGesto(this, target, "");
    }
    if (!this.controlGesto && hasControlAble) {
      this.controlGesto = getAbleGesto(this, controlBoxElement, "controlAbles", "Control");
    }
  };
  __proto._updateTargets = function() {
    var props = this.props;
    this._prevTarget = props.dragTarget || props.target;
    this._prevDragArea = props.dragArea;
  };
  __proto._renderLines = function() {
    var props = this.props;
    var edge = props.edge, zoom = props.zoom, hideDefaultLines = props.hideDefaultLines;
    if (hideDefaultLines) {
      return [];
    }
    var renderPoses = this.state.renderPoses;
    var Renderer2 = {
      createElement
    };
    return [renderLine(Renderer2, edge ? "n" : "", renderPoses[0], renderPoses[1], zoom, 0), renderLine(Renderer2, edge ? "e" : "", renderPoses[1], renderPoses[3], zoom, 1), renderLine(Renderer2, edge ? "w" : "", renderPoses[0], renderPoses[2], zoom, 2), renderLine(Renderer2, edge ? "s" : "", renderPoses[2], renderPoses[3], zoom, 3)];
  };
  __proto._isTargetChanged = function(useDragArea) {
    var props = this.props;
    var target = props.dragTarget || props.target;
    var prevTarget = this._prevTarget;
    var prevDragArea = this._prevDragArea;
    var dragArea = props.dragArea;
    var isTargetChanged = !dragArea && prevTarget !== target;
    var isDragAreaChanged = (useDragArea || dragArea) && prevDragArea !== dragArea;
    return isTargetChanged || isDragAreaChanged;
  };
  __proto._updateNativeEvents = function() {
    var _this = this;
    var props = this.props;
    var target = props.dragArea ? this.areaElement : this.state.target;
    var events = this.events;
    var eventKeys = getKeys(events);
    if (this._isTargetChanged()) {
      for (var eventName in events) {
        var manager = events[eventName];
        manager && manager.destroy();
        events[eventName] = null;
      }
    }
    if (!target) {
      return;
    }
    var enabledAbles = this.enabledAbles;
    eventKeys.forEach(function(eventName2) {
      var ables = filterAbles(enabledAbles, [eventName2]);
      var hasAbles = ables.length > 0;
      var manager2 = events[eventName2];
      if (!hasAbles) {
        if (manager2) {
          manager2.destroy();
          events[eventName2] = null;
        }
        return;
      }
      if (!manager2) {
        manager2 = new EventManager(target, _this, eventName2);
        events[eventName2] = manager2;
      }
      manager2.setAbles(ables);
    });
  };
  MoveableManager2.defaultProps = {
    target: null,
    dragTarget: null,
    container: null,
    rootContainer: null,
    origin: true,
    edge: false,
    parentMoveable: null,
    wrapperMoveable: null,
    parentPosition: null,
    portalContainer: null,
    useResizeObserver: false,
    ables: [],
    pinchThreshold: 20,
    dragArea: false,
    passDragArea: false,
    transformOrigin: "",
    className: "",
    zoom: 1,
    triggerAblesSimultaneously: false,
    padding: {},
    pinchOutside: true,
    checkInput: false,
    groupable: false,
    hideDefaultLines: false,
    cspNonce: "",
    translateZ: 0,
    cssStyled: null,
    customStyledMap: {},
    props: {}
  };
  return MoveableManager2;
}(PureComponent);
var Groupable = {
  name: "groupable",
  props: {
    defaultGroupRotate: Number,
    defaultGroupOrigin: String,
    groupable: Boolean
  },
  events: {},
  render: function(moveable, React) {
    var targets = moveable.props.targets || [];
    moveable.moveables = [];
    var _a3 = moveable.state, left = _a3.left, top = _a3.top;
    var position = {
      left,
      top
    };
    var props = moveable.props;
    return targets.map(function(target, i2) {
      return React.createElement(MoveableManager$1, {
        key: "moveable" + i2,
        ref: refs(moveable, "moveables", i2),
        target,
        origin: false,
        cssStyled: props.cssStyled,
        customStyledMap: props.customStyledMap,
        useResizeObserver: props.useResizeObserver,
        parentMoveable: moveable,
        parentPosition: position
      });
    });
  }
};
var Clickable = makeAble("clickable", {
  props: {
    clickable: Boolean
  },
  events: {
    onClick: "click",
    onClickGroup: "clickGroup"
  },
  always: true,
  dragRelation: "weak",
  dragStart: function(moveable, e) {
    if (!e.isRequest) {
      addEvent(window, "click", moveable.onPreventClick, true);
    }
  },
  dragControlStart: function(moveable, e) {
    this.dragStart(moveable, e);
  },
  dragGroupStart: function(moveable, e) {
    this.dragStart(moveable, e);
    e.datas.inputTarget = e.inputEvent && e.inputEvent.target;
  },
  dragEnd: function(moveable, e) {
    this.endEvent(moveable);
    var target = moveable.state.target;
    var inputEvent = e.inputEvent;
    var inputTarget = e.inputTarget;
    var isMoveableElement = moveable.isMoveableElement(inputTarget);
    var containsElement = !isMoveableElement && moveable.controlBox.getElement().contains(inputTarget);
    if (!e.isDrag || containsElement) {
      this.unset(moveable);
    }
    if (!inputEvent || !inputTarget || e.isDrag || moveable.isMoveableElement(inputTarget) || containsElement) {
      return;
    }
    var containsTarget = target.contains(inputTarget);
    triggerEvent(moveable, "onClick", fillParams(moveable, e, {
      isDouble: e.isDouble,
      inputTarget,
      isTarget: target === inputTarget,
      containsTarget
    }));
  },
  dragGroupEnd: function(moveable, e) {
    this.endEvent(moveable);
    var inputEvent = e.inputEvent;
    var inputTarget = e.inputTarget;
    if (!inputEvent || !inputTarget || e.isDrag || moveable.isMoveableElement(inputTarget) || e.datas.inputTarget === inputTarget) {
      return;
    }
    var targets = moveable.props.targets;
    var targetIndex = targets.indexOf(inputTarget);
    var isTarget = targetIndex > -1;
    var containsTarget = false;
    if (targetIndex === -1) {
      targetIndex = findIndex(targets, function(parentTarget) {
        return parentTarget.contains(inputTarget);
      });
      containsTarget = targetIndex > -1;
    }
    triggerEvent(moveable, "onClickGroup", fillParams(moveable, e, {
      isDouble: e.isDouble,
      targets,
      inputTarget,
      targetIndex,
      isTarget,
      containsTarget
    }));
  },
  dragControlEnd: function(moveable, e) {
    this.dragEnd(moveable, e);
  },
  dragGroupControlEnd: function(moveable, e) {
    this.dragEnd(moveable, e);
  },
  endEvent: function(moveable) {
    var _this = this;
    requestAnimationFrame$1(function() {
      _this.unset(moveable);
    });
  },
  unset: function(moveable) {
    removeEvent(window, "click", moveable.onPreventClick, true);
  }
});
function getDraggableEvent(e) {
  var datas = e.originalDatas.draggable;
  if (!datas) {
    e.originalDatas.draggable = {};
    datas = e.originalDatas.draggable;
  }
  return __assign$2(__assign$2({}, e), {
    datas
  });
}
var edgeDraggable = makeAble("edgeDraggable", {
  dragControlCondition: function(moveable, e) {
    if (!moveable.props.edgeDraggable || !e.inputEvent) {
      return false;
    }
    var target = e.inputEvent.target;
    return hasClass(target, prefix("direction")) && hasClass(target, prefix("line"));
  },
  dragControlStart: function(moveable, e) {
    return Draggable.dragStart(moveable, getDraggableEvent(e));
  },
  dragControl: function(moveable, e) {
    return Draggable.drag(moveable, getDraggableEvent(e));
  },
  dragControlEnd: function(moveable, e) {
    return Draggable.dragEnd(moveable, getDraggableEvent(e));
  },
  dragGroupControlCondition: function(moveable, e) {
    if (!moveable.props.edgeDraggable || !e.inputEvent) {
      return false;
    }
    var target = e.inputEvent.target;
    return hasClass(target, prefix("direction")) && hasClass(target, prefix("line"));
  },
  dragGroupControlStart: function(moveable, e) {
    return Draggable.dragGroupStart(moveable, getDraggableEvent(e));
  },
  dragGroupControl: function(moveable, e) {
    return Draggable.dragGroup(moveable, getDraggableEvent(e));
  },
  dragGroupControlEnd: function(moveable, e) {
    return Draggable.dragGroupEnd(moveable, getDraggableEvent(e));
  },
  unset: function(moveable) {
    return Draggable.unset(moveable);
  }
});
var IndividualGroupable = {
  name: "individualGroupable",
  props: {
    individualGroupable: Boolean
  },
  events: {}
};
var MOVEABLE_ABLES = [BeforeRenderable, Default, Snappable, Pinchable, Draggable, edgeDraggable, Rotatable, Resizable, Scalable, Warpable, Scrollable, Padding, Origin, OriginDraggable, Clippable, Roundable, Groupable, IndividualGroupable, Clickable, DragArea, Renderable];
var MOVEABLE_EVENTS_PROPS_MAP = /* @__PURE__ */ MOVEABLE_ABLES.reduce(function(current, able) {
  return __assign$2(__assign$2({}, current), "events" in able ? able.events : {});
}, {});
var MOVEABLE_PROPS_MAP = /* @__PURE__ */ MOVEABLE_ABLES.reduce(function(current, able) {
  return __assign$2(__assign$2({}, current), able.props);
}, {});
var MOVEABLE_EVENTS_MAP = /* @__PURE__ */ invertObject(MOVEABLE_EVENTS_PROPS_MAP);
var MOVEABLE_EVENTS = Object.keys(MOVEABLE_EVENTS_MAP);
var MOVEABLE_PROPS = Object.keys(MOVEABLE_PROPS_MAP);
function getMaxPos(poses, index) {
  return Math.max.apply(Math, poses.map(function(_a3) {
    var pos1 = _a3[0], pos2 = _a3[1], pos3 = _a3[2], pos4 = _a3[3];
    return Math.max(pos1[index], pos2[index], pos3[index], pos4[index]);
  }));
}
function getMinPos(poses, index) {
  return Math.min.apply(Math, poses.map(function(_a3) {
    var pos1 = _a3[0], pos2 = _a3[1], pos3 = _a3[2], pos4 = _a3[3];
    return Math.min(pos1[index], pos2[index], pos3[index], pos4[index]);
  }));
}
function getGroupRect(moveables, rotation) {
  if (!moveables.length) {
    return [0, 0, 0, 0];
  }
  var moveablePoses = moveables.map(function(_a3) {
    var state = _a3.state;
    return getAbsolutePosesByState(state);
  });
  var minX = MAX_NUM;
  var minY = MAX_NUM;
  var groupWidth = 0;
  var groupHeight = 0;
  var fixedRotation = throttle(rotation, TINY_NUM);
  if (fixedRotation % 90) {
    var rad_1 = fixedRotation / 180 * Math.PI;
    var a1_1 = Math.tan(rad_1);
    var a2_1 = -1 / a1_1;
    var b1MinMax_1 = [MIN_NUM, MAX_NUM];
    var b2MinMax_1 = [MIN_NUM, MAX_NUM];
    moveablePoses.forEach(function(poses) {
      poses.forEach(function(pos) {
        var b1 = pos[1] - a1_1 * pos[0];
        var b2 = pos[1] - a2_1 * pos[0];
        b1MinMax_1[0] = Math.max(b1MinMax_1[0], b1);
        b1MinMax_1[1] = Math.min(b1MinMax_1[1], b1);
        b2MinMax_1[0] = Math.max(b2MinMax_1[0], b2);
        b2MinMax_1[1] = Math.min(b2MinMax_1[1], b2);
      });
    });
    b1MinMax_1.forEach(function(b1) {
      b2MinMax_1.forEach(function(b2) {
        var x2 = (b2 - b1) / (a1_1 - a2_1);
        var y2 = a1_1 * x2 + b1;
        minX = Math.min(minX, x2);
        minY = Math.min(minY, y2);
      });
    });
    var rotatePoses = moveablePoses.map(function(_a3) {
      var pos1 = _a3[0], pos2 = _a3[1], pos3 = _a3[2], pos4 = _a3[3];
      return [rotate(pos1, -rad_1), rotate(pos2, -rad_1), rotate(pos3, -rad_1), rotate(pos4, -rad_1)];
    });
    groupWidth = getMaxPos(rotatePoses, 0) - getMinPos(rotatePoses, 0);
    groupHeight = getMaxPos(rotatePoses, 1) - getMinPos(rotatePoses, 1);
  } else {
    minX = getMinPos(moveablePoses, 0);
    minY = getMinPos(moveablePoses, 1);
    groupWidth = getMaxPos(moveablePoses, 0) - minX;
    groupHeight = getMaxPos(moveablePoses, 1) - minY;
    if (fixedRotation % 180) {
      var changedWidth = groupWidth;
      groupWidth = groupHeight;
      groupHeight = changedWidth;
    }
  }
  return [minX, minY, groupWidth, groupHeight];
}
var MoveableGroup = /* @__PURE__ */ function(_super) {
  __extends$1(MoveableGroup2, _super);
  function MoveableGroup2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.differ = new ChildrenDiffer$1();
    _this.moveables = [];
    _this.transformOrigin = "50% 50%";
    return _this;
  }
  var __proto = MoveableGroup2.prototype;
  __proto.checkUpdate = function() {
    this.updateAbles();
  };
  __proto.updateRect = function(type, isTarget, isSetState) {
    if (isSetState === void 0) {
      isSetState = true;
    }
    if (!this.controlBox) {
      return;
    }
    this.moveables.forEach(function(moveable) {
      moveable.updateRect(type, false, false);
    });
    var state = this.state;
    var props = this.props;
    var target = state.target || props.target;
    if (!isTarget || type !== "" && props.updateGroup) {
      this.rotation = props.defaultGroupRotate;
      this.transformOrigin = props.defaultGroupOrigin || "50% 50%";
      this.scale = [1, 1];
    }
    var rotation = this.rotation;
    var scale = this.scale;
    var _a3 = getGroupRect(this.moveables, rotation), left = _a3[0], top = _a3[1], width = _a3[2], height = _a3[3];
    var transform = "rotate(" + rotation + "deg) scale(" + (scale[0] >= 0 ? 1 : -1) + ", " + (scale[1] >= 0 ? 1 : -1) + ")";
    target.style.cssText += "left:0px;top:0px; transform-origin: " + this.transformOrigin + "; width:" + width + "px; height:" + height + "px;" + ("transform:" + transform);
    state.width = width;
    state.height = height;
    var container = this.getContainer();
    var info = getTargetInfo(this.controlBox.getElement(), target, this.controlBox.getElement(), this.getContainer(), this.props.rootContainer || container);
    var pos = [info.left, info.top];
    var _b3 = getAbsolutePosesByState(info), pos1 = _b3[0], pos2 = _b3[1], pos3 = _b3[2], pos4 = _b3[3];
    var minPos = getMinMaxs([pos1, pos2, pos3, pos4]);
    var delta = [minPos.minX, minPos.minY];
    info.pos1 = minus(pos1, delta);
    info.pos2 = minus(pos2, delta);
    info.pos3 = minus(pos3, delta);
    info.pos4 = minus(pos4, delta);
    info.left = left - info.left + delta[0];
    info.top = top - info.top + delta[1];
    info.origin = minus(plus(pos, info.origin), delta);
    info.beforeOrigin = minus(plus(pos, info.beforeOrigin), delta);
    info.originalBeforeOrigin = plus(pos, info.originalBeforeOrigin);
    var clientRect = info.targetClientRect;
    var direction = scale[0] * scale[1] > 0 ? 1 : -1;
    clientRect.top += info.top - state.top;
    clientRect.left += info.left - state.left;
    target.style.transform = "translate(" + -delta[0] + "px, " + -delta[1] + "px) " + transform;
    this.updateState(__assign$2(__assign$2({}, info), {
      direction,
      beforeDirection: direction
    }), isSetState);
  };
  __proto.getRect = function() {
    return __assign$2(__assign$2({}, _super.prototype.getRect.call(this)), {
      children: this.moveables.map(function(child) {
        return child.getRect();
      })
    });
  };
  __proto.triggerEvent = function(name2, e, isManager) {
    if (isManager || name2.indexOf("Group") > -1) {
      return _super.prototype.triggerEvent.call(this, name2, e);
    }
  };
  __proto.updateAbles = function() {
    _super.prototype.updateAbles.call(this, __spreadArray(__spreadArray([], this.props.ables), [Groupable]), "Group");
  };
  __proto._updateTargets = function() {
    _super.prototype._updateTargets.call(this);
    this._prevTarget = this.props.dragTarget || this.areaElement;
  };
  __proto._updateEvents = function() {
    var state = this.state;
    var props = this.props;
    var prevTarget = this._prevTarget;
    var nextTarget = props.dragTarget || this.areaElement;
    if (prevTarget !== nextTarget) {
      unset(this, "targetGesto");
      unset(this, "controlGesto");
      state.target = null;
    }
    if (!state.target) {
      state.target = this.areaElement;
      this.controlBox.getElement().style.display = "block";
      this.targetGesto = getTargetAbleGesto(this, nextTarget, "Group");
      this.controlGesto = getAbleGesto(this, this.controlBox.getElement(), "controlAbles", "GroupControl");
    }
    var isContainerChanged = !equals(state.container, props.container);
    if (isContainerChanged) {
      state.container = props.container;
    }
    var _a3 = this.differ.update(props.targets), added = _a3.added, changed = _a3.changed, removed = _a3.removed;
    if (isContainerChanged || added.length || changed.length || removed.length) {
      this.updateRect();
    }
  };
  __proto._updateObserver = function() {
  };
  MoveableGroup2.defaultProps = __assign$2(__assign$2({}, MoveableManager$1.defaultProps), {
    transformOrigin: ["50%", "50%"],
    groupable: true,
    dragArea: true,
    keepRatio: true,
    targets: [],
    defaultGroupRotate: 0,
    defaultGroupOrigin: "50% 50%"
  });
  return MoveableGroup2;
}(MoveableManager$1);
var MoveableIndividualGroup = /* @__PURE__ */ function(_super) {
  __extends$1(MoveableIndividualGroup2, _super);
  function MoveableIndividualGroup2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.moveables = [];
    return _this;
  }
  var __proto = MoveableIndividualGroup2.prototype;
  __proto.render = function() {
    var _this = this;
    var _a3 = this.props, cspNonce = _a3.cspNonce, ControlBoxElement = _a3.cssStyled, targets = _a3.targets;
    return createElement(ControlBoxElement, {
      cspNonce,
      ref: ref(this, "controlBox"),
      className: prefix("control-box")
    }, targets.map(function(target, i2) {
      return createElement(MoveableManager$1, __assign$2({
        key: "moveable" + i2,
        ref: refs(_this, "moveables", i2)
      }, _this.props, {
        target,
        wrapperMoveable: _this
      }));
    }));
  };
  __proto.componentDidUpdate = function() {
  };
  __proto.updateRect = function(type, isTarget, isSetState) {
    if (isSetState === void 0) {
      isSetState = true;
    }
    this.moveables.forEach(function(moveable) {
      moveable.updateRect(type, isTarget, isSetState);
    });
  };
  __proto.getRect = function() {
    return __assign$2(__assign$2({}, _super.prototype.getRect.call(this)), {
      children: this.moveables.map(function(child) {
        return child.getRect();
      })
    });
  };
  __proto.request = function() {
    return {
      request: function() {
        return this;
      },
      requestEnd: function() {
        return this;
      }
    };
  };
  __proto.dragStart = function() {
    return this;
  };
  __proto.hitTest = function() {
    return 0;
  };
  __proto.isInside = function() {
    return false;
  };
  __proto.isDragging = function() {
    return false;
  };
  __proto.updateRenderPoses = function() {
  };
  __proto.checkUpdate = function() {
  };
  __proto.triggerEvent = function() {
  };
  __proto.updateAbles = function() {
  };
  __proto._updateEvents = function() {
  };
  __proto._updateObserver = function() {
  };
  return MoveableIndividualGroup2;
}(MoveableManager$1);
var InitialMoveable = /* @__PURE__ */ function(_super) {
  __extends$1(InitialMoveable2, _super);
  function InitialMoveable2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.refTargets = [];
    _this.selectorMap = {};
    return _this;
  }
  var __proto = InitialMoveable2.prototype;
  InitialMoveable2.makeStyled = function() {
    var cssMap = {};
    var ables = this.getTotalAbles();
    ables.forEach(function(_a3) {
      var css = _a3.css;
      if (!css) {
        return;
      }
      css.forEach(function(text2) {
        cssMap[text2] = true;
      });
    });
    var style = getKeys(cssMap).join("\n");
    this.defaultStyled = styled("div", prefixCSS(PREFIX, MOVEABLE_CSS + style));
  };
  InitialMoveable2.getTotalAbles = function() {
    return __spreadArray([Default, Groupable, IndividualGroupable, DragArea], this.defaultAbles);
  };
  __proto.render = function() {
    var moveableContructor = this.constructor;
    if (!moveableContructor.defaultStyled) {
      moveableContructor.makeStyled();
    }
    var _a3 = this.props, userAbles = _a3.ables, userProps = _a3.props, props = __rest(_a3, ["ables", "props"]);
    var refTargets = this._updateRefs(true);
    var elementTargets = getElementTargets(refTargets, this.selectorMap);
    var isGroup = elementTargets.length > 1;
    var totalAbles = moveableContructor.getTotalAbles();
    var ables = __spreadArray(__spreadArray([], totalAbles), userAbles || []);
    var nextProps = __assign$2(__assign$2(__assign$2({}, props), userProps || {}), {
      ables,
      cssStyled: moveableContructor.defaultStyled,
      customStyledMap: moveableContructor.customStyledMap
    });
    if (isGroup) {
      if (props.individualGroupable) {
        return createElement(MoveableIndividualGroup, __assign$2({
          key: "individual-group",
          ref: ref(this, "moveable")
        }, nextProps, {
          target: null,
          targets: elementTargets
        }));
      }
      return createElement(MoveableGroup, __assign$2({
        key: "group",
        ref: ref(this, "moveable")
      }, nextProps, {
        target: null,
        targets: elementTargets
      }));
    } else {
      return createElement(MoveableManager$1, __assign$2({
        key: "single",
        ref: ref(this, "moveable")
      }, nextProps, {
        target: elementTargets[0]
      }));
    }
  };
  __proto.componentDidMount = function() {
    this._updateRefs();
  };
  __proto.componentDidUpdate = function() {
    this._updateRefs();
  };
  __proto.getManager = function() {
    return this.moveable;
  };
  __proto._updateRefs = function(isRender) {
    var prevRefTargets = this.refTargets;
    var nextRefTargets = getRefTargets(this.props.target || this.props.targets);
    var isBrowser = typeof document !== "undefined";
    var isUpdate = prevRefTargets.length !== nextRefTargets.length || prevRefTargets.some(function(target, i2) {
      var nextTarget = nextRefTargets[i2];
      if (!target && !nextTarget) {
        return false;
      } else if (target !== nextTarget) {
        return true;
      }
      return false;
    });
    var selectorMap = this.selectorMap;
    var nextSelectorMap = {};
    this.refTargets.forEach(function(target) {
      if (isString(target)) {
        if (!selectorMap[target] && isBrowser) {
          isUpdate = true;
          nextSelectorMap[target] = [].slice.call(document.querySelectorAll(target));
        } else {
          nextSelectorMap[target] = selectorMap[target];
        }
      }
    });
    this.refTargets = nextRefTargets;
    this.selectorMap = nextSelectorMap;
    if (!isRender && isUpdate) {
      this.forceUpdate();
    }
    return nextRefTargets;
  };
  InitialMoveable2.defaultAbles = [];
  InitialMoveable2.customStyledMap = {};
  InitialMoveable2.defaultStyled = null;
  __decorate$1([withMethods(MOVEABLE_METHODS)], InitialMoveable2.prototype, "moveable", void 0);
  return InitialMoveable2;
}(PureComponent);
var Moveable$2 = /* @__PURE__ */ function(_super) {
  __extends$1(Moveable2, _super);
  function Moveable2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  Moveable2.defaultAbles = MOVEABLE_ABLES;
  return Moveable2;
}(InitialMoveable);
var Moveable$1$1 = Moveable$2;
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var extendStatics = function(d2, b2) {
  extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {
    d3.__proto__ = b3;
  } || function(d3, b3) {
    for (var p2 in b3)
      if (b3.hasOwnProperty(p2))
        d3[p2] = b3[p2];
  };
  return extendStatics(d2, b2);
};
function __extends(d2, b2) {
  extendStatics(d2, b2);
  function __() {
    this.constructor = d2;
  }
  d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
}
var __assign = function() {
  __assign = Object.assign || function __assign2(t) {
    for (var s2, i2 = 1, n = arguments.length; i2 < n; i2++) {
      s2 = arguments[i2];
      for (var p2 in s2)
        if (Object.prototype.hasOwnProperty.call(s2, p2))
          t[p2] = s2[p2];
    }
    return t;
  };
  return __assign.apply(this, arguments);
};
function __decorate(decorators, target, key, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d2;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r2 = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i2 = decorators.length - 1; i2 >= 0; i2--)
      if (d2 = decorators[i2])
        r2 = (c2 < 3 ? d2(r2) : c2 > 3 ? d2(target, key, r2) : d2(target, key)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key, r2), r2;
}
var InnerMoveable = /* @__PURE__ */ function(_super) {
  __extends(InnerMoveable2, _super);
  function InnerMoveable2(props) {
    var _this = _super.call(this, props) || this;
    _this.state = {};
    _this.state = _this.props;
    return _this;
  }
  var __proto = InnerMoveable2.prototype;
  __proto.render = function() {
    return createPortal(createElement(Moveable$1$1, __assign({
      ref: ref(this, "moveable")
    }, this.state)), this.state.parentElement);
  };
  return InnerMoveable2;
}(Component);
var PROPERTIES = MOVEABLE_PROPS;
var METHODS = MOVEABLE_METHODS;
var EVENTS = MOVEABLE_EVENTS;
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var __assign$1 = function() {
  __assign$1 = Object.assign || function __assign2(t) {
    for (var s2, i2 = 1, n = arguments.length; i2 < n; i2++) {
      s2 = arguments[i2];
      for (var p2 in s2)
        if (Object.prototype.hasOwnProperty.call(s2, p2))
          t[p2] = s2[p2];
    }
    return t;
  };
  return __assign$1.apply(this, arguments);
};
function __spreadArrays() {
  for (var s2 = 0, i2 = 0, il = arguments.length; i2 < il; i2++)
    s2 += arguments[i2].length;
  for (var r2 = Array(s2), k = 0, i2 = 0; i2 < il; i2++)
    for (var a2 = arguments[i2], j2 = 0, jl = a2.length; j2 < jl; j2++, k++)
      r2[k] = a2[j2];
  return r2;
}
var EventEmitter = /* @__PURE__ */ function() {
  function EventEmitter2() {
    this._events = {};
  }
  var __proto = EventEmitter2.prototype;
  __proto.on = function(eventName, listener) {
    if (isObject$2(eventName)) {
      for (var name2 in eventName) {
        this.on(name2, eventName[name2]);
      }
    } else {
      this._addEvent(eventName, listener, {});
    }
    return this;
  };
  __proto.off = function(eventName, listener) {
    if (!eventName) {
      this._events = {};
    } else if (isObject$2(eventName)) {
      for (var name2 in eventName) {
        this.off(name2);
      }
    } else if (!listener) {
      this._events[eventName] = [];
    } else {
      var events = this._events[eventName];
      if (events) {
        var index = findIndex(events, function(e) {
          return e.listener === listener;
        });
        if (index > -1) {
          events.splice(index, 1);
        }
      }
    }
    return this;
  };
  __proto.once = function(eventName, listener) {
    var _this = this;
    if (listener) {
      this._addEvent(eventName, listener, {
        once: true
      });
    }
    return new Promise(function(resolve2) {
      _this._addEvent(eventName, resolve2, {
        once: true
      });
    });
  };
  __proto.emit = function(eventName, param) {
    var _this = this;
    if (param === void 0) {
      param = {};
    }
    var events = this._events[eventName];
    if (!eventName || !events) {
      return true;
    }
    var isStop = false;
    param.eventType = eventName;
    param.stop = function() {
      isStop = true;
    };
    param.currentTarget = this;
    __spreadArrays(events).forEach(function(info) {
      info.listener(param);
      if (info.once) {
        _this.off(eventName, info.listener);
      }
    });
    return !isStop;
  };
  __proto.trigger = function(eventName, param) {
    if (param === void 0) {
      param = {};
    }
    return this.emit(eventName, param);
  };
  __proto._addEvent = function(eventName, listener, options) {
    var events = this._events;
    events[eventName] = events[eventName] || [];
    var listeners = events[eventName];
    listeners.push(__assign$1({
      listener
    }, options));
  };
  return EventEmitter2;
}();
var MoveableManager = /* @__PURE__ */ function(_super) {
  __extends(MoveableManager2, _super);
  function MoveableManager2(parentElement, options) {
    if (options === void 0) {
      options = {};
    }
    var _this = _super.call(this) || this;
    _this.tempElement = document.createElement("div");
    var nextOptions = __assign({}, options);
    var events = {};
    EVENTS.forEach(function(name2) {
      events[camelize("on " + name2)] = function(e) {
        return _this.trigger(name2, e);
      };
    });
    render(createElement(InnerMoveable, __assign({
      ref: ref(_this, "innerMoveable"),
      parentElement
    }, nextOptions, events)), _this.tempElement);
    var target = nextOptions.target;
    if (isArray(target) && target.length > 1) {
      _this.updateRect();
    }
    return _this;
  }
  var __proto = MoveableManager2.prototype;
  __proto.setState = function(state, callback) {
    this.innerMoveable.setState(state, callback);
  };
  __proto.destroy = function() {
    render(null, this.tempElement);
    this.off();
    this.tempElement = null;
    this.innerMoveable = null;
  };
  __proto.getMoveable = function() {
    return this.innerMoveable.moveable;
  };
  MoveableManager2 = __decorate([Properties(METHODS, function(prototype, property) {
    if (prototype[property]) {
      return;
    }
    prototype[property] = function() {
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      var self2 = this.getMoveable();
      if (!self2 || !self2[property]) {
        return;
      }
      return self2[property].apply(self2, args);
    };
  }), Properties(PROPERTIES, function(prototype, property) {
    Object.defineProperty(prototype, property, {
      get: function() {
        return this.getMoveable().props[property];
      },
      set: function(value) {
        var _a3;
        this.setState((_a3 = {}, _a3[property] = value, _a3));
      },
      enumerable: true,
      configurable: true
    });
  })], MoveableManager2);
  return MoveableManager2;
}(EventEmitter);
var Moveable = /* @__PURE__ */ function(_super) {
  __extends(Moveable2, _super);
  function Moveable2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  return Moveable2;
}(MoveableManager);
var Moveable$1 = Moveable;
var __accessCheck$3 = (obj, member, msg) => {
  if (!member.has(obj))
    throw TypeError("Cannot " + msg);
};
var __privateGet$3 = (obj, member, getter) => {
  __accessCheck$3(obj, member, "read from private field");
  return getter ? getter.call(obj) : member.get(obj);
};
var __privateAdd$3 = (obj, member, value) => {
  if (member.has(obj))
    throw TypeError("Cannot add the same private member more than once");
  member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
};
var __privateSet$3 = (obj, member, value, setter) => {
  __accessCheck$3(obj, member, "write to private field");
  setter ? setter.call(obj, value) : member.set(obj, value);
  return value;
};
var __privateWrapper = (obj, member, setter, getter) => {
  return {
    set _(value) {
      __privateSet$3(obj, member, value, setter);
    },
    get _() {
      return __privateGet$3(obj, member, getter);
    }
  };
};
var __privateMethod$3 = (obj, member, method) => {
  __accessCheck$3(obj, member, "access private method");
  return method;
};
var _divDesignRoot, _scrItr, _alzTagArg, _cfg$2, _ID_DESIGNMODE, _cntDesignCast, _hId2dc, _aDC, _resizeDiv, resizeDiv_fn;
const _DesignCast = class {
  constructor(bg_col, isLay = false) {
    this.bg_col = bg_col;
    this.isLay = isLay;
    __privateAdd$3(this, _resizeDiv);
    this.hArg = {};
    this.id_tag = "";
    this.hDesignArg = {
      "rotation": 0,
      "pivot_x": 0,
      "pivot_y": 0,
      "left": 0,
      "center": 0,
      "right": 0,
      "s_right": 0,
      "top": 0,
      "middle": 0,
      "bottom": 0,
      "s_bottom": 0,
      "width": 0,
      "height": 0
    };
    this.fncLay = () => {
    };
    this.mov = void 0;
    this.div = void 0;
    this.lx = 0;
    this.ly = 0;
    this.rect = Rectangle.EMPTY;
    this.pivot = new Point(0, 0);
    this.scale = new Point(1, 1);
    this.rotation = 0;
    this.oldFn = () => "";
    this.rotatable = true;
  }
  static init(appPixi, sys, scrItr, prpPrs, alzTagArg, cfg, hPages) {
    appPixi.view.insertAdjacentHTML("beforebegin", `<div id="${__privateGet$3(_DesignCast, _ID_DESIGNMODE)}" style="width: ${CmnLib.stageW * _DesignCast.sys.cvsScale}px; height: ${CmnLib.stageH * sys.cvsScale}px; background: rgba(0,0,0,0); position: absolute; touch-action: none; user-select: none; display: none;"></div>`);
    __privateSet$3(_DesignCast, _divDesignRoot, document.getElementById(__privateGet$3(_DesignCast, _ID_DESIGNMODE)));
    _DesignCast.divHint.classList.add("sn_design_hint");
    appPixi.view.parentElement.appendChild(_DesignCast.divHint);
    _DesignCast.sys = sys;
    __privateSet$3(_DesignCast, _scrItr, scrItr);
    _DesignCast.prpPrs = prpPrs;
    __privateSet$3(_DesignCast, _alzTagArg, alzTagArg);
    __privateSet$3(_DesignCast, _cfg$2, cfg);
    _DesignCast.hPages = hPages;
    addStyle(`
.sn_design_cast {
	position: absolute; touch-action: none; user-select: none;
	opacity: 0.6; border-radius: 8px;
}

.sn_design_cast.drag_border {
	line-height: 1.8;
	border: dashed 5px #333;
}

.sn_design_hint {
	position: absolute;
	left: 0;
	top: 0;
	padding: 5px;
	border-radius: 5px;
	background: #333;
	z-index: 10;
	color: #fff;
	font-weight: bold;
	font-size: 12px;
	display: none;
}
`);
  }
  static setHint(txt, x2, y2, dc) {
    _DesignCast.divHint.innerHTML = txt;
    const s2 = window.getComputedStyle(_DesignCast.divHint);
    const w2 = parseFloat(s2.width);
    const h2 = parseFloat(s2.height);
    _DesignCast.divHint.style.cssText = `display: block; left: ${Math.max(10, dc.lx + x2 - w2)}px;
		top: ${Math.max(10, dc.ly + y2 - h2 - 10)}px;`;
  }
  static cvsResizeDesign() {
    const s2 = __privateGet$3(_DesignCast, _divDesignRoot).style;
    s2.width = `${CmnLib.stageW * _DesignCast.sys.cvsScale}px`;
    s2.height = `${CmnLib.stageH * _DesignCast.sys.cvsScale}px`;
  }
  destroy() {
    var _a3;
    this.div = void 0;
    (_a3 = this.mov) == null ? void 0 : _a3.destroy();
    this.mov = void 0;
  }
  gethArg() {
    return this.hArg;
  }
  sethArg(hArg) {
    var _a3, _b3;
    if (!this.includeDesignArg(hArg))
      return;
    if (!this.id_tag)
      this.id_tag = (_a3 = hArg[":id_tag"]) != null ? _a3 : "";
    this.hArg = hArg;
    const id_dc = (_b3 = hArg[":id_dc"]) != null ? _b3 : this.id_tag;
    __privateGet$3(_DesignCast, _hId2dc)[id_dc] = this;
  }
  includeDesignArg(hArg) {
    for (const name2 in hArg)
      if (name2 in this.hDesignArg)
        return true;
    return false;
  }
  getRect() {
    return Rectangle.EMPTY;
  }
  cnvPosArg(_x, _y) {
    return {};
  }
  cnvSizeArg(_x, _y) {
    return {};
  }
  setPos(_x, _y) {
  }
  setSize(_w, _h) {
  }
  setOther(_hPrm2) {
  }
  adopt(idcCh) {
    this.child = idcCh;
    idcCh.parent = this;
  }
  static enterMode() {
    _DesignCast.leaveMode();
    __privateGet$3(_DesignCast, _divDesignRoot).style.display = "inline";
    __privateSet$3(_DesignCast, _cntDesignCast, 0);
    __privateSet$3(_DesignCast, _hId2dc, {});
  }
  static allHide() {
    __privateGet$3(_DesignCast, _aDC).forEach((v2) => v2.visible = false);
  }
  set visible(v2) {
    if (!this.div || !this.mov)
      return;
    this.div.style.display = v2 ? "inline" : "none";
    this.mov.updateTarget();
  }
  static leaveMode() {
    __privateGet$3(_DesignCast, _divDesignRoot).textContent = "";
    __privateGet$3(_DesignCast, _divDesignRoot).style.display = "none";
    __privateGet$3(_DesignCast, _aDC).forEach((v2) => v2.destroy());
    __privateSet$3(_DesignCast, _aDC, []);
  }
  cvsResize() {
    var _a3;
    __privateMethod$3(this, _resizeDiv, resizeDiv_fn).call(this);
    (_a3 = this.mov) == null ? void 0 : _a3.updateTarget();
  }
  onDragStart() {
  }
  make() {
    var _a3, _b3;
    const id_dc = (_a3 = this.hArg[":id_dc"]) != null ? _a3 : this.id_tag;
    __privateGet$3(_DesignCast, _hId2dc)[id_dc] = this;
    const d2 = this.div = document.createElement("div");
    d2.id = __privateGet$3(_DesignCast, _ID_DESIGNMODE) + "_" + ++__privateWrapper(_DesignCast, _cntDesignCast)._;
    d2.classList.add("sn_design_cast");
    d2.dataset.id_dc = id_dc;
    d2.style.backgroundColor = `${this.bg_col}`;
    d2.style.display = "none";
    this.rect = this.getRect();
    __privateMethod$3(this, _resizeDiv, resizeDiv_fn).call(this);
    (this.parent ? (_b3 = document.querySelector(`[data-id_dc="${this.parent.id_tag}"]`)) != null ? _b3 : __privateGet$3(_DesignCast, _divDesignRoot) : __privateGet$3(_DesignCast, _divDesignRoot)).appendChild(d2);
    const tmp = {
      aPos: [0, 0],
      roDeg: 0,
      trOrg: "",
      origin: [0, 0]
    };
    const procStart = () => {
      tmp.aPos = [NaN, NaN];
      tmp.roDeg = this.rotation;
      const dpx = this.pivot.x * _DesignCast.sys.cvsScale;
      const dpy = this.pivot.y * _DesignCast.sys.cvsScale;
      tmp.trOrg = `${dpx}px ${dpy}px`;
      tmp.origin = [dpx, dpy];
      Object.assign(this.mov, {
        verticalGuidelines: [],
        horizontalGuidelines: []
      });
    };
    const procEnd = (o) => {
      _DesignCast.sys.send2Dbg("_changeCast", __spreadProps(__spreadValues({}, o), {
        ":id_tag": this.id_tag
      }));
      _DesignCast.divHint.style.display = "none";
    };
    const resizeEnd = () => {
      const [dx, dy] = tmp.aPos;
      if (isNaN(dx)) {
        _DesignCast.divHint.style.display = "none";
        return;
      }
      const ix = int(this.rect.x += dx / _DesignCast.sys.cvsScale + this.pivot.x);
      const iy = int(this.rect.y += dy / _DesignCast.sys.cvsScale + this.pivot.y);
      this.setPos(ix, iy);
      const iw = uint(this.rect.width), ih = uint(this.rect.height);
      this.setSize(iw, ih);
      procEnd(__spreadValues(__spreadValues({}, this.cnvPosArg(ix, iy)), this.cnvSizeArg(iw, ih)));
    };
    let heCh = void 0;
    this.mov = new Moveable$1(document.body, {
      target: d2,
      draggable: true,
      resizable: true,
      rotatable: this.rotatable,
      originDraggable: this.rotatable,
      snappable: true
    }).on("dragStart", (e) => {
      var _a4;
      procStart();
      this.onDragStart();
      const m2 = (_a4 = this.child) == null ? void 0 : _a4.mov;
      if (m2) {
        heCh = m2.target;
        if (m2.isInside(e.clientX, e.clientY))
          m2.target = void 0;
      }
    }).on("drag", (e) => {
      tmp.aPos = e.beforeTranslate;
      this.procDragHint(e, e.left, e.top);
    }).on("dragEnd", () => {
      var _a4, _b4;
      resizeEnd();
      if ((_a4 = this.child) == null ? void 0 : _a4.mov)
        this.child.mov.target = heCh;
      if ((_b4 = this.parent) == null ? void 0 : _b4.mov)
        this.parent.mov.target = this.parent.div;
    }).on("resizeStart", procStart).on("resize", (e) => {
      d2.style.width = `${e.width}px`;
      d2.style.height = `${e.height}px`;
      tmp.aPos = e.drag.beforeTranslate;
      this.rect.width = e.width / _DesignCast.sys.cvsScale;
      this.rect.height = e.height / _DesignCast.sys.cvsScale;
      this.procResizeHint(e, e.drag.left, e.drag.top);
    }).on("resizeEnd", resizeEnd).on("rotateStart", (e) => {
      procStart();
      e.set(tmp.roDeg);
    }).on("rotate", (e) => {
      tmp.roDeg = e.beforeRotate;
      _DesignCast.setHint(int(tmp.roDeg) + "\u5EA6", e.drag.left, e.drag.top, this);
    }).on("rotateEnd", () => {
      this.rotation = tmp.roDeg;
      this.setOther({});
      procEnd({ rotation: int(tmp.roDeg) });
    }).on("dragOriginStart", () => procStart).on("dragOrigin", (e) => {
      tmp.trOrg = e.transformOrigin;
      tmp.origin = e.origin;
    }).on("dragOriginEnd", () => {
      const [dpx, dpy] = tmp.origin;
      tmp.trOrg = `${dpx}px ${dpy}px`;
      const px = this.pivot.x = dpx / _DesignCast.sys.cvsScale;
      const py = this.pivot.y = dpy / _DesignCast.sys.cvsScale;
      this.setOther({});
      const ix = int(this.rect.x + px);
      const iy = int(this.rect.y + py);
      this.setPos(ix, iy);
      procEnd(__spreadProps(__spreadValues({}, this.cnvPosArg(ix, iy)), {
        pivot_x: int(px),
        pivot_y: int(py)
      }));
    }).on("render", () => {
      const { aPos, roDeg, trOrg } = tmp;
      d2.style.transformOrigin = trOrg;
      d2.style.transform = `translate(${aPos[0]}px, ${aPos[1]}px) rotate(${roDeg}deg)`;
    });
    __privateGet$3(_DesignCast, _aDC).push(this);
    d2.addEventListener("dragenter", () => d2.classList.add("drag_border"));
    d2.addEventListener("dragover", (e) => {
      e.stopPropagation();
      e.preventDefault();
      if (e.dataTransfer)
        e.dataTransfer.dropEffect = "copy";
    });
    d2.addEventListener("dragleave", () => d2.classList.remove("drag_border"));
    d2.addEventListener("drop", (e) => {
      e.stopPropagation();
      e.preventDefault();
      d2.classList.remove("drag_border");
      const dt = e.dataTransfer;
      if (!dt || dt.files.length === 0)
        return;
      const f2 = dt.files[0];
      const o = {
        ":id_tag": this.id_tag,
        fn: getFn(f2.name),
        ext: getExt(f2.name),
        url: "",
        buf: new ArrayBuffer(0),
        old_fn: this.oldFn(),
        old_url: __privateGet$3(_DesignCast, _cfg$2).searchPath(this.oldFn(), Config.EXT_SPRITE)
      };
      f2.arrayBuffer().then((buf) => {
        o.buf = buf;
        try {
          o.url = __privateGet$3(_DesignCast, _scrItr).cnvPath4Dbg(__privateGet$3(_DesignCast, _cfg$2).searchPath(f2.name, Config.EXT_SPRITE));
        } catch {
        }
        _DesignCast.sys.send2Dbg("_dropFile", o);
      }).catch((e2) => console.error(`drop2dc %o`, e2));
    });
    d2.addEventListener("dblclick", (e) => {
      e.preventDefault();
      _DesignCast.sys.send2Dbg("_focusScript", this.hArg);
    });
  }
  procDragHint(e, left, top) {
    const [dx, dy] = e.beforeTranslate;
    _DesignCast.setHint(`(${int(this.rect.x + dx / _DesignCast.sys.cvsScale)}, ${int(this.rect.y + dy / _DesignCast.sys.cvsScale)})`, left, top, this);
  }
  procResizeHint(e, left, top) {
    _DesignCast.setHint(`(${int(e.drag.left)}, ${int(e.drag.top)})<br/>${int(this.rect.width)} x ${int(this.rect.height)}`, left, top, this);
  }
  static replaceToken(o) {
    var _a3, _b3, _c3, _d2, _e, _f, _g, _h, _i, _j, _k;
    const id_tag = o[":id_tag"];
    const id_dc = id_tag;
    const dc = __privateGet$3(_DesignCast, _hId2dc)[id_dc];
    const d2 = document.querySelector(`div[data-id_dc='${id_dc}']`);
    if (!d2 || !dc)
      return;
    const token = o[":token"];
    __privateGet$3(_DesignCast, _scrItr).replace(o[":idx_tkn"], token);
    const [_tag_name, args] = tagToken2Name_Args(token);
    if (dc.child)
      dc.child.hArg[":token"] = dc.hArg[":token"];
    __privateGet$3(_DesignCast, _alzTagArg).go(args);
    const p2 = __privateGet$3(_DesignCast, _alzTagArg).hPrm;
    if ("pivot_x" in p2 || "pivot_y" in p2) {
      const px = Number(_DesignCast.prpPrs.getValAmpersand((_a3 = p2.pivot_x.val) != null ? _a3 : "0"));
      const py = Number(_DesignCast.prpPrs.getValAmpersand((_b3 = p2.pivot_y.val) != null ? _b3 : "0"));
      if (isNaN(px) || isNaN(py))
        DebugMng.myTrace(`pivot_x\u304Bpivot_y\u304C\u6570\u5024\u3067\u306F\u3042\u308A\u307E\u305B\u3093
(fn:${o[":path"].slice(13)} ln:${o[":ln"]})
${token}`, "F");
      dc.pivot.set(px, py);
    }
    if ("left" in p2 || "top" in p2 || "x" in p2 || "y" in p2) {
      const x2 = int(_DesignCast.prpPrs.getValAmpersand((_d2 = (_c3 = p2.left.val) != null ? _c3 : p2.x.val) != null ? _d2 : "0"));
      const y2 = int(_DesignCast.prpPrs.getValAmpersand((_f = (_e = p2.top.val) != null ? _e : p2.y.val) != null ? _f : "0"));
      if (isNaN(x2) || isNaN(y2))
        DebugMng.myTrace(`width\u304Bheight\u304C\u6570\u5024\u3067\u306F\u3042\u308A\u307E\u305B\u3093
(fn:${o[":path"].slice(13)} ln:${o[":ln"]})
${token}`, "F");
      dc.rect.x = x2 - dc.pivot.x;
      dc.rect.y = y2 - dc.pivot.y;
      dc.setPos(x2, y2);
    }
    if ("width" in p2 || "height" in p2) {
      const w2 = int(_DesignCast.prpPrs.getValAmpersand((_g = p2.width.val) != null ? _g : "0"));
      const h2 = int(_DesignCast.prpPrs.getValAmpersand((_h = p2.height.val) != null ? _h : "0"));
      if (isNaN(w2) || isNaN(h2))
        DebugMng.myTrace(`width\u304Bheight\u304C\u6570\u5024\u3067\u306F\u3042\u308A\u307E\u305B\u3093
(fn:${o[":path"].slice(13)} ln:${o[":ln"]})
${token}`, "F");
      dc.rect.width = w2;
      dc.rect.height = h2;
      dc.setSize(w2, h2);
    }
    if ("scale_x" in p2 || "scale_y" in p2) {
      const sx = Number(_DesignCast.prpPrs.getValAmpersand((_i = p2.scale_x.val) != null ? _i : "0"));
      const sy = Number(_DesignCast.prpPrs.getValAmpersand((_j = p2.scale_y.val) != null ? _j : "0"));
      if (isNaN(sx) || isNaN(sy))
        DebugMng.myTrace(`scale_x\u304Bscale_y\u304C\u6570\u5024\u3067\u306F\u3042\u308A\u307E\u305B\u3093
(fn:${o[":path"].slice(13)} ln:${o[":ln"]})
${token}`, "F");
      dc.scale.set(sx, sy);
    }
    if ("rotation" in p2) {
      const r2 = Number(_DesignCast.prpPrs.getValAmpersand((_k = p2.rotation.val) != null ? _k : "0"));
      if (isNaN(r2))
        DebugMng.myTrace(`rotation\u304C\u6570\u5024\u3067\u306F\u3042\u308A\u307E\u305B\u3093
(fn:${o[":path"].slice(13)} ln:${o[":ln"]})
${token}`, "F");
      dc.rotation = r2;
    }
    dc.setOther(p2);
    dc.cvsResize();
  }
};
let DesignCast = _DesignCast;
_divDesignRoot = /* @__PURE__ */ new WeakMap();
_scrItr = /* @__PURE__ */ new WeakMap();
_alzTagArg = /* @__PURE__ */ new WeakMap();
_cfg$2 = /* @__PURE__ */ new WeakMap();
_ID_DESIGNMODE = /* @__PURE__ */ new WeakMap();
_cntDesignCast = /* @__PURE__ */ new WeakMap();
_hId2dc = /* @__PURE__ */ new WeakMap();
_aDC = /* @__PURE__ */ new WeakMap();
_resizeDiv = /* @__PURE__ */ new WeakSet();
resizeDiv_fn = function() {
  this.fncLay();
  if (this.div)
    Object.assign(this.div.style, {
      left: `${this.lx + this.rect.x * _DesignCast.sys.cvsScale}px`,
      top: `${this.ly + this.rect.y * _DesignCast.sys.cvsScale}px`,
      width: `${this.rect.width * _DesignCast.sys.cvsScale}px`,
      height: `${this.rect.height * _DesignCast.sys.cvsScale}px`,
      transformOrigin: `${this.pivot.x * _DesignCast.sys.cvsScale}px ${this.pivot.y * _DesignCast.sys.cvsScale}px`,
      transform: `scale(${this.scale.x}, ${this.scale.y}) rotate(${this.rotation}deg)`
    });
};
__privateAdd$3(DesignCast, _divDesignRoot, void 0);
__privateAdd$3(DesignCast, _scrItr, void 0);
__privateAdd$3(DesignCast, _alzTagArg, void 0);
__privateAdd$3(DesignCast, _cfg$2, void 0);
DesignCast.divHint = document.createElement("div");
__privateAdd$3(DesignCast, _ID_DESIGNMODE, "DesignMode");
__privateAdd$3(DesignCast, _cntDesignCast, 0);
__privateAdd$3(DesignCast, _hId2dc, {});
__privateAdd$3(DesignCast, _aDC, []);
class GrpLayDesignCast extends DesignCast {
  constructor(spLay, gl) {
    super("#29e", true);
    __privateAdd2(this, _sp, void 0);
    this.spLay = spLay;
    this.gl = gl;
    this.oldFn = () => {
      var _a3;
      return (_a3 = this.hArg.fn) != null ? _a3 : "";
    };
  }
  setSp(sp) {
    __privateSet2(this, _sp, sp);
  }
  getRect() {
    var _a3, _b3, _c3, _d2;
    return new Rectangle(this.spLay.x, this.spLay.y, (_b3 = (_a3 = __privateGet2(this, _sp)) == null ? void 0 : _a3.width) != null ? _b3 : 0, (_d2 = (_c3 = __privateGet2(this, _sp)) == null ? void 0 : _c3.height) != null ? _d2 : 0);
  }
  cnvPosArg(left, top) {
    return { left, top };
  }
  cnvSizeArg(width, height) {
    return { width, height };
  }
  setPos(x2, y2) {
    this.spLay.x = x2;
    this.spLay.y = y2;
  }
  setSize(w2, h2) {
    __privateGet2(this, _sp).width = w2;
    __privateGet2(this, _sp).height = h2;
  }
  setOther(hPrm) {
    var _a3;
    if ("fn" in hPrm) {
      const fn = DesignCast.prpPrs.getValAmpersand((_a3 = hPrm.fn.val) != null ? _a3 : "");
      this.gl.lay({ fn });
    }
    this.spLay.pivot.copyFrom(this.pivot);
    this.spLay.scale.copyFrom(this.scale);
    this.spLay.angle = this.rotation;
  }
}
_sp = new WeakMap();
class TxtLayDesignCast extends DesignCast {
  constructor(spLay, ts) {
    super("#29e", true);
    this.spLay = spLay;
    this.ts = ts;
    this.hDesignArg = {
      "rotation": 0,
      "pivot_x": 0,
      "pivot_y": 0,
      "left": 0,
      "center": 0,
      "right": 0,
      "s_right": 0,
      "top": 0,
      "middle": 0,
      "bottom": 0,
      "s_bottom": 0,
      "width": 0,
      "height": 0,
      "pl": 0,
      "pr": 0,
      "pt": 0,
      "pb": 0
    };
  }
  getRect() {
    const it = this.ts.infTL;
    return new Rectangle(this.spLay.x, this.spLay.y, it.$width, it.$height);
  }
  cnvPosArg(left, top) {
    return { left, top };
  }
  cnvSizeArg(width, height) {
    return { width, height };
  }
  setPos(x2, y2) {
    this.spLay.position.set(x2, y2);
    this.ts.lay(this.cnvPosArg(x2, y2));
  }
  setSize(w2, h2) {
    this.ts.lay(this.cnvSizeArg(w2, h2));
  }
  setOther(hPrm) {
    var _a3;
    (_a3 = this.child) == null ? void 0 : _a3.setOther(hPrm);
    this.spLay.pivot.copyFrom(this.pivot);
    this.spLay.scale.copyFrom(this.scale);
    this.spLay.angle = this.rotation;
  }
}
class TxtLayPadDesignCast extends DesignCast {
  constructor(ts) {
    super("#9e2");
    __privateAdd2(this, _procHint);
    this.ts = ts;
    this.rotatable = false;
  }
  getRect() {
    const it = this.ts.infTL;
    return new Rectangle(it.pad_left, it.pad_top, it.$width - it.pad_left - it.pad_right, it.$height - it.pad_top - it.pad_bottom);
  }
  cnvPosArg(pl, pt) {
    return { pl, pt };
  }
  cnvSizeArg(w2, h2) {
    const it = this.ts.infTL;
    return {
      pr: it.$width - it.pad_left - w2,
      pb: it.$height - it.pad_top - h2
    };
  }
  setPos(x2, y2) {
    this.ts.lay(this.cnvPosArg(x2, y2));
  }
  setSize(w2, h2) {
    this.ts.lay(__spreadProps(__spreadValues({}, this.cnvSizeArg(w2, h2)), { ":redraw": true }));
  }
  setOther(hPrm) {
    var _a3, _b3, _c3, _d2, _e, _f, _g, _h;
    const it = this.ts.infTL;
    if ("pl" in hPrm || "pt" in hPrm) {
      this.setPos(this.rect.x = parseFloat(DesignCast.prpPrs.getValAmpersand((_b3 = (_a3 = hPrm.pl) == null ? void 0 : _a3.val) != null ? _b3 : `${it.pad_left}`)), this.rect.y = parseFloat(DesignCast.prpPrs.getValAmpersand((_d2 = (_c3 = hPrm.pt) == null ? void 0 : _c3.val) != null ? _d2 : `${it.pad_top}`)));
      this.cvsResize();
    }
    if ("pr" in hPrm || "pb" in hPrm) {
      this.ts.lay({
        pr: parseFloat(DesignCast.prpPrs.getValAmpersand((_f = (_e = hPrm.pr) == null ? void 0 : _e.val) != null ? _f : `${it.pad_right}`)),
        pb: parseFloat(DesignCast.prpPrs.getValAmpersand((_h = (_g = hPrm.pb) == null ? void 0 : _g.val) != null ? _h : `${it.pad_bottom}`))
      });
      const rect = this.getRect();
      this.setSize(this.rect.width = rect.width, this.rect.height = rect.height);
      this.cvsResize();
    }
  }
  procDragHint(e, left, top) {
    const [dx, dy] = e.beforeTranslate;
    __privateMethod2(this, _procHint, procHint_fn).call(this, left, top, dx, dy);
  }
  procResizeHint(e, left, top) {
    const [dx, dy] = e.drag.beforeTranslate;
    __privateMethod2(this, _procHint, procHint_fn).call(this, left, top, dx, dy);
  }
}
_procHint = new WeakSet();
procHint_fn = function(left, top, dx, dy) {
  const x2 = this.rect.x, y2 = this.rect.y;
  const w2 = this.rect.width, h2 = this.rect.height;
  const it = this.ts.infTL;
  const pl = int(x2 + dx / DesignCast.sys.cvsScale);
  const pt = int(y2 + dy / DesignCast.sys.cvsScale);
  const pr = int(it.$width - pl - w2);
  const pb = int(it.$height - pt - h2);
  const sp = (re2) => "&nbsp;".repeat(re2);
  DesignCast.setHint(sp(5 + 5 + 1) + `\u4E0A\u5E45=${pt}<br/>
			\u5DE6\u5E45=${pl + sp(1 + 3 + 5 + 1)}\u53F3\u5E45=${pr}<br/>` + sp(5) + `\u5185\u5074 ${int(w2)} x ${int(h2)}<br/>` + sp(5 + 5) + `\u4E0B\u5E45=${pb}`, left, top, this);
};
class BtnDesignCast extends DesignCast {
  constructor(btn, hArg) {
    super("#e92");
    this.btn = btn;
    this.hArg = hArg;
    this.pivot.x = argChk_Num(hArg, "pivot_x", this.pivot.x);
    this.pivot.y = argChk_Num(hArg, "pivot_y", this.pivot.y);
    this.scale.x = argChk_Num(hArg, "scale_x", this.scale.x);
    this.scale.y = argChk_Num(hArg, "scale_y", this.scale.y);
    this.rotation = argChk_Num(hArg, "rotation", this.rotation);
    this.sethArg(hArg);
  }
  sethArg(hArg) {
    var _a3;
    super.sethArg(hArg);
    const layer = (_a3 = this.hArg.layer) != null ? _a3 : "";
    this.fncLay = !this.parent && !this.child && layer ? () => {
      const f2 = DesignCast.hPages[layer].fore;
      this.lx = f2.x * DesignCast.sys.cvsScale;
      this.ly = f2.y * DesignCast.sys.cvsScale;
    } : () => {
    };
  }
  cnvPosArg(left, top) {
    return { left, top };
  }
  cnvSizeArg(width, height) {
    return { width, height };
  }
  setPos(x2, y2) {
    this.btn.x = x2;
    this.btn.y = y2;
  }
  setOther(_hPrm2) {
    this.btn.pivot.copyFrom(this.pivot);
    this.btn.scale.copyFrom(this.scale);
    this.btn.angle = this.rotation;
  }
  onDragStart() {
    const aBtn = this.btn.parent.children.filter((b2) => b2 !== this.btn);
    Object.assign(this.mov, {
      verticalGuidelines: aBtn.map((b2) => this.lx + b2.x * DesignCast.sys.cvsScale),
      horizontalGuidelines: aBtn.map((b2) => this.ly + b2.y * DesignCast.sys.cvsScale)
    });
  }
}
class TxtBtnDesignCast extends BtnDesignCast {
  constructor(btn, hArg, txt) {
    super(btn, hArg);
    this.txt = txt;
    this.oldFn = () => {
      var _a3;
      return (_a3 = this.hArg.b_pic) != null ? _a3 : "";
    };
    if (!argChk_Boolean(hArg, "design", true)) {
      this.setPos = () => {
      };
      this.setSize = () => {
      };
    }
  }
  getRect() {
    return new Rectangle(this.btn.x, this.btn.y, this.txt.width, this.txt.height);
  }
  setSize(w2, h2) {
    this.txt.width = w2;
    this.txt.height = h2;
  }
  setOther(hPrm) {
    var _a3;
    super.setOther(hPrm);
    if ("b_pic" in hPrm) {
      const b_pic = DesignCast.prpPrs.getValAmpersand((_a3 = hPrm.b_pic.val) != null ? _a3 : "");
      this.btn.update_b_pic(b_pic, this.txt);
    }
  }
}
class PicBtnDesignCast extends BtnDesignCast {
  constructor(btn, hArg) {
    super(btn, hArg);
    __privateAdd2(this, _sp2, void 0);
    this.oldFn = () => {
      var _a3;
      return (_a3 = this.hArg.pic) != null ? _a3 : "";
    };
  }
  setSp(sp) {
    __privateSet2(this, _sp2, sp);
  }
  getRect() {
    return new Rectangle(this.btn.x, this.btn.y, __privateGet2(this, _sp2).width, __privateGet2(this, _sp2).height);
  }
  setSize(w2, h2) {
    __privateGet2(this, _sp2).width = w2;
    __privateGet2(this, _sp2).height = h2;
  }
  setOther(hPrm) {
    var _a3;
    super.setOther(hPrm);
    if ("pic" in hPrm) {
      const pic = DesignCast.prpPrs.getValAmpersand((_a3 = hPrm.pic.val) != null ? _a3 : "");
      this.btn.update_pic(pic, __privateGet2(this, _sp2));
    }
  }
}
_sp2 = new WeakMap();
var __accessCheck$2 = (obj, member, msg) => {
  if (!member.has(obj))
    throw TypeError("Cannot " + msg);
};
var __privateGet$2 = (obj, member, getter) => {
  __accessCheck$2(obj, member, "read from private field");
  return getter ? getter.call(obj) : member.get(obj);
};
var __privateAdd$2 = (obj, member, value) => {
  if (member.has(obj))
    throw TypeError("Cannot add the same private member more than once");
  member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
};
var __privateSet$2 = (obj, member, value, setter) => {
  __accessCheck$2(obj, member, "write to private field");
  setter ? setter.call(obj, value) : member.set(obj, value);
  return value;
};
var __privateMethod$2 = (obj, member, method) => {
  __accessCheck$2(obj, member, "access private method");
  return method;
};
var _elc, _hFace, _main$1, _cfg$1, _appPixi, _sys$1, _glbVol, _movVol, _evtMng$1, _idc$1, _csvFn, _sBkFn, _sBkFace, _width, _height, _dec2cache, _sortAFrameName, sortAFrameName_fn, _dec2cache4Cripto, dec2cache4Cripto_fn, _mkSprite, mkSprite_fn, _rtTsy, _spTsy, _fncRender, _hAEncImg, _hEncImgOUrl;
const _GrpLayer = class extends Layer {
  constructor() {
    super();
    __privateAdd$2(this, _idc$1, new GrpLayDesignCast(this.spLay, this));
    __privateAdd$2(this, _csvFn, "");
    __privateAdd$2(this, _sBkFn, "");
    __privateAdd$2(this, _sBkFace, "");
    this.lay = (hArg) => this.laySub(hArg, (isStop) => {
      if (isStop)
        __privateGet$2(_GrpLayer, _main$1).resume();
    });
    __privateAdd$2(this, _width, 0);
    __privateAdd$2(this, _height, 0);
    __privateAdd$2(this, _rtTsy, void 0);
    __privateAdd$2(this, _spTsy, void 0);
    __privateAdd$2(this, _fncRender, () => {
    });
    this.record = () => Object.assign(super.record(), {
      sBkFn: __privateGet$2(this, _sBkFn),
      sBkFace: __privateGet$2(this, _sBkFace),
      idc_hArg: __privateGet$2(this, _idc$1).gethArg()
    });
    this.dump = () => super.dump() + `, "pic":"${__privateGet$2(this, _csvFn)}"`;
    if (CmnLib.isDbg) {
      this.setSp = (sp) => __privateGet$2(this, _idc$1).setSp(sp);
      this.cvsResize = () => {
        super.cvsResize();
        __privateGet$2(this, _idc$1).cvsResize();
      };
    }
  }
  static init(main2, cfg, appPixi, sys, sndMng) {
    __privateSet$2(_GrpLayer, _main$1, main2);
    __privateSet$2(_GrpLayer, _cfg$1, cfg);
    __privateSet$2(_GrpLayer, _appPixi, appPixi);
    __privateSet$2(_GrpLayer, _sys$1, sys);
    const fnc = () => {
      const vol = __privateGet$2(_GrpLayer, _glbVol) * __privateGet$2(_GrpLayer, _movVol);
      for (const fn in _GrpLayer.hFn2VElm)
        _GrpLayer.hFn2VElm[fn].volume = vol;
    };
    sndMng.setNoticeChgVolume((vol) => {
      __privateSet$2(_GrpLayer, _glbVol, vol);
      fnc();
    }, (vol) => {
      __privateSet$2(_GrpLayer, _movVol, vol);
      fnc();
    });
    if (__privateGet$2(_GrpLayer, _sys$1).crypto)
      __privateSet$2(_GrpLayer, _dec2cache, __privateMethod$2(_GrpLayer, _dec2cache4Cripto, dec2cache4Cripto_fn));
  }
  static setEvtMng(evtMng) {
    __privateSet$2(_GrpLayer, _evtMng$1, evtMng);
  }
  static destroy() {
    __privateGet$2(_GrpLayer, _elc).clear();
    __privateSet$2(_GrpLayer, _hFace, {});
    _GrpLayer.hFn2ResAniSpr = {};
    _GrpLayer.hFn2VElm = {};
  }
  setSp(_sp3) {
  }
  laySub(hArg, resolve2) {
    const { fn, face = "" } = hArg;
    __privateGet$2(this, _idc$1).sethArg(hArg);
    if (!fn) {
      super.lay(hArg);
      if (this.spLay.children.length > 0)
        this.setPos(hArg);
      __privateSet$2(this, _sBkFn, "");
      __privateSet$2(this, _csvFn, __privateSet$2(this, _sBkFace, face));
      resolve2(false);
      return false;
    }
    const inFn = "fn" in hArg;
    const inFace = "face" in hArg;
    this.clearLay({ filter: "true" });
    if (inFn)
      __privateSet$2(this, _sBkFn, fn);
    if (inFace)
      __privateSet$2(this, _sBkFace, face);
    super.lay(hArg);
    hArg.dx = 0;
    hArg.dy = 0;
    const ret = _GrpLayer.csv2Sprites(__privateSet$2(this, _csvFn, fn + (face ? "," + face : "")), this.spLay, (sp) => {
      if ("width" in hArg || "height" in hArg) {
        sp.width = argChk_Num(hArg, "width", 0);
        sp.height = argChk_Num(hArg, "height", 0);
      }
      __privateSet$2(this, _width, sp.width);
      __privateSet$2(this, _height, sp.height);
      Layer.setXY(sp, hArg, this.spLay, true);
      this.setSp(sp);
    }, (isStop) => {
      Layer.setBlendmode(this.spLay, hArg);
      resolve2(isStop);
    });
    if (!ret)
      resolve2(false);
    return ret;
  }
  get width() {
    return __privateGet$2(this, _width);
  }
  get height() {
    return __privateGet$2(this, _height);
  }
  static csv2Sprites(csv, parent, fncFirstComp, fncAllComp = () => {
  }) {
    let needLoad = false;
    if (csv.slice(0, 5) === "data:") {
      const fnc = () => {
        const sp = Sprite.from(csv);
        parent == null ? void 0 : parent.addChild(sp);
        fncFirstComp(sp);
        fncAllComp(needLoad);
      };
      if (csv in TextureCache)
        fnc();
      else {
        needLoad = true;
        new Loader().add(csv, csv).load(fnc);
      }
      return needLoad;
    }
    const aComp = [];
    const ldr = new Loader();
    csv.split(",").forEach((fn, i2) => {
      if (!fn)
        throw "face\u5C5E\u6027\u306B\u7A7A\u8981\u7D20\u304C\u542B\u307E\u308C\u307E\u3059";
      const f2 = __privateGet$2(_GrpLayer, _hFace)[fn] || {
        fn,
        dx: 0,
        dy: 0,
        blendmode: BLEND_MODES$3.NORMAL
      };
      const fnc = i2 === 0 ? fncFirstComp : (sp) => {
        sp.x = f2.dx;
        sp.y = f2.dy;
        sp.blendMode = f2.blendmode;
      };
      aComp.push({ fn: f2.fn, fnc });
      if (f2.fn in _GrpLayer.hFn2ResAniSpr)
        return;
      if (f2.fn in TextureCache)
        return;
      if (f2.fn in Loader.shared.resources)
        return;
      needLoad = true;
      const url2 = __privateGet$2(_GrpLayer, _cfg$1).searchPath(f2.fn, Config.EXT_SPRITE);
      const xt = __privateGet$2(this, _sys$1).crypto ? { xhrType: url2.slice(-5) === ".json" ? LoaderResource.XHR_RESPONSE_TYPE.TEXT : LoaderResource.XHR_RESPONSE_TYPE.BUFFER } : {};
      ldr.add(__spreadProps(__spreadValues({}, xt), { name: f2.fn, url: url2 }));
    });
    const fncLoaded = (hRes) => {
      var _a3;
      for (const v2 of aComp) {
        const sp = __privateMethod$2(_a3 = _GrpLayer, _mkSprite, mkSprite_fn).call(_a3, v2.fn, hRes);
        sp.name = v2.fn;
        parent == null ? void 0 : parent.addChild(sp);
        v2.fnc(sp);
      }
      fncAllComp(needLoad);
    };
    if (needLoad) {
      ldr.use((res, next) => {
        __privateGet$2(this, _sys$1).dec(res.extension, res.data).then((r2) => {
          var _a3;
          return __privateGet$2(_a3 = _GrpLayer, _dec2cache).call(_a3, r2, res, () => next == null ? void 0 : next());
        }).catch((e) => __privateGet$2(this, _main$1).errScript(`Graphic \u30ED\u30FC\u30C9\u5931\u6557\u3067\u3059 fn:${res.name} ${e}`, false));
      }).load((_ldr, hRes) => fncLoaded(hRes));
    } else
      fncLoaded({});
    return needLoad;
  }
  static wv(hArg) {
    const { fn } = hArg;
    if (!fn)
      throw "fn\u306F\u5FC5\u9808\u3067\u3059";
    const hve = _GrpLayer.hFn2VElm[fn];
    if (!hve || hve.loop)
      return false;
    if (hve.ended) {
      delete _GrpLayer.hFn2VElm[fn];
      return false;
    }
    const fnc = () => {
      hve.removeEventListener("ended", fnc);
      delete _GrpLayer.hFn2VElm[fn];
      __privateGet$2(this, _main$1).resume();
    };
    hve.addEventListener("ended", fnc, { once: true, passive: true });
    return __privateGet$2(_GrpLayer, _evtMng$1).waitEvent(() => {
      hve.pause();
      fnc();
    }, argChk_Boolean(hArg, "canskip", true), argChk_Boolean(hArg, "global", false));
  }
  renderStart() {
    __privateSet$2(this, _rtTsy, RenderTexture.create({
      width: CmnLib.stageW,
      height: CmnLib.stageH
    }));
    __privateSet$2(this, _spTsy, new Sprite(__privateGet$2(this, _rtTsy)));
    __privateGet$2(this, _spTsy).visible = false;
    this.spLay.addChildAt(__privateGet$2(this, _spTsy), 0);
    __privateGet$2(this, _spTsy).position.set(-this.spLay.x, -this.spLay.y);
    let fncRenderFore = () => {
      const a2 = this.spLay.alpha;
      this.spLay.alpha = 1;
      this.spLay.children.forEach((s2) => s2.visible = true);
      __privateGet$2(this, _spTsy).visible = false;
      __privateGet$2(_GrpLayer, _appPixi).renderer.render(this.spLay, { renderTexture: __privateGet$2(this, _rtTsy) });
      this.spLay.alpha = a2;
      this.spLay.children.forEach((s2) => s2.visible = false);
    };
    if (!this.containMovement) {
      let oldFnc = fncRenderFore;
      fncRenderFore = () => {
        fncRenderFore = () => {
        };
        oldFnc();
      };
    }
    __privateSet$2(this, _fncRender, () => {
      fncRenderFore();
      __privateGet$2(this, _spTsy).visible = true;
    });
    __privateGet$2(_GrpLayer, _appPixi).ticker.add(__privateGet$2(this, _fncRender));
  }
  renderEnd() {
    __privateGet$2(_GrpLayer, _appPixi).ticker.remove(__privateGet$2(this, _fncRender));
    this.spLay.removeChild(__privateGet$2(this, _spTsy));
    this.spLay.children.forEach((s2) => s2.visible = true);
    __privateGet$2(this, _spTsy).destroy(true);
  }
  static loadPic2Img(src, img, onload) {
    const oUrl = __privateGet$2(this, _hEncImgOUrl)[src];
    if (oUrl) {
      img.src = oUrl;
      return;
    }
    const aImg = __privateGet$2(this, _hAEncImg)[src];
    if (aImg) {
      aImg.push(img);
      return;
    }
    __privateGet$2(this, _hAEncImg)[src] = [img];
    const url2 = __privateGet$2(_GrpLayer, _cfg$1).searchPath(src, Config.EXT_SPRITE);
    const ld2 = new Loader().add({ name: src, url: url2, xhrType: LoaderResource.XHR_RESPONSE_TYPE.BUFFER });
    if (__privateGet$2(_GrpLayer, _sys$1).crypto)
      ld2.use((res, next) => {
        __privateGet$2(_GrpLayer, _sys$1).dec(res.extension, res.data).then((r2) => {
          if (res.extension !== "bin") {
            next == null ? void 0 : next();
            return;
          }
          res.data = r2;
          if (r2 instanceof HTMLImageElement) {
            res.type = LoaderResource.TYPE.IMAGE;
          }
          next == null ? void 0 : next();
        }).catch((e) => __privateGet$2(_GrpLayer, _main$1).errScript(`GrpLayer loadPic \u30ED\u30FC\u30C9\u5931\u6557\u3067\u3059 fn:${res.name} ${e}`, false));
      });
    ld2.load((_ldr, hRes) => {
      for (const s2 in hRes) {
        const u2 = __privateGet$2(this, _hEncImgOUrl)[s2] = hRes[s2].data.src;
        __privateGet$2(this, _hAEncImg)[s2].forEach((i2) => {
          i2.src = u2;
          if (onload)
            i2.onload = () => onload(i2);
        });
        delete __privateGet$2(this, _hAEncImg)[s2];
      }
    });
  }
  setPos(hArg) {
    Layer.setXY(this.spLay.children.length === 0 ? this.spLay : this.spLay.children[0], hArg, this.spLay, true);
  }
  static add_face(hArg) {
    const { name: name2 } = hArg;
    if (!name2)
      throw "name\u306F\u5FC5\u9808\u3067\u3059";
    if (name2 in __privateGet$2(_GrpLayer, _hFace))
      throw "\u4E00\u3064\u306Ename\uFF08" + name2 + "\uFF09\u306B\u5BFE\u3057\u3066\u540C\u3058\u753B\u50CF\u3092\u8907\u6570\u5272\u308A\u5F53\u3066\u3089\u308C\u307E\u305B\u3093";
    const { fn = name2 } = hArg;
    __privateGet$2(_GrpLayer, _hFace)[name2] = {
      fn,
      dx: argChk_Num(hArg, "dx", 0),
      dy: argChk_Num(hArg, "dy", 0),
      blendmode: Layer.getBlendmodeNum(hArg.blendmode || "")
    };
    return false;
  }
  static clearFace2Name() {
    __privateSet$2(_GrpLayer, _hFace, {});
  }
  get containMovement() {
    if (__privateGet$2(this, _csvFn) === "")
      return false;
    const c2 = this.spLay.children;
    return __privateGet$2(this, _csvFn).split(",").some((fn, i2) => c2[i2] instanceof AnimatedSprite || _GrpLayer.hFn2VElm[fn]);
  }
  clearLay(hArg) {
    super.clearLay(hArg);
    for (const c2 of this.spLay.removeChildren())
      c2.destroy();
    __privateSet$2(this, _sBkFn, "");
    __privateSet$2(this, _sBkFace, "");
    __privateSet$2(this, _csvFn, "");
  }
  playback(hLay, aPrm) {
    super.playback(hLay, aPrm);
    if (hLay.sBkFn === "" && hLay.sBkFace === "") {
      __privateSet$2(this, _sBkFn, hLay.sBkFn);
      __privateSet$2(this, _sBkFace, hLay.sBkFace);
      __privateGet$2(this, _idc$1).sethArg(hLay.idc_hArg);
      return;
    }
    aPrm.push(new Promise((re2) => this.laySub({ fn: hLay.sBkFn, face: hLay.sBkFace, left: hLay.x, top: hLay.y, alpha: hLay.alpha, blendmode: hLay.blendMode, rotation: hLay.rotation, scale_x: hLay.scale_x, scale_y: hLay.scale_y }, (_isStop) => {
      this.spLay.position.set(hLay.x, hLay.y);
      re2();
    })));
  }
  makeDesignCast(gdc) {
    if (!this.spLay.visible)
      return;
    gdc(__privateGet$2(this, _idc$1));
  }
  cvsResize() {
    super.cvsResize();
  }
  showDesignCast() {
    __privateGet$2(this, _idc$1).visible = true;
  }
};
let GrpLayer = _GrpLayer;
_elc = /* @__PURE__ */ new WeakMap();
_hFace = /* @__PURE__ */ new WeakMap();
_main$1 = /* @__PURE__ */ new WeakMap();
_cfg$1 = /* @__PURE__ */ new WeakMap();
_appPixi = /* @__PURE__ */ new WeakMap();
_sys$1 = /* @__PURE__ */ new WeakMap();
_glbVol = /* @__PURE__ */ new WeakMap();
_movVol = /* @__PURE__ */ new WeakMap();
_evtMng$1 = /* @__PURE__ */ new WeakMap();
_idc$1 = /* @__PURE__ */ new WeakMap();
_csvFn = /* @__PURE__ */ new WeakMap();
_sBkFn = /* @__PURE__ */ new WeakMap();
_sBkFace = /* @__PURE__ */ new WeakMap();
_width = /* @__PURE__ */ new WeakMap();
_height = /* @__PURE__ */ new WeakMap();
_dec2cache = /* @__PURE__ */ new WeakMap();
_sortAFrameName = /* @__PURE__ */ new WeakSet();
sortAFrameName_fn = function(aFn) {
  const a_base_name = /([^\d]+)\d+\.(\w+)/.exec(aFn[0]);
  if (!a_base_name)
    return;
  const is = a_base_name[1].length;
  const ie = -a_base_name[2].length - 1;
  aFn.sort((a2, b2) => int(a2.slice(is, ie)) > int(b2.slice(is, ie)) ? 1 : -1);
};
_dec2cache4Cripto = /* @__PURE__ */ new WeakSet();
dec2cache4Cripto_fn = function(r2, res, next) {
  var _a3;
  res.data = r2;
  if (res.extension === "bin") {
    if (r2 instanceof HTMLImageElement) {
      res.texture = Texture.fromLoader(r2, res.url, res.name);
      res.type = LoaderResource.TYPE.IMAGE;
      URL.revokeObjectURL(r2.src);
    } else if (r2 instanceof HTMLVideoElement) {
      r2.volume = __privateGet$2(_GrpLayer, _glbVol);
      _GrpLayer.hFn2VElm[res.name] = r2;
      res.type = LoaderResource.TYPE.VIDEO;
      URL.revokeObjectURL(r2.src);
    }
  }
  if (res.extension !== "json") {
    next();
    return;
  }
  if (typeof r2 !== "string") {
    next();
    return;
  }
  const o = res.data = JSON.parse(r2);
  res.type = LoaderResource.TYPE.JSON;
  if (!((_a3 = o.meta) == null ? void 0 : _a3.image)) {
    next();
    return;
  }
  const fn = getFn(o.meta.image);
  const url2 = __privateGet$2(_GrpLayer, _cfg$1).searchPath(fn, Config.EXT_SPRITE);
  new Loader().use((res2, next2) => {
    __privateGet$2(this, _sys$1).dec(res2.extension, res2.data).then((r22) => {
      res2.data = r22;
      if (r22 instanceof HTMLImageElement) {
        res2.type = LoaderResource.TYPE.IMAGE;
        URL.revokeObjectURL(r22.src);
      }
      next2 == null ? void 0 : next2();
    }).catch((e) => __privateGet$2(this, _main$1).errScript(`Graphic \u30ED\u30FC\u30C9\u5931\u6557\u3067\u3059 dec2res4Cripto fn:${res2.name} ${e}`, false));
  }).add({ name: fn, url: url2, xhrType: LoaderResource.XHR_RESPONSE_TYPE.BUFFER }).load((ldr, _hRes) => {
    var _a4;
    for (const fn2 in ldr.resources) {
      const bt = Texture.from(ldr.resources[fn2].data).baseTexture;
      const aFn = Object.values(o.frames);
      __privateMethod$2(_a4 = _GrpLayer, _sortAFrameName, sortAFrameName_fn).call(_a4, aFn);
      _GrpLayer.hFn2ResAniSpr[res.name] = {
        aTex: aFn.map((f2) => new Texture(bt, new Rectangle(f2.frame.x, f2.frame.y, f2.frame.w, f2.frame.h))),
        meta: o.meta
      };
    }
    next();
  });
};
_mkSprite = /* @__PURE__ */ new WeakSet();
mkSprite_fn = function(fn, hRes) {
  var _a3;
  const ras = _GrpLayer.hFn2ResAniSpr[fn];
  if (ras) {
    const asp = new AnimatedSprite(ras.aTex);
    asp.animationSpeed = (_a3 = ras.meta.animationSpeed) != null ? _a3 : 1;
    asp.play();
    return asp;
  }
  if (fn in TextureCache)
    return Sprite.from(fn);
  if (fn in _GrpLayer.hFn2VElm)
    return Sprite.from(_GrpLayer.hFn2VElm[fn]);
  return fn in hRes ? new Sprite(hRes[fn].texture) : new Sprite();
};
_rtTsy = /* @__PURE__ */ new WeakMap();
_spTsy = /* @__PURE__ */ new WeakMap();
_fncRender = /* @__PURE__ */ new WeakMap();
_hAEncImg = /* @__PURE__ */ new WeakMap();
_hEncImgOUrl = /* @__PURE__ */ new WeakMap();
__privateAdd$2(GrpLayer, _sortAFrameName);
__privateAdd$2(GrpLayer, _dec2cache4Cripto);
__privateAdd$2(GrpLayer, _mkSprite);
__privateAdd$2(GrpLayer, _elc, new EventListenerCtn());
__privateAdd$2(GrpLayer, _hFace, {});
__privateAdd$2(GrpLayer, _main$1, void 0);
__privateAdd$2(GrpLayer, _cfg$1, void 0);
__privateAdd$2(GrpLayer, _appPixi, void 0);
__privateAdd$2(GrpLayer, _sys$1, void 0);
__privateAdd$2(GrpLayer, _glbVol, 1);
__privateAdd$2(GrpLayer, _movVol, 1);
__privateAdd$2(GrpLayer, _evtMng$1, void 0);
GrpLayer.hFn2ResAniSpr = {};
__privateAdd$2(GrpLayer, _dec2cache, (_r2, res, next) => {
  var _a3;
  switch (res.type) {
    case LoaderResource.TYPE.JSON:
      const aFn = res.spritesheet._frameKeys;
      __privateMethod$2(_a3 = _GrpLayer, _sortAFrameName, sortAFrameName_fn).call(_a3, aFn);
      _GrpLayer.hFn2ResAniSpr[res.name] = {
        aTex: aFn.map((fn) => Texture.from(fn)),
        meta: res.data.meta
      };
      break;
    case LoaderResource.TYPE.VIDEO:
      const hve = res.data;
      hve.volume = __privateGet$2(_GrpLayer, _glbVol);
      _GrpLayer.hFn2VElm[res.name] = hve;
  }
  next();
});
GrpLayer.hFn2VElm = {};
__privateAdd$2(GrpLayer, _hAEncImg, {});
__privateAdd$2(GrpLayer, _hEncImgOUrl, {});
const _TxtStage = class extends Container {
  constructor(spLay, canFocus, sys) {
    super();
    __privateAdd2(this, _lay_sub);
    __privateAdd2(this, _htm2tx);
    __privateAdd2(this, _spWork);
    __privateAdd2(this, _getChRects);
    __privateAdd2(this, _clearText);
    __privateAdd2(this, _htmTxt, document.createElement("span"));
    __privateAdd2(this, _cntTxt, new Container());
    __privateAdd2(this, _grpDbgMasume, new Graphics());
    __privateAdd2(this, _idc2, new TxtLayDesignCast(this.spLay, this));
    __privateAdd2(this, _idcCh, new TxtLayPadDesignCast(this));
    __privateAdd2(this, _infTL, {
      fontsize: 24,
      $width: 0,
      $height: 0,
      pad_left: 0,
      pad_right: 0,
      pad_top: 0,
      pad_bottom: 0
    });
    __privateAdd2(this, _break_fixed, false);
    __privateAdd2(this, _break_fixed_left, 0);
    __privateAdd2(this, _break_fixed_top, 0);
    __privateAdd2(this, _left, 0);
    __privateAdd2(this, _isTategaki, false);
    __privateAdd2(this, _padTx4x, 0);
    __privateAdd2(this, _padTx4y, 0);
    __privateAdd2(this, _ch_filter, void 0);
    __privateAdd2(this, _aSpTw, []);
    __privateAdd2(this, _aRect, []);
    __privateAdd2(this, _lenHtmTxt, 0);
    __privateAdd2(this, _beforeHTMLElm, void 0);
    __privateAdd2(this, _REGDS, /animation\-duration: (?<ms>\d+)ms;/);
    __privateAdd2(this, _fncEndChIn, () => {
    });
    __privateAdd2(this, _isChInIng, false);
    __privateAdd2(this, _lh_half, 0);
    __privateAdd2(this, _fi_easing, "Quadratic.Out");
    __privateAdd2(this, _fo_easing, "Quadratic.Out");
    __privateAdd2(this, _sss, void 0);
    this.spLay = spLay;
    this.canFocus = canFocus;
    this.sys = sys;
    __privateGet2(this, _htmTxt).classList.add("sn_tx");
    __privateGet2(this, _htmTxt).style.position = "absolute";
    __privateGet2(_TxtStage, _appPixi2).view.parentElement.appendChild(__privateGet2(this, _htmTxt));
    this.addChild(__privateGet2(this, _cntTxt));
    this.addChild(__privateGet2(this, _grpDbgMasume));
    __privateGet2(this, _grpDbgMasume).name = "grpDbgMasume";
    __privateGet2(this, _idc2).adopt(__privateGet2(this, _idcCh));
  }
  static init(cfg, appPixi) {
    __privateSet2(_TxtStage, _cfg2, cfg);
    __privateSet2(_TxtStage, _appPixi2, appPixi);
    __privateSet2(_TxtStage, _reg\u884C\u982D\u7981\u5247, /[!?]/);
    __privateSet2(_TxtStage, _reg\u884C\u672B\u7981\u5247, /[]/);
    __privateSet2(_TxtStage, _reg\u5206\u5272\u7981\u6B62, /[]/);
  }
  static setEvtMng(evtMng) {
    __privateSet2(_TxtStage, _evtMng3, evtMng);
  }
  static destroy() {
    __privateSet2(_TxtStage, _hWarning, {
      backgroundColor: 0,
      borderBottomWidth: 0,
      borderLeftWidth: 0,
      borderRightWidth: 0,
      borderTopWidth: 0,
      marginBottom: 0,
      marginLeft: 0,
      marginRight: 0,
      marginTop: 0
    });
    __privateSet2(_TxtStage, _hChInStyle, /* @__PURE__ */ Object.create(null));
    __privateSet2(_TxtStage, _hChOutStyle, /* @__PURE__ */ Object.create(null));
    __privateSet2(_TxtStage, _cntBreak, new Container());
  }
  lay(hArg) {
    var _a3, _b3, _c3, _d2, _e, _f, _g, _h;
    const s2 = __privateGet2(this, _htmTxt).style;
    if (hArg.style) {
      const cln = document.createElement("span");
      cln.style.cssText = hArg.style;
      const len = cln.style.length;
      for (let i2 = 0; i2 < len; ++i2) {
        const key = cln.style[i2];
        if (key in __privateGet2(_TxtStage, _hWarning)) {
          DebugMng.myTrace(`${key}\u306F\u6307\u5B9A\u3067\u304D\u307E\u305B\u3093`, "W");
          continue;
        }
        s2[key] = cln.style[key];
      }
      if (!cln.style.opacity && "alpha" in hArg)
        s2.opacity = String(this.spLay.alpha);
    } else if ("alpha" in hArg)
      s2.opacity = String(this.spLay.alpha);
    if ("width" in hArg)
      s2.width = ((_a3 = hArg.width) != null ? _a3 : "0") + "px";
    if ("height" in hArg)
      s2.height = ((_b3 = hArg.height) != null ? _b3 : "0") + "px";
    if ("pl" in hArg)
      s2.paddingLeft = ((_c3 = hArg.pl) != null ? _c3 : "0") + "px";
    if ("pr" in hArg)
      s2.paddingRight = ((_d2 = hArg.pr) != null ? _d2 : "0") + "px";
    if ("pt" in hArg)
      s2.paddingTop = ((_e = hArg.pt) != null ? _e : "0") + "px";
    if ("pb" in hArg)
      s2.paddingBottom = ((_f = hArg.pb) != null ? _f : "0") + "px";
    if ("kinsoku_sol" in hArg)
      __privateSet2(_TxtStage, _reg\u884C\u982D\u7981\u5247, new RegExp(`[${hArg.kinsoku_sol}]`));
    if ("kinsoku_eol" in hArg)
      __privateSet2(_TxtStage, _reg\u884C\u672B\u7981\u5247, new RegExp(`[${hArg.kinsoku_eol}]`));
    if ("kinsoku_dns" in hArg)
      __privateSet2(_TxtStage, _reg\u5206\u5272\u7981\u6B62, new RegExp(`[${hArg.kinsoku_dns}]`));
    __privateMethod2(this, _lay_sub, lay_sub_fn).call(this);
    __privateGet2(this, _idc2).sethArg(hArg);
    __privateSet2(this, _left, this.spLay.position.x);
    s2.transformOrigin = `${this.spLay.pivot.x}px ${this.spLay.pivot.y}px`;
    this.cvsResize();
    s2.display = this.spLay.visible ? "inline" : "none";
    s2.textShadow = (_h = (_g = hArg.filter) != null ? _g : s2.textShadow) != null ? _h : "";
    __privateSet2(this, _break_fixed, argChk_Boolean(hArg, "break_fixed", __privateGet2(this, _break_fixed)));
    __privateSet2(this, _break_fixed_left, argChk_Num(hArg, "break_fixed_left", __privateGet2(this, _break_fixed_left)));
    __privateSet2(this, _break_fixed_top, argChk_Num(hArg, "break_fixed_top", __privateGet2(this, _break_fixed_top)));
    if (":redraw" in hArg && __privateGet2(this, _lenHtmTxt) > 0) {
      const aSpan = [
        __privateGet2(this, _htmTxt).innerHTML.replace(/(animation-delay: )\d+ms/g, "$10ms"),
        `<span class='sn_ch' data-add='{"ch_in_style":"default"}'>\u3000</span>`
      ];
      __privateMethod2(this, _clearText, clearText_fn).call(this);
      this.goTxt(aSpan);
    }
  }
  cvsResize() {
    const s2 = __privateGet2(this, _htmTxt).style;
    s2.left = `${this.sys.ofsLeft4elm + __privateGet2(this, _left) * this.sys.cvsScale}px`;
    s2.top = `${this.sys.ofsTop4elm + this.spLay.position.y * this.sys.cvsScale}px`;
    s2.transform = `rotate(${this.spLay.angle}deg) scale(${this.spLay.scale.x * this.sys.cvsScale}, ${this.spLay.scale.y * this.sys.cvsScale})`;
    __privateGet2(this, _idc2).cvsResize();
    __privateGet2(this, _idcCh).cvsResize();
  }
  get tategaki() {
    return __privateGet2(this, _isTategaki);
  }
  get infTL() {
    return __privateGet2(this, _infTL);
  }
  get getWidth() {
    return __privateGet2(this, _infTL).$width;
  }
  get getHeight() {
    return __privateGet2(this, _infTL).$height;
  }
  setSize(width, height) {
    __privateGet2(this, _infTL).$width = width;
    __privateGet2(this, _infTL).$height = height;
    __privateGet2(this, _htmTxt).style.width = __privateGet2(this, _infTL).$width + "px";
    __privateGet2(this, _htmTxt).style.height = __privateGet2(this, _infTL).$height + "px";
  }
  goTxt(aSpan) {
    var _a3, _b3, _c3, _d2, _e;
    __privateGet2(_TxtStage, _cntBreak).visible = false;
    const begin = __privateGet2(this, _aRect).length;
    if (begin === 0) {
      if (__privateGet2(_TxtStage, _cfg2).oCfg.debug.masume) {
        if (CmnLib.debugLog)
          console.log(`\u{1F34C} masume ${this.name} v:${this.visible} l:${this.x} t:${this.y} a:${this.alpha} pl:${__privateGet2(this, _infTL).pad_left} pr:${__privateGet2(this, _infTL).pad_right} pt:${__privateGet2(this, _infTL).pad_top} pb:${__privateGet2(this, _infTL).pad_bottom} w:${__privateGet2(this, _infTL).$width} h:${__privateGet2(this, _infTL).$height}`);
        __privateGet2(this, _grpDbgMasume).clear().beginFill(3407616, 0.2).lineStyle(1, 3407616, 1).drawRect(-__privateGet2(this, _infTL).pad_left, -__privateGet2(this, _infTL).pad_top, __privateGet2(this, _infTL).$width, __privateGet2(this, _infTL).$height).endFill().beginFill(13311, 0.2).lineStyle(2, 13311, 1).drawRect(0, 0, __privateGet2(this, _infTL).$width - __privateGet2(this, _infTL).pad_left - __privateGet2(this, _infTL).pad_right, __privateGet2(this, _infTL).$height - __privateGet2(this, _infTL).pad_top - __privateGet2(this, _infTL).pad_bottom).endFill();
      }
      __privateGet2(this, _htmTxt).innerHTML = [...aSpan].join("").replaceAll(/[\n\t]/g, "");
    } else
      __privateGet2(this, _htmTxt).insertAdjacentHTML("beforeend", aSpan.slice(__privateGet2(this, _lenHtmTxt)).join("").replaceAll(/[\n\t]/g, ""));
    __privateSet2(this, _lenHtmTxt, aSpan.length);
    let len = 0;
    let j2 = 2;
    do {
      const e = __privateSet2(this, _aRect, __privateMethod2(this, _getChRects, getChRects_fn).call(this, __privateGet2(this, _htmTxt)));
      len = e.length;
      if (this.sys.cvsScale !== 1) {
        const ox = this.sys.ofsPadLeft_Dom2PIXI + parseFloat(__privateGet2(this, _htmTxt).style.left) * (1 - this.sys.cvsScale);
        const oy = this.sys.ofsPadTop_Dom2PIXI + parseFloat(__privateGet2(this, _htmTxt).style.top) * (1 - this.sys.cvsScale);
        for (let i2 = 0; i2 < len; ++i2) {
          const r2 = e[i2].rect;
          r2.x -= ox;
          r2.y -= oy;
          r2.x /= this.sys.cvsScale;
          r2.y /= this.sys.cvsScale;
          r2.width /= this.sys.cvsScale;
          r2.height /= this.sys.cvsScale;
        }
      }
      if (len < 2)
        break;
      let sl_xy = -Infinity;
      for (; j2 < len; ++j2) {
        const he = e[j2];
        if (he.elm.outerHTML.slice(0, 3) === "<rt")
          continue;
        const xy = this.tategaki ? he.rect.y : he.rect.x;
        if (sl_xy <= xy) {
          sl_xy = xy;
          continue;
        }
        sl_xy = -Infinity;
        const oldJ = j2;
        if (__privateGet2(_TxtStage, _reg\u5206\u5272\u7981\u6B62).test(e[j2 - 1].ch) && e[j2 - 1].ch === he.ch) {
          --j2;
        } else {
          if (__privateGet2(_TxtStage, _reg\u884C\u672B\u7981\u5247).test(e[j2 - 1].ch)) {
            --j2;
          } else if (__privateGet2(_TxtStage, _reg\u884C\u982D\u7981\u5247).test(he.ch)) {
            while (j2 > 0 && __privateGet2(_TxtStage, _reg\u884C\u982D\u7981\u5247).test(e[--j2].ch)) {
            }
          } else
            continue;
          while (j2 > 0 && __privateGet2(_TxtStage, _reg\u884C\u672B\u7981\u5247).test(e[j2 - 1].ch)) {
            --j2;
          }
        }
        const pal = e[j2].elm.parentElement;
        const br = document.createElement("br");
        if (pal.classList.contains("sn_tx"))
          pal.insertBefore(br, e[j2].elm);
        else {
          const ppal = pal.parentElement;
          if (ppal.classList.contains("sn_ch")) {
            ppal.parentElement.insertBefore(br, ppal);
          } else
            ppal.insertBefore(br, pal);
        }
        j2 += 2;
        if (j2 < oldJ)
          j2 = oldJ;
        len = -1;
        break;
      }
    } while (len < 0);
    const fncMasumeLog = CmnLib.debugLog ? (v2, rct) => console.log(`\u{1F34C} masume ch:${v2.ch} x:${rct.x} y:${rct.y} w:${rct.width} h:${rct.height}`) : () => {
    };
    const fncMasume = __privateGet2(_TxtStage, _cfg2).oCfg.debug.masume ? (v2, rct) => {
      fncMasumeLog(v2, rct);
      __privateGet2(this, _grpDbgMasume).beginFill(6737151, 0.5).lineStyle(2, 16724736, 1).drawRect(rct.x, rct.y, rct.width, rct.height).endFill();
    } : () => {
    };
    const ease = CmnTween.ease(__privateGet2(this, _fi_easing));
    const bcr = __privateGet2(this, _htmTxt).getBoundingClientRect();
    const sx = bcr.left + globalThis.scrollX + __privateGet2(this, _infTL).pad_left;
    const sy = bcr.top + globalThis.scrollY + __privateGet2(this, _infTL).pad_top;
    let rctLastCh = new Rectangle();
    for (let i2 = begin; i2 < len; ++i2) {
      const v2 = __privateGet2(this, _aRect)[i2];
      const rct = v2.rect;
      const arg = JSON.parse((_a3 = v2.arg) != null ? _a3 : '{"delay": 0}');
      const add3 = JSON.parse((_b3 = v2.add) != null ? _b3 : "{}");
      const cis = __privateGet2(_TxtStage, _hChInStyle)[add3.ch_in_style];
      rct.x -= sx;
      rct.y -= sy;
      fncMasume(v2, rct);
      if (cis) {
        if (__privateGet2(this, _isTategaki)) {
          rct.x += (rct.width - rct.height) / 2;
          rct.width = rct.height;
        } else {
          rct.y += (rct.height - rct.width) / 2;
          rct.height = rct.width;
        }
        rctLastCh = rct;
      }
      switch (v2.cmd) {
        case "grp":
          const cnt = new Container();
          __privateGet2(this, _cntTxt).addChild(cnt);
          GrpLayer.csv2Sprites(arg.pic, cnt, (sp2) => {
            __privateMethod2(this, _spWork, spWork_fn).call(this, cnt, arg, add3, rct, ease, cis != null ? cis : {});
            if (!cnt.parent)
              cnt.removeChild(sp2);
          });
          break;
        case "link":
          const sp = new Sprite();
          arg.key = `lnk=[${i2}] ` + this.name;
          __privateMethod2(this, _spWork, spWork_fn).call(this, sp, arg, add3, rct, ease, cis != null ? cis : {});
          (_c3 = arg.hint_tate) != null ? _c3 : arg.hint_tate = __privateGet2(this, _isTategaki);
          const style_normal = v2.elm.style.cssText;
          const style_hover = (_d2 = arg.style_hover) != null ? _d2 : "";
          const style_clicked = (_e = arg.style_clicked) != null ? _e : "";
          __privateGet2(_TxtStage, _evtMng3).button(arg, sp, () => v2.elm.style.cssText = style_normal, __privateGet2(this, _beforeHTMLElm) !== v2.elm ? () => {
            if (!this.canFocus())
              return false;
            v2.elm.style.cssText = style_hover;
            return true;
          } : () => false, () => v2.elm.style.cssText = style_clicked);
          __privateSet2(this, _beforeHTMLElm, v2.elm);
          __privateGet2(this, _cntTxt).addChild(sp);
          break;
      }
    }
    const chs = __privateGet2(this, _htmTxt).querySelectorAll("span.sn_ch");
    chs.forEach((v2) => v2.className = v2.className.replace(/sn_ch_in_([^\s"]+)/g, "go_ch_in_$1"));
    __privateSet2(this, _isChInIng, true);
    __privateSet2(this, _fncEndChIn, () => {
      __privateSet2(this, _isChInIng, false);
      chs.forEach((v2) => v2.className = v2.className.replace(/ go_ch_in_[^\s"]+/g, ""));
      if (begin !== len) {
        __privateSet2(this, _break_fixed_left, rctLastCh.x + (__privateGet2(this, _isTategaki) ? 0 : rctLastCh.width));
        __privateSet2(this, _break_fixed_top, rctLastCh.y + (__privateGet2(this, _isTategaki) ? rctLastCh.height : 0));
      }
      __privateGet2(_TxtStage, _cntBreak).position.set(__privateGet2(this, _break_fixed_left), __privateGet2(this, _break_fixed_top));
      __privateGet2(_TxtStage, _cntBreak).visible = true;
      __privateSet2(this, _fncEndChIn, () => {
      });
    });
    const len_chs = chs.length;
    if (len_chs === 0) {
      __privateGet2(this, _fncEndChIn).call(this);
      return;
    }
    let le = void 0;
    for (let i2 = len_chs - 1; i2 >= 0; --i2) {
      const v2 = chs[i2];
      if (v2.className === "sn_ch")
        break;
      const st = v2.getAttribute("style");
      if (!st) {
        le = v2;
        break;
      }
      const m2 = st.match(__privateGet2(this, _REGDS));
      const g2 = m2 == null ? void 0 : m2.groups;
      if (!g2 || Number(g2.ms) > 0) {
        le = v2;
        break;
      }
    }
    if (!le) {
      __privateGet2(this, _fncEndChIn).call(this);
      return;
    }
    le.addEventListener("animationend", __privateGet2(this, _fncEndChIn), { once: true, passive: true });
  }
  skipChIn() {
    let isLiveTw = __privateGet2(this, _isChInIng);
    __privateGet2(this, _fncEndChIn).call(this);
    __privateGet2(this, _aSpTw).forEach((st) => {
      if (st.tw) {
        st.tw.stop().end();
        isLiveTw = true;
      }
    });
    __privateSet2(this, _aSpTw, []);
    return isLiveTw;
  }
  static initChStyle() {
    __privateSet2(_TxtStage, _hChInStyle, /* @__PURE__ */ Object.create(null));
    __privateSet2(_TxtStage, _hChOutStyle, /* @__PURE__ */ Object.create(null));
  }
  static getChInStyle(name2) {
    return __privateGet2(_TxtStage, _hChInStyle)[name2];
  }
  static ch_in_style(hArg) {
    var _a3, _b3, _c3;
    const { name: name2 } = hArg;
    if (!name2)
      throw "name\u306F\u5FC5\u9808\u3067\u3059";
    __privateGet2(_TxtStage, _REG_NG_CHSTYLE_NAME_CHR).lastIndex = 0;
    if (__privateGet2(_TxtStage, _REG_NG_CHSTYLE_NAME_CHR).test(name2))
      throw `name\u3010${name2}\u3011\u306B\u4F7F\u3048\u306A\u3044\u6587\u5B57\u304C\u542B\u307E\u308C\u307E\u3059`;
    if (name2 in __privateGet2(_TxtStage, _hChInStyle))
      throw `name\u3010${name2}\u3011\u306F\u3059\u3067\u306B\u3042\u308A\u307E\u3059`;
    const x2 = String((_a3 = hArg.x) != null ? _a3 : "=0");
    const y2 = String((_b3 = hArg.y) != null ? _b3 : "=0");
    return __privateGet2(_TxtStage, _hChInStyle)[name2] = {
      wait: argChk_Num(hArg, "wait", 500),
      alpha: argChk_Num(hArg, "alpha", 0),
      x: x2,
      y: y2,
      nx: parseFloat(x2.charAt(0) === "=" ? x2.slice(1) : x2),
      ny: parseFloat(y2.charAt(0) === "=" ? y2.slice(1) : y2),
      scale_x: argChk_Num(hArg, "scale_x", 1),
      scale_y: argChk_Num(hArg, "scale_y", 1),
      rotate: argChk_Num(hArg, "rotate", 0),
      join: argChk_Boolean(hArg, "join", true),
      ease: (_c3 = hArg.ease) != null ? _c3 : "ease-out"
    };
  }
  static getChOutStyle(name2) {
    return __privateGet2(_TxtStage, _hChOutStyle)[name2];
  }
  static ch_out_style(hArg) {
    var _a3, _b3, _c3;
    const { name: name2 } = hArg;
    if (!name2)
      throw "name\u306F\u5FC5\u9808\u3067\u3059";
    __privateGet2(_TxtStage, _REG_NG_CHSTYLE_NAME_CHR).lastIndex = 0;
    if (__privateGet2(_TxtStage, _REG_NG_CHSTYLE_NAME_CHR).test(name2))
      throw `name\u3010${name2}\u3011\u306B\u4F7F\u3048\u306A\u3044\u6587\u5B57\u304C\u542B\u307E\u308C\u307E\u3059`;
    if (name2 in __privateGet2(_TxtStage, _hChOutStyle))
      throw `name\u3010${name2}\u3011\u306F\u3059\u3067\u306B\u3042\u308A\u307E\u3059`;
    const x2 = String((_a3 = hArg.x) != null ? _a3 : "=0");
    const y2 = String((_b3 = hArg.y) != null ? _b3 : "=0");
    return __privateGet2(_TxtStage, _hChOutStyle)[name2] = {
      wait: argChk_Num(hArg, "wait", 500),
      alpha: argChk_Num(hArg, "alpha", 0),
      x: x2,
      y: y2,
      nx: parseFloat(x2.charAt(0) === "=" ? x2.slice(1) : x2),
      ny: parseFloat(y2.charAt(0) === "=" ? y2.slice(1) : y2),
      scale_x: argChk_Num(hArg, "scale_x", 1),
      scale_y: argChk_Num(hArg, "scale_y", 1),
      rotate: argChk_Num(hArg, "rotate", 0),
      join: argChk_Boolean(hArg, "join", false),
      ease: (_c3 = hArg.ease) != null ? _c3 : "ease-out"
    };
  }
  dispBreak(pic) {
    const cnt = __privateGet2(_TxtStage, _cntBreak);
    cnt.visible = false;
    this.addChild(cnt);
    GrpLayer.csv2Sprites(pic, cnt, (sp) => {
      if (!cnt.parent)
        cnt.removeChild(sp);
    });
  }
  static delBreak() {
    const cnt = __privateGet2(_TxtStage, _cntBreak);
    if (cnt.parent) {
      cnt.parent.removeChild(cnt);
      cnt.removeChildren();
    }
    __privateSet2(_TxtStage, _cntBreak, new Container());
  }
  reNew() {
    var _a3;
    __privateMethod2(this, _clearText, clearText_fn).call(this);
    const to = new _TxtStage(this.spLay, () => this.canFocus(), this.sys);
    __privateSet2(to, _infTL, __privateGet2(this, _infTL));
    __privateGet2(to, _htmTxt).style.cssText = __privateGet2(this, _htmTxt).style.cssText;
    __privateSet2(to, _left, __privateGet2(this, _left));
    to.name = this.name;
    __privateMethod2(_a3 = to, _lay_sub, lay_sub_fn).call(_a3);
    __privateGet2(to, _idc2).sethArg(__privateGet2(this, _idc2).gethArg());
    __privateSet2(to, _ch_filter, __privateGet2(this, _ch_filter));
    __privateSet2(to, _fi_easing, __privateGet2(this, _fi_easing));
    __privateSet2(to, _fo_easing, __privateGet2(this, _fo_easing));
    __privateSet2(to, _break_fixed, __privateGet2(this, _break_fixed));
    __privateSet2(to, _break_fixed_left, __privateGet2(this, _break_fixed_left));
    __privateSet2(to, _break_fixed_top, __privateGet2(this, _break_fixed_top));
    this.destroy();
    return to;
  }
  record() {
    return {
      infTL: __privateGet2(this, _infTL),
      cssText: __privateGet2(this, _htmTxt).style.cssText,
      left: __privateGet2(this, _left),
      idc_hArg: __privateGet2(this, _idc2).gethArg(),
      ch_filter: __privateGet2(this, _ch_filter),
      fi_easing: __privateGet2(this, _fi_easing),
      fo_easing: __privateGet2(this, _fo_easing),
      break_fixed: __privateGet2(this, _break_fixed),
      break_fixed_left: __privateGet2(this, _break_fixed_left),
      break_fixed_top: __privateGet2(this, _break_fixed_top)
    };
  }
  playback(hLay) {
    var _a3, _b3, _c3;
    __privateSet2(this, _infTL, hLay.infTL);
    this.position.set(__privateGet2(this, _infTL).pad_left, __privateGet2(this, _infTL).pad_top);
    __privateGet2(this, _htmTxt).style.cssText = hLay.cssText;
    __privateSet2(this, _left, hLay.left);
    __privateMethod2(this, _lay_sub, lay_sub_fn).call(this);
    __privateGet2(this, _idc2).sethArg(hLay.idc_hArg);
    __privateSet2(this, _ch_filter, hLay.ch_filter);
    __privateSet2(this, _fi_easing, hLay.fi_easing);
    __privateSet2(this, _fo_easing, hLay.fo_easing);
    __privateSet2(this, _break_fixed, (_a3 = hLay.break_fixed) != null ? _a3 : false);
    __privateSet2(this, _break_fixed_left, (_b3 = hLay.break_fixed_left) != null ? _b3 : 0);
    __privateSet2(this, _break_fixed_top, (_c3 = hLay.break_fixed_top) != null ? _c3 : 0);
  }
  snapshot(rnd, re2) {
    __privateMethod2(this, _htm2tx, htm2tx_fn).call(this, (tx) => {
      __privateSet2(this, _sss, new Sprite(tx));
      if (__privateGet2(this, _isTategaki)) {
        __privateGet2(this, _sss).x += CmnLib.stageW - (__privateGet2(this, _left) + __privateGet2(this, _infTL).$width);
      }
      __privateGet2(this, _sss).y -= __privateGet2(this, _padTx4y);
      __privateGet2(this, _sss).texture.frame = new Rectangle(0, 0, __privateGet2(this, _infTL).$width - __privateGet2(this, _left), __privateGet2(this, _infTL).$height);
      __privateGet2(this, _cntTxt).addChild(__privateGet2(this, _sss));
      rnd.render(__privateGet2(this, _sss), void 0, false);
      re2();
    }, false);
  }
  snapshot_end() {
    if (__privateGet2(this, _sss)) {
      __privateGet2(this, _cntTxt).removeChild(__privateGet2(this, _sss));
      __privateSet2(this, _sss, void 0);
    }
  }
  makeDesignCast(gdc) {
    gdc(__privateGet2(this, _idc2));
    const o = __privateGet2(this, _idc2).gethArg();
    __privateGet2(this, _idcCh).sethArg(__spreadProps(__spreadValues({}, o), { ":id_dc": o[":id_tag"] + "_pad" }));
    gdc(__privateGet2(this, _idcCh));
  }
  showDesignCast() {
    __privateGet2(this, _idc2).visible = true;
    __privateGet2(this, _idcCh).visible = true;
  }
  dump() {
    const aStyle = [];
    const s2 = __privateGet2(this, _htmTxt).style;
    const len = s2.length;
    for (let i2 = 0; i2 < len; ++i2) {
      const key = s2[i2];
      aStyle.push(`"${key}":"${s2[key].replace(/(["\\])/g, "\\$1")}"`);
    }
    return `"txt":"${__privateGet2(this, _htmTxt).textContent.replace(/(["\\])/g, "\\$1")}", "style":{${aStyle.join(",")}}`;
  }
  destroy() {
    _TxtStage.delBreak();
    __privateGet2(this, _htmTxt).parentElement.removeChild(__privateGet2(this, _htmTxt));
    this.removeChild(__privateGet2(this, _cntTxt));
    this.removeChild(__privateGet2(this, _grpDbgMasume));
    super.destroy();
  }
};
let TxtStage = _TxtStage;
_cfg2 = new WeakMap();
_appPixi2 = new WeakMap();
_evtMng3 = new WeakMap();
_htmTxt = new WeakMap();
_cntTxt = new WeakMap();
_grpDbgMasume = new WeakMap();
_idc2 = new WeakMap();
_idcCh = new WeakMap();
_infTL = new WeakMap();
_break_fixed = new WeakMap();
_break_fixed_left = new WeakMap();
_break_fixed_top = new WeakMap();
_lay_sub = new WeakSet();
lay_sub_fn = function() {
  var _a3;
  const s2 = __privateGet2(this, _htmTxt).style;
  const fs = parseFloat(s2.fontSize || "0");
  __privateGet2(this, _infTL).fontsize = fs;
  __privateGet2(this, _infTL).pad_left = parseFloat(s2.paddingLeft || "0");
  __privateGet2(this, _infTL).pad_right = parseFloat(s2.paddingRight || "0");
  __privateGet2(this, _infTL).pad_top = parseFloat(s2.paddingTop || "0");
  __privateGet2(this, _infTL).pad_bottom = parseFloat(s2.paddingBottom || "0");
  __privateGet2(this, _infTL).$width = parseFloat(s2.width || "0");
  __privateGet2(this, _infTL).$height = parseFloat(s2.height || "0");
  this.position.set(__privateGet2(this, _infTL).pad_left, __privateGet2(this, _infTL).pad_top);
  __privateSet2(this, _isTategaki, s2.writingMode === "vertical-rl");
  __privateSet2(this, _padTx4x, 0);
  __privateSet2(this, _padTx4y, 0);
  const lh = (_a3 = s2.lineHeight) != null ? _a3 : "0";
  __privateSet2(this, _lh_half, __privateGet2(this, _isTategaki) ? 0 : (lh.slice(-2) === "px" ? parseFloat(lh) : fs * parseFloat(lh) - fs) / 2);
};
_left = new WeakMap();
_isTategaki = new WeakMap();
_padTx4x = new WeakMap();
_padTx4y = new WeakMap();
_hWarning = new WeakMap();
_htm2tx = new WeakSet();
htm2tx_fn = function(fnc, hidden = true) {
  const util2 = {
    escape: (str2) => str2.replace(/([.*+?^${}()|\[\]\/\\])/g, "\\$1"),
    mimeType: (url2) => {
      const extension = parseExtension(url2).toLowerCase();
      return mimes()[extension] || "";
    },
    dataAsUrl,
    isDataUrl,
    resolveUrl,
    getAndEncode,
    asArray: (arrayLike) => {
      const a2 = [];
      const len = arrayLike.length;
      for (let i2 = 0; i2 < len; ++i2)
        a2.push(arrayLike[i2]);
      return a2;
    }
  };
  function mimes() {
    const WOFF = "application/font-woff";
    const JPEG = "image/jpeg";
    return {
      "woff": WOFF,
      "woff2": WOFF,
      "ttf": "application/font-truetype",
      "eot": "application/vnd.ms-fontobject",
      "png": "image/png",
      "jpg": JPEG,
      "jpeg": JPEG,
      "gif": "image/gif",
      "tiff": "image/tiff",
      "svg": "image/svg+xml"
    };
  }
  const inliner = newInliner();
  const fontFaces = newFontFaces();
  function embedFonts(node) {
    return fontFaces.resolveAll().then((cssText) => {
      const styleNode = document.createElement("style");
      node.appendChild(styleNode);
      styleNode.appendChild(document.createTextNode(cssText));
      return node;
    });
  }
  function parseExtension(url2) {
    var _a3;
    const match = /\.([^\.\/]*?)$/g.exec(url2);
    return (_a3 = match == null ? void 0 : match[1]) != null ? _a3 : "";
  }
  function isDataUrl(url2) {
    return url2.search(/^(data:)/) !== -1;
  }
  function resolveUrl(url2, baseUrl) {
    const doc2 = document.implementation.createHTMLDocument();
    const base = doc2.createElement("base");
    doc2.head.appendChild(base);
    const a2 = doc2.createElement("a");
    doc2.body.appendChild(a2);
    base.href = baseUrl;
    a2.href = url2;
    return a2.href;
  }
  function getAndEncode(url2) {
    let TIMEOUT = 3e4;
    return new Promise(function(resolve2) {
      const request = new XMLHttpRequest();
      request.onreadystatechange = done;
      request.ontimeout = timeout;
      request.responseType = "blob";
      request.timeout = TIMEOUT;
      request.open("GET", url2, true);
      request.send();
      function done() {
        if (request.readyState !== 4)
          return;
        if (request.status !== 200) {
          fail("cannot fetch resource: " + url2 + ", status: " + request.status);
          return;
        }
        const encoder = new FileReader();
        encoder.onloadend = function() {
          const content = encoder.result.toString().split(/,/)[1];
          resolve2(content);
        };
        encoder.readAsDataURL(request.response);
      }
      function timeout() {
        fail("timeout of " + TIMEOUT + "ms occured while fetching resource: " + url2);
      }
      function fail(message) {
        console.error(message);
        resolve2("");
      }
    });
  }
  function dataAsUrl(content, type) {
    return "data:" + type + ";base64," + content;
  }
  function newInliner() {
    const URL_REGEX = /url\(['"]?([^'"]+?)['"]?\)/g;
    return {
      inlineAll,
      shouldProcess
    };
    function shouldProcess(str2) {
      return str2.search(URL_REGEX) !== -1;
    }
    function readUrls(str2) {
      const result = [];
      let match;
      while (match = URL_REGEX.exec(str2)) {
        result.push(match[1]);
      }
      return result.filter(function(url2) {
        return !util2.isDataUrl(url2);
      });
    }
    function inline(str2, url2, baseUrl, get) {
      return Promise.resolve(url2).then((url22) => baseUrl ? util2.resolveUrl(url22, baseUrl) : url22).then(get || util2.getAndEncode).then((data) => util2.dataAsUrl(data, util2.mimeType(url2))).then((dataUrl) => str2.replace(urlAsRegex(url2), "$1" + dataUrl + "$3"));
      function urlAsRegex(url22) {
        return new RegExp(`(url\\(['"]?)(` + util2.escape(url22) + `)(['"]?\\))`, "g");
      }
    }
    function inlineAll(str2, baseUrl, get) {
      if (nothingToInline())
        return Promise.resolve(str2);
      return Promise.resolve(str2).then(readUrls).then((urls) => {
        let done = Promise.resolve(str2);
        for (const url2 of urls) {
          done = done.then((string) => {
            return inline(string, url2, baseUrl, get);
          });
        }
        return done;
      });
      function nothingToInline() {
        return !shouldProcess(str2);
      }
    }
  }
  function newFontFaces() {
    return {
      resolveAll,
      impl: { readAll }
    };
    function resolveAll() {
      return readAll().then((webFonts) => Promise.allSettled(webFonts.map((webFont) => webFont.resolve()))).then((cssStrings) => cssStrings.join("\n"));
    }
    function readAll() {
      return Promise.resolve(util2.asArray(document.styleSheets)).then(getCssRules).then(selectWebFontRules).then((rules) => rules.map(newWebFont));
      function selectWebFontRules(cssRules) {
        return cssRules.filter((rule) => rule.type === CSSRule.FONT_FACE_RULE).filter((rule) => inliner.shouldProcess(rule.style.getPropertyValue("src")));
      }
      function getCssRules(styleSheets) {
        const cssRules = [];
        for (const sheet of styleSheets) {
          try {
            if (sheet.href)
              continue;
            util2.asArray(sheet.cssRules || []).forEach(cssRules.push.bind(cssRules));
          } catch (e) {
            console.error("Error while reading CSS rules from " + sheet.href, e.toString());
          }
        }
        return cssRules;
      }
      function newWebFont(webFontRule) {
        return {
          resolve: function resolve2() {
            const baseUrl = (webFontRule.parentStyleSheet || {}).href;
            return inliner.inlineAll(webFontRule.cssText, baseUrl);
          },
          src: function() {
            return webFontRule.style.getPropertyValue("src");
          }
        };
      }
    }
  }
  Promise.resolve(__privateGet2(this, _htmTxt)).then((node) => {
    const cln = node.cloneNode(true);
    cln.style.padding = "0px";
    cln.style.paddingRight = __privateGet2(this, _padTx4x) + "px";
    cln.style.paddingTop = __privateGet2(this, _padTx4y) + "px";
    cln.style.left = "0px";
    cln.style.top = "0px";
    cln.style.width = __privateGet2(this, _infTL).$width - __privateGet2(this, _infTL).pad_left - __privateGet2(this, _infTL).pad_right + "px";
    cln.style.height = __privateGet2(this, _infTL).$height - __privateGet2(this, _infTL).pad_top - __privateGet2(this, _infTL).pad_bottom + "px";
    __privateGet2(this, _htmTxt).hidden = hidden;
    return cln;
  }).then(embedFonts).then((node) => {
    node.setAttribute("xmlns", "http://www.w3.org/1999/xhtml");
    const img = new Image();
    img.src = `data:image/svg+xml;charset=utf-8,<svg xmlns="http://www.w3.org/2000/svg" width="${__privateGet2(this, _infTL).$width}px" height="${__privateGet2(this, _infTL).$height}px"><foreignObject x="0" y="0" width="100%" height="100%">${new XMLSerializer().serializeToString(node).replaceAll("#", "%23").replaceAll("\n", "%0A")}</foreignObject></svg>`;
    return new Promise((resolve2) => img.onload = () => resolve2(img));
  }).then((img) => new Promise((resolve2) => setTimeout(() => resolve2(img), 100))).then((img) => {
    const canvas2 = document.createElement("canvas");
    canvas2.width = __privateGet2(this, _infTL).$width;
    canvas2.height = __privateGet2(this, _infTL).$height;
    canvas2.getContext("2d").drawImage(img, 0, 0);
    canvas2.toBlob((blob) => {
      if (!blob)
        return;
      const url2 = URL.createObjectURL(blob);
      Texture.from(url2).once("update", (tx2) => {
        fnc(tx2);
        URL.revokeObjectURL(url2);
      });
    });
  }).catch((err) => DebugMng.myTrace(`goTxt() = ${err}`));
};
_ch_filter = new WeakMap();
_aSpTw = new WeakMap();
_aRect = new WeakMap();
_lenHtmTxt = new WeakMap();
_reg\u884C\u982D\u7981\u5247 = new WeakMap();
_reg\u884C\u672B\u7981\u5247 = new WeakMap();
_reg\u5206\u5272\u7981\u6B62 = new WeakMap();
_beforeHTMLElm = new WeakMap();
_REGDS = new WeakMap();
_fncEndChIn = new WeakMap();
_spWork = new WeakSet();
spWork_fn = function(sp, arg, add3, rct, ease, cis) {
  var _a3, _b3, _c3;
  sp.alpha = 0;
  if (arg.x)
    rct.x = arg.x.charAt(0) === "=" ? rct.x + parseInt(arg.x.slice(1)) : parseInt(arg.x);
  if (arg.y)
    rct.y = arg.y.charAt(0) === "=" ? rct.y + parseInt(arg.y.slice(1)) : parseInt(arg.y);
  if (arg.width)
    rct.width = parseInt(arg.width);
  if (arg.height)
    rct.height = parseInt(arg.height);
  if (arg.wait)
    cis.wait = parseInt(arg.wait);
  sp.width = rct.width;
  sp.height = rct.height;
  sp.position.set(cis.x.charAt(0) === "=" ? rct.x + sp.width * cis.nx : cis.nx, cis.y.charAt(0) === "=" ? rct.y + sp.height * cis.ny : cis.ny);
  const st = {
    sp,
    tw: new Tween(sp).to({ alpha: 1, x: rct.x, y: rct.y, width: rct.width, height: rct.height, angle: 0 }, (_a3 = cis.wait) != null ? _a3 : 0).easing(ease).delay(((_b3 = add3.wait) != null ? _b3 : 0) + ((_c3 = arg.delay) != null ? _c3 : 0)).onComplete(() => {
      st.tw = void 0;
    }).start()
  };
  __privateGet2(this, _aSpTw).push(st);
};
_isChInIng = new WeakMap();
_hChInStyle = new WeakMap();
_REG_NG_CHSTYLE_NAME_CHR = new WeakMap();
_hChOutStyle = new WeakMap();
_cntBreak = new WeakMap();
_lh_half = new WeakMap();
_getChRects = new WeakSet();
getChRects_fn = function(elm) {
  var _a3, _b3, _c3, _d2;
  const ret = [];
  if (elm.nodeType !== elm.TEXT_NODE) {
    elm.childNodes.forEach((v2) => ret.push(__privateMethod2(this, _getChRects, getChRects_fn).call(this, v2)));
    return Array.prototype.concat.apply([], ret);
  }
  const range = elm.ownerDocument.createRange();
  range.selectNodeContents(elm);
  let pos = 0;
  const end = range.endOffset;
  while (pos < end) {
    range.setStart(elm, pos);
    range.setEnd(elm, ++pos);
    const r2 = range.getBoundingClientRect();
    const pe = range.startContainer.parentElement;
    if (!pe)
      throw `fn:TxtStage.ts pe null`;
    const ch = range.toString();
    const cr = {
      ch,
      rect: new Rectangle(r2.left + globalThis.scrollX, r2.top + globalThis.scrollY, r2.width, r2.height + ("gjqy".includes(ch) ? __privateGet2(this, _lh_half) : 0)),
      elm: pe,
      cmd: (_a3 = pe.getAttribute("data-cmd")) != null ? _a3 : void 0,
      arg: (_b3 = pe.getAttribute("data-arg")) != null ? _b3 : void 0,
      add: (_c3 = pe.getAttribute("data-add")) != null ? _c3 : void 0,
      tcy: (_d2 = pe.getAttribute("data-tcy")) != null ? _d2 : void 0
    };
    ret.push(cr);
  }
  range.detach();
  return ret;
};
_fi_easing = new WeakMap();
_fo_easing = new WeakMap();
_clearText = new WeakSet();
clearText_fn = function() {
  var _a3;
  __privateGet2(this, _grpDbgMasume).clear();
  __privateSet2(this, _aRect, []);
  __privateSet2(this, _lenHtmTxt, 0);
  this.skipChIn();
  const n = __privateGet2(this, _htmTxt).cloneNode(true);
  n.textContent = "";
  const old = __privateGet2(this, _htmTxt);
  old.parentElement.insertBefore(n, old);
  let sum_wait = 0;
  old.querySelectorAll("span.sn_ch").forEach((elm) => {
    var _a4, _b3, _c3, _d2, _e, _f;
    const add3 = JSON.parse((_f = (_e = (_b3 = elm == null ? void 0 : elm.getAttribute("data-add")) != null ? _b3 : (_a4 = elm == null ? void 0 : elm.children[0]) == null ? void 0 : _a4.getAttribute("data-add")) != null ? _e : (_d2 = (_c3 = elm == null ? void 0 : elm.children[0]) == null ? void 0 : _c3.children[0]) == null ? void 0 : _d2.getAttribute("data-add")) != null ? _f : "{}");
    if (!add3.ch_out_style)
      return;
    const cos = __privateGet2(_TxtStage, _hChOutStyle)[add3.ch_out_style];
    if (!cos)
      return;
    if (cos.wait === 0) {
      elm.style.display = "none";
      return;
    }
    sum_wait += cos.wait;
    if (!cos.join)
      elm.style.animationDelay = "0ms";
    elm.classList.add(`go_ch_out_${add3.ch_out_style}`);
  });
  const end = () => {
    old.parentElement.removeChild(old);
    __privateGet2(this, _cntTxt).removeChildren().forEach((c2) => {
      if (c2 instanceof Container)
        __privateGet2(_TxtStage, _evtMng3).unButton(c2);
      c2.destroy();
    });
  };
  if (sum_wait === 0) {
    __privateGet2(this, _htmTxt).textContent = "";
    end();
  } else
    (_a3 = old.lastElementChild) == null ? void 0 : _a3.addEventListener("animationend", end, { once: true, passive: true });
  __privateSet2(this, _htmTxt, n);
};
_sss = new WeakMap();
__privateAdd2(TxtStage, _cfg2, void 0);
__privateAdd2(TxtStage, _appPixi2, void 0);
__privateAdd2(TxtStage, _evtMng3, void 0);
__privateAdd2(TxtStage, _hWarning, {
  backgroundColor: 0,
  borderBottomWidth: 0,
  borderLeftWidth: 0,
  borderRightWidth: 0,
  borderTopWidth: 0,
  marginBottom: 0,
  marginLeft: 0,
  marginRight: 0,
  marginTop: 0
});
__privateAdd2(TxtStage, _reg\u884C\u982D\u7981\u5247, void 0);
__privateAdd2(TxtStage, _reg\u884C\u672B\u7981\u5247, void 0);
__privateAdd2(TxtStage, _reg\u5206\u5272\u7981\u6B62, void 0);
__privateAdd2(TxtStage, _hChInStyle, /* @__PURE__ */ Object.create(null));
__privateAdd2(TxtStage, _REG_NG_CHSTYLE_NAME_CHR, /[\s\.,]/);
__privateAdd2(TxtStage, _hChOutStyle, /* @__PURE__ */ Object.create(null));
__privateAdd2(TxtStage, _cntBreak, new Container());
var __accessCheck$1 = (obj, member, msg) => {
  if (!member.has(obj))
    throw TypeError("Cannot " + msg);
};
var __privateGet$1 = (obj, member, getter) => {
  __accessCheck$1(obj, member, "read from private field");
  return getter ? getter.call(obj) : member.get(obj);
};
var __privateAdd$1 = (obj, member, value) => {
  if (member.has(obj))
    throw TypeError("Cannot add the same private member more than once");
  member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
};
var __privateSet$1 = (obj, member, value, setter) => {
  __accessCheck$1(obj, member, "write to private field");
  setter ? setter.call(obj, value) : member.set(obj, value);
  return value;
};
var __privateMethod$1 = (obj, member, method) => {
  __accessCheck$1(obj, member, "access private method");
  return method;
};
var _procMasume4txt, _procMasume4pic, _rctBtnTxt, _idc, _sp_b_pic, _sp_pic, _loaded_b_pic, loaded_b_pic_fn, _normal, _hover, _clicked, _loaded_pic, loaded_pic_fn;
const _Button = class extends Container {
  constructor(hArg, evtMng, resolve2, canFocus) {
    super();
    var _a4, _b3, _c3;
    this.hArg = hArg;
    this.evtMng = evtMng;
    this.resolve = resolve2;
    this.canFocus = canFocus;
    __privateAdd$1(this, _loaded_b_pic);
    __privateAdd$1(this, _loaded_pic);
    this.getBtnBounds = () => __privateGet$1(this, _rctBtnTxt);
    __privateAdd$1(this, _rctBtnTxt, new Rectangle());
    __privateAdd$1(this, _idc, void 0);
    __privateAdd$1(this, _sp_b_pic, void 0);
    __privateAdd$1(this, _sp_pic, void 0);
    __privateAdd$1(this, _normal, () => {
    });
    __privateAdd$1(this, _hover, () => false);
    __privateAdd$1(this, _clicked, () => {
    });
    var _a3;
    if (CmnLib.isDbg) {
      this.makeDesignCast = (gdc) => gdc(__privateGet$1(this, _idc));
      this.cvsResize = () => __privateGet$1(this, _idc).cvsResize();
    }
    let oName = {
      x: this.x = uint((_a4 = hArg.left) != null ? _a4 : 0),
      y: this.y = uint((_b3 = hArg.top) != null ? _b3 : 0),
      rotation: this.angle = argChk_Num(hArg, "rotation", this.angle),
      pivot_x: this.pivot.x = argChk_Num(hArg, "pivot_x", this.pivot.x),
      pivot_y: this.pivot.y = argChk_Num(hArg, "pivot_y", this.pivot.y),
      scale_x: this.scale.x = argChk_Num(hArg, "scale_x", this.scale.x),
      scale_y: this.scale.y = argChk_Num(hArg, "scale_y", this.scale.y),
      width: 0,
      height: 0
    };
    const enabled = oName.enabled = argChk_Boolean(hArg, "enabled", true);
    this.getBtnBounds = () => {
      __privateGet$1(this, _rctBtnTxt).x = oName.x;
      __privateGet$1(this, _rctBtnTxt).y = oName.y;
      return __privateGet$1(this, _rctBtnTxt);
    };
    if (hArg.pic) {
      oName.type = "pic";
      __privateSet$1(this, _idc, new PicBtnDesignCast(this, hArg));
      if (enabled)
        this.evtMng.button(this.hArg, this, () => __privateGet$1(this, _normal).call(this), () => __privateGet$1(this, _hover).call(this), () => __privateGet$1(this, _clicked).call(this));
      if (!GrpLayer.csv2Sprites(hArg.pic, this, (sp) => {
        __privateMethod$1(this, _loaded_pic, loaded_pic_fn).call(this, sp, oName);
        __privateGet$1(this, _rctBtnTxt).width = sp.width * oName.scale_x;
        __privateGet$1(this, _rctBtnTxt).height = sp.height * oName.scale_y;
      }, (isStop2) => {
        if (isStop2)
          resolve2();
      }))
        resolve2();
      return;
    }
    if (!hArg.text)
      throw "text\u307E\u305F\u306Fpic\u5C5E\u6027\u306F\u5FC5\u9808\u3067\u3059";
    const height = argChk_Num(hArg, "height", 30);
    const style = new TextStyle({
      align: "center",
      dropShadow: true,
      dropShadowAlpha: 0.7,
      dropShadowColor: "white",
      dropShadowBlur: 7,
      dropShadowDistance: 0,
      fill: "black",
      fontFamily: _Button.fontFamily,
      fontSize: height,
      padding: 5
    });
    if (hArg.style)
      try {
        const o = JSON.parse(hArg.style);
        for (const nm in o)
          style[nm] = o[nm];
      } catch (e) {
        throw new Error(`[button] style\u6307\u5B9A\u304C\u7570\u5E38\u3067\u3059\u3002JSON\u6587\u5B57\u5217\u306F\u300C"\u300D\u3067\u56F2\u3093\u3067\u4E0B\u3055\u3044 err:${e}`);
      }
    const txt = new Text((_c3 = hArg.text) != null ? _c3 : "", style);
    txt.alpha = argChk_Num(hArg, "alpha", txt.alpha);
    txt.width = argChk_Num(hArg, "width", 100);
    txt.height = hArg.height = height;
    this.setText = (text2) => txt.text = text2;
    oName.type = "text";
    oName = __spreadValues(__spreadValues({}, oName), style);
    oName.alpha = txt.alpha;
    oName.text = txt.text;
    oName.width = txt.width;
    oName.height = txt.height;
    __privateSet$1(this, _idc, new TxtBtnDesignCast(this, hArg, txt));
    let isStop = false;
    if (hArg.b_pic) {
      oName.b_pic = hArg.b_pic;
      isStop = GrpLayer.csv2Sprites(hArg.b_pic, this, (sp) => {
        __privateMethod$1(this, _loaded_b_pic, loaded_b_pic_fn).call(this, sp, txt);
        oName.width = this.width;
        oName.height = this.height;
      }, (isStop2) => {
        Layer.setBlendmode(this, hArg);
        if (isStop2)
          resolve2();
      });
    }
    txt.name = JSON.stringify(oName);
    this.addChild(txt);
    __privateGet$1(this, _rctBtnTxt).width = txt.width;
    __privateGet$1(this, _rctBtnTxt).height = txt.height;
    oName.width = this.width;
    oName.height = this.height;
    if (!hArg.b_pic)
      Layer.setBlendmode(this, hArg);
    __privateGet$1(_a3 = _Button, _procMasume4txt).call(_a3, this, txt);
    if (!enabled) {
      if (!isStop)
        resolve2();
      return;
    }
    const style_hover = style.clone();
    if (hArg.style_hover)
      try {
        const o = JSON.parse(hArg.style_hover);
        for (const nm in o)
          style_hover[nm] = o[nm];
      } catch (e) {
        throw new Error(`[button] style_hover\u6307\u5B9A\u304C\u7570\u5E38\u3067\u3059\u3002JSON\u6587\u5B57\u5217\u306F\u300C"\u300D\u3067\u56F2\u3093\u3067\u4E0B\u3055\u3044 err:${e}`);
      }
    else
      style_hover.fill = "white";
    const style_clicked = style_hover.clone();
    if (hArg.style_clicked)
      try {
        const o = JSON.parse(hArg.style_clicked);
        for (const nm in o)
          style_clicked[nm] = o[nm];
      } catch (e) {
        throw new Error(`[button] style_clicked\u6307\u5B9A\u304C\u7570\u5E38\u3067\u3059\u3002JSON\u6587\u5B57\u5217\u306F\u300C"\u300D\u3067\u56F2\u3093\u3067\u4E0B\u3055\u3044 err:${e}`);
      }
    else
      style_clicked.dropShadow = false;
    evtMng.button(hArg, this, () => txt.style = style, () => {
      if (!canFocus())
        return false;
      txt.style = style_hover;
      return true;
    }, () => txt.style = style_clicked);
    if (!isStop)
      resolve2();
  }
  static init(cfg) {
    if (!cfg.oCfg.debug.masume)
      return;
    __privateSet$1(_Button, _procMasume4txt, (me, txt) => me.addChild(new Graphics().beginFill(8926088, 0.2).lineStyle(1, 8926088, 1).drawRect(txt.x, txt.y, txt.width, txt.height).endFill()));
    __privateSet$1(_Button, _procMasume4pic, (me, sp, w3, h2) => me.addChild(new Graphics().beginFill(8926088, 0.2).lineStyle(1, 8926088, 1).drawRect(sp.x, sp.y, w3, h2).endFill()));
  }
  setText(_text) {
  }
  destroy(_options) {
    this.evtMng.unButton(this);
    super.destroy();
  }
  makeDesignCast(_gdc) {
  }
  showDesignCast() {
    __privateGet$1(this, _idc).visible = true;
  }
  cvsResize() {
  }
  update_b_pic(fn, txt) {
    var _a3;
    const oName = JSON.parse((_a3 = txt.name) != null ? _a3 : "{}");
    if (__privateGet$1(this, _sp_b_pic))
      this.removeChild(__privateGet$1(this, _sp_b_pic));
    this.hArg.b_pic = oName.b_pic = fn;
    txt.name = JSON.stringify(oName);
    if (!fn)
      return;
    GrpLayer.csv2Sprites(fn, this, (sp) => __privateMethod$1(this, _loaded_b_pic, loaded_b_pic_fn).call(this, sp, txt), () => Layer.setBlendmode(this, this.hArg));
  }
  update_pic(fn, sp) {
    var _a3;
    const oName = JSON.parse((_a3 = sp.name) != null ? _a3 : "{}");
    if (__privateGet$1(this, _sp_pic))
      this.removeChild(__privateGet$1(this, _sp_pic));
    this.hArg.pic = oName.pic = fn;
    sp.name = JSON.stringify(oName);
    if (!fn)
      return;
    GrpLayer.csv2Sprites(fn, this, (sp2) => __privateMethod$1(this, _loaded_pic, loaded_pic_fn).call(this, sp2, oName), () => Layer.setBlendmode(this, this.hArg));
  }
};
let Button = _Button;
_procMasume4txt = /* @__PURE__ */ new WeakMap();
_procMasume4pic = /* @__PURE__ */ new WeakMap();
_rctBtnTxt = /* @__PURE__ */ new WeakMap();
_idc = /* @__PURE__ */ new WeakMap();
_sp_b_pic = /* @__PURE__ */ new WeakMap();
_sp_pic = /* @__PURE__ */ new WeakMap();
_loaded_b_pic = /* @__PURE__ */ new WeakSet();
loaded_b_pic_fn = function(sp, txt) {
  __privateSet$1(this, _sp_b_pic, sp);
  this.setChildIndex(sp, 0);
  sp.alpha = txt.alpha;
  sp.setTransform(txt.x, txt.y, 1, 1, txt.rotation, 0, 0, (sp.width - txt.width) / 2, (sp.height - txt.height) / 2);
  sp.name = txt.name;
};
_normal = /* @__PURE__ */ new WeakMap();
_hover = /* @__PURE__ */ new WeakMap();
_clicked = /* @__PURE__ */ new WeakMap();
_loaded_pic = /* @__PURE__ */ new WeakSet();
loaded_pic_fn = function(sp, oName) {
  var _a3;
  __privateSet$1(this, _sp_pic, sp);
  oName.alpha = sp.alpha = argChk_Num(this.hArg, "alpha", sp.alpha);
  __privateGet$1(this, _idc).setSp(sp);
  const w3 = sp.width / 3;
  const h2 = sp.height;
  const tx = sp.texture.baseTexture;
  const txNormal = new Texture(tx, new Rectangle(0, 0, w3, h2));
  const txClicked = new Texture(tx, new Rectangle(w3, 0, w3, h2));
  const txHover = new Texture(tx, new Rectangle(w3 * 2, 0, w3, h2));
  const normal = () => sp.texture = txNormal;
  normal();
  __privateSet$1(this, _normal, normal);
  __privateSet$1(this, _hover, () => {
    if (!this.canFocus())
      return false;
    sp.texture = txHover;
    return true;
  });
  __privateSet$1(this, _clicked, () => sp.texture = txClicked);
  if ("width" in this.hArg) {
    oName.width = uint(this.hArg.width);
    this.scale.x *= oName.width / w3;
  } else
    oName.width = w3;
  if ("height" in this.hArg) {
    oName.height = uint(this.hArg.height);
    this.scale.y *= oName.height / w3;
  } else
    oName.height = w3;
  sp.name = JSON.stringify(oName);
  __privateGet$1(_a3 = _Button, _procMasume4pic).call(_a3, this, sp, w3, h2);
};
Button.fontFamily = "'Hiragino Sans', 'Hiragino Kaku Gothic ProN', '\u6E38\u30B4\u30B7\u30C3\u30AF Medium', meiryo, sans-serif";
__privateAdd$1(Button, _procMasume4txt, (_me, _txt) => {
});
__privateAdd$1(Button, _procMasume4pic, (_me, _sp3, _w3, _h) => {
});
var __accessCheck = (obj, member, msg) => {
  if (!member.has(obj))
    throw TypeError("Cannot " + msg);
};
var __privateGet = (obj, member, getter) => {
  __accessCheck(obj, member, "read from private field");
  return getter ? getter.call(obj) : member.get(obj);
};
var __privateAdd = (obj, member, value) => {
  if (member.has(obj))
    throw TypeError("Cannot add the same private member more than once");
  member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
};
var __privateSet = (obj, member, value, setter) => {
  __accessCheck(obj, member, "write to private field");
  setter ? setter.call(obj, value) : member.set(obj, value);
  return value;
};
var __privateMethod = (obj, member, method) => {
  __accessCheck(obj, member, "access private method");
  return method;
};
var _cfg, _val, _recText, _isPageFore, _ch_in_style, ch_in_style_fn, _ch_out_style, ch_out_style_fn, _main, _evtMng, _sys, _doAutoWc, _hAutoWc, _autowc, autowc_fn, _b_color, _b_alpha, _b_alpha_isfixed, _b_do, _b_pic, _txs, _rbSpl, _cntBtn, _set_ch_in, set_ch_in_fn, _$ch_in_style, _ch_in_join, _set_ch_out, set_ch_out_fn, _$ch_out_style, _drawBack, drawBack_fn, _setFfs, setFfs_fn, _ffs, _fncFFSStyle, _fncFFSSpan, _strNoFFS, _regNoFFS, _ruby_pd, _r_align, _mkStyle_r_align4ff, mkStyle_r_align4ff_fn, _needGoTxt, _putCh, _tagCh_sub, tagCh_sub_fn, _cumDelay, _firstCh, _aSpan, _aSpan_bk, _aSpan_link, _hSpanBk, _beginSpan, beginSpan_fn, _autoCloseSpan, autoCloseSpan_fn, _page_text;
const _TxtLayer = class extends Layer {
  constructor() {
    super();
    __privateAdd(this, _set_ch_in);
    __privateAdd(this, _set_ch_out);
    __privateAdd(this, _drawBack);
    __privateAdd(this, _setFfs);
    __privateAdd(this, _mkStyle_r_align4ff);
    __privateAdd(this, _tagCh_sub);
    __privateAdd(this, _beginSpan);
    __privateAdd(this, _autoCloseSpan);
    __privateAdd(this, _b_color, 0);
    __privateAdd(this, _b_alpha, 0);
    __privateAdd(this, _b_alpha_isfixed, false);
    __privateAdd(this, _b_do, void 0);
    __privateAdd(this, _b_pic, "");
    __privateAdd(this, _txs, new TxtStage(this.spLay, () => this.canFocus(), __privateGet(_TxtLayer, _sys)));
    __privateAdd(this, _rbSpl, new RubySpliter());
    __privateAdd(this, _cntBtn, new Container());
    __privateAdd(this, _$ch_in_style, "");
    __privateAdd(this, _ch_in_join, true);
    __privateAdd(this, _$ch_out_style, "");
    __privateAdd(this, _ffs, "");
    __privateAdd(this, _fncFFSStyle, (_ch2) => "");
    __privateAdd(this, _fncFFSSpan, (ch) => ch);
    __privateAdd(this, _strNoFFS, "");
    __privateAdd(this, _regNoFFS, new RegExp("[\u3000]"));
    this.isCur = false;
    __privateAdd(this, _ruby_pd, () => "");
    __privateAdd(this, _r_align, "");
    __privateAdd(this, _needGoTxt, false);
    __privateAdd(this, _putCh, (ch, ruby) => {
      var _a4, _b3, _c3, _d2, _e, _f, _g, _h;
      var _a3;
      if (__privateGet(_TxtLayer, _cfg).oCfg.debug.putCh)
        console.log(`\u{1F58A} \u6587\u5B57\u8868\u793A text:\`${ch}\` ruby:\`${ruby}\` name:\`${this.name_}\``);
      const a_ruby = ruby.split("\uFF5C");
      let add_htm = "";
      const isSkip = __privateGet(_TxtLayer, _evtMng).isSkippingByKeyDown();
      switch (a_ruby.length) {
        case 1:
          __privateSet(this, _needGoTxt, true);
          if (ch === "\n") {
            if (__privateGet(this, _aSpan_bk)) {
              add_htm = __privateGet(this, _aSpan_bk).slice(-1)[0];
              __privateMethod(this, _autoCloseSpan, autoCloseSpan_fn).call(this);
              __privateGet(this, _aSpan).push(_TxtLayer.rec("<br/>"));
              __privateGet(this, _aSpan).push(add_htm);
              __privateSet(this, _aSpan_bk, __privateGet(this, _aSpan));
              __privateSet(this, _aSpan, []);
              return;
            }
            if (__privateGet(this, _firstCh)) {
              __privateSet(this, _firstCh, false);
              add_htm = "<ruby>\u3000<rt>\u3000</rt></ruby><br/>";
            } else
              add_htm = "<br/>";
            break;
          }
          if (__privateGet(this, _firstCh)) {
            __privateSet(this, _firstCh, false);
            if (ruby === "")
              ruby = "\u3000";
          }
          add_htm = __privateMethod(this, _tagCh_sub, tagCh_sub_fn).call(this, ch, ruby, isSkip, __privateGet(this, _r_align));
          break;
        case 2:
          switch (a_ruby[0]) {
            case "start":
            case "left":
            case "center":
            case "right":
            case "justify":
            case "121":
            case "even":
            case "1ruby":
              __privateSet(this, _firstCh, false);
              __privateSet(this, _needGoTxt, true);
              add_htm = __privateMethod(this, _tagCh_sub, tagCh_sub_fn).call(this, ch, a_ruby[1], isSkip, a_ruby[0]);
              break;
            case "gotxt": {
              __privateMethod(this, _autoCloseSpan, autoCloseSpan_fn).call(this);
              if (this.isCur)
                __privateGet(_a3 = _TxtLayer, _recText).call(_a3, __privateGet(this, _aSpan).join("").replace(/^<ruby><rt><\/rt><\/ruby>(<br\/>)+/, "").replace(/style='(anim\S+ \S+?;\s*)+/g, `style='`).replace(/( style=''| data-(add|arg|cmd)='.+?'|\n+|\t+)/g, "").replace(/class='sn_ch .+?'/g, `class='sn_ch'`).replaceAll(`class='offrec'`, `style='display: none;'`).replaceAll("`", "\\`"));
              if (!__privateGet(this, _needGoTxt))
                return;
              __privateGet(this, _txs).goTxt(__privateGet(this, _aSpan));
              __privateSet(this, _needGoTxt, false);
              __privateSet(this, _cumDelay, 0);
              return;
            }
            case "add":
              {
                const o = JSON.parse(a_ruby[1]);
                (_a4 = o.style) != null ? _a4 : o.style = "";
                __privateMethod(this, _beginSpan, beginSpan_fn).call(this, o);
                if (__privateGet(this, _aSpan_bk))
                  __privateMethod(this, _autoCloseSpan, autoCloseSpan_fn).call(this);
                else {
                  if (isSkip)
                    __privateSet(this, _cumDelay, 0);
                  const wait = Number((_b3 = o.wait) != null ? _b3 : -1);
                  const sn_ch = wait === 0 ? "" : ` sn_ch_in_${__privateGet(this, _$ch_in_style)}`;
                  const ad = wait < 0 ? "" : ` animation-duration: ${wait}ms;`;
                  __privateGet(this, _aSpan).push(`<span class='sn_ch${sn_ch}' style='animation-delay: ${__privateGet(this, _cumDelay)}ms;${ad} ${o.style}' data-add='${JSON.stringify(o)}'>`);
                }
                __privateSet(this, _aSpan_bk, __privateGet(this, _aSpan));
                __privateSet(this, _aSpan, []);
              }
              return;
            case "add_close":
              __privateMethod(this, _autoCloseSpan, autoCloseSpan_fn).call(this);
              return;
            case "grp":
              __privateSet(this, _needGoTxt, true);
              {
                if (isSkip)
                  __privateSet(this, _cumDelay, 0);
                const arg = (a_ruby[1] ? a_ruby[1].slice(0, -1) + "," : `{`) + `"delay": ${__privateGet(this, _cumDelay)}}`;
                if (__privateGet(this, _ch_in_join))
                  __privateSet(this, _cumDelay, __privateGet(this, _cumDelay) + (__privateGet(_TxtLayer, _doAutoWc) ? 0 : LayerMng.msecChWait));
                const o = JSON.parse(arg);
                (_c3 = o.style) != null ? _c3 : o.style = "";
                if (!("id" in o))
                  o.id = __privateGet(this, _aSpan).length;
                if (o.id === "break") {
                  __privateGet(this, _txs).dispBreak(o.pic);
                  return;
                }
                add_htm = `<span data-cmd='grp' data-id='${o.id}' data-arg='${arg}'`;
                const wait = Number((_d2 = o.wait) != null ? _d2 : -1);
                const sn_ch = wait === 0 ? "" : ` sn_ch_in_${__privateGet(this, _$ch_in_style)}`;
                const ad = wait < 0 ? "" : ` animation-duration: ${wait}ms;`;
                add_htm += ` class='sn_ch${sn_ch}' style='animation-delay: ${__privateGet(this, _cumDelay)}ms;${ad} ${o.style}' data-add='{"ch_in_style":"${__privateGet(this, _$ch_in_style)}", "ch_out_style":"${__privateGet(this, _$ch_out_style)}"}'>\u3000</span>`;
                if (__privateGet(this, _firstCh)) {
                  __privateSet(this, _firstCh, false);
                  add_htm = `<ruby>${add_htm}<rt>\u3000</rt></ruby>`;
                }
                if (__privateGet(this, _aSpan).slice(-1)[0] === add_htm)
                  return;
              }
              break;
            case "del":
              const id_del = a_ruby[1];
              if (id_del !== "break")
                throw "\u6587\u5B57\u30EC\u30A4\u30E4del\u30B3\u30DE\u30F3\u30C9\u306F\u3001\u73FE\u5728id=break\u306E\u307F\u30B5\u30DD\u30FC\u30C8\u3057\u307E\u3059";
              TxtStage.delBreak();
              return;
            case "span":
              __privateMethod(this, _autoCloseSpan, autoCloseSpan_fn).call(this);
              __privateSet(this, _needGoTxt, true);
              {
                const o = JSON.parse(a_ruby[1]);
                __privateMethod(this, _beginSpan, beginSpan_fn).call(this, o);
                if (!o.style)
                  return;
                if (isSkip)
                  __privateSet(this, _cumDelay, 0);
                const wait = Number((_e = o.wait) != null ? _e : -1);
                const sn_ch = wait === 0 ? "" : ` sn_ch_in_${__privateGet(this, _$ch_in_style)}`;
                const ad = wait < 0 ? "" : ` animation-duration: ${wait}ms;`;
                __privateGet(this, _aSpan).push(`<span class='sn_ch${sn_ch}' style='animation-delay: ${__privateGet(this, _cumDelay)}ms;${ad} ${o.style}' data-add='{"ch_in_style":"${__privateGet(this, _$ch_in_style)}", "ch_out_style":"${__privateGet(this, _$ch_out_style)}"}'>`);
                __privateSet(this, _aSpan_bk, __privateGet(this, _aSpan));
                __privateSet(this, _aSpan, []);
              }
              return;
            case "link":
              __privateMethod(this, _autoCloseSpan, autoCloseSpan_fn).call(this);
              __privateSet(this, _needGoTxt, true);
              {
                const o = JSON.parse(a_ruby[1]);
                (_f = o.style) != null ? _f : o.style = "";
                __privateMethod(this, _beginSpan, beginSpan_fn).call(this, o);
                if (isSkip)
                  __privateSet(this, _cumDelay, 0);
                const wait = Number((_g = o.wait) != null ? _g : -1);
                const sn_ch = wait === 0 ? "" : ` sn_ch_in_${__privateGet(this, _$ch_in_style)}`;
                const ad = wait < 0 ? "" : ` animation-duration: ${wait}ms;`;
                __privateSet(this, _aSpan_link, ` data-cmd='link' data-arg='${a_ruby[1]}'`);
                __privateGet(this, _aSpan).push(`<span${__privateGet(this, _aSpan_link)} class='sn_ch${sn_ch}' style='animation-delay: ${__privateGet(this, _cumDelay)}ms;${ad} ${o.style}' data-add='{"ch_in_style":"${__privateGet(this, _$ch_in_style)}", "ch_out_style":"${__privateGet(this, _$ch_out_style)}"}'>`);
                __privateSet(this, _aSpan_bk, __privateGet(this, _aSpan));
                __privateSet(this, _aSpan, []);
              }
              return;
            case "endlink":
              __privateSet(this, _needGoTxt, true);
              if (__privateGet(this, _aSpan_bk))
                __privateSet(this, _aSpan, __privateGet(this, _aSpan).map((v2) => v2.replace(/ data-cmd='linkrsv'/, __privateGet(this, _aSpan_link))));
              __privateMethod(this, _autoCloseSpan, autoCloseSpan_fn).call(this);
              return;
            default:
              __privateSet(this, _needGoTxt, true);
              add_htm = __privateMethod(this, _tagCh_sub, tagCh_sub_fn).call(this, ch, ruby, isSkip, __privateGet(this, _r_align));
          }
          break;
        case 3:
          __privateSet(this, _firstCh, false);
          __privateSet(this, _needGoTxt, true);
          switch (a_ruby[0]) {
            case "tcy":
              {
                if (__privateGet(_TxtLayer, _val).doRecLog())
                  __privateSet(this, _page_text, __privateGet(this, _page_text) + (ch + (ruby ? `\u300A${ruby}\u300B` : "")));
                const tx = a_ruby[1];
                const id_tcy = tx.length > 1 ? __privateGet(this, _aSpan).length + 1 : "";
                const rb = CmnLib.isSafari ? a_ruby[2].replace(/[A-Za-z0-9]/g, (s2) => String.fromCharCode(s2.charCodeAt(0) + 65248)) : a_ruby[2];
                if (isSkip)
                  __privateSet(this, _cumDelay, 0);
                const rs = this.mkStyle_r_align(tx, rb, __privateGet(this, _r_align));
                const da = ` data-add='{"ch_in_style":"${__privateGet(this, _$ch_in_style)}", "ch_out_style":"${__privateGet(this, _$ch_out_style)}"}'`;
                const st = `<span data-tcy='${id_tcy}' style='
text-combine-upright: all;
-webkit-text-combine: horizontal;
${__privateGet(this, _fncFFSStyle).call(this, tx)}`;
                add_htm = rb ? __privateGet(this, _aSpan_bk) ? `<ruby>${st}'${da} data-cmd='linkrsv'>${tx}</span>
							<rt${rs}>${rb}</rt></ruby>` : `<span class='sn_ch sn_ch_in_${__privateGet(this, _$ch_in_style)}' style='animation-delay: ${__privateGet(this, _cumDelay)}ms;'>
							<ruby>${st}'${da}>${tx}</span>
							<rt${rs}>${rb}</rt></ruby>
						</span>` : __privateGet(this, _aSpan_bk) ? `${st}'${da} data-cmd='linkrsv'>${tx}</span>` : `${st}
							animation-delay: ${__privateGet(this, _cumDelay)}ms;
							height: 1em;
						' class='sn_ch sn_ch_in_${__privateGet(this, _$ch_in_style)}'${da}>${tx}</span>`;
                if (__privateGet(this, _ch_in_join))
                  __privateSet(this, _cumDelay, __privateGet(this, _cumDelay) + (__privateGet(_TxtLayer, _doAutoWc) ? (_h = __privateGet(_TxtLayer, _hAutoWc)[ch.charAt(0)]) != null ? _h : 0 : LayerMng.msecChWait));
              }
              break;
            default:
              throw `\u7570\u5E38\u306A\u5024\u3067\u3059 putCh(text: ${ch}, ruby: ${ruby})`;
          }
          break;
      }
      __privateGet(this, _aSpan).push(_TxtLayer.rec(add_htm));
    });
    __privateAdd(this, _cumDelay, 0);
    __privateAdd(this, _firstCh, true);
    __privateAdd(this, _aSpan, []);
    __privateAdd(this, _aSpan_bk, void 0);
    __privateAdd(this, _aSpan_link, "");
    __privateAdd(this, _hSpanBk, {
      ch_in_style: "",
      ch_out_style: "",
      r_align: ""
    });
    this.click = () => {
      if (!this.spLay.interactiveChildren || !this.spLay.visible)
        return true;
      return __privateGet(this, _txs).skipChIn();
    };
    __privateAdd(this, _page_text, "");
    this.addButton = (hArg) => new Promise((re2) => {
      hArg.key = `btn=[${__privateGet(this, _cntBtn).children.length}] ` + this.name_;
      hArg[":id_tag"] = hArg.key.slice(0, -7);
      argChk_Boolean(hArg, "hint_tate", __privateGet(this, _txs).tategaki);
      const btn = new Button(hArg, __privateGet(_TxtLayer, _evtMng), () => re2(), () => this.canFocus());
      btn.name = JSON.stringify(hArg).replaceAll('"', "'");
      __privateGet(this, _cntBtn).addChild(btn);
    });
    this.record = () => Object.assign(super.record(), {
      enabled: this.enabled,
      r_align: __privateGet(this, _r_align),
      b_do: __privateGet(this, _b_do) === void 0 ? void 0 : __privateGet(this, _b_do) instanceof Sprite ? "Sprite" : "Graphics",
      b_pic: __privateGet(this, _b_pic),
      b_color: __privateGet(this, _b_color),
      b_alpha: __privateGet(this, _b_alpha),
      b_alpha_isfixed: __privateGet(this, _b_alpha_isfixed),
      ffs: __privateGet(this, _ffs),
      txs: __privateGet(this, _txs).record(),
      strNoFFS: __privateGet(this, _strNoFFS),
      btns: __privateGet(this, _cntBtn).children.map((btn) => btn.name)
    });
    this.spLay.addChild(__privateGet(this, _txs));
    __privateGet(this, _rbSpl).init(__privateGet(this, _putCh));
    this.spLay.addChild(__privateGet(this, _cntBtn));
    __privateGet(this, _cntBtn).name = "cntBtn";
    const padding = 16;
    this.lay({ style: `width: ${CmnLib.stageW}px; height: ${CmnLib.stageH}px; font-family: 'Hiragino Sans', 'Hiragino Kaku Gothic ProN', '\u6E38\u30B4\u30B7\u30C3\u30AF Medium', meiryo, sans-serif; color: white; font-size: 24px; line-height: 1.5; padding: ${padding}px;`, in_style: "default", out_style: "default", back_clear: "true" });
  }
  static init(cfg, hTag, val, recText, isPageFore, appPixi) {
    var _a3, _b3;
    __privateSet(_TxtLayer, _cfg, cfg);
    TxtStage.init(cfg, appPixi);
    __privateSet(_TxtLayer, _val, val);
    __privateSet(_TxtLayer, _recText, recText);
    __privateSet(_TxtLayer, _isPageFore, isPageFore);
    val.setDoRecProc(_TxtLayer.chgDoRec);
    hTag.autowc = (o) => {
      var _a22;
      return __privateMethod(_a22 = _TxtLayer, _autowc, autowc_fn).call(_a22, o);
    };
    hTag.autowc({ enabled: false, text: "", time: 0 });
    hTag.ch_in_style = (o) => {
      var _a22;
      return __privateMethod(_a22 = _TxtLayer, _ch_in_style, ch_in_style_fn).call(_a22, o);
    };
    hTag.ch_out_style = (o) => {
      var _a22;
      return __privateMethod(_a22 = _TxtLayer, _ch_out_style, ch_out_style_fn).call(_a22, o);
    };
    TxtStage.initChStyle();
    initStyle();
    let font = "";
    cfg.matchPath(".+", Config.EXT_FONT).forEach((o) => {
      for (const key in o)
        font += `
@font-face {
	font-family: '${o[key]}';
	src: url('${__privateGet(this, _cfg).searchPath(o[key], Config.EXT_FONT)}');
}
`;
    });
    font += `
.sn_tx {
	pointer-events: none;
	user-select: none;
	-webkit-touch-callout: none;
	box-sizing: border-box;
}
.sn_ch {
	position: relative;
	display: inline-block;
}
`;
    addStyle(font);
    __privateMethod(_a3 = _TxtLayer, _ch_in_style, ch_in_style_fn).call(_a3, {
      name: "default",
      wait: 500,
      alpha: 0,
      x: "=0.3",
      y: "=0",
      scale_x: 1,
      scale_y: 1,
      rotate: 0,
      join: true,
      ease: "ease-out"
    });
    __privateMethod(_b3 = _TxtLayer, _ch_out_style, ch_out_style_fn).call(_b3, {
      name: "default",
      wait: 0,
      alpha: 0,
      x: "=0",
      y: "=0",
      scale_x: 1,
      scale_y: 1,
      rotate: 0,
      join: false,
      ease: "ease-out"
    });
  }
  static setEvtMng(main2, evtMng, sys) {
    __privateSet(_TxtLayer, _main, main2);
    __privateSet(_TxtLayer, _evtMng, evtMng);
    __privateSet(_TxtLayer, _sys, sys);
    TxtStage.setEvtMng(evtMng);
  }
  destroy() {
    if (__privateGet(this, _b_do)) {
      this.spLay.removeChild(__privateGet(this, _b_do)).destroy();
      __privateSet(this, _b_do, void 0);
    }
    this.clearText();
    __privateGet(this, _txs).destroy();
  }
  static destroy() {
    __privateSet(_TxtLayer, _doAutoWc, false);
    __privateSet(_TxtLayer, _hAutoWc, {});
    _TxtLayer.rec = (tx) => tx;
  }
  set name(nm) {
    this.name_ = nm;
    __privateGet(this, _txs).name = nm;
  }
  get name() {
    return this.name_;
  }
  cvsResize() {
    __privateGet(this, _txs).cvsResize();
  }
  cvsResizeChildren() {
    __privateGet(this, _cntBtn).children.forEach((b2) => b2.cvsResize());
  }
  lay(hArg) {
    var _a3;
    super.lay(hArg);
    Layer.setXY(this.spLay, hArg, this.spLay);
    hArg[":id_tag"] = this.name_.slice(0, -7);
    RubySpliter.setting(hArg);
    __privateMethod(this, _setFfs, setFfs_fn).call(this, hArg);
    __privateGet(this, _txs).lay(hArg);
    if ("r_align" in hArg)
      __privateSet(this, _r_align, (_a3 = hArg.r_align) != null ? _a3 : "");
    __privateSet(this, _ruby_pd, CmnLib.isSafari ? __privateGet(this, _txs).tategaki ? (v2, l2) => `text-align: start; height: ${l2}em; padding-top: ${v2}; padding-bottom: ${v2};` : (v2, l2) => `text-align: start; width: ${l2}em; padding-left: ${v2}; padding-right: ${v2};` : __privateGet(this, _txs).tategaki ? (v2) => `text-align: justify; text-align-last: justify; padding-top: ${v2}; padding-bottom: ${v2};` : (v2) => `text-align: justify; text-align-last: justify; padding-left: ${v2}; padding-right: ${v2};`);
    if (CmnLib.isFirefox)
      this.mkStyle_r_align = __privateMethod(this, _mkStyle_r_align4ff, mkStyle_r_align4ff_fn);
    if ("alpha" in hArg)
      __privateGet(this, _cntBtn).children.forEach((e) => e.alpha = this.spLay.alpha);
    __privateMethod(this, _set_ch_in, set_ch_in_fn).call(this, hArg);
    __privateMethod(this, _set_ch_out, set_ch_out_fn).call(this, hArg);
    return __privateMethod(this, _drawBack, drawBack_fn).call(this, hArg, (isStop) => {
      if (isStop)
        __privateGet(_TxtLayer, _main).resume();
    });
  }
  get width() {
    return __privateGet(this, _txs).getWidth;
  }
  get height() {
    return __privateGet(this, _txs).getHeight;
  }
  chgBackAlpha(g_alpha) {
    const alpha = __privateGet(this, _b_alpha_isfixed) ? __privateGet(this, _b_alpha) : g_alpha * __privateGet(this, _b_alpha);
    if (__privateGet(this, _b_do) instanceof Graphics) {
      if (__privateGet(this, _b_do)) {
        this.spLay.removeChild(__privateGet(this, _b_do));
        __privateGet(this, _b_do).destroy();
      }
      this.spLay.addChildAt(__privateSet(this, _b_do, new Graphics()).beginFill(__privateGet(this, _b_color)).lineStyle(void 0).drawRect(0, 0, __privateGet(this, _txs).getWidth, __privateGet(this, _txs).getHeight).endFill(), 0);
      __privateGet(this, _b_do).name = "back(color)";
    }
    if (__privateGet(this, _b_do)) {
      __privateGet(this, _b_do).visible = alpha > 0;
      __privateGet(this, _b_do).alpha = alpha;
    }
  }
  static chgDoRec(doRec) {
    _TxtLayer.rec = doRec ? (tx) => tx : (tx) => `<span class='offrec'>${tx}</span>`;
  }
  mkStyle_r_align(ch, rb, r_align) {
    if (!r_align)
      return "";
    const len = ch.length * 2;
    if (len - rb.length < 0)
      return ` style='text-align: ${r_align};'`;
    let st = "";
    switch (r_align) {
      case "justify":
        st = __privateGet(this, _ruby_pd).call(this, "0", len);
        break;
      case "121":
        st = __privateGet(this, _ruby_pd).call(this, `calc(${(len - rb.length) / (rb.length * 2)}em)`, len);
        break;
      case "even":
        st = __privateGet(this, _ruby_pd).call(this, `calc(${(len - rb.length) / (rb.length + 1)}em)`, len);
        break;
      case "1ruby":
        st = __privateGet(this, _ruby_pd).call(this, "1em", len);
        break;
      default:
        st = `text-align: ${r_align};`;
    }
    return ` style='${st}'`;
  }
  tagCh(text2) {
    __privateGet(this, _rbSpl).putTxt(text2);
  }
  clearText() {
    var _a3;
    this.spLay.addChild(__privateSet(this, _txs, __privateGet(this, _txs).reNew()));
    __privateSet(this, _cumDelay, 0);
    __privateSet(this, _firstCh, true);
    __privateSet(this, _aSpan, []);
    __privateSet(this, _aSpan_bk, void 0);
    __privateSet(this, _page_text, "");
    __privateGet(_a3 = _TxtLayer, _recText).call(_a3, "", true);
  }
  get pageText() {
    return __privateGet(this, _page_text).replace("\u300A\u3000\u300B", "");
  }
  get enabled() {
    return this.spLay.interactiveChildren;
  }
  set enabled(e) {
    this.spLay.interactiveChildren = e;
  }
  canFocus() {
    var _a4;
    var _a3;
    return ((_a4 = this.spLay.interactiveChildren) != null ? _a4 : false) && this.spLay.visible && __privateGet(_a3 = _TxtLayer, _isPageFore).call(_a3, this);
  }
  clearLay(hArg) {
    super.clearLay(hArg);
    this.clearText();
    __privateGet(this, _cntBtn).removeChildren().forEach((c2) => c2.destroy());
  }
  playback(hLay, aPrm) {
    super.playback(hLay, aPrm);
    this.enabled = hLay.enabled;
    __privateSet(this, _r_align, hLay.r_align);
    this.cvsResize();
    __privateMethod(this, _setFfs, setFfs_fn).call(this, hLay);
    __privateGet(this, _txs).playback(hLay.txs);
    __privateSet(this, _b_alpha, hLay.b_alpha);
    __privateSet(this, _b_alpha_isfixed, hLay.b_alpha_isfixed);
    aPrm.push(new Promise((re2) => {
      if (!__privateMethod(this, _drawBack, drawBack_fn).call(this, hLay.b_do ? hLay.b_do === "Sprite" ? { b_pic: hLay.b_pic } : { b_color: hLay.b_color } : { b_pic: "" }, (isStop) => {
        if (isStop)
          re2();
      }))
        re2();
    }));
    const aBtn = hLay.btns;
    aPrm = aPrm.concat(aBtn.map((v2) => this.addButton(JSON.parse(v2.replaceAll(`'`, '"')))));
  }
  snapshot(rnd, re2) {
    rnd.render(this.spLay, { clear: false });
    __privateGet(this, _txs).snapshot(rnd, re2);
  }
  snapshot_end() {
    __privateGet(this, _txs).snapshot_end();
  }
  makeDesignCast(gdc) {
    if (!this.spLay.visible)
      return;
    __privateGet(this, _txs).makeDesignCast(gdc);
  }
  makeDesignCastChildren(gdc) {
    if (!this.spLay.visible)
      return;
    __privateGet(this, _cntBtn).children.forEach((btn) => btn.makeDesignCast(gdc));
  }
  showDesignCast() {
    __privateGet(this, _txs).showDesignCast();
  }
  showDesignCastChildren() {
    __privateGet(this, _cntBtn).children.forEach((btn) => btn.showDesignCast());
  }
  dump() {
    __privateGet(this, _putCh).call(this, "", "gotxt\uFF5C");
    return super.dump() + `, "enabled":"${this.enabled}", ${__privateGet(this, _txs).dump()}, "b_pic":"${__privateGet(this, _b_pic)}", "b_color":"${__privateGet(this, _b_color)}", "b_alpha":${__privateGet(this, _b_alpha)}, "b_alpha_isfixed":"${__privateGet(this, _b_alpha_isfixed)}", "width":${__privateGet(this, _txs).getWidth}, "height":${__privateGet(this, _txs).getHeight}, "pixi_obj":[${this.spLay.children.map((e) => `{"class":"${e instanceof Sprite ? "Sprite" : e instanceof Graphics ? "Graphics" : e instanceof Container ? "Container" : "?"}", "name":"${e.name}", "alpha":${e.alpha}, "x":${e.x}, "y":${e.y}, "visible":"${e.visible}"}`).join(",")}], "button":[${__privateGet(this, _cntBtn).children.map((d2) => {
      var _a3;
      return (_a3 = d2.children[0].name) != null ? _a3 : "{}";
    }).join(",")}]`;
  }
};
let TxtLayer = _TxtLayer;
_cfg = /* @__PURE__ */ new WeakMap();
_val = /* @__PURE__ */ new WeakMap();
_recText = /* @__PURE__ */ new WeakMap();
_isPageFore = /* @__PURE__ */ new WeakMap();
_ch_in_style = /* @__PURE__ */ new WeakSet();
ch_in_style_fn = function(hArg) {
  const o = TxtStage.ch_in_style(hArg);
  const x2 = o.x.charAt(0) === "=" ? `${o.nx * 100}%` : `${o.nx}px`;
  const y2 = o.y.charAt(0) === "=" ? `${o.ny * 100}%` : `${o.ny}px`;
  const { name: name2 } = hArg;
  addStyle(`
.sn_ch_in_${name2} {
	position: relative;
	display: inline-block;
}
.go_ch_in_${name2} {
	opacity: ${o.alpha};
	position: relative;
	display: inline-block;
	animation: sn_ch_in_${name2} ${o.wait}ms ${o.ease} 0s both;
}
@keyframes sn_ch_in_${name2} {
	from {transform: rotate(${o.rotate}deg) scale(${o.scale_x}, ${o.scale_y}) translate(${x2}, ${y2});}
	to {opacity: 1; transform: none;}
}
`);
  return false;
};
_ch_out_style = /* @__PURE__ */ new WeakSet();
ch_out_style_fn = function(hArg) {
  const o = TxtStage.ch_out_style(hArg);
  const x2 = o.x.charAt(0) === "=" ? `${o.nx * 100}%` : `${o.nx}px`;
  const y2 = o.y.charAt(0) === "=" ? `${o.ny * 100}%` : `${o.ny}px`;
  const { name: name2 } = hArg;
  addStyle(`
.go_ch_out_${name2} {
	position: relative;
	display: inline-block;
	animation: go_ch_out_${name2} ${o.wait}ms ${o.ease} 0s both;
}
@keyframes go_ch_out_${name2} {
	to {
		opacity: ${o.alpha};
		transform: rotate(${o.rotate}deg) scale(${o.scale_x}, ${o.scale_y}) translate(${x2}, ${y2});
	}
`);
  return false;
};
_main = /* @__PURE__ */ new WeakMap();
_evtMng = /* @__PURE__ */ new WeakMap();
_sys = /* @__PURE__ */ new WeakMap();
_doAutoWc = /* @__PURE__ */ new WeakMap();
_hAutoWc = /* @__PURE__ */ new WeakMap();
_autowc = /* @__PURE__ */ new WeakSet();
autowc_fn = function(hArg) {
  __privateSet(_TxtLayer, _doAutoWc, argChk_Boolean(hArg, "enabled", __privateGet(_TxtLayer, _doAutoWc)));
  __privateGet(_TxtLayer, _val).setVal_Nochk("save", "const.sn.autowc.enabled", __privateGet(_TxtLayer, _doAutoWc));
  const { text: text2 } = hArg;
  if ("text" in hArg !== "time" in hArg)
    throw "[autowc] text\u3068time\u306F\u540C\u6642\u6307\u5B9A\u5FC5\u9808\u3067\u3059";
  __privateGet(_TxtLayer, _val).setVal_Nochk("save", "const.sn.autowc.text", text2);
  if (!text2) {
    __privateGet(_TxtLayer, _val).setVal_Nochk("save", "const.sn.autowc.time", "");
    return false;
  }
  const len = text2.length;
  if (__privateGet(_TxtLayer, _doAutoWc) && len === 0)
    throw '[autowc] enabled === false \u304B\u3064 text === "" \u306F\u8A31\u3055\u308C\u307E\u305B\u3093';
  const a2 = String(hArg.time).split(",");
  if (a2.length !== len)
    throw "[autowc] text\u6587\u5B57\u6570\u3068time\u306B\u8A18\u8FF0\u3055\u308C\u305F\u5F85\u3061\u6642\u9593\uFF08\u30B3\u30F3\u30DE\u533A\u5207\u308A\uFF09\u306F\u540C\u6570\u306B\u3057\u3066\u4E0B\u3055\u3044";
  __privateSet(_TxtLayer, _hAutoWc, {});
  a2.forEach((v2, i2) => __privateGet(_TxtLayer, _hAutoWc)[text2[i2]] = uint(v2));
  __privateGet(_TxtLayer, _val).setVal_Nochk("save", "const.sn.autowc.time", hArg.time);
  return false;
};
_b_color = /* @__PURE__ */ new WeakMap();
_b_alpha = /* @__PURE__ */ new WeakMap();
_b_alpha_isfixed = /* @__PURE__ */ new WeakMap();
_b_do = /* @__PURE__ */ new WeakMap();
_b_pic = /* @__PURE__ */ new WeakMap();
_txs = /* @__PURE__ */ new WeakMap();
_rbSpl = /* @__PURE__ */ new WeakMap();
_cntBtn = /* @__PURE__ */ new WeakMap();
_set_ch_in = /* @__PURE__ */ new WeakSet();
set_ch_in_fn = function(hArg) {
  const { in_style } = hArg;
  if (!in_style)
    return;
  const cis = TxtStage.getChInStyle(in_style);
  if (!cis)
    throw `\u5B58\u5728\u3057\u306A\u3044in_style\u3010${in_style}\u3011\u3067\u3059`;
  __privateSet(this, _$ch_in_style, in_style);
  __privateSet(this, _ch_in_join, cis.join);
};
_$ch_in_style = /* @__PURE__ */ new WeakMap();
_ch_in_join = /* @__PURE__ */ new WeakMap();
_set_ch_out = /* @__PURE__ */ new WeakSet();
set_ch_out_fn = function(hArg) {
  const { out_style } = hArg;
  if (!out_style)
    return;
  const cos = TxtStage.getChOutStyle(out_style);
  if (!cos)
    throw `\u5B58\u5728\u3057\u306A\u3044out_style\u3010${out_style}\u3011\u3067\u3059`;
  __privateSet(this, _$ch_out_style, out_style);
};
_$ch_out_style = /* @__PURE__ */ new WeakMap();
_drawBack = /* @__PURE__ */ new WeakSet();
drawBack_fn = function(hArg, fncComp) {
  if ("back_clear" in hArg) {
    if (argChk_Boolean(hArg, "back_clear", false)) {
      __privateSet(this, _b_color, 0);
      __privateSet(this, _b_alpha, 0);
      __privateSet(this, _b_alpha_isfixed, false);
      __privateSet(this, _b_pic, "");
    }
    fncComp(false);
    return false;
  }
  __privateSet(this, _b_alpha, argChk_Num(hArg, "b_alpha", __privateGet(this, _b_alpha)));
  __privateSet(this, _b_alpha_isfixed, argChk_Boolean(hArg, "b_alpha_isfixed", __privateGet(this, _b_alpha_isfixed)));
  const alpha = (__privateGet(this, _b_alpha_isfixed) ? 1 : Number(__privateGet(_TxtLayer, _val).getVal("sys:TextLayer.Back.Alpha"))) * __privateGet(this, _b_alpha);
  if (hArg.b_pic) {
    if (__privateGet(this, _b_pic) !== hArg.b_pic) {
      __privateSet(this, _b_pic, hArg.b_pic);
      if (__privateGet(this, _b_do)) {
        this.spLay.removeChild(__privateGet(this, _b_do));
        __privateGet(this, _b_do).destroy();
      }
      return GrpLayer.csv2Sprites(__privateGet(this, _b_pic), this.spLay, (sp) => {
        __privateSet(this, _b_do, sp);
        sp.name = "back(pic)";
        sp.visible = alpha > 0;
        sp.alpha = alpha;
        __privateGet(this, _txs).setSize(sp.width, sp.height);
        this.spLay.setChildIndex(sp, 0);
        fncComp(true);
      });
    }
  } else if ("b_color" in hArg) {
    __privateSet(this, _b_color, argChk_Color(hArg, "b_color", 0));
    if (__privateGet(this, _b_do)) {
      this.spLay.removeChild(__privateGet(this, _b_do));
      __privateGet(this, _b_do).destroy();
    }
    __privateSet(this, _b_pic, "");
    this.spLay.addChildAt(__privateSet(this, _b_do, new Graphics()).beginFill(__privateGet(this, _b_color)).lineStyle(void 0).drawRect(0, 0, __privateGet(this, _txs).getWidth, __privateGet(this, _txs).getHeight).endFill(), 0);
    __privateGet(this, _b_do).name = "back(color)";
  }
  if (__privateGet(this, _b_do)) {
    __privateGet(this, _b_do).visible = alpha > 0;
    __privateGet(this, _b_do).alpha = alpha;
  }
  fncComp(false);
  return false;
};
_setFfs = /* @__PURE__ */ new WeakSet();
setFfs_fn = function(hArg) {
  var _a3, _b3;
  if ("noffs" in hArg) {
    __privateSet(this, _strNoFFS, (_a3 = hArg.noffs) != null ? _a3 : "");
    __privateSet(this, _regNoFFS, new RegExp(`[\u3000${__privateGet(this, _strNoFFS)}]`));
  }
  if (!("ffs" in hArg))
    return;
  (_b3 = __privateGet(this, _ffs)) != null ? _b3 : __privateSet(this, _ffs, "");
  if (__privateGet(this, _ffs) === "") {
    __privateSet(this, _fncFFSStyle, () => "");
    __privateSet(this, _fncFFSSpan, (ch) => ch);
  } else {
    __privateSet(this, _fncFFSStyle, (ch) => __privateGet(this, _regNoFFS).test(ch) ? "" : ` font-feature-settings: ${__privateGet(this, _ffs)};`);
    __privateSet(this, _fncFFSSpan, (ch) => __privateGet(this, _regNoFFS).test(ch) ? ch : `<span style='font-feature-settings: ${__privateGet(this, _ffs)};'>${ch}</span>`);
  }
};
_ffs = /* @__PURE__ */ new WeakMap();
_fncFFSStyle = /* @__PURE__ */ new WeakMap();
_fncFFSSpan = /* @__PURE__ */ new WeakMap();
_strNoFFS = /* @__PURE__ */ new WeakMap();
_regNoFFS = /* @__PURE__ */ new WeakMap();
_ruby_pd = /* @__PURE__ */ new WeakMap();
_r_align = /* @__PURE__ */ new WeakMap();
_mkStyle_r_align4ff = /* @__PURE__ */ new WeakSet();
mkStyle_r_align4ff_fn = function(ch, rb, r_align) {
  if (!r_align)
    return "";
  const len = ch.length * 2;
  if (len - rb.length < 0)
    return ` style='text-align: ${r_align};'`;
  let st = "";
  switch (r_align) {
    case "left":
      st = `ruby-align: start;`;
      break;
    case "center":
      st = `ruby-align: center;`;
      break;
    case "right":
      st = `ruby-align: start;`;
      break;
    case "justify":
      st = `ruby-align: space-between;`;
      break;
    case "121":
      st = `ruby-align: space-around;`;
      break;
    case "even":
      const ev = (len - rb.length) / (rb.length + 1);
      st = `ruby-align: space-between; ` + (__privateGet(this, _txs).tategaki ? `padding-top: ${ev}em; padding-bottom: ${ev}em;` : `padding-left: ${ev}em; padding-right: ${ev}em;`);
      break;
    case "1ruby":
      st = `ruby-align: space-between; ` + (__privateGet(this, _txs).tategaki ? `padding-top: 1em; padding-bottom: 1em;` : `padding-left: 1em; padding-right: 1em;`);
      break;
    default:
      st = `text-align: ${r_align};`;
  }
  return ` style='${st}'`;
};
_needGoTxt = /* @__PURE__ */ new WeakMap();
_putCh = /* @__PURE__ */ new WeakMap();
_tagCh_sub = /* @__PURE__ */ new WeakSet();
tagCh_sub_fn = function(ch, ruby, isSkip, r_align) {
  var _a3;
  if (ch === " ")
    ch = "&nbsp;";
  if (__privateGet(_TxtLayer, _val).doRecLog())
    __privateSet(this, _page_text, __privateGet(this, _page_text) + (ch + (ruby ? `\u300A${ruby}\u300B` : "")));
  let add_htm = "";
  const rs = this.mkStyle_r_align(ch, ruby, r_align);
  if (isSkip)
    __privateSet(this, _cumDelay, 0);
  const da = ` data-add='{"ch_in_style":"${__privateGet(this, _$ch_in_style)}", "ch_out_style":"${__privateGet(this, _$ch_out_style)}"}'`;
  add_htm = ruby ? __privateGet(this, _aSpan_bk) ? `<ruby style='${__privateGet(this, _fncFFSStyle).call(this, ch)}'${da} data-cmd='linkrsv'>${ch}<rt${rs}>${ruby}</rt></ruby>` : `<span class='sn_ch sn_ch_in_${__privateGet(this, _$ch_in_style)}' style='animation-delay: ${__privateGet(this, _cumDelay)}ms;${__privateGet(this, _fncFFSStyle).call(this, ch)}'>
					<ruby${da}>${ch}<rt${rs}>${ruby}</rt></ruby>
				</span>` : __privateGet(this, _aSpan_bk) ? __privateGet(this, _fncFFSSpan).call(this, ch) : `<span class='sn_ch sn_ch_in_${__privateGet(this, _$ch_in_style)}' style='animation-delay: ${__privateGet(this, _cumDelay)}ms;${__privateGet(this, _fncFFSStyle).call(this, ch)}'${da}>${ch}</span>`;
  if (__privateGet(this, _ch_in_join))
    __privateSet(this, _cumDelay, __privateGet(this, _cumDelay) + (__privateGet(_TxtLayer, _doAutoWc) ? (_a3 = __privateGet(_TxtLayer, _hAutoWc)[ch.charAt(0)]) != null ? _a3 : 0 : LayerMng.msecChWait));
  return add_htm;
};
_cumDelay = /* @__PURE__ */ new WeakMap();
_firstCh = /* @__PURE__ */ new WeakMap();
_aSpan = /* @__PURE__ */ new WeakMap();
_aSpan_bk = /* @__PURE__ */ new WeakMap();
_aSpan_link = /* @__PURE__ */ new WeakMap();
_hSpanBk = /* @__PURE__ */ new WeakMap();
_beginSpan = /* @__PURE__ */ new WeakSet();
beginSpan_fn = function(o) {
  __privateGet(this, _hSpanBk).ch_in_style = __privateGet(this, _$ch_in_style);
  __privateMethod(this, _set_ch_in, set_ch_in_fn).call(this, o);
  __privateGet(this, _hSpanBk).ch_out_style = __privateGet(this, _$ch_out_style);
  __privateMethod(this, _set_ch_out, set_ch_out_fn).call(this, o);
  __privateGet(this, _hSpanBk).r_align = __privateGet(this, _r_align);
  if ("r_align" in o)
    __privateSet(this, _r_align, o.r_align);
};
_autoCloseSpan = /* @__PURE__ */ new WeakSet();
autoCloseSpan_fn = function() {
  if (!__privateGet(this, _aSpan_bk))
    return;
  __privateGet(this, _aSpan_bk).push(__privateGet(this, _aSpan), "</span>");
  __privateSet(this, _aSpan, Array.prototype.concat.apply([], __privateGet(this, _aSpan_bk)));
  __privateSet(this, _aSpan_bk, void 0);
  __privateMethod(this, _set_ch_in, set_ch_in_fn).call(this, { in_style: __privateGet(this, _hSpanBk).ch_in_style });
  __privateMethod(this, _set_ch_out, set_ch_out_fn).call(this, { out_style: __privateGet(this, _hSpanBk).ch_out_style });
  __privateSet(this, _r_align, __privateGet(this, _hSpanBk).r_align);
};
_page_text = /* @__PURE__ */ new WeakMap();
__privateAdd(TxtLayer, _ch_in_style);
__privateAdd(TxtLayer, _ch_out_style);
__privateAdd(TxtLayer, _autowc);
__privateAdd(TxtLayer, _cfg, void 0);
__privateAdd(TxtLayer, _val, void 0);
__privateAdd(TxtLayer, _recText, void 0);
__privateAdd(TxtLayer, _isPageFore, void 0);
__privateAdd(TxtLayer, _main, void 0);
__privateAdd(TxtLayer, _evtMng, void 0);
__privateAdd(TxtLayer, _sys, void 0);
__privateAdd(TxtLayer, _doAutoWc, false);
__privateAdd(TxtLayer, _hAutoWc, {});
TxtLayer.rec = (tx) => tx;
class FrameMng {
  constructor(cfg, hTag, appPixi, val, main2, sys, hTwInf) {
    __privateAdd2(this, _add_frame);
    __privateAdd2(this, _rect);
    __privateAdd2(this, _let_frame);
    __privateAdd2(this, _set_frame);
    __privateAdd2(this, _frame);
    __privateAdd2(this, _tsy_frame);
    __privateAdd2(this, _evtMng4, void 0);
    __privateAdd2(this, _hIfrm, /* @__PURE__ */ Object.create(null));
    __privateAdd2(this, _hDisabled, {});
    __privateAdd2(this, _zIdx, 1);
    this.cfg = cfg;
    this.appPixi = appPixi;
    this.val = val;
    this.main = main2;
    this.sys = sys;
    this.hTwInf = hTwInf;
    hTag.add_frame = (o) => __privateMethod2(this, _add_frame, add_frame_fn).call(this, o);
    hTag.let_frame = (o) => __privateMethod2(this, _let_frame, let_frame_fn).call(this, o);
    hTag.set_frame = (o) => __privateMethod2(this, _set_frame, set_frame_fn).call(this, o);
    hTag.frame = (o) => __privateMethod2(this, _frame, frame_fn).call(this, o);
    hTag.tsy_frame = (o) => __privateMethod2(this, _tsy_frame, tsy_frame_fn).call(this, o);
  }
  setEvtMng(evtMng) {
    __privateSet2(this, _evtMng4, evtMng);
  }
  destroy() {
    for (const n in __privateGet2(this, _hIfrm)) {
      const f2 = __privateGet2(this, _hIfrm)[n];
      f2.parentElement.removeChild(f2);
    }
    __privateSet2(this, _hIfrm, /* @__PURE__ */ Object.create(null));
  }
  getFrmDisabled(id) {
    return __privateGet2(this, _hDisabled)[id];
  }
  cvsResize() {
    for (const id in __privateGet2(this, _hIfrm)) {
      const f2 = __privateGet2(this, _hIfrm)[id];
      const vn = "const.sn.frm." + id;
      const x2 = Number(this.val.getVal(vn + ".x"));
      const y2 = Number(this.val.getVal(vn + ".y"));
      const w2 = Number(this.val.getVal(vn + ".width"));
      const h2 = Number(this.val.getVal(vn + ".height"));
      f2.style.left = `${this.sys.ofsLeft4elm + x2 * this.sys.cvsScale}px`;
      f2.style.top = `${this.sys.ofsTop4elm + y2 * this.sys.cvsScale}px`;
      f2.width = String(w2 * this.sys.cvsScale);
      f2.height = String(h2 * this.sys.cvsScale);
    }
  }
}
_evtMng4 = new WeakMap();
_hIfrm = new WeakMap();
_add_frame = new WeakSet();
add_frame_fn = function(hArg) {
  const { id, src, alpha: a2 = 1, scale_x: sx = 1, scale_y: sy = 1, rotate: r2 = 0 } = hArg;
  if (!id)
    throw "id\u306F\u5FC5\u9808\u3067\u3059";
  if (!src)
    throw "src\u306F\u5FC5\u9808\u3067\u3059";
  const vn = "const.sn.frm." + id;
  if (this.val.getVal(`tmp:${vn}`))
    throw `frame\u3010${id}\u3011\u306F\u3059\u3067\u306B\u3042\u308A\u307E\u3059`;
  const v2 = argChk_Boolean(hArg, "visible", true);
  const b_color = hArg.b_color ? ` background-color: ${hArg.b_color};` : "";
  const rct = __privateMethod2(this, _rect, rect_fn).call(this, hArg);
  this.appPixi.view.insertAdjacentHTML("beforebegin", `<iframe id="${id}" sandbox="allow-scripts allow-same-origin" style="opacity: ${a2}; position: absolute; left:${this.sys.ofsLeft4elm + rct.x * this.sys.cvsScale}px; top: ${this.sys.ofsTop4elm + rct.y * this.sys.cvsScale}px; z-index: 1; ${b_color} border: 0px; overflow: hidden; display: ${v2 ? "inline" : "none"}; transform: scale(${sx}, ${sy}) rotate(${r2}deg);" width="${rct.width * this.sys.cvsScale}" height="${rct.height * this.sys.cvsScale}"></iframe>`);
  const url2 = this.cfg.searchPath(src, Config.EXT_HTML);
  const ld = new Loader().add({ name: src, url: url2, xhrType: LoaderResource.XHR_RESPONSE_TYPE.TEXT });
  if (this.sys.crypto)
    ld.use((res, next) => {
      try {
        res.data = this.sys.decStr(res.extension, res.data);
      } catch (e) {
        this.main.errScript(`[add_frame]Html \u30ED\u30FC\u30C9\u5931\u6557\u3067\u3059 src:${res.name} ${e}`, false);
      }
      next == null ? void 0 : next();
    });
  ld.load((_ldr, hRes) => {
    var _a3;
    const ifrm = document.getElementById(id);
    __privateGet2(this, _hIfrm)[id] = ifrm;
    __privateGet2(this, _hDisabled)[id] = false;
    ifrm.srcdoc = String((_a3 = hRes[src]) == null ? void 0 : _a3.data).replace("sn_repRes();", "").replace(/\s(?:src|href)=(["'])(\S+)\1/g, (v22, p1, p2) => p2.slice(0, 3) === "../" ? this.sys.cur + p2.slice(4) : v22.replace(p1, p1 + url2.slice(0, url2.lastIndexOf("/") + 1)));
    ifrm.onload = () => {
      var _a4;
      this.val.setVal_Nochk("tmp", vn, true);
      this.val.setVal_Nochk("tmp", vn + ".alpha", a2);
      this.val.setVal_Nochk("tmp", vn + ".x", rct.x);
      this.val.setVal_Nochk("tmp", vn + ".y", rct.y);
      this.val.setVal_Nochk("tmp", vn + ".scale_x", sx);
      this.val.setVal_Nochk("tmp", vn + ".scale_y", sy);
      this.val.setVal_Nochk("tmp", vn + ".rotate", r2);
      this.val.setVal_Nochk("tmp", vn + ".width", rct.width);
      this.val.setVal_Nochk("tmp", vn + ".height", rct.height);
      this.val.setVal_Nochk("tmp", vn + ".visible", v2);
      const win = ifrm.contentWindow;
      __privateGet2(this, _evtMng4).resvFlameEvent(win);
      (_a4 = win.sn_repRes) == null ? void 0 : _a4.call(win, (img) => {
        var _a5;
        return GrpLayer.loadPic2Img((_a5 = img.dataset.src) != null ? _a5 : "", img);
      });
      this.main.resume();
    };
  });
  return true;
};
_hDisabled = new WeakMap();
_rect = new WeakSet();
rect_fn = function(hArg) {
  const a2 = __spreadValues({}, hArg);
  const re2 = this.sys.resolution;
  return new DOMRect(argChk_Num(a2, "x", 0) * re2, argChk_Num(a2, "y", 0) * re2, argChk_Num(a2, "width", CmnLib.stageW) * re2, argChk_Num(a2, "height", CmnLib.stageH) * re2);
};
_let_frame = new WeakSet();
let_frame_fn = function(hArg) {
  const { id, var_name } = hArg;
  if (!id)
    throw "id\u306F\u5FC5\u9808\u3067\u3059";
  const f2 = document.getElementById(id);
  if (!f2)
    throw `id\u3010${id}\u3011\u306F\u30D5\u30EC\u30FC\u30E0\u3067\u306F\u3042\u308A\u307E\u305B\u3093`;
  const vn = "const.sn.frm." + id;
  if (!this.val.getVal(`tmp:${vn}`))
    throw `frame\u3010${id}\u3011\u304C\u8AAD\u307F\u8FBC\u307E\u308C\u3066\u3044\u307E\u305B\u3093`;
  if (!var_name)
    throw "var_name\u306F\u5FC5\u9808\u3067\u3059";
  const win = f2.contentWindow;
  if (!win.hasOwnProperty(var_name))
    throw `frame\u3010${id}\u3011\u306B\u5909\u6570/\u95A2\u6570\u3010${var_name}\u3011\u304C\u3042\u308A\u307E\u305B\u3093\u3002\u5909\u6570\u306F var\u4ED8\u304D\u306B\u3057\u3066\u4E0B\u3055\u3044`;
  const v2 = win[var_name];
  this.val.setVal_Nochk("tmp", vn + "." + var_name, argChk_Boolean(hArg, "function", false) ? v2() : v2);
  return false;
};
_set_frame = new WeakSet();
set_frame_fn = function(hArg) {
  const { id, var_name, text: text2 } = hArg;
  if (!id)
    throw "id\u306F\u5FC5\u9808\u3067\u3059";
  const f2 = document.getElementById(id);
  if (!f2)
    throw `id\u3010${id}\u3011\u306F\u30D5\u30EC\u30FC\u30E0\u3067\u306F\u3042\u308A\u307E\u305B\u3093`;
  const vn = "const.sn.frm." + id;
  if (!this.val.getVal(`tmp:${vn}`))
    throw `frame\u3010${id}\u3011\u304C\u8AAD\u307F\u8FBC\u307E\u308C\u3066\u3044\u307E\u305B\u3093`;
  if (!var_name)
    throw "var_name\u306F\u5FC5\u9808\u3067\u3059";
  if (!text2)
    throw "text\u306F\u5FC5\u9808\u3067\u3059";
  this.val.setVal_Nochk("tmp", vn + "." + var_name, text2);
  const win = f2.contentWindow;
  win[var_name] = text2;
  return false;
};
_zIdx = new WeakMap();
_frame = new WeakSet();
frame_fn = function(hArg) {
  const { id } = hArg;
  if (!id)
    throw "id\u306F\u5FC5\u9808\u3067\u3059";
  const f2 = document.getElementById(id);
  if (!f2)
    throw `id\u3010${id}\u3011\u306F\u30D5\u30EC\u30FC\u30E0\u3067\u306F\u3042\u308A\u307E\u305B\u3093`;
  const vn = "const.sn.frm." + id;
  if (!this.val.getVal("tmp:" + vn))
    throw `frame\u3010${id}\u3011\u304C\u8AAD\u307F\u8FBC\u307E\u308C\u3066\u3044\u307E\u305B\u3093`;
  const s2 = f2.style;
  if (argChk_Boolean(hArg, "float", false))
    s2.zIndex = `${++__privateWrapper2(this, _zIdx)._}`;
  else if ("index" in hArg)
    s2.zIndex = `${argChk_Num(hArg, "index", 0)}`;
  else if (hArg.dive)
    s2.zIndex = `-${++__privateWrapper2(this, _zIdx)._}`;
  if ("alpha" in hArg) {
    const a2 = s2.opacity = String(hArg.alpha);
    this.val.setVal_Nochk("tmp", vn + ".alpha", a2);
  }
  const rct = __privateMethod2(this, _rect, rect_fn).call(this, hArg);
  if ("x" in hArg || "y" in hArg) {
    s2.left = `${this.sys.ofsLeft4elm + rct.x * this.sys.cvsScale}px`;
    s2.top = `${this.sys.ofsTop4elm + rct.y * this.sys.cvsScale}px`;
    this.val.setVal_Nochk("tmp", vn + ".x", rct.x);
    this.val.setVal_Nochk("tmp", vn + ".y", rct.y);
  }
  if ("scale_x" in hArg || "scale_y" in hArg || "rotate" in hArg) {
    const sx = argChk_Num(hArg, "scale_x", 1);
    const sy = argChk_Num(hArg, "scale_y", 1);
    const r2 = argChk_Num(hArg, "rotate", 0);
    s2.transform = `scale(${sx}, ${sy}) rotate(${r2}deg)`;
    this.val.setVal_Nochk("tmp", vn + ".scale_x", sx);
    this.val.setVal_Nochk("tmp", vn + ".scale_y", sy);
    this.val.setVal_Nochk("tmp", vn + ".rotate", r2);
  }
  if ("width" in hArg) {
    f2.width = String(rct.width * this.sys.cvsScale);
    this.val.setVal_Nochk("tmp", vn + ".width", rct.width);
  }
  if ("height" in hArg) {
    f2.height = String(rct.height * this.sys.cvsScale);
    this.val.setVal_Nochk("tmp", vn + ".height", rct.height);
  }
  if ("visible" in hArg) {
    const v2 = argChk_Boolean(hArg, "visible", true);
    s2.display = v2 ? "inline" : "none";
    this.val.setVal_Nochk("tmp", vn + ".visible", v2);
  }
  if ("b_color" in hArg)
    s2.backgroundColor = hArg.b_color;
  if ("disabled" in hArg) {
    const d2 = __privateGet2(this, _hDisabled)[id] = argChk_Boolean(hArg, "disabled", true);
    const il = f2.contentDocument.body.querySelectorAll("input,select");
    il.forEach((v2) => v2.disabled = d2);
  }
  return false;
};
_tsy_frame = new WeakSet();
tsy_frame_fn = function(hArg) {
  var _a3;
  const { id } = hArg;
  if (!id)
    throw "id\u306F\u5FC5\u9808\u3067\u3059";
  const f2 = document.getElementById(id);
  if (!f2)
    throw `id\u3010${id}\u3011\u306F\u30D5\u30EC\u30FC\u30E0\u3067\u306F\u3042\u308A\u307E\u305B\u3093`;
  const vn = `const.sn.frm.` + id;
  if (!this.val.getVal(`tmp:${vn}`, 0))
    throw `frame\u3010${id}\u3011\u304C\u8AAD\u307F\u8FBC\u307E\u308C\u3066\u3044\u307E\u305B\u3093`;
  const hNow = {};
  if ("alpha" in hArg)
    hNow.a = f2.style.opacity;
  if ("x" in hArg || "y" in hArg || "scale_x" in hArg || "scale_y" in hArg || "rotate" in hArg) {
    hNow.x = Number(this.val.getVal(`tmp:${vn}.x`));
    hNow.y = Number(this.val.getVal(`tmp:${vn}.y`));
    hNow.sx = Number(this.val.getVal(`tmp:${vn}.scale_x`));
    hNow.sy = Number(this.val.getVal(`tmp:${vn}.scale_y`));
    hNow.r = Number(this.val.getVal(`tmp:${vn}.rotate`));
  }
  if ("width" in hArg)
    hNow.w = this.val.getVal(`tmp:${vn}.width`);
  if ("height" in hArg)
    hNow.h = this.val.getVal(`tmp:${vn}.height`);
  const hArg2 = cnvTweenArg(hArg, hNow);
  const hTo = {};
  const repeat = argChk_Num(hArg, "repeat", 1);
  let fncA = () => {
  };
  if ("alpha" in hArg) {
    hTo.a = argChk_Num(hArg2, "alpha", 0);
    fncA = () => {
      f2.style.opacity = hNow.a;
      this.val.setVal_Nochk("tmp", "alpha", hNow.a);
    };
  }
  let fncXYSR = () => {
  };
  const rct = __privateMethod2(this, _rect, rect_fn).call(this, hArg2);
  if ("x" in hArg || "y" in hArg || "scale_x" in hArg || "scale_y" in hArg || "rotate" in hArg) {
    hTo.x = rct.x;
    hTo.y = rct.y;
    hTo.sx = argChk_Num(hArg2, "scale_x", 1);
    hTo.sy = argChk_Num(hArg2, "scale_y", 1);
    hTo.r = argChk_Num(hArg2, "rotate", 0);
    fncXYSR = () => {
      f2.style.left = this.sys.ofsLeft4elm + hNow.x * this.sys.cvsScale + "px";
      f2.style.top = this.sys.ofsTop4elm + hNow.y * this.sys.cvsScale + "px";
      f2.style.transform = `scale(${hNow.sx}, ${hNow.sy}) rotate(${hNow.r}deg)`;
      this.val.setVal_Nochk("tmp", vn + ".x", hNow.x);
      this.val.setVal_Nochk("tmp", vn + ".y", hNow.y);
      this.val.setVal_Nochk("tmp", vn + ".scale_x", hNow.sx);
      this.val.setVal_Nochk("tmp", vn + ".scale_y", hNow.sy);
      this.val.setVal_Nochk("tmp", vn + ".rotate", hNow.r);
    };
  }
  let fncW = () => {
  };
  if ("width" in hArg) {
    hTo.w = rct.width;
    fncW = () => {
      f2.width = hNow.w * this.sys.cvsScale + "px";
      this.val.setVal_Nochk("tmp", vn + ".width", hNow.w);
    };
  }
  let fncH = () => {
  };
  if ("height" in hArg) {
    hTo.h = rct.height;
    fncH = () => {
      f2.height = hNow.h * this.sys.cvsScale + "px";
      this.val.setVal_Nochk("tmp", vn + ".height", hNow.h);
    };
  }
  this.appPixi.stage.interactive = false;
  const tw_nm = `frm
${hArg.id}`;
  const tw = new Tween(hNow).to(hTo, argChk_Num(hArg, "time", NaN) * (Boolean(this.val.getVal("tmp:sn.skip.enabled") || __privateGet2(this, _evtMng4).isSkippingByKeyDown()) ? 0 : 1)).delay(argChk_Num(hArg, "delay", 0)).easing(CmnTween.ease(hArg.ease)).repeat(repeat === 0 ? Infinity : repeat - 1).yoyo(argChk_Boolean(hArg, "yoyo", false)).onUpdate(() => {
    fncA();
    fncXYSR();
    fncW();
    fncH();
  }).onComplete(() => {
    var _a4, _b3;
    this.appPixi.stage.interactive = true;
    const ti = this.hTwInf[tw_nm];
    if (!ti)
      return;
    delete this.hTwInf[tw_nm];
    (_a4 = ti.tw) == null ? void 0 : _a4.stop();
    if (ti.resume)
      this.main.resume();
    (_b3 = ti.onEnd) == null ? void 0 : _b3.call(ti);
  });
  if ("chain" in hArg) {
    const twFrom = this.hTwInf[(_a3 = hArg.chain) != null ? _a3 : ""];
    if (!twFrom || !twFrom.tw)
      throw `${hArg.chain}\u306F\u5B58\u5728\u3057\u306A\u3044\u30FB\u307E\u305F\u306F\u7D42\u4E86\u3057\u305F\u30C8\u30A5\u30A4\u30FC\u30F3\u3067\u3059`;
    delete twFrom.onEnd;
    twFrom.tw.chain(tw);
  } else
    tw.start();
  this.hTwInf[tw_nm] = { tw, resume: false };
  return false;
};
const _LayerMng = class {
  constructor(cfg, hTag, appPixi, val, main2, scrItr, sys, sndMng, alzTagArg, prpPrs) {
    __privateAdd2(this, _selectNode);
    __privateAdd2(this, _foreachRedrawTxtLayBack);
    __privateAdd2(this, _snapshot);
    __privateAdd2(this, _loadplugin);
    __privateAdd2(this, _add_lay);
    __privateAdd2(this, _lay);
    __privateAdd2(this, _rebuildLayerRankInfo);
    __privateAdd2(this, _clear_lay);
    __privateAdd2(this, _trans);
    __privateAdd2(this, _getLayers);
    __privateAdd2(this, _foreachLayers);
    __privateAdd2(this, _sortLayers);
    __privateAdd2(this, _wt);
    __privateAdd2(this, _finish_trans);
    __privateAdd2(this, _quake);
    __privateAdd2(this, _tsy);
    __privateAdd2(this, _wait_tsy);
    __privateAdd2(this, _stop_tsy);
    __privateAdd2(this, _pause_tsy);
    __privateAdd2(this, _resume_tsy);
    __privateAdd2(this, _ch);
    __privateAdd2(this, _$getTxtLayer);
    __privateAdd2(this, _$current);
    __privateAdd2(this, _argChk_layer);
    __privateAdd2(this, _clear_text);
    __privateAdd2(this, _endlink);
    __privateAdd2(this, _er);
    __privateAdd2(this, _graph);
    __privateAdd2(this, _link);
    __privateAdd2(this, _r);
    __privateAdd2(this, _rec_r);
    __privateAdd2(this, _rec_ch);
    __privateAdd2(this, _reset_rec);
    __privateAdd2(this, _ruby2);
    __privateAdd2(this, _span);
    __privateAdd2(this, _tcy);
    __privateAdd2(this, _dump_lay);
    __privateAdd2(this, _enable_event);
    __privateAdd2(this, _button);
    __privateAdd2(this, _stage, void 0);
    __privateAdd2(this, _fore, void 0);
    __privateAdd2(this, _back, void 0);
    __privateAdd2(this, _frmMng, void 0);
    __privateAdd2(this, _fncTicker, void 0);
    __privateAdd2(this, _hProcDbgRes2, void 0);
    __privateAdd2(this, _modeLn, void 0);
    __privateAdd2(this, _modeLnSub, void 0);
    __privateAdd2(this, _grpCover, void 0);
    __privateAdd2(this, _evtMng5, void 0);
    __privateAdd2(this, _cmdTxt, void 0);
    __privateAdd2(this, _hPages, void 0);
    __privateAdd2(this, _aLayName, void 0);
    __privateAdd2(this, _curTxtlay, void 0);
    __privateAdd2(this, _firstGrplay, void 0);
    __privateAdd2(this, _srcRuleTransFragment, void 0);
    __privateAdd2(this, _ufRuleTrans, void 0);
    __privateAdd2(this, _fltRule, void 0);
    __privateAdd2(this, _rtTransBack, void 0);
    __privateAdd2(this, _spTransBack, void 0);
    __privateAdd2(this, _rtTransFore, void 0);
    __privateAdd2(this, _spTransFore, void 0);
    __privateAdd2(this, _aBackTransAfter, void 0);
    __privateAdd2(this, _tiTrans, void 0);
    __privateAdd2(this, _hTwInf, void 0);
    __privateAdd2(this, _getTxtLayer, void 0);
    __privateAdd2(this, _current, void 0);
    __privateAdd2(this, _pgTxtlay, void 0);
    __privateAdd2(this, _chkTxtLay, void 0);
    __privateAdd2(this, _oLastPage, void 0);
    __privateAdd2(this, _aTxtLog, void 0);
    this.cfg = cfg;
    this.hTag = hTag;
    this.appPixi = appPixi;
    this.val = val;
    this.main = main2;
    this.scrItr = scrItr;
    this.sys = sys;
    this.sndMng = sndMng;
    this.alzTagArg = alzTagArg;
    this.prpPrs = prpPrs;
    __privateSet2(this, _fore, new Container());
    __privateSet2(this, _back, new Container());
    __privateSet2(this, _fncTicker, () => update());
    __privateSet2(this, _hProcDbgRes2, {
      attach: (_2) => {
        DesignCast.leaveMode();
        return false;
      },
      continue: (_2) => {
        DesignCast.leaveMode();
        return false;
      },
      disconnect: (_2) => {
        DesignCast.leaveMode();
        return false;
      },
      _enterDesign: (_2) => {
        DesignCast.enterMode();
        __privateGet2(this, _aLayName).forEach((layer) => {
          const lay = __privateGet2(this, _hPages)[layer].fore;
          lay.makeDesignCastChildren((gdc) => gdc.make());
          lay.makeDesignCast((gdc) => gdc.make());
        });
        __privateMethod2(this, _selectNode, selectNode_fn).call(this, __privateGet2(this, _curTxtlay));
        return false;
      },
      _replaceToken: (_2, o) => {
        DesignCast.replaceToken(o);
        return false;
      },
      _selectNode: (_2, o) => {
        __privateMethod2(this, _selectNode, selectNode_fn).call(this, o.node);
        return false;
      }
    });
    __privateSet2(this, _modeLn, "");
    __privateSet2(this, _modeLnSub, "");
    this.getFrmDisabled = (id) => __privateGet2(this, _frmMng).getFrmDisabled(id);
    __privateSet2(this, _grpCover, void 0);
    __privateSet2(this, _cmdTxt, (cmd, tl = this.currentTxtlayForeNeedErr, _record = true) => tl.tagCh("\uFF5C\u3000\u300A" + cmd + "\u300B"));
    this.goTxt = () => {
    };
    this.breakLine = () => {
    };
    this.breakPage = () => {
    };
    __privateSet2(this, _hPages, {});
    __privateSet2(this, _aLayName, []);
    __privateSet2(this, _curTxtlay, "");
    __privateSet2(this, _firstGrplay, "");
    __privateSet2(this, _srcRuleTransFragment, `
precision mediump float;

varying vec2 vTextureCoord;
uniform sampler2D uSampler;

uniform sampler2D rule;
uniform float vague;
uniform float tick;

uniform vec4 inputPixel;
uniform highp vec4 outputFrame;
vec2 getUV(vec2 coord) {
	return coord * inputPixel.xy / outputFrame.zw;
}

void main(void) {
	vec4 fg = texture2D(uSampler, vTextureCoord);
	vec4 ru = texture2D(rule, getUV(vTextureCoord));

	float v = ru.r - tick;
	if (abs(v) < vague) {
		float f_a = fg.a *(0.5 +v /vague *0.5);

		gl_FragColor.rgb = fg.rgb *f_a;
		gl_FragColor.a = f_a;
	}
	else {
		gl_FragColor = (v >= 0.0)? fg : vec4(0);
	}
}`);
    __privateSet2(this, _ufRuleTrans, {
      rule: Texture.EMPTY,
      vague: 0,
      tick: 0
    });
    __privateSet2(this, _fltRule, new Filter(void 0, __privateGet2(this, _srcRuleTransFragment), __privateGet2(this, _ufRuleTrans)));
    __privateSet2(this, _rtTransBack, RenderTexture.create({
      width: CmnLib.stageW,
      height: CmnLib.stageH
    }));
    __privateSet2(this, _spTransBack, new Sprite(__privateGet2(this, _rtTransBack)));
    __privateSet2(this, _rtTransFore, RenderTexture.create({
      width: CmnLib.stageW,
      height: CmnLib.stageH
    }));
    __privateSet2(this, _spTransFore, new Sprite(__privateGet2(this, _rtTransFore)));
    __privateSet2(this, _aBackTransAfter, []);
    __privateSet2(this, _tiTrans, { tw: void 0, resume: false });
    __privateSet2(this, _hTwInf, {});
    __privateSet2(this, _getTxtLayer, (_hArg) => {
      __privateGet2(this, _chkTxtLay).call(this);
      throw 0;
    });
    __privateSet2(this, _current, (_hArg) => {
      __privateGet2(this, _chkTxtLay).call(this);
      throw 0;
    });
    __privateSet2(this, _chkTxtLay, () => {
      throw "\u6587\u5B57\u30EC\u30A4\u30E4\u30FC\u304C\u3042\u308A\u307E\u305B\u3093\u3002\u6587\u5B57\u8868\u793A\u3084\u64CD\u4F5C\u3059\u308B\u524D\u306B\u3001[add_lay layer=\uFF08\u30EC\u30A4\u30E4\u540D\uFF09 class=txt]\u3067\u6587\u5B57\u30EC\u30A4\u30E4\u3092\u8FFD\u52A0\u3057\u3066\u4E0B\u3055\u3044";
    });
    __privateSet2(this, _oLastPage, { text: "" });
    __privateSet2(this, _aTxtLog, []);
    const fncResizeLay = () => {
      sys.cvsResize();
      this.cvsResizeDesign();
      if (__privateGet2(this, _modeLnSub))
        __privateGet2(this, _aLayName).forEach((layer) => __privateGet2(this, _hPages)[layer].fore.cvsResizeChildren());
      else
        __privateGet2(this, _aLayName).forEach((layer) => __privateGet2(this, _hPages)[layer].fore.cvsResize());
      __privateGet2(this, _frmMng).cvsResize();
      __privateGet2(this, _evtMng5).cvsResize();
    };
    if (CmnLib.isMobile) {
      globalThis.addEventListener("orientationchange", fncResizeLay, { passive: true });
    } else {
      let tid = void 0;
      globalThis.addEventListener("resize", () => {
        if (tid)
          return;
        tid = setTimeout(() => {
          tid = void 0;
          fncResizeLay();
        }, 1e3 / 60 * 10);
      }, { passive: true });
    }
    sys.cvsResize();
    TxtLayer.init(cfg, hTag, val, (txt) => this.recText(txt), (me) => __privateGet2(this, _hPages)[me.layname].fore === me, appPixi);
    GrpLayer.init(main2, cfg, appPixi, sys, sndMng);
    Button.init(cfg);
    __privateSet2(this, _frmMng, new FrameMng(this.cfg, this.hTag, this.appPixi, this.val, main2, this.sys, __privateGet2(this, _hTwInf)));
    sys.hFactoryCls.grp = () => new GrpLayer();
    sys.hFactoryCls.txt = () => new TxtLayer();
    hTag.loadplugin = (o) => __privateMethod2(this, _loadplugin, loadplugin_fn).call(this, o);
    hTag.snapshot = (o) => __privateMethod2(this, _snapshot, snapshot_fn).call(this, o);
    hTag.add_lay = (o) => __privateMethod2(this, _add_lay, add_lay_fn).call(this, o);
    hTag.clear_lay = (o) => __privateMethod2(this, _clear_lay, clear_lay_fn).call(this, o);
    hTag.finish_trans = () => __privateMethod2(this, _finish_trans, finish_trans_fn).call(this);
    hTag.lay = (o) => __privateMethod2(this, _lay, lay_fn).call(this, o);
    hTag.trans = (o) => __privateMethod2(this, _trans, trans_fn).call(this, o);
    hTag.wt = (o) => __privateMethod2(this, _wt, wt_fn).call(this, o);
    hTag.quake = (o) => __privateMethod2(this, _quake, quake_fn).call(this, o);
    hTag.stop_quake = (o) => hTag.finish_trans(o);
    hTag.wq = (o) => hTag.wt(o);
    hTag.pause_tsy = (o) => __privateMethod2(this, _pause_tsy, pause_tsy_fn).call(this, o);
    hTag.resume_tsy = (o) => __privateMethod2(this, _resume_tsy, resume_tsy_fn).call(this, o);
    hTag.stop_tsy = (o) => __privateMethod2(this, _stop_tsy, stop_tsy_fn).call(this, o);
    hTag.tsy = (o) => __privateMethod2(this, _tsy, tsy_fn).call(this, o);
    hTag.wait_tsy = (o) => __privateMethod2(this, _wait_tsy, wait_tsy_fn).call(this, o);
    hTag.ch = (o) => __privateMethod2(this, _ch, ch_fn).call(this, o);
    hTag.clear_text = (o) => __privateMethod2(this, _clear_text, clear_text_fn).call(this, o);
    hTag.current = (o) => __privateGet2(this, _current).call(this, o);
    hTag.endlink = (o) => __privateMethod2(this, _endlink, endlink_fn).call(this, o);
    hTag.er = (o) => __privateMethod2(this, _er, er_fn).call(this, o);
    hTag.graph = (o) => __privateMethod2(this, _graph, graph_fn).call(this, o);
    hTag.link = (o) => __privateMethod2(this, _link, link_fn).call(this, o);
    hTag.r = (o) => __privateMethod2(this, _r, r_fn).call(this, o);
    hTag.rec_ch = (o) => __privateMethod2(this, _rec_ch, rec_ch_fn).call(this, o);
    hTag.rec_r = () => __privateMethod2(this, _rec_r, rec_r_fn).call(this);
    hTag.reset_rec = (o) => __privateMethod2(this, _reset_rec, reset_rec_fn).call(this, o);
    hTag.ruby2 = (o) => __privateMethod2(this, _ruby2, ruby2_fn).call(this, o);
    hTag.span = (o) => __privateMethod2(this, _span, span_fn).call(this, o);
    hTag.tcy = (o) => __privateMethod2(this, _tcy, tcy_fn).call(this, o);
    hTag.add_face = (o) => GrpLayer.add_face(o);
    hTag.wv = (o) => GrpLayer.wv(o);
    hTag.dump_lay = (o) => __privateMethod2(this, _dump_lay, dump_lay_fn).call(this, o);
    hTag.enable_event = (o) => __privateMethod2(this, _enable_event, enable_event_fn).call(this, o);
    hTag.button = (o) => __privateMethod2(this, _button, button_fn).call(this, o);
    if (cfg.existsBreakline)
      this.breakLine = () => __privateGet2(this, _cmdTxt).call(this, 'grp\uFF5C{"id":"break","pic":"breakline"}');
    if (cfg.existsBreakpage)
      this.breakPage = () => __privateGet2(this, _cmdTxt).call(this, 'grp\uFF5C{"id":"break","pic":"breakpage"}');
    const grp = new Graphics();
    grp.beginFill(cfg.oCfg.init.bg_color, 1).lineStyle(0, cfg.oCfg.init.bg_color).drawRect(0, 0, CmnLib.stageW, CmnLib.stageH).endFill();
    __privateGet2(this, _fore).addChild(grp.clone());
    __privateGet2(this, _back).addChild(grp);
    __privateGet2(this, _back).visible = false;
    __privateSet2(this, _stage, this.appPixi.stage);
    __privateGet2(this, _stage).addChild(__privateGet2(this, _back));
    __privateGet2(this, _stage).addChild(__privateGet2(this, _fore));
    __privateGet2(this, _stage).addChild(__privateGet2(this, _spTransBack));
    __privateGet2(this, _stage).addChild(__privateGet2(this, _spTransFore));
    this.appPixi.ticker.add(__privateGet2(this, _fncTicker));
    const fncTxt_b_alpha = (_name, val2) => {
      __privateMethod2(this, _foreachRedrawTxtLayBack, foreachRedrawTxtLayBack_fn).call(this, Number(val2));
    };
    fncTxt_b_alpha("", val.getVal("sys:TextLayer.Back.Alpha", 1));
    val.defValTrg("sys:TextLayer.Back.Alpha", fncTxt_b_alpha);
    const fncBtnFont = (_name, val2) => Button.fontFamily = val2;
    fncBtnFont("", val.getVal("tmp:sn.button.fontFamily", Button.fontFamily));
    val.defValTrg("tmp:sn.button.fontFamily", fncBtnFont);
    val.defTmp("const.sn.log.json", () => JSON.stringify(__privateGet2(this, _oLastPage).text ? [...__privateGet2(this, _aTxtLog), __privateGet2(this, _oLastPage)] : __privateGet2(this, _aTxtLog)));
    val.defTmp("const.sn.last_page_text", () => {
      var _a3, _b3;
      return (_b3 = (_a3 = this.currentTxtlayFore) == null ? void 0 : _a3.pageText) != null ? _b3 : "";
    });
    if (CmnLib.isDbg) {
      DesignCast.init(this.appPixi, sys, scrItr, prpPrs, alzTagArg, this.cfg, __privateGet2(this, _hPages));
      this.cvsResizeDesign = () => DesignCast.cvsResizeDesign();
      sys.addHook((type, o) => {
        var _a3, _b3;
        if (!((_b3 = (_a3 = __privateGet2(this, _hProcDbgRes2))[type]) == null ? void 0 : _b3.call(_a3, type, o)))
          return;
        delete __privateGet2(this, _hProcDbgRes2)[type];
      });
    }
  }
  cvsResizeDesign() {
  }
  cover(visible, bg_color = 0) {
    if (__privateGet2(this, _grpCover)) {
      __privateGet2(this, _stage).removeChild(__privateGet2(this, _grpCover));
      __privateGet2(this, _grpCover).destroy();
      __privateSet2(this, _grpCover, void 0);
    }
    if (visible)
      __privateGet2(this, _stage).addChild(__privateSet2(this, _grpCover, new Graphics()).beginFill(bg_color).lineStyle(0, bg_color).drawRect(0, 0, CmnLib.stageW, CmnLib.stageH).endFill());
  }
  setEvtMng(evtMng) {
    __privateSet2(this, _evtMng5, evtMng);
    __privateGet2(this, _frmMng).setEvtMng(evtMng);
    GrpLayer.setEvtMng(evtMng);
  }
  before_destroy() {
    for (const pg in __privateGet2(this, _hPages))
      __privateGet2(this, _hPages)[pg].destroy();
  }
  destroy() {
    GrpLayer.destroy();
    RubySpliter.destroy();
    TxtStage.destroy();
    TxtLayer.destroy();
    __privateGet2(this, _frmMng).destroy();
    this.stopAllTw();
    this.appPixi.ticker.remove(__privateGet2(this, _fncTicker));
    __privateSet2(_LayerMng, _msecChWait, 10);
  }
  stopAllTw() {
    __privateSet2(this, _hTwInf, {});
    removeAll();
  }
  clearBreak() {
    if (!this.currentTxtlayFore)
      return;
    this.clearBreak = () => __privateGet2(this, _cmdTxt).call(this, "del\uFF5Cbreak");
    this.clearBreak();
  }
  clickTxtLay() {
    if (!this.currentTxtlayFore)
      return;
    const vct = __privateMethod2(this, _getLayers, getLayers_fn).call(this);
    const len = vct.length;
    for (let i2 = 0; i2 < len; ++i2) {
      const name2 = vct[i2];
      const pg = __privateGet2(this, _hPages)[name2];
      if (!(pg.fore instanceof TxtLayer))
        continue;
      const pTxt = pg.fore;
      if (!pTxt.click())
        break;
    }
  }
  static get msecChWait() {
    return __privateGet2(_LayerMng, _msecChWait);
  }
  static set msecChWait(v2) {
    __privateSet2(_LayerMng, _msecChWait, v2);
  }
  setNormalChWait() {
    __privateSet2(_LayerMng, _msecChWait, this.scrItr.normalWait);
  }
  get currentTxtlayForeNeedErr() {
    __privateGet2(this, _chkTxtLay).call(this);
    return this.currentTxtlayFore;
  }
  get currentTxtlayFore() {
    if (!__privateGet2(this, _pgTxtlay))
      return void 0;
    return __privateGet2(this, _pgTxtlay).fore;
  }
  recText(txt, pagebreak = false) {
    const o = __privateGet2(this, _oLastPage);
    if (pagebreak) {
      if (o.text) {
        o.text = String(o.text).replaceAll(`</span><span class='sn_ch'>`, "");
        if (__privateGet2(this, _aTxtLog).push(o) > this.cfg.oCfg.log.max_len)
          __privateSet2(this, _aTxtLog, __privateGet2(this, _aTxtLog).slice(-this.cfg.oCfg.log.max_len));
      }
      __privateSet2(this, _oLastPage, { text: "" });
      return;
    }
    o.text = txt.replace(/\\`/, "`");
    this.val.setVal_Nochk("save", "const.sn.sLog", String(this.val.getVal("const.sn.log.json")));
  }
  record() {
    const o = {};
    __privateGet2(this, _aLayName).forEach((layer) => {
      const pg = __privateGet2(this, _hPages)[layer];
      o[layer] = {
        cls: pg.cls,
        fore: pg.fore.record(),
        back: pg.back.record()
      };
    });
    return o;
  }
  playback($hPages, fncComp) {
    var _a3, _b3;
    __privateSet2(this, _aTxtLog, JSON.parse(String(this.val.getVal("save:const.sn.sLog"))));
    __privateSet2(this, _oLastPage, { text: "" });
    const aPrm = [];
    const aSort = [];
    for (const layer in $hPages) {
      const $pg = $hPages[layer];
      aSort.push({ layer, idx: $pg.fore.idx });
      const pg = (_b3 = (_a3 = __privateGet2(this, _hPages))[layer]) != null ? _b3 : _a3[layer] = new Pages(layer, $pg.cls, __privateGet2(this, _fore), __privateGet2(this, _back), {}, this.sys, this.val, { isWait: false });
      pg.fore.playback($pg.fore, aPrm);
      pg.back.playback($pg.back, aPrm);
    }
    const len = __privateGet2(this, _fore).children.length;
    Promise.allSettled(aPrm).then(() => {
      aSort.sort(function(a2, b2) {
        if (a2.idx < b2.idx)
          return -1;
        if (a2.idx > b2.idx)
          return 1;
        return 0;
      });
      aSort.forEach((o) => {
        const pg = __privateGet2(this, _hPages)[o.layer];
        if (!pg)
          return;
        const idx = len > o.idx ? o.idx : len - 1;
        __privateGet2(this, _fore).setChildIndex(pg.fore.spLay, idx);
        __privateGet2(this, _back).setChildIndex(pg.back.spLay, idx);
      });
      fncComp();
    }).catch((e) => console.error(`fn:LayerMng.ts playback e:%o`, e));
  }
};
let LayerMng = _LayerMng;
_stage = new WeakMap();
_fore = new WeakMap();
_back = new WeakMap();
_frmMng = new WeakMap();
_fncTicker = new WeakMap();
_hProcDbgRes2 = new WeakMap();
_modeLn = new WeakMap();
_modeLnSub = new WeakMap();
_selectNode = new WeakSet();
selectNode_fn = function(node) {
  [__privateWrapper2(this, _modeLn)._, this._modeLnSub = ""] = node.split("/");
  const pages = __privateGet2(this, _hPages)[__privateGet2(this, _modeLn)];
  if (!pages)
    return;
  DesignCast.allHide();
  if (__privateGet2(this, _modeLnSub))
    pages.fore.showDesignCastChildren();
  else
    pages.fore.showDesignCast();
};
_grpCover = new WeakMap();
_evtMng5 = new WeakMap();
_foreachRedrawTxtLayBack = new WeakSet();
foreachRedrawTxtLayBack_fn = function(g_alpha) {
  __privateMethod2(this, _getLayers, getLayers_fn).call(this).forEach((name2) => {
    const pg = __privateGet2(this, _hPages)[name2];
    if (!(pg.fore instanceof TxtLayer))
      return;
    const pTxt = pg.fore;
    pTxt.chgBackAlpha(g_alpha);
    pg.back.chgBackAlpha(g_alpha);
  });
};
_cmdTxt = new WeakMap();
_snapshot = new WeakSet();
snapshot_fn = function(hArg) {
  const fn0 = hArg.fn ? hArg.fn.slice(0, 10) === "userdata:/" ? hArg.fn : `downloads:/${hArg.fn + getDateStr("-", "_", "", "_")}.png` : `downloads:/snapshot${getDateStr("-", "_", "", "_")}.png`;
  const fn = this.cfg.searchPath(fn0);
  if (this.sys.canCapturePage(fn))
    return false;
  const ext = getExt(fn);
  const b_color = argChk_Color(hArg, "b_color", this.cfg.oCfg.init.bg_color);
  const rnd = autoDetectRenderer({
    width: argChk_Num(hArg, "width", CmnLib.stageW),
    height: argChk_Num(hArg, "height", CmnLib.stageH),
    backgroundAlpha: b_color > 16777216 && ext === "png" ? 0 : 1,
    antialias: argChk_Boolean(hArg, "smoothing", false),
    preserveDrawingBuffer: true,
    backgroundColor: b_color & 16777215,
    autoDensity: true
  });
  const a2 = [];
  const pg = hArg.page !== "back" ? "fore" : "back";
  if (__privateGet2(this, _tiTrans).tw)
    a2.push(new Promise((re2) => {
      __privateGet2(this, _back).visible = true;
      __privateGet2(this, _aBackTransAfter).forEach((lay) => rnd.render(lay, { clear: false }));
      __privateGet2(this, _back).visible = false;
      __privateGet2(this, _spTransBack).visible = true;
      __privateGet2(this, _fore).filters = __privateGet2(this, _spTransFore).filters;
      __privateGet2(this, _fore).visible = true;
      rnd.render(__privateGet2(this, _fore), { clear: false });
      __privateGet2(this, _fore).visible = false;
      __privateGet2(this, _fore).filters = [];
      re2();
    }));
  else
    __privateMethod2(this, _getLayers, getLayers_fn).call(this, hArg.layer).forEach((v2) => a2.push(new Promise((re2) => __privateGet2(this, _hPages)[v2][pg].snapshot(rnd, () => re2()))));
  Promise.allSettled(a2).then(async () => {
    const renTx = RenderTexture.create({ width: rnd.width, height: rnd.height, transform: true });
    rnd.render(__privateGet2(this, _stage), { renderTexture: renTx });
    await this.sys.savePic(fn, rnd.plugins.extract.base64(Sprite.from(renTx)));
    if (!__privateGet2(this, _tiTrans).tw)
      __privateMethod2(this, _getLayers, getLayers_fn).call(this, hArg.layer).forEach((v2) => __privateGet2(this, _hPages)[v2][pg].snapshot_end());
    rnd.destroy(true);
  });
  return false;
};
_loadplugin = new WeakSet();
loadplugin_fn = function(hArg) {
  const { fn } = hArg;
  if (!fn)
    throw "fn\u306F\u5FC5\u9808\u3067\u3059";
  const join = argChk_Boolean(hArg, "join", true);
  switch (getExt(fn)) {
    case "css":
      (async () => {
        const res = await fetch(fn);
        if (!res.ok)
          throw new Error("Network response was not ok.");
        addStyle(await res.text());
        if (join)
          this.main.resume();
      })();
      break;
    default:
      throw "\u30B5\u30DD\u30FC\u30C8\u3055\u308C\u306A\u3044\u62E1\u5F35\u5B50\u3067\u3059";
  }
  return join;
};
_add_lay = new WeakSet();
add_lay_fn = function(hArg) {
  const { layer, class: cls } = hArg;
  if (!layer)
    throw "layer\u306F\u5FC5\u9808\u3067\u3059";
  if (layer.includes(","))
    throw "layer\u540D\u306B\u300C,\u300D\u306F\u4F7F\u3048\u307E\u305B\u3093";
  if (layer in __privateGet2(this, _hPages))
    throw `layer\u3010${layer}\u3011\u306F\u3059\u3067\u306B\u3042\u308A\u307E\u3059`;
  if (!cls)
    throw "cls\u306F\u5FC5\u9808\u3067\u3059";
  const ret = { isWait: false };
  __privateGet2(this, _hPages)[layer] = new Pages(layer, cls, __privateGet2(this, _fore), __privateGet2(this, _back), hArg, this.sys, this.val, ret);
  __privateGet2(this, _aLayName).push(layer);
  switch (cls) {
    case "txt":
      if (!__privateGet2(this, _curTxtlay)) {
        __privateSet2(this, _chkTxtLay, () => {
        });
        __privateSet2(this, _getTxtLayer, __privateMethod2(this, _$getTxtLayer, $getTxtLayer_fn));
        __privateSet2(this, _current, __privateMethod2(this, _$current, $current_fn));
        this.hTag.current({ layer });
        this.goTxt = () => {
          if (this.val.getVal("sn.skip.enabled")) {
            __privateSet2(_LayerMng, _msecChWait, 0);
          } else {
            this.setNormalChWait();
          }
          __privateMethod2(this, _getLayers, getLayers_fn).call(this).forEach((name2) => {
            const pg = __privateGet2(this, _hPages)[name2];
            if (!(pg.fore instanceof TxtLayer))
              return;
            __privateGet2(this, _cmdTxt).call(this, "gotxt\uFF5C", pg.fore, false);
          });
        };
      }
      this.val.setVal_Nochk("save", "const.sn.layer." + (layer != null ? layer : __privateGet2(this, _curTxtlay)) + ".enabled", true);
      break;
    case "grp":
      if (__privateGet2(this, _firstGrplay))
        break;
      __privateSet2(this, _firstGrplay, layer);
      break;
  }
  this.scrItr.recodeDesign(hArg);
  return ret.isWait;
};
_hPages = new WeakMap();
_aLayName = new WeakMap();
_curTxtlay = new WeakMap();
_firstGrplay = new WeakMap();
_lay = new WeakSet();
lay_fn = function(hArg) {
  const layer = __privateMethod2(this, _argChk_layer, argChk_layer_fn).call(this, hArg);
  const pg = __privateGet2(this, _hPages)[layer];
  const back = pg.back.spLay;
  const fore = pg.fore.spLay;
  if (argChk_Boolean(hArg, "float", false)) {
    __privateGet2(this, _back).setChildIndex(back, __privateGet2(this, _back).children.length - 1);
    __privateGet2(this, _fore).setChildIndex(fore, __privateGet2(this, _fore).children.length - 1);
    __privateMethod2(this, _rebuildLayerRankInfo, rebuildLayerRankInfo_fn).call(this);
  } else if (hArg.index) {
    if (argChk_Num(hArg, "index", 0)) {
      __privateGet2(this, _back).setChildIndex(back, hArg.index);
      __privateGet2(this, _fore).setChildIndex(fore, hArg.index);
      __privateMethod2(this, _rebuildLayerRankInfo, rebuildLayerRankInfo_fn).call(this);
    }
  } else if (hArg.dive) {
    const { dive } = hArg;
    let idx_dive = 0;
    if (layer === dive)
      throw "[lay] \u5C5E\u6027 layer\u3068dive\u304C\u540C\u3058\u3010" + dive + "\u3011\u3067\u3059";
    const pg_dive = __privateGet2(this, _hPages)[dive];
    if (!pg_dive)
      throw "[lay] \u5C5E\u6027 dive\u3010" + dive + "\u3011\u304C\u4E0D\u6B63\u3067\u3059\u3002\u30EC\u30A4\u30E4\u30FC\u304C\u3042\u308A\u307E\u305B\u3093";
    const back_dive = pg_dive.back;
    const fore_dive = pg_dive.fore;
    const idx_back_dive = __privateGet2(this, _back).getChildIndex(back_dive.spLay);
    const idx_fore_dive = __privateGet2(this, _fore).getChildIndex(fore_dive.spLay);
    idx_dive = idx_back_dive < idx_fore_dive ? idx_back_dive : idx_fore_dive;
    if (idx_dive > __privateGet2(this, _back).getChildIndex(back))
      --idx_dive;
    __privateGet2(this, _fore).setChildIndex(fore, idx_dive);
    __privateGet2(this, _back).setChildIndex(back, idx_dive);
    __privateMethod2(this, _rebuildLayerRankInfo, rebuildLayerRankInfo_fn).call(this);
  }
  hArg[":id_tag"] = pg.fore.name.slice(0, -7);
  this.scrItr.recodeDesign(hArg);
  return pg.lay(hArg);
};
_rebuildLayerRankInfo = new WeakSet();
rebuildLayerRankInfo_fn = function() {
  __privateSet2(this, _aLayName, __privateMethod2(this, _sortLayers, sortLayers_fn).call(this));
};
_clear_lay = new WeakSet();
clear_lay_fn = function(hArg) {
  __privateMethod2(this, _foreachLayers, foreachLayers_fn).call(this, hArg, (name2) => {
    const pg = __privateGet2(this, _hPages)[__privateMethod2(this, _argChk_layer, argChk_layer_fn).call(this, { layer: name2 })];
    if (hArg.page === "both") {
      pg.fore.clearLay(hArg);
      pg.back.clearLay(hArg);
    } else {
      pg.getPage(hArg).clearLay(hArg);
    }
  });
  return false;
};
_srcRuleTransFragment = new WeakMap();
_ufRuleTrans = new WeakMap();
_fltRule = new WeakMap();
_rtTransBack = new WeakMap();
_spTransBack = new WeakMap();
_rtTransFore = new WeakMap();
_spTransFore = new WeakMap();
_aBackTransAfter = new WeakMap();
_trans = new WeakSet();
trans_fn = function(hArg) {
  __privateMethod2(this, _finish_trans, finish_trans_fn).call(this);
  const ease = CmnTween.ease(hArg.ease);
  __privateSet2(this, _aBackTransAfter, []);
  const hTarget = {};
  const aFore = [];
  __privateMethod2(this, _getLayers, getLayers_fn).call(this, hArg.layer).forEach((lay_nm) => {
    hTarget[lay_nm] = true;
    aFore.push(__privateGet2(this, _hPages)[lay_nm].fore);
  });
  const aBack = [];
  __privateMethod2(this, _getLayers, getLayers_fn).call(this).forEach((lay_nm) => {
    const lay = __privateGet2(this, _hPages)[lay_nm][hTarget[lay_nm] ? "back" : "fore"];
    __privateGet2(this, _aBackTransAfter).push(lay.spLay);
    aBack.push(lay);
  });
  __privateGet2(this, _rtTransBack).resize(CmnLib.stageW, CmnLib.stageH);
  this.appPixi.renderer.render(__privateGet2(this, _back), { renderTexture: __privateGet2(this, _rtTransBack) });
  let fncRenderBack = () => {
    __privateGet2(this, _back).visible = true;
    __privateGet2(this, _aBackTransAfter).forEach((spLay) => {
      this.appPixi.renderer.render(spLay, { renderTexture: __privateGet2(this, _rtTransBack), clear: false });
    });
    __privateGet2(this, _back).visible = false;
  };
  if (!aBack.some((lay) => lay.containMovement)) {
    let oldFnc = fncRenderBack;
    fncRenderBack = () => {
      fncRenderBack = () => {
      };
      oldFnc();
    };
  }
  __privateGet2(this, _rtTransFore).resize(CmnLib.stageW, CmnLib.stageH);
  this.appPixi.renderer.render(__privateGet2(this, _fore), { renderTexture: __privateGet2(this, _rtTransFore) });
  let fncRenderFore = () => {
    __privateGet2(this, _fore).visible = true;
    this.appPixi.renderer.render(__privateGet2(this, _fore), { renderTexture: __privateGet2(this, _rtTransFore) });
    __privateGet2(this, _fore).visible = false;
  };
  if (!aFore.some((lay) => lay.containMovement)) {
    let oldFnc = fncRenderFore;
    fncRenderFore = () => {
      fncRenderFore = () => {
      };
      oldFnc();
    };
  }
  const fncRender = () => {
    fncRenderBack();
    __privateGet2(this, _spTransBack).visible = true;
    fncRenderFore();
    __privateGet2(this, _spTransFore).visible = true;
  };
  __privateGet2(this, _spTransFore).alpha = 1;
  const comp = () => {
    var _a3;
    if (this.appPixi.ticker)
      this.appPixi.ticker.remove(fncRender);
    [__privateWrapper2(this, _fore)._, __privateWrapper2(this, _back)._] = [__privateGet2(this, _back), __privateGet2(this, _fore)];
    const aPrm = [];
    for (const lay_name in __privateGet2(this, _hPages)) {
      const pg = __privateGet2(this, _hPages)[lay_name];
      if (hTarget[lay_name]) {
        pg.transPage(aPrm);
        continue;
      }
      const idx = __privateGet2(this, _fore).getChildIndex(pg.back.spLay);
      __privateGet2(this, _fore).removeChild(pg.back.spLay);
      __privateGet2(this, _back).removeChild(pg.fore.spLay);
      __privateGet2(this, _fore).addChildAt(pg.fore.spLay, idx);
      __privateGet2(this, _back).addChildAt(pg.back.spLay, idx);
    }
    Promise.allSettled(aPrm);
    __privateGet2(this, _fore).visible = true;
    __privateGet2(this, _back).visible = false;
    __privateGet2(this, _spTransBack).visible = false;
    __privateGet2(this, _spTransFore).visible = false;
    (_a3 = __privateGet2(this, _tiTrans).tw) == null ? void 0 : _a3.stop();
    if (__privateGet2(this, _tiTrans).resume)
      this.main.resume();
    __privateSet2(this, _tiTrans, { tw: void 0, resume: false });
  };
  __privateSet2(this, _tiTrans, { tw: void 0, resume: false });
  const time = argChk_Num(hArg, "time", 0);
  if (time === 0 || __privateGet2(this, _evtMng5).isSkippingByKeyDown()) {
    comp();
    return false;
  }
  const is_glsl = "glsl" in hArg;
  if (!is_glsl && !("rule" in hArg)) {
    __privateGet2(this, _spTransFore).filters = [];
    __privateGet2(this, _tiTrans).tw = new Tween(__privateGet2(this, _spTransFore)).to({ alpha: 0 }, time).delay(argChk_Num(hArg, "delay", 0)).easing(ease).onComplete(comp).start();
    this.appPixi.ticker.add(fncRender);
    return false;
  }
  const flt = is_glsl ? new Filter(void 0, hArg.glsl, __privateGet2(this, _ufRuleTrans)) : __privateGet2(this, _fltRule);
  flt.uniforms.vague = argChk_Num(hArg, "vague", 0.04);
  flt.uniforms.tick = 0;
  __privateGet2(this, _tiTrans).tw = new Tween(flt.uniforms).to({ tick: 1 }, time).delay(argChk_Num(hArg, "delay", 0)).easing(ease).onComplete(comp);
  __privateGet2(this, _spTransFore).filters = [flt];
  if (is_glsl) {
    __privateGet2(this, _tiTrans).tw.start();
    this.appPixi.ticker.add(fncRender);
    return false;
  }
  if (!hArg.rule)
    throw "rule\u304C\u6307\u5B9A\u3055\u308C\u3066\u3044\u307E\u305B\u3093";
  GrpLayer.csv2Sprites(hArg.rule, void 0, (sp) => {
    var _a3;
    flt.uniforms.rule = sp.texture;
    sp.destroy();
    (_a3 = __privateGet2(this, _tiTrans).tw) == null ? void 0 : _a3.start();
    this.appPixi.ticker.add(fncRender);
  });
  return false;
};
_tiTrans = new WeakMap();
_getLayers = new WeakSet();
getLayers_fn = function(layer = "") {
  return layer ? layer.split(",") : __privateGet2(this, _aLayName);
};
_foreachLayers = new WeakSet();
foreachLayers_fn = function(hArg, fnc) {
  const vct = __privateMethod2(this, _getLayers, getLayers_fn).call(this, hArg.layer);
  vct.forEach((name2) => {
    if (!name2)
      return;
    const pg = __privateGet2(this, _hPages)[name2];
    if (!pg)
      throw "\u5B58\u5728\u3057\u306A\u3044layer\u3010" + name2 + "\u3011\u3067\u3059";
    fnc(name2, pg);
  });
  return vct;
};
_sortLayers = new WeakSet();
sortLayers_fn = function(layers = "") {
  return __privateMethod2(this, _getLayers, getLayers_fn).call(this, layers).sort((a2, b2) => {
    const ai = __privateGet2(this, _fore).getChildIndex(__privateGet2(this, _hPages)[a2].fore.spLay);
    const bi = __privateGet2(this, _fore).getChildIndex(__privateGet2(this, _hPages)[b2].fore.spLay);
    if (ai < bi)
      return -1;
    if (ai > bi)
      return 1;
    return 0;
  });
};
_wt = new WeakSet();
wt_fn = function(hArg) {
  if (!__privateGet2(this, _tiTrans).tw)
    return false;
  __privateGet2(this, _tiTrans).resume = true;
  return __privateGet2(this, _evtMng5).waitLimitedEvent(hArg, () => __privateMethod2(this, _finish_trans, finish_trans_fn).call(this));
};
_finish_trans = new WeakSet();
finish_trans_fn = function() {
  var _a3;
  (_a3 = __privateGet2(this, _tiTrans).tw) == null ? void 0 : _a3.end();
  return false;
};
_quake = new WeakSet();
quake_fn = function(hArg) {
  __privateMethod2(this, _finish_trans, finish_trans_fn).call(this);
  const time = argChk_Num(hArg, "time", NaN);
  if (time === 0)
    return false;
  if (this.val.getVal("tmp:sn.skip.enabled"))
    return false;
  if (__privateGet2(this, _evtMng5).isSkippingByKeyDown())
    return false;
  const aDo = [];
  __privateMethod2(this, _getLayers, getLayers_fn).call(this, hArg.layer).forEach((lay_nm) => {
    aDo.push(__privateGet2(this, _hPages)[lay_nm].fore.spLay);
  });
  __privateGet2(this, _rtTransFore).resize(CmnLib.stageW, CmnLib.stageH);
  const fncRender = () => {
    __privateGet2(this, _fore).visible = true;
    aDo.forEach((lay) => this.appPixi.renderer.render(lay, { renderTexture: __privateGet2(this, _rtTransFore), clear: false }));
    __privateGet2(this, _fore).visible = false;
  };
  __privateGet2(this, _spTransFore).visible = true;
  __privateGet2(this, _spTransFore).alpha = 1;
  const h2 = uint(argChk_Num(hArg, "hmax", 10));
  const v2 = uint(argChk_Num(hArg, "vmax", 10));
  const fncH = h2 === 0 ? () => {
  } : () => __privateGet2(this, _spTransFore).x = Math.round(Math.random() * h2 * 2) - h2;
  const fncV = v2 === 0 ? () => {
  } : () => __privateGet2(this, _spTransFore).y = Math.round(Math.random() * v2 * 2) - v2;
  __privateGet2(this, _spTransFore).filters = [];
  const repeat = argChk_Num(hArg, "repeat", 1);
  const tw = new Tween(__privateGet2(this, _spTransFore)).to({ x: 0, y: 0 }, time).delay(argChk_Num(hArg, "delay", 0)).easing(CmnTween.ease(hArg.ease)).onUpdate(() => {
    fncH();
    fncV();
  }).repeat(repeat === 0 ? Infinity : repeat - 1).yoyo(argChk_Boolean(hArg, "yoyo", false)).onComplete(() => {
    var _a3, _b3;
    (_a3 = this.appPixi.ticker) == null ? void 0 : _a3.remove(fncRender);
    __privateGet2(this, _fore).visible = true;
    __privateGet2(this, _spTransFore).visible = false;
    __privateGet2(this, _spTransFore).x = 0;
    __privateGet2(this, _spTransFore).y = 0;
    (_b3 = __privateGet2(this, _tiTrans).tw) == null ? void 0 : _b3.stop();
    if (__privateGet2(this, _tiTrans).resume)
      this.main.resume();
    __privateSet2(this, _tiTrans, { tw: void 0, resume: false });
  }).start();
  __privateSet2(this, _tiTrans, { tw, resume: false });
  this.appPixi.ticker.add(fncRender);
  return false;
};
_hTwInf = new WeakMap();
_tsy = new WeakSet();
tsy_fn = function(hArg) {
  var _a3, _b3;
  if (!hArg.layer)
    throw "layer\u306F\u5FC5\u9808\u3067\u3059";
  const layer = __privateMethod2(this, _argChk_layer, argChk_layer_fn).call(this, hArg);
  let foreLay = __privateGet2(this, _hPages)[layer].fore;
  let finishBlendLayer = () => {
  };
  const isSkip = __privateGet2(this, _evtMng5).isSkippingByKeyDown();
  if (!isSkip && "render" in hArg) {
    foreLay.renderStart();
    finishBlendLayer = () => foreLay.renderEnd();
  }
  const hTo = cnvTweenArg(hArg, foreLay);
  const repeat = argChk_Num(hArg, "repeat", 1);
  const tw_nm = (_a3 = hArg.name) != null ? _a3 : hArg.layer;
  const tw = new Tween(foreLay).to(hTo, argChk_Num(hArg, "time", NaN) * (Boolean(this.val.getVal("tmp:sn.skip.enabled") || isSkip) ? 0 : 1)).delay(argChk_Num(hArg, "delay", 0)).easing(CmnTween.ease(hArg.ease)).repeat(repeat === 0 ? Infinity : repeat - 1).yoyo(argChk_Boolean(hArg, "yoyo", false)).onComplete(() => {
    var _a4, _b4;
    const ti = __privateGet2(this, _hTwInf)[tw_nm];
    if (!ti)
      return;
    finishBlendLayer();
    delete __privateGet2(this, _hTwInf)[tw_nm];
    (_a4 = ti.tw) == null ? void 0 : _a4.stop();
    if (ti.resume)
      this.main.resume();
    (_b4 = ti.onEnd) == null ? void 0 : _b4.call(ti);
  });
  if ("chain" in hArg) {
    const twFrom = __privateGet2(this, _hTwInf)[(_b3 = hArg.chain) != null ? _b3 : ""];
    if (!(twFrom == null ? void 0 : twFrom.tw))
      throw `${hArg.chain}\u306F\u5B58\u5728\u3057\u306A\u3044\u30FB\u307E\u305F\u306F\u7D42\u4E86\u3057\u305F\u30C8\u30A5\u30A4\u30FC\u30F3\u3067\u3059`;
    delete twFrom.onEnd;
    twFrom.tw.chain(tw);
  } else
    tw.start();
  const arrive = argChk_Boolean(hArg, "arrive", false);
  const backlay = argChk_Boolean(hArg, "backlay", false);
  __privateGet2(this, _hTwInf)[tw_nm] = { tw, resume: false, onEnd: () => {
    if (arrive)
      Object.assign(foreLay, hTo);
    if (backlay) {
      const backCnt = __privateGet2(this, _hPages)[layer].back.spLay;
      for (const nm in hMemberCnt)
        backCnt[nm] = foreLay[nm];
    }
  } };
  return false;
};
_wait_tsy = new WeakSet();
wait_tsy_fn = function(hArg) {
  var _a3;
  const tw_nm = "id" in hArg ? `frm
${hArg.id}` : (_a3 = hArg.name) != null ? _a3 : hArg.layer;
  if (!tw_nm)
    throw "\u30C8\u30A5\u30A4\u30FC\u30F3\u304C\u6307\u5B9A\u3055\u308C\u3066\u3044\u307E\u305B\u3093";
  const ti = __privateGet2(this, _hTwInf)[tw_nm];
  if (!(ti == null ? void 0 : ti.tw))
    return false;
  return ti.resume = __privateGet2(this, _evtMng5).waitEvent(() => {
    var _a4;
    return (_a4 = ti.tw) == null ? void 0 : _a4.end();
  }, argChk_Boolean(hArg, "canskip", true), argChk_Boolean(hArg, "global", false));
};
_stop_tsy = new WeakSet();
stop_tsy_fn = function(hArg) {
  var _a3, _b3, _c3;
  const tw_nm = "id" in hArg ? `frm
${hArg.id}` : (_a3 = hArg.name) != null ? _a3 : hArg.layer;
  if (!tw_nm)
    throw "\u30C8\u30A5\u30A4\u30FC\u30F3\u304C\u6307\u5B9A\u3055\u308C\u3066\u3044\u307E\u305B\u3093";
  (_c3 = (_b3 = __privateGet2(this, _hTwInf)[tw_nm]) == null ? void 0 : _b3.tw) == null ? void 0 : _c3.end();
  return false;
};
_pause_tsy = new WeakSet();
pause_tsy_fn = function(hArg) {
  var _a3, _b3, _c3;
  const tw_nm = "id" in hArg ? `frm
${hArg.id}` : (_a3 = hArg.name) != null ? _a3 : hArg.layer;
  if (!tw_nm)
    throw "\u30C8\u30A5\u30A4\u30FC\u30F3\u304C\u6307\u5B9A\u3055\u308C\u3066\u3044\u307E\u305B\u3093";
  (_c3 = (_b3 = __privateGet2(this, _hTwInf)[tw_nm]) == null ? void 0 : _b3.tw) == null ? void 0 : _c3.pause();
  return false;
};
_resume_tsy = new WeakSet();
resume_tsy_fn = function(hArg) {
  var _a3, _b3, _c3;
  const tw_nm = "id" in hArg ? `frm
${hArg.id}` : (_a3 = hArg.name) != null ? _a3 : hArg.layer;
  if (!tw_nm)
    throw "\u30C8\u30A5\u30A4\u30FC\u30F3\u304C\u6307\u5B9A\u3055\u308C\u3066\u3044\u307E\u305B\u3093";
  (_c3 = (_b3 = __privateGet2(this, _hTwInf)[tw_nm]) == null ? void 0 : _b3.tw) == null ? void 0 : _c3.resume();
  return false;
};
_msecChWait = new WeakMap();
_ch = new WeakSet();
ch_fn = function(hArg) {
  const { text: text2 } = hArg;
  if (!text2)
    throw "text\u306F\u5FC5\u9808\u3067\u3059";
  const tl = __privateGet2(this, _getTxtLayer).call(this, hArg);
  delete hArg.text;
  if (this.val.getVal("tmp:sn.skip.enabled"))
    hArg.wait = 0;
  else if ("wait" in hArg)
    argChk_Num(hArg, "wait", NaN);
  const record = argChk_Boolean(hArg, "record", true);
  const doRecLog = this.val.doRecLog();
  if (!record)
    this.val.setVal_Nochk("save", "sn.doRecLog", record);
  tl.tagCh(text2.replaceAll("[r]", "\n"));
  if (!record)
    this.val.setVal_Nochk("save", "sn.doRecLog", doRecLog);
  return false;
};
_getTxtLayer = new WeakMap();
_$getTxtLayer = new WeakSet();
$getTxtLayer_fn = function(hArg) {
  const layer = __privateMethod2(this, _argChk_layer, argChk_layer_fn).call(this, hArg, __privateGet2(this, _curTxtlay));
  const pg = __privateGet2(this, _hPages)[layer];
  const lay = pg.getPage(hArg);
  if (!(lay instanceof TxtLayer))
    throw layer + "\u306FTxtLayer\u3067\u306F\u3042\u308A\u307E\u305B\u3093";
  const tf = lay;
  return tf;
};
_current = new WeakMap();
_$current = new WeakSet();
$current_fn = function(hArg) {
  const { layer } = hArg;
  if (!layer)
    throw "[current] layer\u306F\u5FC5\u9808\u3067\u3059";
  __privateSet2(this, _pgTxtlay, __privateGet2(this, _hPages)[layer]);
  if (!(__privateGet2(this, _pgTxtlay).getPage(hArg) instanceof TxtLayer))
    throw `${layer}\u306FTxtLayer\u3067\u306F\u3042\u308A\u307E\u305B\u3093`;
  this.recText("", true);
  __privateSet2(this, _curTxtlay, layer);
  this.val.setVal_Nochk("save", "const.sn.mesLayer", layer);
  __privateMethod2(this, _getLayers, getLayers_fn).call(this).forEach((name2) => {
    const pg = __privateGet2(this, _hPages)[name2];
    if (!(pg.fore instanceof TxtLayer))
      return;
    pg.fore.isCur = pg.back.isCur = name2 === layer;
  });
  return false;
};
_pgTxtlay = new WeakMap();
_chkTxtLay = new WeakMap();
_argChk_layer = new WeakSet();
argChk_layer_fn = function(hash2, def = "") {
  var _a3;
  const v2 = (_a3 = hash2.layer) != null ? _a3 : def;
  if (v2.includes(","))
    throw "layer\u540D\u306B\u300C,\u300D\u306F\u4F7F\u3048\u307E\u305B\u3093";
  if (!(v2 in __privateGet2(this, _hPages)))
    throw "\u5C5E\u6027 layer\u3010" + v2 + "\u3011\u304C\u4E0D\u6B63\u3067\u3059\u3002\u30EC\u30A4\u30E4\u30FC\u304C\u3042\u308A\u307E\u305B\u3093";
  return hash2.layer = v2;
};
_oLastPage = new WeakMap();
_aTxtLog = new WeakMap();
_clear_text = new WeakSet();
clear_text_fn = function(hArg) {
  const tf = __privateGet2(this, _getTxtLayer).call(this, hArg);
  if (hArg.layer === __privateGet2(this, _curTxtlay) && hArg.page === "fore")
    this.recText("", true);
  tf.clearText();
  return false;
};
_endlink = new WeakSet();
endlink_fn = function(hArg) {
  __privateGet2(this, _cmdTxt).call(this, "endlink\uFF5C", __privateGet2(this, _getTxtLayer).call(this, hArg));
  return false;
};
_er = new WeakSet();
er_fn = function(hArg) {
  if (argChk_Boolean(hArg, "rec_page_break", true))
    this.recText("", true);
  if (__privateGet2(this, _pgTxtlay)) {
    __privateGet2(this, _pgTxtlay).fore.clearLay(hArg);
    __privateGet2(this, _pgTxtlay).back.clearLay(hArg);
  }
  return false;
};
_graph = new WeakSet();
graph_fn = function(hArg) {
  if (!hArg.pic)
    throw "[graph] pic\u306F\u5FC5\u9808\u3067\u3059";
  hArg.text = "\uFF5C\u3000\u300Agrp\uFF5C" + JSON.stringify(hArg) + "\u300B";
  return __privateMethod2(this, _ch, ch_fn).call(this, hArg);
};
_link = new WeakSet();
link_fn = function(hArg) {
  var _a3, _b3, _c3;
  (_a3 = hArg.style) != null ? _a3 : hArg.style = "background-color: rgba(255,0,0,0.5);";
  (_b3 = hArg.style_hover) != null ? _b3 : hArg.style_hover = "background-color: rgba(255,0,0,0.9);";
  (_c3 = hArg.style_clicked) != null ? _c3 : hArg.style_clicked = hArg.style;
  __privateGet2(this, _cmdTxt).call(this, "link\uFF5C" + JSON.stringify(hArg), __privateGet2(this, _getTxtLayer).call(this, hArg));
  return false;
};
_r = new WeakSet();
r_fn = function(hArg) {
  hArg.text = "\n";
  return __privateMethod2(this, _ch, ch_fn).call(this, hArg);
};
_rec_r = new WeakSet();
rec_r_fn = function() {
  this.recText("\n");
  return false;
};
_rec_ch = new WeakSet();
rec_ch_fn = function(hArg) {
  var _a3;
  __privateSet2(this, _oLastPage, hArg);
  this.recText((_a3 = hArg.text) != null ? _a3 : "");
  return false;
};
_reset_rec = new WeakSet();
reset_rec_fn = function(hArg) {
  var _a3;
  __privateSet2(this, _aTxtLog, []);
  __privateSet2(this, _oLastPage, { text: (_a3 = hArg.text) != null ? _a3 : "" });
  this.val.setVal_Nochk("save", "const.sn.sLog", hArg.text ? `[{text:"${hArg.text}"}]` : "[]");
  return false;
};
_ruby2 = new WeakSet();
ruby2_fn = function(hArg) {
  const { t, r: r2 } = hArg;
  if (!t)
    throw "[ruby2] t\u306F\u5FC5\u9808\u3067\u3059";
  if (!r2)
    throw "[ruby2] r\u306F\u5FC5\u9808\u3067\u3059";
  hArg.text = "\uFF5C" + t + "\u300A" + r2 + "\u300B";
  return __privateMethod2(this, _ch, ch_fn).call(this, hArg);
};
_span = new WeakSet();
span_fn = function(hArg) {
  __privateGet2(this, _cmdTxt).call(this, "span\uFF5C" + JSON.stringify(hArg), __privateGet2(this, _getTxtLayer).call(this, hArg));
  return false;
};
_tcy = new WeakSet();
tcy_fn = function(hArg) {
  var _a3;
  if (!hArg.t)
    throw "[tcy] t\u306F\u5FC5\u9808\u3067\u3059";
  hArg.text = "\uFF5C\u3000\u300Atcy\uFF5C" + hArg.t + "\uFF5C" + ((_a3 = hArg.r) != null ? _a3 : "") + "\u300B";
  return __privateMethod2(this, _ch, ch_fn).call(this, hArg);
};
_dump_lay = new WeakSet();
dump_lay_fn = function(hArg) {
  console.group("\u{1F95F} [dump_lay]");
  __privateMethod2(this, _getLayers, getLayers_fn).call(this, hArg.layer).forEach((name2) => {
    const pg = __privateGet2(this, _hPages)[name2];
    try {
      console.info(`%c${pg.fore.name.slice(0, -7)} %o`, `color:#${CmnLib.isDarkMode ? "49F" : "05A"};`, JSON.parse(`{"back":{${pg.back.dump()}}, "fore":{${pg.fore.dump()}}}`));
    } catch (error) {
      console.error(`dump_lay err:%o`, error);
      console.error(`   back:${pg.back.dump()}`);
      console.error(`   fore:${pg.fore.dump()}`);
    }
  });
  console.groupEnd();
  return false;
};
_enable_event = new WeakSet();
enable_event_fn = function(hArg) {
  const layer = __privateMethod2(this, _argChk_layer, argChk_layer_fn).call(this, hArg, __privateGet2(this, _curTxtlay));
  const v2 = argChk_Boolean(hArg, "enabled", true);
  __privateGet2(this, _getTxtLayer).call(this, hArg).enabled = v2;
  this.val.setVal_Nochk("save", "const.sn.layer." + layer + ".enabled", v2);
  return false;
};
_button = new WeakSet();
button_fn = function(hArg) {
  var _a3, _b3, _c3;
  Pages.argChk_page(hArg, "back");
  (_a3 = hArg.clicksebuf) != null ? _a3 : hArg.clicksebuf = "SYS";
  (_b3 = hArg.entersebuf) != null ? _b3 : hArg.entersebuf = "SYS";
  (_c3 = hArg.leavesebuf) != null ? _c3 : hArg.leavesebuf = "SYS";
  if (!hArg.fn)
    hArg.fn = this.scrItr.scriptFn;
  __privateGet2(this, _getTxtLayer).call(this, hArg).addButton(hArg);
  this.scrItr.recodeDesign(hArg);
  return false;
};
__privateAdd2(LayerMng, _msecChWait, 10);
class FocusMng {
  constructor() {
    __privateAdd2(this, _radio_next);
    __privateAdd2(this, _allOff);
    __privateAdd2(this, _aBtn, []);
    __privateAdd2(this, _idx, -1);
    __privateAdd2(this, _logFocus, CmnLib.debugLog ? (i2) => console.log(`\u{1F47E} <FocusMng idx:${i2} btn:%o`, __privateGet2(this, _aBtn)[i2].btn) : () => {
    });
  }
  destroy() {
    __privateSet2(this, _aBtn, []);
    __privateSet2(this, _idx, -1);
  }
  add(cmp, on2, off) {
    var _a3;
    if (__privateGet2(this, _aBtn).findIndex((b2) => b2.btn === cmp) >= 0)
      return;
    if (cmp instanceof Container) {
      cmp.on("pointerdown", () => {
        for (let i2 = __privateGet2(this, _aBtn).length - 1; i2 >= 0; --i2) {
          const b2 = __privateGet2(this, _aBtn)[i2];
          if (b2.btn === cmp) {
            __privateSet2(this, _idx, i2);
            return;
          }
        }
        __privateSet2(this, _idx, -1);
      });
      __privateGet2(this, _aBtn).push({ btn: cmp, on: on2, off });
      return;
    }
    cmp.addEventListener("focus", () => {
      for (let i2 = __privateGet2(this, _aBtn).length - 1; i2 >= 0; --i2) {
        const b2 = __privateGet2(this, _aBtn)[i2];
        if (b2.btn === cmp) {
          __privateSet2(this, _idx, i2);
          return;
        }
      }
      __privateSet2(this, _idx, -1);
    });
    let fnc = (_2) => {
    };
    let fnc4EnterSwitch = cmp.localName === "button" || cmp.localName === "a" ? (e) => !e.isTrusted && e.key === "Enter" : (e) => e.key === "Enter";
    const inp = cmp;
    switch ((_a3 = inp.type) != null ? _a3 : "") {
      case "checkbox":
        fnc = () => inp.checked = !inp.checked;
        break;
      case "":
        if (cmp.querySelectorAll("input[type]").length > 0) {
          fnc = (e) => __privateMethod2(this, _radio_next, radio_next_fn).call(this, cmp, e.key);
          fnc4EnterSwitch = () => false;
        }
        break;
      case "range":
        fnc = (e) => {
          if (e.isTrusted)
            return;
          if (e.key === "ArrowUp")
            inp.stepUp();
          else
            inp.stepDown();
        };
        break;
      case "text":
      case "textarea":
        fnc = (e) => {
          var _a4;
          if (e.isTrusted)
            return;
          let cur = ((_a4 = inp.selectionStart) != null ? _a4 : 0) + (e.key === "ArrowUp" ? -1 : 1);
          if (cur < 0)
            cur = 0;
          inp.setSelectionRange(cur, cur);
        };
        break;
    }
    cmp.addEventListener("keydown", (e) => {
      if (e.key !== "ArrowUp" && e.key !== "ArrowDown" && e.key !== "Enter")
        return;
      e.stopPropagation();
      e.stopImmediatePropagation();
      if (fnc4EnterSwitch(e)) {
        cmp.dispatchEvent(new MouseEvent("click"));
        return;
      }
      fnc(e);
    }, { passive: true });
    if (!cmp.hasAttribute("tabindex"))
      cmp.tabIndex = 0;
    __privateGet2(this, _aBtn).push({ btn: cmp, on: on2, off });
  }
  remove(cmp) {
    const idx = __privateGet2(this, _aBtn).findIndex((b2) => b2.btn === cmp);
    if (idx < 0)
      return;
    __privateGet2(this, _aBtn).splice(idx, 1);
    if (__privateGet2(this, _aBtn).length === 0)
      __privateSet2(this, _idx, -1);
    else if (idx <= __privateGet2(this, _idx))
      --__privateWrapper2(this, _idx)._;
  }
  isFocus(cmp) {
    if (__privateGet2(this, _idx) < 0)
      return false;
    return __privateGet2(this, _aBtn)[__privateGet2(this, _idx)].btn === cmp;
  }
  prev() {
    __privateMethod2(this, _allOff, allOff_fn).call(this);
    const len = __privateGet2(this, _aBtn).length;
    if (len === 0)
      return;
    if (--__privateWrapper2(this, _idx)._ < 0)
      __privateSet2(this, _idx, len - 1);
    for (let i2 = len; i2 >= 1; --i2) {
      const j2 = (__privateGet2(this, _idx) + i2) % len;
      if (__privateGet2(this, _aBtn)[j2].on()) {
        __privateSet2(this, _idx, j2);
        __privateGet2(this, _logFocus).call(this, j2);
        return;
      }
    }
    __privateSet2(this, _idx, -1);
  }
  next() {
    __privateMethod2(this, _allOff, allOff_fn).call(this);
    const len = __privateGet2(this, _aBtn).length;
    if (len === 0)
      return;
    if (++__privateWrapper2(this, _idx)._ >= len)
      __privateSet2(this, _idx, 0);
    for (let i2 = 0; i2 < len; ++i2) {
      const j2 = (__privateGet2(this, _idx) + i2) % len;
      if (__privateGet2(this, _aBtn)[j2].on()) {
        __privateSet2(this, _idx, j2);
        __privateGet2(this, _logFocus).call(this, j2);
        return;
      }
    }
    __privateSet2(this, _idx, -1);
  }
  getFocus() {
    if (__privateGet2(this, _idx) < 0)
      return void 0;
    __privateMethod2(this, _allOff, allOff_fn).call(this);
    if (__privateGet2(this, _idx) >= __privateGet2(this, _aBtn).length)
      __privateSet2(this, _idx, 0);
    const b2 = __privateGet2(this, _aBtn)[__privateGet2(this, _idx)];
    return b2.on() ? b2.btn : void 0;
  }
  blur() {
    __privateMethod2(this, _allOff, allOff_fn).call(this);
    __privateSet2(this, _idx, -1);
    globalThis.focus();
  }
}
_aBtn = new WeakMap();
_idx = new WeakMap();
_radio_next = new WeakSet();
radio_next_fn = function(elm, key) {
  const op = elm.querySelectorAll("input[type]");
  const len = op.length;
  for (let i2 = 0; i2 < len; ++i2) {
    if (!op[i2].checked)
      continue;
    op[(i2 + len + (key === "ArrowUp" ? -1 : 1)) % len].checked = true;
    break;
  }
};
_logFocus = new WeakMap();
_allOff = new WeakSet();
allOff_fn = function() {
  for (let i2 = __privateGet2(this, _aBtn).length - 1; i2 >= 0; --i2) {
    const b2 = __privateGet2(this, _aBtn)[i2];
    if (!(b2.btn instanceof Container) || b2.btn.parent)
      b2.off();
    else
      __privateGet2(this, _aBtn).splice(i2, 1);
  }
};
const { GamepadListener } = require("gamepad.js");
class EventMng {
  constructor(cfg, hTag, appPixi, main2, layMng, val, sndMng, scrItr, sys) {
    __privateAdd2(this, _ev_keydown);
    __privateAdd2(this, _ev_contextmenu);
    __privateAdd2(this, _ev_wheel);
    __privateAdd2(this, _ev_wheel_waitstop);
    __privateAdd2(this, _waitEventBase);
    __privateAdd2(this, _dispHint);
    __privateAdd2(this, _clear_event);
    __privateAdd2(this, _clear_eventer);
    __privateAdd2(this, _event);
    __privateAdd2(this, _canFocus);
    __privateAdd2(this, _getHtmlElmList);
    __privateAdd2(this, _l);
    __privateAdd2(this, _p);
    __privateAdd2(this, _set_cancel_skip);
    __privateAdd2(this, _set_focus);
    __privateAdd2(this, _wait);
    __privateAdd2(this, _waitclick);
    __privateAdd2(this, _elc2, void 0);
    __privateAdd2(this, _cvsHint, void 0);
    __privateAdd2(this, _picHint_w, void 0);
    __privateAdd2(this, _picHint_h, void 0);
    __privateAdd2(this, _padHint, void 0);
    __privateAdd2(this, _grpHint, void 0);
    __privateAdd2(this, _gamepad, void 0);
    __privateAdd2(this, _fcs, void 0);
    __privateAdd2(this, _resvFlameEvent4Wheel, void 0);
    __privateAdd2(this, _wheeling, void 0);
    __privateAdd2(this, _extend_wheel, void 0);
    __privateAdd2(this, _hLocalEvt2Fnc, void 0);
    __privateAdd2(this, _hGlobalEvt2Fnc, void 0);
    __privateAdd2(this, _isDbgBreak, void 0);
    __privateAdd2(this, _isWait, void 0);
    __privateAdd2(this, _getEvt2Fnc, void 0);
    __privateAdd2(this, _firstWait, void 0);
    __privateAdd2(this, _dispHint_hArg, void 0);
    __privateAdd2(this, _dispHint_ctnBtn, void 0);
    __privateAdd2(this, _dispHint_masume, void 0);
    __privateAdd2(this, _procWheel4wle, void 0);
    __privateAdd2(this, _elcWLE, void 0);
    __privateAdd2(this, _goTxt, void 0);
    __privateAdd2(this, _stopSkip, void 0);
    __privateAdd2(this, _cancelWait, void 0);
    __privateAdd2(this, _hDownKeys, void 0);
    this.cfg = cfg;
    this.hTag = hTag;
    this.appPixi = appPixi;
    this.main = main2;
    this.layMng = layMng;
    this.val = val;
    this.sndMng = sndMng;
    this.scrItr = scrItr;
    this.sys = sys;
    __privateSet2(this, _elc2, new EventListenerCtn());
    __privateSet2(this, _cvsHint, document.createElement("canvas"));
    __privateSet2(this, _picHint_w, 100);
    __privateSet2(this, _picHint_h, 50);
    __privateSet2(this, _grpHint, new Graphics());
    this.setTxtHint = (_txt, _fillStyle, _hint_font) => {
    };
    __privateSet2(this, _gamepad, new GamepadListener({
      analog: false,
      deadZone: 0.3
    }));
    __privateSet2(this, _fcs, new FocusMng());
    __privateSet2(this, _resvFlameEvent4Wheel, (_win) => {
    });
    __privateSet2(this, _wheeling, false);
    __privateSet2(this, _extend_wheel, false);
    __privateSet2(this, _hLocalEvt2Fnc, {});
    __privateSet2(this, _hGlobalEvt2Fnc, {});
    __privateSet2(this, _isDbgBreak, false);
    __privateSet2(this, _isWait, false);
    __privateSet2(this, _getEvt2Fnc, (key) => {
      var _a3;
      return (_a3 = __privateGet2(this, _hLocalEvt2Fnc)[key]) != null ? _a3 : __privateGet2(this, _hGlobalEvt2Fnc)[key];
    });
    __privateSet2(this, _firstWait, () => {
      __privateSet2(this, _firstWait, () => {
      });
      this.scrItr.firstWait();
    });
    __privateSet2(this, _dispHint_masume, (hArg, ctnBtn, rctBtn, isLink, hint_width, hint_tate) => {
      __privateGet2(this, _grpHint).zIndex = 1e3;
      __privateGet2(this, _grpHint).x = rctBtn.x;
      __privateGet2(this, _grpHint).y = rctBtn.y;
      __privateGet2(this, _grpHint).rotation = ctnBtn.rotation;
      const p2 = (isLink ? ctnBtn.parent : ctnBtn).scale;
      const isBtnPic = hArg[":\u30BF\u30B0\u540D"] === "button" && hArg.pic;
      __privateGet2(this, _grpHint).clear().beginFill(3407616, 0.2).lineStyle(1, 3407616, 1).drawRect(0, 0, rctBtn.width, rctBtn.height).endFill().beginFill(13311, 0.2).lineStyle(2, 13311, 1);
      if (hint_tate)
        __privateGet2(this, _grpHint).drawRect(isLink ? rctBtn.height : rctBtn.width, ((isLink ? rctBtn.width : rctBtn.height) - hint_width) / 2, __privateGet2(this, _picHint_h) * (isBtnPic ? 1 : p2.x), hint_width * (isBtnPic ? 1 : p2.y));
      else
        __privateGet2(this, _grpHint).drawRect((rctBtn.width - hint_width) / 2, -__privateGet2(this, _picHint_h), hint_width * (isBtnPic ? 1 : p2.x), __privateGet2(this, _picHint_h) * (isBtnPic ? 1 : p2.y));
      __privateGet2(this, _grpHint).endFill();
    });
    __privateSet2(this, _procWheel4wle, (_elc3, _fnc) => {
    });
    __privateSet2(this, _elcWLE, new EventListenerCtn());
    __privateSet2(this, _goTxt, () => this.layMng.goTxt());
    __privateSet2(this, _stopSkip, () => false);
    __privateSet2(this, _cancelWait, () => {
    });
    __privateSet2(this, _hDownKeys, {
      "Alt": 0,
      "Meta": 0,
      "Control": 0,
      "ArrowDown": 0,
      "End": 0,
      "Enter": 0,
      "Escape": 0,
      " ": 0,
      "GoBack": 0
    });
    hTag.clear_event = (o) => __privateMethod2(this, _clear_event, clear_event_fn).call(this, o);
    hTag.event = (o) => __privateMethod2(this, _event, event_fn).call(this, o);
    hTag.l = (o) => __privateMethod2(this, _l, l_fn).call(this, o);
    hTag.p = (o) => __privateMethod2(this, _p, p_fn).call(this, o);
    hTag.s = () => {
      this.scrItr.recodePage();
      __privateMethod2(this, _waitEventBase, waitEventBase_fn).call(this, () => {
      }, false, true);
      return true;
    };
    hTag.set_cancel_skip = () => __privateMethod2(this, _set_cancel_skip, set_cancel_skip_fn).call(this);
    hTag.set_focus = (o) => __privateMethod2(this, _set_focus, set_focus_fn).call(this, o);
    hTag.wait = (o) => __privateMethod2(this, _wait, wait_fn).call(this, o);
    hTag.waitclick = () => __privateMethod2(this, _waitclick, waitclick_fn).call(this);
    sndMng.setEvtMng(this);
    scrItr.setOtherObj(this, layMng);
    TxtLayer.setEvtMng(main2, this, sys);
    layMng.setEvtMng(this);
    sys.setFire((KEY, e) => this.fire(KEY, e));
    if (CmnLib.isDbg) {
      const hHook = {
        pause: () => {
          __privateSet2(this, _isDbgBreak, true);
          if (!__privateGet2(this, _isWait))
            return;
          const hArg = {};
          this.scrItr.recodeDesign(hArg);
          this.sys.callHook("_enterDesign", hArg);
          this.sys.send2Dbg("_enterDesign", hArg);
        },
        stopOnBreakpoint: () => __privateSet2(this, _isDbgBreak, true),
        stopOnDataBreakpoint: () => __privateSet2(this, _isDbgBreak, true),
        continue: () => __privateSet2(this, _isDbgBreak, false),
        disconnect: () => __privateSet2(this, _isDbgBreak, false)
      };
      hHook.attach = hHook.stopOnEntry = hHook.stopOnStep = hHook.stopOnStepIn = hHook.stopOnStepOut = hHook.stopOnBackstep = hHook.pause;
      sys.addHook((type) => {
        var _a3;
        return (_a3 = hHook[type]) == null ? void 0 : _a3.call(hHook);
      });
    }
    let fnHint = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAGQAAAAyBAMAAABYG2ONAAAACXBIWXMAAAsTAAALEwEAmpwYAAAGuGlUWHRYTUw6Y29tLmFkb2JlLnhtcAAAAAAAPD94cGFja2V0IGJlZ2luPSLvu78iIGlkPSJXNU0wTXBDZWhpSHpyZVN6TlRjemtjOWQiPz4gPHg6eG1wbWV0YSB4bWxuczp4PSJhZG9iZTpuczptZXRhLyIgeDp4bXB0az0iQWRvYmUgWE1QIENvcmUgNi4wLWMwMDIgNzkuMTY0NDYwLCAyMDIwLzA1LzEyLTE2OjA0OjE3ICAgICAgICAiPiA8cmRmOlJERiB4bWxuczpyZGY9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkvMDIvMjItcmRmLXN5bnRheC1ucyMiPiA8cmRmOkRlc2NyaXB0aW9uIHJkZjphYm91dD0iIiB4bWxuczp4bXA9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC8iIHhtbG5zOmRjPSJodHRwOi8vcHVybC5vcmcvZGMvZWxlbWVudHMvMS4xLyIgeG1sbnM6cGhvdG9zaG9wPSJodHRwOi8vbnMuYWRvYmUuY29tL3Bob3Rvc2hvcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RFdnQ9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZUV2ZW50IyIgeG1wOkNyZWF0b3JUb29sPSJBZG9iZSBQaG90b3Nob3AgMjEuMiAoTWFjaW50b3NoKSIgeG1wOkNyZWF0ZURhdGU9IjIwMjAtMDgtMTlUMDM6MDk6MjUrMDk6MDAiIHhtcDpNb2RpZnlEYXRlPSIyMDIwLTA4LTE5VDIzOjUyOjI5KzA5OjAwIiB4bXA6TWV0YWRhdGFEYXRlPSIyMDIwLTA4LTE5VDIzOjUyOjI5KzA5OjAwIiBkYzpmb3JtYXQ9ImltYWdlL3BuZyIgcGhvdG9zaG9wOkNvbG9yTW9kZT0iMyIgcGhvdG9zaG9wOklDQ1Byb2ZpbGU9InNSR0IgSUVDNjE5NjYtMi4xIiB4bXBNTTpJbnN0YW5jZUlEPSJ4bXAuaWlkOjI5ZjM1YWNlLTc0NzMtNGI3My05OGJjLWQ1OTk4ZDk5MjQzNiIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDphY2U0MDcwOS04ZTQxLTQ1YjYtYTMwZi05NDU1YWM1OTAwMmEiIHhtcE1NOk9yaWdpbmFsRG9jdW1lbnRJRD0ieG1wLmRpZDphY2U0MDcwOS04ZTQxLTQ1YjYtYTMwZi05NDU1YWM1OTAwMmEiPiA8eG1wTU06SGlzdG9yeT4gPHJkZjpTZXE+IDxyZGY6bGkgc3RFdnQ6YWN0aW9uPSJjcmVhdGVkIiBzdEV2dDppbnN0YW5jZUlEPSJ4bXAuaWlkOmFjZTQwNzA5LThlNDEtNDViNi1hMzBmLTk0NTVhYzU5MDAyYSIgc3RFdnQ6d2hlbj0iMjAyMC0wOC0xOVQwMzowOToyNSswOTowMCIgc3RFdnQ6c29mdHdhcmVBZ2VudD0iQWRvYmUgUGhvdG9zaG9wIDIxLjIgKE1hY2ludG9zaCkiLz4gPHJkZjpsaSBzdEV2dDphY3Rpb249InNhdmVkIiBzdEV2dDppbnN0YW5jZUlEPSJ4bXAuaWlkOjA3Mzg4MzYwLWJjMjctNDRkZi1hMTYwLTk5N2M4ODNmYTA0ZCIgc3RFdnQ6d2hlbj0iMjAyMC0wOC0xOVQyMjo0NTozNiswOTowMCIgc3RFdnQ6c29mdHdhcmVBZ2VudD0iQWRvYmUgUGhvdG9zaG9wIDIxLjIgKE1hY2ludG9zaCkiIHN0RXZ0OmNoYW5nZWQ9Ii8iLz4gPHJkZjpsaSBzdEV2dDphY3Rpb249InNhdmVkIiBzdEV2dDppbnN0YW5jZUlEPSJ4bXAuaWlkOjI5ZjM1YWNlLTc0NzMtNGI3My05OGJjLWQ1OTk4ZDk5MjQzNiIgc3RFdnQ6d2hlbj0iMjAyMC0wOC0xOVQyMzo1MjoyOSswOTowMCIgc3RFdnQ6c29mdHdhcmVBZ2VudD0iQWRvYmUgUGhvdG9zaG9wIDIxLjIgKE1hY2ludG9zaCkiIHN0RXZ0OmNoYW5nZWQ9Ii8iLz4gPC9yZGY6U2VxPiA8L3htcE1NOkhpc3Rvcnk+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+WWAYXwAAACdQTFRF////PDIlPDIlPDIlPDIlPDIlPDIlPDIlPDIlPDIlPDIlPDIlPDIlCOA6SAAAAA10Uk5TACB/MID/EJBA8NCwYDCdv6cAAABoSURBVHgBYxicYBQIKZEIlJmMSQWGTKS7a8RpGdUyqmVUy6iWUS3y7zGBAlwai+wnrOZwTA2FgBnE220F0RFlQLwWtq1gLdtI8SI7SEc4acFyMjQ08gBpgWzlAEKkgayoBJJj7AAuCQAm1kUjHh83WgAAAABJRU5ErkJggg==";
    let isCustomHint = false;
    try {
      fnHint = cfg.searchPath("hint", Config.EXT_SPRITE);
      isCustomHint = true;
    } catch {
    }
    const ctx = __privateGet2(this, _cvsHint).getContext("2d");
    if (ctx) {
      __privateGet2(this, _cvsHint).hidden = true;
      appPixi.view.parentElement.appendChild(__privateGet2(this, _cvsHint));
      const s2 = __privateGet2(this, _cvsHint).style;
      s2.position = "absolute";
      s2.left = s2.top = "0";
      s2.zIndex = "10000";
      s2.pointerEvents = "none";
      s2.userSelect = "none";
      __privateSet2(this, _padHint, 10);
      const img = new Image();
      const initHint = () => {
        __privateGet2(this, _cvsHint).width = __privateSet2(this, _picHint_w, img.width);
        __privateGet2(this, _cvsHint).height = __privateSet2(this, _picHint_h, img.height);
        this.setTxtHint("\u884C\u65B9\u5411\u306E\u5909\u66F4", "white", "22px Arial");
      };
      this.setTxtHint = (txt, fillStyle, hint_font) => {
        ctx.clearRect(0, 0, __privateGet2(this, _cvsHint).width, __privateGet2(this, _cvsHint).height);
        ctx.drawImage(img, 0, 0);
        ctx.textBaseline = "top";
        ctx.font = hint_font;
        ctx.fillStyle = fillStyle;
        ctx.fillText(txt, __privateGet2(this, _padHint), 16, __privateGet2(this, _picHint_w) - __privateGet2(this, _padHint) * 2);
      };
      if (isCustomHint)
        GrpLayer.loadPic2Img("hint", img, (i2) => {
          if (img === i2)
            initHint();
        });
      else {
        img.src = fnHint;
        img.onload = initHint;
      }
    }
    if (this.cfg.oCfg.debug.masume)
      appPixi.stage.addChild(__privateGet2(this, _grpHint));
    else
      __privateSet2(this, _dispHint_masume, () => {
      });
    appPixi.stage.interactive = true;
    if (CmnLib.isMobile)
      appPixi.stage.on("pointerdown", (e) => this.fire("click", e));
    else
      __privateGet2(this, _elc2).add(appPixi.stage, "pointerdown", (e) => {
        switch (e.data.button) {
          case 0:
            this.fire("click", e);
            break;
          case 1:
            this.fire("middleclick", e);
            break;
        }
      });
    __privateGet2(this, _elc2).add(window, "keydown", (e) => __privateMethod2(this, _ev_keydown, ev_keydown_fn).call(this, e));
    __privateGet2(this, _elc2).add(appPixi.view, "contextmenu", (e) => __privateMethod2(this, _ev_contextmenu, ev_contextmenu_fn).call(this, e));
    const fncMql = (mq) => {
      CmnLib.isDarkMode = mq.matches;
      val.setVal_Nochk("tmp", "const.sn.isDarkMode", CmnLib.isDarkMode);
    };
    const mql = globalThis.matchMedia("(prefers-color-scheme: dark)");
    fncMql(mql);
    mql.addEventListener("change", (e) => {
      fncMql(e);
      this.fire("sn:chgDarkMode", e);
    });
    if ("WheelEvent" in window) {
      __privateGet2(this, _elc2).add(appPixi.view, "wheel", (e) => __privateMethod2(this, _ev_wheel, ev_wheel_fn).call(this, e), { passive: true });
      __privateSet2(this, _resvFlameEvent4Wheel, (win) => win.addEventListener("wheel", (e) => __privateMethod2(this, _ev_wheel, ev_wheel_fn).call(this, e), { passive: true }));
      __privateSet2(this, _procWheel4wle, (elc, fnc) => elc.add(appPixi.view, "wheel", (e) => {
        if (e["isComposing"])
          return;
        if (e.deltaY <= 0)
          return;
        e.stopPropagation();
        fnc();
      }));
    }
    if (CmnLib.debugLog) {
      __privateGet2(this, _gamepad).on("gamepad:connected", (e) => console.log(`\u{1F47A}<'gamepad:connected' index:${e.detail.index} id:${e.detail.gamepad.id}`));
      __privateGet2(this, _gamepad).on("gamepad:disconnected", (e) => console.log(`\u{1F47A}<'gamepad:disconnected' index:${e.detail.index} id:${e.detail.gamepad.id}`));
    }
    const aStick = [
      "",
      "ArrowUp",
      "",
      "ArrowLeft",
      "",
      "ArrowRight",
      "",
      "ArrowDown",
      ""
    ];
    const stick_xy = [0, 0];
    __privateGet2(this, _gamepad).on("gamepad:axis", (e) => {
      if (!document.hasFocus() || e.detail.stick !== 0)
        return;
      stick_xy[e.detail.axis] = e.detail.value;
      const s2 = (stick_xy[1] + 1) * 3 + (stick_xy[0] + 1);
      const s22 = aStick[s2];
      if (!s22)
        return;
      const cmp = __privateGet2(this, _fcs).getFocus();
      (!cmp || cmp instanceof Container ? globalThis : cmp).dispatchEvent(new KeyboardEvent("keydown", { key: s22, bubbles: true }));
      if (!cmp || cmp instanceof Container)
        return;
      if (cmp.getAttribute("type") === "range")
        cmp.dispatchEvent(new InputEvent("input", { bubbles: true }));
    });
    __privateGet2(this, _gamepad).on("gamepad:button", (e) => {
      if (!document.hasFocus() || e.detail.value === 0)
        return;
      if (e.detail.button % 2 === 0) {
        const cmp = __privateGet2(this, _fcs).getFocus();
        (!cmp || cmp instanceof Container ? globalThis : cmp).dispatchEvent(new KeyboardEvent("keydown", { key: "Enter", bubbles: true }));
      } else
        appPixi.view.dispatchEvent(new Event("contextmenu"));
    });
    __privateGet2(this, _gamepad).start();
    __privateGet2(this, _elc2).add(window, "keyup", (e) => {
      if (e["isComposing"])
        return;
      if (e.key in __privateGet2(this, _hDownKeys))
        __privateGet2(this, _hDownKeys)[e.key] = 0;
    });
    val.defTmp("const.sn.key.alternate", () => __privateGet2(this, _hDownKeys)["Alt"] > 0);
    val.defTmp("const.sn.key.command", () => __privateGet2(this, _hDownKeys)["Meta"] > 0);
    val.defTmp("const.sn.key.control", () => __privateGet2(this, _hDownKeys)["Control"] > 0);
    val.defTmp("const.sn.key.end", () => __privateGet2(this, _hDownKeys)["End"] > 0);
    val.defTmp("const.sn.key.escape", () => __privateGet2(this, _hDownKeys)["Escape"] > 0);
    val.defTmp("const.sn.key.back", () => __privateGet2(this, _hDownKeys)["GoBack"] > 0);
  }
  resvFlameEvent(win) {
    win.addEventListener("keydown", (e) => __privateMethod2(this, _ev_keydown, ev_keydown_fn).call(this, e));
    win.addEventListener("contextmenu", (e) => __privateMethod2(this, _ev_contextmenu, ev_contextmenu_fn).call(this, e));
    __privateGet2(this, _resvFlameEvent4Wheel).call(this, win);
  }
  destroy() {
    var _a3;
    __privateGet2(this, _fcs).destroy();
    __privateGet2(this, _elc2).clear();
    (_a3 = __privateGet2(this, _cvsHint)) == null ? void 0 : _a3.parentElement.removeChild(__privateGet2(this, _cvsHint));
  }
  fire(KEY, e) {
    var _a3;
    if (__privateGet2(this, _stopSkip).call(this) || !__privateGet2(this, _isWait) || __privateGet2(this, _isDbgBreak))
      return;
    const key = KEY.toLowerCase();
    if (CmnLib.debugLog)
      console.log(`\u{1F47A} fire<(key:\`${key}\` type:${e.type} e:%o)`, __spreadValues({}, e));
    if (key === "enter") {
      const em = __privateGet2(this, _fcs).getFocus();
      if (em instanceof Container) {
        em.emit("pointerdown", new Event("pointerdown"));
        return;
      }
    }
    const ke = __privateGet2(this, _getEvt2Fnc).call(this, key);
    if (!ke) {
      if (key.slice(0, 5) === "swipe")
        globalThis.scrollBy(-e.deltaX, -e.deltaY);
      return;
    }
    if (key.slice(-5) !== "wheel")
      (_a3 = e.preventDefault) == null ? void 0 : _a3.call(e);
    e.stopPropagation();
    if (key.slice(0, 4) !== "dom=")
      this.layMng.clickTxtLay();
    __privateSet2(this, _isWait, false);
    ke(e);
    __privateGet2(this, _cvsHint).hidden = true;
  }
  popLocalEvts() {
    const ret = __privateGet2(this, _hLocalEvt2Fnc);
    __privateSet2(this, _hLocalEvt2Fnc, {});
    return ret;
  }
  pushLocalEvts(h2) {
    __privateSet2(this, _hLocalEvt2Fnc, h2);
  }
  waitEvent(onFinish, canskip = true, global2 = false) {
    if (canskip && global2)
      throw `canskip\u3068global\u3092\u540C\u6642\u306Btrue\u6307\u5B9A\u3067\u304D\u307E\u305B\u3093`;
    if (this.val.getVal("tmp:sn.skip.enabled")) {
      if (this.val.getVal("tmp:sn.skip.all") || this.scrItr.isNextKidoku) {
        onFinish();
        return false;
      }
      __privateGet2(this, _stopSkip).call(this);
    }
    __privateMethod2(this, _waitEventBase, waitEventBase_fn).call(this, onFinish, canskip, global2);
    return true;
  }
  unButton(ctnBtn) {
    __privateGet2(this, _fcs).remove(ctnBtn);
  }
  button(hArg, ctnBtn, normal, hover, clicked) {
    var _a3, _b3;
    if (!hArg.fn && !hArg.label)
      this.main.errScript("fn\u307E\u305F\u306Flabel\u306F\u5FC5\u9808\u3067\u3059");
    ctnBtn.interactive = ctnBtn.buttonMode = true;
    const key = (_b3 = (_a3 = hArg.key) == null ? void 0 : _a3.toLowerCase()) != null ? _b3 : " ";
    if (!hArg.fn)
      hArg.fn = this.scrItr.scriptFn;
    const glb = argChk_Boolean(hArg, "global", false);
    if (glb)
      __privateGet2(this, _hGlobalEvt2Fnc)[key] = () => this.main.resumeByJumpOrCall(hArg);
    else
      __privateGet2(this, _hLocalEvt2Fnc)[key] = () => this.main.resumeByJumpOrCall(hArg);
    const ee = ctnBtn;
    ee.on("pointerdown", (e) => this.fire(key, e));
    const onHint = hArg.hint ? () => __privateMethod2(this, _dispHint, dispHint_fn).call(this, hArg, ctnBtn) : () => {
    };
    const nr = () => {
      normal();
      __privateGet2(this, _cvsHint).hidden = true;
    };
    const hv = () => {
      onHint();
      return hover();
    };
    ee.on("pointerover", hv);
    ee.on("pointerout", () => {
      if (__privateGet2(this, _fcs).isFocus(ctnBtn))
        hv();
      else
        nr();
    });
    ee.on("pointerdown", clicked);
    ee.on("pointerup", CmnLib.isMobile ? nr : () => {
      if (__privateGet2(this, _fcs).isFocus(ctnBtn))
        hv();
      else
        nr();
    });
    __privateGet2(this, _fcs).add(ctnBtn, hv, nr);
    if (hArg.clickse) {
      this.cfg.searchPath(hArg.clickse, Config.EXT_SOUND);
      ee.on("pointerdown", () => {
        const o = { fn: hArg.clickse, join: false };
        if (hArg.clicksebuf)
          o.buf = hArg.clicksebuf;
        this.hTag.playse(o);
      });
    }
    if (hArg.enterse) {
      this.cfg.searchPath(hArg.enterse, Config.EXT_SOUND);
      ee.on("pointerover", () => {
        const o = { fn: hArg.enterse, join: false };
        if (hArg.entersebuf)
          o.buf = hArg.entersebuf;
        this.hTag.playse(o);
      });
    }
    if (hArg.leavese) {
      this.cfg.searchPath(hArg.leavese, Config.EXT_SOUND);
      ee.on("pointerout", () => {
        const o = { fn: hArg.leavese, join: false };
        if (hArg.leavesebuf)
          o.buf = hArg.leavesebuf;
        this.hTag.playse(o);
      });
    }
    if (hArg.onenter) {
      const k = key + hArg.onenter.toLowerCase();
      const o = { fn: hArg.fn, label: hArg.onenter, call: true, key: k };
      if (glb)
        __privateGet2(this, _hGlobalEvt2Fnc)[k] = () => this.main.resumeByJumpOrCall(o);
      else
        __privateGet2(this, _hLocalEvt2Fnc)[k] = () => this.main.resumeByJumpOrCall(o);
      ee.on("pointerover", (e) => this.fire(k, e));
    }
    if (hArg.onleave) {
      const k = key + hArg.onleave.toLowerCase();
      const o = { fn: hArg.fn, label: hArg.onleave, call: true, key: k };
      if (glb)
        __privateGet2(this, _hGlobalEvt2Fnc)[k] = () => this.main.resumeByJumpOrCall(o);
      else
        __privateGet2(this, _hLocalEvt2Fnc)[k] = () => this.main.resumeByJumpOrCall(o);
      ee.on("pointerout", (e) => this.fire(k, e));
    }
    this.sndMng.loadAheadSnd(hArg);
  }
  cvsResize() {
    if (__privateGet2(this, _cvsHint).hidden)
      return;
    __privateMethod2(this, _dispHint, dispHint_fn).call(this, __privateGet2(this, _dispHint_hArg), __privateGet2(this, _dispHint_ctnBtn), false);
  }
  waitLimitedEvent(hArg, onFinish) {
    __privateGet2(this, _goTxt).call(this);
    this.val.saveKidoku();
    const fnc = () => {
      __privateGet2(this, _elcWLE).clear();
      onFinish();
    };
    if (this.val.getVal("tmp:sn.skip.enabled")) {
      if (!this.val.getVal("tmp:sn.skip.all") && !this.scrItr.isNextKidoku)
        __privateGet2(this, _stopSkip).call(this);
      else {
        fnc();
        return false;
      }
    }
    if (!argChk_Boolean(hArg, "canskip", true))
      return true;
    __privateGet2(this, _elcWLE).add(window, "pointerdown", (e) => {
      e.stopPropagation();
      fnc();
    });
    __privateGet2(this, _elcWLE).add(window, "keydown", (e) => {
      if (e["isComposing"])
        return;
      e.stopPropagation();
      fnc();
    });
    __privateGet2(this, _procWheel4wle).call(this, __privateGet2(this, _elcWLE), fnc);
    return true;
  }
  isSkippingByKeyDown() {
    if (this.scrItr.skip4page)
      return true;
    for (const k in __privateGet2(this, _hDownKeys))
      if (__privateGet2(this, _hDownKeys)[k] === 2)
        return true;
    return false;
  }
}
_elc2 = new WeakMap();
_cvsHint = new WeakMap();
_picHint_w = new WeakMap();
_picHint_h = new WeakMap();
_padHint = new WeakMap();
_grpHint = new WeakMap();
_gamepad = new WeakMap();
_fcs = new WeakMap();
_resvFlameEvent4Wheel = new WeakMap();
_ev_keydown = new WeakSet();
ev_keydown_fn = function(e) {
  if (e["isComposing"])
    return;
  if (e.key in __privateGet2(this, _hDownKeys))
    __privateGet2(this, _hDownKeys)[e.key] = e.repeat ? 2 : 1;
  const key = (e.altKey ? e.key === "Alt" ? "" : "alt+" : "") + (e.ctrlKey ? e.key === "Control" ? "" : "ctrl+" : "") + (e.shiftKey ? e.key === "Shift" ? "" : "shift+" : "") + e.key;
  this.fire(key, e);
};
_ev_contextmenu = new WeakSet();
ev_contextmenu_fn = function(e) {
  const key = (e.altKey ? e.key === "Alt" ? "" : "alt+" : "") + (e.ctrlKey ? e.key === "Control" ? "" : "ctrl+" : "") + (e.shiftKey ? e.key === "Shift" ? "" : "shift+" : "") + "rightclick";
  this.fire(key, e);
  e.preventDefault();
};
_ev_wheel = new WeakSet();
ev_wheel_fn = function(e) {
  if (e["isComposing"])
    return;
  if (__privateGet2(this, _wheeling)) {
    __privateSet2(this, _extend_wheel, true);
    return;
  }
  __privateSet2(this, _wheeling, true);
  __privateMethod2(this, _ev_wheel_waitstop, ev_wheel_waitstop_fn).call(this);
  const key = (e.altKey ? "alt+" : "") + (e.ctrlKey ? "ctrl+" : "") + (e.shiftKey ? "shift+" : "") + (e.deltaY > 0 ? "downwheel" : "upwheel");
  this.fire(key, e);
};
_wheeling = new WeakMap();
_extend_wheel = new WeakMap();
_ev_wheel_waitstop = new WeakSet();
ev_wheel_waitstop_fn = function() {
  setTimeout(() => {
    if (__privateGet2(this, _extend_wheel)) {
      __privateSet2(this, _extend_wheel, false);
      __privateMethod2(this, _ev_wheel_waitstop, ev_wheel_waitstop_fn).call(this);
      return;
    }
    __privateSet2(this, _wheeling, false);
  }, 250);
};
_hLocalEvt2Fnc = new WeakMap();
_hGlobalEvt2Fnc = new WeakMap();
_isDbgBreak = new WeakMap();
_isWait = new WeakMap();
_getEvt2Fnc = new WeakMap();
_waitEventBase = new WeakSet();
waitEventBase_fn = function(onFinish, canskip = true, global2 = true) {
  __privateGet2(this, _goTxt).call(this);
  this.val.saveKidoku();
  if (canskip) {
    __privateGet2(this, _hLocalEvt2Fnc)["click"] = __privateGet2(this, _hLocalEvt2Fnc)["enter"] = __privateGet2(this, _hLocalEvt2Fnc)["arrowdown"] = __privateGet2(this, _hLocalEvt2Fnc)["wheel.y>0"] = onFinish;
  } else {
    delete __privateGet2(this, _hLocalEvt2Fnc)["click"];
    delete __privateGet2(this, _hLocalEvt2Fnc)["enter"];
    delete __privateGet2(this, _hLocalEvt2Fnc)["arrowdown"];
    delete __privateGet2(this, _hLocalEvt2Fnc)["wheel.y>0"];
  }
  __privateSet2(this, _getEvt2Fnc, global2 ? (key) => {
    var _a3;
    return (_a3 = __privateGet2(this, _hLocalEvt2Fnc)[key]) != null ? _a3 : __privateGet2(this, _hGlobalEvt2Fnc)[key];
  } : (key) => __privateGet2(this, _hLocalEvt2Fnc)[key]);
  __privateSet2(this, _isWait, true);
  __privateGet2(this, _firstWait).call(this);
  if (CmnLib.debugLog) {
    const o = /* @__PURE__ */ Object.create(null);
    o.local = Object.keys(__privateGet2(this, _hLocalEvt2Fnc));
    o.global = Object.keys(__privateGet2(this, _hGlobalEvt2Fnc));
    console.log(`\u{1F38D} wait event... %o`, o);
  }
};
_firstWait = new WeakMap();
_dispHint = new WeakSet();
dispHint_fn = function(hArg, ctnBtn, masume = true) {
  var _a3, _b3, _c3;
  __privateSet2(this, _dispHint_hArg, hArg);
  __privateSet2(this, _dispHint_ctnBtn, ctnBtn);
  const rctBtn = ctnBtn instanceof Button ? ctnBtn.getBtnBounds() : ctnBtn.getBounds();
  const isLink = hArg[":\u30BF\u30B0\u540D"] === "link";
  if (!isLink) {
    const cpp = ctnBtn.parent.parent;
    rctBtn.x += cpp.x;
    rctBtn.y += cpp.y;
  }
  this.setTxtHint((_a3 = hArg.hint) != null ? _a3 : "", (_b3 = hArg.hint_color) != null ? _b3 : "white", (_c3 = hArg.hint_font) != null ? _c3 : "22px Arial");
  const hint_width = argChk_Num(hArg, "hint_width", __privateGet2(this, _picHint_w));
  const scale_x = hint_width / __privateGet2(this, _picHint_w);
  const hint_tate = argChk_Boolean(hArg, "hint_tate", false);
  __privateGet2(this, _cvsHint).style.left = `${this.sys.ofsLeft4elm + rctBtn.x * this.sys.cvsScale}px`;
  __privateGet2(this, _cvsHint).style.top = `${this.sys.ofsTop4elm + rctBtn.y * this.sys.cvsScale}px`;
  __privateGet2(this, _cvsHint).style.transformOrigin = "top left";
  __privateGet2(this, _cvsHint).style.transform = `rotateZ(${ctnBtn.rotation + (hint_tate ? Math.PI * 90 / 180 : 0)}rad) scale(${scale_x * this.sys.cvsScale}, ${this.sys.cvsScale}) translate(${((hint_tate ? rctBtn.height : rctBtn.width) - hint_width) / 2 / scale_x}px, ${(hint_tate ? -rctBtn.width : 0) - __privateGet2(this, _picHint_h)}px)`;
  __privateGet2(this, _cvsHint).hidden = false;
  if (masume)
    __privateGet2(this, _dispHint_masume).call(this, hArg, ctnBtn, rctBtn, isLink, hint_width, hint_tate);
};
_dispHint_hArg = new WeakMap();
_dispHint_ctnBtn = new WeakMap();
_dispHint_masume = new WeakMap();
_procWheel4wle = new WeakMap();
_elcWLE = new WeakMap();
_clear_event = new WeakSet();
clear_event_fn = function(hArg) {
  const glb = argChk_Boolean(hArg, "global", false);
  const h2 = glb ? __privateGet2(this, _hGlobalEvt2Fnc) : __privateGet2(this, _hLocalEvt2Fnc);
  for (const nm in h2)
    __privateMethod2(this, _clear_eventer, clear_eventer_fn).call(this, nm, h2[nm]);
  if (glb)
    __privateSet2(this, _hGlobalEvt2Fnc, {});
  else
    __privateSet2(this, _hLocalEvt2Fnc, {});
  __privateSet2(this, _isWait, false);
  return false;
};
_clear_eventer = new WeakSet();
clear_eventer_fn = function(KeY, e2f) {
  if (KeY.slice(0, 4) !== "dom=")
    return;
  __privateMethod2(this, _getHtmlElmList, getHtmlElmList_fn).call(this, KeY).el.forEach((v2) => v2.removeEventListener("click", e2f));
};
_event = new WeakSet();
event_fn = function(hArg) {
  var _a3, _b3;
  const KeY = hArg.key;
  if (!KeY)
    throw "key\u306F\u5FC5\u9808\u3067\u3059";
  const key = KeY.toLowerCase();
  const call = argChk_Boolean(hArg, "call", false);
  const h2 = argChk_Boolean(hArg, "global", false) ? __privateGet2(this, _hGlobalEvt2Fnc) : __privateGet2(this, _hLocalEvt2Fnc);
  if (argChk_Boolean(hArg, "del", false)) {
    if (hArg.fn || hArg.label || call)
      throw "fn/label/call\u3068del\u306F\u540C\u6642\u6307\u5B9A\u3067\u304D\u307E\u305B\u3093";
    __privateMethod2(this, _clear_eventer, clear_eventer_fn).call(this, KeY, h2[key]);
    delete h2[key];
    return false;
  }
  (_a3 = hArg.fn) != null ? _a3 : hArg.fn = this.scrItr.scriptFn;
  if (KeY.slice(0, 4) === "dom=") {
    const g2 = __privateMethod2(this, _getHtmlElmList, getHtmlElmList_fn).call(this, KeY);
    if (g2.el.length === 0) {
      if (argChk_Boolean(hArg, "need_err", true))
        throw `HTML\u5185\u306B\u30BB\u30EC\u30AF\u30BF\uFF08${g2.sel}\uFF09\u306B\u5BFE\u5FDC\u3059\u308B\u8981\u7D20\u304C\u898B\u3064\u304B\u308A\u307E\u305B\u3093\u3002\u5B58\u5728\u3057\u306A\u3044\u5834\u5408\u3092\u8A31\u5BB9\u3059\u308B\u306A\u3089\u3001need_err=false \u3068\u6307\u5B9A\u3057\u3066\u304F\u3060\u3055\u3044`;
      return false;
    }
    let aEv = ["click", "keydown"];
    const inp = g2.el[0];
    switch ((_b3 = inp.type) != null ? _b3 : "") {
      case "checkbox":
        aEv = ["input"];
        break;
      case "range":
        aEv = ["input"];
        break;
      case "text":
      case "textarea":
        aEv = ["input", "change"];
        break;
    }
    aEv.forEach((v2, i2) => g2.el.forEach((elm) => {
      __privateGet2(this, _elc2).add(elm, v2, (e) => {
        if (!__privateGet2(this, _isWait) || this.layMng.getFrmDisabled(g2.id))
          return;
        if (v2 === "keydown" && e.key !== "Enter")
          return;
        const d2 = elm.dataset;
        for (const n in d2)
          if (d2.hasOwnProperty(n))
            this.val.setVal_Nochk("tmp", `sn.event.domdata.${n}`, d2[n]);
        this.fire(KeY, e);
      });
      if (i2 === 0)
        __privateGet2(this, _fcs).add(elm, () => {
          if (!__privateMethod2(this, _canFocus, canFocus_fn).call(this, elm))
            return false;
          elm.focus();
          return true;
        }, () => {
        });
    }));
  }
  h2[key] = () => this.main.resumeByJumpOrCall(hArg);
  return false;
};
_canFocus = new WeakSet();
canFocus_fn = function(elm) {
  if (elm.offsetParent === null)
    return false;
  let el = elm;
  do {
    const style = getComputedStyle(el);
    if (style.display === "none" || el.dataset.focus === "false" || (el == null ? void 0 : el.disabled))
      return false;
    el = el.parentElement;
  } while (el !== null);
  return true;
};
_getHtmlElmList = new WeakSet();
getHtmlElmList_fn = function(KeY) {
  const idx = KeY.indexOf(":");
  let sel = "";
  if (idx >= 0) {
    const id = KeY.slice(4, idx);
    const frmnm = `const.sn.frm.${id}`;
    if (!this.val.getVal(`tmp:${frmnm}`, 0))
      throw `HTML\u3010${id}\u3011\u304C\u8AAD\u307F\u8FBC\u307E\u308C\u3066\u3044\u307E\u305B\u3093`;
    const ifrm = document.getElementById(id);
    const win = ifrm.contentWindow;
    sel = KeY.slice(idx + 1);
    return { el: win.document.querySelectorAll(sel), id, sel };
  }
  sel = KeY.slice(4);
  return { el: document.querySelectorAll(sel), id: "", sel };
};
_goTxt = new WeakMap();
_l = new WeakSet();
l_fn = function(hArg) {
  if (this.scrItr.skip4page)
    return false;
  if (!this.val.getVal("tmp:sn.tagL.enabled")) {
    __privateGet2(this, _goTxt).call(this);
    return false;
  }
  if (this.val.getVal("tmp:sn.skip.enabled")) {
    if (!this.val.getVal("tmp:sn.skip.all") && !this.scrItr.isNextKidoku)
      __privateGet2(this, _stopSkip).call(this);
    else if ("ps".includes(this.val.getVal("sys:sn.skip.mode")))
      return false;
  }
  if (this.val.getVal("tmp:sn.auto.enabled"))
    return __privateMethod2(this, _wait, wait_fn).call(this, {
      time: Number(this.scrItr.isKidoku ? this.val.getVal("sys:sn.auto.msecLineWait_Kidoku") : this.val.getVal("sys:sn.auto.msecLineWait"))
    });
  if (argChk_Boolean(hArg, "visible", true))
    this.layMng.breakLine();
  __privateMethod2(this, _waitEventBase, waitEventBase_fn).call(this, () => this.main.resume());
  return true;
};
_p = new WeakSet();
p_fn = function(hArg) {
  this.scrItr.recodePage();
  if (this.val.getVal("tmp:sn.skip.enabled")) {
    if (!this.val.getVal("tmp:sn.skip.all") && !this.scrItr.isNextKidoku)
      __privateGet2(this, _stopSkip).call(this);
    else if (this.val.getVal("sys:sn.skip.mode") == "s") {
      __privateGet2(this, _goTxt).call(this);
      return false;
    }
  }
  if (this.val.getVal("tmp:sn.auto.enabled"))
    return __privateMethod2(this, _wait, wait_fn).call(this, {
      time: Number(this.scrItr.isKidoku ? this.val.getVal("sys:sn.auto.msecPageWait_Kidoku") : this.val.getVal("sys:sn.auto.msecPageWait"))
    });
  if (argChk_Boolean(hArg, "visible", true))
    this.layMng.breakPage();
  const fnc = () => {
    this.sndMng.clearCache();
    this.main.resume();
  };
  __privateMethod2(this, _waitEventBase, waitEventBase_fn).call(this, argChk_Boolean(hArg, "er", false) && this.layMng.currentTxtlayFore ? () => {
    this.hTag.er(hArg);
    fnc();
  } : fnc);
  return true;
};
_stopSkip = new WeakMap();
_set_cancel_skip = new WeakSet();
set_cancel_skip_fn = function() {
  __privateSet2(this, _stopSkip, () => {
    __privateSet2(this, _stopSkip, () => false);
    this.val.setVal_Nochk("tmp", "sn.tagL.enabled", true);
    this.val.setVal_Nochk("tmp", "sn.skip.enabled", false);
    this.val.setVal_Nochk("tmp", "sn.auto.enabled", false);
    this.layMng.setNormalChWait();
    __privateGet2(this, _cancelWait).call(this);
    return true;
  });
  return false;
};
_set_focus = new WeakSet();
set_focus_fn = function(hArg) {
  const { add: add3, del, to } = hArg;
  if ((add3 == null ? void 0 : add3.slice(0, 4)) === "dom=") {
    const g2 = __privateMethod2(this, _getHtmlElmList, getHtmlElmList_fn).call(this, add3);
    if (g2.el.length === 0 && argChk_Boolean(hArg, "need_err", true))
      throw `HTML\u5185\u306B\u30BB\u30EC\u30AF\u30BF\uFF08${g2.sel}\uFF09\u306B\u5BFE\u5FDC\u3059\u308B\u8981\u7D20\u304C\u898B\u3064\u304B\u308A\u307E\u305B\u3093\u3002\u5B58\u5728\u3057\u306A\u3044\u5834\u5408\u3092\u8A31\u5BB9\u3059\u308B\u306A\u3089\u3001need_err=false \u3068\u6307\u5B9A\u3057\u3066\u304F\u3060\u3055\u3044`;
    g2.el.forEach((elm) => __privateGet2(this, _fcs).add(elm, () => {
      if (!__privateMethod2(this, _canFocus, canFocus_fn).call(this, elm))
        return false;
      elm.focus();
      return true;
    }, () => {
    }));
    return false;
  }
  if ((del == null ? void 0 : del.slice(0, 4)) === "dom=") {
    const g2 = __privateMethod2(this, _getHtmlElmList, getHtmlElmList_fn).call(this, del);
    if (g2.el.length === 0 && argChk_Boolean(hArg, "need_err", true))
      throw `HTML\u5185\u306B\u30BB\u30EC\u30AF\u30BF\uFF08${g2.sel}\uFF09\u306B\u5BFE\u5FDC\u3059\u308B\u8981\u7D20\u304C\u898B\u3064\u304B\u308A\u307E\u305B\u3093\u3002\u5B58\u5728\u3057\u306A\u3044\u5834\u5408\u3092\u8A31\u5BB9\u3059\u308B\u306A\u3089\u3001need_err=false \u3068\u6307\u5B9A\u3057\u3066\u304F\u3060\u3055\u3044`;
    g2.el.forEach((elm) => __privateGet2(this, _fcs).remove(elm));
    return false;
  }
  if (!to)
    throw "[set_focus] add \u304B to \u306F\u5FC5\u9808\u3067\u3059";
  switch (to) {
    case "null":
      __privateGet2(this, _fcs).blur();
      break;
    case "next":
      __privateGet2(this, _fcs).next();
      break;
    case "prev":
      __privateGet2(this, _fcs).prev();
      break;
  }
  return false;
};
_wait = new WeakSet();
wait_fn = function(hArg) {
  const time = argChk_Num(hArg, "time", NaN);
  if (this.scrItr.skip4page)
    return false;
  if (this.val.getVal("tmp:sn.skip.enabled")) {
    if (!this.val.getVal("tmp:sn.skip.all") && !this.scrItr.isNextKidoku)
      __privateGet2(this, _stopSkip).call(this);
    return false;
  }
  if (this.val.getVal("tmp:sn.auto.enabled"))
    __privateSet2(this, _cancelWait, () => {
      this.scrItr.subIdxToken();
      tw.end();
    });
  const tw = new Tween({}).to({}, time).onComplete(() => {
    __privateSet2(this, _cancelWait, () => {
    });
    tw.stop();
    this.main.resume();
  }).start();
  return this.waitEvent(() => tw.end(), argChk_Boolean(hArg, "canskip", true), argChk_Boolean(hArg, "global", false));
};
_cancelWait = new WeakMap();
_waitclick = new WeakSet();
waitclick_fn = function() {
  if (this.scrItr.skip4page)
    return false;
  if (this.val.getVal("tmp:sn.skip.enabled") || this.val.getVal("tmp:sn.auto.enabled"))
    __privateGet2(this, _stopSkip).call(this);
  __privateMethod2(this, _waitEventBase, waitEventBase_fn).call(this, () => this.main.resume());
  return true;
};
_hDownKeys = new WeakMap();
class CallStack {
  constructor($fn = "", $idx = 0, $csArg = { ":hEvt1Time": {}, ":hMp": {} }) {
    this.$fn = $fn;
    this.$idx = $idx;
    this.$csArg = $csArg;
    this.toString = () => `[fn:${this.$fn}, idx:${this.$idx}, csArg:${this.$csArg}]`;
  }
  get fn() {
    return this.$fn;
  }
  get idx() {
    return this.$idx;
  }
  get csArg() {
    return this.$csArg;
  }
}
const _ScriptIterator = class {
  constructor(cfg, hTag, main2, val, alzTagArg, runAnalyze, prpPrs, sndMng, sys) {
    __privateAdd2(this, _regBreakPoint);
    __privateAdd2(this, _go_stepover);
    __privateAdd2(this, _go_stepout);
    __privateAdd2(this, _idxDx4Dbg);
    __privateAdd2(this, _isIdxOverLast);
    __privateAdd2(this, _isBreak_base);
    __privateAdd2(this, _subHitCondition);
    __privateAdd2(this, _aStack);
    __privateAdd2(this, _let_ml);
    __privateAdd2(this, _dump_stack);
    __privateAdd2(this, _cnvIdx2lineCol);
    __privateAdd2(this, _dump_script);
    __privateAdd2(this, _endif);
    __privateAdd2(this, _if);
    __privateAdd2(this, _call);
    __privateAdd2(this, _callSub);
    __privateAdd2(this, _jump);
    __privateAdd2(this, _page);
    __privateAdd2(this, _pop_stack);
    __privateAdd2(this, _return);
    __privateAdd2(this, _clearResvToken);
    __privateAdd2(this, _jumpWork);
    __privateAdd2(this, _nextToken_Proc);
    __privateAdd2(this, _errOverScr);
    __privateAdd2(this, _seekScript);
    __privateAdd2(this, _resolveScript);
    __privateAdd2(this, _jump_light);
    __privateAdd2(this, _recordKidoku);
    __privateAdd2(this, _eraseKidoku);
    __privateAdd2(this, _bracket2macro);
    __privateAdd2(this, _char2macro);
    __privateAdd2(this, _macro);
    __privateAdd2(this, _load);
    __privateAdd2(this, _loadFromMark);
    __privateAdd2(this, _reload_script);
    __privateAdd2(this, _record_place);
    __privateAdd2(this, _nowScrIdx);
    __privateAdd2(this, _save);
    __privateAdd2(this, _script, void 0);
    __privateAdd2(this, _scriptFn, void 0);
    __privateAdd2(this, _idxToken, void 0);
    __privateAdd2(this, _lineNum, void 0);
    __privateAdd2(this, _aCallStk, void 0);
    __privateAdd2(this, _grm, void 0);
    __privateAdd2(this, _hHook2, void 0);
    __privateAdd2(this, _cnvSnPath, void 0);
    __privateAdd2(this, _cnvSnPath4Dbg, void 0);
    __privateAdd2(this, _csDepth_macro_esc, void 0);
    __privateAdd2(this, _breakState, void 0);
    __privateAdd2(this, _procDebugtag, void 0);
    __privateAdd2(this, _evtMng6, void 0);
    __privateAdd2(this, _layMng, void 0);
    __privateAdd2(this, _fncSet, void 0);
    __privateAdd2(this, _fncBreak, void 0);
    __privateAdd2(this, _fnLastBreak, void 0);
    __privateAdd2(this, _hScrCache4Dump, void 0);
    __privateAdd2(this, _dumpErrLine, void 0);
    __privateAdd2(this, _aIfStk, void 0);
    __privateAdd2(this, _resvToken, void 0);
    __privateAdd2(this, _skipLabel, void 0);
    __privateAdd2(this, _dbgToken, void 0);
    __privateAdd2(this, _REG_NONAME_LABEL, void 0);
    __privateAdd2(this, _REG_TOKEN_MACRO_BEGIN, void 0);
    __privateAdd2(this, _REG_TOKEN_MACRO_END, void 0);
    __privateAdd2(this, _REG_TAG_LET_ML, void 0);
    __privateAdd2(this, _REG_TAG_ENDLET_ML, void 0);
    __privateAdd2(this, _hScript, void 0);
    __privateAdd2(this, _REG_WILDCARD, void 0);
    __privateAdd2(this, _REG_WILDCARD2, void 0);
    __privateAdd2(this, _replaceScript_Wildcard, void 0);
    __privateAdd2(this, _isKidoku, void 0);
    __privateAdd2(this, _strStepin, void 0);
    __privateAdd2(this, _REGSTEPIN, void 0);
    __privateAdd2(this, _skip4page, void 0);
    __privateAdd2(this, _mark, void 0);
    __privateAdd2(this, _aPageLog, void 0);
    __privateAdd2(this, _posAPageLog, void 0);
    this.cfg = cfg;
    this.hTag = hTag;
    this.main = main2;
    this.val = val;
    this.alzTagArg = alzTagArg;
    this.runAnalyze = runAnalyze;
    this.prpPrs = prpPrs;
    this.sndMng = sndMng;
    this.sys = sys;
    __privateSet2(this, _script, { aToken: [""], len: 1, aLNum: [1] });
    __privateSet2(this, _scriptFn, "");
    __privateSet2(this, _idxToken, 0);
    __privateSet2(this, _lineNum, 0);
    this.addLineNum = (len) => __privateSet2(this, _lineNum, __privateGet2(this, _lineNum) + len);
    __privateSet2(this, _aCallStk, []);
    __privateSet2(this, _grm, new Grammar());
    this.firstWait = () => {
    };
    __privateSet2(this, _hHook2, {
      disconnect: () => {
        __privateSet2(_ScriptIterator, _hFn2hLineBP, {});
        __privateSet2(_ScriptIterator, _hFuncBP, {});
        this.isBreak = () => false;
        __privateGet2(this, _hHook2).continue({});
        __privateSet2(this, _breakState, 0);
      },
      restart: () => this.isBreak = () => false,
      add_break: (o) => __privateMethod2(this, _regBreakPoint, regBreakPoint_fn).call(this, o.fn, o.o),
      data_break: (o) => {
        if (__privateGet2(this, _breakState) !== 0)
          return;
        __privateSet2(this, _breakState, 1);
        this.main.setLoop(false, `\u5909\u6570 ${o.dataId}\u3010${o.old_v}\u3011\u2192\u3010${o.new_v}\u3011\u30C7\u30FC\u30BF\u30D6\u30EC\u30FC\u30AF`);
        this.sys.callHook("stopOnDataBreakpoint", {});
        this.sys.send2Dbg("stopOnDataBreakpoint", {});
      },
      set_func_break: (o) => {
        __privateSet2(_ScriptIterator, _hFuncBP, {});
        o.a.forEach((v2) => __privateGet2(_ScriptIterator, _hFuncBP)[v2.name] = 1);
        this.sys.send2Dbg(o.ri, {});
      },
      stack: (o) => this.sys.send2Dbg(o.ri, { a: __privateMethod2(this, _aStack, aStack_fn).call(this) }),
      eval: (o) => {
        this.sys.send2Dbg(o.ri, { v: this.prpPrs.parse(o.txt) });
      },
      continue: () => {
        if (__privateMethod2(this, _isIdxOverLast, isIdxOverLast_fn).call(this))
          return;
        __privateSet2(this, _idxToken, __privateGet2(this, _idxToken) - __privateGet2(this, _idxDx4Dbg, idxDx4Dbg_get));
        __privateSet2(this, _breakState, 3);
        this.main.setLoop(true);
        this.main.resume();
      },
      stepover: (o) => __privateMethod2(this, _go_stepover, go_stepover_fn).call(this, o),
      stepin: () => {
        if (__privateMethod2(this, _isIdxOverLast, isIdxOverLast_fn).call(this))
          return;
        const tkn = __privateGet2(this, _script).aToken[__privateGet2(this, _idxToken) - __privateGet2(this, _idxDx4Dbg, idxDx4Dbg_get)];
        this.sys.callHook(`stopOnStep${__privateGet2(this, _REGSTEPIN).test(tkn) ? "In" : ""}`, {});
        __privateSet2(this, _idxToken, __privateGet2(this, _idxToken) - __privateGet2(this, _idxDx4Dbg, idxDx4Dbg_get));
        __privateSet2(this, _breakState, __privateGet2(this, _breakState) === 1 ? 4 : 5);
        this.main.setLoop(true);
        this.main.resume();
      },
      stepout: (o) => {
        if (__privateMethod2(this, _isIdxOverLast, isIdxOverLast_fn).call(this))
          return;
        if (__privateGet2(this, _aCallStk).length > 0)
          __privateMethod2(this, _go_stepout, go_stepout_fn).call(this, true);
        else
          __privateMethod2(this, _go_stepover, go_stepover_fn).call(this, o);
      },
      pause: () => {
        __privateSet2(this, _breakState, 4);
        this.main.setLoop(false, "\u4E00\u6642\u505C\u6B62");
        this.sys.send2Dbg("stopOnStep", {});
      },
      stopOnEntry: () => {
        __privateSet2(this, _breakState, 4);
        this.main.setLoop(false, "\u4E00\u6642\u505C\u6B62");
        this.sys.send2Dbg("stopOnEntry", {});
      }
    });
    __privateSet2(this, _cnvSnPath, (fn) => this.cfg.searchPath(fn, Config.EXT_SCRIPT));
    __privateSet2(this, _cnvSnPath4Dbg, (fn) => (this.sys.pathBaseCnvSnPath4Dbg + __privateGet2(this, _cnvSnPath).call(this, fn)).replace(__privateGet2(_ScriptIterator, _REG4CODE_FN), `$1/prj/$2/${__privateGet2(this, _scriptFn)}$3`));
    this.cnvPath4Dbg = (fn) => this.sys.pathBaseCnvSnPath4Dbg + fn.replace("/crypto_prj/", "/prj/");
    __privateSet2(this, _csDepth_macro_esc, 0);
    __privateSet2(this, _breakState, 0);
    this.isBreak = (_token) => false;
    __privateSet2(this, _procDebugtag, (_tag_name) => {
    });
    __privateSet2(this, _fncSet, () => {
    });
    __privateSet2(this, _fncBreak, () => {
    });
    __privateSet2(this, _fnLastBreak, "");
    __privateSet2(this, _hScrCache4Dump, {});
    this.noticeBreak = (_goto) => {
    };
    __privateSet2(this, _dumpErrLine, 5);
    __privateSet2(this, _aIfStk, [-1]);
    __privateSet2(this, _resvToken, "");
    __privateSet2(this, _skipLabel, "");
    this.nextToken = () => "";
    __privateSet2(this, _dbgToken, (_token) => {
    });
    __privateSet2(this, _REG_NONAME_LABEL, /(\*{2,})(.*)/);
    __privateSet2(this, _REG_TOKEN_MACRO_BEGIN, /\[macro\s/);
    __privateSet2(this, _REG_TOKEN_MACRO_END, /\[endmacro[\s\]]/);
    __privateSet2(this, _REG_TAG_LET_ML, /^\[let_ml\s/g);
    __privateSet2(this, _REG_TAG_ENDLET_ML, /^\[endlet_ml\s*]/g);
    __privateSet2(this, _hScript, /* @__PURE__ */ Object.create(null));
    __privateSet2(this, _REG_WILDCARD, /^\[(call|loadplugin)\s/);
    __privateSet2(this, _REG_WILDCARD2, /\bfn\s*=\s*[^\s\]]+/);
    __privateSet2(this, _replaceScript_Wildcard, () => {
      for (let i2 = __privateGet2(this, _script).len - 1; i2 >= 0; --i2) {
        const token = __privateGet2(this, _script).aToken[i2];
        __privateGet2(this, _REG_WILDCARD).lastIndex = 0;
        if (!__privateGet2(this, _REG_WILDCARD).test(token))
          continue;
        const [tag_name, args] = tagToken2Name_Args(token);
        this.alzTagArg.go(args);
        const p_fn2 = this.alzTagArg.hPrm.fn;
        if (!p_fn2)
          continue;
        const fn = p_fn2.val;
        if (!fn || fn.slice(-1) !== "*")
          continue;
        const ext = tag_name === "loadplugin" ? "css" : "sn";
        const a2 = this.cfg.matchPath("^" + fn.slice(0, -1) + ".*", ext);
        __privateGet2(this, _script).aToken.splice(i2, 1, "	", "; " + token);
        __privateGet2(this, _script).aLNum.splice(i2, 1, NaN, NaN);
        for (const v2 of a2) {
          const nt = token.replace(__privateGet2(this, _REG_WILDCARD2), "fn=" + decodeURIComponent(getFn(v2[ext])));
          __privateGet2(this, _script).aToken.splice(i2, 0, nt);
          __privateGet2(this, _script).aLNum.splice(i2, 0, NaN);
        }
      }
      __privateGet2(this, _script).len = __privateGet2(this, _script).aToken.length;
    });
    __privateSet2(this, _isKidoku, false);
    __privateSet2(this, _strStepin, "call");
    __privateSet2(this, _REGSTEPIN, /\[(call)\b/);
    __privateSet2(this, _skip4page, false);
    __privateSet2(this, _mark, {
      hSave: {},
      hPages: {},
      aIfStk: [-1]
    });
    __privateSet2(this, _aPageLog, []);
    __privateSet2(this, _posAPageLog, -1);
    hTag.let_ml = (o) => __privateMethod2(this, _let_ml, let_ml_fn).call(this, o);
    hTag.dump_stack = () => __privateMethod2(this, _dump_stack, dump_stack_fn).call(this);
    hTag.dump_script = (o) => __privateMethod2(this, _dump_script, dump_script_fn).call(this, o);
    hTag["else"] = hTag.elsif = hTag.endif = () => __privateMethod2(this, _endif, endif_fn).call(this);
    hTag["if"] = (o) => __privateMethod2(this, _if, if_fn).call(this, o);
    hTag.call = (o) => __privateMethod2(this, _call, call_fn).call(this, o);
    hTag.jump = (o) => __privateMethod2(this, _jump, jump_fn).call(this, o);
    hTag.page = (o) => __privateMethod2(this, _page, page_fn).call(this, o);
    hTag.pop_stack = (o) => __privateMethod2(this, _pop_stack, pop_stack_fn).call(this, o);
    hTag.return = () => __privateMethod2(this, _return, return_fn).call(this);
    hTag.bracket2macro = (o) => __privateMethod2(this, _bracket2macro, bracket2macro_fn).call(this, o);
    hTag.char2macro = (o) => __privateMethod2(this, _char2macro, char2macro_fn).call(this, o);
    hTag.endmacro = () => __privateMethod2(this, _return, return_fn).call(this);
    hTag.macro = (o) => __privateMethod2(this, _macro, macro_fn).call(this, o);
    hTag.load = (o) => __privateMethod2(this, _load, load_fn).call(this, o);
    hTag.reload_script = (o) => __privateMethod2(this, _reload_script, reload_script_fn).call(this, o);
    hTag.record_place = () => __privateMethod2(this, _record_place, record_place_fn).call(this);
    hTag.save = (o) => __privateMethod2(this, _save, save_fn).call(this, o);
    if (cfg.oCfg.debug.token)
      __privateSet2(this, _dbgToken, (token) => console.log(`\u{1F331} \u30C8\u30FC\u30AF\u30F3 fn:${__privateGet2(this, _scriptFn)} idx:${__privateGet2(this, _idxToken)} ln:${__privateGet2(this, _lineNum)} token\u3010${token}\u3011`));
    val.defTmp("const.sn.vctCallStk.length", () => __privateGet2(this, _aCallStk).length);
    __privateGet2(this, _grm).setEscape(cfg.oCfg.init.escape);
    if (CmnLib.isDbg) {
      sys.addHook((type, o) => {
        var _a3, _b3;
        return (_b3 = (_a3 = __privateGet2(this, _hHook2))[type]) == null ? void 0 : _b3.call(_a3, o);
      });
      this.isBreak = __privateMethod2(this, _isBreak_base, isBreak_base_fn);
      const fnc = this.analyzeInit;
      this.analyzeInit = () => {
        this.analyzeInit = () => {
        };
        this.sys.send2Dbg("hi", {});
      };
      __privateGet2(this, _hHook2).auth = (o) => {
        const hLineBP = o.hBreakpoint.hFn2hLineBP;
        for (const fn in hLineBP)
          __privateMethod2(this, _regBreakPoint, regBreakPoint_fn).call(this, fn, hLineBP[fn]);
        __privateSet2(_ScriptIterator, _hFuncBP, {});
        o.hBreakpoint.aFunc.forEach((v2) => __privateGet2(_ScriptIterator, _hFuncBP)[v2.name] = 1);
        if (o.stopOnEntry) {
          while (true) {
            let tkn = this.nextToken();
            if (!tkn)
              break;
            const uc = tkn.charCodeAt(0);
            if (uc === 91)
              break;
            if (uc === 38)
              break;
            if (uc === 42 && tkn.length === 1)
              break;
            if (uc === 10)
              __privateSet2(this, _lineNum, __privateGet2(this, _lineNum) + tkn.length);
          }
          this.sys.callHook("stopOnEntry", {});
          this.analyzeInit = fnc;
          this.analyzeInit();
        } else {
          this.firstWait = () => {
            this.sys.callHook("stopOnEntry", {});
          };
          this.analyzeInit = fnc;
          this.analyzeInit();
        }
      };
    } else
      this.recodeDesign = () => {
      };
    if (cfg.oCfg.debug.tag)
      __privateSet2(this, _procDebugtag, (tag_name) => console.log(`\u{1F332} \u30BF\u30B0\u89E3\u6790 fn:${__privateGet2(this, _scriptFn)} idx:${__privateGet2(this, _idxToken)} ln:${__privateGet2(this, _lineNum)} [${tag_name} %o]`, this.alzTagArg.hPrm));
  }
  get scriptFn() {
    return __privateGet2(this, _scriptFn);
  }
  subIdxToken() {
    --__privateWrapper2(this, _idxToken)._;
  }
  get lineNum() {
    return __privateGet2(this, _lineNum);
  }
  destroy() {
    this.isBreak = () => false;
  }
  \u30BF\u30B0\u89E3\u6790(tagToken) {
    const [tag_name, args] = tagToken2Name_Args(tagToken);
    const tag_fnc = this.hTag[tag_name];
    if (!tag_fnc)
      throw `\u672A\u5B9A\u7FA9\u306E\u30BF\u30B0\u3010${tag_name}\u3011\u3067\u3059`;
    this.alzTagArg.go(args);
    __privateGet2(this, _procDebugtag).call(this, tag_name);
    const hPrm = this.alzTagArg.hPrm;
    if (hPrm.cond) {
      const cond = hPrm.cond.val;
      if (!cond || cond.charAt(0) === "&")
        throw "\u5C5E\u6027cond\u306F\u300C&\u300D\u304C\u4E0D\u8981\u3067\u3059";
      const p2 = this.prpPrs.parse(cond);
      const ps = String(p2);
      if (ps === "null" || ps === "undefined")
        return false;
      if (!p2)
        return false;
    }
    let hArg = {};
    const len = __privateGet2(this, _aCallStk).length;
    if (this.alzTagArg.isKomeParam) {
      if (len === 0)
        throw "\u5C5E\u6027\u300C*\u300D\u306F\u30DE\u30AF\u30ED\u306E\u307F\u6709\u52B9\u3067\u3059";
      hArg = __spreadValues({}, __privateGet2(this, _aCallStk)[__privateGet2(this, _aCallStk).length - 1].csArg);
    }
    hArg[":\u30BF\u30B0\u540D"] = tag_name;
    for (const arg_nm in hPrm) {
      let v2 = hPrm[arg_nm].val;
      if ((v2 == null ? void 0 : v2.charAt(0)) === "%") {
        if (len === 0)
          throw "\u5C5E\u6027\u300C%\u300D\u306F\u30DE\u30AF\u30ED\u5B9A\u7FA9\u5185\u3067\u306E\u307F\u4F7F\u7528\u3067\u304D\u307E\u3059\uFF08\u305D\u306E\u30DE\u30AF\u30ED\u306E\u5F15\u6570\u3092\u793A\u3059\u7C21\u7565\u6587\u6CD5\u3067\u3042\u308B\u305F\u3081\uFF09";
        const mac = __privateGet2(this, _aCallStk)[__privateGet2(this, _aCallStk).length - 1].csArg[v2.slice(1)];
        if (mac) {
          hArg[arg_nm] = mac;
          continue;
        }
        v2 = hPrm[arg_nm].def;
        if (v2 === void 0 || v2 === "null")
          continue;
      }
      v2 = this.prpPrs.getValAmpersand(v2 != null ? v2 : "");
      if (v2 !== "undefined") {
        hArg[arg_nm] = v2;
        continue;
      }
      const def = hPrm[arg_nm].def;
      if (def === void 0)
        continue;
      v2 = this.prpPrs.getValAmpersand(def);
      if (v2 !== "undefined")
        hArg[arg_nm] = v2;
    }
    return tag_fnc(hArg);
  }
  setOtherObj(evtMng, layMng) {
    __privateSet2(this, _evtMng6, evtMng);
    __privateSet2(this, _layMng, layMng);
  }
  dumpErrForeLine() {
    var _a3;
    if (__privateGet2(this, _idxToken) === 0) {
      console.group(`\u{1F95F} Error line (from 0 rows before) fn:${__privateGet2(this, _scriptFn)}`);
      console.groupEnd();
      return;
    }
    let s2 = "";
    for (let i2 = __privateGet2(this, _idxToken) - 1; i2 >= 0; --i2) {
      s2 = __privateGet2(this, _script).aToken[i2] + s2;
      if (((_a3 = s2.match(/\n/g)) != null ? _a3 : []).length >= __privateGet2(this, _dumpErrLine))
        break;
    }
    const a2 = s2.split("\n").slice(-__privateGet2(this, _dumpErrLine));
    const len = a2.length;
    console.group(`\u{1F95F} Error line (from ${len} rows before) fn:${__privateGet2(this, _scriptFn)}`);
    const ln_txt_width = String(__privateGet2(this, _lineNum)).length;
    const lc = __privateMethod2(this, _cnvIdx2lineCol, cnvIdx2lineCol_fn).call(this, __privateGet2(this, _script), __privateGet2(this, _idxToken));
    for (let i2 = 0; i2 < len; ++i2) {
      const ln = __privateGet2(this, _lineNum) - len + i2 + 1;
      const mes = `${String(ln).padStart(ln_txt_width, " ")}: %c`;
      const e = a2[i2];
      const line = e.length > 75 ? e.slice(0, 75) + "\u2026" : e;
      if (i2 === len - 1)
        console.info(mes + line.slice(0, lc.col_s) + "%c" + line.slice(lc.col_s), "color: black; background-color: skyblue;", "color: black; background-color: pink;");
      else
        console.info(mes + line, "color: black; background-color: skyblue;");
    }
    console.groupEnd();
  }
  analyzeInit() {
    const o = __privateMethod2(this, _seekScript, seekScript_fn).call(this, __privateGet2(this, _script), Boolean(this.val.getVal("mp:const.sn.macro.name")), __privateGet2(this, _lineNum), __privateGet2(this, _skipLabel), __privateGet2(this, _idxToken));
    __privateSet2(this, _idxToken, o.idx);
    __privateSet2(this, _lineNum, o.ln);
    this.runAnalyze();
  }
  get isKidoku() {
    return __privateGet2(this, _isKidoku);
  }
  get isNextKidoku() {
    let fn = __privateGet2(this, _scriptFn);
    let idx = __privateGet2(this, _idxToken);
    let len = __privateGet2(this, _script).len;
    if (__privateGet2(this, _aCallStk).length > 0) {
      const cs = __privateGet2(this, _aCallStk)[0];
      fn = cs.fn;
      idx = cs.idx;
      const st = __privateGet2(this, _hScript)[fn];
      if (st)
        len = st.len;
    }
    const areas = this.val.getAreaKidoku(fn);
    if (!areas)
      return false;
    if (idx === len)
      return false;
    return areas.search(idx);
  }
  get normalWait() {
    return __privateGet2(this, _isKidoku) ? this.val.getVal("sys:sn.tagCh.doWait_Kidoku") ? uint(this.val.getVal("sys:sn.tagCh.msecWait_Kidoku")) : 0 : this.val.getVal("sys:sn.tagCh.doWait") ? uint(this.val.getVal("sys:sn.tagCh.msecWait")) : 0;
  }
  get skip4page() {
    return __privateGet2(this, _skip4page);
  }
  recodePage() {
    __privateSet2(this, _skip4page, false);
    if (!this.val.getVal("save:sn.doRecLog"))
      return;
    const { fn, idx } = __privateMethod2(this, _nowScrIdx, nowScrIdx_fn).call(this);
    const i2 = idx - 1;
    const key = i2 + ":" + fn;
    const iPl = __privateGet2(this, _aPageLog).findIndex((p2) => p2.key === key);
    if (iPl > -1) {
      __privateSet2(this, _posAPageLog, iPl);
      return;
    }
    const o = {
      key,
      fn,
      idx: i2,
      retFn: fn,
      retIdx: 0,
      retMark: __spreadValues({}, __privateGet2(this, _mark))
    };
    if (__privateGet2(this, _posAPageLog) >= 0) {
      const pl = __privateGet2(this, _aPageLog)[__privateGet2(this, _posAPageLog)];
      o.retFn = pl.fn;
      o.retIdx = pl.idx + 1;
    }
    if (++__privateWrapper2(this, _posAPageLog)._ === __privateGet2(this, _aPageLog).length)
      __privateGet2(this, _aPageLog).push(o);
    else
      __privateGet2(this, _aPageLog)[__privateGet2(this, _posAPageLog)] = o;
  }
  recodeDesign(hArg) {
    let fn = "";
    let idx = 0;
    const len = __privateGet2(this, _aCallStk).length;
    if (hArg.design_unit && len > 0) {
      const cs = __privateGet2(this, _aCallStk)[0];
      fn = cs.fn;
      idx = cs.idx;
    } else {
      fn = __privateGet2(this, _scriptFn);
      idx = __privateGet2(this, _idxToken);
    }
    hArg[":path"] = __privateGet2(this, _cnvSnPath4Dbg).call(this, fn);
    const lc = __privateMethod2(this, _cnvIdx2lineCol, cnvIdx2lineCol_fn).call(this, __privateGet2(this, _hScript)[fn], idx);
    hArg[":ln"] = lc.ln;
    hArg[":col_s"] = lc.col_s;
    hArg[":col_e"] = lc.col_e;
    const idx_1 = idx - 1;
    hArg[":idx_tkn"] = idx_1;
    hArg[":token"] = __privateGet2(this, _hScript)[fn].aToken[idx_1];
    this.sys.send2Dbg("_recodeDesign", hArg);
  }
  replace(idx, val) {
    __privateGet2(this, _script).aToken[idx] = val;
  }
};
let ScriptIterator = _ScriptIterator;
_script = new WeakMap();
_scriptFn = new WeakMap();
_idxToken = new WeakMap();
_lineNum = new WeakMap();
_aCallStk = new WeakMap();
_grm = new WeakMap();
_regBreakPoint = new WeakSet();
regBreakPoint_fn = function(fn, o) {
  __privateGet2(_ScriptIterator, _hFn2hLineBP)[__privateGet2(this, _cnvSnPath4Dbg).call(this, fn)] = o;
};
_hHook2 = new WeakMap();
_cnvSnPath = new WeakMap();
_REG4CODE_FN = new WeakMap();
_cnvSnPath4Dbg = new WeakMap();
_go_stepover = new WeakSet();
go_stepover_fn = function(o) {
  if (__privateMethod2(this, _isIdxOverLast, isIdxOverLast_fn).call(this))
    return;
  const tkn = __privateGet2(this, _script).aToken[__privateGet2(this, _idxToken) - __privateGet2(this, _idxDx4Dbg, idxDx4Dbg_get)];
  if (__privateGet2(this, _REGSTEPIN).test(tkn))
    __privateMethod2(this, _go_stepout, go_stepout_fn).call(this, false);
  else {
    this.sys.callHook("stopOnStep", {});
    __privateGet2(this, _hHook2).stepin(o);
  }
};
_go_stepout = new WeakSet();
go_stepout_fn = function(out) {
  this.sys.callHook(`stopOnStep${out ? "Out" : ""}`, {});
  __privateSet2(this, _csDepth_macro_esc, __privateGet2(this, _aCallStk).length - (out ? 1 : 0));
  __privateSet2(this, _idxToken, __privateGet2(this, _idxToken) - __privateGet2(this, _idxDx4Dbg, idxDx4Dbg_get));
  __privateSet2(this, _breakState, out ? 7 : 6);
  this.main.setLoop(true);
  this.main.resume();
};
_csDepth_macro_esc = new WeakMap();
_idxDx4Dbg = new WeakSet();
idxDx4Dbg_get = function() {
  return __privateGet2(this, _breakState) === 2 || __privateGet2(this, _breakState) === 4 ? 1 : 0;
};
_isIdxOverLast = new WeakSet();
isIdxOverLast_fn = function() {
  if (__privateGet2(this, _idxToken) < __privateGet2(this, _script).len)
    return false;
  this.sys.callHook("stopOnEntry", {});
  this.main.setLoop(false, "\u30B9\u30AF\u30EA\u30D7\u30C8\u7D42\u7AEF\u3067\u3059");
  return true;
};
_hFn2hLineBP = new WeakMap();
_hFuncBP = new WeakMap();
_breakState = new WeakMap();
_isBreak_base = new WeakSet();
isBreak_base_fn = function(token) {
  switch (__privateGet2(this, _breakState)) {
    case 6:
      __privateMethod2(this, _subHitCondition, subHitCondition_fn).call(this);
      __privateSet2(this, _breakState, 7);
      break;
    case 7:
      if (__privateGet2(this, _aCallStk).length !== __privateGet2(this, _csDepth_macro_esc))
        break;
      __privateSet2(this, _breakState, 4);
      this.main.setLoop(false, "\u30B9\u30C6\u30C3\u30D7\u5B9F\u884C");
      this.sys.send2Dbg("stopOnStep", {});
      return true;
    case 5:
      __privateMethod2(this, _subHitCondition, subHitCondition_fn).call(this);
      __privateSet2(this, _breakState, 4);
      break;
    case 4:
      __privateMethod2(this, _subHitCondition, subHitCondition_fn).call(this);
      this.main.setLoop(false, "\u30B9\u30C6\u30C3\u30D7\u5B9F\u884C");
      this.sys.send2Dbg("stopOnStep", {});
      return true;
    case 3:
      __privateMethod2(this, _subHitCondition, subHitCondition_fn).call(this);
      __privateSet2(this, _breakState, 0);
      break;
    default:
      {
        if (tagToken2Name(token) in __privateGet2(_ScriptIterator, _hFuncBP)) {
          __privateSet2(this, _breakState, 2);
          this.main.setLoop(false, `\u95A2\u6570 ${token} \u30D6\u30EC\u30FC\u30AF`);
          this.sys.callHook("stopOnBreakpoint", {});
          this.sys.send2Dbg("stopOnBreakpoint", {});
          return true;
        }
      }
      {
        const bp = __privateGet2(_ScriptIterator, _hFn2hLineBP)[__privateGet2(this, _cnvSnPath4Dbg).call(this, __privateGet2(this, _scriptFn))];
        if (!bp)
          break;
        const o = bp[__privateGet2(this, _lineNum)];
        if (!o)
          break;
        if (o.condition) {
          if (!this.prpPrs.parse(o.condition))
            break;
        } else if ("hitCondition" in o && --o.hitCondition > 0)
          break;
        const isBreak = __privateGet2(this, _breakState) === 0;
        __privateSet2(this, _breakState, 2);
        this.main.setLoop(false, isBreak ? (o.condition ? "\u6761\u4EF6" : "\u30D2\u30C3\u30C8\u30AB\u30A6\u30F3\u30C8") + "\u30D6\u30EC\u30FC\u30AF" : "\u30B9\u30C6\u30C3\u30D7\u5B9F\u884C");
        const type = isBreak ? "stopOnBreakpoint" : "stopOnStep";
        this.sys.callHook(type, {});
        this.sys.send2Dbg(type, {});
      }
      return true;
  }
  return false;
};
_subHitCondition = new WeakSet();
subHitCondition_fn = function() {
  var _a3;
  const o = (_a3 = __privateGet2(_ScriptIterator, _hFn2hLineBP)[getFn(__privateGet2(this, _scriptFn))]) == null ? void 0 : _a3[__privateGet2(this, _lineNum)];
  if (o == null ? void 0 : o.hitCondition)
    --o.hitCondition;
};
_aStack = new WeakSet();
aStack_fn = function() {
  var _a3, _b3;
  const idx_n = __privateGet2(this, _breakState) === 3 ? 1 : 0;
  const tkn0 = __privateGet2(this, _script).aToken[__privateGet2(this, _idxToken) - 1 + idx_n];
  const fn0 = __privateGet2(this, _cnvSnPath4Dbg).call(this, __privateGet2(this, _scriptFn));
  const tag_name0 = tagToken2Name(tkn0);
  const nm = tag_name0 ? `[${tag_name0}]` : tkn0;
  const ma = (_a3 = this.val.getVal("mp:const.sn.macro")) != null ? _a3 : "{}";
  if (__privateGet2(this, _idxToken) === 0)
    return [{ fn: fn0, ln: 1, col: 1, nm, ma }];
  const lc0 = __privateMethod2(this, _cnvIdx2lineCol, cnvIdx2lineCol_fn).call(this, __privateGet2(this, _script), __privateGet2(this, _idxToken));
  const a2 = [{ fn: fn0, ln: lc0.ln, col: lc0.col_s + 1, nm, ma }];
  const len = __privateGet2(this, _aCallStk).length;
  if (len === 0)
    return a2;
  for (let i2 = len - 1; i2 >= 0; --i2) {
    const cs = __privateGet2(this, _aCallStk)[i2];
    const st = __privateGet2(this, _hScript)[cs.fn];
    const tkn = st.aToken[cs.idx - 1];
    const lc = __privateMethod2(this, _cnvIdx2lineCol, cnvIdx2lineCol_fn).call(this, st, cs.idx);
    const tag_name = tagToken2Name(tkn);
    a2.push({
      fn: __privateGet2(this, _cnvSnPath4Dbg).call(this, cs.fn),
      ln: lc.ln,
      col: lc.col_s + 1,
      nm: tag_name ? `[${tag_name}]` : tkn,
      ma: (_b3 = cs.csArg[":hMp"]["const.sn.macro"]) != null ? _b3 : "{}"
    });
  }
  return a2;
};
_procDebugtag = new WeakMap();
_evtMng6 = new WeakMap();
_layMng = new WeakMap();
_let_ml = new WeakSet();
let_ml_fn = function(hArg) {
  var _a3;
  const { name: name2 } = hArg;
  if (!name2)
    throw "name\u306F\u5FC5\u9808\u3067\u3059";
  let ml = "";
  const len = __privateGet2(this, _script).len;
  for (; __privateGet2(this, _idxToken) < len; ++__privateWrapper2(this, _idxToken)._) {
    ml = __privateGet2(this, _script).aToken[__privateGet2(this, _idxToken)];
    if (ml !== "")
      break;
  }
  hArg.text = ml;
  hArg.cast = "str";
  this.hTag["let"](hArg);
  __privateSet2(this, _idxToken, __privateGet2(this, _idxToken) + 2);
  __privateSet2(this, _lineNum, __privateGet2(this, _lineNum) + ((_a3 = ml.match(/\n/g)) != null ? _a3 : []).length);
  return false;
};
_dump_stack = new WeakSet();
dump_stack_fn = function() {
  var _a3;
  if (__privateGet2(this, _idxToken) === 0) {
    console.group(`\u{1F95F} [dump_stack] \u30B9\u30AF\u30EA\u30D7\u30C8\u73FE\u5728\u5730 fn:${__privateGet2(this, _scriptFn)} line:${1} col:${0}`);
    console.groupEnd();
    return false;
  }
  const lc0 = __privateMethod2(this, _cnvIdx2lineCol, cnvIdx2lineCol_fn).call(this, __privateGet2(this, _script), __privateGet2(this, _idxToken));
  const now2 = `\u30B9\u30AF\u30EA\u30D7\u30C8\u73FE\u5728\u5730 fn:${__privateGet2(this, _scriptFn)} line:${lc0.ln} col:${lc0.col_s + 1}`;
  console.group(`\u{1F95F} [dump_stack] ${now2}`);
  const len = __privateGet2(this, _aCallStk).length;
  if (len > 0) {
    console.info(now2);
    for (let i2 = len - 1; i2 >= 0; --i2) {
      const cs = __privateGet2(this, _aCallStk)[i2];
      const hMp = cs.csArg[":hMp"];
      const from_macro_nm = hMp ? hMp[":\u30BF\u30B0\u540D"] : void 0;
      const call_nm = (_a3 = cs.csArg[":\u30BF\u30B0\u540D"]) != null ? _a3 : "";
      const lc = __privateMethod2(this, _cnvIdx2lineCol, cnvIdx2lineCol_fn).call(this, __privateGet2(this, _hScript)[cs.fn], cs.idx);
      console.info(`${len - i2}\u3064\u524D\u306E\u30B3\u30FC\u30EB\u5143 fn:${cs.fn} line:${lc.ln} col:${lc.col_s + 1}` + (from_macro_nm ? "\uFF08[" + from_macro_nm + "]\u30DE\u30AF\u30ED\u5185\uFF09" : " ") + `\u3067 [${call_nm} ...]\u3092\u30B3\u30FC\u30EB`);
    }
  }
  console.groupEnd();
  return false;
};
_cnvIdx2lineCol = new WeakSet();
cnvIdx2lineCol_fn = function(st, idx) {
  const ret = { ln: 1, col_s: 0, col_e: 0 };
  if (!st)
    return ret;
  let i2 = idx - 1;
  const lN = ret.ln = st.aLNum[i2];
  while (st.aLNum[i2] === lN) {
    if (st.aToken[i2].charAt(0) !== "\n") {
      const len = st.aToken[i2].length;
      if (ret.col_e > 0)
        ret.col_s += len;
      ret.col_e += len;
    }
    if (--i2 < 0)
      break;
  }
  return ret;
};
_dump_script = new WeakSet();
dump_script_fn = function(hArg) {
  const { set_fnc, break_fnc } = hArg;
  if (!set_fnc)
    throw "set_fnc\u306F\u5FC5\u9808\u3067\u3059";
  __privateSet2(this, _fncSet, globalThis[set_fnc]);
  if (!__privateGet2(this, _fncSet)) {
    if (argChk_Boolean(hArg, "need_err", true))
      throw `HTML\u5185\u306B\u95A2\u6570${set_fnc}\u304C\u898B\u3064\u304B\u308A\u307E\u305B\u3093`;
    __privateSet2(this, _fncSet, () => {
    });
    return false;
  }
  this.noticeBreak = (goto) => {
    var _a3;
    if (__privateGet2(this, _fnLastBreak) !== __privateGet2(this, _scriptFn)) {
      __privateSet2(this, _fnLastBreak, __privateGet2(this, _scriptFn));
      __privateGet2(this, _fncSet).call(this, __privateGet2(this, _hScrCache4Dump)[__privateGet2(this, _scriptFn)] = (_a3 = __privateGet2(this, _hScrCache4Dump)[__privateGet2(this, _scriptFn)]) != null ? _a3 : __privateGet2(this, _script).aToken.join(""));
    }
    __privateGet2(this, _fncBreak).call(this, __privateGet2(this, _lineNum), goto);
  };
  this.noticeBreak(true);
  if (!break_fnc)
    return false;
  __privateSet2(this, _fncBreak, globalThis[break_fnc]);
  if (!__privateGet2(this, _fncBreak)) {
    if (argChk_Boolean(hArg, "need_err", true))
      throw `HTML\u5185\u306B\u95A2\u6570${break_fnc}\u304C\u898B\u3064\u304B\u308A\u307E\u305B\u3093`;
    __privateSet2(this, _fncBreak, () => {
    });
  }
  return false;
};
_fncSet = new WeakMap();
_fncBreak = new WeakMap();
_fnLastBreak = new WeakMap();
_hScrCache4Dump = new WeakMap();
_dumpErrLine = new WeakMap();
_aIfStk = new WeakMap();
_endif = new WeakSet();
endif_fn = function() {
  if (__privateGet2(this, _aIfStk)[0] === -1)
    throw "if\u30D6\u30ED\u30C3\u30AF\u5185\u3067\u306F\u3042\u308A\u307E\u305B\u3093";
  __privateSet2(this, _idxToken, __privateGet2(this, _aIfStk)[0]);
  __privateGet2(this, _aIfStk).shift();
  return false;
};
_if = new WeakSet();
if_fn = function(hArg) {
  var _a3;
  const { exp } = hArg;
  if (!exp)
    throw "exp\u306F\u5FC5\u9808\u3067\u3059";
  if (exp.charAt(0) === "&")
    throw "\u5C5E\u6027exp\u306F\u300C&\u300D\u304C\u4E0D\u8981\u3067\u3059";
  let cntDepth = 0;
  let idxGo = this.prpPrs.parse(exp) ? __privateGet2(this, _idxToken) : -1;
  const lnIf = __privateGet2(this, _script).aLNum[__privateGet2(this, _idxToken)];
  let zLn = __privateGet2(this, _lineNum) - (lnIf || 0);
  const len = __privateGet2(this, _script).len;
  for (; __privateGet2(this, _idxToken) < len; ++__privateWrapper2(this, _idxToken)._) {
    const ln = __privateGet2(this, _script).aLNum[__privateGet2(this, _idxToken)];
    __privateGet2(this, _script).aLNum[__privateGet2(this, _idxToken)] = (ln || 0) + zLn;
    const tkn = __privateGet2(this, _script).aToken[__privateGet2(this, _idxToken)];
    if (!tkn)
      continue;
    const uc = tkn.charCodeAt(0);
    if (uc === 10) {
      __privateSet2(this, _lineNum, __privateGet2(this, _lineNum) + tkn.length);
      continue;
    }
    if (uc !== 91)
      continue;
    const [tag_name, args] = tagToken2Name_Args(tkn);
    if (!(tag_name in this.hTag))
      throw `\u672A\u5B9A\u7FA9\u306E\u30BF\u30B0[${tag_name}]\u3067\u3059`;
    this.alzTagArg.go(args);
    switch (tag_name) {
      case "if":
        ++cntDepth;
        break;
      case "elsif":
        if (cntDepth > 0)
          break;
        if (idxGo > -1)
          break;
        const e = (_a3 = this.alzTagArg.hPrm.exp.val) != null ? _a3 : "";
        if (e.charAt(0) === "&")
          throw "\u5C5E\u6027exp\u306F\u300C&\u300D\u304C\u4E0D\u8981\u3067\u3059";
        if (this.prpPrs.parse(e))
          idxGo = __privateGet2(this, _idxToken) + 1;
        break;
      case "else":
        if (cntDepth > 0)
          break;
        if (idxGo === -1)
          idxGo = __privateGet2(this, _idxToken) + 1;
        break;
      case "endif":
        if (cntDepth > 0) {
          --cntDepth;
          break;
        }
        if (idxGo === -1) {
          ++__privateWrapper2(this, _idxToken)._;
          __privateGet2(this, _script).aLNum[__privateGet2(this, _idxToken)] += zLn;
        } else {
          __privateGet2(this, _aIfStk).unshift(__privateGet2(this, _idxToken) + 1);
          __privateSet2(this, _idxToken, idxGo);
          __privateSet2(this, _lineNum, __privateGet2(this, _script).aLNum[__privateGet2(this, _idxToken)]);
        }
        return false;
    }
  }
  throw "[endif]\u304C\u306A\u3044\u307E\u307E\u30B9\u30AF\u30EA\u30D7\u30C8\u7D42\u7AEF\u3067\u3059";
};
_call = new WeakSet();
call_fn = function(hArg) {
  if (!argChk_Boolean(hArg, "count", false))
    __privateMethod2(this, _eraseKidoku, eraseKidoku_fn).call(this);
  const { fn } = hArg;
  if (fn)
    __privateGet2(this, _cnvSnPath).call(this, fn);
  __privateMethod2(this, _callSub, callSub_fn).call(this, { ":hEvt1Time": __privateGet2(this, _evtMng6).popLocalEvts(), ":hMp": this.val.cloneMp() });
  if (argChk_Boolean(hArg, "clear_local_event", false))
    this.hTag.clear_event({});
  __privateMethod2(this, _jumpWork, jumpWork_fn).call(this, fn, hArg.label);
  return true;
};
_callSub = new WeakSet();
callSub_fn = function(csa) {
  __privateGet2(this, _script).aLNum[__privateGet2(this, _idxToken)] = __privateGet2(this, _lineNum);
  if (!__privateGet2(this, _resvToken)) {
    csa[":resvToken"] = "";
    __privateMethod2(this, _clearResvToken, clearResvToken_fn).call(this);
  }
  __privateGet2(this, _aCallStk).push(new CallStack(__privateGet2(this, _scriptFn), __privateGet2(this, _idxToken), csa));
  __privateGet2(this, _aIfStk).unshift(-1);
};
_jump = new WeakSet();
jump_fn = function(hArg) {
  if (!argChk_Boolean(hArg, "count", true))
    __privateMethod2(this, _eraseKidoku, eraseKidoku_fn).call(this);
  __privateGet2(this, _aIfStk)[0] = -1;
  __privateMethod2(this, _jumpWork, jumpWork_fn).call(this, hArg.fn, hArg.label);
  return true;
};
_page = new WeakSet();
page_fn = function(hArg) {
  if (__privateGet2(this, _posAPageLog) === -1)
    return false;
  if (argChk_Boolean(hArg, "clear", false)) {
    __privateSet2(this, _aPageLog, []);
    __privateSet2(this, _posAPageLog, -1);
    return false;
  }
  const { to } = hArg;
  if (!to)
    throw "clear\u304Bto\u306F\u5FC5\u9808\u3067\u3059";
  const oldPos = __privateGet2(this, _posAPageLog);
  switch (to) {
    case "prev":
      if (__privateGet2(this, _posAPageLog) > 0)
        --__privateWrapper2(this, _posAPageLog)._;
      break;
    case "next":
      const len = __privateGet2(this, _aPageLog).length;
      if (__privateGet2(this, _posAPageLog) < len - 1)
        ++__privateWrapper2(this, _posAPageLog)._;
      break;
    default:
      throw `\u5C5E\u6027to\u300C${to}\u300D\u306F\u7570\u5E38\u3067\u3059`;
  }
  if (oldPos === __privateGet2(this, _posAPageLog))
    return false;
  const o = __privateGet2(this, _aPageLog)[__privateGet2(this, _posAPageLog)];
  const { fn, idx } = __privateMethod2(this, _nowScrIdx, nowScrIdx_fn).call(this);
  if (o.key === idx + ":" + fn)
    return false;
  return __privateMethod2(this, _loadFromMark, loadFromMark_fn).call(this, { fn: o.retFn, index: o.retIdx }, o.retMark);
};
_pop_stack = new WeakSet();
pop_stack_fn = function(hArg) {
  if (argChk_Boolean(hArg, "clear", false))
    __privateSet2(this, _aCallStk, []);
  else if (!__privateGet2(this, _aCallStk).pop())
    throw "[pop_stack] \u30B9\u30BF\u30C3\u30AF\u304C\u7A7A\u3067\u3059";
  __privateMethod2(this, _clearResvToken, clearResvToken_fn).call(this);
  __privateSet2(this, _aIfStk, [-1]);
  this.val.setMp({});
  return false;
};
_return = new WeakSet();
return_fn = function() {
  const cs = __privateGet2(this, _aCallStk).pop();
  if (!cs)
    throw "[return] \u30B9\u30BF\u30C3\u30AF\u304C\u7A7A\u3067\u3059";
  const csa = cs.csArg;
  __privateGet2(this, _aIfStk).shift();
  const hMp = csa[":hMp"];
  if (hMp)
    this.val.setMp(hMp);
  const after_token = csa[":resvToken"];
  if (after_token)
    this.nextToken = () => {
      __privateMethod2(this, _clearResvToken, clearResvToken_fn).call(this);
      return after_token;
    };
  else
    __privateMethod2(this, _clearResvToken, clearResvToken_fn).call(this);
  if (csa[":hEvt1Time"])
    __privateGet2(this, _evtMng6).pushLocalEvts(csa[":hEvt1Time"]);
  if (cs.fn in __privateGet2(this, _hScript)) {
    __privateMethod2(this, _jump_light, jump_light_fn).call(this, cs);
    return false;
  }
  __privateMethod2(this, _jumpWork, jumpWork_fn).call(this, cs.fn, "", cs.idx);
  return true;
};
_resvToken = new WeakMap();
_clearResvToken = new WeakSet();
clearResvToken_fn = function() {
  __privateSet2(this, _resvToken, "");
  this.nextToken = __privateMethod2(this, _nextToken_Proc, nextToken_Proc_fn);
};
_skipLabel = new WeakMap();
_jumpWork = new WeakSet();
jumpWork_fn = function(fn = "", label = "", idx = 0) {
  if (!fn && !label)
    this.main.errScript("[jump\u7CFB] fn\u307E\u305F\u306Flabel\u306F\u5FC5\u9808\u3067\u3059");
  if (label) {
    if (label.charAt(0) !== "*")
      this.main.errScript("[jump\u7CFB] label\u306F*\u3067\u59CB\u307E\u308A\u307E\u3059");
    __privateSet2(this, _skipLabel, label);
    if (__privateGet2(this, _skipLabel).slice(0, 2) !== "**")
      __privateSet2(this, _idxToken, idx);
  } else {
    __privateSet2(this, _skipLabel, "");
    __privateSet2(this, _idxToken, idx);
  }
  if (!fn) {
    this.analyzeInit();
    return;
  }
  const full_path = __privateGet2(this, _cnvSnPath).call(this, fn);
  if (fn === __privateGet2(this, _scriptFn)) {
    this.analyzeInit();
    return;
  }
  __privateSet2(this, _scriptFn, fn);
  const st = __privateGet2(this, _hScript)[__privateGet2(this, _scriptFn)];
  if (st) {
    __privateSet2(this, _script, st);
    this.analyzeInit();
    return;
  }
  new Loader().add({ name: __privateGet2(this, _scriptFn), url: full_path }).use((res, next) => {
    try {
      res.data = this.sys.decStr(res.extension, res.data);
    } catch (e) {
      this.main.errScript(`[jump\u7CFB]sn\u30ED\u30FC\u30C9\u5931\u6557\u3067\u3059 fn:${res.name} ${e}`, false);
    }
    next == null ? void 0 : next();
  }).load((_ldr, hRes) => {
    this.nextToken = __privateMethod2(this, _nextToken_Proc, nextToken_Proc_fn);
    __privateSet2(this, _lineNum, 1);
    __privateMethod2(this, _resolveScript, resolveScript_fn).call(this, hRes[fn].data);
    this.hTag.record_place({});
    this.main.resume(() => this.analyzeInit());
  });
  this.main.stop();
};
_nextToken_Proc = new WeakSet();
nextToken_Proc_fn = function() {
  var _a3, _b3;
  if (__privateMethod2(this, _errOverScr, errOverScr_fn).call(this))
    return "";
  __privateMethod2(this, _recordKidoku, recordKidoku_fn).call(this);
  (_a3 = __privateGet2(this, _script).aLNum)[_b3 = __privateGet2(this, _idxToken)] || (_a3[_b3] = __privateGet2(this, _lineNum));
  const token = __privateGet2(this, _script).aToken[__privateGet2(this, _idxToken)];
  __privateGet2(this, _dbgToken).call(this, token);
  ++__privateWrapper2(this, _idxToken)._;
  return token;
};
_dbgToken = new WeakMap();
_errOverScr = new WeakSet();
errOverScr_fn = function() {
  if (__privateGet2(this, _idxToken) < __privateGet2(this, _script).len)
    return false;
  this.main.errScript("\u30B9\u30AF\u30EA\u30D7\u30C8\u7D42\u7AEF\u3067\u3059");
  return true;
};
_REG_NONAME_LABEL = new WeakMap();
_REG_TOKEN_MACRO_BEGIN = new WeakMap();
_REG_TOKEN_MACRO_END = new WeakMap();
_REG_TAG_LET_ML = new WeakMap();
_REG_TAG_ENDLET_ML = new WeakMap();
_seekScript = new WeakSet();
seekScript_fn = function(st, inMacro, ln, skipLabel, idx) {
  var _a3, _b3, _c3, _d2, _e;
  const len = st.aToken.length;
  if (!skipLabel) {
    if (__privateMethod2(this, _errOverScr, errOverScr_fn).call(this))
      return { idx, ln };
    if (!st.aLNum[idx]) {
      ln = 1;
      for (let j2 = 0; j2 < idx; ++j2) {
        (_a3 = st.aLNum)[j2] || (_a3[j2] = ln);
        const tkn = st.aToken[j2];
        if (tkn.charCodeAt(0) === 10)
          ln += tkn.length;
        else
          ln += ((_b3 = tkn.match(/\n/g)) != null ? _b3 : []).length;
      }
      st.aLNum[idx] = ln;
    } else
      ln = st.aLNum[idx];
    return { idx, ln };
  }
  st.aLNum[0] = 1;
  const a_skipLabel = skipLabel.match(__privateGet2(this, _REG_NONAME_LABEL));
  if (a_skipLabel) {
    skipLabel = a_skipLabel[1];
    let i2 = idx;
    switch (a_skipLabel[2]) {
      case "before":
        while (st.aToken[--i2] !== skipLabel) {
          if (i2 === 0)
            DebugMng.myTrace("[jump\u7CFB \u7121\u540D\u30E9\u30D9\u30EBbefore] " + ln + "\u884C\u76EE\u4EE5\u524D\u3067" + (inMacro ? "\u30DE\u30AF\u30ED\u5185\u306B" : "") + "\u30E9\u30D9\u30EB\u3010" + skipLabel + "\u3011\u304C\u3042\u308A\u307E\u305B\u3093", "ET");
          if (inMacro && st.aToken[i2].search(__privateGet2(this, _REG_TOKEN_MACRO_BEGIN)) > -1)
            DebugMng.myTrace("[jump\u7CFB \u7121\u540D\u30E9\u30D9\u30EBbefore] \u30DE\u30AF\u30ED\u5185\u306B\u30E9\u30D9\u30EB\u3010" + skipLabel + "\u3011\u304C\u3042\u308A\u307E\u305B\u3093", "ET");
        }
        return { idx: i2 + 1, ln: st.aLNum[i2] };
      case "after":
        while (st.aToken[++i2] !== skipLabel) {
          if (i2 === len)
            DebugMng.myTrace("[jump\u7CFB \u7121\u540D\u30E9\u30D9\u30EBafter] " + ln + "\u884C\u76EE\u4EE5\u5F8C\u3067\u30DE\u30AF\u30ED\u5185\u306B\u30E9\u30D9\u30EB\u3010" + skipLabel + "\u3011\u304C\u3042\u308A\u307E\u305B\u3093", "ET");
          if (st.aToken[i2].search(__privateGet2(this, _REG_TOKEN_MACRO_END)) > -1)
            DebugMng.myTrace("[jump\u7CFB \u7121\u540D\u30E9\u30D9\u30EBafter] " + ln + "\u884C\u76EE\u4EE5\u5F8C\u3067\u30DE\u30AF\u30ED\u5185\u306B\u30E9\u30D9\u30EB\u3010" + skipLabel + "\u3011\u304C\u3042\u308A\u307E\u305B\u3093", "ET");
        }
        return { idx: i2 + 1, ln: st.aLNum[i2] };
      default:
        DebugMng.myTrace("[jump\u7CFB] \u7121\u540D\u30E9\u30D9\u30EB\u6307\u5B9A\u3010label=" + skipLabel + "\u3011\u304C\u9593\u9055\u3063\u3066\u3044\u307E\u3059", "ET");
    }
  }
  ln = 1;
  const reLabel = new RegExp("^" + skipLabel.replaceAll("*", "\\*") + "(?:\\s|;|\\[|$)");
  let in_let_ml = false;
  for (let i2 = 0; i2 < len; ++i2) {
    (_c3 = st.aLNum)[i2] || (_c3[i2] = ln);
    const tkn = st.aToken[i2];
    if (in_let_ml) {
      __privateGet2(this, _REG_TAG_ENDLET_ML).lastIndex = 0;
      if (__privateGet2(this, _REG_TAG_ENDLET_ML).test(tkn))
        in_let_ml = false;
      else
        ln += ((_d2 = tkn.match(/\n/g)) != null ? _d2 : []).length;
      continue;
    }
    const uc = tkn.charCodeAt(0);
    if (uc === 10) {
      ln += tkn.length;
      continue;
    }
    if (uc === 42) {
      if (tkn.search(reLabel) > -1)
        return { idx: i2 + 1, ln };
      continue;
    }
    if (uc !== 91)
      continue;
    ln += ((_e = tkn.match(/\n/g)) != null ? _e : []).length;
    __privateGet2(this, _REG_TAG_LET_ML).lastIndex = 0;
    if (__privateGet2(this, _REG_TAG_LET_ML).test(tkn))
      in_let_ml = true;
  }
  if (in_let_ml)
    throw "[let_ml]\u306E\u7D42\u7AEF\u30FB[endlet_ml]\u304C\u3042\u308A\u307E\u305B\u3093";
  DebugMng.myTrace(`[jump\u7CFB] \u30E9\u30D9\u30EB\u3010${skipLabel}\u3011\u304C\u3042\u308A\u307E\u305B\u3093`, "ET");
  throw "Dummy";
};
_hScript = new WeakMap();
_resolveScript = new WeakSet();
resolveScript_fn = function(txt) {
  const v2 = __privateGet2(this, _grm).matchToken(txt.replace(/(\r\n|\r)/g, "\n"));
  for (let i2 = v2.length - 1; i2 >= 0; --i2) {
    const e = v2[i2];
    __privateGet2(this, _REG_TAG_LET_ML).lastIndex = 0;
    if (__privateGet2(this, _REG_TAG_LET_ML).test(e)) {
      const idx = e.indexOf("]") + 1;
      if (idx === 0)
        throw "[let_ml]\u3067\u9589\u3058\u308B\u3010]\u3011\u304C\u3042\u308A\u307E\u305B\u3093";
      const a2 = e.slice(0, idx);
      const b2 = e.slice(idx);
      v2.splice(i2, 1, a2, b2);
    }
  }
  __privateSet2(this, _script, { aToken: v2, len: v2.length, aLNum: [] });
  let mes = "";
  try {
    mes = "ScriptIterator.replaceScriptChar2macro";
    __privateGet2(this, _grm).replaceScr_C2M_And_let_ml(__privateGet2(this, _script));
    mes = "ScriptIterator.replaceScript_Wildcard";
    __privateGet2(this, _replaceScript_Wildcard).call(this);
  } catch (err) {
    if (err instanceof Error) {
      const e = err;
      mes += `\u4F8B\u5916 mes=${e.message}(${e.name})`;
    } else {
      mes = err;
    }
    this.main.errScript(mes, false);
  }
  __privateGet2(this, _hScript)[__privateGet2(this, _scriptFn)] = __privateGet2(this, _script);
  this.val.loadScrWork(__privateGet2(this, _scriptFn));
};
_jump_light = new WeakSet();
jump_light_fn = function(cs) {
  __privateSet2(this, _scriptFn, cs.fn);
  __privateSet2(this, _idxToken, cs.idx);
  const st = __privateGet2(this, _hScript)[__privateGet2(this, _scriptFn)];
  if (st)
    __privateSet2(this, _script, st);
  __privateSet2(this, _lineNum, __privateGet2(this, _script).aLNum[cs.idx]);
};
_REG_WILDCARD = new WeakMap();
_REG_WILDCARD2 = new WeakMap();
_replaceScript_Wildcard = new WeakMap();
_recordKidoku = new WeakSet();
recordKidoku_fn = function() {
  const areas = this.val.getAreaKidoku(__privateGet2(this, _scriptFn));
  if (!areas)
    throw `recordKidoku fn:'${__privateGet2(this, _scriptFn)}' (areas === null)`;
  if (__privateGet2(this, _aCallStk).length > 0) {
    areas.record(__privateGet2(this, _idxToken));
    return;
  }
  __privateSet2(this, _isKidoku, areas.search(__privateGet2(this, _idxToken)));
  this.val.setVal_Nochk("tmp", "const.sn.isKidoku", __privateGet2(this, _isKidoku));
  if (__privateGet2(this, _isKidoku))
    return;
  areas.record(__privateGet2(this, _idxToken));
};
_isKidoku = new WeakMap();
_eraseKidoku = new WeakSet();
eraseKidoku_fn = function() {
  var _a3;
  (_a3 = this.val.getAreaKidoku(__privateGet2(this, _scriptFn))) == null ? void 0 : _a3.erase(__privateGet2(this, _idxToken));
  __privateSet2(this, _isKidoku, false);
};
_bracket2macro = new WeakSet();
bracket2macro_fn = function(hArg) {
  __privateGet2(this, _grm).bracket2macro(hArg, __privateGet2(this, _script), __privateGet2(this, _idxToken));
  return false;
};
_char2macro = new WeakSet();
char2macro_fn = function(hArg) {
  __privateGet2(this, _grm).char2macro(hArg, this.hTag, __privateGet2(this, _script), __privateGet2(this, _idxToken));
  return false;
};
_macro = new WeakSet();
macro_fn = function(hArg) {
  var _a3, _b3, _c3;
  const { name: name2 } = hArg;
  if (!name2)
    throw "name\u306F\u5FC5\u9808\u3067\u3059";
  if (name2 in this.hTag)
    throw `[${name2}]\u306F\u30BF\u30B0\u304B\u3059\u3067\u306B\u5B9A\u7FA9\u6E08\u307F\u306E\u30DE\u30AF\u30ED\u3067\u3059`;
  const ln = __privateGet2(this, _lineNum);
  const cs = new CallStack(__privateGet2(this, _scriptFn), __privateGet2(this, _idxToken));
  __privateSet2(this, _strStepin, __privateGet2(this, _strStepin) + ("|" + name2));
  __privateSet2(this, _REGSTEPIN, new RegExp(`\\[(${__privateGet2(this, _strStepin)})\\b`));
  this.hTag[name2] = (hArgM) => {
    hArgM.design_unit = hArg.design_unit;
    __privateMethod2(this, _callSub, callSub_fn).call(this, __spreadProps(__spreadValues({}, hArgM), { ":hMp": this.val.cloneMp() }));
    this.val.setMp(hArgM);
    this.val.setVal_Nochk("mp", "const.sn.macro", JSON.stringify(hArg));
    this.val.setVal_Nochk("mp", "const.sn.me_call_scriptFn", __privateGet2(this, _scriptFn));
    __privateSet2(this, _lineNum, ln);
    __privateMethod2(this, _jump_light, jump_light_fn).call(this, cs);
    return false;
  };
  for (; __privateGet2(this, _idxToken) < __privateGet2(this, _script).len; ++__privateWrapper2(this, _idxToken)._) {
    (_a3 = __privateGet2(this, _script).aLNum)[_b3 = __privateGet2(this, _idxToken)] || (_a3[_b3] = __privateGet2(this, _lineNum));
    const token = __privateGet2(this, _script).aToken[__privateGet2(this, _idxToken)];
    if (token.search(__privateGet2(this, _REG_TOKEN_MACRO_END)) > -1) {
      ++__privateWrapper2(this, _idxToken)._;
      return false;
    }
    const uc = token.charCodeAt(0);
    if (uc === 10)
      __privateSet2(this, _lineNum, __privateGet2(this, _lineNum) + token.length);
    else if (uc === 91)
      __privateSet2(this, _lineNum, __privateGet2(this, _lineNum) + ((_c3 = token.match(/\n/g)) != null ? _c3 : []).length);
  }
  throw `\u30DE\u30AF\u30ED[${name2}]\u5B9A\u7FA9\u306E\u7D42\u7AEF\u30FB[endmacro]\u304C\u3042\u308A\u307E\u305B\u3093`;
};
_strStepin = new WeakMap();
_REGSTEPIN = new WeakMap();
_load = new WeakSet();
load_fn = function(hArg) {
  if (!("place" in hArg))
    throw "place\u306F\u5FC5\u9808\u3067\u3059";
  const place = Number(hArg.place);
  if ("fn" in hArg !== "label" in hArg)
    throw "fn\u3068label\u306F\u30BB\u30C3\u30C8\u3067\u6307\u5B9A\u3057\u3066\u4E0B\u3055\u3044";
  const mark = this.val.getMark(place);
  if (!mark)
    throw `place\u3010${place}\u3011\u306F\u5B58\u5728\u3057\u307E\u305B\u3093`;
  return __privateMethod2(this, _loadFromMark, loadFromMark_fn).call(this, hArg, mark);
};
_loadFromMark = new WeakSet();
loadFromMark_fn = function(hArg, mark, reload_sound = true) {
  this.hTag.clear_event({});
  this.val.mark2save(mark);
  this.val.setMp({});
  __privateGet2(this, _layMng).recText("", true);
  if (reload_sound)
    this.sndMng.playLoopFromSaveObj();
  if (argChk_Boolean(hArg, "do_rec", true))
    __privateSet2(this, _mark, {
      hSave: this.val.cloneSave(),
      hPages: __spreadValues({}, mark.hPages),
      aIfStk: [...mark.aIfStk]
    });
  const o = {
    enabled: this.val.getVal("save:const.sn.autowc.enabled"),
    text: this.val.getVal("save:const.sn.autowc.text"),
    time: Number(this.val.getVal("save:const.sn.autowc.time"))
  };
  this.hTag.autowc(o);
  const fn = String(this.val.getVal("save:const.sn.scriptFn"));
  const idx = Number(this.val.getVal("save:const.sn.scriptIdx"));
  __privateSet2(this, _aIfStk, [...__privateGet2(this, _mark).aIfStk]);
  __privateSet2(this, _aCallStk, []);
  __privateGet2(this, _layMng).cover(true);
  __privateGet2(this, _layMng).stopAllTw();
  if ("index" in hArg) {
    __privateGet2(this, _layMng).playback(__privateGet2(this, _mark).hPages, () => {
      var _a3, _b3;
      __privateGet2(this, _layMng).cover(false);
      __privateSet2(this, _skip4page, true);
      __privateMethod2(this, _jumpWork, jumpWork_fn).call(this, (_a3 = hArg.fn) != null ? _a3 : fn, "", (_b3 = hArg.index) != null ? _b3 : idx);
    });
    return true;
  }
  delete __privateGet2(this, _hScript)[fn];
  __privateGet2(this, _layMng).playback(__privateGet2(this, _mark).hPages, "label" in hArg ? () => {
    __privateGet2(this, _layMng).cover(false);
    __privateSet2(this, _scriptFn, fn);
    __privateSet2(this, _idxToken, idx);
    this.hTag.call({ fn: hArg.fn, label: hArg.label });
  } : () => {
    __privateGet2(this, _layMng).cover(false);
    __privateMethod2(this, _jumpWork, jumpWork_fn).call(this, fn, "", idx);
  });
  return true;
};
_skip4page = new WeakMap();
_reload_script = new WeakSet();
reload_script_fn = function(hArg) {
  const mark = this.val.getMark(0);
  delete __privateGet2(this, _hScript)[getFn(mark.hSave["const.sn.scriptFn"])];
  hArg.do_rec = false;
  return __privateMethod2(this, _loadFromMark, loadFromMark_fn).call(this, hArg, mark, false);
};
_mark = new WeakMap();
_record_place = new WeakSet();
record_place_fn = function() {
  if (this.main.isDestroyed())
    return false;
  const { fn, idx } = __privateMethod2(this, _nowScrIdx, nowScrIdx_fn).call(this);
  this.val.setVal_Nochk("save", "const.sn.scriptFn", fn);
  this.val.setVal_Nochk("save", "const.sn.scriptIdx", idx);
  __privateSet2(this, _mark, {
    hSave: this.val.cloneSave(),
    hPages: __privateGet2(this, _layMng).record(),
    aIfStk: __privateGet2(this, _aIfStk).slice(__privateGet2(this, _aCallStk).length)
  });
  return false;
};
_nowScrIdx = new WeakSet();
nowScrIdx_fn = function() {
  const len = __privateGet2(this, _aCallStk).length;
  if (len === 0)
    return {
      fn: __privateGet2(this, _scriptFn),
      idx: __privateGet2(this, _idxToken)
    };
  const cs = __privateGet2(this, _aCallStk)[0];
  return {
    fn: cs.fn,
    idx: cs.idx
  };
};
_save = new WeakSet();
save_fn = function(hArg) {
  var _a3;
  if (!("place" in hArg))
    throw "place\u306F\u5FC5\u9808\u3067\u3059";
  const place = Number(hArg.place);
  delete hArg[":\u30BF\u30B0\u540D"];
  delete hArg.place;
  hArg.text = ((_a3 = hArg.text) != null ? _a3 : "").replace(/^(<br\/>)+/, "");
  __privateGet2(this, _mark).json = hArg;
  this.val.setMark(place, __privateGet2(this, _mark));
  const now_sp = Number(this.val.getVal("sys:const.sn.save.place"));
  if (place === now_sp)
    this.val.setVal_Nochk("sys", "const.sn.save.place", now_sp + 1);
  return false;
};
_aPageLog = new WeakMap();
_posAPageLog = new WeakMap();
__privateAdd2(ScriptIterator, _REG4CODE_FN, /(.+)\/crypto_prj\/([^\/]+)\/[^\.]+(\.\w+)/);
__privateAdd2(ScriptIterator, _hFn2hLineBP, {});
__privateAdd2(ScriptIterator, _hFuncBP, {});
class Main {
  constructor(sys) {
    __privateAdd2(this, _init);
    __privateAdd2(this, _runAnalyze);
    __privateAdd2(this, _cfg3, void 0);
    __privateAdd2(this, _appPixi3, void 0);
    __privateAdd2(this, _hTag2, void 0);
    __privateAdd2(this, _val2, void 0);
    __privateAdd2(this, _prpPrs, void 0);
    __privateAdd2(this, _sndMng, void 0);
    __privateAdd2(this, _scrItr2, void 0);
    __privateAdd2(this, _dbgMng, void 0);
    __privateAdd2(this, _layMng2, void 0);
    __privateAdd2(this, _evtMng7, void 0);
    __privateAdd2(this, _fncNext, void 0);
    __privateAdd2(this, _alzTagArg2, void 0);
    __privateAdd2(this, _inited, void 0);
    __privateAdd2(this, _SN_ID, void 0);
    __privateAdd2(this, _fncTicker2, void 0);
    __privateAdd2(this, _fncresume, void 0);
    __privateAdd2(this, _isLoop, void 0);
    __privateAdd2(this, _destroyed, void 0);
    __privateAdd2(this, _clone_cvs, void 0);
    this.sys = sys;
    __privateSet2(this, _hTag2, /* @__PURE__ */ Object.create(null));
    __privateSet2(this, _fncNext, () => {
    });
    __privateSet2(this, _alzTagArg2, new AnalyzeTagArg());
    __privateSet2(this, _inited, false);
    __privateSet2(this, _SN_ID, "skynovel");
    __privateSet2(this, _fncTicker2, () => __privateGet2(this, _fncNext).call(this));
    __privateSet2(this, _fncresume, (fnc = __privateMethod2(this, _runAnalyze, runAnalyze_fn)) => {
      if (__privateGet2(this, _destroyed))
        return;
      __privateGet2(this, _layMng2).clearBreak();
      __privateSet2(this, _fncNext, fnc);
      this.resume = (fnc2 = __privateMethod2(this, _runAnalyze, runAnalyze_fn)) => {
        __privateSet2(this, _fncNext, fnc2);
      };
      __privateGet2(this, _scrItr2).noticeBreak(false);
    });
    this.resume = __privateGet2(this, _fncresume);
    this.stop = () => {
      __privateSet2(this, _fncNext, () => {
      });
      this.resume = __privateGet2(this, _fncresume);
      __privateGet2(this, _scrItr2).noticeBreak(true);
    };
    __privateSet2(this, _isLoop, true);
    __privateSet2(this, _destroyed, false);
    this.isDestroyed = () => __privateGet2(this, _destroyed);
    skipHello();
    Config.generate(sys).then((c2) => __privateSet2(this, _cfg3, c2)).then(() => __privateMethod2(this, _init, init_fn).call(this)).catch((e) => console.error(`load err fn:prj.json e:%o`, e));
  }
  errScript(mes, isThrow = true) {
    this.stop();
    DebugMng.myTrace(mes);
    if (CmnLib.debugLog)
      console.log("\u{1F35C} SKYNovel err!");
    if (isThrow)
      throw mes;
  }
  resumeByJumpOrCall(hArg) {
    var _a3, _b3;
    if (hArg.url) {
      globalThis.open(hArg.url);
      return;
    }
    __privateGet2(this, _val2).setVal_Nochk("tmp", "sn.eventArg", (_a3 = hArg.arg) != null ? _a3 : "");
    __privateGet2(this, _val2).setVal_Nochk("tmp", "sn.eventLabel", (_b3 = hArg.label) != null ? _b3 : "");
    if (argChk_Boolean(hArg, "call", false)) {
      __privateGet2(this, _scrItr2).subIdxToken();
      this.resume(() => __privateGet2(this, _hTag2).call(hArg));
    } else {
      __privateGet2(this, _hTag2).clear_event({});
      this.resume(() => __privateGet2(this, _hTag2).jump(hArg));
    }
  }
  setLoop(isLoop, mes = "") {
    if (__privateSet2(this, _isLoop, isLoop))
      this.resume();
    else
      this.stop();
    this.sys.setTitleInfo(mes ? ` -- ${mes}\u4E2D` : "");
  }
  fire(KEY, e) {
    __privateGet2(this, _evtMng7).fire(KEY, e);
  }
  async destroy(ms_late = 0) {
    if (__privateGet2(this, _destroyed))
      return;
    __privateSet2(this, _destroyed, true);
    if (!__privateGet2(this, _inited))
      return;
    this.stop();
    __privateSet2(this, _isLoop, false);
    await __privateGet2(this, _layMng2).before_destroy();
    if (ms_late > 0)
      await new Promise((r2) => setTimeout(r2, ms_late));
    __privateSet2(this, _hTag2, {});
    __privateGet2(this, _evtMng7).destroy();
    __privateGet2(this, _scrItr2).destroy();
    __privateGet2(this, _layMng2).destroy();
    __privateGet2(this, _dbgMng).destroy();
    __privateGet2(this, _appPixi3).ticker.remove(__privateGet2(this, _fncTicker2));
    if (__privateGet2(this, _clone_cvs) && __privateGet2(this, _appPixi3)) {
      document.body.insertBefore(__privateGet2(this, _clone_cvs), __privateGet2(this, _appPixi3).view);
    }
    clearTextureCache();
    __privateGet2(this, _appPixi3).destroy(true);
  }
}
_cfg3 = new WeakMap();
_appPixi3 = new WeakMap();
_hTag2 = new WeakMap();
_val2 = new WeakMap();
_prpPrs = new WeakMap();
_sndMng = new WeakMap();
_scrItr2 = new WeakMap();
_dbgMng = new WeakMap();
_layMng2 = new WeakMap();
_evtMng7 = new WeakMap();
_fncNext = new WeakMap();
_alzTagArg2 = new WeakMap();
_inited = new WeakMap();
_SN_ID = new WeakMap();
_init = new WeakSet();
init_fn = async function() {
  var _a3, _b3, _c3;
  const cc = (_a3 = document.createElement("canvas")) == null ? void 0 : _a3.getContext("2d");
  if (!cc)
    throw "argChk_Color err";
  CmnLib.cc4ColorName = cc;
  const hApp = {
    width: __privateGet2(this, _cfg3).oCfg.window.width,
    height: __privateGet2(this, _cfg3).oCfg.window.height,
    backgroundColor: parseColor(String(__privateGet2(this, _cfg3).oCfg.init.bg_color)),
    resolution: (_b3 = globalThis.devicePixelRatio) != null ? _b3 : 1,
    autoResize: true
  };
  const cvs = document.getElementById(__privateGet2(this, _SN_ID));
  if (cvs) {
    __privateSet2(this, _clone_cvs, cvs.cloneNode(true));
    __privateGet2(this, _clone_cvs).id = __privateGet2(this, _SN_ID);
    hApp.view = cvs;
  }
  __privateSet2(this, _appPixi3, new Application(hApp));
  if (!cvs) {
    document.body.appendChild(__privateGet2(this, _appPixi3).view);
    __privateGet2(this, _appPixi3).view.id = __privateGet2(this, _SN_ID);
  }
  __privateSet2(this, _val2, new Variable(__privateGet2(this, _cfg3), __privateGet2(this, _hTag2)));
  __privateSet2(this, _prpPrs, new PropParser(__privateGet2(this, _val2), (_c3 = __privateGet2(this, _cfg3).oCfg.init.escape) != null ? _c3 : "\\"));
  await Promise.allSettled(this.sys.init(__privateGet2(this, _hTag2), __privateGet2(this, _appPixi3), __privateGet2(this, _val2), this));
  __privateGet2(this, _hTag2).title({ text: __privateGet2(this, _cfg3).oCfg.book.title || "SKYNovel" });
  __privateSet2(this, _sndMng, new SoundMng(__privateGet2(this, _cfg3), __privateGet2(this, _hTag2), __privateGet2(this, _val2), this, this.sys));
  __privateSet2(this, _scrItr2, new ScriptIterator(__privateGet2(this, _cfg3), __privateGet2(this, _hTag2), this, __privateGet2(this, _val2), __privateGet2(this, _alzTagArg2), () => __privateMethod2(this, _runAnalyze, runAnalyze_fn).call(this), __privateGet2(this, _prpPrs), __privateGet2(this, _sndMng), this.sys));
  __privateSet2(this, _dbgMng, new DebugMng(this.sys, __privateGet2(this, _hTag2), __privateGet2(this, _scrItr2)));
  __privateSet2(this, _layMng2, new LayerMng(__privateGet2(this, _cfg3), __privateGet2(this, _hTag2), __privateGet2(this, _appPixi3), __privateGet2(this, _val2), this, __privateGet2(this, _scrItr2), this.sys, __privateGet2(this, _sndMng), __privateGet2(this, _alzTagArg2), __privateGet2(this, _prpPrs)));
  __privateSet2(this, _evtMng7, new EventMng(__privateGet2(this, _cfg3), __privateGet2(this, _hTag2), __privateGet2(this, _appPixi3), this, __privateGet2(this, _layMng2), __privateGet2(this, _val2), __privateGet2(this, _sndMng), __privateGet2(this, _scrItr2), this.sys));
  __privateGet2(this, _appPixi3).ticker.add(__privateGet2(this, _fncTicker2));
  this.resumeByJumpOrCall({ fn: "main" });
  __privateSet2(this, _inited, true);
};
_fncTicker2 = new WeakMap();
_fncresume = new WeakMap();
_isLoop = new WeakMap();
_runAnalyze = new WeakSet();
runAnalyze_fn = function() {
  var _a3;
  while (__privateGet2(this, _isLoop)) {
    let token = __privateGet2(this, _scrItr2).nextToken();
    if (!token)
      break;
    const uc = token.charCodeAt(0);
    if (uc === 9)
      continue;
    if (uc === 10) {
      __privateGet2(this, _scrItr2).addLineNum(token.length);
      continue;
    }
    if (uc === 91) {
      if (__privateGet2(this, _scrItr2).isBreak(token))
        return;
      try {
        const cl = ((_a3 = token.match(/\n/g)) != null ? _a3 : []).length;
        if (cl > 0)
          __privateGet2(this, _scrItr2).addLineNum(cl);
        if (__privateGet2(this, _scrItr2).\u30BF\u30B0\u89E3\u6790(token)) {
          this.stop();
          break;
        }
        continue;
      } catch (err) {
        if (err instanceof Error) {
          const e = err;
          let mes = `\u30BF\u30B0\u89E3\u6790\u4E2D\u4F8B\u5916 mes=${e.message}(${e.name})`;
          mes = `[${tagToken2Name(token)}]` + mes;
          this.errScript(mes, false);
        } else
          this.errScript(String(err), false);
        return;
      }
    }
    if (uc === 38) {
      try {
        if (token.slice(-1) !== "&") {
          if (__privateGet2(this, _scrItr2).isBreak(token))
            return;
          const o = splitAmpersand(token.slice(1));
          o.name = __privateGet2(this, _prpPrs).getValAmpersand(o.name);
          o.text = String(__privateGet2(this, _prpPrs).parse(o.text));
          __privateGet2(this, _hTag2).let(o);
          continue;
        }
        if (token.charAt(1) === "&")
          throw new Error("\u300C&\u8868\u793A&\u300D\u66F8\u5F0F\u3067\u306F\u300C&\u300D\u6307\u5B9A\u304C\u4E0D\u8981\u3067\u3059");
        token = String(__privateGet2(this, _prpPrs).parse(token.slice(1, -1)));
      } catch (err) {
        this.errScript(err instanceof Error ? `& \u5909\u6570\u64CD\u4F5C\u30FB\u8868\u793A mes=${err.message}(${err.name})` : err, false);
        return;
      }
    } else if (uc === 59)
      continue;
    else if (uc === 42 && token.length > 1)
      continue;
    try {
      const tl = __privateGet2(this, _layMng2).currentTxtlayForeNeedErr;
      tl.tagCh(token);
    } catch (err) {
      this.errScript(err instanceof Error ? `\u6587\u5B57\u8868\u793A mes=${err.message}(${err.name})` : err, false);
      return;
    }
  }
};
_destroyed = new WeakMap();
_clone_cvs = new WeakMap();
var assign = make_assign();
var create$1 = make_create();
var trim$1 = make_trim();
var Global$5 = typeof window !== "undefined" ? window : commonjsGlobal;
var util$6 = {
  assign,
  create: create$1,
  trim: trim$1,
  bind: bind$1,
  slice: slice$1,
  each: each$7,
  map,
  pluck: pluck$1,
  isList: isList$1,
  isFunction: isFunction$1,
  isObject: isObject$1,
  Global: Global$5
};
function make_assign() {
  if (Object.assign) {
    return Object.assign;
  } else {
    return function shimAssign(obj, props1, props2, etc) {
      for (var i2 = 1; i2 < arguments.length; i2++) {
        each$7(Object(arguments[i2]), function(val, key) {
          obj[key] = val;
        });
      }
      return obj;
    };
  }
}
function make_create() {
  if (Object.create) {
    return function create2(obj, assignProps1, assignProps2, etc) {
      var assignArgsList = slice$1(arguments, 1);
      return assign.apply(this, [Object.create(obj)].concat(assignArgsList));
    };
  } else {
    let F2 = function() {
    };
    return function create2(obj, assignProps1, assignProps2, etc) {
      var assignArgsList = slice$1(arguments, 1);
      F2.prototype = obj;
      return assign.apply(this, [new F2()].concat(assignArgsList));
    };
  }
}
function make_trim() {
  if (String.prototype.trim) {
    return function trim2(str2) {
      return String.prototype.trim.call(str2);
    };
  } else {
    return function trim2(str2) {
      return str2.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, "");
    };
  }
}
function bind$1(obj, fn) {
  return function() {
    return fn.apply(obj, Array.prototype.slice.call(arguments, 0));
  };
}
function slice$1(arr, index) {
  return Array.prototype.slice.call(arr, index || 0);
}
function each$7(obj, fn) {
  pluck$1(obj, function(val, key) {
    fn(val, key);
    return false;
  });
}
function map(obj, fn) {
  var res = isList$1(obj) ? [] : {};
  pluck$1(obj, function(v2, k) {
    res[k] = fn(v2, k);
    return false;
  });
  return res;
}
function pluck$1(obj, fn) {
  if (isList$1(obj)) {
    for (var i2 = 0; i2 < obj.length; i2++) {
      if (fn(obj[i2], i2)) {
        return obj[i2];
      }
    }
  } else {
    for (var key in obj) {
      if (obj.hasOwnProperty(key)) {
        if (fn(obj[key], key)) {
          return obj[key];
        }
      }
    }
  }
}
function isList$1(val) {
  return val != null && typeof val != "function" && typeof val.length == "number";
}
function isFunction$1(val) {
  return val && {}.toString.call(val) === "[object Function]";
}
function isObject$1(val) {
  return val && {}.toString.call(val) === "[object Object]";
}
var util$5 = util$6;
var slice = util$5.slice;
var pluck = util$5.pluck;
var each$6 = util$5.each;
var bind = util$5.bind;
var create = util$5.create;
var isList = util$5.isList;
var isFunction = util$5.isFunction;
var isObject = util$5.isObject;
var storeEngine = {
  createStore
};
var storeAPI = {
  version: "2.0.12",
  enabled: false,
  get: function(key, optionalDefaultValue) {
    var data = this.storage.read(this._namespacePrefix + key);
    return this._deserialize(data, optionalDefaultValue);
  },
  set: function(key, value) {
    if (value === void 0) {
      return this.remove(key);
    }
    this.storage.write(this._namespacePrefix + key, this._serialize(value));
    return value;
  },
  remove: function(key) {
    this.storage.remove(this._namespacePrefix + key);
  },
  each: function(callback) {
    var self2 = this;
    this.storage.each(function(val, namespacedKey) {
      callback.call(self2, self2._deserialize(val), (namespacedKey || "").replace(self2._namespaceRegexp, ""));
    });
  },
  clearAll: function() {
    this.storage.clearAll();
  },
  hasNamespace: function(namespace) {
    return this._namespacePrefix == "__storejs_" + namespace + "_";
  },
  createStore: function() {
    return createStore.apply(this, arguments);
  },
  addPlugin: function(plugin) {
    this._addPlugin(plugin);
  },
  namespace: function(namespace) {
    return createStore(this.storage, this.plugins, namespace);
  }
};
function _warn() {
  var _console = typeof console == "undefined" ? null : console;
  if (!_console) {
    return;
  }
  var fn = _console.warn ? _console.warn : _console.log;
  fn.apply(_console, arguments);
}
function createStore(storages2, plugins2, namespace) {
  if (!namespace) {
    namespace = "";
  }
  if (storages2 && !isList(storages2)) {
    storages2 = [storages2];
  }
  if (plugins2 && !isList(plugins2)) {
    plugins2 = [plugins2];
  }
  var namespacePrefix = namespace ? "__storejs_" + namespace + "_" : "";
  var namespaceRegexp = namespace ? new RegExp("^" + namespacePrefix) : null;
  var legalNamespaces = /^[a-zA-Z0-9_\-]*$/;
  if (!legalNamespaces.test(namespace)) {
    throw new Error("store.js namespaces can only have alphanumerics + underscores and dashes");
  }
  var _privateStoreProps = {
    _namespacePrefix: namespacePrefix,
    _namespaceRegexp: namespaceRegexp,
    _testStorage: function(storage) {
      try {
        var testStr = "__storejs__test__";
        storage.write(testStr, testStr);
        var ok = storage.read(testStr) === testStr;
        storage.remove(testStr);
        return ok;
      } catch (e) {
        return false;
      }
    },
    _assignPluginFnProp: function(pluginFnProp, propName) {
      var oldFn = this[propName];
      this[propName] = function pluginFn() {
        var args = slice(arguments, 0);
        var self2 = this;
        function super_fn() {
          if (!oldFn) {
            return;
          }
          each$6(arguments, function(arg, i2) {
            args[i2] = arg;
          });
          return oldFn.apply(self2, args);
        }
        var newFnArgs = [super_fn].concat(args);
        return pluginFnProp.apply(self2, newFnArgs);
      };
    },
    _serialize: function(obj) {
      return JSON.stringify(obj);
    },
    _deserialize: function(strVal, defaultVal) {
      if (!strVal) {
        return defaultVal;
      }
      var val = "";
      try {
        val = JSON.parse(strVal);
      } catch (e) {
        val = strVal;
      }
      return val !== void 0 ? val : defaultVal;
    },
    _addStorage: function(storage) {
      if (this.enabled) {
        return;
      }
      if (this._testStorage(storage)) {
        this.storage = storage;
        this.enabled = true;
      }
    },
    _addPlugin: function(plugin) {
      var self2 = this;
      if (isList(plugin)) {
        each$6(plugin, function(plugin2) {
          self2._addPlugin(plugin2);
        });
        return;
      }
      var seenPlugin = pluck(this.plugins, function(seenPlugin2) {
        return plugin === seenPlugin2;
      });
      if (seenPlugin) {
        return;
      }
      this.plugins.push(plugin);
      if (!isFunction(plugin)) {
        throw new Error("Plugins must be function values that return objects");
      }
      var pluginProperties = plugin.call(this);
      if (!isObject(pluginProperties)) {
        throw new Error("Plugins must return an object of function properties");
      }
      each$6(pluginProperties, function(pluginFnProp, propName) {
        if (!isFunction(pluginFnProp)) {
          throw new Error("Bad plugin property: " + propName + " from plugin " + plugin.name + ". Plugins should only return functions.");
        }
        self2._assignPluginFnProp(pluginFnProp, propName);
      });
    },
    addStorage: function(storage) {
      _warn("store.addStorage(storage) is deprecated. Use createStore([storages])");
      this._addStorage(storage);
    }
  };
  var store = create(_privateStoreProps, storeAPI, {
    plugins: []
  });
  store.raw = {};
  each$6(store, function(prop, propName) {
    if (isFunction(prop)) {
      store.raw[propName] = bind(store, prop);
    }
  });
  each$6(storages2, function(storage) {
    store._addStorage(storage);
  });
  each$6(plugins2, function(plugin) {
    store._addPlugin(plugin);
  });
  return store;
}
var util$4 = util$6;
var Global$4 = util$4.Global;
var localStorage_1 = {
  name: "localStorage",
  read: read$5,
  write: write$5,
  each: each$5,
  remove: remove$5,
  clearAll: clearAll$5
};
function localStorage() {
  return Global$4.localStorage;
}
function read$5(key) {
  return localStorage().getItem(key);
}
function write$5(key, data) {
  return localStorage().setItem(key, data);
}
function each$5(fn) {
  for (var i2 = localStorage().length - 1; i2 >= 0; i2--) {
    var key = localStorage().key(i2);
    fn(read$5(key), key);
  }
}
function remove$5(key) {
  return localStorage().removeItem(key);
}
function clearAll$5() {
  return localStorage().clear();
}
var util$3 = util$6;
var Global$3 = util$3.Global;
var oldFFGlobalStorage = {
  name: "oldFF-globalStorage",
  read: read$4,
  write: write$4,
  each: each$4,
  remove: remove$4,
  clearAll: clearAll$4
};
var globalStorage = Global$3.globalStorage;
function read$4(key) {
  return globalStorage[key];
}
function write$4(key, data) {
  globalStorage[key] = data;
}
function each$4(fn) {
  for (var i2 = globalStorage.length - 1; i2 >= 0; i2--) {
    var key = globalStorage.key(i2);
    fn(globalStorage[key], key);
  }
}
function remove$4(key) {
  return globalStorage.removeItem(key);
}
function clearAll$4() {
  each$4(function(key, _2) {
    delete globalStorage[key];
  });
}
var util$2 = util$6;
var Global$2 = util$2.Global;
var oldIEUserDataStorage = {
  name: "oldIE-userDataStorage",
  write: write$3,
  read: read$3,
  each: each$3,
  remove: remove$3,
  clearAll: clearAll$3
};
var storageName = "storejs";
var doc$1 = Global$2.document;
var _withStorageEl = _makeIEStorageElFunction();
var disable = (Global$2.navigator ? Global$2.navigator.userAgent : "").match(/ (MSIE 8|MSIE 9|MSIE 10)\./);
function write$3(unfixedKey, data) {
  if (disable) {
    return;
  }
  var fixedKey = fixKey(unfixedKey);
  _withStorageEl(function(storageEl) {
    storageEl.setAttribute(fixedKey, data);
    storageEl.save(storageName);
  });
}
function read$3(unfixedKey) {
  if (disable) {
    return;
  }
  var fixedKey = fixKey(unfixedKey);
  var res = null;
  _withStorageEl(function(storageEl) {
    res = storageEl.getAttribute(fixedKey);
  });
  return res;
}
function each$3(callback) {
  _withStorageEl(function(storageEl) {
    var attributes = storageEl.XMLDocument.documentElement.attributes;
    for (var i2 = attributes.length - 1; i2 >= 0; i2--) {
      var attr = attributes[i2];
      callback(storageEl.getAttribute(attr.name), attr.name);
    }
  });
}
function remove$3(unfixedKey) {
  var fixedKey = fixKey(unfixedKey);
  _withStorageEl(function(storageEl) {
    storageEl.removeAttribute(fixedKey);
    storageEl.save(storageName);
  });
}
function clearAll$3() {
  _withStorageEl(function(storageEl) {
    var attributes = storageEl.XMLDocument.documentElement.attributes;
    storageEl.load(storageName);
    for (var i2 = attributes.length - 1; i2 >= 0; i2--) {
      storageEl.removeAttribute(attributes[i2].name);
    }
    storageEl.save(storageName);
  });
}
var forbiddenCharsRegex = new RegExp("[!\"#$%&'()*+,/\\\\:;<=>?@[\\]^`{|}~]", "g");
function fixKey(key) {
  return key.replace(/^\d/, "___$&").replace(forbiddenCharsRegex, "___");
}
function _makeIEStorageElFunction() {
  if (!doc$1 || !doc$1.documentElement || !doc$1.documentElement.addBehavior) {
    return null;
  }
  var scriptTag = "script", storageOwner, storageContainer, storageEl;
  try {
    storageContainer = new ActiveXObject("htmlfile");
    storageContainer.open();
    storageContainer.write("<" + scriptTag + ">document.w=window</" + scriptTag + '><iframe src="/favicon.ico"></iframe>');
    storageContainer.close();
    storageOwner = storageContainer.w.frames[0].document;
    storageEl = storageOwner.createElement("div");
  } catch (e) {
    storageEl = doc$1.createElement("div");
    storageOwner = doc$1.body;
  }
  return function(storeFunction) {
    var args = [].slice.call(arguments, 0);
    args.unshift(storageEl);
    storageOwner.appendChild(storageEl);
    storageEl.addBehavior("#default#userData");
    storageEl.load(storageName);
    storeFunction.apply(this, args);
    storageOwner.removeChild(storageEl);
    return;
  };
}
var util$1 = util$6;
var Global$1 = util$1.Global;
var trim = util$1.trim;
var cookieStorage = {
  name: "cookieStorage",
  read: read$2,
  write: write$2,
  each: each$2,
  remove: remove$2,
  clearAll: clearAll$2
};
var doc = Global$1.document;
function read$2(key) {
  if (!key || !_has(key)) {
    return null;
  }
  var regexpStr = "(?:^|.*;\\s*)" + escape(key).replace(/[\-\.\+\*]/g, "\\$&") + "\\s*\\=\\s*((?:[^;](?!;))*[^;]?).*";
  return unescape(doc.cookie.replace(new RegExp(regexpStr), "$1"));
}
function each$2(callback) {
  var cookies = doc.cookie.split(/; ?/g);
  for (var i2 = cookies.length - 1; i2 >= 0; i2--) {
    if (!trim(cookies[i2])) {
      continue;
    }
    var kvp = cookies[i2].split("=");
    var key = unescape(kvp[0]);
    var val = unescape(kvp[1]);
    callback(val, key);
  }
}
function write$2(key, data) {
  if (!key) {
    return;
  }
  doc.cookie = escape(key) + "=" + escape(data) + "; expires=Tue, 19 Jan 2038 03:14:07 GMT; path=/";
}
function remove$2(key) {
  if (!key || !_has(key)) {
    return;
  }
  doc.cookie = escape(key) + "=; expires=Thu, 01 Jan 1970 00:00:00 GMT; path=/";
}
function clearAll$2() {
  each$2(function(_2, key) {
    remove$2(key);
  });
}
function _has(key) {
  return new RegExp("(?:^|;\\s*)" + escape(key).replace(/[\-\.\+\*]/g, "\\$&") + "\\s*\\=").test(doc.cookie);
}
var util = util$6;
var Global = util.Global;
var sessionStorage_1 = {
  name: "sessionStorage",
  read: read$1,
  write: write$1,
  each: each$1,
  remove: remove$1,
  clearAll: clearAll$1
};
function sessionStorage$1() {
  return Global.sessionStorage;
}
function read$1(key) {
  return sessionStorage$1().getItem(key);
}
function write$1(key, data) {
  return sessionStorage$1().setItem(key, data);
}
function each$1(fn) {
  for (var i2 = sessionStorage$1().length - 1; i2 >= 0; i2--) {
    var key = sessionStorage$1().key(i2);
    fn(read$1(key), key);
  }
}
function remove$1(key) {
  return sessionStorage$1().removeItem(key);
}
function clearAll$1() {
  return sessionStorage$1().clear();
}
var memoryStorage_1 = {
  name: "memoryStorage",
  read,
  write,
  each,
  remove,
  clearAll
};
var memoryStorage = {};
function read(key) {
  return memoryStorage[key];
}
function write(key, data) {
  memoryStorage[key] = data;
}
function each(callback) {
  for (var key in memoryStorage) {
    if (memoryStorage.hasOwnProperty(key)) {
      callback(memoryStorage[key], key);
    }
  }
}
function remove(key) {
  delete memoryStorage[key];
}
function clearAll(key) {
  memoryStorage = {};
}
var all = [
  localStorage_1,
  oldFFGlobalStorage,
  oldIEUserDataStorage,
  cookieStorage,
  sessionStorage_1,
  memoryStorage_1
];
if (typeof JSON !== "object") {
  JSON = {};
}
(function() {
  var rx_one = /^[\],:{}\s]*$/;
  var rx_two = /\\(?:["\\\/bfnrt]|u[0-9a-fA-F]{4})/g;
  var rx_three = /"[^"\\\n\r]*"|true|false|null|-?\d+(?:\.\d*)?(?:[eE][+\-]?\d+)?/g;
  var rx_four = /(?:^|:|,)(?:\s*\[)+/g;
  var rx_escapable = /[\\"\u0000-\u001f\u007f-\u009f\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g;
  var rx_dangerous = /[\u0000\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g;
  function f(n) {
    return n < 10 ? "0" + n : n;
  }
  function this_value() {
    return this.valueOf();
  }
  if (typeof Date.prototype.toJSON !== "function") {
    Date.prototype.toJSON = function() {
      return isFinite(this.valueOf()) ? this.getUTCFullYear() + "-" + f(this.getUTCMonth() + 1) + "-" + f(this.getUTCDate()) + "T" + f(this.getUTCHours()) + ":" + f(this.getUTCMinutes()) + ":" + f(this.getUTCSeconds()) + "Z" : null;
    };
    Boolean.prototype.toJSON = this_value;
    Number.prototype.toJSON = this_value;
    String.prototype.toJSON = this_value;
  }
  var gap;
  var indent;
  var meta;
  var rep;
  function quote(string) {
    rx_escapable.lastIndex = 0;
    return rx_escapable.test(string) ? '"' + string.replace(rx_escapable, function(a2) {
      var c2 = meta[a2];
      return typeof c2 === "string" ? c2 : "\\u" + ("0000" + a2.charCodeAt(0).toString(16)).slice(-4);
    }) + '"' : '"' + string + '"';
  }
  function str(key, holder) {
    var i2;
    var k;
    var v2;
    var length2;
    var mind = gap;
    var partial;
    var value = holder[key];
    if (value && typeof value === "object" && typeof value.toJSON === "function") {
      value = value.toJSON(key);
    }
    if (typeof rep === "function") {
      value = rep.call(holder, key, value);
    }
    switch (typeof value) {
      case "string":
        return quote(value);
      case "number":
        return isFinite(value) ? String(value) : "null";
      case "boolean":
      case "null":
        return String(value);
      case "object":
        if (!value) {
          return "null";
        }
        gap += indent;
        partial = [];
        if (Object.prototype.toString.apply(value) === "[object Array]") {
          length2 = value.length;
          for (i2 = 0; i2 < length2; i2 += 1) {
            partial[i2] = str(i2, value) || "null";
          }
          v2 = partial.length === 0 ? "[]" : gap ? "[\n" + gap + partial.join(",\n" + gap) + "\n" + mind + "]" : "[" + partial.join(",") + "]";
          gap = mind;
          return v2;
        }
        if (rep && typeof rep === "object") {
          length2 = rep.length;
          for (i2 = 0; i2 < length2; i2 += 1) {
            if (typeof rep[i2] === "string") {
              k = rep[i2];
              v2 = str(k, value);
              if (v2) {
                partial.push(quote(k) + (gap ? ": " : ":") + v2);
              }
            }
          }
        } else {
          for (k in value) {
            if (Object.prototype.hasOwnProperty.call(value, k)) {
              v2 = str(k, value);
              if (v2) {
                partial.push(quote(k) + (gap ? ": " : ":") + v2);
              }
            }
          }
        }
        v2 = partial.length === 0 ? "{}" : gap ? "{\n" + gap + partial.join(",\n" + gap) + "\n" + mind + "}" : "{" + partial.join(",") + "}";
        gap = mind;
        return v2;
    }
  }
  if (typeof JSON.stringify !== "function") {
    meta = {
      "\b": "\\b",
      "	": "\\t",
      "\n": "\\n",
      "\f": "\\f",
      "\r": "\\r",
      '"': '\\"',
      "\\": "\\\\"
    };
    JSON.stringify = function(value, replacer, space) {
      var i2;
      gap = "";
      indent = "";
      if (typeof space === "number") {
        for (i2 = 0; i2 < space; i2 += 1) {
          indent += " ";
        }
      } else if (typeof space === "string") {
        indent = space;
      }
      rep = replacer;
      if (replacer && typeof replacer !== "function" && (typeof replacer !== "object" || typeof replacer.length !== "number")) {
        throw new Error("JSON.stringify");
      }
      return str("", { "": value });
    };
  }
  if (typeof JSON.parse !== "function") {
    JSON.parse = function(text, reviver) {
      var j;
      function walk(holder, key) {
        var k;
        var v2;
        var value = holder[key];
        if (value && typeof value === "object") {
          for (k in value) {
            if (Object.prototype.hasOwnProperty.call(value, k)) {
              v2 = walk(value, k);
              if (v2 !== void 0) {
                value[k] = v2;
              } else {
                delete value[k];
              }
            }
          }
        }
        return reviver.call(holder, key, value);
      }
      text = String(text);
      rx_dangerous.lastIndex = 0;
      if (rx_dangerous.test(text)) {
        text = text.replace(rx_dangerous, function(a2) {
          return "\\u" + ("0000" + a2.charCodeAt(0).toString(16)).slice(-4);
        });
      }
      if (rx_one.test(text.replace(rx_two, "@").replace(rx_three, "]").replace(rx_four, ""))) {
        j = eval("(" + text + ")");
        return typeof reviver === "function" ? walk({ "": j }, "") : j;
      }
      throw new SyntaxError("JSON.parse");
    };
  }
})();
var json2 = json2Plugin;
function json2Plugin() {
  return {};
}
var engine = storeEngine;
var storages = all;
var plugins = [json2];
var store_legacy = engine.createStore(storages, plugins);
/*!
devtools-detect
https://github.com/sindresorhus/devtools-detect
By Sindre Sorhus
MIT License
*/
const devtools = {
  isOpen: false,
  orientation: void 0
};
const threshold = 160;
const emitEvent = (isOpen, orientation) => {
  globalThis.dispatchEvent(new globalThis.CustomEvent("devtoolschange", {
    detail: {
      isOpen,
      orientation
    }
  }));
};
const main = ({ emitEvents = true } = {}) => {
  const widthThreshold = globalThis.outerWidth - globalThis.innerWidth > threshold;
  const heightThreshold = globalThis.outerHeight - globalThis.innerHeight > threshold;
  const orientation = widthThreshold ? "vertical" : "horizontal";
  if (!(heightThreshold && widthThreshold) && (globalThis.Firebug && globalThis.Firebug.chrome && globalThis.Firebug.chrome.isInitialized || widthThreshold || heightThreshold)) {
    if ((!devtools.isOpen || devtools.orientation !== orientation) && emitEvents) {
      emitEvent(true, orientation);
    }
    devtools.isOpen = true;
    devtools.orientation = orientation;
  } else {
    if (devtools.isOpen && emitEvents) {
      emitEvent(false, void 0);
    }
    devtools.isOpen = false;
    devtools.orientation = void 0;
  }
};
main({ emitEvents: false });
setInterval(main, 500);
class SysWeb extends SysBase {
  constructor(hPlg = {}, arg = { cur: "prj/", crypto: false, dip: "" }) {
    super(hPlg, arg);
    __privateAdd2(this, _path_base, void 0);
    __privateAdd2(this, _now_prj, void 0);
    __privateAdd2(this, _main2, void 0);
    __privateAdd2(this, _hAppendFile, void 0);
    __privateSet2(this, _path_base, "");
    __privateSet2(this, _now_prj, ":");
    this.run = async () => {
      if (__privateGet2(this, _main2)) {
        const ms_late = 10;
        __privateGet2(this, _main2).destroy(ms_late);
        await new Promise((r2) => setTimeout(r2, ms_late));
      }
      __privateSet2(this, _main2, new Main(this));
    };
    __privateSet2(this, _main2, void 0);
    this.pathBaseCnvSnPath4Dbg = "${pathbase}/";
    this._export = () => {
      (async () => {
        const s2 = JSON.stringify({
          "sys": this.data.sys,
          "mark": this.data.mark,
          "kidoku": this.data.kidoku
        });
        const s22 = this.crypto ? await this.enc(s2) : s2;
        const blob = new Blob([s22], { "type": "text/json" });
        const a3 = document.createElement("a");
        a3.href = URL.createObjectURL(blob);
        a3.download = (this.crypto ? "" : "no_crypto_") + this.cfg.getNs() + getDateStr("-", "_", "") + ".swpd";
        a3.click();
        if (CmnLib.debugLog)
          console.log("\u30D7\u30EC\u30A4\u30C7\u30FC\u30BF\u3092\u30A8\u30AF\u30B9\u30DD\u30FC\u30C8\u3057\u307E\u3057\u305F");
        setTimeout(() => this.fire("sn:exported", new Event("click")), 10);
      })();
      return false;
    };
    this._import = () => {
      new Promise((rs, rj) => {
        const inp = document.createElement("input");
        inp.type = "file";
        inp.accept = ".swpd, text/plain";
        inp.onchange = () => {
          if (inp.files)
            rs(inp.files[0].path);
          else
            rj();
        };
        inp.click();
      }).then((file) => new Promise((rs) => {
        const rd = new FileReader();
        rd.readAsText(file);
        rd.onload = () => rs(rd.result);
      })).then(async (s2) => {
        const o = JSON.parse(this.crypto ? this.decStr("json", s2) : s2);
        if (!o.sys || !o.mark || !o.kidoku)
          throw new Error("\u7570\u5E38\u306A\u30D7\u30EC\u30A4\u30C7\u30FC\u30BF\u3067\u3059");
        if (o.sys[SysBase.VALNM_CFG_NS] !== this.cfg.oCfg.save_ns) {
          console.error(`\u5225\u306E\u30B2\u30FC\u30E0\u3010\u30D7\u30ED\u30B8\u30A7\u30AF\u30C8\u540D=${o.sys[SysBase.VALNM_CFG_NS]}\u3011\u306E\u30D7\u30EC\u30A4\u30C7\u30FC\u30BF\u3067\u3059`);
          return;
        }
        this.data.sys = o.sys;
        this.data.mark = o.mark;
        this.data.kidoku = o.kidoku;
        this.flush();
        this.val.updateData(o);
        if (CmnLib.debugLog)
          console.log("\u30D7\u30EC\u30A4\u30C7\u30FC\u30BF\u3092\u30A4\u30F3\u30DD\u30FC\u30C8\u3057\u307E\u3057\u305F");
        this.fire("sn:imported", new Event("click"));
      }).catch((e) => console.error(`\u7570\u5E38\u306A\u30D7\u30EC\u30A4\u30C7\u30FC\u30BF\u3067\u3059 ${e.message}`));
      return false;
    };
    this.navigate_to = (hArg) => {
      const { url: url2 } = hArg;
      if (!url2)
        throw "[navigate_to] url\u306F\u5FC5\u9808\u3067\u3059";
      globalThis.open(url2, "_blank");
      return false;
    };
    __privateSet2(this, _hAppendFile, {});
    const a2 = arg.cur.split("/");
    __privateSet2(this, _path_base, a2.length > 2 ? a2.slice(0, -2).join("/") + "/" : "");
    globalThis.onload = async () => this.loaded(hPlg, arg);
  }
  async loaded(hPlg, arg) {
    await super.loaded(hPlg, arg);
    document.querySelectorAll("[data-prj]").forEach((v2) => {
      const elm = v2.attributes.getNamedItem("data-prj");
      if (elm)
        v2.addEventListener("click", () => this.runSN(elm.value), { passive: true });
    });
    document.querySelectorAll("[data-reload]").forEach((v2) => v2.addEventListener("click", () => this.run(), { passive: true }));
    if (arg.dip)
      CmnLib.hDip = JSON.parse(arg.dip);
    const sp = new URLSearchParams(location.search);
    const dip = sp.get("dip");
    if (dip)
      CmnLib.hDip = __spreadValues(__spreadValues({}, CmnLib.hDip), JSON.parse(dip.replaceAll(`%2C`, ",")));
    if (!argChk_Boolean(CmnLib.hDip, "oninit_run", true))
      return;
    if (argChk_Boolean(CmnLib.hDip, "dbg", false)) {
      CmnLib.isDbg = true;
      this.fetch = (url2) => fetch(url2, { mode: "cors" });
    }
    this.extPort = argChk_Num(CmnLib.hDip, "port", this.extPort);
    const cur = sp.get("cur");
    if (cur)
      arg.cur = __privateGet2(this, _path_base) + cur + "/";
    this.run();
  }
  runSN(prj) {
    this.arg.cur = __privateGet2(this, _path_base) + prj + "/";
    if (__privateGet2(this, _now_prj) === this.arg.cur)
      return;
    __privateSet2(this, _now_prj, this.arg.cur);
    this.run();
  }
  stop() {
    if (!__privateGet2(this, _main2))
      return;
    __privateGet2(this, _main2).destroy();
    __privateSet2(this, _main2, void 0);
  }
  async loadPath(hPathFn2Exts, cfg) {
    await super.loadPath(hPathFn2Exts, cfg);
    const fn = this.arg.cur + "path.json";
    const res = await fetch(fn);
    if (!res.ok)
      throw Error(res.statusText);
    const src = await res.text();
    const oJs = JSON.parse(this.decStr(fn, src));
    for (const nm in oJs) {
      const h2 = hPathFn2Exts[nm] = oJs[nm];
      for (const ext in h2)
        if (ext !== ":cnt")
          h2[ext] = this.arg.cur + h2[ext];
    }
  }
  initVal(data, hTmp, comp) {
    const hn = encodeURIComponent(document.location.hostname);
    hTmp["const.sn.isDebugger"] = hn === "localhost" || hn === "127.0.0.1";
    const ns = this.cfg.getNs();
    this.flush = this.crypto ? async () => {
      store_legacy.set(ns + "sys_", this.enc(JSON.stringify(this.data.sys)));
      store_legacy.set(ns + "mark_", this.enc(JSON.stringify(this.data.mark)));
      store_legacy.set(ns + "kidoku_", this.enc(JSON.stringify(this.data.kidoku)));
    } : () => {
      store_legacy.set(ns + "sys", this.data.sys);
      store_legacy.set(ns + "mark", this.data.mark);
      store_legacy.set(ns + "kidoku", this.data.kidoku);
    };
    const nm = ns + (this.arg.crypto ? "sys_" : "sys");
    if (hTmp["const.sn.isFirstBoot"] = store_legacy.get(nm) === void 0) {
      this.data.sys = data.sys;
      this.data.mark = data.mark;
      this.data.kidoku = data.kidoku;
      this.flush();
      comp(this.data);
      return;
    }
    if (!this.crypto) {
      this.data.sys = store_legacy.get(ns + "sys");
      this.data.mark = store_legacy.get(ns + "mark");
      this.data.kidoku = store_legacy.get(ns + "kidoku");
      comp(this.data);
      return;
    }
    let mes = "";
    try {
      mes = "sys";
      this.data.sys = JSON.parse(this.decStr("json", store_legacy.get(ns + "sys_")));
      mes += Number(this.val.getVal("sys:TextLayer.Back.Alpha", 1));
      mes = "mark";
      this.data.mark = JSON.parse(this.decStr("json", store_legacy.get(ns + "mark_")));
      mes = "kidoku";
      this.data.kidoku = JSON.parse(this.decStr("json", store_legacy.get(ns + "kidoku_")));
    } catch (e) {
      console.error(`\u30BB\u30FC\u30D6\u30C7\u30FC\u30BF\uFF08${mes}\uFF09\u304C\u58CA\u308C\u3066\u3044\u307E\u3059\u3002\u4E00\u5EA6\u30AF\u30EA\u30A2\u3059\u308B\u5FC5\u8981\u304C\u3042\u308A\u307E\u3059 %o`, e);
    }
    comp(this.data);
  }
  init(hTag, appPixi, val, main2) {
    super.init(hTag, appPixi, val, main2);
    const pCvs = appPixi.view.parentElement;
    if ("requestFullscreen" in document.body) {
      this.tglFlscr_sub = () => this.isFullScr ? document.exitFullscreen() : pCvs.requestFullscreen();
      document.addEventListener("fullscreenchange", () => this.isFullScr = Boolean(document.fullscreenElement));
    } else {
      const doc2 = document;
      this.tglFlscr_sub = () => this.isFullScr ? doc2.webkitCancelFullScreen() : pCvs.webkitRequestFullscreen();
      document.addEventListener("fullscreenchange", () => this.isFullScr = Boolean(doc2.webkitFullscreenElement));
    }
    if (!this.cfg.oCfg.debug.devtool)
      window.addEventListener("devtoolschange", (e) => {
        if (!e.detail.isOpen)
          return;
        console.error(`DevTool\u306F\u7981\u6B62\u3055\u308C\u3066\u3044\u307E\u3059\u3002\u8A31\u53EF\u3059\u308B\u5834\u5408\u306F\u3010\u30D7\u30ED\u30B8\u30A7\u30AF\u30C8\u8A2D\u5B9A\u3011\u306E\u3010devtool\u3011\u3092ON\u306B\u3002`);
        main2.destroy();
      }, { once: true, passive: true });
    return [];
  }
  cvsResize() {
    super.cvsResize();
    if (this.isFullScr) {
      const s2 = this.appPixi.view.style;
      s2.width = s2.height = "";
    }
  }
  titleSub(txt) {
    document.title = txt;
    document.querySelectorAll("[data-title]").forEach((v2) => v2.textContent = txt);
  }
  async savePic(fn, data_url) {
    const a2 = document.createElement("a");
    a2.href = data_url;
    a2.download = fn;
    a2.click();
    if (CmnLib.debugLog)
      console.log("\u753B\u50CF\u30D5\u30A1\u30A4\u30EB\u3092\u30C0\u30A6\u30F3\u30ED\u30FC\u30C9\u3057\u307E\u3059");
  }
  async appendFile(path, data, _callback) {
    var _a3;
    const txt = ((_a3 = __privateGet2(this, _hAppendFile)[path]) != null ? _a3 : "") + data;
    __privateGet2(this, _hAppendFile)[path] = txt;
    const blob = new Blob([txt], { "type": "text/json" });
    const a2 = document.createElement("a");
    a2.href = URL.createObjectURL(blob);
    a2.download = path;
    a2.click();
  }
}
_path_base = new WeakMap();
_now_prj = new WeakMap();
_main2 = new WeakMap();
_hAppendFile = new WeakMap();
export { CmnLib, Layer, SysWeb, argChk_Boolean, argChk_Num };
//# sourceMappingURL=web.js.map
